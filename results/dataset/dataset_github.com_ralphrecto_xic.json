[
    {
        "repository": "github.com/ralphrecto/xic",
        "file": "src/polyglot/util/OptimalCodeWriter.java",
        "code": "    @Override\n    void selfFormat(SearchState s) {\n        boolean backtrack = false;\n        boolean findminovf = false;\n        boolean assignment;\n        if (s.forward) {\n            if (s.findminovf) {\n                // First, check the cache if we have done tried the given\n                // search parameters.  If so, just return the memoized\n                // result and backtrack.\n                if (cache.containsKey(s.maxbrs)) {\n                    Map<Integer, Pair<Integer, ConsList<Boolean>>> brCache =\n                            cache.get(s.maxbrs);\n                    if (brCache.containsKey(s.pos)) {\n                        Pair<Integer, ConsList<Boolean>> result =\n                                brCache.get(s.pos);\n                        s.forward = false;\n                        s.minovf = result.part1();\n                        s.afterBrkAssignment = result.part2();\n                        return;\n                    }\n                }\n            }\n            // First, check if there is already an assignment for us.\n            if (s.afterBrkAssignment.length() > 0) {\n                // Just take the specified assignment.\n                assignment = s.afterBrkAssignment.elem;\n                s.afterBrkAssignment = s.afterBrkAssignment.next;\n            }\n            else if (canLeaveUnbroken(s.minbr, s.minbu)\n                    && s.pos + altlen <= s.rmargin) {\n                // This break can be left unbroken without causing immediate overflow.\n                assignment = false;\n                findminovf = true;\n            }\n            else if (canBreak(s.maxbr)) {\n                // This break must be broken.\n                // If not breaking causes immediate overflow, it is better to\n                // break now and possibly overflow later.\n                assignment = true;\n                findminovf = s.findminovf;\n            }\n            else if (canLeaveUnbroken(s.minbr, s.minbu)) {\n                // Overflow always happens, and we could not break.\n                assignment = false;\n                if (s.findminovf) {\n                    // If an earlier break is finding minimal overflow, punt to that break.\n                    backtrack = true;\n                    // Since we could not break, the amount of minimal overflow is by not breaking.\n                    s.minovf = s.pos + altlen - s.rmargin;\n                }\n            }\n            else throw new InternalCompilerError(\"Could not either break or not break.\"\n                    + this);\n        }\n        else {\n            // Later item failed to stay within width limit\n            // Plan to move forward for now.\n            // If this is impossible, later code will reset.\n            s.forward = true;\n            if (!s.brkAssignment.get(this) && canBreak(s.maxbr)) {\n                // We tried not breaking and did not work.\n                // Save later assignments that cause the overflow when not breaking.\n                minovf = s.minovf;\n                afterBrkAssignment = s.afterBrkAssignment;\n                s.afterBrkAssignment = ConsList.empty();\n                // Now we try breaking.\n                assignment = true;\n            }\n            else {\n                // We tried all options, and overflow always happens.\n                if (afterBrkAssignment != null) {\n                    // We tried both breaking and not breaking.\n                    if (afterBrkAssignment.length() > s.afterBrkAssignment.length()\n                            || afterBrkAssignment.length() == s.afterBrkAssignment.length()\n                                    && minovf <= s.minovf) {\n                        // Not breaking causes overflow later.\n                        //  or\n                        // Overflow at the same location,\n                        // but breaking does not cause less overflow.\n                        assignment = false;\n                        // Restore saved assignments.\n                        s.minovf = minovf;\n                        s.afterBrkAssignment = afterBrkAssignment;\n                    }\n                    else assignment = true;\n                }\n                else {\n                    // We did not save assignments.\n                    // If we can break, then we could not break, so we must break.\n                    // Otherwise, we must not break.\n                    assignment = canBreak(s.maxbr);\n                }\n                SearchState prev = s.prevBreak;\n                s.prevBreak = prev.prevBreak;\n                if (prev.findminovf) {\n                    // If an earlier break is finding minimal overflow, punt to that break.\n                    backtrack = true;\n                }\n                else {\n                    // All earlier breaks have tried their best job,\n                    // so we continue on with our best break assignment.\n                    s.findminovf = false;\n                }\n            }\n        }\n        if (backtrack) {\n            // Reset saved assignments.\n            afterBrkAssignment = null;\n            // Prepare best assignment causing minimal overflow for earlier break.\n            s.forward = false;\n            s.brkAssignment.remove(this);\n            s.afterBrkAssignment =\n                    ConsList.cons(assignment, s.afterBrkAssignment);\n\n            // Memoize overflow results before backtracking.\n            Map<Integer, Pair<Integer, ConsList<Boolean>>> brCache;\n            if (cache.containsKey(s.maxbr))\n                brCache = cache.get(s.maxbr);\n            else {\n                brCache = new HashMap<>();\n                cache.put(s.maxbrs, brCache);\n            }\n            Pair<Integer, ConsList<Boolean>> result =\n                    new Pair<>(s.minovf, s.afterBrkAssignment);\n            brCache.put(s.pos, result);\n        }\n        else {\n            if (findminovf) {\n                // Set backtracking point to this break.\n                s.it = this;\n                // Save provided information.\n                s.prevBreak = s.copy();\n                s.findminovf = true;\n                s.minovf = 0;\n            }\n            s.brkAssignment.put(this, assignment);\n            if (assignment) {\n                // Break is broken.\n                s.pos = s.lmargin + indent;\n                // Since we are breaking, all breaks of lower levels must also be broken.\n                if (s.minbr < level) s.minbr = level - 1;\n                // If this is a unified break, all unified breaks of our level must also be broken.\n                if (unified && s.minbu < level) s.minbu = level;\n                // The min break level of outer block must be at least this level.\n                if (s.minbo < level) s.minbo = level;\n            }\n            else {\n                // Break is not broken.\n                s.pos += altlen;\n                // Since we are not breaking, the max break level must be adjusted.\n                if (s.maxbr >= level) {\n                    if (unified) {\n                        // If this is a unified break, the max break level must be less than our level.\n                        s.maxbr = level - 1;\n                    }\n                    else {\n                        // Otherwise, the max break level must be at most our level.\n                        s.maxbr = level;\n                    }\n                }\n                // The max break level of inner block must be less than our level.\n                if (s.maxbi >= level) s.maxbi = level - 1;\n            }\n        }\n    }\n",
        "methodStartingLine": 719,
        "methodEndingLine": 884,
        "jml": "//@ requires n_ >= 0\n//@ requires alt_ != null"
    }
]