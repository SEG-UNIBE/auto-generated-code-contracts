{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/eracle/gap lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "2a24073f396cd22afd3261a4e6d1fe714e1c74b6"
        },
        "content": "/*\r\n *    This program is free software; you can redistribute it and/or modify\r\n *    it under the terms of the GNU General Public License as published by\r\n *    the Free Software Foundation; either version 2 of the License, or\r\n *    (at your option) any later version.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU General Public License\r\n *    along with this program; if not, write to the Free Software\r\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\r\n */\r\n\r\n/*\r\n *    Utils.java\r\n *    Copyright (C) 1999-2004 University of Waikato\r\n *\r\n */\r\n\r\npackage nz.ac.waikato.cs.weka;\r\n\r\nimport java.lang.Math;\r\nimport java.lang.reflect.Array;\r\nimport java.util.Properties;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.util.Random;\r\n\r\n/**\r\n * Class implementing some simple utility methods.\r\n *\r\n * @author Eibe Frank \r\n * @author Yong Wang \r\n * @author Len Trigg \r\n * @author Julien Prados\r\n * @version $Revision: 1.53 $\r\n */\r\npublic final class Utils {\r\n\r\n  /** The natural logarithm of 2. */\r\n  public static double log2 = Math.log(2);\r\n\r\n  /** The small deviation allowed in double comparisons */\r\n  public static double SMALL = 1e-6;\r\n\r\n  \r\n  /**\r\n   * Reads properties that inherit from three locations. Properties\r\n   * are first defined in the system resource location (i.e. in the\r\n   * CLASSPATH).  These default properties must exist. Properties\r\n   * defined in the users home directory (optional) override default\r\n   * settings. Properties defined in the current directory (optional)\r\n   * override all these settings.\r\n   *\r\n   * @param resourceName the location of the resource that should be\r\n   * loaded.  e.g.: \"weka/core/Utils.props\". (The use of hardcoded\r\n   * forward slashes here is OK - see\r\n   * jdk1.1/docs/guide/misc/resources.html) This routine will also\r\n   * look for the file (in this case) \"Utils.props\" in the users home\r\n   * directory and the current directory.\r\n   * @return the Properties\r\n   * @exception Exception if no default properties are defined, or if\r\n   * an error occurs reading the properties files.  \r\n   */\r\n  public static Properties readProperties(String resourceName)\r\n    throws Exception {\r\n\r\n    Properties defaultProps = new Properties();\r\n    try {\r\n      // Apparently hardcoded slashes are OK here\r\n      // jdk1.1/docs/guide/misc/resources.html\r\n      defaultProps.load(ClassLoader.getSystemResourceAsStream(resourceName));\r\n    } catch (Exception ex) {\r\n/*      throw new Exception(\"Problem reading default properties: \"\r\n\t+ ex.getMessage()); */\r\n      System.err.println(\"Warning, unable to load properties file from \"\r\n\t\t\t +\"system resource (Utils.java)\");\r\n    }\r\n\r\n    // Hardcoded slash is OK here\r\n    // eg: see jdk1.1/docs/guide/misc/resources.html\r\n    int slInd = resourceName.lastIndexOf('/');\r\n    if (slInd != -1) {\r\n      resourceName = resourceName.substring(slInd + 1);\r\n    }\r\n\r\n    // Allow a properties file in the home directory to override\r\n    Properties userProps = new Properties(defaultProps);    \r\n    File propFile = new File(System.getProperties().getProperty(\"user.home\")\r\n                             + File.separatorChar\r\n                             + resourceName);\r\n    if (propFile.exists()) {\r\n      try {\r\n        userProps.load(new FileInputStream(propFile));\r\n      } catch (Exception ex) {\r\n        throw new Exception(\"Problem reading user properties: \" + propFile);\r\n      }\r\n    }\r\n\r\n    // Allow a properties file in the current directory to override\r\n    Properties localProps = new Properties(userProps);\r\n    propFile = new File(resourceName);\r\n    if (propFile.exists()) {\r\n      try {\r\n        localProps.load(new FileInputStream(propFile));\r\n      } catch (Exception ex) {\r\n        throw new Exception(\"Problem reading local properties: \" + propFile);\r\n      }\r\n    }\r\n    \r\n    return localProps;\r\n  }\r\n\r\n  /**\r\n   * Returns the correlation coefficient of two double vectors.\r\n   *\r\n   * @param y1 double vector 1\r\n   * @param y2 double vector 2\r\n   * @param n the length of two double vectors\r\n   * @return the correlation coefficient\r\n   */\r\n  public static final double correlation(double y1[],double y2[],int n) {\r\n\r\n    int i;\r\n    double av1 = 0.0, av2 = 0.0, y11 = 0.0, y22 = 0.0, y12 = 0.0, c;\r\n    \r\n    if (n \u003c= 1) {\r\n      return 1.0;\r\n    }\r\n    for (i = 0; i \u003c n; i++) {\r\n      av1 += y1[i];\r\n      av2 += y2[i];\r\n    }\r\n    av1 /= (double) n;\r\n    av2 /= (double) n;\r\n    for (i = 0; i \u003c n; i++) {\r\n      y11 += (y1[i] - av1) * (y1[i] - av1);\r\n      y22 += (y2[i] - av2) * (y2[i] - av2);\r\n      y12 += (y1[i] - av1) * (y2[i] - av2);\r\n    }\r\n    if (y11 * y22 == 0.0) {\r\n      c=1.0;\r\n    } else {\r\n      c = y12 / Math.sqrt(Math.abs(y11 * y22));\r\n    }\r\n    \r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * Removes all occurrences of a string from another string.\r\n   *\r\n   * @param inString the string to remove substrings from.\r\n   * @param substring the substring to remove.\r\n   * @return the input string with occurrences of substring removed.\r\n   */\r\n  public static String removeSubstring(String inString, String substring) {\r\n\r\n    StringBuffer result = new StringBuffer();\r\n    int oldLoc = 0, loc = 0;\r\n    while ((loc = inString.indexOf(substring, oldLoc))!= -1) {\r\n      result.append(inString.substring(oldLoc, loc));\r\n      oldLoc = loc + substring.length();\r\n    }\r\n    result.append(inString.substring(oldLoc));\r\n    return result.toString();\r\n  }\r\n\r\n  /**\r\n   * Replaces with a new string, all occurrences of a string from \r\n   * another string.\r\n   *\r\n   * @param inString the string to replace substrings in.\r\n   * @param subString the substring to replace.\r\n   * @param replaceString the replacement substring\r\n   * @return the input string with occurrences of substring replaced.\r\n   */\r\n  public static String replaceSubstring(String inString, String subString,\r\n\t\t\t\t\tString replaceString) {\r\n\r\n    StringBuffer result = new StringBuffer();\r\n    int oldLoc = 0, loc = 0;\r\n    while ((loc = inString.indexOf(subString, oldLoc))!= -1) {\r\n      result.append(inString.substring(oldLoc, loc));\r\n      result.append(replaceString);\r\n      oldLoc = loc + subString.length();\r\n    }\r\n    result.append(inString.substring(oldLoc));\r\n    return result.toString();\r\n  }\r\n\r\n\r\n  /**\r\n   * Pads a string to a specified length, inserting spaces on the left\r\n   * as required. If the string is too long, characters are removed (from\r\n   * the right).\r\n   *\r\n   * @param inString the input string\r\n   * @param length the desired length of the output string\r\n   * @return the output string\r\n   */\r\n  public static String padLeft(String inString, int length) {\r\n\r\n    return fixStringLength(inString, length, false);\r\n  }\r\n  \r\n  /**\r\n   * Pads a string to a specified length, inserting spaces on the right\r\n   * as required. If the string is too long, characters are removed (from\r\n   * the right).\r\n   *\r\n   * @param inString the input string\r\n   * @param length the desired length of the output string\r\n   * @return the output string\r\n   */\r\n  public static String padRight(String inString, int length) {\r\n\r\n    return fixStringLength(inString, length, true);\r\n  }\r\n  \r\n  /**\r\n   * Pads a string to a specified length, inserting spaces as\r\n   * required. If the string is too long, characters are removed (from\r\n   * the right).\r\n   *\r\n   * @param inString the input string\r\n   * @param length the desired length of the output string\r\n   * @param right true if inserted spaces should be added to the right\r\n   * @return the output string\r\n   */\r\n  private static /*@pure@*/ String fixStringLength(String inString, int length,\r\n\t\t\t\t\tboolean right) {\r\n\r\n    if (inString.length() \u003c length) {\r\n      while (inString.length() \u003c length) {\r\n\tinString = (right ? inString.concat(\" \") : \" \".concat(inString));\r\n      }\r\n    } else if (inString.length() \u003e length) {\r\n      inString = inString.substring(0, length);\r\n    }\r\n    return inString;\r\n  }\r\n \r\n  /**\r\n   * Rounds a double and converts it into String.\r\n   *\r\n   * @param value the double value\r\n   * @param afterDecimalPoint the (maximum) number of digits permitted\r\n   * after the decimal point\r\n   * @return the double as a formatted string\r\n   */\r\n  public static /*@pure@*/ String doubleToString(double value, int afterDecimalPoint) {\r\n    \r\n    StringBuffer stringBuffer;\r\n    double temp;\r\n    int dotPosition;\r\n    long precisionValue;\r\n    \r\n    temp = value * Math.pow(10.0, afterDecimalPoint);\r\n    if (Math.abs(temp) \u003c Long.MAX_VALUE) {\r\n      precisionValue = \t(temp \u003e 0) ? (long)(temp + 0.5) \r\n                                   : -(long)(Math.abs(temp) + 0.5);\r\n      if (precisionValue == 0) {\r\n\tstringBuffer = new StringBuffer(String.valueOf(0));\r\n      } else {\r\n\tstringBuffer = new StringBuffer(String.valueOf(precisionValue));\r\n      }\r\n      if (afterDecimalPoint == 0) {\r\n\treturn stringBuffer.toString();\r\n      }\r\n      dotPosition = stringBuffer.length() - afterDecimalPoint;\r\n      while (((precisionValue \u003c 0) \u0026\u0026 (dotPosition \u003c 1)) ||\r\n\t     (dotPosition \u003c 0)) {\r\n\tif (precisionValue \u003c 0) {\r\n\t  stringBuffer.insert(1, '0');\r\n\t} else {\r\n\t  stringBuffer.insert(0, '0');\r\n\t}\r\n\tdotPosition++;\r\n      }\r\n      stringBuffer.insert(dotPosition, '.');\r\n      if ((precisionValue \u003c 0) \u0026\u0026 (stringBuffer.charAt(1) == '.')) {\r\n\tstringBuffer.insert(1, '0');\r\n      } else if (stringBuffer.charAt(0) == '.') {\r\n\tstringBuffer.insert(0, '0');\r\n      }\r\n      int currentPos = stringBuffer.length() - 1;\r\n      while ((currentPos \u003e dotPosition) \u0026\u0026\r\n\t     (stringBuffer.charAt(currentPos) == '0')) {\r\n\tstringBuffer.setCharAt(currentPos--, ' ');\r\n      }\r\n      if (stringBuffer.charAt(currentPos) == '.') {\r\n\tstringBuffer.setCharAt(currentPos, ' ');\r\n      }\r\n      \r\n      return stringBuffer.toString().trim();\r\n    }\r\n    return new String(\"\" + value);\r\n  }\r\n\r\n  /**\r\n   * Rounds a double and converts it into a formatted decimal-justified String.\r\n   * Trailing 0's are replaced with spaces.\r\n   *\r\n   * @param value the double value\r\n   * @param width the width of the string\r\n   * @param afterDecimalPoint the number of digits after the decimal point\r\n   * @return the double as a formatted string\r\n   */\r\n  public static /*@pure@*/ String doubleToString(double value, int width,\r\n\t\t\t\t      int afterDecimalPoint) {\r\n    \r\n    String tempString = doubleToString(value, afterDecimalPoint);\r\n    char[] result;\r\n    int dotPosition;\r\n\r\n    if ((afterDecimalPoint \u003e= width) \r\n        || (tempString.indexOf('E') != -1)) { // Protects sci notation\r\n      return tempString;\r\n    }\r\n\r\n    // Initialize result\r\n    result = new char[width];\r\n    for (int i = 0; i \u003c result.length; i++) {\r\n      result[i] = ' ';\r\n    }\r\n\r\n    if (afterDecimalPoint \u003e 0) {\r\n      // Get position of decimal point and insert decimal point\r\n      dotPosition = tempString.indexOf('.');\r\n      if (dotPosition == -1) {\r\n\tdotPosition = tempString.length();\r\n      } else {\r\n\tresult[width - afterDecimalPoint - 1] = '.';\r\n      }\r\n    } else {\r\n      dotPosition = tempString.length();\r\n    }\r\n    \r\n\r\n    int offset = width - afterDecimalPoint - dotPosition;\r\n    if (afterDecimalPoint \u003e 0) {\r\n      offset--;\r\n    }\r\n\r\n    // Not enough room to decimal align within the supplied width\r\n    if (offset \u003c 0) {\r\n      return tempString;\r\n    }\r\n\r\n    // Copy characters before decimal point\r\n    for (int i = 0; i \u003c dotPosition; i++) {\r\n      result[offset + i] = tempString.charAt(i);\r\n    }\r\n\r\n    // Copy characters after decimal point\r\n    for (int i = dotPosition + 1; i \u003c tempString.length(); i++) {\r\n      result[offset + i] = tempString.charAt(i);\r\n    }\r\n\r\n    return new String(result);\r\n  }\r\n\r\n  /**\r\n   * Returns the basic class of an array class (handles multi-dimensional\r\n   * arrays).\r\n   * @param c        the array to inspect\r\n   * @return         the class of the innermost elements\r\n   */\r\n  public static Class getArrayClass(Class c) {\r\n     if (c.getComponentType().isArray())\r\n        return getArrayClass(c.getComponentType());\r\n     else\r\n        return c.getComponentType();\r\n  }\r\n\r\n  /**\r\n   * Returns the dimensions of the given array. Even though the\r\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\r\n   * int[3] or double[2][4].\r\n   *\r\n   * @param array       the array to determine the dimensions for\r\n   * @return            the dimensions of the array\r\n   */\r\n  public static int getArrayDimensions(Class array) {\r\n    if (array.getComponentType().isArray())\r\n      return 1 + getArrayDimensions(array.getComponentType());\r\n    else\r\n      return 1;\r\n  }\r\n\r\n  /**\r\n   * Returns the dimensions of the given array. Even though the\r\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\r\n   * int[3] or double[2][4].\r\n   *\r\n   * @param array       the array to determine the dimensions for\r\n   * @return            the dimensions of the array\r\n   */\r\n  public static int getArrayDimensions(Object array) {\r\n    return getArrayDimensions(array.getClass());\r\n  }\r\n\r\n  /**\r\n   * Returns the given Array in a string representation. Even though the\r\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\r\n   * int[3] or double[2][4].\r\n   * \r\n   * @param array       the array to return in a string representation\r\n   * @return            the array as string\r\n   */\r\n  public static String arrayToString(Object array) {\r\n    String        result;\r\n    int           dimensions;\r\n    int           i;       \r\n\r\n    result     = \"\";\r\n    dimensions = getArrayDimensions(array);\r\n    \r\n    if (dimensions == 0) {\r\n      result = \"null\";\r\n    }\r\n    else if (dimensions == 1) {\r\n      for (i = 0; i \u003c Array.getLength(array); i++) {\r\n        if (i \u003e 0)\r\n          result += \",\";\r\n        if (Array.get(array, i) == null)\r\n          result += \"null\";\r\n        else\r\n          result += Array.get(array, i).toString();\r\n      }\r\n    }\r\n    else {\r\n      for (i = 0; i \u003c Array.getLength(array); i++) {\r\n        if (i \u003e 0)\r\n          result += \",\";\r\n        result += \"[\" + arrayToString(Array.get(array, i)) + \"]\";\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Tests if a is equal to b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n   */\r\n  public static /*@pure@*/ boolean eq(double a, double b){\r\n    \r\n    return (a - b \u003c SMALL) \u0026\u0026 (b - a \u003c SMALL); \r\n  }\r\n\r\n  /**\r\n   * Checks if the given array contains any non-empty options.\r\n   *\r\n   * @param options an array of strings\r\n   * @exception Exception if there are any non-empty options\r\n   */\r\n  public static void checkForRemainingOptions(String [] options) \r\n    throws Exception {\r\n    \r\n    int illegalOptionsFound = 0;\r\n    StringBuffer text = new StringBuffer();\r\n\r\n    if (options == null) {\r\n      return;\r\n    }\r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if (options[i].length() \u003e 0) {\r\n\tillegalOptionsFound++;\r\n\ttext.append(options[i] + ' ');\r\n      }\r\n    }\r\n    if (illegalOptionsFound \u003e 0) {\r\n      throw new Exception(\"Illegal options: \" + text);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Checks if the given array contains the flag \"-Char\". Stops\r\n   * searching at the first marker \"--\". If the flag is found,\r\n   * it is replaced with the empty string.\r\n   *\r\n   * @param flag the character indicating the flag.\r\n   * @param options the array of strings containing all the options.\r\n   * @return true if the flag was found\r\n   * @exception Exception if an illegal option was found\r\n   */\r\n  public static boolean getFlag(char flag, String [] options) \r\n    throws Exception {\r\n    \r\n    return getFlag(\"\" + flag, options);\r\n  }\r\n  \r\n  /**\r\n   * Checks if the given array contains the flag \"-String\". Stops\r\n   * searching at the first marker \"--\". If the flag is found,\r\n   * it is replaced with the empty string.\r\n   *\r\n   * @param flag the String indicating the flag.\r\n   * @param options the array of strings containing all the options.\r\n   * @return true if the flag was found\r\n   * @exception Exception if an illegal option was found\r\n   */\r\n  public static boolean getFlag(String flag, String [] options) \r\n    throws Exception {\r\n    \r\n    int pos = getOptionPos(flag, options);\r\n\r\n    if (pos \u003e -1)\r\n      options[pos] = \"\";\r\n    \r\n    return (pos \u003e -1);\r\n  }\r\n\r\n  /**\r\n   * Gets an option indicated by a flag \"-Char\" from the given array\r\n   * of strings. Stops searching at the first marker \"--\". Replaces \r\n   * flag and option with empty strings.\r\n   *\r\n   * @param flag the character indicating the option.\r\n   * @param options the array of strings containing all the options.\r\n   * @return the indicated option or an empty string\r\n   * @exception Exception if the option indicated by the flag can't be found\r\n   */\r\n  public static /*@non_null@*/ String getOption(char flag, String [] options) \r\n    throws Exception {\r\n    \r\n    return getOption(\"\" + flag, options);\r\n  }\r\n\r\n  /**\r\n   * Gets an option indicated by a flag \"-String\" from the given array\r\n   * of strings. Stops searching at the first marker \"--\". Replaces \r\n   * flag and option with empty strings.\r\n   *\r\n   * @param flag the String indicating the option.\r\n   * @param options the array of strings containing all the options.\r\n   * @return the indicated option or an empty string\r\n   * @exception Exception if the option indicated by the flag can't be found\r\n   */\r\n  public static /*@non_null@*/ String getOption(String flag, String [] options) \r\n    throws Exception {\r\n\r\n    String newString;\r\n    int i = getOptionPos(flag, options);\r\n\r\n    if (i \u003e -1) {\r\n      if (options[i].equals(\"-\" + flag)) {\r\n\tif (i + 1 == options.length) {\r\n\t  throw new Exception(\"No value given for -\" + flag + \" option.\");\r\n\t}\r\n\toptions[i] = \"\";\r\n\tnewString = new String(options[i + 1]);\r\n\toptions[i + 1] = \"\";\r\n\treturn newString;\r\n      }\r\n      if (options[i].charAt(1) == '-') {\r\n\treturn \"\";\r\n      }\r\n    }\r\n    \r\n    return \"\";\r\n  }\r\n\r\n  /**\r\n   * Gets the index of an option or flag indicated by a flag \"-Char\" from \r\n   * the given array of strings. Stops searching at the first marker \"--\".\r\n   *\r\n   * @param flag \tthe character indicating the option.\r\n   * @param options \tthe array of strings containing all the options.\r\n   * @return \t\tthe position if found, or -1 otherwise\r\n   */\r\n  public static int getOptionPos(char flag, String[] options) {\r\n     return getOptionPos(\"\" + flag, options);\r\n  }\r\n\r\n  /**\r\n   * Gets the index of an option or flag indicated by a flag \"-String\" from \r\n   * the given array of strings. Stops searching at the first marker \"--\".\r\n   *\r\n   * @param flag \tthe String indicating the option.\r\n   * @param options \tthe array of strings containing all the options.\r\n   * @return \t\tthe position if found, or -1 otherwise\r\n   */\r\n  public static int getOptionPos(String flag, String[] options) {\r\n    if (options == null)\r\n      return -1;\r\n    \r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if ((options[i].length() \u003e 0) \u0026\u0026 (options[i].charAt(0) == '-')) {\r\n\t// Check if it is a negative number\r\n\ttry {\r\n\t  Double.valueOf(options[i]);\r\n\t} \r\n\tcatch (NumberFormatException e) {\r\n\t  // found?\r\n\t  if (options[i].equals(\"-\" + flag))\r\n\t    return i;\r\n\t  // did we reach \"--\"?\r\n\t  if (options[i].charAt(1) == '-')\r\n\t    return -1;\r\n\t}\r\n      }\r\n    }\r\n    \r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Quotes a string if it contains special characters.\r\n   * \r\n   * The following rules are applied:\r\n   *\r\n   * A character is backquoted version of it is one \r\n   * of \u003ctt\u003e\" ' % \\ \\n \\r \\t\u003c/tt\u003e.\r\n   *\r\n   * A string is enclosed within single quotes if a character has been\r\n   * backquoted using the previous rule above or contains \r\n   * \u003ctt\u003e{ }\u003c/tt\u003e or is exactly equal to the strings \r\n   * \u003ctt\u003e, ? space or \"\"\u003c/tt\u003e (empty string).\r\n   *\r\n   * A quoted question mark distinguishes it from the missing value which\r\n   * is represented as an unquoted question mark in arff files.\r\n   *\r\n   * @param string the string to be quoted\r\n   * @return the string (possibly quoted)\r\n   */\r\n  public static /*@pure@*/ String quote(String string) {\r\n      boolean quote = false;\r\n\r\n      // backquote the following characters \r\n      if ((string.indexOf('\\n') != -1) || (string.indexOf('\\r') != -1) || \r\n\t  (string.indexOf('\\'') != -1) || (string.indexOf('\"') != -1) || \r\n\t  (string.indexOf('\\\\') != -1) || \r\n\t  (string.indexOf('\\t') != -1) || (string.indexOf('%') != -1)) {\r\n\t  string = backQuoteChars(string);\r\n\t  quote = true;\r\n      }\r\n\r\n      // Enclose the string in 's if the string contains a recently added\r\n      // backquote or contains one of the following characters.\r\n      if((quote == true) || \r\n\t (string.indexOf('{') != -1) || (string.indexOf('}') != -1) ||\r\n\t (string.indexOf(',') != -1) || (string.equals(\"?\")) ||\r\n\t (string.indexOf(' ') != -1) || (string.equals(\"\"))) {\r\n\t  string = (\"'\".concat(string)).concat(\"'\");\r\n      }\r\n\r\n      return string;\r\n  }\r\n\r\n  /**\r\n   * Converts carriage returns and new lines in a string into \\r and \\n.\r\n   * Backquotes the following characters: ` \" \\ \\t and %\r\n   * @param string the string\r\n   * @return the converted string\r\n   */\r\n  public static /*@pure@*/ String backQuoteChars(String string) {\r\n\r\n    int index;\r\n    StringBuffer newStringBuffer;\r\n\r\n    // replace each of the following characters with the backquoted version\r\n    char   charsFind[] =    {'\\\\',   '\\'',  '\\t',  '\"',    '%'};\r\n    String charsReplace[] = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\\\\"\", \"\\\\%\"};\r\n    for(int i = 0; i \u003c charsFind.length; i++) {\r\n\tif (string.indexOf(charsFind[i]) != -1 ) {\r\n\t    newStringBuffer = new StringBuffer();\r\n\t    while ((index = string.indexOf(charsFind[i])) != -1) {\r\n\t\tif (index \u003e 0) {\r\n\t\t    newStringBuffer.append(string.substring(0, index));\r\n\t\t}\r\n\t\tnewStringBuffer.append(charsReplace[i]);\r\n\t\tif ((index + 1) \u003c string.length()) {\r\n\t\t    string = string.substring(index + 1);\r\n\t\t} else {\r\n\t\t    string = \"\";\r\n\t\t}\r\n\t    }\r\n\t    newStringBuffer.append(string);\r\n\t    string = newStringBuffer.toString();\r\n\t}\r\n    }\r\n\r\n    return Utils.convertNewLines(string);\r\n  }\r\n\r\n  /**\r\n   * Converts carriage returns and new lines in a string into \\r and \\n.\r\n   * @param string the string\r\n   * @return the converted string\r\n   */\r\n  public static /*@pure@*/ String convertNewLines(String string) {\r\n    \r\n    int index;\r\n\r\n    // Replace with \\n\r\n    StringBuffer newStringBuffer = new StringBuffer();\r\n    while ((index = string.indexOf('\\n')) != -1) {\r\n      if (index \u003e 0) {\r\n\tnewStringBuffer.append(string.substring(0, index));\r\n      }\r\n      newStringBuffer.append('\\\\');\r\n      newStringBuffer.append('n');\r\n      if ((index + 1) \u003c string.length()) {\r\n\tstring = string.substring(index + 1);\r\n      } else {\r\n\tstring = \"\";\r\n      }\r\n    }\r\n    newStringBuffer.append(string);\r\n    string = newStringBuffer.toString();\r\n\r\n    // Replace with \\r\r\n    newStringBuffer = new StringBuffer();\r\n    while ((index = string.indexOf('\\r')) != -1) {\r\n      if (index \u003e 0) {\r\n\tnewStringBuffer.append(string.substring(0, index));\r\n      }\r\n      newStringBuffer.append('\\\\');\r\n      newStringBuffer.append('r');\r\n      if ((index + 1) \u003c string.length()){\r\n\tstring = string.substring(index + 1);\r\n      } else {\r\n\tstring = \"\";\r\n      }\r\n    }\r\n    newStringBuffer.append(string);\r\n    return newStringBuffer.toString();\r\n  }\r\n    \r\n\r\n  /**\r\n   * Returns the secondary set of options (if any) contained in\r\n   * the supplied options array. The secondary set is defined to\r\n   * be any options after the first \"--\". These options are removed from\r\n   * the original options array.\r\n   *\r\n   * @param options the input array of options\r\n   * @return the array of secondary options\r\n   */\r\n  public static String [] partitionOptions(String [] options) {\r\n\r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if (options[i].equals(\"--\")) {\r\n\toptions[i++] = \"\";\r\n\tString [] result = new String [options.length - i];\r\n\tfor (int j = i; j \u003c options.length; j++) {\r\n\t  result[j - i] = options[j];\r\n\t  options[j] = \"\";\r\n\t}\r\n\treturn result;\r\n      }\r\n    }\r\n    return new String [0];\r\n  }\r\n    \r\n  /**\r\n   * The inverse operation of backQuoteChars().\r\n   * Converts back-quoted carriage returns and new lines in a string \r\n   * to the corresponding character ('\\r' and '\\n').\r\n   * Also \"un\"-back-quotes the following characters: ` \" \\ \\t and %\r\n   * @param string the string\r\n   * @return the converted string\r\n   */\r\n  public static String unbackQuoteChars(String string) {\r\n\r\n    int index;\r\n    StringBuffer newStringBuffer;\r\n    \r\n    // replace each of the following characters with the backquoted version\r\n    String charsFind[]    = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\\\\"\", \"\\\\%\"};\r\n    char   charsReplace[] = {'\\\\',   '\\'',  '\\t',  '\"',    '%'};\r\n    \r\n    for(int i = 0; i \u003c charsFind.length; i++) {\r\n      if (string.indexOf(charsFind[i]) != -1 ) {\r\n\tnewStringBuffer = new StringBuffer();\r\n\twhile ((index = string.indexOf(charsFind[i])) != -1) {\r\n\t  if (index \u003e 0) {\r\n\t    newStringBuffer.append(string.substring(0, index));\r\n\t  }\r\n\t  newStringBuffer.append(charsReplace[i]);\r\n\t  if ((index + charsFind[i].length()) \u003c string.length()) {\r\n\t    string = string.substring(index + charsFind[i].length());\r\n\t  } else {\r\n\t    string = \"\";\r\n\t  }\r\n\t}\r\n\tnewStringBuffer.append(string);\r\n\tstring = newStringBuffer.toString();\r\n      }\r\n    }\r\n    return Utils.convertNewLines(string);\r\n  }    \r\n  \r\n \r\n  \r\n  \r\n\r\n  /**\r\n   * Computes entropy for an array of integers.\r\n   *\r\n   * @param counts array of counts\r\n   * @return - a log2 a - b log2 b - c log2 c + (a+b+c) log2 (a+b+c)\r\n   * when given array [a b c]\r\n   */\r\n  public static /*@pure@*/ double info(int counts[]) {\r\n    \r\n    int total = 0;\r\n    double x = 0;\r\n    for (int j = 0; j \u003c counts.length; j++) {\r\n      x -= xlogx(counts[j]);\r\n      total += counts[j];\r\n    }\r\n    return x + xlogx(total);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is smaller or equal to b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n   */\r\n  public static /*@pure@*/ boolean smOrEq(double a,double b) {\r\n    \r\n    return (a-b \u003c SMALL);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is greater or equal to b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n   */\r\n  public static /*@pure@*/ boolean grOrEq(double a,double b) {\r\n    \r\n    return (b-a \u003c SMALL);\r\n  }\r\n  \r\n  /**\r\n   * Tests if a is smaller than b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n   */\r\n  public static /*@pure@*/ boolean sm(double a,double b) {\r\n    \r\n    return (b-a \u003e SMALL);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is greater than b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double \r\n   */\r\n  public static /*@pure@*/ boolean gr(double a,double b) {\r\n    \r\n    return (a-b \u003e SMALL);\r\n  }\r\n\r\n  /**\r\n   * Returns the kth-smallest value in the array.\r\n   *\r\n   * @param array the array of integers\r\n   * @param k the value of k\r\n   * @return the kth-smallest value\r\n   */\r\n  public static double kthSmallestValue(int[] array, int k) {\r\n\r\n    int [] index = new int[array.length];\r\n    \r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n    }\r\n\r\n    return array[index[select(array, index, 0, array.length - 1, k)]];\r\n  }\r\n\r\n  /**\r\n   * Returns the kth-smallest value in the array\r\n   *\r\n   * @param array the array of double\r\n   * @param k the value of k\r\n   * @return the kth-smallest value\r\n   */\r\n  public static double kthSmallestValue(double[] array, int k) {\r\n\r\n    int [] index = new int[array.length];\r\n    \r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n    }\r\n\r\n    return array[index[select(array, index, 0, array.length - 1, k)]];\r\n  }\r\n\r\n  /**\r\n   * Returns the logarithm of a for base 2.\r\n   *\r\n   * @param a \ta double\r\n   * @return\tthe logarithm for base 2\r\n   */\r\n  public static /*@pure@*/ double log2(double a) {\r\n    \r\n    return Math.log(a) / log2;\r\n  }\r\n\r\n  /**\r\n   * Returns index of maximum element in a given\r\n   * array of doubles. First maximum is returned.\r\n   *\r\n   * @param doubles the array of doubles\r\n   * @return the index of the maximum element\r\n   */\r\n  public static /*@pure@*/ int maxIndex(double [] doubles) {\r\n\r\n    double maximum = 0;\r\n    int maxIndex = 0;\r\n\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      if ((i == 0) || (doubles[i] \u003e maximum)) {\r\n\tmaxIndex = i;\r\n\tmaximum = doubles[i];\r\n      }\r\n    }\r\n\r\n    return maxIndex;\r\n  }\r\n\r\n  /**\r\n   * Returns index of maximum element in a given\r\n   * array of integers. First maximum is returned.\r\n   *\r\n   * @param ints the array of integers\r\n   * @return the index of the maximum element\r\n   */\r\n  public static /*@pure@*/ int maxIndex(int [] ints) {\r\n\r\n    int maximum = 0;\r\n    int maxIndex = 0;\r\n\r\n    for (int i = 0; i \u003c ints.length; i++) {\r\n      if ((i == 0) || (ints[i] \u003e maximum)) {\r\n\tmaxIndex = i;\r\n\tmaximum = ints[i];\r\n      }\r\n    }\r\n\r\n    return maxIndex;\r\n  }\r\n\r\n  /**\r\n   * Computes the mean for an array of doubles.\r\n   *\r\n   * @param vector the array\r\n   * @return the mean\r\n   */\r\n  public static /*@pure@*/ double mean(double[] vector) {\r\n  \r\n    double sum = 0;\r\n\r\n    if (vector.length == 0) {\r\n      return 0;\r\n    }\r\n    for (int i = 0; i \u003c vector.length; i++) {\r\n      sum += vector[i];\r\n    }\r\n    return sum / (double) vector.length;\r\n  }\r\n\r\n  /**\r\n   * Returns index of minimum element in a given\r\n   * array of integers. First minimum is returned.\r\n   *\r\n   * @param ints the array of integers\r\n   * @return the index of the minimum element\r\n   */\r\n  public static /*@pure@*/ int minIndex(int [] ints) {\r\n\r\n    int minimum = 0;\r\n    int minIndex = 0;\r\n\r\n    for (int i = 0; i \u003c ints.length; i++) {\r\n      if ((i == 0) || (ints[i] \u003c minimum)) {\r\n\tminIndex = i;\r\n\tminimum = ints[i];\r\n      }\r\n    }\r\n\r\n    return minIndex;\r\n  }\r\n\r\n  /**\r\n   * Returns index of minimum element in a given\r\n   * array of doubles. First minimum is returned.\r\n   *\r\n   * @param doubles the array of doubles\r\n   * @return the index of the minimum element\r\n   */\r\n  public static /*@pure@*/ int minIndex(double [] doubles) {\r\n\r\n    double minimum = 0;\r\n    int minIndex = 0;\r\n\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      if ((i == 0) || (doubles[i] \u003c minimum)) {\r\n\tminIndex = i;\r\n\tminimum = doubles[i];\r\n      }\r\n    }\r\n\r\n    return minIndex;\r\n  }\r\n\r\n  /**\r\n   * Normalizes the doubles in the array by their sum.\r\n   *\r\n   * @param doubles the array of double\r\n   * @exception IllegalArgumentException if sum is Zero or NaN\r\n   */\r\n  public static void normalize(double[] doubles) {\r\n\r\n    double sum = 0;\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      sum += doubles[i];\r\n    }\r\n    normalize(doubles, sum);\r\n  }\r\n\r\n  /**\r\n   * Normalizes the doubles in the array using the given value.\r\n   *\r\n   * @param doubles the array of double\r\n   * @param sum the value by which the doubles are to be normalized\r\n   * @exception IllegalArgumentException if sum is zero or NaN\r\n   */\r\n  public static void normalize(double[] doubles, double sum) {\r\n\r\n    if (Double.isNaN(sum)) {\r\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is NaN.\");\r\n    }\r\n    if (sum == 0) {\r\n      // Maybe this should just be a return.\r\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is zero.\");\r\n    }\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      doubles[i] /= sum;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts an array containing the natural logarithms of\r\n   * probabilities stored in a vector back into probabilities.\r\n   * The probabilities are assumed to sum to one.\r\n   *\r\n   * @param a an array holding the natural logarithms of the probabilities\r\n   * @return the converted array \r\n   */\r\n  public static double[] logs2probs(double[] a) {\r\n\r\n    double max = a[maxIndex(a)];\r\n    double sum = 0.0;\r\n\r\n    double[] result = new double[a.length];\r\n    for(int i = 0; i \u003c a.length; i++) {\r\n      result[i] = Math.exp(a[i] - max);\r\n      sum += result[i];\r\n    }\r\n\r\n    normalize(result, sum);\r\n\r\n    return result;\r\n  } \r\n\r\n  /**\r\n   * Returns the log-odds for a given probabilitiy.\r\n   *\r\n   * @param prob the probabilitiy\r\n   *\r\n   * @return the log-odds after the probability has been mapped to\r\n   * [Utils.SMALL, 1-Utils.SMALL]\r\n   */\r\n  public static /*@pure@*/ double probToLogOdds(double prob) {\r\n\r\n    if (gr(prob, 1) || (sm(prob, 0))) {\r\n      throw new IllegalArgumentException(\"probToLogOdds: probability must \" +\r\n\t\t\t\t     \"be in [0,1] \"+prob);\r\n    }\r\n    double p = SMALL + (1.0 - 2 * SMALL) * prob;\r\n    return Math.log(p / (1 - p));\r\n  }\r\n\r\n  /**\r\n   * Rounds a double to the next nearest integer value. The JDK version\r\n   * of it doesn't work properly.\r\n   *\r\n   * @param value the double value\r\n   * @return the resulting integer value\r\n   */\r\n  public static /*@pure@*/ int round(double value) {\r\n\r\n    int roundedValue = value \u003e 0\r\n      ? (int)(value + 0.5)\r\n      : -(int)(Math.abs(value) + 0.5);\r\n    \r\n    return roundedValue;\r\n  }\r\n\r\n  /**\r\n   * Rounds a double to the next nearest integer value in a probabilistic\r\n   * fashion (e.g. 0.8 has a 20% chance of being rounded down to 0 and a\r\n   * 80% chance of being rounded up to 1). In the limit, the average of\r\n   * the rounded numbers generated by this procedure should converge to\r\n   * the original double.\r\n   *\r\n   * @param value the double value\r\n   * @param rand the random number generator\r\n   * @return the resulting integer value\r\n   */\r\n  public static int probRound(double value, Random rand) {\r\n\r\n    if (value \u003e= 0) {\r\n      double lower = Math.floor(value);\r\n      double prob = value - lower;\r\n      if (rand.nextDouble() \u003c prob) {\r\n\treturn (int)lower + 1;\r\n      } else {\r\n\treturn (int)lower;\r\n      }\r\n    } else {\r\n      double lower = Math.floor(Math.abs(value));\r\n      double prob = Math.abs(value) - lower;\r\n      if (rand.nextDouble() \u003c prob) {\r\n\treturn -((int)lower + 1);\r\n      } else {\r\n\treturn -(int)lower;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rounds a double to the given number of decimal places.\r\n   *\r\n   * @param value the double value\r\n   * @param afterDecimalPoint the number of digits after the decimal point\r\n   * @return the double rounded to the given precision\r\n   */\r\n  public static /*@pure@*/ double roundDouble(double value,int afterDecimalPoint) {\r\n\r\n    double mask = Math.pow(10.0, (double)afterDecimalPoint);\r\n\r\n    return (double)(Math.round(value * mask)) / mask;\r\n  }\r\n\r\n  /**\r\n   * Sorts a given array of integers in ascending order and returns an \r\n   * array of integers with the positions of the elements of the original \r\n   * array in the sorted array. The sort is stable. (Equal elements remain\r\n   * in their original order.)\r\n   *\r\n   * @param array this array is not changed by the method!\r\n   * @return an array of integers with the positions in the sorted\r\n   * array.\r\n   */\r\n  public static /*@pure@*/ int[] sort(int [] array) {\r\n\r\n    int [] index = new int[array.length];\r\n    int [] newIndex = new int[array.length];\r\n    int [] helpIndex;\r\n    int numEqual;\r\n    \r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n    }\r\n    quickSort(array, index, 0, array.length - 1);\r\n\r\n    // Make sort stable\r\n    int i = 0;\r\n    while (i \u003c index.length) {\r\n      numEqual = 1;\r\n      for (int j = i + 1; ((j \u003c index.length)\r\n\t\t\t   \u0026\u0026 (array[index[i]] == array[index[j]]));\r\n\t   j++) {\r\n\tnumEqual++;\r\n      }\r\n      if (numEqual \u003e 1) {\r\n\thelpIndex = new int[numEqual];\r\n\tfor (int j = 0; j \u003c numEqual; j++) {\r\n\t  helpIndex[j] = i + j;\r\n\t}\r\n\tquickSort(index, helpIndex, 0, numEqual - 1);\r\n\tfor (int j = 0; j \u003c numEqual; j++) {\r\n\t  newIndex[i + j] = index[helpIndex[j]];\r\n\t}\r\n\ti += numEqual;\r\n      } else {\r\n\tnewIndex[i] = index[i];\r\n\ti++;\r\n      }\r\n    }\r\n    return newIndex;\r\n  }\r\n\r\n  /**\r\n   * Sorts a given array of doubles in ascending order and returns an\r\n   * array of integers with the positions of the elements of the\r\n   * original array in the sorted array. NOTE THESE CHANGES: the sort\r\n   * is no longer stable and it doesn't use safe floating-point\r\n   * comparisons anymore. Occurrences of Double.NaN are treated as \r\n   * Double.MAX_VALUE\r\n   *\r\n   * @param array this array is not changed by the method!\r\n   * @return an array of integers with the positions in the sorted\r\n   * array.  \r\n   */\r\n  public static /*@pure@*/ int[] sort(/*@non_null@*/ double [] array) {\r\n\r\n    int [] index = new int[array.length];\r\n    array = (double [])array.clone();\r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n      if (Double.isNaN(array[i])) {\r\n        array[i] = Double.MAX_VALUE;\r\n      }\r\n    }\r\n    quickSort(array, index, 0, array.length - 1);\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Sorts a given array of doubles in ascending order and returns an \r\n   * array of integers with the positions of the elements of the original \r\n   * array in the sorted array. The sort is stable (Equal elements remain\r\n   * in their original order.) Occurrences of Double.NaN are treated as \r\n   * Double.MAX_VALUE\r\n   *\r\n   * @param array this array is not changed by the method!\r\n   * @return an array of integers with the positions in the sorted\r\n   * array.\r\n   */\r\n  public static /*@pure@*/ int[] stableSort(double [] array){\r\n\r\n    int [] index = new int[array.length];\r\n    int [] newIndex = new int[array.length];\r\n    int [] helpIndex;\r\n    int numEqual;\r\n    \r\n    array = (double [])array.clone();\r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n      if (Double.isNaN(array[i])) {\r\n        array[i] = Double.MAX_VALUE;\r\n      }\r\n    }\r\n    quickSort(array,index,0,array.length-1);\r\n\r\n    // Make sort stable\r\n\r\n    int i = 0;\r\n    while (i \u003c index.length) {\r\n      numEqual = 1;\r\n      for (int j = i+1; ((j \u003c index.length) \u0026\u0026 Utils.eq(array[index[i]],\r\n\t\t\t\t\t\t\tarray[index[j]])); j++)\r\n\tnumEqual++;\r\n      if (numEqual \u003e 1) {\r\n\thelpIndex = new int[numEqual];\r\n\tfor (int j = 0; j \u003c numEqual; j++)\r\n\t  helpIndex[j] = i+j;\r\n\tquickSort(index, helpIndex, 0, numEqual-1);\r\n\tfor (int j = 0; j \u003c numEqual; j++) \r\n\t  newIndex[i+j] = index[helpIndex[j]];\r\n\ti += numEqual;\r\n      } else {\r\n\tnewIndex[i] = index[i];\r\n\ti++;\r\n      }\r\n    }\r\n\r\n    return newIndex;\r\n  }\r\n\r\n  /**\r\n   * Computes the variance for an array of doubles.\r\n   *\r\n   * @param vector the array\r\n   * @return the variance\r\n   */\r\n  public static /*@pure@*/ double variance(double[] vector) {\r\n  \r\n    double sum = 0, sumSquared = 0;\r\n\r\n    if (vector.length \u003c= 1) {\r\n      return 0;\r\n    }\r\n    for (int i = 0; i \u003c vector.length; i++) {\r\n      sum += vector[i];\r\n      sumSquared += (vector[i] * vector[i]);\r\n    }\r\n    double result = (sumSquared - (sum * sum / (double) vector.length)) / \r\n      (double) (vector.length - 1);\r\n\r\n    // We don't like negative variance\r\n    if (result \u003c 0) {\r\n      return 0;\r\n    } else {\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Computes the sum of the elements of an array of doubles.\r\n   *\r\n   * @param doubles the array of double\r\n   * @return the sum of the elements\r\n   */\r\n  public static /*@pure@*/ double sum(double[] doubles) {\r\n\r\n    double sum = 0;\r\n\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      sum += doubles[i];\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * Computes the sum of the elements of an array of integers.\r\n   *\r\n   * @param ints the array of integers\r\n   * @return the sum of the elements\r\n   */\r\n  public static /*@pure@*/ int sum(int[] ints) {\r\n\r\n    int sum = 0;\r\n\r\n    for (int i = 0; i \u003c ints.length; i++) {\r\n      sum += ints[i];\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * Returns c*log2(c) for a given integer value c.\r\n   *\r\n   * @param c an integer value\r\n   * @return c*log2(c) (but is careful to return 0 if c is 0)\r\n   */\r\n  public static /*@pure@*/ double xlogx(int c) {\r\n    \r\n    if (c == 0) {\r\n      return 0.0;\r\n    }\r\n    return c * Utils.log2((double) c);\r\n  }\r\n\r\n  /**\r\n   * Partitions the instances around a pivot. Used by quicksort and\r\n   * kthSmallestValue.\r\n   *\r\n   * @param array the array of doubles to be sorted\r\n   * @param index the index into the array of doubles\r\n   * @param l the first index of the subset \r\n   * @param r the last index of the subset \r\n   *\r\n   * @return the index of the middle element\r\n   */\r\n  private static int partition(double[] array, int[] index, int l, int r) {\r\n    \r\n    double pivot = array[index[(l + r) / 2]];\r\n    int help;\r\n\r\n    while (l \u003c r) {\r\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\r\n        l++;\r\n      }\r\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\r\n        r--;\r\n      }\r\n      if (l \u003c r) {\r\n        help = index[l];\r\n        index[l] = index[r];\r\n        index[r] = help;\r\n        l++;\r\n        r--;\r\n      }\r\n    }\r\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\r\n      r--;\r\n    } \r\n\r\n    return r;\r\n  }\r\n\r\n  /**\r\n   * Partitions the instances around a pivot. Used by quicksort and\r\n   * kthSmallestValue.\r\n   *\r\n   * @param array the array of integers to be sorted\r\n   * @param index the index into the array of integers\r\n   * @param l the first index of the subset \r\n   * @param r the last index of the subset \r\n   *\r\n   * @return the index of the middle element\r\n   */\r\n  private static int partition(int[] array, int[] index, int l, int r) {\r\n    \r\n    double pivot = array[index[(l + r) / 2]];\r\n    int help;\r\n\r\n    while (l \u003c r) {\r\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\r\n        l++;\r\n      }\r\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\r\n        r--;\r\n      }\r\n      if (l \u003c r) {\r\n        help = index[l];\r\n        index[l] = index[r];\r\n        index[r] = help;\r\n        l++;\r\n        r--;\r\n      }\r\n    }\r\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\r\n      r--;\r\n    } \r\n\r\n    return r;\r\n  }\r\n  \r\n  /**\r\n   * Implements quicksort according to Manber's \"Introduction to\r\n   * Algorithms\".\r\n   *\r\n   * @param array the array of doubles to be sorted\r\n   * @param index the index into the array of doubles\r\n   * @param left the first index of the subset to be sorted\r\n   * @param right the last index of the subset to be sorted\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r\n  //@ requires array != index;\r\n  //  assignable index;\r\n  private static void quickSort(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \r\n                                int left, int right) {\r\n\r\n    if (left \u003c right) {\r\n      int middle = partition(array, index, left, right);\r\n      quickSort(array, index, left, middle);\r\n      quickSort(array, index, middle + 1, right);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Implements quicksort according to Manber's \"Introduction to\r\n   * Algorithms\".\r\n   *\r\n   * @param array the array of integers to be sorted\r\n   * @param index the index into the array of integers\r\n   * @param left the first index of the subset to be sorted\r\n   * @param right the last index of the subset to be sorted\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r\n  //@ requires array != index;\r\n  //  assignable index;\r\n  private static void quickSort(/*@non_null@*/ int[] array, /*@non_null@*/  int[] index, \r\n                                int left, int right) {\r\n\r\n    if (left \u003c right) {\r\n      int middle = partition(array, index, left, right);\r\n      quickSort(array, index, left, middle);\r\n      quickSort(array, index, middle + 1, right);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Implements computation of the kth-smallest element according\r\n   * to Manber's \"Introduction to Algorithms\".\r\n   *\r\n   * @param array the array of double\r\n   * @param index the index into the array of doubles\r\n   * @param left the first index of the subset \r\n   * @param right the last index of the subset \r\n   * @param k the value of k\r\n   *\r\n   * @return the index of the kth-smallest element\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  private static int select(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \r\n                            int left, int right, int k) {\r\n    \r\n    if (left == right) {\r\n      return left;\r\n    } else {\r\n      int middle = partition(array, index, left, right);\r\n      if ((middle - left + 1) \u003e= k) {\r\n        return select(array, index, left, middle, k);\r\n      } else {\r\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Implements computation of the kth-smallest element according\r\n   * to Manber's \"Introduction to Algorithms\".\r\n   *\r\n   * @param array the array of integers\r\n   * @param index the index into the array of integers\r\n   * @param left the first index of the subset \r\n   * @param right the last index of the subset \r\n   * @param k the value of k\r\n   *\r\n   * @return the index of the kth-smallest element\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  private static int select(/*@non_null@*/ int[] array, /*@non_null@*/ int[] index, \r\n                            int left, int right, int k) {\r\n    \r\n    if (left == right) {\r\n      return left;\r\n    } else {\r\n      int middle = partition(array, index, left, right);\r\n      if ((middle - left + 1) \u003e= k) {\r\n        return select(array, index, left, middle, k);\r\n      } else {\r\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\r\n      }\r\n    }\r\n  }\r\n\r\n  \r\n}\r\n  \r\n",
        "name": "Utils.java",
        "path": "src/main/java/nz/ac/waikato/cs/weka/Utils.java",
        "url": "/github.com/eracle/gap/-/blob/src/main/java/nz/ac/waikato/cs/weka/Utils.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 1447,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1448,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1449,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1470,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1471,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1472,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1496,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1524,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        }
      ],
      "repository": {
        "name": "github.com/eracle/gap",
        "url": "/github.com/eracle/gap"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 8,
  "ElapsedMilliseconds": 1702,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
