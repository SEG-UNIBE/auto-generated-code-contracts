{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/liflab/beepbeep-3 lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "11df50406b53cda57dd922fa70ca1e06b2546859"
        },
        "content": "/*\n    BeepBeep, an event stream processor\n    Copyright (C) 2008-2023 Sylvain Hallé\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\npackage ca.uqac.lif.cep;\n\nimport ca.uqac.lif.azrael.ObjectPrinter;\nimport ca.uqac.lif.azrael.ObjectReader;\nimport ca.uqac.lif.azrael.PrintException;\nimport ca.uqac.lif.azrael.Printable;\nimport ca.uqac.lif.azrael.ReadException;\nimport ca.uqac.lif.azrael.Readable;\nimport ca.uqac.lif.cep.Connector.PipeSelector;\nimport ca.uqac.lif.cep.Connector.SelectedInputPipe;\nimport ca.uqac.lif.cep.Connector.Variant;\nimport ca.uqac.lif.cep.util.Equals;\nimport ca.uqac.lif.cep.util.Lists.MathList;\nimport ca.uqac.lif.cep.util.Maps.MathMap;\nimport ca.uqac.lif.petitpoucet.NodeFunction;\nimport ca.uqac.lif.petitpoucet.ProvenanceNode;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Set;\n\n/**\n * Receives zero or more input events, and produces zero or more output events.\n * The processor is the fundamental class where all computation occurs. All of\n * BeepBeep's processors (including yours) are descendants of this class.\n * \n * A processor is depicted graphically as a \"box\", with \"pipes\" representing its\n * input and output streams.\n * \u003cp\u003e\n * \u003cimg src=\"{@docRoot}/doc-files/Processor-generic.png\" alt=\"Processor\"\u003e\n * \u003cp\u003e\n * This class itself is abstract; nevertheless, it provides important methods\n * for handling input/output event queues, connecting processors together, etc.\n * However, if you write your own processor, you will most likely want to\n * inherit from its child, {@link SynchronousProcessor}, which does some more work\n * for you.\n * \u003cp\u003e\n * The {@link Processor} class does not assume anything about the type of events\n * being input or output. All its input and output queues are therefore declared\n * as containing instances of `Object`, Java's most generic type.\n * \n * @author Sylvain Hallé\n * @since 0.1\n *\n */\npublic abstract class Processor implements DuplicableProcessor, \n  Contextualizable, Printable, Readable\n{\n  /**\n   * The processor's input arity, i.e. the number of input events it requires to\n   * produce an output\n   */\n  protected int m_inputArity;\n\n  /**\n   * The processor's output arity, i.e. the number of output events it produces\n   */\n  protected int m_outputArity;\n\n  /**\n   * A string used to identify the program's version\n   */\n  public static final transient String s_versionString = \"0.10.5\";\n\n  /**\n   * An array of input event queues. This is where the input events will be stored\n   * before the processor consumes them. There are as many input queues as the\n   * input arity of the processor.\n   */\n  protected transient Queue\u003cObject\u003e[] m_inputQueues;\n\n  /**\n   * An object that keeps track of the relationship between input and output\n   * events.\n   */\n  protected transient EventTracker m_eventTracker = null;\n\n  /**\n   * An array of output event queues. This is where the output events will be\n   * stored when the processor does its computation. There are as many output\n   * queues as the output arity of the processor.\n   */\n  protected transient Queue\u003cObject\u003e[] m_outputQueues;\n\n  /**\n   * An array of {@link Pullable}s, one for each input trace this processor\n   * receives\n   */\n  protected transient Pullable[] m_inputPullables;\n\n  /**\n   * An array of {@link Pushable}s, one for each output trace this processor\n   * produces\n   */\n  protected transient Pushable[] m_outputPushables;\n\n  /**\n   * A counter incremented upon each input front processed\n   */\n  protected int m_inputCount = 0;\n\n  /**\n   * A counter incremented upon each output front processed\n   */\n  protected int m_outputCount = 0;\n\n  /**\n   * A static counter, to be incremented every time a new {@link Processor} is\n   * instantiated. This is used to give a unique integer number to every\n   * processor.\n   */\n  private static int s_uniqueIdCounter = 0;\n\n  /**\n   * The unique ID given to this processor instance\n   */\n  private final int m_uniqueId;\n\n  /**\n   * The context in which the processor is instantiated\n   */\n  protected Context m_context = null;\n\n  /**\n   * Number of times the {@link Pullable#hasNext()} method tries to produce an\n   * output from the input before giving up. While in theory, the method tries \"as\n   * long as necessary\", in practice a bound was put on the number of attempts as\n   * a safeguard to avoid infinite loops.\n   */\n  public static final transient int MAX_PULL_RETRIES = 10000000;\n\n  /**\n   * Indicates whether the processor has been notified of the end of trace or\n   * not. Each input pushable has its own flag, and the end of trace signal\n   * is propagated only once all upstream processors have sent the\n   * notification.\n   */\n  protected boolean[] m_hasBeenNotifiedOfEndOfTrace;\n  \n  /**\n   * Indicates whether the processor has notified the end of the trace to the\n   * downstream processors it is connected to. The end of trace signal should\n   * be sent at most once.\n   */\n  protected boolean m_notifiedEndOfTraceDownstream;\n\n  /**\n   * Initializes a processor. This has for effect of executing the basic\n   * operations common to every processor:\n   * \u003cul\u003e\n   * \u003cli\u003eGiving a unique ID\u003c/li\u003e\n   * \u003cli\u003eDetermining its input and output arity\u003c/li\u003e\n   * \u003cli\u003eCreating arrays of empty input and output queues, as well as arrays of\n   * {@link Pullable}s and {@link Pushable}s\u003c/li\u003e\n   * \u003c/ul\u003e\n   * \u003cp\u003e\n   * If you create your own processor, its constructor \u003cstrong\u003emust\u003c/strong\u003e start\n   * by calling its ancestor's constructor (which ultimately ends up calling this\n   * constructor). Otherwise, expect a plethora of null pointers and other\n   * oddities.\n   * \n   * @param in_arity\n   *          The processor's input arity\n   * @param out_arity\n   *          The processor's output arity\n   */\n  @SuppressWarnings(\"unchecked\")\n  //@ requires in_arity \u003e= 0\n  //@ requires out_arity \u003e= 0\n  public Processor(int in_arity, int out_arity)\n  {\n    super();\n    m_inputArity = in_arity;\n    m_outputArity = out_arity;\n    m_uniqueId = s_uniqueIdCounter++;\n    m_inputQueues = new Queue[m_inputArity];\n    for (int i = 0; i \u003c m_inputArity; i++)\n    {\n      m_inputQueues[i] = new ArrayDeque\u003cObject\u003e();\n    }\n    m_outputQueues = new Queue[m_outputArity];\n    for (int i = 0; i \u003c m_outputArity; i++)\n    {\n      m_outputQueues[i] = new ArrayDeque\u003cObject\u003e();\n    }\n    m_inputPullables = new Pullable[m_inputArity];\n    m_outputPushables = new Pushable[m_outputArity];\n    m_hasBeenNotifiedOfEndOfTrace = new boolean[m_inputArity];\n    for (int i = 0; i \u003c m_inputArity; i++)\n    {\n      m_hasBeenNotifiedOfEndOfTrace[i] = false; \n    }\n    m_notifiedEndOfTraceDownstream = false;\n  }\n  \n  /**\n   * Determines if all the upstream pushables have sent the end of trace\n   * notification.\n   * @return {@code true} if all notifications have been sent, {@code false}\n   * otherwise\n   */\n  protected boolean allNotifiedEndOfTrace()\n  {\n    for (int i = 0; i \u003c m_inputArity; i++)\n    {\n      if (!m_hasBeenNotifiedOfEndOfTrace[i])\n      {\n        return false;\n      }\n    }\n    return true;\n  }\n  \n  /**\n   * Creates a new empty context map\n   * \n   * @return The context map\n   */\n  protected final /*@ non_null @*/ Context newContext()\n  {\n    return new Context();\n  }\n\n  /**\n   * Retrieves an object from the processor's context\n   * \n   * @param key\n   *          The key associated to that object\n   * @return The object, or {@code null} if no object exists with such key\n   */\n  public final /*@ null @*/ Object getContext(/*@ non_null @*/ String key)\n  {\n    if (m_context == null || !m_context.containsKey(key))\n    {\n      return null;\n    }\n    return m_context.get(key);\n  }\n\n  @Override\n  public /*@ non_null @*/ Context getContext()\n  {\n    // As the context map is created only on demand, we must first\n    // check if a map already exists and create it if not\n    if (m_context == null)\n    {\n      m_context = newContext();\n    }\n    return m_context;\n  }\n\n  @Override\n  public void setContext(/*@ non_null @*/ String key, Object value)\n  {\n    // As the context map is created only on demand, we must first\n    // check if a map already exists and create it if not\n    if (m_context == null)\n    {\n      m_context = newContext();\n    }\n    m_context.put(key, value);\n  }\n\n  @Override\n  public void setContext(/*@ null @*/ Context context)\n  {\n    // As the context map is created only on demand, we must first\n    // check if a map already exists and create it if not\n    if (context != null)\n    {\n      if (m_context == null)\n      {\n        m_context = newContext();\n      }\n      m_context.putAll(context);\n    }\n  }\n\n  /**\n   * Implementation of {@link java.lang.Object#hashCode() hashCode()} specific\n   * to processors. Every processor instance in BeepBeep is given a unique ID;\n   * even a clone of a processor (created using {@link Processor#duplicate()} will\n   * be identical to the original, except for this ID. This behavior cannot be\n   * overridden by descendants.\n   */\n  @Override\n  public final int hashCode()\n  {\n    return m_uniqueId;\n  }\n\n  /**\n   * Implementation of {@link java.lang.Object#equals(Object) equals()} specific\n   * to processors. Since every processor has a unique ID, equality amounts to\n   * equality of the field {@link #m_uniqueId}. This behavior cannot be\n   * overridden by descendants. \n   */\n  @Override\n  public final boolean equals(Object o)\n  {\n    if (o == null || !(o instanceof Processor))\n    {\n      return false;\n    }\n    Processor p = (Processor) o;\n    return m_uniqueId == p.m_uniqueId;\n  }\n\n  /**\n   * Fetches the processor instance's unique ID\n   * \n   * @return The ID\n   */\n  public final int getId()\n  {\n    return m_uniqueId;\n  }\n\n  /**\n   * Resets the processor. This has for effect of flushing the contents of all\n   * input and output event queues. If the processor has an internal state, this\n   * should also reset this state to its \"initial\" settings (whatever that means\n   * in your context).\n   */\n  public void reset()\n  {\n    // Reset input\n    for (int i = 0; i \u003c m_inputArity; i++)\n    {\n      m_inputQueues[i].clear();\n    }\n    // Reset output\n    for (int i = 0; i \u003c m_outputArity; i++)\n    {\n      m_outputQueues[i].clear();\n    }\n    for (int i = 0; i \u003c m_inputArity; i++)\n    {\n      m_hasBeenNotifiedOfEndOfTrace[i] = false; \n    }\n    m_notifiedEndOfTraceDownstream = false;\n    m_inputCount = 0;\n    m_outputCount = 0;\n  }\n\n  /**\n   * Returns the {@link Pushable} corresponding to the processor's \u003ci\u003ei\u003c/i\u003e-th\n   * input trace.\n   * \n   * @param index\n   *          The index. Should be between 0 and the processor's input arity - 1\n   *          (since indices start at 0).\n   * @return The pushable if the index is within the appropriate range. Outside of\n   *         the range,\n   */\n  /*@ assume index \u003e= 0 @*/\n  public abstract /*@ non_null @*/ Pushable getPushableInput(int index);\n\n  /**\n   * Returns the {@link Pushable} corresponding to the processor's first input\n   * trace\n   * \n   * @return The pushable if the processor has at least one input. An\n   *         ArrayIndexOutOfBounds will be thrown if the processor has an input\n   *         arity of 0.\n   */\n  public final /*@ non_null @*/ Pushable getPushableInput()\n  {\n    return getPushableInput(0);\n  }\n\n  /**\n   * Returns the {@link Pullable} corresponding to the processor's \u003ci\u003ei\u003c/i\u003e-th\n   * output trace.\n   * \n   * @param index\n   *          The index. Should be between 0 and the processor's output arity - 1\n   *          (since indices start at 0).\n   * @return The pullable if the index is within the appropriate range,\n   *         {@code null} otherwise.\n   */\n  public abstract /*@ non_null @*/ Pullable getPullableOutput(int index);\n\n  /**\n   * Returns the {@link Pullable} corresponding to the processor's first output\n   * trace\n   * \n   * @return The pullable if the processor has at least one output. An\n   *         ArrayIndexOutOfBounds will be thrown if the processor has an output\n   *         arity of 0.\n   */\n  public final /*@ non_null @*/ Pullable getPullableOutput()\n  {\n    return getPullableOutput(0);\n  }\n\n  /**\n   * Assigns a {@link Pullable} to the processor's \u003ci\u003ei\u003c/i\u003e-th input.\n   * \n   * @param i\n   *          The index of the input. An ArrayIndexOutOfBounds will be thrown if\n   *          it is out of range.\n   * @param p\n   *          The pullable to assign it to\n   */\n  public void setPullableInput(int i, /*@ non_null @*/ Pullable p)\n  {\n    m_inputPullables[i] = p;\n  }\n\n  /**\n   * Returns the {@link Pullable} corresponding to the processor's \u003ci\u003ei\u003c/i\u003e-th\n   * input\n   * \n   * @param i\n   *          The index of the input. Should be greater than 0 and less than the\n   *          processor's output arity. Outside these bounds, an\n   *          ArrayIndexOutOfBounds will be thrown.\n   * @return The pullable\n   */\n  public Pullable getPullableInput(int i)\n  {\n    return m_inputPullables[i];\n  }\n\n  /**\n   * Assigns a {@link Pushable} to the processor's \u003ci\u003ei\u003c/i\u003e-th output.\n   * \n   * @param i\n   *          The index of the output. Should be greater than 0 and less than the\n   *          processor's output arity. Outside these bounds, an\n   *          ArrayIndexOutOfBounds will be thrown.\n   * @param p\n   *          The pushable to assign it to\n   */\n  public void setPushableOutput(int i, /*@ non_null @*/ Pushable p)\n  {\n    m_outputPushables[i] = p;\n  }\n\n  /**\n   * Retrieves the {@link Pushable} associated to the processor's \u003ci\u003ei\u003c/i\u003e-th\n   * output.\n   * \n   * @param i\n   *          The index of the output. Should be greater than 0 (not checked) and\n   *          less than the processor's output arity. Outside these bounds, an\n   *          ArrayIndexOutOfBounds will be thrown.\n   * @return The pushable\n   */\n  public /*@ non_null @*/ Pushable getPushableOutput(int i)\n  {\n    return m_outputPushables[i];\n  }\n\n  /**\n   * Returns the processor's input arity\n   * \n   * @return The arity\n   */\n  /*@ pure @*/ public final int getInputArity()\n  {\n    return m_inputArity;\n  }\n\n  /**\n   * Returns the processor's output arity\n   * \n   * @return The arity\n   */\n  /*@ pure @*/ public final int getOutputArity()\n  {\n    return m_outputArity;\n  }\n\n  /**\n   * Checks if all objects in the array are null. This is a convenience method\n   * used by other processor classes (e.g. {@link SynchronousProcessor} to make sure\n   * that some output was generated from a given input\n   * \n   * @param v\n   *          The array\n   * @return {@code true} if all elements in the array are null,\n   *         {@code false} otherwise\n   */\n  public static boolean allNull(Object[] v)\n  {\n    for (Object o : v)\n    {\n      if (o != null)\n      {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Copies the contents and state of the current processor into another\n   * \n   * @param p\n   *          The processor to copy contents into\n   */\n  public void duplicateInto(Processor p)\n  {\n    p.m_eventTracker = m_eventTracker;\n    p.setContext(m_context);\n    for (int i = 0; i \u003c m_inputQueues.length; i++)\n    {\n      p.m_inputQueues[i].addAll(m_inputQueues[i]);\n    }\n    for (int i = 0; i \u003c m_outputQueues.length; i++)\n    {\n      p.m_outputQueues[i].addAll(m_outputQueues[i]);\n    }\n  }\n\n  /**\n   * Gets the type of events the processor accepts for its \u003ci\u003ei\u003c/i\u003e-th input\n   * trace. Note that this method returns a \u003cem\u003eset\u003c/em\u003e, in the case where the\n   * processor accepts various types of objects (for example, a processor\n   * accepting {@code Number}s, but also {@code String}s it converts\n   * into numbers internally).\n   * \n   * @param index\n   *          The index of the input to query\n   * @return A set of classes. If {@code index} is less than 0 or greater\n   *         than the processor's declared input arity, the set will be empty.\n   */\n  //@ requires index \u003e= 0\n  /*@ non_null @*/ public final Set\u003cClass\u003c?\u003e\u003e getInputType(int index)\n  {\n    Set\u003cClass\u003c?\u003e\u003e classes = new HashSet\u003cClass\u003c?\u003e\u003e();\n    if (index \u003e= 0 \u0026\u0026 index \u003c m_inputArity)\n    {\n      getInputTypesFor(classes, index);\n    }\n    return classes;\n  }\n\n  /**\n   * Populates the set of classes accepted by the processor for its \u003ci\u003ei\u003c/i\u003e-th\n   * input.\n   * \u003cp\u003e\n   * By default, a processor returns the {@link Connector.Variant} type for all\n   * its inputs and all its outputs, meaning that the checking of types in\n   * {@link Connector#connect(Processor...)} will be skipped. A descendant of this\n   * class may choose to define specific types for its input and output, thereby\n   * activating runtime type checking.\n   * \n   * @param classes\n   *          The set of to fill with classes\n   * @param index\n   *          The index of the input to query\n   */\n  public void getInputTypesFor(/*@ non_null @*/ Set\u003cClass\u003c?\u003e\u003e classes, int index)\n  {\n    classes.add(Variant.class);\n  }\n\n  /**\n   * Returns the type of the events produced by the processor for its \u003ci\u003ei\u003c/i\u003e-th\n   * output.\n   * \u003cp\u003e\n   * By default, a processor returns the {@link Connector.Variant} type for all\n   * its inputs and all its outputs, meaning that the checking of types in\n   * {@link Connector#connect(Processor...)} will be skipped. A descendant of this\n   * class may choose to define specific types for its input and output, thereby\n   * activating runtime type checking.\n   * \n   * @param index\n   *          The index of the output to query\n   * @return The type of the output. If {@code index} it less than 0 or\n   *         greater than the processor's declared output arity, this method\n   *         \u003cem\u003emay\u003c/em\u003e throw an IndexOutOfBoundsException.\n   */\n  // requires index \u003e= 0 \u0026\u0026 index \u003c getInputArity()\n  public Class\u003c?\u003e getOutputType(int index)\n  {\n    return Variant.class;\n  }\n\n  /**\n   * Gets an instance of an empty event queue. It is recommended that processors\n   * call this method to get a queue instance, rather than instantiate their own\n   * manually.\n   * \n   * @return The queue\n   */\n  /*@ non_null @*/ public static Queue\u003cObject[]\u003e getEmptyQueue()\n  {\n    return new ArrayDeque\u003cObject[]\u003e();\n  }\n\n  /**\n   * Starts the processor. This has no effect, except for processors that use\n   * threads; in such a case, calling this method should start the thread.\n   */\n  public void start()\n  {\n    // Nothing\n  }\n\n  /**\n   * Stops the processor. This has no effect, except for processors that use\n   * threads; in such a case, calling this method should stop the thread.\n   */\n  public void stop()\n  {\n    // Nothing\n  }\n\n  /**\n   * Starts all processors given as an argument\n   * \n   * @param procs\n   *          The processors\n   */\n  public static void startAll(Processor ... procs)\n  {\n    for (Processor p : procs)\n    {\n      if (p != null)\n      {\n        p.start();\n      }\n    }\n  }\n\n  /**\n   * Stops all processors given as an argument\n   * \n   * @param procs\n   *          The processors\n   */\n  public static void stopAll(Processor ... procs)\n  {\n    for (Processor p : procs)\n    {\n      if (p != null)\n      {\n        p.stop();\n      }\n    }\n  }\n\n  /**\n   * Gets the instance of event tracker associated to this processor\n   * \n   * @return The event tracker, or {@code null} of no event tracker is associated\n   *         to this processor\n   */\n  public final /*@ null @*/ EventTracker getEventTracker()\n  {\n    return m_eventTracker;\n  }\n\n  /**\n   * Associates an event tracker to this processor\n   * \n   * @param tracker\n   *          The event tracker, or {@code null} to remove the association to an\n   *          existing tracker\n   * @return This processor\n   */\n  public Processor setEventTracker(/*@ null @*/ EventTracker tracker)\n  {\n    m_eventTracker = tracker;\n    return this;\n  }\n\n  /**\n   * Associates an input event to an output event.\n   * @param in_stream_index The index of the processor's input stream \n   * @param in_stream_pos The position of the event in the input stream\n   * @param out_stream_index The index of the processor's output stream \n   * @param out_stream_pos The position of the event in the output stream\n   */\n  public void associateToInput(int in_stream_index, int in_stream_pos, int out_stream_index,\n      int out_stream_pos)\n  {\n    if (m_eventTracker != null)\n    {\n      m_eventTracker.associateToInput(m_uniqueId, in_stream_index, in_stream_pos, out_stream_index,\n          out_stream_pos);\n    }\n  }\n\n  /**\n   * Associates a node function to a particular event of processor's\n   * output stream. \n   * @param f The node function\n   * @param out_stream_index The index of the processor's output stream \n   * @param out_stream_pos The position of the event in the output stream\n   */\n  public void associateTo(NodeFunction f, int out_stream_index, int out_stream_pos)\n  {\n    if (m_eventTracker != null)\n    {\n      m_eventTracker.associateTo(m_uniqueId, f, out_stream_index, out_stream_pos);\n    }\n  }\n\n  /**\n   * Associates an input event to an output event.\n   * @param in_stream_index The index of the processor's input stream \n   * @param in_stream_pos The position of the event in the input stream\n   * @param out_stream_index The index of the processor's output stream \n   * @param out_stream_pos The position of the event in the output stream\n   */\n  public void associateToOutput(int in_stream_index, int in_stream_pos, int out_stream_index,\n      int out_stream_pos)\n  {\n    if (m_eventTracker != null)\n    {\n      m_eventTracker.associateToOutput(m_uniqueId, in_stream_index, in_stream_pos, out_stream_index,\n          out_stream_pos);\n    }\n  }\n\n  /**\n   * Allows to describe a specific behavior when the trace of input fronts has\n   * reached its end. Called in \"push mode\" only. In \"pull mode\", implementing\n   * such a behavior can be done by using {@link Pullable#hasNext()} or\n   * {@link Pullable#hasNextSoft()}.\n   *\n   * @param outputs\n   *          A queue of arrays of objects. The processor should push arrays into\n   *          this queue for every output front it produces. The size of each\n   *          array should be equal to the processor's output arity, although this\n   *          is not enforced.\n   * @return true if the processor should output one or several output fronts,\n   *         false otherwise and by default.\n   * @throws ProcessorException\n   *           An exception thrown when a problem occurs with the operation\n   */\n  protected boolean onEndOfTrace(Queue\u003cObject[]\u003e outputs) throws ProcessorException\n  {\n    return false;\n  }\n\n  /**\n   * Gets the number of event fronts received so far by this processor\n   * @return The number of fronts\n   */\n  public final int getInputCount()\n  {\n    return m_inputCount;\n  }\n\n  /**\n   * Gets the number of event fronts produced so far by this processor\n   * @return The number of fronts\n   */\n  public final int getOutputCount()\n  {\n    return m_outputCount;\n  }\n\n  /**\n   * Prints the contents of this processor into an object printer.\n   * @param printer The printer to print this processor to\n   * @return The printed processor\n   * @since 0.10.2\n   */\n  @Override\n  public final Object print(ObjectPrinter\u003c?\u003e printer) throws ProcessorException\n  {\n    Map\u003cString,Object\u003e contents = new HashMap\u003cString,Object\u003e();\n    contents.put(\"id\", m_uniqueId);\n    contents.put(\"input-count\", m_inputCount);\n    contents.put(\"output-count\", m_outputCount);\n    contents.put(\"context\", m_context);\n    List\u003cQueue\u003cObject\u003e\u003e in_queues = new ArrayList\u003cQueue\u003cObject\u003e\u003e(m_inputQueues.length);\n    for (Queue\u003cObject\u003e q : m_inputQueues)\n    {\n      in_queues.add(q);\n    }\n    contents.put(\"input-queues\", in_queues);\n    List\u003cQueue\u003cObject\u003e\u003e out_queues = new ArrayList\u003cQueue\u003cObject\u003e\u003e(m_outputQueues.length);\n    for (Queue\u003cObject\u003e q : m_outputQueues)\n    {\n      out_queues.add(q);\n    }\n    contents.put(\"output-queues\", out_queues);\n    contents.put(\"contents\", printState());\n    try\n    {\n      return printer.print(contents);\n    }\n    catch (PrintException e)\n    {\n      throw new ProcessorException(e);\n    }\n  }\n\n  /**\n   * Produces an object that represents the state of the current processor.\n   * A concrete processor should override this method to add whatever state\n   * information that needs to be preserved in the serialization process.\n   * @return Any object representing the processor's state \n   * (including {@code null})\n   * @since 0.10.2\n   */\n  protected Object printState()\n  {\n    return null;\n  }\n  \n  /**\n   * Reads the content of a processor from a serialized object.\n   * @param reader An object reader\n   * @param o The object to read from\n   * @return The serialized processor\n   * @throws ProcessorException If the read operation failed for some reason\n   */\n  @SuppressWarnings(\"unchecked\")\n  @Override\n  public final Processor read(ObjectReader\u003c?\u003e reader, Object o) throws ProcessorException\n  {\n    Map\u003cString, Object\u003e contents = null;\n    try\n    {\n      contents = (Map\u003cString,Object\u003e) reader.read(o);\n    }\n    catch (ReadException e)\n    {\n      throw new ProcessorException(e);\n    }\n    Processor p = null;\n    if (contents.containsKey(\"contents\"))\n    {\n      Object o_contents = contents.get(\"contents\");\n      try\n      {\n        p = readState(o_contents);\n      }\n      catch (UnsupportedOperationException e)\n      {\n        throw new ProcessorException(e);\n      }\n    }\n    if (p == null)\n    {\n      throw new ProcessorException(\"The processor returned null with being deserialized\");\n    }\n    p.m_inputCount = ((Number) contents.get(\"input-count\")).intValue();\n    p.m_outputCount = ((Number) contents.get(\"output-count\")).intValue();\n    try\n    {\n      reader.setField(p, \"m_uniqueId\", ((Number) contents.get(\"id\")).intValue());\n    }\n    catch (ReadException e)\n    {\n      throw new ProcessorException(e);\n    }\n    List\u003cQueue\u003cObject\u003e\u003e in_queues = (List\u003cQueue\u003cObject\u003e\u003e) contents.get(\"input-queues\");\n    for (int i = 0; i \u003c in_queues.size(); i++)\n    {\n      p.m_inputQueues[i] = in_queues.get(i);\n    }\n    List\u003cQueue\u003cObject\u003e\u003e out_queues = (List\u003cQueue\u003cObject\u003e\u003e) contents.get(\"output-queues\");\n    for (int i = 0; i \u003c out_queues.size(); i++)\n    {\n      p.m_outputQueues[i] = in_queues.get(i);\n    }\n    return p;\n  }\n\n  /**\n   * Reads the state of a processor and uses it to create a new instance\n   * @param o The object containing the processor's state\n   * @return A new processor instance\n   * @since 0.10.2\n   */\n  protected Processor readState(Object o)\n  {\n    throw new UnsupportedOperationException(\"This processor does not support deserialization\");\n  }\n\n  @Override\n  /*@ pure non_null @*/ public final Processor duplicate()\n  {\n    return duplicate(false);\n  }\n  \n  /**\n   * Copies the content of one of the processor's input queue to a collection.\n   * @param index The index of the input queue\n   * @param to The collection where queue contents are copied to\n   * @since 0.11\n   */\n  /*@ pure @*/ public void copyInputQueue(int index, Collection\u003cObject\u003e to)\n  {\n  \tto.addAll(m_inputQueues[index]);\n  }\n  \n  /**\n   * Copies the content of one of the processor's output queue to a collection.\n   * @param index The index of the output queue\n   * @param to The collection where queue contents are copied to\n   * @since 0.11\n   */\n  /*@ pure @*/ public void copyOutputQueue(int index, Collection\u003cObject\u003e to)\n  {\n  \tto.addAll(m_outputQueues[index]);\n  }\n\n  @Override\n  /*@ non_null @*/ public abstract Processor duplicate(boolean with_state);\n  \n  /**\n   * Gets the leaves of a provenance tree\n   * @param root The root of the tree\n   * @return A list of nodes that correspond to the leaves\n   */\n  public static List\u003cProvenanceNode\u003e getLeaves(ProvenanceNode root)\n  {\n    List\u003cProvenanceNode\u003e leaves = new ArrayList\u003cProvenanceNode\u003e();\n    getLeaves(root, leaves);\n    return leaves;\n  }\n  \n  /**\n   * Accumulates the leaves of a provenance tree in a list\n   * @param root The current node in the tree\n   * @param leaves The list of leaves\n   */\n  protected static void getLeaves(ProvenanceNode root, List\u003cProvenanceNode\u003e leaves)\n  {\n    if (root == null)\n    {\n      return;\n    }\n    List\u003cProvenanceNode\u003e children = root.getChildren();\n    if (children.isEmpty())\n    {\n      leaves.add(root);\n    }\n    else\n    {\n      for (ProvenanceNode child : children)\n      {\n        getLeaves(child, leaves);\n      }\n    }\n  }\n  \n  /**\n   * Connects the first output pipe of this processor to the first input pipe\n   * of another processor.\n   * \u003cp\u003e\n   * Java programmers probably won't use this method, but users of the Groovy\n   * language can benefit from its operator overloading conventions, which map\n   * the construct {@code p | q} to {@code p.or(q)}. This can be used to\n   * easily pipe two processors together:\n   * \u003cpre\u003e{@code \n   * def p = (some processor)\n   * def q = (some other processor)\n   * p | q // Connects p to q\n   * }\u003c/pre\u003e\n   * @param p The other processor\n   * @return The other processor\n   * @since 0.10.9\n   */\n  public Processor or(Processor p)\n  {\n  \tConnector.connect(this, p);\n  \treturn p;\n  }\n  \n  /**\n   * Connects the output at index 0 of the current processor to the input\n   * of another processor.\n   * \u003cp\u003e\n   * Java programmers probably won't use this method. However, combined with\n   * the definition of {@link #getAt(int)}, users of the Groovy language\n   * can benefit from its operator overloading conventions, which map\n   * the construct {@code p | q} to {@code p.or(q)}. This can be used to\n   * easily pipe two processors together:\n   * \u003cpre\u003e{@code \n   * def p = (some processor)\n   * def q = (some other processor)\n   * p | q[1] // Connects p to pipe index 1 of q\n   * }\u003c/pre\u003e\n   * The above example works because {@code q[1]} returns {@code q}'s\n   * input pushable for pipe index 1.\n   * @param p The pushable object representing the input of the other processor\n   * to which the current output should be connected.\n   * @return The other processor\n   * @since 0.10.9\n   */\n  public Processor or(SelectedInputPipe p)\n  {\n  \tint index = p.getIndex();\n  \tProcessor proc = p.getProcessor();\n  \tConnector.connect(this, 0, proc, index);\n  \treturn proc;\n  }\n  \n  /**\n   * Gets the {@link PipeSelector} object corresponding to the processor's\n   * input or output pipe for a given index.\n   * \u003cp\u003e\n   * Java programmers probably won't use this method, but users of the Groovy\n   * language can benefit from its operator overloading conventions, which map\n   * the construct {@code p[x]} to {@code p.getAt(x)}. Combined with the\n   * definition of {@link #or(Pushable)}, this can be used to easily pipe two\n   * processors together:\n   * \u003cpre\u003e{@code \n   * def p = (some processor)\n   * def q = (some other processor)\n   * p | q[1] // Connects p to pipe index 1 of q\n   * }\u003c/pre\u003e\n   * @param index The input pipe index\n   * @return The pushable object\n   * @since 0.11\n   * @see #positive()\n   * @see #negative()\n   */\n  /*@ pure non_null @*/ public PipeSelector getAt(int index)\n  {\n  \treturn new PipeSelector(this, index);\n  }\n  \n  public Pushable rightShift(int index)\n  {\n    return getPushableInput(index);\n  }\n  \n  public Pullable leftShift(int index)\n  {\n    return getPullableInput(index);\n  }\n  \n  /**\n   * An object capturing the internal state of a processor,\n   * including the current contents of its input and output queues.\n   * @since 0.10.8\n   */\n  public static class InternalProcessorState\n  {\n  \t/**\n  \t * A map between input pipe indices and the contents of the processor's\n  \t * corresponding input queue.\n  \t */\n  \t/*@ non_null @*/ protected final MathMap\u003cInteger,MathList\u003cObject\u003e\u003e m_inputQueues;\n  \t\n  \t/**\n  \t * A map between output pipe indices and the contents of the processor's\n  \t * corresponding output queue.\n  \t */\n  \t/*@ non_null @*/ protected final MathMap\u003cInteger,MathList\u003cObject\u003e\u003e m_outputQueues;\n  \t\n  \t/**\n  \t * The internal state of the processor itself.\n  \t */\n  \t/*@ null @*/ protected Object m_processorState = null;\n  \t\n  \tpublic InternalProcessorState(Processor p)\n  \t{\n  \t\tsuper();\n  \t\tm_inputQueues = new MathMap\u003cInteger,MathList\u003cObject\u003e\u003e();\n  \t\tm_outputQueues = new MathMap\u003cInteger,MathList\u003cObject\u003e\u003e();\n  \t\tif (p instanceof Stateful)\n  \t\t{\n  \t\t\tm_processorState = ((Stateful) p).getState();\n  \t\t}\n  \t\tfor (int i = 0; i \u003c p.getInputArity(); i++)\n  \t\t{\n  \t\t\tMathList\u003cObject\u003e q = new MathList\u003cObject\u003e();\n  \t\t\tp.copyInputQueue(i, q);\n  \t\t\tm_inputQueues.put(i, q);\n  \t\t}\n  \t\tfor (int i = 0; i \u003c p.getOutputArity(); i++)\n  \t\t{\n  \t\t\tMathList\u003cObject\u003e q = new MathList\u003cObject\u003e();\n  \t\t\tp.copyOutputQueue(i, q);\n  \t\t\tm_outputQueues.put(i, q);\n  \t\t}\n  \t}\n  \t\n  \t@Override\n  \tpublic boolean equals(Object o)\n  \t{\n  \t\tif (!(o instanceof InternalProcessorState))\n  \t\t{\n  \t\t\treturn false;\n  \t\t}\n  \t\tInternalProcessorState ips = (InternalProcessorState) o;\n  \t\tboolean c1 = Equals.isEqualTo(m_processorState, ips.m_processorState);\n  \t\tboolean c2 = Equals.isEqualTo(m_inputQueues, ips.m_inputQueues);\n  \t\tboolean c3 = Equals.isEqualTo(m_outputQueues, ips.m_outputQueues);\n  \t\t// Three conditions separated to facilitate debugging\n  \t\treturn c1 \u0026\u0026 c2 \u0026\u0026 c3;\n  \t}\n  \t\n  \t@Override\n  \tpublic String toString()\n  \t{\n  \t\tStringBuilder out = new StringBuilder();\n  \t\tout.append(\"[\").append(m_inputQueues).append(\",\").append(m_outputQueues);\n  \t\tif (m_processorState != null)\n  \t\t{\n  \t\t\tout.append(\",\").append(m_processorState);\n  \t\t}\n  \t\tout.append(\"]\");\n  \t\treturn out.toString();\n  \t}\n  \t\n  \t@Override\n  \tpublic int hashCode()\n  \t{\n  \t\tint h = 0;\n  \t\tif (m_processorState != null)\n  \t\t{\n  \t\t\th += m_processorState.hashCode();\n  \t\t}\n  \t\th += m_inputQueues.hashCode();\n  \t\th += m_outputQueues.hashCode();\n  \t\treturn h;\n  \t}\n  }\n}\n",
        "name": "Processor.java",
        "path": "Core/src/ca/uqac/lif/cep/Processor.java",
        "url": "/github.com/liflab/beepbeep-3/-/blob/Core/src/ca/uqac/lif/cep/Processor.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 189,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires in_arity \u003e= 0"
        },
        {
          "limitHit": false,
          "lineNumber": 190,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires out_arity \u003e= 0"
        },
        {
          "limitHit": false,
          "lineNumber": 551,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0"
        }
      ],
      "repository": {
        "name": "github.com/liflab/beepbeep-3",
        "url": "/github.com/liflab/beepbeep-3"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "11df50406b53cda57dd922fa70ca1e06b2546859"
        },
        "content": "/*\n    BeepBeep, an event stream processor\n    Copyright (C) 2008-2017 Sylvain Hallé\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\npackage ca.uqac.lif.cep.util;\n\nimport ca.uqac.lif.cep.UniformProcessor;\nimport ca.uqac.lif.cep.functions.Function;\nimport ca.uqac.lif.cep.functions.UnaryFunction;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * A container object for map functions and processors. Some functions come in\n * two flavors:\n * \u003cul\u003e\n * \u003cli\u003eThe \"plain\" function takes as input a map object and returns the\n * \u003cem\u003esame\u003c/em\u003e object, to which a modification has been applied\n * \u003cli\u003eThe \"new\" function takes as input a map object, and returns a \u003cem\u003enew\n * copy\u003c/em\u003e of the object with the modification made to it\u003c/li\u003e\n * \u003c/ul\u003e\n * \n * @author Sylvain Hallé\n * @since 0.7\n */\npublic class Maps\n{\n  /**\n   * Extracts the set of values of a map\n   */\n  public static final transient Values values = new Values();\n  \n  /**\n   * Extracts the multi-set of values of a map\n   */\n  public static final transient MultiValues multiValues = new MultiValues();\n    \n  private Maps()\n  {\n    // Utility class\n  }\n\n  /**\n   * Gets the set of values in a map\n   */\n  @SuppressWarnings(\"rawtypes\")\n  public static class Values extends UnaryFunction\u003cMap, Collection\u003e\n  {\n    /**\n     * A single instance of the function\n     */\n    public static final transient Values instance = new Values();\n\n    protected Values()\n    {\n      super(Map.class, Collection.class);\n    }\n\n    @Override\n    public Collection\u003c?\u003e getValue(Map x)\n    {\n      Collection\u003c?\u003e col = x.values();\n      col.remove(null);\n      return col;\n    }\n  }\n  \n  /**\n   * Gets the multi-set of values in a map. This means that the same\n   * value occurring multiple times will be there multiple times as\n   * well.\n   * @since 0.10.3\n   */\n  @SuppressWarnings(\"rawtypes\")\n  public static class MultiValues extends UnaryFunction\u003cMap, Collection\u003e\n  {\n    /**\n     * A single instance of the function\n     */\n    public static final transient MultiValues instance = new MultiValues();\n\n    protected MultiValues()\n    {\n      super(Map.class, Collection.class);\n    }\n\n    @Override\n    public Collection\u003c?\u003e getValue(Map x)\n    {\n      Multiset set = new Multiset();\n      for (Object o : x.entrySet())\n      {\n        Map.Entry\u003c?,?\u003e e  = (Map.Entry\u003c?,?\u003e) o;\n        set.add(e.getValue());\n      }\n      return set;\n    }\n  }\n\n  /**\n   * Gets a value in the map, based on the name of a key.\n   */\n  @SuppressWarnings(\"rawtypes\")\n  public static class Get extends UnaryFunction\u003cMap, Object\u003e\n  {\n    /**\n     * The key to get from the map\n     */\n    protected String m_key;\n\n    /**\n     * Creates a new get function\n     * \n     * @param key\n     *          The key to get from the map\n     */\n    public Get(String key)\n    {\n      super(Map.class, Object.class);\n      m_key = key;\n    }\n\n    @Override\n    public Object getValue(Map x)\n    {\n      return x.get(m_key);\n    }\n  }\n\n  /**\n   * Updates a map by putting key-value pairs into it. The processor takes two\n   * input streams; the first contains the key, and the second contains the value.\n   */\n  public static class PutInto extends UniformProcessor\n  {\n    /**\n     * The underlying map\n     */\n    protected Map\u003cObject, Object\u003e m_map;\n\n    /**\n     * Create a new instance of the processor\n     */\n    public PutInto()\n    {\n      super(2, 1);\n      m_map = new HashMap\u003cObject, Object\u003e();\n    }\n\n    @Override\n    public void reset()\n    {\n      super.reset();\n      m_map.clear();\n    }\n\n    @Override\n    public PutInto duplicate(boolean with_state)\n    {\n      return new PutInto();\n    }\n\n    @Override\n    protected boolean compute(Object[] inputs, Object[] outputs)\n    {\n      m_map.put(inputs[0], inputs[1]);\n      outputs[0] = m_map;\n      return true;\n    }\n\n    @Override\n    public Class\u003c?\u003e getOutputType(int index)\n    {\n      return Map.class;\n    }\n  }\n\n  /**\n   * Updates a map by putting key-value pairs into it. The processor takes a\n   * single input stream, whose events are \u003cem\u003earrays\u003c/em\u003e. The first element of\n   * the array contains the key, and the second contains the value.\n   */\n  public static class MapPutInto extends UniformProcessor\n  {\n    /**\n     * The underlying map\n     */\n    protected Map\u003cObject, Object\u003e m_map;\n\n    /**\n     * Create a new instance of the processor\n     */\n    public MapPutInto()\n    {\n      super(1, 1);\n      m_map = new HashMap\u003cObject, Object\u003e();\n    }\n\n    @Override\n    public void reset()\n    {\n      super.reset();\n      m_map.clear();\n    }\n\n    @Override\n    public MapPutInto duplicate(boolean with_state)\n    {\n      return new MapPutInto();\n    }\n\n    @Override\n    protected boolean compute(Object[] inputs, Object[] outputs)\n    {\n      m_map.put(((Object[]) inputs[0])[0], ((Object[]) inputs[0])[1]);\n      outputs[0] = m_map;\n      return true;\n    }\n\n    @Override\n    public Class\u003c?\u003e getOutputType(int index)\n    {\n      return Map.class;\n    }\n  }\n\n  /**\n   * Creates a new map by applying a function to all the values of\n   * a map given as input\n   */\n  @SuppressWarnings(\"rawtypes\")\n  public static class ApplyAll extends UnaryFunction\u003cMap,Map\u003e\n  {\n    /**\n     * The function to apply to each value of the map\n     */\n    protected Function m_function;\n\n    /**\n     * Creates a new {@code ApplyAll} function\n     * @param f The function to apply to all the values. Must be\n     * a 1:1 function.\n     */\n    //@ requires f.getInputArity() == 1\n    //@ requires f.getOutputArity() == 1\n    public ApplyAll(/*@ non_null @*/ Function f)\n    {\n      super(Map.class, Map.class);\n      m_function = f;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Map getValue(Map x)\n    {\n      Map\u003cObject,Object\u003e out = new HashMap\u003cObject,Object\u003e();\n      Object[] a_out = new Object[1];\n      for (Object o  : x.entrySet())\n      {\n        Map.Entry\u003cObject,Object\u003e e = (Map.Entry\u003cObject,Object\u003e) o;\n        m_function.evaluate(new Object[]{e.getValue()}, a_out);\n        out.put(e.getKey(), a_out[0]);\n      }\n      return out;\n    }\n  }\n  \n  /**\n   * Updates a map by merging its contents with a stream of incoming maps.\n   * The output of this processor is a map with arbitrary keys, and sets\n   * as values.\n   */\n  public static class MergeMaps extends UniformProcessor\n  {\n    /**\n     * The map that is being updated\n     */\n    protected Map\u003cObject,Set\u003cObject\u003e\u003e m_map;\n    \n    /**\n     * Creates a new merge processor.\n     */\n    public MergeMaps()\n    {\n      super(1, 1);\n      m_map = new HashMap\u003cObject,Set\u003cObject\u003e\u003e();\n    }\n\n    @Override\n    protected boolean compute(Object[] inputs, Object[] outputs)\n    {\n      Map\u003c?,?\u003e m = (Map\u003c?,?\u003e) inputs[0];\n      for (Object m_o : m.entrySet())\n      {\n        if (m_o instanceof Map.Entry)\n        {\n          Map.Entry\u003c?,?\u003e e  = (Map.Entry\u003c?,?\u003e) m_o;\n          Object key = e.getKey();\n          Object value = e.getValue();\n          if (value == null)\n          {\n            outputs[0] = m_map;\n            return true;\n          }\n          Set\u003cObject\u003e s_value;\n          if (m_map.containsKey(key))\n          {\n            s_value = m_map.get(key);\n          }\n          else\n          {\n            s_value = new HashSet\u003cObject\u003e();\n          }\n          if (value instanceof Collection)\n          {\n            s_value.addAll((Collection\u003c?\u003e) value);\n          }\n          else\n          {\n            s_value.add(value);\n          }\n          m_map.put(key, s_value);\n        }\n      }\n      outputs[0] = m_map;\n      return true;\n    }\n    \n    @Override\n    public void reset()\n    {\n      super.reset();\n      m_map.clear();\n    }\n\n    @Override\n    public MergeMaps duplicate(boolean with_state)\n    {\n      MergeMaps mm = new MergeMaps();\n      if (with_state)\n      {\n        for (Map.Entry\u003cObject,Set\u003cObject\u003e\u003e e : m_map.entrySet())\n        {\n          HashSet\u003cObject\u003e new_set = new HashSet\u003cObject\u003e();\n          new_set.addAll(e.getValue());\n          mm.m_map.put(e.getKey(), new_set);\n        }\n      }\n      return mm;\n    }\n  }\n  \n  /**\n   * A map that implements equality based on its contents. Two mathmaps are\n   * equal if they have equal keys, and for each key, the associated value is\n   * equal.\n   *\n   * @param \u003cK\u003e The type of the keys\n   * @param \u003cV\u003e The type of the values\n   */\n  public static class MathMap\u003cK,V\u003e extends HashMap\u003cK,V\u003e\n  {\n\t\t/**\n\t\t * Dummy UID.\n\t\t */\n\t\tprivate static final long serialVersionUID = 1L;\n\t\t\n\t\t@Override\n\t\tpublic boolean equals(Object o)\n\t\t{\n\t\t\tif (!(o instanceof MathMap))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tMathMap\u003c?,?\u003e map = (MathMap\u003c?,?\u003e) o;\n\t\t\tif (map.size() != size())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (Map.Entry\u003cK,V\u003e e : entrySet())\n\t\t\t{\n\t\t\t\tif (!map.containsKey(e.getKey()))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tObject v = map.get(e.getKey());\n\t\t\t\tif (!Equals.isEqualTo(e.getValue(), v))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int hashCode()\n\t\t{\n\t\t\treturn size();\n\t\t}\n  \t\n  }\n}\n",
        "name": "Maps.java",
        "path": "Core/src/ca/uqac/lif/cep/util/Maps.java",
        "url": "/github.com/liflab/beepbeep-3/-/blob/Core/src/ca/uqac/lif/cep/util/Maps.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 259,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires f.getInputArity() == 1"
        },
        {
          "limitHit": false,
          "lineNumber": 260,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires f.getOutputArity() == 1"
        }
      ],
      "repository": {
        "name": "github.com/liflab/beepbeep-3",
        "url": "/github.com/liflab/beepbeep-3"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "11df50406b53cda57dd922fa70ca1e06b2546859"
        },
        "content": "/*\n    BeepBeep, an event stream processor\n    Copyright (C) 2008-2018 Sylvain Hallé\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\npackage ca.uqac.lif.cep.functions;\n\nimport ca.uqac.lif.cep.Connector.Variant;\nimport ca.uqac.lif.cep.Context;\nimport ca.uqac.lif.cep.EventTracker;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * A {@link Function} that raises the arity of another function.\n * Given an \u003ci\u003em\u003c/i\u003e:\u003ci\u003en\u003c/i\u003e function \u003ci\u003ef\u003c/i\u003e, an instance of\n * {@code RaiseArity} \u003ci\u003er\u003c/i\u003e makes \u003ci\u003ef\u003c/i\u003e behave like an\n * \u003ci\u003em\u003c/i\u003e':\u003ci\u003en\u003c/i\u003e function, with \u003ci\u003em\u003c/i\u003e' \u0026gt; \u003ci\u003em\u003c/i\u003e.\n * The extra arguments given to \u003ci\u003er\u003c/i\u003e are simply ignored.\n *  \n * @author Sylvain Hallé\n * @since 0.3\n */\npublic class RaiseArity extends Function\n{\n  /**\n   * The function whose arity is to be raised\n   */\n  /*@ non_null @*/ protected Function m_function;\n\n  /**\n   * The target input arity of the function\n   */\n  protected int m_inArity;\n\n  /**\n   * Creates a new instance of the function\n   * @param arity The target arity\n   * @param f The function to evaluate\n   */\n  //@ requires arity \u003e= 0\n  public RaiseArity(int arity, /*@ non_null @*/ Function f)\n  {\n    super();\n    m_inArity = arity;\n    m_function = f;\n  }\n\n  @Override\n  public void evaluate(Object[] inputs, Object[] outputs)\n  {\n    m_function.evaluate(inputs, outputs);\n  }\n\n  @Override\n  public void evaluate(Object[] inputs, Object[] outputs, Context context, EventTracker tracker)\n  {\n    m_function.evaluate(inputs, outputs, context, tracker);\n  }\n\n  @Override\n  public int getInputArity()\n  {\n    return m_inArity;\n  }\n\n  @Override\n  public int getOutputArity()\n  {\n    return m_function.getOutputArity();\n  }\n\n  @Override\n  public void getInputTypesFor(Set\u003cClass\u003c?\u003e\u003e classes, int index)\n  {\n    if (index \u003e= m_function.getOutputArity())\n    {\n      classes.add(Variant.class);\n    }\n    else\n    {\n      m_function.getInputTypesFor(classes, index);\n    }\n  }\n\n  @Override\n  public Class\u003c?\u003e getOutputTypeFor(int index)\n  {\n    return m_function.getOutputTypeFor(index);\n  }\n\n  @Override\n  public RaiseArity duplicate(boolean with_state)\n  {\n    return new RaiseArity(m_inArity, m_function.duplicate(with_state));\n  }\n\n  /**\n   * @since 0.10.2\n   */\n  @Override\n  public Object printState()\n  {\n    List\u003cObject\u003e list = new ArrayList\u003cObject\u003e(2);\n    list.add(m_function);\n    list.add(m_inArity);\n    return list;\n  }\n\n  /**\n   * @since 0.10.2\n   */\n  @SuppressWarnings(\"unchecked\")\n  public RaiseArity readState(Object o)\n  {\n    List\u003cObject\u003e list = (List\u003cObject\u003e) o;\n    Function func = (Function) list.get(0);\n    RaiseArity ra = new RaiseArity(((Number) list.get(1)).intValue(), func);\n    return ra;\n  }\n}\n",
        "name": "RaiseArity.java",
        "path": "Core/src/ca/uqac/lif/cep/functions/RaiseArity.java",
        "url": "/github.com/liflab/beepbeep-3/-/blob/Core/src/ca/uqac/lif/cep/functions/RaiseArity.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 53,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires arity \u003e= 0"
        }
      ],
      "repository": {
        "name": "github.com/liflab/beepbeep-3",
        "url": "/github.com/liflab/beepbeep-3"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "83644ed63bf2b1cbbdfe085ad7054309e16abe7a"
        },
        "content": "/*\n    BeepBeep, an event stream processor\n    Copyright (C) 2008-2018 Sylvain Hallé\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\npackage ca.uqac.lif.cep.signal;\n\nimport ca.uqac.lif.cep.UniformProcessor;\n\n/**\n * Persists a locally maximal value for a certain amount of time.\n * @author Sylvain Hallé\n */\npublic class Persist extends UniformProcessor\n{\n  protected int m_width;\n  \n  protected float m_lastValue;\n  \n  protected int m_timeSinceLast;\n  \n  /**\n   * Creates a new decay processor\n   * @param width The width of the window\n   */\n  //@ requires width \u003e 0\n  public Persist(int width)\n  {\n    super(1, 1);\n    m_width = width;\n    m_lastValue = 0f;\n    m_timeSinceLast = 0;\n  }\n  \n  @Override\n  protected boolean compute(Object[] inputs, Object[] outputs)\n  {\n    float f = ((Number) inputs[0]).floatValue();\n    m_timeSinceLast++;\n    if (Math.abs(f) \u003e Math.abs(m_lastValue))\n    {\n      m_lastValue = f;\n      m_timeSinceLast = 0;\n    }\n    if (m_timeSinceLast \u003e m_width)\n    {\n      m_lastValue = 0f;\n      m_timeSinceLast = 0;\n    }\n    outputs[0] = m_lastValue;\n    return true;\n  }\n\n  @Override\n  public Persist duplicate(boolean with_state)\n  {\n    Persist d = new Persist(m_width);\n    d.m_context.putAll(getContext());\n    if (with_state)\n    {\n      d.m_lastValue = m_lastValue;\n      d.m_timeSinceLast = m_timeSinceLast;\n    }\n    return d;\n  }\n  \n  @Override\n  public void reset()\n  {\n    super.reset();\n    m_lastValue = 0f;\n    m_timeSinceLast = 0;\n  }\n}\n",
        "name": "Persist.java",
        "path": "Signal/src/ca/uqac/lif/cep/signal/Persist.java",
        "url": "/github.com/liflab/beepbeep-3-palettes/-/blob/Signal/src/ca/uqac/lif/cep/signal/Persist.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 37,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires width \u003e 0"
        }
      ],
      "repository": {
        "name": "github.com/liflab/beepbeep-3-palettes",
        "url": "/github.com/liflab/beepbeep-3-palettes"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 7,
  "ElapsedMilliseconds": 135,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
