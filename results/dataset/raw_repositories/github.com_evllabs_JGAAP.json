{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/evllabs/JGAAP lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "96732816bd919292d0b59afff4a9ffbfdb873f02"
        },
        "content": "/*\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; either version 2 of the License, or\n *    (at your option) any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n/*\n *    Instance.java\n *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand\n *\n */\n\npackage com.jgaap.util;\n\nimport weka.core.*;\n\nimport java.io.Serializable;\nimport java.util.Enumeration;\n\n/**\n * Extension of Weka's Instance class to remove a strange function \n * that repeatedly copies arrays with no possible change in functional or defensive purpose.\n *\n * @author Michael Ryan\n * @version $Revision: 9140 $ \n */\n//There is more of the original instance code here than necessary \n@SuppressWarnings({\"rawtypes\"})\npublic class Instance extends weka.core.Instance\n  implements Copyable, Serializable, RevisionHandler {\n  \n  /** for serialization */\n  static final long serialVersionUID = 1482635194499365122L;\n  \n//  /** Constant representing a missing value. */\n//  protected static final double MISSING_VALUE = Double.NaN;\n//\n//  /** \n//   * The dataset the instance has access to.  Null if the instance\n//   * doesn't have access to any dataset.  Only if an instance has\n//   * access to a dataset, it knows about the actual attribute types.  \n//   */\n//  protected /*@spec_public@*/ Instances m_Dataset;\n//\n//  /** The instance's attribute values. */\n//  protected /*@spec_public non_null@*/ double[] m_AttValues;\n//\n//  /** The instance's weight. */\n//  protected double m_Weight;\n\n  /**\n   * Constructor that copies the attribute values and the weight from\n   * the given instance. Reference to the dataset is set to null.\n   * (ie. the instance doesn't have access to information about the\n   * attribute types)\n   *\n   * @param instance the instance from which the attribute\n   * values and the weight are to be copied \n   */\n  //@ ensures m_Dataset == null;\n  public Instance(/*@non_null@*/ Instance instance) {\n    \n    m_AttValues = instance.m_AttValues;\n    m_Weight = instance.m_Weight;\n    m_Dataset = null;\n  }\n\n  /**\n   * Constructor that inititalizes instance variable with given\n   * values. Reference to the dataset is set to null. (ie. the instance\n   * doesn't have access to information about the attribute types)\n   *\n   * @param weight the instance's weight\n   * @param attValues a vector of attribute values \n   */\n  //@ ensures m_Dataset == null;\n  public Instance(double weight,  /*@non_null@*/ double[]attValues){\n    \n    m_AttValues = attValues;\n    m_Weight = weight;\n    m_Dataset = null;\n  }\n\n  /**\n   * Constructor of an instance that sets weight to one, all values to\n   * be missing, and the reference to the dataset to null. (ie. the instance\n   * doesn't have access to information about the attribute types)\n   *\n   * @param numAttributes the size of the instance \n   */\n  //@ requires numAttributes \u003e 0;    // Or maybe == 0 is okay too?\n  //@ ensures m_Dataset == null;\n  public Instance(int numAttributes) {\n    \n    m_AttValues = new double[numAttributes];\n    for (int i = 0; i \u003c m_AttValues.length; i++) {\n      m_AttValues[i] = MISSING_VALUE;\n    }\n    m_Weight = 1;\n    m_Dataset = null;\n  }\n\n  /**\n   * Returns the attribute with the given index.\n   *\n   * @param index the attribute's index\n   * @return the attribute at the given position\n   * @throws UnassignedDatasetException if instance doesn't have access to a\n   * dataset\n   */ \n  //@ requires m_Dataset != null;\n  public /*@pure@*/ Attribute attribute(int index) {\n   \n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    return m_Dataset.attribute(index);\n  }\n\n  /**\n   * Returns the attribute with the given index. Does the same\n   * thing as attribute().\n   *\n   * @param indexOfIndex the index of the attribute's index \n   * @return the attribute at the given position\n   * @throws UnassignedDatasetException if instance doesn't have access to a\n   * dataset\n   */ \n  //@ requires m_Dataset != null;\n  public /*@pure@*/ Attribute attributeSparse(int indexOfIndex) {\n   \n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    return m_Dataset.attribute(indexOfIndex);\n  }\n\n  /**\n   * Returns class attribute.\n   *\n   * @return the class attribute\n   * @throws UnassignedDatasetException if the class is not set or the\n   * instance doesn't have access to a dataset\n   */\n  //@ requires m_Dataset != null;\n  public /*@pure@*/ Attribute classAttribute() {\n\n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    return m_Dataset.classAttribute();\n  }\n\n  /**\n   * Returns the class attribute's index.\n   *\n   * @return the class index as an integer \n   * @throws UnassignedDatasetException if instance doesn't have access to a dataset \n   */\n  //@ requires m_Dataset != null;\n  //@ ensures  \\result == m_Dataset.classIndex();\n  public /*@pure@*/ int classIndex() {\n    \n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    return m_Dataset.classIndex();\n  }\n\n  /**\n   * Tests if an instance's class is missing.\n   *\n   * @return true if the instance's class is missing\n   * @throws UnassignedClassException if the class is not set or the instance doesn't\n   * have access to a dataset\n   */\n  //@ requires classIndex() \u003e= 0;\n  public /*@pure@*/ boolean classIsMissing() {\n\n    if (classIndex() \u003c 0) {\n      throw new UnassignedClassException(\"Class is not set!\");\n    }\n    return isMissing(classIndex());\n  }\n\n  /**\n   * Returns an instance's class value in internal format. (ie. as a\n   * floating-point number)\n   *\n   * @return the corresponding value as a double (If the \n   * corresponding attribute is nominal (or a string) then it returns the \n   * value's index as a double).\n   * @throws UnassignedClassException if the class is not set or the instance doesn't\n   * have access to a dataset \n   */\n  //@ requires classIndex() \u003e= 0;\n  public /*@pure@*/ double classValue() {\n    \n    if (classIndex() \u003c 0) {\n      throw new UnassignedClassException(\"Class is not set!\");\n    }\n    return value(classIndex());\n  }\n\n  /**\n   * Produces a shallow copy of this instance. The copy has\n   * access to the same dataset. (if you want to make a copy\n   * that doesn't have access to the dataset, use \n   * \u003ccode\u003enew Instance(instance)\u003c/code\u003e\n   *\n   * @return the shallow copy\n   */\n  //@ also ensures \\result != null;\n  //@ also ensures \\result instanceof Instance;\n  //@ also ensures ((Instance)\\result).m_Dataset == m_Dataset;\n  public /*@pure@*/ Object copy() {\n\n    Instance result = new Instance(this);\n    result.m_Dataset = m_Dataset;\n    return result;\n  }\n\n  /**\n   * Returns the dataset this instance has access to. (ie. obtains\n   * information about attribute types from) Null if the instance\n   * doesn't have access to a dataset.\n   *\n   * @return the dataset the instance has accesss to\n   */\n  //@ ensures \\result == m_Dataset;\n  public /*@pure@*/ Instances dataset() {\n\n    return m_Dataset;\n  }\n\n  /**\n   * Deletes an attribute at the given position (0 to \n   * numAttributes() - 1). Only succeeds if the instance does not\n   * have access to any dataset because otherwise inconsistencies\n   * could be introduced.\n   *\n   * @param position the attribute's position\n   * @throws RuntimeException if the instance has access to a\n   * dataset \n   */\n  //@ requires m_Dataset != null;\n  public void deleteAttributeAt(int position) {\n\n    if (m_Dataset != null) {\n      throw new RuntimeException(\"Instance has access to a dataset!\");\n    }\n    forceDeleteAttributeAt(position);\n  }\n\n  /**\n   * Returns an enumeration of all the attributes.\n   *\n   * @return enumeration of all the attributes\n   * @throws UnassignedDatasetException if the instance doesn't\n   * have access to a dataset \n   */\n  //@ requires m_Dataset != null;\n  public /*@pure@*/ Enumeration enumerateAttributes() {\n\n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    return m_Dataset.enumerateAttributes();\n  }\n\n  /**\n   * Tests if the headers of two instances are equivalent.\n   *\n   * @param inst another instance\n   * @return true if the header of the given instance is \n   * equivalent to this instance's header\n   * @throws UnassignedDatasetException if instance doesn't have access to any\n   * dataset\n   */\n  //@ requires m_Dataset != null;\n  public /*@pure@*/ boolean equalHeaders(Instance inst) {\n\n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    return m_Dataset.equalHeaders(inst.m_Dataset);\n  }\n\n  /**\n   * Tests whether an instance has a missing value. Skips the class attribute if set.\n   * @return true if instance has a missing value.\n   * @throws UnassignedDatasetException if instance doesn't have access to any\n   * dataset\n   */\n  //@ requires m_Dataset != null;\n  public /*@pure@*/ boolean hasMissingValue() {\n    \n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      if (i != classIndex()) {\n\tif (isMissing(i)) {\n\t  return true;\n\t}\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Returns the index of the attribute stored at the given position.\n   * Just returns the given value.\n   *\n   * @param position the position \n   * @return the index of the attribute stored at the given position\n   */\n  public /*@pure@*/ int index(int position) {\n\n    return position;\n  }\n\n  /**\n   * Inserts an attribute at the given position (0 to \n   * numAttributes()). Only succeeds if the instance does not\n   * have access to any dataset because otherwise inconsistencies\n   * could be introduced.\n   *\n   * @param position the attribute's position\n   * @throws RuntimeException if the instance has accesss to a\n   * dataset\n   * @throws IllegalArgumentException if the position is out of range\n   */\n  //@ requires m_Dataset == null;\n  //@ requires 0 \u003c= position \u0026\u0026 position \u003c= numAttributes();\n  public void insertAttributeAt(int position) {\n\n    if (m_Dataset != null) {\n      throw new RuntimeException(\"Instance has accesss to a dataset!\");\n    }\n    if ((position \u003c 0) ||\n\t(position \u003e numAttributes())) {\n      throw new IllegalArgumentException(\"Can't insert attribute: index out \"+\n                                         \"of range\");\n    }\n    forceInsertAttributeAt(position);\n  }\n\n  /**\n   * Tests if a specific value is \"missing\".\n   *\n   * @param attIndex the attribute's index\n   * @return true if the value is \"missing\"\n   */\n  public /*@pure@*/ boolean isMissing(int attIndex) {\n\n    if (Double.isNaN(m_AttValues[attIndex])) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Tests if a specific value is \"missing\". Does\n   * the same thing as isMissing() if applied to an Instance.\n   *\n   * @param indexOfIndex the index of the attribute's index \n   * @return true if the value is \"missing\"\n   */\n  public /*@pure@*/ boolean isMissingSparse(int indexOfIndex) {\n\n    if (Double.isNaN(m_AttValues[indexOfIndex])) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Tests if a specific value is \"missing\".\n   * The given attribute has to belong to a dataset.\n   *\n   * @param att the attribute\n   * @return true if the value is \"missing\"\n   */\n  public /*@pure@*/ boolean isMissing(Attribute att) {\n\n    return isMissing(att.index());\n  }\n\n  /**\n   * Tests if the given value codes \"missing\".\n   *\n   * @param val the value to be tested\n   * @return true if val codes \"missing\"\n   */\n  public static /*@pure@*/ boolean isMissingValue(double val) {\n\n    return Double.isNaN(val);\n  }\n\n  /**\n   * Merges this instance with the given instance and returns\n   * the result. Dataset is set to null.\n   *\n   * @param inst the instance to be merged with this one\n   * @return the merged instances\n   */\n  public Instance mergeInstance(Instance inst) {\n\n    int m = 0;\n    double [] newVals = new double[numAttributes() + inst.numAttributes()];\n    for (int j = 0; j \u003c numAttributes(); j++, m++) {\n      newVals[m] = value(j);\n    }\n    for (int j = 0; j \u003c inst.numAttributes(); j++, m++) {\n      newVals[m] = inst.value(j);\n    }\n    return new Instance(1.0, newVals);\n  }\n\n  /**\n   * Returns the double that codes \"missing\".\n   *\n   * @return the double that codes \"missing\"\n   */\n  public /*@pure@*/ static double missingValue() {\n\n    return MISSING_VALUE;\n  }\n\n  /**\n   * Returns the number of attributes.\n   *\n   * @return the number of attributes as an integer\n   */\n  //@ ensures \\result == m_AttValues.length;\n  public /*@pure@*/ int numAttributes() {\n\n    return m_AttValues.length;\n  }\n\n  /**\n   * Returns the number of class labels.\n   *\n   * @return the number of class labels as an integer if the \n   * class attribute is nominal, 1 otherwise.\n   * @throws UnassignedDatasetException if instance doesn't have access to any\n   * dataset\n   */\n  //@ requires m_Dataset != null;\n  public /*@pure@*/ int numClasses() {\n    \n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    return m_Dataset.numClasses();\n  }\n\n  /**\n   * Returns the number of values present. Always the same as numAttributes().\n   *\n   * @return the number of values\n   */\n  //@ ensures \\result == m_AttValues.length;\n  public /*@pure@*/ int numValues() {\n\n    return m_AttValues.length;\n  }\n\n  /** \n   * Replaces all missing values in the instance with the\n   * values contained in the given array. A deep copy of\n   * the vector of attribute values is performed before the\n   * values are replaced.\n   *\n   * @param array containing the means and modes\n   * @throws IllegalArgumentException if numbers of attributes are unequal\n   */\n  public void replaceMissingValues(double[] array) {\n\t \n    if ((array == null) || \n\t(array.length != m_AttValues.length)) {\n      throw new IllegalArgumentException(\"Unequal number of attributes!\");\n    }\n    //freshAttributeVector();\n    for (int i = 0; i \u003c m_AttValues.length; i++) {\n      if (isMissing(i)) {\n\tm_AttValues[i] = array[i];\n      }\n    }\n  }\n\n  /**\n   * Sets the class value of an instance to be \"missing\". A deep copy of\n   * the vector of attribute values is performed before the\n   * value is set to be missing.\n   *\n   * @throws UnassignedClassException if the class is not set\n   * @throws UnassignedDatasetException if the instance doesn't\n   * have access to a dataset\n   */\n  //@ requires classIndex() \u003e= 0;\n  public void setClassMissing() {\n\n    if (classIndex() \u003c 0) {\n      throw new UnassignedClassException(\"Class is not set!\");\n    }\n    setMissing(classIndex());\n  }\n\n  /**\n   * Sets the class value of an instance to the given value (internal\n   * floating-point format).  A deep copy of the vector of attribute\n   * values is performed before the value is set.\n   *\n   * @param value the new attribute value (If the corresponding\n   * attribute is nominal (or a string) then this is the new value's\n   * index as a double).  \n   * @throws UnassignedClassException if the class is not set\n   * @throws UnaddignedDatasetException if the instance doesn't\n   * have access to a dataset \n   */\n  //@ requires classIndex() \u003e= 0;\n  public void setClassValue(double value) {\n\n    if (classIndex() \u003c 0) {\n      throw new UnassignedClassException(\"Class is not set!\");\n    }\n    setValue(classIndex(), value);\n  }\n\n\n  /**\n   * Sets a specific value in the instance to the given value \n   * (internal floating-point format). Performs a deep copy\n   * of the vector of attribute values before the value is set.\n   *\n   * @param attIndex the attribute's index \n   * @param value the new attribute value (If the corresponding\n   * attribute is nominal (or a string) then this is the new value's\n   * index as a double).  \n   */\n  public void setValue(int attIndex, double value) {\n    \n    //freshAttributeVector();\n    m_AttValues[attIndex] = value;\n  }\n\n  /**\n   * Sets a specific value in the instance to the given value \n   * (internal floating-point format). Performs a deep copy\n   * of the vector of attribute values before the value is set.\n   * Does exactly the same thing as setValue().\n   *\n   * @param indexOfIndex the index of the attribute's index \n   * @param value the new attribute value (If the corresponding\n   * attribute is nominal (or a string) then this is the new value's\n   * index as a double).  \n   */\n  public void setValueSparse(int indexOfIndex, double value) {\n    \n    //freshAttributeVector();\n    m_AttValues[indexOfIndex] = value;\n  }\n\n\n\n\n\n\n\n\n\n\n\n\n\n  /**\n   * Returns the values of each attribute as an array of doubles.\n   *\n   * @return an array containing all the instance attribute values\n   */\n  public double[] toDoubleArray() {\n\n    double[] newValues = new double[m_AttValues.length];\n    System.arraycopy(m_AttValues, 0, newValues, 0, \n\t\t     m_AttValues.length);\n    return newValues;\n  }\n\n  /**\n   * Returns the description of one instance. If the instance\n   * doesn't have access to a dataset, it returns the internal\n   * floating-point values. Quotes string\n   * values that contain whitespace characters.\n   *\n   * @return the instance's description as a string\n   */\n  public String toString() {\n\n    StringBuffer text = new StringBuffer();\n    \n    for (int i = 0; i \u003c m_AttValues.length; i++) {\n      if (i \u003e 0) text.append(\",\");\n      text.append(toString(i));\n    }\n\n    if (m_Weight != 1.0) {\n      text.append(\",{\" + Utils.doubleToString(m_Weight, 6) + \"}\");\n    }\n\n    return text.toString();\n  }\n\n  /**\n   * Returns the description of one instance (without weight\n   * appended). If the instance\n   * doesn't have access to a dataset, it returns the internal\n   * floating-point values. Quotes string\n   * values that contain whitespace characters.\n   *\n   * This method is used by getRandomNumberGenerator() in\n   * Instances.java in order to maintain backwards compatibility\n   * with weka 3.4.\n   *\n   * @return the instance's description as a string\n   */\n  protected String toStringNoWeight() {\n    StringBuffer text = new StringBuffer();\n    \n    for (int i = 0; i \u003c m_AttValues.length; i++) {\n      if (i \u003e 0) text.append(\",\");\n      text.append(toString(i));\n    }\n\n    return text.toString();\n  }\n\n\n\n\n  /**\n   * Returns an instance's attribute value in internal format.\n   *\n   * @param attIndex the attribute's index\n   * @return the specified value as a double (If the corresponding\n   * attribute is nominal (or a string) then it returns the value's index as a \n   * double).\n   */\n  public /*@pure@*/ double value(int attIndex) {\n\n    return m_AttValues[attIndex];\n  }\n\n  /**\n   * Returns an instance's attribute value in internal format.\n   * Does exactly the same thing as value() if applied to an Instance.\n   *\n   * @param indexOfIndex the index of the attribute's index\n   * @return the specified value as a double (If the corresponding\n   * attribute is nominal (or a string) then it returns the value's index as a \n   * double).\n   */\n  public /*@pure@*/ double valueSparse(int indexOfIndex) {\n\n    return m_AttValues[indexOfIndex];\n  }  \n\n  /**\n   * Returns an instance's attribute value in internal format.\n   * The given attribute has to belong to a dataset.\n   *\n   * @param att the attribute\n   * @return the specified value as a double (If the corresponding\n   * attribute is nominal (or a string) then it returns the value's index as a\n   * double).\n   */\n  public /*@pure@*/ double value(Attribute att) {\n\n    return value(att.index());\n  }\n\n  /**\n   * Deletes an attribute at the given position (0 to \n   * numAttributes() - 1).\n   *\n   * @param position the attribute's position\n   */\n  void forceDeleteAttributeAt(int position) {\n\n    double[] newValues = new double[m_AttValues.length - 1];\n\n    System.arraycopy(m_AttValues, 0, newValues, 0, position);\n    if (position \u003c m_AttValues.length - 1) {\n      System.arraycopy(m_AttValues, position + 1, \n\t\t       newValues, position, \n\t\t       m_AttValues.length - (position + 1));\n    }\n    m_AttValues = newValues;\n  }\n\n  /**\n   * Inserts an attribute at the given position\n   * (0 to numAttributes()) and sets its value to be missing. \n   *\n   * @param position the attribute's position\n   */\n  void forceInsertAttributeAt(int position)  {\n\n    double[] newValues = new double[m_AttValues.length + 1];\n\n    System.arraycopy(m_AttValues, 0, newValues, 0, position);\n    newValues[position] = MISSING_VALUE;\n    System.arraycopy(m_AttValues, position, newValues, \n\t\t     position + 1, m_AttValues.length - position);\n    m_AttValues = newValues;\n  }\n\n  /**\n   * Private constructor for subclasses. Does nothing.\n   */\n  protected Instance() {\n  }\n  \n  /**\n   * Main method for testing this class.\n   * \n   * @param options the commandline options - ignored\n   */\n  //@ requires options != null;\n  public static void main(String[] options) {\n\n    try {\n\n      // Create numeric attributes \"length\" and \"weight\"\n      Attribute length = new Attribute(\"length\");\n      Attribute weight = new Attribute(\"weight\");\n      \n      // Create vector to hold nominal values \"first\", \"second\", \"third\" \n      FastVector my_nominal_values = new FastVector(3); \n      my_nominal_values.addElement(\"first\"); \n      my_nominal_values.addElement(\"second\"); \n      my_nominal_values.addElement(\"third\"); \n      \n      // Create nominal attribute \"position\" \n      Attribute position = new Attribute(\"position\", my_nominal_values);\n      \n      // Create vector of the above attributes \n      FastVector attributes = new FastVector(3);\n      attributes.addElement(length);\n      attributes.addElement(weight);\n      attributes.addElement(position);\n      \n      // Create the empty dataset \"race\" with above attributes\n      Instances race = new Instances(\"race\", attributes, 0);\n      \n      // Make position the class attribute\n      race.setClassIndex(position.index());\n      \n      // Create empty instance with three attribute values\n      Instance inst = new Instance(3);\n      \n      // Set instance's values for the attributes \"length\", \"weight\", and \"position\"\n      inst.setValue(length, 5.3);\n      inst.setValue(weight, 300);\n      inst.setValue(position, \"first\");\n      \n      // Set instance's dataset to be the dataset \"race\"\n      inst.setDataset(race);\n      \n      // Print the instance\n      System.out.println(\"The instance: \" + inst);\n      \n      // Print the first attribute\n      System.out.println(\"First attribute: \" + inst.attribute(0));\n      \n      // Print the class attribute\n      System.out.println(\"Class attribute: \" + inst.classAttribute());\n      \n      // Print the class index\n      System.out.println(\"Class index: \" + inst.classIndex());\n      \n      // Say if class is missing\n      System.out.println(\"Class is missing: \" + inst.classIsMissing());\n      \n      // Print the instance's class value in internal format\n      System.out.println(\"Class value (internal format): \" + inst.classValue());\n      \n      // Print a shallow copy of this instance\n      Instance copy = (Instance) inst.copy();\n      System.out.println(\"Shallow copy: \" + copy);\n      \n      // Set dataset for shallow copy\n      copy.setDataset(inst.dataset());\n      System.out.println(\"Shallow copy with dataset set: \" + copy);\n      \n      // Unset dataset for copy, delete first attribute, and insert it again\n      copy.setDataset(null);\n      copy.deleteAttributeAt(0);\n      copy.insertAttributeAt(0);\n      copy.setDataset(inst.dataset());\n      System.out.println(\"Copy with first attribute deleted and inserted: \" + copy); \n      \n      // Enumerate attributes (leaving out the class attribute)\n      System.out.println(\"Enumerating attributes (leaving out class):\");\n      Enumeration enu = inst.enumerateAttributes();\n      while (enu.hasMoreElements()) {\n\tAttribute att = (Attribute) enu.nextElement();\n\tSystem.out.println(att);\n      }\n      \n      // Headers are equivalent?\n      System.out.println(\"Header of original and copy equivalent: \" +\n\t\t\t inst.equalHeaders(copy));\n\n      // Test for missing values\n      System.out.println(\"Length of copy missing: \" + copy.isMissing(length));\n      System.out.println(\"Weight of copy missing: \" + copy.isMissing(weight.index()));\n      System.out.println(\"Length of copy missing: \" + \n\t\t\t Instance.isMissingValue(copy.value(length)));\n      System.out.println(\"Missing value coded as: \" + Instance.missingValue());\n\n      // Prints number of attributes and classes\n      System.out.println(\"Number of attributes: \" + copy.numAttributes());\n      System.out.println(\"Number of classes: \" + copy.numClasses());\n\n      // Replace missing values\n      double[] meansAndModes = {2, 3, 0};\n      copy.replaceMissingValues(meansAndModes);\n      System.out.println(\"Copy with missing value replaced: \" + copy);\n\n      // Setting and getting values and weights\n      copy.setClassMissing();\n      System.out.println(\"Copy with missing class: \" + copy);\n      copy.setClassValue(0);\n      System.out.println(\"Copy with class value set to first value: \" + copy);\n      copy.setClassValue(\"third\");\n      System.out.println(\"Copy with class value set to \\\"third\\\": \" + copy);\n      copy.setMissing(1);\n      System.out.println(\"Copy with second attribute set to be missing: \" + copy);\n      copy.setMissing(length);\n      System.out.println(\"Copy with length set to be missing: \" + copy);\n      copy.setValue(0, 0);\n      System.out.println(\"Copy with first attribute set to 0: \" + copy);\n      copy.setValue(weight, 1);\n      System.out.println(\"Copy with weight attribute set to 1: \" + copy);\n      copy.setValue(position, \"second\");\n      System.out.println(\"Copy with position set to \\\"second\\\": \" + copy);\n      copy.setValue(2, \"first\");\n      System.out.println(\"Copy with last attribute set to \\\"first\\\": \" + copy);\n      System.out.println(\"Current weight of instance copy: \" + copy.weight());\n      copy.setWeight(2);\n      System.out.println(\"Current weight of instance copy (set to 2): \" + copy.weight());\n      System.out.println(\"Last value of copy: \" + copy.toString(2));\n      System.out.println(\"Value of position for copy: \" + copy.toString(position));\n      System.out.println(\"Last value of copy (internal format): \" + copy.value(2));\n      System.out.println(\"Value of position for copy (internal format): \" + \n\t\t\t copy.value(position));\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n  \n  /**\n   * Returns the revision string.\n   * \n   * @return\t\tthe revision\n   */\n  public String getRevision() {\n    return RevisionUtils.extract(\"$Revision: 9140 $\");\n  }\n}\n",
        "name": "Instance.java",
        "path": "src/com/jgaap/util/Instance.java",
        "url": "/github.com/evllabs/JGAAP/-/blob/src/com/jgaap/util/Instance.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 69,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Dataset == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 85,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Dataset == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 100,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires numAttributes \u003e 0;    // Or maybe == 0 is okay too?"
        },
        {
          "limitHit": false,
          "lineNumber": 101,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Dataset == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 120,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 138,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 154,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 169,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 186,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 205,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 239,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Dataset;"
        },
        {
          "limitHit": false,
          "lineNumber": 255,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 271,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 289,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 304,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 343,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 344,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= position \u0026\u0026 position \u003c= numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 445,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_AttValues.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 459,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 473,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_AttValues.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 511,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 532,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 739,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires options != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 170,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  \\result == m_Dataset.classIndex();"
        }
      ],
      "repository": {
        "name": "github.com/evllabs/JGAAP",
        "url": "/github.com/evllabs/JGAAP"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 24,
  "ElapsedMilliseconds": 995,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
