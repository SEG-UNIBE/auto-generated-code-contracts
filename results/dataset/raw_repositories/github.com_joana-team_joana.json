{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/joana-team/joana lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d49d82b5892f9331d37432d02d090f28feab56ea"
        },
        "content": "/**\n * This file is part of the Joana IFC project. It is developed at the\n * Programming Paradigms Group of the Karlsruhe Institute of Technology.\n *\n * For further details on licensing please read the information at\n * http://joana.ipd.kit.edu or contact the authors.\n */\n/*\n * This file is part of the Daisy distribution.  This software is\n * distributed 'as is' without any guarantees whatsoever. It may be\n * used freely for research but may not be used in any commercial\n * products.  The contents of this distribution should not be posted\n * on the web or distributed without the consent of the authors.\n *\n * Authors: Cormac Flanagan, Stephen N. Freund, Shaz Qadeer\n * Contact: Shaz Qadeer (qadeer@microsoft.com)\n */\n\n/** Some design decisions:\n\tC-style error handling (return -1, null, etc, no exceptions).\n\tMostly ignore error cases, for now.\n\tC and UNIX style identifiers, function names.\n\tNo buffering/caching\n\tRead/write one byte at a time\n\tNo hard links, keep file names in inodes.\n\tFile names are 8 chars, packed into a long.\n\t1 directory.\n  \t1 block per file (ie virtual disk)\n\tNo owner/permissions/access times\n\tDistributed filesystem\n\n    Open issues:\n\tFile and record locking primitives to clients\n\tCan have multiple files open?\n\tMinimum use of dynamic memory allocation (have fixed set of\n\tin-core Inodes, etc.)\n\n    Standard routines not needed/implemented\n        bmap\n\tdup, pipe, chdir, chroot, chmod, stat, link, mknod, mount, umount\n\n*/\n\npackage conc.daisy;\n\nimport java.util.Vector;\n\nclass LockManager {\n    // Java only has signed longs\n    public static final long SIZE = 0x7fffffff /*2^63*/;\n\n    private static Vector\u003cMutex\u003e plocks = new Vector\u003cMutex\u003e(0);\n    private static Mutex m = new Mutex(-1);\n\n    //@ ghost public static long -\u003e Thread locks\n\n    //@ requires 0 \u003c= lockno \u0026\u0026 lockno \u003c SIZE\n    /*@ performs action \"act\" (locks[lockno]) {\n          \\old(locks)[lockno] == null \u0026\u0026 locks[lockno] == \\tid\n        }\n     */\n    public static void acq(long lockno) {\n        if (lockno \u003e= plocks.size() || plocks.get((int)lockno) == null) {\n            m.acq();\n            if (lockno \u003e= plocks.size()) {\n                plocks.setSize((int)lockno + 100);\n            }\n            if (plocks.get((int)lockno) == null) {\n                plocks.setElementAt(new Mutex((int)lockno), (int)lockno);\n            }\n            m.rel();\n        }\n        plocks.get((int)lockno).acq();\n    }\n\n    //@ requires 0 \u003c= lockno \u0026\u0026 lockno \u003c SIZE\n    //@ requires locks[lockno] == \\tid\n    /*@ performs action \"act\" (locks[lockno]) {\n          locks[lockno] == null\n        }\n     */\n    public static void rel(long lockno) {\n        plocks.get((int)lockno).rel();\n    }\n}\n\n/*@ thread_local */\nclass Inode {\n    // No owner/permissions/access times\n    // Almost always kept flushed\n    // invariant 0 \u003c= blockno \u0026\u0026 blockno \u003c Daisy.MAXBLOCK\n    long blockno;\n\n    // invariant 0 \u003c= size \u0026\u0026 size \u003c= Daisy.BLOCKSIZE\n    long size;\n    boolean used;\n\n    // following fields just in in-core copy\n    // in-core copy only exists if inode is locked\n    // invariant 0 \u003c= inodenum \u0026\u0026 inodenum \u003c Daisy.MAXINODE\n    long inodenum;\n\n    public String toString() {\n        return\n        \"[inodenum=0x\" + Long.toHexString(inodenum)+\n        \", blockno=\" + blockno +\n        \", size=\" + size +\n        \", used=\" + used + \"]\";\n    }\n}\n\nclass DaisyLock {\n    // Split LockManager into sections, also:\n    // locks 0 .. MAXINODE-1 are for inodes\n    // locks MAXINODE .. MAXINODE+MAXBLOCK-1 are for blocks\n\n    static final long STARTINODELOCKAREA = 0;\n    static final long   ENDINODELOCKAREA = STARTINODELOCKAREA + Daisy.MAXINODE;\n    static final long STARTBLOCKLOCKAREA = ENDINODELOCKAREA;\n    static final long   ENDBLOCKLOCKAREA = STARTBLOCKLOCKAREA + Daisy.MAXBLOCK;\n    static final long STARTFILELOCKAREA = ENDBLOCKLOCKAREA;\n    static final long   ENDFILELOCKAREA = STARTFILELOCKAREA + Daisy.MAXINODE;\n\n    //-----------------------------------------\n    // ops on locks corresponding to inodes\n\n    //@ ghost /*@ guarded_by[i] inodeLocks[i] == \\tid */ public static long -\u003e Thread inodeLocks\n\n    //@ requires 0 \u003c= inodenum \u0026\u0026 inodenum \u003c Daisy.MAXINODE\n    /*@ performs action \"act\" (inodeLocks[inodenum]) {\n          \\old(inodeLocks)[inodenum] == null \u0026\u0026 inodeLocks[inodenum] == \\tid\n\t}\n     */\n    static void acqi(long inodenum) {\n        LockManager.acq(STARTINODELOCKAREA+inodenum);\n    } // nowarn Post\n\n    //@ requires 0 \u003c= inodenum \u0026\u0026 inodenum \u003c Daisy.MAXINODE;\n    //@ requires inodeLocks[inodenum] == \\tid\n    /*@ performs action \"act\" (inodeLocks[inodenum]) {\n          inodeLocks[inodenum] == null\n\t}\n     */\n    static void reli(long inodenum) {\n        LockManager.rel(STARTINODELOCKAREA+inodenum);\n    } // nowarn Post\n\n    //-----------------------------------------\n    // ops on locks corresponding to blocks (covers both alloc bit \u0026 block)\n\n    //@ ghost /*@ guarded_by[i] blockLocks[i] == \\tid */ public static long -\u003e Thread blockLocks\n\n    //@ requires 0 \u003c= blockno \u0026\u0026 blockno \u003c Daisy.MAXBLOCK\n    /*@ performs action \"act\" (blockLocks[blockno]) {\n          \\old(blockLocks)[blockno] == null \u0026\u0026 blockLocks[blockno] == \\tid\n\t}\n     */\n    static void acqb(long blockno) {\n        LockManager.acq(STARTBLOCKLOCKAREA+blockno);\n    } // nowarn Post\n\n    //@ requires 0 \u003c= blockno \u0026\u0026 blockno \u003c Daisy.MAXBLOCK\n    //@ requires blockLocks[blockno] == \\tid\n    /*@ performs action \"act\" (blockLocks[blockno]) {\n          blockLocks[blockno] == null\n\t}\n     */\n    static void relb(long blockno) {\n        LockManager.rel(STARTBLOCKLOCKAREA+blockno);\n    } // nowarn Post\n\n\n    //-----------------------------------------\n    // ops on locks corresponding to blocks (covers both alloc bit \u0026 block)\n\n    //@ ghost /*@ guarded_by[i] fileLocks[i] == \\tid */ public static long -\u003e Thread fileLocks\n\n    //@ requires 0 \u003c= inodenum \u0026\u0026 inodenum \u003c Daisy.MAXINODE\n    /*@ performs action \"act\" (fileLocks[inodenum]) {\n          \\old(fileLocks)[inodenum] == null \u0026\u0026 fileLocks[inodenum] == \\tid\n\t}\n     */\n    public static void lock_file(long inodenum) {\n        LockManager.acq(STARTFILELOCKAREA+inodenum);\n    }\n\n    //@ requires 0 \u003c= inodenum \u0026\u0026 inodenum \u003c Daisy.MAXINODE;\n    //@ requires fileLocks[inodenum] == \\tid\n    /*@ performs action \"act\" (fileLocks[inodenum]) {\n          fileLocks[inodenum] == null\n\t}\n     */\n    public static void unlock_file(long inodenum) {\n        LockManager.rel(STARTFILELOCKAREA+inodenum);\n    }\n}\n\nclass DaisyDisk {\n    //========================================================\n    // Splits Petal into sections, much like Frangipani\n\n    static final long STARTINODEAREA = 0;\n    static final long   ENDINODEAREA = STARTINODEAREA + Daisy.MAXINODE * Daisy.INODESIZE;\n    static final long STARTBLOCKAREA = ENDINODEAREA;\n\n    static final long   ENDBLOCKAREA = STARTBLOCKAREA + Daisy.MAXBLOCK * Daisy.BLOCKSIZE;\n\n    static final long STARTALLOCAREA = ENDBLOCKAREA;\n    static final long   ENDALLOCAREA = STARTALLOCAREA + Daisy.MAXBLOCK/8;\n\n    //@ ghost /*@ guarded_by[i] DaisyLock.inodeLocks[i] == \\tid */ public static long -\u003e long inodeSizes\n    //@ ghost /*@ guarded_by[i] DaisyLock.inodeLocks[i] == \\tid */ public static long -\u003e long inodeBlocknos\n    //@ ghost /*@ guarded_by[i] DaisyLock.inodeLocks[i] == \\tid */ public static long -\u003e boolean inodeUsed\n\n    /* global_invariant (\\forall int i; inodeLocks[i] == null ==\u003e 0 \u003c= inodeBlocknos[i] \u0026\u0026 inodeBlocknos[i] \u003c Daisy.MAXBLOCK) */\n\n    //@ requires 0 \u003c= inodenum \u0026\u0026 inodenum \u003c Daisy.MAXINODE;\n    //@ requires i != null\n    //@ requires DaisyLock.inodeLocks[inodenum] == \\tid\n    //@ modifies i.blockno, i.size, i.used, i.inodenum\n    //@ ensures i.blockno  == inodeBlocknos[inodenum]\n    //@ ensures i.size     == inodeSizes[inodenum]\n    //@ ensures i.used     == inodeUsed[inodenum]\n    //@ ensures i.inodenum == inodenum\n    //@ ensures 0 \u003c= i.blockno \u0026\u0026 i.blockno \u003c Daisy.MAXBLOCK\n    static void readi(long inodenum, Inode i) {\n        i.blockno = Petal.readLong(STARTINODEAREA +\n                (inodenum * Daisy.INODESIZE));\n        i.size= Petal.readLong(STARTINODEAREA +\n                (inodenum * Daisy.INODESIZE) + 8);\n        i.used = Petal.read(STARTINODEAREA +\n                (inodenum * Daisy.INODESIZE) + 16) == 1;\n        i.inodenum = inodenum;\n        // read the right bytes, put in inode\n    } //@ nowarn Post\n\n    //@ requires i != null\n    //@ requires DaisyLock.inodeLocks[i.inodenum] == \\tid\n    //@ modifies inodeBlocknos[i.inodenum], inodeUsed[i.inodenum], inodeSizes[i.inodenum]\n    //@ ensures i.blockno  == inodeBlocknos[i.inodenum]\n    //@ ensures i.size     == inodeSizes[i.inodenum]\n    //@ ensures i.used     == inodeUsed[i.inodenum]\n    static void writei(Inode i) {\n        Petal.writeLong(STARTINODEAREA +\n                (i.inodenum * Daisy.INODESIZE), i.blockno);\n        Petal.writeLong(STARTINODEAREA +\n                (i.inodenum * Daisy.INODESIZE) + 8, i.size);\n        Petal.write(STARTINODEAREA +\n                (i.inodenum * Daisy.INODESIZE) + 16,\n                (byte)(i.used ? 1 : 0));\n    } //@ nowarn Post\n\n    // bits indicating block allocation status\n    //@ ghost /*@ guarded_by[i] DaisyLock.blockLocks[i] == \\tid */ public static long -\u003e boolean allocBit\n\n    //@ requires 0 \u003c= blockno \u0026\u0026 blockno \u003c Daisy.MAXBLOCK\n    //@ requires DaisyLock.blockLocks[blockno] == \\tid\n    //@ ensures \\result == allocBit[blockno]\n    static boolean readAllocBit(long blockno) {\n        return (Petal.read( STARTALLOCAREA+blockno/8 ) \u0026  (1\u003c\u003c(blockno \u0026 7))) != 0;\n    } //@ nowarn Post\n\n    //@ requires 0 \u003c= blockno \u0026\u0026 blockno \u003c Daisy.MAXBLOCK\n    //@ requires DaisyLock.blockLocks[blockno] == \\tid\n    //@ modifies allocBit[blockno]\n    //@ ensures allocBit[blockno] == bit\n    static void writeAllocBit(long blockno, boolean bit) {\n        byte b = Petal.read( STARTALLOCAREA+blockno/8 );\n        byte mask = (byte)(1\u003c\u003c(blockno \u0026 7));\n        b = bit ? (byte)(b | mask) : (byte)(b \u0026 ~mask);\n        Petal.write( STARTALLOCAREA+blockno/8, b );\n    } //@ nowarn Post\n\n    //@ ghost /*@ guarded_by[i][j] DaisyLock.blockLocks[i] == \\tid */ public static long -\u003e long -\u003e byte blocks\n\n    //@ requires 0 \u003c= blockno \u0026\u0026 blockno \u003c Daisy.MAXBLOCK\n    //@ requires 0 \u003c= offset \u0026\u0026 offset \u003c Daisy.BLOCKSIZE\n    //@ requires DaisyLock.blockLocks[blockno] == \\tid\n    //@ ensures \\result == blocks[blockno][offset]\n    static byte readBlockByte(long blockno, long offset) {\n        return Petal.read( STARTBLOCKAREA + blockno * Daisy.BLOCKSIZE + offset );\n    } //@ nowarn Post\n\n    //@ requires 0 \u003c= blockno \u0026\u0026 blockno \u003c Daisy.MAXBLOCK\n    //@ requires 0 \u003c= offset \u0026\u0026 offset \u003c Daisy.BLOCKSIZE\n    //@ requires DaisyLock.blockLocks[blockno] == \\tid\n    //@ modifies blocks[blockno][offset]\n    //@ ensures b == blocks[blockno][offset]\n    static void writeBlockByte(long blockno, long offset, byte b) {\n        Petal.write( STARTBLOCKAREA + blockno * Daisy.BLOCKSIZE + offset, b );\n    } //@ nowarn Post\n}\n\npublic class Daisy {\n\n    public static final long MAXINODE  = 64;\n    public static final long MAXBLOCK = 64;\n\n    public static final int  INODESIZE = 24;    // 2 longs + boolean\n    public static final long BLOCKSIZE = 1024 * 10;\n\n    /*@\n      axiom MAXINODE \u003e 0;\n      axiom MAXBLOCK \u003e 0;\n     */\n\n    // error codes for Daisy functions.  These are\n    // the negated values of the standard NFS error codes.\n    static final int DAISY_ERR_OK = -0;\n    static final int DAISY_ERR_NOENT = -2;\n    static final int DAISY_ERR_BADHANDLE = -2;\n    static final int DAISY_ERR_EXIST = -17;\n    static final int DAISY_ERR_FBIG = -27;\n    static final int DAISY_ERR_NOSPC = -28;\n\n\n    //====================================================\n    // Lower level routines on inodes\n\n    // returns locked inode\n    //@ helper\n    static Inode iget(long inodenum) {\n        Inode p = new Inode();\n        DaisyLock.acqi(inodenum);\n        DaisyDisk.readi(inodenum, p);\n        return p;\n    }\n\n    // flushes Inode to disk and unlocks\n    //@ helper\n    static void iput(Inode inode) {\n        DaisyDisk.writei(inode);\n        DaisyLock.reli(inode.inodenum);\n    }\n\n    // returns locked inode, or null\n    // uses dumb, sequential search thru inodes\n    // modifies DaisyLock.inodeLocks[\\result.inodenum];\n    /*@\n      performs\n      action \"act1\" () { \\result == null }\n      []\n      action \"act2\" (DaisyLock.inodeLocks[\\result.inodenum]) {\n          ( \\old(DaisyLock.inodeLocks)[\\result.inodenum] == null \u0026\u0026\n            DaisyLock.inodeLocks[\\result.inodenum] == \\tid \u0026\u0026\n            !\\old(DaisyDisk.inodeUsed)[\\result.inodenum] \u0026\u0026\n            \\result.used \u0026\u0026\n\t    0 \u003c= \\result.inodenum \u0026\u0026 \\result.inodenum \u003c MAXINODE)\n      };\n     */\n    static Inode ialloc() {\n        for(long i=0; i\u003cMAXINODE; i++) {\n            Inode p = iget(i);\n            if( !p.used ) {\n                p.used = true;\n                //@ set \\witness = \"act2\"\n                return p;\n            }\n            DaisyLock.reli(i);\n        }\n        //@ set \\witness = \"act1\"\n        return null;\n    }\n\n    // takes allocated + locked inode, and unlocks and frees it\n    //@ helper\n    static void ifree(Inode inode) {\n        inode.used = false;\n        iput(inode);\n    }\n\n    static public void init() {\n        byte b[] = { 0,0,0,0,0,0,0,0 };\n        creat();\n        //        write(0, 0, 8, b);\n    }\n\n    //====================================================\n    // Lower level routines on blocks\n\n    // allocate a disk block\n    // modifies DaisyDisk.allocBit[\\result])\n    /*@\n      performs\n      action \"act1\" () { \\result == -1 }\n      []\n      action \"act2\" (DaisyDisk.allocBit[\\result]) {\n\t  (0 \u003c= \\result \u0026\u0026 \\result \u003c MAXBLOCK \u0026\u0026\n\t   !\\old(DaisyDisk.allocBit)[\\result] \u0026\u0026 DaisyDisk.allocBit[\\result] \u0026\u0026\n\t   \\old(DaisyLock.blockLocks)[\\result] == null)\n      }\n     */\n    static long alloc() {\n        for(long i=0; i\u003cMAXBLOCK; i++) {\n            DaisyLock.acqb(i);\n            if( DaisyDisk.readAllocBit(i) == false ) {\n                DaisyDisk.writeAllocBit( i, true );\n                DaisyLock.relb(i);\n                //@ set \\witness = \"act2\"\n                return i;\n            }\n            DaisyLock.relb(i);\n        }\n        //@ set \\witness = \"act1\"\n        return -1;\n    }\n\n    //@ helper\n    static void free(long blockno) {\n        DaisyLock.acqb(blockno);\n        DaisyDisk.writeAllocBit( blockno, false );\n        DaisyLock.relb(blockno);\n    }\n\n\n    //@ helper\n    public static void read(Inode inode, int offset, int size, byte b[]) {\n        DaisyLock.acqb( inode.blockno );\n        long blk = inode.blockno;\n        int i;\n        for (i = 0; i \u003c size \u0026\u0026 (offset + i \u003c inode.size); i++) {\n            b[i] = DaisyDisk.readBlockByte( blk, offset + i );\n        }\n        DaisyLock.relb( inode.blockno );\n    }\n\n    //@ helper\n    public static void write(Inode inode, int offset, int size, byte b[]) {\n        DaisyLock.acqb( inode.blockno );\n        long blk = inode.blockno;\n        int i;\n        for (i = 0; i \u003c size; i++) {\n            DaisyDisk.writeBlockByte( blk, offset + i, b[i]);\n        }\n\n        if( inode.size \u003c offset + size) {\n            inode.size = offset + size;\n            DaisyDisk.writei(inode);\n        }\n        DaisyLock.relb( inode.blockno );\n    }\n\n    //@ helper\n    public static void get_attr(Inode inode, Attribute a) {\n        a.size = inode.size;\n    }\n\n    //@ helper\n    public static void set_attr(Inode inode, Attribute a) {\n        inode.size = a.size;\n        iput(inode);\n    }\n\n\n\n    //===================================================\n    // Higher level routines\n\n    //@ ghost /*@ guarded_by[i][j] DaisyLock.inodeLocks[i] == \\tid */ public long -\u003e long -\u003e byte inodeContents\n\n    /*@\n      performs\n      action \"act1\" () { \\result == DAISY_ERR_NOSPC }\n      []\n      action \"act2\" (DaisyDisk.inodeUsed[\\result],\n                     DaisyDisk.inodeBlocknos[\\result],\n\t\t     DaisyDisk.allocBit[DaisyDisk.inodeBlocknos[\\result]]) {\n\t    \\old(DaisyLock.inodeLocks)[\\result] == null \u0026\u0026\n\t    DaisyLock.blockLocks[DaisyDisk.inodeBlocknos[\\result]] == null \u0026\u0026\n\t    !\\old(DaisyDisk.inodeUsed)[\\result] \u0026\u0026\n\t    DaisyDisk.inodeUsed[\\result] \u0026\u0026\n\t    !\\old(DaisyDisk.allocBit)[DaisyDisk.inodeBlocknos[\\result]] \u0026\u0026\n\t    DaisyDisk.allocBit[DaisyDisk.inodeBlocknos[\\result]]\n      }\n     */\n    //@ helper\n    public static long creat() {\n        Inode inode = ialloc();\n        if( inode == null ) {\n            // set \\witness = \"act1\"\n            return DAISY_ERR_NOSPC;\n        }\n        // assert DaisyLock.inodeLocks[inode.inodenum] == \\tid\n        long blockno = alloc();\n        if( blockno == -1 ) {\n            //@ assert DaisyLock.inodeLocks[inode.inodenum] == \\tid\n            ifree(inode);\n            // set \\witness = \"act1\"\n            return DAISY_ERR_NOSPC;\n        }\n        inode.blockno = blockno;\n        inode.size = 0;\n        iput(inode);\n        // set \\witness = \"act2\"\n        return inode.inodenum;\n    }\n\n    /*@\n      performs\n      action \"act1\" () { \\result != DAISY_ERR_OK }\n      []\n      action \"act2\" (DaisyDisk.inodeUsed[inodenum],\n                     DaisyDisk.inodeBlocknos[inodenum],\n\t\t     DaisyDisk.allocBit[DaisyDisk.inodeBlocknos[inodenum]]) {\n\t\t     ( !DaisyDisk.inodeUsed[inodenum] \u0026\u0026\n\t\t       !DaisyDisk.allocBit[\\old(DaisyDisk.inodeBlocknos)[inodenum]] )\n      }\n     */\n    public static int unlink(long inodenum) {\n        if (inodenum \u003c 0 || inodenum \u003e= MAXINODE) {\n            //@ set \\witness = \"act1\"\n            return DAISY_ERR_BADHANDLE;\n        }\n\n        Inode inode = iget(inodenum);\n        if ( inode == null ) {\n            //@ set \\witness = \"act1\"\n            return DAISY_ERR_NOENT;\n        }\n        inode.used = false;\n        free( inode.blockno );\n        iput( inode );\n        //@ set \\witness = \"act2\"\n        return DAISY_ERR_OK;\n    }\n\n    //@ helper\n    public static int get_attr(long inodenum, Attribute a) {\n        if (inodenum \u003c 0 || inodenum \u003e= MAXINODE) {\n            return DAISY_ERR_BADHANDLE;\n        }\n\n        Inode inode = iget( inodenum );\n        if (inode == null) {\n            return DAISY_ERR_NOENT;\n        }\n        if (!inode.used) {\n            DaisyLock.reli( inodenum );\n            return DAISY_ERR_NOENT;\n        }\n        get_attr(inode, a);\n        DaisyLock.reli (inodenum);\n        return DAISY_ERR_OK;\n    }\n\n    //@ helper\n    public static int set_attr(long inodenum, Attribute a) {\n        if (inodenum \u003c 0 || inodenum \u003e= MAXINODE) {\n            return DAISY_ERR_BADHANDLE;\n        }\n\n        Inode inode = iget( inodenum );\n        if (inode == null) {\n            return DAISY_ERR_NOENT;\n        }\n        if (!inode.used) {\n            DaisyLock.reli( inodenum );\n            return DAISY_ERR_NOENT;\n        }\n        set_attr(inode, a);\n        return DAISY_ERR_OK;\n    }\n\n    /* performs action \"act\" () {\n            \\result == DAISY_ERR_BADHANDLE ||\n\t    (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c size ==\u003e b[i] == inodeContents[inodenum][offset+i])\n        }\n     */\n    public static int read(long inodenum, int offset, int size, byte b[]) {\n        if (inodenum \u003c 0 || inodenum \u003e= MAXINODE) {\n            return DAISY_ERR_BADHANDLE;\n        }\n\n        Inode inode = iget( inodenum );\n        if (!inode.used) {\n            DaisyLock.reli( inodenum );\n            return DAISY_ERR_BADHANDLE;\n        }\n        read(inode, offset, size, b);\n        DaisyLock.reli( inode.inodenum );\n        return DAISY_ERR_OK;\n    }\n\n    /* performs action \"act\" (inodeContents[inodenum]) {\n            \\result == DAISY_ERR_FBIG ||\n            \\result == DAISY_ERR_BADHANDLE ||\n\t    (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c size ==\u003e b[i] == inodeContents[inodenum][offset+i])\n        }\n     */\n    public static int write(long inodenum, int offset, int size, byte b[]) {\n        if (offset + size \u003e BLOCKSIZE) {\n            return DAISY_ERR_FBIG;\n        }\n        if (inodenum \u003c 0 || inodenum \u003e= MAXINODE) {\n            return DAISY_ERR_BADHANDLE;\n        }\n\n        Inode inode = iget( inodenum );\n        if (!inode.used) {\n            DaisyLock.reli( inodenum );\n            return DAISY_ERR_BADHANDLE;\n        }\n        write(inode, offset, size, b);\n        DaisyLock.reli( inode.inodenum );\n        return DAISY_ERR_OK;\n    }\n\n    public static void dumpDisk() {\n        for(long i=0; i\u003cMAXINODE; i++) {\n            Inode p = iget(i);\n            if (p.used) {\n                System.out.println(\" inode \" + i + \": \" + p.toString());\n            }\n            DaisyLock.reli(i);\n        }\n\n        for(long i=0; i\u003cMAXBLOCK; i++) {\n            String s = \"\";\n            String t = \"\";\n            DaisyLock.acqb(i);\n            if (DaisyDisk.readAllocBit(i)) {\n                s += \" block \" + i + \": \";\n                for (int j = 0; j \u003c 16; j++) {\n                    if (j % 4 == 0 \u0026\u0026 j \u003e 0) s += \" \";\n                    int n = (int)DaisyDisk.readBlockByte(i, j);\n                    if (n \u003c 0x10 \u0026\u0026 n \u003e= 0) {\n                        s += \"0\";\n                    }\n                    s += Integer.toHexString(n \u0026 0xff);\n                    t += (char)n;\n                }\n                System.out.println(s + \" | \" + t);\n            }\n            DaisyLock.relb(i);\n        }\n    }\n}\n",
        "name": "Daisy.java",
        "path": "example/joana.example.many-small-progs/src/conc/daisy/Daisy.java",
        "url": "/github.com/joana-team/joana/-/blob/example/joana.example.many-small-progs/src/conc/daisy/Daisy.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 56,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= lockno \u0026\u0026 lockno \u003c SIZE"
        },
        {
          "limitHit": false,
          "lineNumber": 75,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= lockno \u0026\u0026 lockno \u003c SIZE"
        },
        {
          "limitHit": false,
          "lineNumber": 76,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires locks[lockno] == \\tid"
        },
        {
          "limitHit": false,
          "lineNumber": 128,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= inodenum \u0026\u0026 inodenum \u003c Daisy.MAXINODE"
        },
        {
          "limitHit": false,
          "lineNumber": 137,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= inodenum \u0026\u0026 inodenum \u003c Daisy.MAXINODE;"
        },
        {
          "limitHit": false,
          "lineNumber": 138,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires inodeLocks[inodenum] == \\tid"
        },
        {
          "limitHit": false,
          "lineNumber": 152,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= blockno \u0026\u0026 blockno \u003c Daisy.MAXBLOCK"
        },
        {
          "limitHit": false,
          "lineNumber": 161,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= blockno \u0026\u0026 blockno \u003c Daisy.MAXBLOCK"
        },
        {
          "limitHit": false,
          "lineNumber": 162,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires blockLocks[blockno] == \\tid"
        },
        {
          "limitHit": false,
          "lineNumber": 177,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= inodenum \u0026\u0026 inodenum \u003c Daisy.MAXINODE"
        },
        {
          "limitHit": false,
          "lineNumber": 186,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= inodenum \u0026\u0026 inodenum \u003c Daisy.MAXINODE;"
        },
        {
          "limitHit": false,
          "lineNumber": 187,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires fileLocks[inodenum] == \\tid"
        },
        {
          "limitHit": false,
          "lineNumber": 216,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= inodenum \u0026\u0026 inodenum \u003c Daisy.MAXINODE;"
        },
        {
          "limitHit": false,
          "lineNumber": 217,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires i != null"
        },
        {
          "limitHit": false,
          "lineNumber": 218,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires DaisyLock.inodeLocks[inodenum] == \\tid"
        },
        {
          "limitHit": false,
          "lineNumber": 220,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures i.blockno  == inodeBlocknos[inodenum]"
        },
        {
          "limitHit": false,
          "lineNumber": 221,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures i.size     == inodeSizes[inodenum]"
        },
        {
          "limitHit": false,
          "lineNumber": 222,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures i.used     == inodeUsed[inodenum]"
        },
        {
          "limitHit": false,
          "lineNumber": 223,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures i.inodenum == inodenum"
        },
        {
          "limitHit": false,
          "lineNumber": 224,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures 0 \u003c= i.blockno \u0026\u0026 i.blockno \u003c Daisy.MAXBLOCK"
        },
        {
          "limitHit": false,
          "lineNumber": 236,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires i != null"
        },
        {
          "limitHit": false,
          "lineNumber": 237,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires DaisyLock.inodeLocks[i.inodenum] == \\tid"
        },
        {
          "limitHit": false,
          "lineNumber": 239,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures i.blockno  == inodeBlocknos[i.inodenum]"
        },
        {
          "limitHit": false,
          "lineNumber": 240,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures i.size     == inodeSizes[i.inodenum]"
        },
        {
          "limitHit": false,
          "lineNumber": 241,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures i.used     == inodeUsed[i.inodenum]"
        },
        {
          "limitHit": false,
          "lineNumber": 255,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= blockno \u0026\u0026 blockno \u003c Daisy.MAXBLOCK"
        },
        {
          "limitHit": false,
          "lineNumber": 256,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires DaisyLock.blockLocks[blockno] == \\tid"
        },
        {
          "limitHit": false,
          "lineNumber": 257,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result == allocBit[blockno]"
        },
        {
          "limitHit": false,
          "lineNumber": 262,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= blockno \u0026\u0026 blockno \u003c Daisy.MAXBLOCK"
        },
        {
          "limitHit": false,
          "lineNumber": 263,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires DaisyLock.blockLocks[blockno] == \\tid"
        },
        {
          "limitHit": false,
          "lineNumber": 265,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures allocBit[blockno] == bit"
        },
        {
          "limitHit": false,
          "lineNumber": 275,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= blockno \u0026\u0026 blockno \u003c Daisy.MAXBLOCK"
        },
        {
          "limitHit": false,
          "lineNumber": 276,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= offset \u0026\u0026 offset \u003c Daisy.BLOCKSIZE"
        },
        {
          "limitHit": false,
          "lineNumber": 277,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires DaisyLock.blockLocks[blockno] == \\tid"
        },
        {
          "limitHit": false,
          "lineNumber": 278,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result == blocks[blockno][offset]"
        },
        {
          "limitHit": false,
          "lineNumber": 283,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= blockno \u0026\u0026 blockno \u003c Daisy.MAXBLOCK"
        },
        {
          "limitHit": false,
          "lineNumber": 284,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= offset \u0026\u0026 offset \u003c Daisy.BLOCKSIZE"
        },
        {
          "limitHit": false,
          "lineNumber": 285,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires DaisyLock.blockLocks[blockno] == \\tid"
        },
        {
          "limitHit": false,
          "lineNumber": 287,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures b == blocks[blockno][offset]"
        }
      ],
      "repository": {
        "name": "github.com/joana-team/joana",
        "url": "/github.com/joana-team/joana"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d49d82b5892f9331d37432d02d090f28feab56ea"
        },
        "content": "/**\n * This file is part of the Joana IFC project. It is developed at the\n * Programming Paradigms Group of the Karlsruhe Institute of Technology.\n *\n * For further details on licensing please read the information at\n * http://joana.ipd.kit.edu or contact the authors.\n */\n/*\n * This file is part of the Daisy distribution.  This software is\n * distributed 'as is' without any guarantees whatsoever. It may be\n * used freely for research but may not be used in any commercial\n * products.  The contents of this distribution should not be posted\n * on the web or distributed without the consent of the authors.\n *\n * Authors: Cormac Flanagan, Stephen N. Freund, Shaz Qadeer\n * Contact: Shaz Qadeer (qadeer@microsoft.com)\n */\n\npackage conc.daisy;\n\n/**\n * Various routines for testing assertions and reporting errors.\n */\npublic class Assert {\n    static boolean useException = false;\n\n    /**\n     * If passed true, assertion failures will generate Exceptions\n     * rather than terminating execution.\n     */\n    static public void assertFailWithException(boolean b) {\n        useException = b;\n    }\n\n    /**\n     * If passed false, this method well report an assertion failure\n     * and exit the program.\n     */\n    //@ ensures b\n    static public void notFalse(boolean b) {\n        if (!b) {\n            String s = \"assertion failed\\n\" + Debug.getStackDump();\n            if (useException) {\n                throw new RuntimeException(s);\n            } else {\n                System.err.println(s);\n                ShutDown.exit(0);\n            }\n        }\n    }\n\n    /**\n     * If passed false, this method well report an assertion failure,\n     * print the string passed in, and exit the program.\n     */\n    //@ ensures b\n    static public void notFalse(boolean b, String e) {\n        if (!b) {\n            String s = \"assertion failed: \" + e + \"\\n\" + Debug.getStackDump();\n            if (useException) {\n                throw new RuntimeException(s);\n            } else {\n                System.err.println(s);\n                ShutDown.exit(0);\n            }\n        }\n    }\n\n    /**\n     * Prints the exception e, dumps the stack where e occurred, and exits.\n     */\n    //@ ensures false\n    static public void fail(Throwable e) {\n        System.err.println(\"fail: \" + e);\n        e.printStackTrace();\n        ShutDown.exit(0);\n    }\n\n    /**\n     * Prints the exception e and message s, dumps the stack where e\n     * occurred, and exits.\n     */\n    //@ ensures false\n    static public void fail(Throwable e, String s) {\n        System.err.println(\"fail: \" + s);\n        fail(e);\n    }\n\n    /**\n     * Prints the message s, dumps the current stack, and exits.\n     */\n    //@ ensures false\n    static public void fail(String s) {\n        fail(new Throwable(), s);\n    }\n\n    /**\n     * Same as fail, but does not exit.\n     */\n    static public void notify(String s) {\n        System.err.println(s);\n    }\n\n    static public void notify(Throwable e) {\n        System.err.println(\"notify: \" + e);\n        e.printStackTrace();\n    }\n\n    static public void notify(Throwable e, String s) {\n        System.err.println(\"notify: \" + s);\n        notify(e);\n    }\n}\n",
        "name": "Assert.java",
        "path": "example/joana.example.many-small-progs/src/conc/daisy/Assert.java",
        "url": "/github.com/joana-team/joana/-/blob/example/joana.example.many-small-progs/src/conc/daisy/Assert.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures b"
        },
        {
          "limitHit": false,
          "lineNumber": 55,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures b"
        },
        {
          "limitHit": false,
          "lineNumber": 71,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures false"
        },
        {
          "limitHit": false,
          "lineNumber": 82,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures false"
        },
        {
          "limitHit": false,
          "lineNumber": 91,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures false"
        }
      ],
      "repository": {
        "name": "github.com/joana-team/joana",
        "url": "/github.com/joana-team/joana"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d49d82b5892f9331d37432d02d090f28feab56ea"
        },
        "content": "package rs3.hybrid.functionalities.smt;\n\nimport rs3.hybrid.environment.SMTEnv;\nimport rs3.hybrid.functionalities.smt.SMT.ConnectionError;\nimport rs3.hybrid.functionalities.smt.SMT.SMTError;\nimport rs3.hybrid.utils.MessageTools;\n\nfinal public class Receiver {\n\tpublic final int id;\n\t/*@ invariant \n\t  @ (\\exists int i; 0 \u003c= i \u0026\u0026 i \u003c SMT.registered_receiver_ids.length; (int)SMT.registered_receiver_ids[i]==id);\n\t  @ invariant \n\t  @ (\\forall Receiver r; r.id == id; r == this);\n\t  @ invariant \\disjoint(SMT.rep, \\singleton(this.id));\n\t  @*/\n\n\t//@ ensures true;\n\t//@ pure\n\tpublic void listenOn(int port) throws ConnectionError {\n\t\tboolean ok = SMTEnv.listenOn(port);\n\t\tif (!ok) throw new ConnectionError();\n\t}\n\n\t/*@ ensures \\result==null || (\\exists int i; 0 \u003c= i \u0026\u0026 i \u003c SMT.messages.length;\n\t  @\t\\result.message[0] == (byte)SMT.messages[i]\n\t  @\t\u0026\u0026 (int)SMT.receiver_ids[i] == id \u0026\u0026 (int)SMT.sender_ids[i] == \\result.sender_id);\n\t  @ ensures \\result==null || (\\fresh(\\result) \u0026\u0026 \\invariant_for(\\result));\n\t  @ ensures \\disjoint(SMT.rep, \\result.*);\n  \t  @ ensures \\new_elems_fresh(SMT.rep);\n\t  @ assignable SMT.rep, Environment.counter;\n\t  @*/\n\tpublic /*@ nullable @*/ AuthenticatedMessage getMessage(int port) throws SMTError {\n\t\tif (SMT.registrationInProgress) throw new SMTError();\t\t\t\n\n\t\t// the simulator/environment determines the index of the message to be returned\n\t\tint index = SMTEnv.getMessage(this.id, port);\n\t\tif (index \u003c 0) return null;\n\t\tLogEntry smtmsg = SMT.log.get(index);\n\t\tif (smtmsg == null) return null;\n\t\t// check whether the message was sent to *this* receiver\n\t\tif (smtmsg.receiver_id != id) return null;\n\t\t// return new authenticated message\n\t\treturn new AuthenticatedMessage(MessageTools.copyOf(smtmsg.message), smtmsg.sender_id);\n\t}\n\n\tReceiver(int id)  {\n\t\tthis.id = id;\n\t}\n}",
        "name": "Receiver.java",
        "path": "example/joana.example.many-small-progs/src/rs3/hybrid/functionalities/smt/Receiver.java",
        "url": "/github.com/joana-team/joana/-/blob/example/joana.example.many-small-progs/src/rs3/hybrid/functionalities/smt/Receiver.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/joana-team/joana",
        "url": "/github.com/joana-team/joana"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 45,
  "ElapsedMilliseconds": 899,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
