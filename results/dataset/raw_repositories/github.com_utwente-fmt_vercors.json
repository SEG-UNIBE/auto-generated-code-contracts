{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/utwente-fmt/vercors lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "enum AB { A, B }\n\nclass C {\n    void foo() {\n        AB ab = AB.A;\n        //@ assert AB.A != null;\n        //@ assert ab != AB.B;\n    }\n\n    //@ requires ab != null;\n    void bar(AB ab) {\n        //@ assert ab == AB.A || ab == AB.B;\n        AB[] abs = new AB[2];\n        abs[0] = ab;\n        abs[1] = AB.A;\n    }\n}\n",
        "name": "Enums.java",
        "path": "examples/technical/enums/Enums.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/technical/enums/Enums.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires ab != null;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:2 ; indent-tabs-mode:nil -*-\n//:: cases Roster\n//:: tools chalice\n//:: options --explicit\n//:: suite medium\n\n/**\n  See pg 42, phd Hurlin.\n  The command line to verify with the VerCors Tool is:\n  \n  vct --chalice --explicit Roster.java\n  \n  The expected result is Pass.\n*/\nclass Roster {\n  int id;\n  int grade;\n  Roster next;\n\n/*@\n  resource ids_and_links(frac p,frac q)=Perm(id,p)\n    ** Perm(next,q) ** (next!=null ==\u003e idal:next.ids_and_links(p,q));\n   \n  resource grades_and_links(frac p,frac q)=Perm(grade,p)\n    ** Perm(next,q) ** (next!=null ==\u003e gral:next.grades_and_links(p,q));\n     \n  resource state(frac p) =\n    (idal:ids_and_links(p,p/2)) ** (gral:grades_and_links(p,p/2));\n     \n*/\n\n  /*@\n    given frac p, q, r;\n    requires gral1:grades_and_links(100,p);\n    requires idal1:ids_and_links(q,r);\n    ensures  gral2:grades_and_links(100,p);\n    ensures  idal2:ids_and_links(q,r);\n   */\n  void updateGrade(int id, int g) {\n    //@ unfold gral1:grades_and_links(100,p);\n    //@ unfold idal1:ids_and_links(q,r);\n    //@ witness gral_tmp:grades_and_links(*,*);\n    //@ witness idal_tmp:ids_and_links(*,*);\n    //@ gral_tmp=gral1.gral;\n    //@ idal_tmp=idal1.idal;\n    if (this.id == id) {\n      grade = g;\n    } else if (next != null) {\n      rec1:next.updateGrade(id,g)\n      /*@ with { \n        p=p;\n        q=q;\n        r=r;\n        gral1=gral1.gral;\n        idal1=idal1.idal;\n      } then {\n        gral_tmp = gral2;\n        idal_tmp = idal2;\n      } */ ;\n    }\n    //@ fold gral2:grades_and_links(100,p,gral:gral_tmp);\n    //@ fold idal2:ids_and_links(q,r,idal:idal_tmp);\n  }\n\n  /*@\n    given frac q,r;\n    requires idal1:ids_and_links(q,r);\n    ensures  idal2:ids_and_links(q,r);\n   */\n  boolean contains(int id) {\n    //@ unfold idal1:ids_and_links(q,r);\n    //@ witness idal_tmp:ids_and_links(*,*);\n    //@ idal_tmp=idal1.idal;\n    boolean b = this.id==id;\n    if(!b \u0026\u0026 next!=null){\n      b=(next.contains(id)\n      /*@ with {q=q;r=r;idal1=idal1.idal; }\n        then { idal_tmp = idal2; } */);\n    }\n    //@ fold idal2:ids_and_links(q,r,idal:idal_tmp);\n    return b;\n  }\n    \n  //@ requires n!=null ==\u003e state_in:n.state(100);\n  //@ ensures  state_out:state(100);\n  public Roster(int i,int g,Roster n){\n    this.id = i;\n    this.grade = g;\n    this.next = n;\n    /*@\n    witness tmp1:grades_and_links(*,*);\n    witness tmp2:Roster.ids_and_links(*,*);\n    if (n!=null) {\n      unfold state_in:n.state(100);\n      fold tmp1:grades_and_links(100,50,gral:state_in.gral);\n      fold tmp2:ids_and_links(100,50,idal:state_in.idal);\n    } else {\n      fold tmp1:grades_and_links(100,50,gral:null);\n      fold tmp2:ids_and_links(100,50,idal:null);\n    }\n    fold state_out:state(100,idal:tmp2,gral:tmp1);\n    @*/\n  }\n}\n\n",
        "name": "Roster.java",
        "path": "examples/archive/chalice/Roster.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/archive/chalice/Roster.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 83,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires n!=null ==\u003e state_in:n.state(100);"
        },
        {
          "limitHit": false,
          "lineNumber": 84,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  state_out:state(100);"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:2 ; indent-tabs-mode:nil -*-\n//:: cases WandDemo\n//:: tools chalice\n//:: option --explicit\n\n/**\n  The command line to verify with the VerCors Tool is:\n  \n  vct --chalice --explicit WandDemo.java\n  \n  The expected result is Pass.\n*/\nclass WandDemo {\n  int x;\n\n  /*@\n    resource readonly()=Perm(x,25);\n    resource writeonly()=Perm(x,100);\n  @*/\n  \n  //@ requires r:readonly();\n  public /*@ pure */ int get(){\n    //@ unfold r:readonly();\n    return x;\n  }\n  \n  //@ ensures w:writeonly();\n  WandDemo(){\n    //@ fold w:writeonly();\n  }\n\n  /*@\n    requires w:writeonly();\n    ensures  r:readonly();\n    ensures  wand:(readonly()-*writeonly());\n  @*/\n  void set(int v){\n    //@ unfold w:writeonly();\n    x=v;\n    //@ fold r:readonly();\n    /*@\n      create {\n        unfold r:readonly();\n        use    Perm(this.x,75);\n        fold   w:writeonly();\n        qed    wand:((r:readonly())-*(w:writeonly()));\n      }\n    @*/\n  }\n  \n  void demo(){\n    //@ witness wand:(readonly()-*writeonly());\n    //@ witness w:writeonly();\n    //@ witness r:readonly();\n    WandDemo d=new WandDemo() /*@ then { w=w; } @*/;\n    int i=1;\n    //@ loop_invariant ww:d.writeonly();\n    while(true)\n    //@ with { ww = w ; }\n    {\n        d.set(i) /*@ with { w = ww ; } then { r=r; wand=wand; } */;\n        i=(d.get()/*@ with { r=r; } @*/)+(d.get()/*@ with { r=r; } @*/);\n        //@ apply wand:((r:d.readonly())-*(ww:d.writeonly()));\n    }\n  }\n}\n\n",
        "name": "WandDemo.java",
        "path": "examples/archive/chalice/WandDemo.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/archive/chalice/WandDemo.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires r:readonly();"
        },
        {
          "limitHit": false,
          "lineNumber": 26,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures w:writeonly();"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:2 ; indent-tabs-mode:nil -*-\n//:: cases TreeWand\n//:: tools\n//:: options --inline\n//:: suite slow\n\n// Example disabled because it must be rewritten.\n\n/*\n    This file demonstrates how a magic wand can be used to prove\n    that the deletion of a node from a binary search tree is sound.\n    \n    vct --chalice --inline TreeWand.java\n\n    The expected result is Pass.\n\n*/\n\nclass Tree {\n  public int data;\n  public Tree left;\n  public Tree right;\n  \n  /*@ resource state()=Perm(data,100)**\n      Perm(left,100)**Perm(right,100)**left-\u003estate()**right-\u003estate();\n  @*/\n\n  /*\n    The definition of the contents of a list uses mutually recursive functions\n    contents and tolist. The definitions are fairly complicated. The ensures\n    clauses are extensive because they help Chalice proves facts faster.\n    Moreover, the tolist funciton cannot be simplified by defining it as its\n    third ensures clause becauses this causes the termination check to fail.\n   */\n\n  /*@\n    requires t-\u003estate();\n    ensures  t!=null ==\u003e \\result.length \u003e 0;\n    ensures  t==null ==\u003e \\result == seq\u003cint\u003e{};\n    public seq\u003cint\u003e contents(Tree t)=\n        (t==null)?\n            seq\u003cint\u003e{}\n        :\n            \\unfolding t.state() \\in\n                this.contents(t.left) + seq\u003cint\u003e{t.data} + this.contents(t.right);\n  @*/\n\n  /*@\n    resource contains(Tree t,seq\u003cint\u003eL)=t-\u003estate() ** L == contents(t);\n\n    public boolean sorted_list(seq\u003cint\u003e s)=\n      (\\forall int i ; 1 \u003c i \u0026\u0026 i \u003c |s| ; s[i-1] \u003c= s[i] );\n      \n    requires t-\u003estate();\n    public boolean sorted(Tree t)=sorted_list(contents(t));\n  @*/\n\n  //@ requires top!=null ** top.state();\n  //@ ensures  contains(\\result,tail(\\old(contents(top))));\n  //@ ensures  \\old(sorted(top)) ==\u003e sorted(\\result);\n  public Tree del_min(Tree top){\n    //@ seq\u003cint\u003e orig_contents=contents(top);\n    //@ seq\u003cint\u003e target_contents=tail(contents(top));\n    //@ unfold top.state();\n    if (top.left == null) {\n      return top.right;\n    } else {\n      Tree cur, left;\n      cur = top;\n      left = top.left;\n      //@ seq\u003cint\u003e cur_contents=orig_contents;\n      //@ assert cur_contents == contents(left) + seq\u003cint\u003e{top.data} + contents(top.right);\n      //@ unfold left.state();\n      /*@\n      loop_invariant Perm(cur.left,100) ** Perm(cur.data,100) ** Perm(cur.right,100);\n      loop_invariant cur.left==left ** cur.right-\u003estate() ;\n      loop_invariant Perm(left.left,100) ** Perm(left.data,100) ** Perm(left.right,100);\n      loop_invariant left.left-\u003estate() ** left.right-\u003estate();\n      loop_invariant cur_contents == (contents(left.left) + seq\u003cint\u003e{left.data} + contents(left.right))\n                                      + seq\u003cint\u003e{cur.data} + contents(cur.right);\n      loop_invariant wand:(contains(cur,tail(cur_contents)) -* contains(top,target_contents)); @*/\n      while (left.left != null) /*@ with {\n        create {} wand:(contains(top,target_contents) -* contains(top,target_contents));#\\label{proof 1}#\n      } @*/\n      { /*@ Tree prev = cur;\n            seq\u003cint\u003e prev_contents = cur_contents; */\n        cur = left;\n        left = cur.left;\n        /*@\n        unfold left.state();\n        cur_contents = contents(left.left) + seq\u003cint\u003e{left.data} + contents(left.right);\n        cur_contents = cur_contents + seq\u003cint\u003e{cur.data} + contents(cur.right);\n        assert prev_contents.length \u003e 0 ;\n        assert cur_contents.length \u003e 0 ;\n        assert prev_contents == cur_contents + seq\u003cint\u003e{prev.data} + contents(prev.right);\n        create  {#\\label{proof 2 begin}#\n          use    prev_contents.length \u003e 0 ;\n          use    cur_contents.length \u003e 0 ;\n          use    Perm(prev.left,100)**Perm(prev.data,100);\n          use    Perm(prev.right,100)**prev.right-\u003estate();\n          use    prev.left==cur;\n          use    prev_contents == cur_contents + seq\u003cint\u003e{prev.data} + contents(prev.right);\n          fold   prev.state();\n          apply  wand:(contains(prev,tail(prev_contents)) -* contains(top,target_contents));#\\label{apply 1}#\n          qed    wand:(contains(cur,tail(cur_contents)) -* contains(top,target_contents));\n        } #\\label{proof 2 end}#\n        @*/\n      }\n      cur.left = left.right;\n      //@ fold cur.state();\n      //@ assert contents(cur)==tail(cur_contents);\n      //@ apply wand:(contains(cur,tail(cur_contents)) -* contains(top,target_contents));#\\label{apply 2}#\n\n      return top;\n    }\n  }\n}\n\n",
        "name": "TreeWand.java",
        "path": "examples/archive/chalice/TreeWand.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/archive/chalice/TreeWand.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 57,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires top!=null ** top.state();"
        },
        {
          "limitHit": false,
          "lineNumber": 58,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  contains(\\result,tail(\\old(contents(top))));"
        },
        {
          "limitHit": false,
          "lineNumber": 59,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  \\old(sorted(top)) ==\u003e sorted(\\result);"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:4 ; indent-tabs-mode:nil -*-\n//:: cases OnlyCatch\n//:: tools silicon\n//:: verdict Pass\n\nfinal class MyException extends Exception { }\n\nfinal class FooException extends Exception { }\n\nfinal class MyClass {\n    int x;\n\n    //@ signals (FooException e) true;\n    // //@ ensures true;\n    final int foo() {\n        return 0;\n    }\n\n    //@ requires Perm(x, 1);\n    //@ ensures Perm(x, 1) ** x == 40;\n    final void bar() {\n        try {\n            x = 20;\n            //@ assert x == 20;\n            throw new MyException();\n            assert false;\n        } catch (MyException e) {\n            //@ assert x == 20;\n            x = 40;\n            //@ assert x == 40;\n        }\n        //@ assert x == 40 ;\n    }\n}\n",
        "name": "OnlyCatch.java",
        "path": "examples/concepts/abrupt/OnlyCatch.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/abrupt/OnlyCatch.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              7,
              12
            ]
          ],
          "preview": "    // //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 18,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires Perm(x, 1);"
        },
        {
          "limitHit": false,
          "lineNumber": 19,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures Perm(x, 1) ** x == 40;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:2 ; indent-tabs-mode:nil -*-\n//:: cases LabeledWhile\n//:: tools silicon carbon\n//:: verdict Pass\n\nclass C {\n    int i;\n\n    //@ requires Perm(i, write);\n    void m1() {\n        i = 0;\n        //@ loop_invariant Perm(i, write) ** 0 \u003c= i ** i \u003c= 5;\n        l: while (i \u003c 5) {\n            i += 1;\n        }\n        //@ assert i == 5;\n        //@ assert Perm(i, write);\n    }\n\n    //@ requires Perm(i, write);\n    void m2() {\n        i = 100;\n        //@ loop_invariant Perm(i, write) ** 100 \u003c= i ** i \u003c=110;\n        l1: l2: while (i \u003c 110) {\n            i += 1;\n        }\n        //@ assert i == 110;\n        //@ assert Perm(i, write);\n    }\n\n    //@ requires Perm(i, write);\n    void m3() {\n        i = 200;\n        //@ loop_invariant Perm(i, write);\n        l1: l2:\n        //@ loop_invariant i \u003c= 230;\n        while (i \u003c 230) {\n            i += 1;\n        }\n        //@ assert i == 230;\n        //@ assert Perm(i, write);\n    }\n\n    //@ requires Perm(i, write);\n    void m4() {\n        i = -7;\n        //@ loop_invariant Perm(i, 1\\2);\n        l1:\n        //@ loop_invariant Perm(i, 1\\2);\n        l2:\n        //@ loop_invariant i \u003c= 7;\n        while (i \u003c 7) {\n            i += 1;\n        }\n        //@ assert i == 7;\n        //@ assert Perm(i, write);\n    }\n}",
        "name": "LabeledWhile.java",
        "path": "examples/concepts/goto/LabeledWhile.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/goto/LabeledWhile.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires Perm(i, write);"
        },
        {
          "limitHit": false,
          "lineNumber": 19,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires Perm(i, write);"
        },
        {
          "limitHit": false,
          "lineNumber": 30,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires Perm(i, write);"
        },
        {
          "limitHit": false,
          "lineNumber": 43,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires Perm(i, write);"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:4 ; indent-tabs-mode:nil -*-\n//:: cases OnlyReturn\n//:: tools silicon\n//:: verdict Pass\n\nfinal class MyClas {\n    //@ ensures !\\result;\n    final boolean foo() {\n        return false;\n    }\n\n    //@ ensures \\result;\n    final boolean bar() {\n        return true;\n    }\n\n    //@ ensures \\result == 5;\n    final int baz() {\n        return 5;\n    }\n\n    final void qux() {\n        return;\n    }\n}\n",
        "name": "OnlyReturn.java",
        "path": "examples/concepts/abrupt/OnlyReturn.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/abrupt/OnlyReturn.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures !\\result;"
        },
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result;"
        },
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result == 5;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:2 ; indent-tabs-mode:nil -*-\n//:: cases WitnessDemo\n//:: tools\n//:: options --explicit\n/**\n  The command line to verify with the VerCors Tool is:\n  \n  vct --chalice --explicit WitnessDemo.java\n  \n  The expected result is Pass.\n*/\nclass WandDemo {\n  int x;\n\n  /*@\n    resource readonly(frac p)=Perm(x,p/2);\n    resource writeonly()=Perm(x,100);\n  @*/\n  \n  //@ given frac p;\n  //@ requires ro:readonly(p);\n  public /*@ pure */ int get(){\n    //@ unfold ro:readonly(p);\n    return x;\n  }\n  \n  //@ ensures rw:writeonly();\n  WandDemo(){\n    //@ fold rw:writeonly();\n  }\n\n  /*@\n    requires rw:writeonly();\n    ensures  ro:readonly(100);\n    ensures  wand:((rdp:readonly(100)) -* wrp:writeonly());\n  @*/\n  void set(int v){\n    //@ unfold rw:writeonly();\n    x=v;\n    //@ fold ro:readonly(100);\n    /*@\n      create {\n        unfold rdp:readonly(100);\n        use    Perm(this.x,50);\n        fold   wrp:writeonly();\n        qed    wand:((rdp:readonly(100))-*wrp:writeonly());\n      }\n    @*/\n  }\n\n  void demo(){\n    //@ witness wand:((rdp:readonly(100))-*wrp:writeonly());\n    //@ witness wrp:writeonly();\n    WandDemo d=new WandDemo() /*@ then { wrp=rw; } */;\n    int i=1;\n    //@ loop_invariant inv:d.writeonly();\n    //@ inv=wrp;\n    while(true) {\n        set_call:d.set(i) /*@ with { rw=inv; } */;\n        //@ wand=set_call.wand;\n        int tmp1=d.get()/*@ with { p = 100 ; ro=set_call.ro; } */;\n        int tmp2=d.get()/*@ with { p = 100 ; ro=set_call.ro; } */;\n        i=tmp1+tmp2;\n        //@ apply wand:((rdp:readonly(100))-*wrp:writeonly()) label dummy with { rdp=set_call.ro; };\n        //@ inv=dummy.wrp;\n    }\n  }\n}\n\n",
        "name": "WitnessDemo.java",
        "path": "examples/archive/chalice/WitnessDemo.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/archive/chalice/WitnessDemo.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires ro:readonly(p);"
        },
        {
          "limitHit": false,
          "lineNumber": 26,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures rw:writeonly();"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:2 ; indent-tabs-mode:nil -*-\n//:: cases TreeWand-E1\n//:: tools\n//:: options --inline\n//:: verdict Fail\n//:: suite slow\n\n// Example disabled because it must be rewritten.\n\n/*\n    This file demonstrates how a magic wand can be used to prove\n    that the deletion of a node from a binary search tree is sound.\n    \n    vct --chalice --inline TreeWand-e1.java\n\n    The expected result is Fail.\n\n    Beware that this specification can take 5-10 minutes to check.\n*/\n\nclass Tree {\n  public int data;\n  public Tree left;\n  public Tree right;\n  \n  /*@ resource state()=Perm(data,100)**\n      Perm(left,100)**Perm(right,100)**(left-\u003estate())**(right-\u003estate());\n  @*/\n\n  /*\n    The definition of the contents of a list uses mutually recursive functions\n    contents and tolist. The definitions are fairly complicated. The ensures\n    clauses are extensive because they help Chalice proves facts faster.\n    Moreover, the tolist funciton cannot be simplified by defining it as its\n    third ensures clause becauses this causes the termination check to fail.\n   */\n\n  /*@\n    requires state();\n    ensures  \\result.length\u003e0;\n    ensures  \\result == tolist(this);\n    pure seq\u003cint\u003e contents()=tolist(left) + seq\u003cint\u003e{data} + tolist(right);\n\n    ghost\n    requires t-\u003estate();\n    ensures  t!=null ==\u003e \\result == t.contents();\n    ensures  t==null ==\u003e \\result == seq\u003cint\u003e{};\n    ensures  \\result == (t==null ? seq\u003cint\u003e{} : t.contents());\n    pure seq\u003cint\u003e tolist(Tree t){\n        if (t==null) {\n            return seq\u003cint\u003e{};\n        } else {\n            unfold t.state();\n            return t.tolist(t.left) + seq\u003cint\u003e{t.data} + t.tolist(t.right);\n        }\n    }  \n  @*/\n\n  /*@\n    resource state_contains(seq\u003cint\u003e L)=state() ** contents()==L;\n        \n    resource contains(Tree t,seq\u003cint\u003eL)=t-\u003estate() ** L == tolist(t);\n\n    pure boolean sorted_list(seq\u003cint\u003e s)=\n      (\\forall int i ; 1 \u003c i \u0026\u0026 i \u003c |s| ; s[i-1] \u003c= s[i] );\n      \n    requires t-\u003estate();\n    pure boolean sorted(Tree t)=t==null || sorted_list(t.contents());\n  @*/\n\n  //@ requires top!=null ** top.state();\n  //@ ensures  contains(\\result,tail(\\old(top.contents())));\n  //@ ensures  \\old(sorted(top)) ==\u003e sorted(\\result);\n  public Tree del_min(Tree top){\n    //@ seq\u003cint\u003e orig_contents=top.contents();\n    //@ seq\u003cint\u003e target_contents=tail(top.contents());\n    //@ unfold top.state();\n    if (top.left == null) {\n      return top.right;\n    } else {\n      Tree cur, left;\n      cur = top;\n      left = top.left;\n      //@ seq\u003cint\u003e cur_contents=orig_contents;\n      //@ assert cur_contents == left.contents() + seq\u003cint\u003e{top.data} + tolist(top.right);\n      //@ unfold left.state();\n      /*@\n      loop_invariant Perm(cur.left,100) ** Perm(cur.data,100) ** Perm(cur.right,100);\n      loop_invariant cur.left==left ** cur.right-\u003estate() ;\n      loop_invariant Perm(left.left,100) ** Perm(left.data,100) ** Perm(left.right,100);\n      loop_invariant left.left-\u003estate() ** left.right-\u003estate();\n      loop_invariant cur_contents == (tolist(left.left) + seq\u003cint\u003e{left.data} + tolist(left.right))\n                                      + seq\u003cint\u003e{cur.data} + tolist(cur.right);\n      loop_invariant wand:(cur.state_contains(tail(cur_contents)) -* top.state_contains(target_contents)); @*/\n      while (left.left != null) /*@ with {\n        create {} wand:(top.state_contains(target_contents) -* top.state_contains(target_contents));#\\label{proof 1}#\n      } @*/\n      { /*@ Tree prev = cur;\n            seq\u003cint\u003e prev_contents = cur_contents; */\n        cur = left;\n        left = cur.left;\n        //@ assert left != null;\n        /*@\n        unfold left.state();\n        assert left.left != null;\n        cur_contents = tolist(left.left) + seq\u003cint\u003e{left.data} + tolist(left.right);\n        cur_contents = cur_contents + seq\u003cint\u003e{cur.data} + tolist(cur.right);\n        assert prev_contents.length \u003e 0 ;\n        assert cur_contents.length \u003e 0 ;\n        assert prev_contents == cur_contents + seq\u003cint\u003e{prev.data} + tolist(prev.right);\n        create  {#\\label{proof 2 begin}#\n          use    prev_contents.length \u003e 0 ;\n          use    cur_contents.length \u003e 0 ;\n          use    Perm(prev.left,100)**Perm(prev.data,100);\n          use    Perm(prev.right,100)**prev.right-\u003estate();\n          use    prev.left==cur;\n          use    prev_contents == cur_contents + seq\u003cint\u003e{prev.data} + tolist(prev.right);\n          fold   prev.state();\n          apply  wand:(prev.state_contains(tail(prev_contents)) -* top.state_contains(target_contents));\n          qed    wand:(cur.state_contains(tail(cur_contents)) -* top.state_contains(target_contents));\n        } #\\label{proof 2 end}#\n        @*/\n        \n        //@ assert left.left != null;\n      }\n      //@ assert false;\n      cur.left = left.left;\n      //@ fold cur.state();\n      //@ assert cur.contents()==tail(cur_contents);\n      //@ apply wand:(cur.state_contains(tail(cur_contents)) -* top.state_contains(target_contents));\n      return top;\n    }\n  }\n}\n\n",
        "name": "TreeWand-e1.java",
        "path": "examples/archive/chalice/TreeWand-e1.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/archive/chalice/TreeWand-e1.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 70,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires top!=null ** top.state();"
        },
        {
          "limitHit": false,
          "lineNumber": 71,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  contains(\\result,tail(\\old(top.contents())));"
        },
        {
          "limitHit": false,
          "lineNumber": 72,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  \\old(sorted(top)) ==\u003e sorted(\\result);"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:4 ; indent-tabs-mode:nil -*-\n//:: cases Synchronized\n//:: tools silicon\n//:: verdict Pass\n\nfinal\n//@ lock_invariant Perm(this.x, 1);\nclass MyClass {\n    int x;\n\n    //@ ensures committed(this);\n    MyClass() {\n        x = 0;\n        //@ commit this;\n    }\n\n    //@ requires committed(this);\n    void increment() {\n        synchronized (this) {\n            x += 1;\n        }\n    }\n\n    //@ requires committed(this);\n    synchronized void other_increment() {\n        x += 1;\n    }\n}\n\n",
        "name": "Synchronized.java",
        "path": "examples/concepts/abrupt/Synchronized.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/abrupt/Synchronized.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures committed(this);"
        },
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires committed(this);"
        },
        {
          "limitHit": false,
          "lineNumber": 23,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires committed(this);"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:2 ; indent-tabs-mode:nil -*-\n//:: cases WandDemoSilver\n//:: tools silicon\n\n/**\n * The command line to verify with the VerCors Tool is:\n * \u003cp\u003e\n * vct --silver=silicon WandDemoSilver.java\n * \u003cp\u003e\n * The expected result is Pass.\n */\nfinal class WandDemo {\n    int x;\n\n    /*@\n    resource readonly() = Perm(x,1\\4);\n    resource writeonly() = Perm(x,write);\n    @*/\n  \n    /*@\n    requires readonly();\n    pure int get() = \\unfolding readonly() \\in x;\n    */\n\n    //@ ensures writeonly();\n    WandDemo() {\n        //@ fold writeonly();\n    }\n\n    /*@\n    requires writeonly();\n    ensures  readonly();\n    ensures  readonly()-*writeonly();\n    @*/\n    void set(int v) {\n        //@ unfold writeonly();\n        x = v;\n        //@ fold readonly();\n        /*@\n        package readonly() -* writeonly() {\n        unfold readonly();\n        fold writeonly();\n        }\n        @*/\n    }\n\n\n    void demo() {\n        WandDemo d = new WandDemo();\n        int i = 1;\n        //@ loop_invariant d.writeonly();\n        while (true) {\n            d.set(i);\n            i = d.get() + d.get();\n            //@ apply d.readonly()-*d.writeonly();\n        }\n    }\n\n}\n\n",
        "name": "WandDemoSilver.java",
        "path": "examples/concepts/wand/WandDemoSilver.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/wand/WandDemoSilver.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 24,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures writeonly();"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:2 ; indent-tabs-mode:nil -*-\n//:: cases TreeWandSilver\n// suite puptol\n// tools silicon\n/*\n    This file demonstrates how a magic wand can be used to prove\n    that the deletion of a node from a binary search tree is sound.\n    \n    vct --silver=silicon TreeWandSilver.java\n\n    The expected result is Pass.\n*/\n\n/*@\n    requires t-\u003estate();\n    pure seq\u003cint\u003e tolist(Tree t)=(t==null)?seq\u003cint\u003e{}:\n        \\unfolding t.state() \\in tolist(t.left) + seq\u003cint\u003e{t.data} + tolist(t.right);\n\n    requires t-\u003estate();\n    pure boolean sorted(Tree t)=sorted_list(tolist(t));\n\n    pure boolean sorted_list(seq\u003cint\u003e s)=\n      (\\forall int i ; 1 \u003c i \u0026\u0026 i \u003c |s| ; s[i-1] \u003c= s[i] );\n    @*/\n\nfinal class Tree {\n  public int data;\n  public Tree left;\n  public Tree right;\n  \n  /*@ resource state()=Perm(data,write)**\n      Perm(left,write)**Perm(right,write)**left-\u003estate()**right-\u003estate();\n  @*/\n\n  /*@\n    inline resource state_contains(seq\u003cint\u003e L)=this.state() ** tolist(this)==L;\n        \n    inline resource contains(Tree t,seq\u003cint\u003eL)=t-\u003estate() ** L == tolist(t);\n  @*/\n\n  //@ requires top!=null ** top.state();\n  //@ ensures  contains(\\result,\\old(tolist(top)).tail);\n  //@ ensures  \\old(sorted(top)) ==\u003e sorted(\\result);\n  public Tree del_min(Tree top){\n    //@ ghost seq\u003cint\u003e orig_contents=tolist(top);\n    //@ ghost seq\u003cint\u003e target_contents=(tolist(top)).tail;\n    //@ unfold top.state();\n    if (top.left == null) {\n      //@ assert orig_contents == tolist(top.left) + seq\u003cint\u003e{top.data} + tolist(top.right);\n      //@ assert tolist(top.left) == seq\u003cint\u003e{};\n      return top.right;\n    } else {\n      Tree cur, left;\n      cur = top;\n      left = top.left;\n      //@ ghost seq\u003cint\u003e cur_contents=orig_contents;\n      //@ assert cur_contents == tolist(left) + seq\u003cint\u003e{top.data} + tolist(top.right);\n      //@ unfold left.state();\n      //@ package top.state_contains(target_contents) -* top.state_contains(target_contents) {}\n\n      /*@\n      loop_invariant Perm(cur.left,write) ** Perm(cur.data,write) ** Perm(cur.right,write);\n      loop_invariant cur.left==left ** cur.right-\u003estate() ;\n      loop_invariant Perm(left.left,write) ** Perm(left.data,write) ** Perm(left.right,write);\n      loop_invariant left.left-\u003estate() ** left.right-\u003estate();\n      loop_invariant cur_contents == (tolist(left.left) + seq\u003cint\u003e{left.data} + tolist(left.right))\n                                      + seq\u003cint\u003e{cur.data} + tolist(cur.right);\n      loop_invariant (cur.state_contains((cur_contents).tail) -* top.state_contains(target_contents));\n      @*/\n      while (left.left != null)\n      {\n        //@ ghost Tree prev = cur;\n        //@ ghost seq\u003cint\u003e prev_contents = cur_contents;\n        cur = left;\n        left = cur.left;\n        /*@\n        unfold left.state();\n        ghost cur_contents = tolist(left.left) + seq\u003cint\u003e{left.data} + tolist(left.right);\n        ghost cur_contents = cur_contents + seq\u003cint\u003e{cur.data} + tolist(cur.right);\n        assert |prev_contents| \u003e 0 ;\n        assert |cur_contents| \u003e 0 ;\n        assert prev_contents == cur_contents + seq\u003cint\u003e{prev.data} + tolist(prev.right);\n        package cur.state_contains((cur_contents).tail) -* top.state_contains(target_contents) {\n          fold prev.state();\n          apply prev.state_contains(prev_contents.tail) -* top.state_contains(target_contents);\n        }\n        @*/\n      }\n      cur.left = left.right;\n      //@ fold cur.state();\n      //@ assert tolist(cur)==(cur_contents).tail;\n      //@ assert cur.state_contains(tolist(cur));\n      //@ assert cur.state_contains((cur_contents).tail);\n      //@ apply (cur.state_contains((cur_contents).tail) -* top.state_contains(target_contents));\n      return top;\n    }\n  }\n}\n\n",
        "name": "TreeWandSilver.java",
        "path": "examples/concepts/wand/TreeWandSilver.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/wand/TreeWandSilver.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 40,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires top!=null ** top.state();"
        },
        {
          "limitHit": false,
          "lineNumber": 41,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  contains(\\result,\\old(tolist(top)).tail);"
        },
        {
          "limitHit": false,
          "lineNumber": 42,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  \\old(sorted(top)) ==\u003e sorted(\\result);"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:2 ; indent-tabs-mode:nil -*-\n//:: cases TreeWandErr\n//:: tools\n//:: options --inline\n//:: verdict Fail\n//:: suite slow\n\n// Example disabled because it must be rewritten.\n\n/*\n    This file demonstrates how a magic wand can be used to prove\n    that the deletion of a node from a binary search tree is sound.\n    \n    vct --chalice --inline TreeWand.java\n\n    The expected result is Pass.\n\n*/\n\nclass Tree {\n  public int data;\n  public Tree left;\n  public Tree right;\n  \n  /*@ resource state()=Perm(data,100)**\n      Perm(left,100)**Perm(right,100)**left-\u003estate()**right-\u003estate();\n  @*/\n\n  /*\n    The definition of the contents of a list uses mutually recursive functions\n    contents and tolist. The definitions are fairly complicated. The ensures\n    clauses are extensive because they help Chalice proves facts faster.\n    Moreover, the tolist funciton cannot be simplified by defining it as its\n    third ensures clause becauses this causes the termination check to fail.\n   */\n\n  /*@\n    requires t-\u003estate();\n    ensures  t!=null ==\u003e \\result.length \u003e 0;\n    ensures  t==null ==\u003e \\result == seq\u003cint\u003e{};\n    public seq\u003cint\u003e contents(Tree t)=\n        (t==null)?\n            seq\u003cint\u003e{}\n        :\n            \\unfolding t.state() \\in\n                this.contents(t.left) + seq\u003cint\u003e{t.data} + this.contents(t.right);\n  @*/\n\n  /*@\n    resource contains(Tree t,seq\u003cint\u003eL)=t-\u003estate() ** L == contents(t);\n\n    public boolean sorted_list(seq\u003cint\u003e s)=\n      (\\forall int i ; 1 \u003c i \u0026\u0026 i \u003c |s| ; s[i-1] \u003c= s[i] );\n      \n    requires t-\u003estate();\n    public boolean sorted(Tree t)=sorted_list(contents(t));\n  @*/\n\n  //@ requires top!=null ** top.state();\n  //@ ensures  contains(\\result,tail(\\old(contents(top))));\n  //@ ensures  \\old(sorted(top)) ==\u003e sorted(\\result);\n  public Tree del_min(Tree top){\n    //@ seq\u003cint\u003e orig_contents=contents(top);\n    //@ seq\u003cint\u003e target_contents=tail(contents(top));\n    //@ unfold top.state();\n    if (top.left == null) {\n      return top.right;\n    } else {\n      Tree cur, left;\n      cur = top;\n      left = top.left;\n      //@ seq\u003cint\u003e cur_contents=orig_contents;\n      //@ assert cur_contents == contents(left) + seq\u003cint\u003e{top.data} + contents(top.right);\n      //@ unfold left.state();\n      /*@\n      loop_invariant Perm(cur.left,100) ** Perm(cur.data,100) ** Perm(cur.right,100);\n      loop_invariant cur.left==left ** cur.right-\u003estate() ;\n      loop_invariant Perm(left.left,100) ** Perm(left.data,100) ** Perm(left.right,100);\n      loop_invariant left.left-\u003estate() ** left.right-\u003estate();\n      loop_invariant cur_contents == (contents(left.left) + seq\u003cint\u003e{left.data} + contents(left.right))\n                                      + seq\u003cint\u003e{cur.data} + contents(cur.right);\n      loop_invariant wand:(contains(cur,tail(cur_contents)) -* contains(top,target_contents)); @*/\n      while (left.left != null) /*@ with {\n        create {} wand:(contains(top,target_contents) -* contains(top,target_contents));#\\label{proof 1}#\n      } @*/\n      { /*@ Tree prev = cur;\n            seq\u003cint\u003e prev_contents = cur_contents; */\n        cur = left;\n        left = cur.left;\n        /*@\n        unfold left.state();\n        cur_contents = contents(left.left) + seq\u003cint\u003e{left.data} + contents(left.right);\n        cur_contents = cur_contents + seq\u003cint\u003e{cur.data} + contents(cur.right);\n        assert prev_contents.length \u003e 0 ;\n        assert cur_contents.length \u003e 0 ;\n        assert prev_contents == cur_contents + seq\u003cint\u003e{prev.data} + contents(prev.right);\n        create  {#\\label{proof 2 begin}#\n          use    prev_contents.length \u003e 0 ;\n          use    cur_contents.length \u003e 0 ;\n          use    Perm(prev.left,100)**Perm(prev.data,100);\n          use    Perm(prev.right,100)**prev.right-\u003estate();\n          use    prev.left==cur;\n          use    prev_contents == cur_contents + seq\u003cint\u003e{prev.data} + contents(prev.right);\n          fold   prev.state();\n          apply  wand:(contains(prev,tail(prev_contents)) -* contains(top,target_contents));#\\label{apply 1}#\n          qed    wand:(contains(cur,tail(cur_contents)) -* contains(top,target_contents));\n        } #\\label{proof 2 end}#\n        @*/\n      }\n      cur.left = left.left;\n      //@ fold cur.state();\n      //@ assert contents(cur)==tail(cur_contents);\n      //@ apply wand:(contains(cur,tail(cur_contents)) -* contains(top,target_contents));#\\label{apply 2}#\n\n      return top;\n    }\n  }\n}\n\n",
        "name": "TreeWand-err.java",
        "path": "examples/archive/chalice/TreeWand-err.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/archive/chalice/TreeWand-err.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 58,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires top!=null ** top.state();"
        },
        {
          "limitHit": false,
          "lineNumber": 59,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  contains(\\result,tail(\\old(contents(top))));"
        },
        {
          "limitHit": false,
          "lineNumber": 60,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  \\old(sorted(top)) ==\u003e sorted(\\result);"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:4 ; indent-tabs-mode:nil -*-\n//:: cases MultiDimArray\n//:: tools silicon\n//:: verdict Pass\npublic class MultiDimArray {\n    //@ requires x == null || x.length == 5;\n    public static void method(int[] x) {\n\n    }\n\n    public static void main(String[] args) {\n        int[][][] a = new int[][][] {\n                null,\n                {null},\n                {{1, 2}}\n        };\n\n        boolean cond = true;\n\n        Object[][] x = cond ? new Object[][]{null} : new Object[][]{{null}};\n\n        method(null);\n\n//        x[0][0] = cond ? null : null;\n        x[0] = cond ? null : null;\n        x[0] = cond ? null : x[0];\n\n        if(x[0] == null) {\n            return;\n        }\n    }\n}\n",
        "name": "MultiDimArray.java",
        "path": "examples/concepts/basic/MultiDimArray.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/basic/MultiDimArray.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires x == null || x.length == 5;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "import java.lang.Deprecated;\n\n@interface MyAnnotation {\n    int value() default 15;\n    int foo() default 3;\n    boolean bar() default true;\n}\n\n@interface Dummy {\n    ;\n}\n\n@MyAnnotation(xxx) // RR: This should preferably not typecheck, but this is currently difficult to accomodate.\nclass C {\n    int xxx;\n\n    @Deprecated\n    void m() { }\n\n    @MyAnnotation(100)\n    void n() { }\n\n    @MyAnnotation(value = 100, foo = 3, bar = false)\n    void o() { }\n\n    @MyAnnotation\n    void p() {\n        @MyAnnotation int x;\n    }\n\n    void xx(@MyAnnotation int param) {\n\n    }\n\n    //@ requires ma != null ** ma instanceof MyAnnotation;\n    int x(MyAnnotation ma) {\n       return ma.foo();\n    }\n}",
        "name": "JavaAnnotation.java",
        "path": "examples/technical/java/JavaAnnotation.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/technical/java/JavaAnnotation.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 34,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires ma != null ** ma instanceof MyAnnotation;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:4 ; indent-tabs-mode:nil -*-\n//:: cases SwitchVarious\n//:: tools silicon\n//:: verdict Pass\n\nclass C {\n    void m1() {\n        int x = -1;\n        switch (1) {\n            case 1:\n                switch (3) {\n                    case 3:\n                        x = 33;\n                        break;\n                    case 4:\n                        x = 44;\n                        break;\n                }\n                break;\n            case 2:\n                x = 22;\n                break;\n            default:\n                x = 100;\n        }\n        //@ assert x == 33;\n    }\n\n    void m2() {\n        int x = -1;\n        switch (1) {\n            case 1:\n                x = 11;\n                break;\n            case 2:\n                x = 22;\n                break;\n        }\n        //@ assert x == 11;\n    }\n\n    void m3() {\n        int x = -1;\n        switch (3) {\n        }\n        //@ assert x == -1;\n    }\n\n    void m4() {\n        int x = -1;\n        switch (3) {\n            default:\n                x = 33;\n                break;\n        }\n        //@ assert x == 33;\n    }\n\n    void m5() {\n        int x = -1;\n        switch (3) {\n            case 1:\n                x = 11;\n                break;\n            case 2:\n                x = 22;\n                break;\n            default:\n                x = 33;\n                break;\n        }\n        //@ assert x == 33;\n    }\n\n    //@ ensures 1 \u003c= \\result \u0026\u0026 \\result \u003c= 5;\n    int pickBetween1And5();\n\n    void m6() {\n        int x = -1;\n        switch (pickBetween1And5()) {\n            case 0:\n                x = 11;\n                break;\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n                x = 22;\n                break;\n            case 6:\n                x = 33;\n                break;\n        }\n        //@ assert x == 22;\n    }\n\n    void m7() {\n        int x = -1;\n        switch (pickBetween1And5()) {\n            case 1:\n                x += 1;\n            case 2:\n                x += 1;\n            case 3:\n                x += 1;\n            case 4:\n                x += 1;\n            case 5:\n                x += 1;\n                break;\n        }\n        //@ assert x \u003e -1;\n    }\n\n    void m8() {\n        int x = 0;\n        switch (1) {\n            case 0:\n                x += 5;\n            case 1:\n                x += 20;\n            case 2:\n                x += 100;\n        }\n        //@ assert x == 120;\n    }\n}",
        "name": "SwitchVarious.java",
        "path": "examples/concepts/abrupt/SwitchVarious.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/abrupt/SwitchVarious.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 74,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures 1 \u003c= \\result \u0026\u0026 \\result \u003c= 5;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "package java.lang;\n\nimport java.io.PrintStream;\nimport java.io.InputStream;\n\nclass System {\n    public static final PrintStream out;\n    public static final PrintStream err;\n    public static final InputStream in;\n\n    /*@\n    ghost\n    ensures out != null ** err != null;\n    public static void staticInvariant() {\n        //@ assume false;\n    }\n    */\n\n    //@ requires in != null;\n    public static void setIn(InputStream in) {\n        //@ assume false;\n    }\n\n    //@ requires out != null;\n    public static void setOut(PrintStream out) {\n        //@ assume false;\n    }\n\n    //@ requires err != null;\n    public static void setErr(PrintStream err) {\n        //@ assume false;\n    }\n}",
        "name": "System.java",
        "path": "res/universal/res/jdk/java/lang/System.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/res/universal/res/jdk/java/lang/System.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 18,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires in != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 23,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires out != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires err != null;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:4 ; indent-tabs-mode:nil -*-\n//:: cases Knuth_Tabulate\n//:: tools silicon\n//:: verdict Pass\n\nfinal class MyClass {\n    int i;\n\n    //@ context Perm(i, 1);\n    //@ ensures i == \\old(i) + 1;\n    int read_char();\n\n    void write_char(int c);\n\n    void return_the_carriage();\n    void tabulate();\n\n    //@ context Perm(i, 1);\n    void foo() {\n        //@ ghost int old_i = i;\n        int SLASH = 900;\n        int DOT = 100;\n        int x = read_char();\n        //@ assert old_i + 1 == i;\n        //@ ghost boolean saw_slash = false;\n        char_processed: {\n            if (x == SLASH) {\n                //@ ghost saw_slash = true;\n                x = read_char();\n                if (x == SLASH) {\n                    return_the_carriage();\n                    break char_processed;\n                } else {\n                    tabulate();\n                }\n            }\n            write_char(x);\n            if (x == DOT) {\n                write_char(DOT);\n            }\n        }\n        //@ assert saw_slash ? old_i + 2 == i : old_i + 1 == i;\n    }\n}\n",
        "name": "KnuthTabulate.java",
        "path": "examples/concepts/abrupt/KnuthTabulate.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/abrupt/KnuthTabulate.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures i == \\old(i) + 1;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "package java.lang;\n\n// TODO: Should not have to use instanceof anywhere in this file\n\n/*@\nghost\nadt StringBijection {\n    pure String toString(string data);\n    pure string fromString(String object);\n\n    axiom (\\forall string data; {: toString(data) :} != null);\n    axiom (\\forall String o; o != null; toString({: fromString(o) :}) == o);\n    axiom (\\forall string data; fromString({: toString(data) :}) == data);\n}\n@*/\n\npublic class String {\n    /*@\n    ghost\n    decreases;\n    ensures data() == str;\n    String(string str) {\n        //@ assume false;\n    }\n    @*/\n\n    //@ requires other != null;\n    String(String other) {\n        //@ assume data() == other.data();\n    }\n\n    /*@\n    decreases;\n    pure string data();\n    */\n\n    /*@\n    ghost\n    decreases;\n    ensures \\result == StringBijection.toString(str);\n    static pure String vercorsIntern(string str);\n     */\n\n    //@ decreases;\n    //@ ensures \\result == StringBijection.toString(data());\n    public native /*@ pure @*/ String intern();\n\n\n    /*@\n    decreases;\n    requires other != null;\n    ensures \\result != null ** \\result instanceof String;\n    ensures \\result.data() == data() + other.data();\n    String +(String other) {\n        return new String(data() + other.data());\n    }\n\n    decreases;\n    requires other != null;\n    ensures \\result != null ** \\result instanceof String;\n    ensures \\result.data() == other.data() + data();\n    String right+(String other) {\n        return new String(other.data() + data());\n    }\n    @*/\n\n    /*@\n    ghost\n    decreases;\n    public pure boolean isEmpty();\n     @*/\n\n\n    // Since VerCors does not support Object... varargs, in order to be able to comfortably specific examples that use\n    //  String.format, I am adding a few possible scenarios which could be used in verification.\n    /*@\n    ghost\n    decreases;\n    public static String format(String other, int arg1, String arg2) {\n        return other;\n    }\n     @*/\n\n    /*@\n    ghost\n    decreases;\n    public static String format(String other, int arg1) {\n        return other;\n    }\n     @*/\n\n    /*@\n    ghost\n    decreases;\n    public static String format(String other, int arg1, int arg2) {\n        return other;\n    }\n     @*/\n\n    /*@\n    ghost\n    decreases;\n    public static String format(String other, String arg1, String arg2) {\n        return other;\n    }\n     @*/\n\n    /*@\n    ghost\n    decreases;\n    public static String format(String other, String arg1) {\n        return other;\n    }\n     @*/\n\n}",
        "name": "String.java",
        "path": "res/universal/res/jdk/java/lang/String.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/res/universal/res/jdk/java/lang/String.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 26,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires other != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 44,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result == StringBijection.toString(data());"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:4 ; indent-tabs-mode:nil -*-\n//:: cases ReturnFinally\n//:: tools silicon\n//:: verdict Pass\n\n// This is an adaptation of a file from the examples directory of key.\n// Original file path: KEY_ROOT/key/key.ui/examples/standard_key/java_dl/exceptions_java/MyClass2.java\n// It has been adapted and extended to use the vercors syntax for specifications.\n\npublic class ReturnFinally {\n    int i;\n\n    //@ requires Perm(i, write);\n    //@ ensures Perm(i, write) ** \\result == 0 ** i == 1;\n    public int m() {\n        i = 0;\n        try {\n            return i;\n        } finally {\n            i = 1;\n        }\n    }\n}\n",
        "name": "ReturnFinally.java",
        "path": "examples/concepts/abrupt/ReturnFinally.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/abrupt/ReturnFinally.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires Perm(i, write);"
        },
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures Perm(i, write) ** \\result == 0 ** i == 1;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "package java.lang;\n\nclass Integer {\n    final static int MIN_VALUE;\n    final static int MAX_VALUE;\n    \n    //@ ensures intValue() == x;\n    public Integer(int x) {\n        //@ assume false;\n    }\n\n    private Integer() {\n        //@ assume false;\n    }\n\n    /*@\n    ghost\n    pure public int intValue();\n     */\n\n    //@ ensures \\result != null;\n    public String toString() {\n       //@ assume false;\n        return null;\n    }\n}",
        "name": "Integer.java",
        "path": "res/universal/res/jdk/java/lang/Integer.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/res/universal/res/jdk/java/lang/Integer.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures intValue() == x;"
        },
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result != null;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:4 ; indent-tabs-mode:nil -*-\n//:: cases WhileInFinally\n//:: tools silicon\n//:: verdict Pass\n\nimport java.io.*;\n\nclass C {\n    int x;\n\n    //@ requires Perm(x, write) ** x == 0;\n    //@ signals (IOException e) Perm(x, write) ** x == 5;\n    //@ ensures false;\n    void m() throws IOException {\n        try {\n            throw new IOException();\n        } finally {\n            //@ loop_invariant Perm(x, write);\n            //@ loop_invariant 0 \u003c= x \u0026\u0026 x \u003c= 5;\n            while (x \u003c 5) {\n                x += 1;\n            }\n        }\n        x = 0;\n    }\n}\n",
        "name": "WhileInFinally.java",
        "path": "examples/concepts/abrupt/WhileInFinally.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/abrupt/WhileInFinally.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires Perm(x, write) ** x == 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures false;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:2 ; indent-tabs-mode:nil -*-\n//:: cases CastExample\n//:: tools silicon\n//:: verdict Pass\n\n/**\n  This example shows how a binary tree with internal \u003ccode\u003eNode\u003c/code\u003es\n  and \u003ccode\u003eLeaf\u003c/code\u003es can be specified if access is by means of casting\n  rather than through a visitor pattern.\n*/\nclass Node {\n  int key;\n  Object left;\n  Object right;\n  \n  //@ requires state(left) ** state(right);\n  //@ ensures state(this);\n  public Node(int key,Object left,Object right){\n    this.key=key;\n    this.left=left;\n    this.right=right;\n    //@ assert this instanceof Node;\n    //@ assert !(this instanceof Leaf);\n    //@ fold state_rec(this);\n  }\n  \n}\n\nclass Leaf {\n  int other;\n}\n\n/*@\nresource state_rec(Object t) = t != null **\n  (t instanceof Leaf || t instanceof Node) **\n  (t instanceof Leaf ==\u003e Perm(((Leaf)t).other,1)) **\n  (t instanceof Node ==\u003e\n     Perm(((Node)t).key,1) **\n     Perm(((Node)t).left,1) ** state(((Node)t).left) **\n     Perm(((Node)t).right,1) ** state(((Node)t).right));\n\ninline resource state(Object t) = t != null ** state_rec(t);\n@*/\n\nclass Test {\n  //@ requires state(tt);\n  int find(Object tt,int key){\n    Object t=tt;\n    //@ loop_invariant state(t);\n    while(t instanceof Node){\n      Node n=(Node)t;\n      //@ unfold state_rec(n);\n      if (key \u003c n.key) {\n        t=n.left;\n      } else {\n        t=n.right;\n      }\n    }\n    //@ unfold state_rec(t);\n    Leaf l=(Leaf)t;\n    return l.other;\n  }\n}",
        "name": "CastExample.java",
        "path": "examples/concepts/typevalues/CastExample.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/typevalues/CastExample.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires state(left) ** state(right);"
        },
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures state(this);"
        },
        {
          "limitHit": false,
          "lineNumber": 45,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires state(tt);"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:2 ; indent-tabs-mode:nil -*-\n//:: cases TreeWandSilverE1\n//:: tools silicon\n//:: verdict Fail\n/*\n    This file demonstrates how a magic wand can be used to prove\n    that the deletion of a node from a binary search tree is sound.\n    \n    vct --silver=silicon TreeWandSilver-e1.java\n\n    The expected result is Fail.\n*/\n\n/*@\n    requires t-\u003estate();\n    pure seq\u003cint\u003e tolist(Tree t)=(t==null)?seq\u003cint\u003e{}:\n        \\unfolding t.state() \\in tolist(t.left) + seq\u003cint\u003e{t.data} + tolist(t.right);\n    @*/\n\n  /*@\n\n    pure boolean sorted_list(seq\u003cint\u003e s)=\n      (\\forall int i ; 1 \u003c i \u0026\u0026 i \u003c |s| ; s[i-1] \u003c= s[i] );\n\n    requires t-\u003estate();\n    pure boolean sorted(Tree t)=sorted_list(tolist(t));\n  @*/\n\nfinal class Tree {\n  public int data;\n  public Tree left;\n  public Tree right;\n\n  /*@\n    inline resource state_contains(seq\u003cint\u003e L)=this.state() ** tolist(this)==L;\n\n    inline resource contains(Tree t,seq\u003cint\u003eL)=t-\u003estate() ** L == tolist(t);\n  @*/\n  \n  /*@ resource state()=Perm(data,write)**\n      Perm(left,write)**Perm(right,write)**left-\u003estate()**right-\u003estate();\n  @*/\n\n  //@ requires top!=null ** top.state();\n  //@ ensures  contains(\\result,\\old(tolist(top)).tail);\n  //@ ensures  \\old(sorted(top)) ==\u003e sorted(\\result);\n  public Tree del_min(Tree top){\n    //@ ghost seq\u003cint\u003e orig_contents=tolist(top);\n    //@ ghost seq\u003cint\u003e target_contents=(tolist(top)).tail;\n    //@ unfold top.state();\n    if (top.left == null) {\n      //@ assert orig_contents == tolist(top.left) + seq\u003cint\u003e{top.data} + tolist(top.right);\n      //@ assert tolist(top.left) == seq\u003cint\u003e{};\n      return top.left;\n    } else {\n      Tree cur, left;\n      cur = top;\n      left = top.left;\n      //@ ghost seq\u003cint\u003e cur_contents = orig_contents;\n      //@ assert cur_contents == tolist(left) + seq\u003cint\u003e{top.data} + tolist(top.right);\n      //@ unfold left.state();\n      //@ package top.state_contains(target_contents) -* top.state_contains(target_contents) {}\n\n      /*@\n      loop_invariant Perm(cur.left,write) ** Perm(cur.data,write) ** Perm(cur.right,write);\n      loop_invariant cur.left==left ** cur.right-\u003estate() ;\n      loop_invariant Perm(left.left,write) ** Perm(left.data,write) ** Perm(left.right,write);\n      loop_invariant left.left-\u003estate() ** left.right-\u003estate();\n      loop_invariant cur_contents == (tolist(left.left) + seq\u003cint\u003e{left.data} + tolist(left.right))\n                                      + seq\u003cint\u003e{cur.data} + tolist(cur.right);\n      loop_invariant (cur.state_contains((cur_contents).tail) -* top.state_contains(target_contents));\n      @*/\n      while (left.left != null)\n      {\n        //@ ghost Tree prev = cur;\n        //@ ghost seq\u003cint\u003e prev_contents = cur_contents;\n        cur = left;\n        left = cur.left;\n        /*@\n        unfold left.state();\n        ghost cur_contents = tolist(left.left) + seq\u003cint\u003e{left.data} + tolist(left.right);\n        ghost cur_contents = cur_contents + seq\u003cint\u003e{cur.data} + tolist(cur.right);\n        assert |prev_contents| \u003e 0 ;\n        assert |cur_contents| \u003e 0 ;\n        assert prev_contents == cur_contents + seq\u003cint\u003e{prev.data} + tolist(prev.right);\n        [/expect packageFailed:perm]\n        package (cur.state_contains((cur_contents).tail) -* top.state_contains(target_contents)) {}\n        [/end]\n        @*/\n      }\n      cur.left = left.right;\n      //@ fold cur.state();\n      //@ assert tolist(cur)==(cur_contents).tail;\n      //@ assert cur.state_contains(tolist(cur));\n      //@ assert cur.state_contains((cur_contents).tail);\n      //@ apply (cur.state_contains((cur_contents).tail) -* top.state_contains(target_contents));\n      return top;\n    }\n  }\n}\n\n",
        "name": "TreeWandSilver-e1.java",
        "path": "examples/concepts/wand/TreeWandSilver-e1.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/wand/TreeWandSilver-e1.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 43,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires top!=null ** top.state();"
        },
        {
          "limitHit": false,
          "lineNumber": 44,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  contains(\\result,\\old(tolist(top)).tail);"
        },
        {
          "limitHit": false,
          "lineNumber": 45,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  \\old(sorted(top)) ==\u003e sorted(\\result);"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:2 ; indent-tabs-mode:nil -*-\n//:: cases TreeWandSilverE2\n//:: tools silicon\n//:: verdict Fail\n/*\n    This file demonstrates how a magic wand can be used to prove\n    that the deletion of a node from a binary search tree is sound.\n    \n    vct --silver=silicon TreeWandSilver-e2.java\n\n    The expected result is Fail.\n*/\n\n/*@\n    requires t-\u003estate();\n    pure seq\u003cint\u003e tolist(Tree t)=(t==null)?seq\u003cint\u003e{}:\n        \\unfolding t.state() \\in tolist(t.left) + seq\u003cint\u003e{t.data} + tolist(t.right);\n    @*/\n\n  /*@\n\n    pure boolean sorted_list(seq\u003cint\u003e s)=\n      (\\forall int i ; 1 \u003c i \u0026\u0026 i \u003c |s| ; s[i-1] \u003c= s[i] );\n\n    requires t-\u003estate();\n    pure boolean sorted(Tree t)=sorted_list(tolist(t));\n  @*/\n\nfinal class Tree {\n  public int data;\n  public Tree left;\n  public Tree right;\n\n  /*@\n    inline resource state_contains(seq\u003cint\u003e L)=this.state() ** tolist(this)==L;\n\n    inline resource contains(Tree t,seq\u003cint\u003eL)=t-\u003estate() ** L == tolist(t);\n  @*/\n\n  /*@ resource state()=Perm(data,write)\n        **Perm(left,write)\n        **Perm(right,write)\n        **left-\u003estate()\n        **right-\u003estate();\n  @*/\n\n  //@ requires top!=null ** top.state();\n  //@ ensures  contains(\\result,\\old(tolist(top)).tail);\n  //@ ensures  \\old(sorted(top)) ==\u003e sorted(\\result);\n  public Tree del_min(Tree top){\n    //@ ghost seq\u003cint\u003e orig_contents=tolist(top);\n    //@ ghost seq\u003cint\u003e target_contents=(tolist(top)).tail;\n    //@ unfold top.state();\n    if (top.left == null) {\n      //@ assert orig_contents == tolist(top.left) + seq\u003cint\u003e{top.data} + tolist(top.right);\n      //@ assert tolist(top.left) == seq\u003cint\u003e{};\n      return top.right;\n    } else {\n      Tree cur, left;\n      cur = top;\n      left = top.left;\n      //@ ghost seq\u003cint\u003e cur_contents = orig_contents;\n      //@ assert cur_contents == tolist(left) + seq\u003cint\u003e{top.data} + tolist(top.right);\n      //@ unfold left.state();\n      //@ package (top.state_contains(target_contents) -* top.state_contains(target_contents)) {}\n\n      /*@\n      loop_invariant Perm(cur.left, write) ** Perm(cur.data, write) ** Perm(cur.right, write);\n      loop_invariant cur.left == left ** cur.right-\u003estate();\n      loop_invariant Perm(left.left, write) ** Perm(left.data, write) ** Perm(left.right, write);\n      loop_invariant left.left-\u003estate() ** left.right-\u003estate();\n      loop_invariant cur_contents == (tolist(left.left) + seq\u003cint\u003e{left.data} + tolist(left.right))\n                                      + seq\u003cint\u003e{cur.data} + tolist(cur.right);\n      loop_invariant (cur.state_contains((cur_contents).tail) -* top.state_contains(target_contents));\n      @*/\n      while (left.left != null)\n      {\n        //@ ghost Tree prev = cur;\n        //@ ghost seq\u003cint\u003e prev_contents = cur_contents;\n        cur = left;\n        left = cur.left;\n        /*@\n        unfold left.state();\n        ghost cur_contents = tolist(left.left) + seq\u003cint\u003e{left.data} + tolist(left.right);\n        ghost cur_contents = cur_contents + seq\u003cint\u003e{cur.data} + tolist(cur.right);\n        assert |prev_contents| \u003e 0 ;\n        assert |cur_contents| \u003e 0 ;\n        assert prev_contents == cur_contents + seq\u003cint\u003e{prev.data} + tolist(prev.right);\n        package (cur.state_contains(cur_contents.tail) -* top.state_contains(target_contents)) {\n          fold prev.state();\n          apply prev.state_contains(prev_contents.tail) -* top.state_contains(target_contents);\n        }\n        @*/\n      }\n      cur.left = left.left;\n      //@ fold cur.state();\n      /*@\n      [/expect assertFailed:false]\n      assert tolist(cur)==(cur_contents).tail;\n      [/end]\n      @*/\n      //@ assert cur.state_contains(tolist(cur));\n      //@ assert cur.state_contains((cur_contents).tail);\n      //@ apply cur.state_contains((cur_contents).tail) -* top.state_contains(target_contents);\n      return top;\n    }\n  }\n}\n\n",
        "name": "TreeWandSilver-e2.java",
        "path": "examples/concepts/wand/TreeWandSilver-e2.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/wand/TreeWandSilver-e2.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 46,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires top!=null ** top.state();"
        },
        {
          "limitHit": false,
          "lineNumber": 47,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  contains(\\result,\\old(tolist(top)).tail);"
        },
        {
          "limitHit": false,
          "lineNumber": 48,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  \\old(sorted(top)) ==\u003e sorted(\\result);"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:2 ; indent-tabs-mode:nil -*-\n//:: cases RosterFixed\n//:: tools silicon\n//:: verdict Pass\n\n/* See pg 42, phd Hurlin. */\n\nfinal class Roster {\n  int id;\n  int grade;\n  Roster next;\n\n/*@\n  resource ids_and_links()=Perm(id,1) ** Perm(next,1\\2) ** next-\u003eids_and_links();\n \n  resource grades_and_links()=Perm(grade,1) ** Perm(next,1\\2) ** next-\u003egrades_and_links() ;\n\n  resource state()= ids_and_links() ** grades_and_links();\n */\n \n  //@ requires n-\u003estate();\n  //@ ensures this.state();\n  Roster(int i, int g, Roster n) {\n    id = i;\n    grade = g;\n    next = n;\n    /*@ ghost\n      if (n!=null) { unfold n.state(); }\n    */\n    //@ fold ids_and_links();\n    //@ fold grades_and_links();\n    //@ fold state();\n  }\n\n  //@ requires state();\n  //@ ensures state();\n  void updateGrade(int id, int grade) {\n    /*@\n      unfold state();\n      unfold ids_and_links();\n      unfold grades_and_links();\n    @*/\n    if (this.id == id) {\n      this.grade = grade;\n    } else if (next != null) {\n      //@ fold next.state();\n      next.updateGrade(id,grade);\n      //@ unfold next.state();\n    }\n    /*@\n      fold ids_and_links();\n      fold grades_and_links();\n      fold state();\n    @*/\n  }\n\n  //@ requires ids_and_links();\n  //@ ensures ids_and_links();\n  boolean contains(int id) {\n    //@ unfold ids_and_links();\n    boolean b = this.id==id;\n    if(!b \u0026\u0026 next!=null){\n      b=next.contains(id);\n    }\n    //@ fold ids_and_links();\n    return b;\n  }\n}\n\n",
        "name": "RosterFixed.java",
        "path": "examples/concepts/permissions/RosterFixed.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/permissions/RosterFixed.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires n-\u003estate();"
        },
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures this.state();"
        },
        {
          "limitHit": false,
          "lineNumber": 34,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires state();"
        },
        {
          "limitHit": false,
          "lineNumber": 35,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures state();"
        },
        {
          "limitHit": false,
          "lineNumber": 56,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires ids_and_links();"
        },
        {
          "limitHit": false,
          "lineNumber": 57,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures ids_and_links();"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "package java.lang;\n\npublic class Exception extends Throwable {\n    Exception() {\n        //@ assume false;\n    }\n\n    //@ ensures getMessage() == msg;\n    Exception(String msg) {\n        //@ assume false;\n    }\n    public /*@ pure @*/ String getMessage();\n    public void printStackTrace();\n}",
        "name": "Exception.java",
        "path": "res/universal/res/jdk/java/lang/Exception.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/res/universal/res/jdk/java/lang/Exception.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures getMessage() == msg;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:4 ; indent-tabs-mode:nil -*-\n//:: cases OverloadedReturn\n//:: tools silicon\n//:: verdict Pass\n\nclass C {\n    //@ ensures \\result == x + 2;\n    int m(int x) {\n        try {\n            return x + 2;\n        } finally {\n\n        }\n    }\n\n    //@ ensures \\result == x + y + 10;\n    int m(int x, int y) {\n        try {\n            return x + y + 10;\n        } finally {\n\n        }\n    }\n}",
        "name": "OverloadedReturn.java",
        "path": "examples/concepts/abrupt/OverloadedReturn.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/abrupt/OverloadedReturn.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result == x + 2;"
        },
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result == x + y + 10;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:2 ; indent-tabs-mode:nil -*-\n//:: cases TypeExample1\n//:: tools silicon\n//:: verdict Pass\n\n/*\n  This file show how the syntax for stating that an object \n  is an instance of a specific class (\\typeof) works.\n  It is future work to make sure that the knowledge\n  that this is an instance of C is automatically added.\n*/\n\nclass C {\n\n  //@ requires \\typeof(this) == \\type(C);\n  void m1(){\n    //@ assert this instanceof C;\n    //@ assert \\typeof(this) == \\type(C);\n  }\n  \n  //@ requires this instanceof C;\n  void m2(){\n    //@ assert this instanceof C;\n  }\n\n}\n",
        "name": "TypeExample1.java",
        "path": "examples/concepts/typevalues/TypeExample1.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/typevalues/TypeExample1.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires \\typeof(this) == \\type(C);"
        },
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires this instanceof C;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:2 ; indent-tabs-mode:nil -*-\n//:: cases Separate\n\n//:: cases SeparateUtil\n//:: tools silicon\n//:: verdict Fail\n\npackage separate;\n\npublic class Util {\n\n\n    /*[/expect postFailed:false]*/\n    //@ ensures \\result==x+1;\n    public static int incr(int x){\n      return x+2;\n    }\n    /*[/end]*/\n}\n",
        "name": "Util.java",
        "path": "examples/concepts/import/src/separate/Util.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/import/src/separate/Util.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result==x+1;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "//:: cases SynchronizedReturn\n//:: tools silicon\n//:: verdict Fail\n\n/*\nIn this file it is tested if the return statement below is not accidentally encoded using a goto-oblivious encoding,\nwhich would turn the return statement into \"inhale false;\", since control flow does not proceed to after the return\nstatement. However, the synchronized keyword requires the intrinsic lock of the class to be unlocked, so in fact other\ncode _is_ executed after the return statement. Since the method n() steals the held predicate, this synchronized-related\nclean-up code should fail in the normal case, but if the goto-oblivious encoding is used this is not the case.\n*/\n\n/*[/expect heldFailed:perm]*/\n\n//@ lock_invariant Perm(f, 1);\nclass C {\n    int f;\n\n    //@ ensures committed(this);\n    C() {\n        //@ commit this;\n    }\n\n    //@ requires committed(this);\n    synchronized void m() {\n        n();\n        return;\n    }\n\n    /*@\n    requires held(this); // Steal the lock\n     @*/\n    void n() {\n\n    }\n}\n\n/*[/end]*/",
        "name": "SynchronizedReturn.java",
        "path": "examples/concepts/abrupt/SynchronizedReturn.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/abrupt/SynchronizedReturn.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 18,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures committed(this);"
        },
        {
          "limitHit": false,
          "lineNumber": 23,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires committed(this);"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:4 ; indent-tabs-mode:nil -*-\n//:: cases ExceptionsAndAbrupt.java\n//:: tools silicon\n//:: verdict Pass\n\n// This is an adaptation of a file from the examples directory of key.\n// Original file path: KEY_ROOT/key/key.ui/examples/standard_key/java_dl/exceptions_java/MyClass2.java\n// It has been adapted to use the vercors syntax for specifications.\n\npublic class C {\n    //@ ensures \\old(input_i) == 0 ==\u003e \\result == \\old(input_i) + 2;\n    //@ ensures \\old(input_i) != 0 ==\u003e \\result == \\old(input_i) + 3;\n    public int foo(int input_i) {\n        int i = input_i;\n        l1: {\n            try{\n                if (i==0) {\n                    break l1;\n                }\n                i = i + 1;\n            } catch (Exception e) {\n                // Nothing\n                //@ assert false; // Is not executed\n            } finally{\n                i = i + 1;\n            }\n        }\n\n        i = i + 1;\n\n        return i;\n    }\n\n    //@ ensures \\result == 2;\n    public int bar() {\n        IllegalArgumentException e = new IllegalArgumentException();\n        int i = 0;\n        try {\n            throw e;\n        } catch (IllegalStateException e0) {\n            //@ assert false; // Should never happen\n            return 0;\n        } catch (RuntimeException e1) {\n            i = 10;\n            return 1;\n        } finally {\n            //@ assert i == 10; // Went through the RunTimeException first\n            return 2;\n        }\n    }\n}\n",
        "name": "ExceptionsAndAbrupt.java",
        "path": "examples/concepts/abrupt/ExceptionsAndAbrupt.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/abrupt/ExceptionsAndAbrupt.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\old(input_i) == 0 ==\u003e \\result == \\old(input_i) + 2;"
        },
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\old(input_i) != 0 ==\u003e \\result == \\old(input_i) + 3;"
        },
        {
          "limitHit": false,
          "lineNumber": 33,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result == 2;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "package casino;\n\nimport org.javabip.annotations.*;\nimport org.javabip.api.PortType;\nimport static casino.Coin.HEADS;\nimport static casino.Coin.TAILS;\nimport static casino.Constants.*;\n\n@Port(name = PREPARE_BET, type = PortType.enforceable)\n@Port(name = PLACE_BET, type = PortType.enforceable)\n@Port(name = RECEIVE_MONEY, type = PortType.enforceable)\n@ComponentType(initial = GAME_AVAILABLE, name = PLAYER_SPEC)\n@Invariant(\"purse \u003e= 0 \u0026\u0026 id != null\")\n@StatePredicate(state = BET_PREPARED, expr = \"guess != null \u0026\u0026 bet \u003e= 0\")\npublic class Player {\n    final Integer id;\n    int bet;\n    Coin guess;\n    int purse;\n\n    //@ requires purse \u003e= 0;\n    Player(int id, int purse) {\n        this.id = new Integer(id);\n        this.purse = purse;\n        //@ ghost System.staticInvariant();\n        System.out.println(\"PLAYER\" + this.id.toString() + \": INITIALIZED\");\n    }\n    \n    // Player prepares a bet\n    @Transition(name = PREPARE_BET, source = GAME_AVAILABLE, target = BET_PREPARED)\n    public void prepareBet() {\n        bet = (int) (Math.random() * purse);\n        guess = Math.random() \u003c 0.5 ? HEADS : TAILS;\n        purse = purse - bet;\n        //@ ghost System.staticInvariant();\n        System.out.println(\"PLAYER\" + id.toString()\n                + \": bet \" + new Integer(bet).toString()\n                + \" prepared, purse: \" + new Integer(purse).toString());\n    }\n\n    // Player places a bet\n    @Transition(name = PLACE_BET, source = BET_PREPARED, target = GAME_AVAILABLE)\n    public void placeBet() {\n        //@ ghost System.staticInvariant();\n        System.out.println(\"PLAYER\" + id.toString()\n                + \": bet \" + new Integer(bet).toString()\n                + \" placed, purse: \" + new Integer(purse).toString());\n        bet = 0;\n        guess = null;\n    }\n\n    // Player receives a contribution\n    @Transition(name = RECEIVE_MONEY, source = GAME_AVAILABLE, target = GAME_AVAILABLE,\n        requires = \"win \u003e= 0\" // Needed, otherwise VerCors cannot prove invariant again. E.g. what if win is negative? This is excluded by the casino invariant \"bet \u003e= 0\"\n    )\n    public void receiveContribution(@Data(name = INCOMING_MONEY) int win) {\n        purse += win;\n        //@ ghost System.staticInvariant();\n        System.out.println(\"PLAYER\" + id.toString()\n                + \": won \" + new Integer(win).toString()\n                + \" purse: \" + new Integer(purse).toString());\n    }\n\n    @Data(name = OUTGOING_BET)\n    @Pure\n    public int getBet() {\n        return bet;\n    }\n\n    @Data(name = OUTGOING_GUESS)\n    @Pure\n    public Coin getGuess() {\n        return guess;\n    }\n\n    @Data(name = ID)\n    @Pure\n    public Integer id() {\n        return id;\n    }\n}\n",
        "name": "Player.java",
        "path": "examples/concepts/javabip/casinoBroken/Player.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/javabip/casinoBroken/Player.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires purse \u003e= 0;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:4 ; indent-tabs-mode:nil -*-\n//:: cases SignalsThrowNoThrows\n//:: tools silicon\n//:: verdict Pass\n\nfinal class MyException extends Exception { }\n\nfinal class FooException extends RuntimeException { }\n\nfinal class MyClass {\n    int x;\n\n    //@ requires Perm(x, 1);\n    //@ signals (FooException e) Perm(x, 1) ** x == 10;\n    //@ ensures Perm(x, 1) ** x == (\\old(x) + 1);\n    final void foo() {\n        x = x + 1;\n    }\n\n    //@ requires Perm(x, 1);\n    //@ ensures Perm(x, 1) ** (x == 40 || x == 50);\n    final void bar() {\n        try {\n            foo();\n            x = 20;\n            //@ assert x == 20;\n            throw new MyException();\n            //@ assert false;\n            x = 30;\n        } catch (MyException e) {\n            //@ assert x == 20;\n            x = 40;\n            //@ assert x == 40;\n        } catch (FooException f) {\n            //@ assert x == 10;\n            x = 50;\n            //@ assert x == 50;\n        }\n        //@ assert x == 40 || x == 50;\n    }\n}\n",
        "name": "SignalsThrowNoThrows.java",
        "path": "examples/concepts/abrupt/SignalsThrowNoThrows.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/abrupt/SignalsThrowNoThrows.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires Perm(x, 1);"
        },
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures Perm(x, 1) ** x == (\\old(x) + 1);"
        },
        {
          "limitHit": false,
          "lineNumber": 19,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires Perm(x, 1);"
        },
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures Perm(x, 1) ** (x == 40 || x == 50);"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:4 ; indent-tabs-mode:nil -*-\n//:: cases NestedTryCatchFinally\n//:: tools silicon\n//:: verdict Pass\n\nimport java.io.*;\n\nclass C {\n    //@ signals (IOException e) true;\n    //@ ensures false;\n    void m() throws IOException {\n        try {\n            throw new IOException();\n        } finally {\n            try {\n                throw new ArithmeticException();\n            } catch (ArithmeticException e) {\n\n            }\n        }\n    }\n}\n",
        "name": "NestedTryCatchFinally.java",
        "path": "examples/concepts/abrupt/NestedTryCatchFinally.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/abrupt/NestedTryCatchFinally.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures false;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "package casino;\n\nimport org.javabip.annotations.*;\nimport org.javabip.api.DataOut;\nimport org.javabip.api.PortType;\n\nimport static casino.Constants.*;\n\n@Port(name = CREATE_GAME, type = PortType.enforceable)\n@Port(name = ADD_TO_POT, type = PortType.enforceable)\n@Port(name = REMOVE_FROM_POT, type = PortType.enforceable)\n@Port(name = DECIDE_BET, type = PortType.enforceable)\n@Port(name = PREPARE_TO_ADD, type = PortType.enforceable)\n@Port(name = PREPARE_TO_REMOVE, type = PortType.enforceable)\n@ComponentType(initial = WORKING, name = OPERATOR_SPEC)\n@Invariant(\"pot \u003e= 0 \u0026\u0026 wallet \u003e= 0 \u0026\u0026 id != null\")\n@StatePredicate(state = PUT_FUNDS, expr = \"amountToMove \u003e= 0\")\n@StatePredicate(state = WITHDRAW_FUNDS, expr = \"0 \u003c= amountToMove \u0026\u0026 amountToMove \u003c= pot\")\npublic class Operator {\n    final Integer id;\n    int wallet;\n    int pot;\n    int amountToMove;\n\n    //@ requires id != null;\n    Operator (Integer id, int funds) throws Exception {\n        this.id = id;\n        if (funds \u003c 0) throw new Exception(\"Cannot have negative funds\");\n        wallet = funds;\n        amountToMove = 0;\n        //@ ghost System.staticInvariant();\n        System.out.println(\"OPERATOR\" + id.toString() + \" created with wallet: \" + new Integer(wallet).toString());\n    }\n\n    @Transition(name = CREATE_GAME, source = WORKING, target = WORKING, requires = \"newPot \u003e= 0\")\n    @Transition(name = CREATE_GAME, source = PUT_FUNDS, target = PUT_FUNDS, requires = \"newPot \u003e= 0\")\n    @Transition(name = CREATE_GAME, source = WITHDRAW_FUNDS, target = WITHDRAW_FUNDS, requires = \"newPot \u003e= 0\")\n    @Transition(name = DECIDE_BET, source = WORKING, target = WORKING, requires = \"newPot \u003e= 0\")\n    @Transition(name = DECIDE_BET, source = PUT_FUNDS, target = PUT_FUNDS, requires = \"newPot \u003e= 0\")\n    @Transition(name = DECIDE_BET, source = WITHDRAW_FUNDS, target = WITHDRAW_FUNDS, requires = \"newPot \u003e= 0\")\n    public void gameStep(@Data(name = AVAILABLE_FUNDS) int newPot) {\n        this.pot = newPot;\n        //@ ghost System.staticInvariant();\n        System.out.println(\"OPERATOR\" + id.toString() + \": making one step in the game\");\n    }\n\n    @Transition(name = PREPARE_TO_ADD, source = WORKING, target = PUT_FUNDS, guard = ENOUGH_FUNDS)\n    public void prepareAmountToPut() {\n        amountToMove = (int) (Math.random() * wallet); // Note: Math.random is replaced with 0 here (temporary workaround for static method access)\n        wallet -= amountToMove;\n        //@ ghost System.staticInvariant();\n        System.out.println(\"OPERATOR\" + id.toString()\n                + \": decided to put \" + new Integer(amountToMove).toString()\n                + \", wallet: \" + new Integer(wallet).toString());\n    }\n\n    @Transition(name = PREPARE_TO_REMOVE, source = WORKING, target = WITHDRAW_FUNDS)\n    public void prepareAmountToWithdraw() {\n        amountToMove = (int) (Math.random() * pot); // Note: Math.random is replaced with 0 here (temporary workaround for static method access)\n        //@ ghost System.staticInvariant();\n        System.out.println(\"OPERATOR\" + id.toString()\n                + \": decided to withdraw \" + new Integer(amountToMove).toString()\n                + \", wallet: \" + new Integer(wallet).toString());\n    }\n\n    @Transition(name = ADD_TO_POT, source = PUT_FUNDS, target = WORKING, requires = \"newPot \u003e= 0\")\n    public void addToPot (@Data(name = AVAILABLE_FUNDS) int newPot) {\n        this.pot = newPot + amountToMove;\n        //@ ghost System.staticInvariant();\n        System.out.println(\"OPERATOR\" + id.toString()\n                + \": added \" + new Integer(amountToMove).toString()\n                + \" to pot, wallet: \" + new Integer(wallet).toString());\n    }\n\n    @Transition(name = REMOVE_FROM_POT, source = WITHDRAW_FUNDS, target = WORKING)\n    public void removeFromPot (@Data(name = AVAILABLE_FUNDS) int newPot) {\n        wallet += amountToMove;\n        this.pot = newPot - amountToMove;\n        //@ ghost System.staticInvariant();\n        System.out.println(\"OPERATOR\" + id.toString() +\n                \": removed \" + new Integer(amountToMove).toString()\n                + \" from pot, wallet: \" + new Integer(wallet).toString());\n    }\n\n    @Pure\n    @Guard(name = ENOUGH_FUNDS)\n    public boolean haveMoney() {\n        return wallet \u003e 0;\n    }\n\n    @Pure\n    @Data(name = OUTGOING_FUNDS, accessTypePort = /*@ \\replacing(0) */ DataOut.AccessType.allowed /*@ \\replacing_done */, ports = {ADD_TO_POT, REMOVE_FROM_POT})\n    public int funds() {\n        return amountToMove;\n    }\n\n    @Pure\n    @Data(name = ID)\n    public Integer id() {\n        return id;\n    }\n}\n",
        "name": "Operator.java",
        "path": "examples/concepts/javabip/casinoBroken/Operator.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/javabip/casinoBroken/Operator.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 24,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires id != null;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "package casino;\n\nimport org.javabip.annotations.*;\nimport org.javabip.api.PortType;\nimport static casino.Coin.HEADS;\nimport static casino.Coin.TAILS;\nimport static casino.Constants.*;\n\n@Port(name = PREPARE_BET, type = PortType.enforceable)\n@Port(name = PLACE_BET, type = PortType.enforceable)\n@Port(name = RECEIVE_MONEY, type = PortType.enforceable)\n@ComponentType(initial = GAME_AVAILABLE, name = PLAYER_SPEC)\n@Invariant(\"purse \u003e= 0 \u0026\u0026 id != null\")\n@StatePredicate(state = BET_PREPARED, expr = \"guess != null \u0026\u0026 bet \u003e= 0\")\npublic class Player {\n    final Integer id;\n    int bet;\n    Coin guess;\n    int purse;\n\n    //@ requires purse \u003e= 0;\n    Player(int id, int purse) {\n        this.id = new Integer(id);\n        this.purse = purse;\n        //@ ghost System.staticInvariant();\n        System.out.println(\"PLAYER\" + this.id.toString() + \": INITIALIZED\");\n    }\n    \n    // Player prepares a bet\n    @Transition(name = PREPARE_BET, source = GAME_AVAILABLE, target = BET_PREPARED)\n    public void prepareBet() {\n        bet = (int) (Math.random() * purse);\n        guess = Math.random() \u003c 0.5 ? HEADS : TAILS;\n        purse = purse - bet;\n        //@ ghost System.staticInvariant();\n        System.out.println(\"PLAYER\" + id.toString()\n                + \": bet \" + new Integer(bet).toString()\n                + \" prepared, purse: \" + new Integer(purse).toString());\n    }\n\n    // Player places a bet\n    @Transition(name = PLACE_BET, source = BET_PREPARED, target = GAME_AVAILABLE)\n    public void placeBet() {\n        //@ ghost System.staticInvariant();\n        System.out.println(\"PLAYER\" + id.toString()\n                + \": bet \" + new Integer(bet).toString()\n                + \" placed, purse: \" + new Integer(purse).toString());\n        bet = 0;\n        guess = null;\n    }\n\n    // Player receives a contribution\n    @Transition(name = RECEIVE_MONEY, source = GAME_AVAILABLE, target = GAME_AVAILABLE,\n        requires = \"win \u003e= 0\" // Needed, otherwise VerCors cannot prove invariant again. E.g. what if win is negative? This is excluded by the casino invariant \"bet \u003e= 0\"\n    )\n    public void receiveContribution(@Data(name = INCOMING_MONEY) int win) {\n        purse += win;\n        //@ ghost System.staticInvariant();\n        System.out.println(\"PLAYER\" + id.toString()\n                + \": won \" + new Integer(win).toString()\n                + \" purse: \" + new Integer(purse).toString());\n    }\n\n    @Data(name = OUTGOING_BET)\n    @Pure\n    public int getBet() {\n        return bet;\n    }\n\n    @Data(name = OUTGOING_GUESS)\n    @Pure\n    public Coin getGuess() {\n        return guess;\n    }\n\n    @Data(name = ID)\n    @Pure\n    public Integer id() {\n        return id;\n    }\n}\n",
        "name": "Player.java",
        "path": "examples/concepts/javabip/casinoAdjusted/Player.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/javabip/casinoAdjusted/Player.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires purse \u003e= 0;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:2 ; indent-tabs-mode:nil -*-\n//:: cases Semaphore\n//:: tools chalice\n//:: verdict Pass\n//:: options --explicit\n\n/*\n Example: Semaphore\n Description: Semaphore using AtomicInteger as synchronizer.\n Author: Afshin Amighi\n Status: Pass.\n command: vct --chalice --explicit Semaphore.java\n */\n\npublic class Semaphore{\n\n    // partd resource\n    private int data;\n\n    // constants are not supported\n    // ghost final int S=0;\n\n    // maximum number of thread concurrently using the partd resource (data).\n    //@ int permits;\n\n    // resource invariant\n    //@ resource inv(zfrac p) = Perm(data,p);\n    //@ pure zfrac part(int r, int v, int M){ return (r==0 \u0026\u0026 v\u003e=0 \u0026\u0026 M\u003e0 \u0026\u0026 v\u003c=M \u0026\u0026 M\u003c=100) ? ((v*100)/M) : (0); }\n\n    /* ------- AtomicInteger ------------*/\n    /* only the methods and contracts used in the verification. */\n\n    //@ requires true;\n    //@ ensures true;\n    public int get();\n\n    //@ given int max;\n    //@ requires max \u003e0 \u0026\u0026 x \u003c=max \u0026\u0026 n\u003c=max \u0026\u0026 100%max==0;\n    //@ requires cri:inv(part(0,n,max)-part(0,x,max));\n    //@ ensures  \\result ==\u003e cepi:inv(part(0,x,max)-part(0,n,max));\n    //@ ensures !\\result ==\u003e ceni:inv(part(0,n,max)-part(0,x,max));\n    public boolean compareAndSet(int x, int n);\n\n    /*---------- Semaphore --------------*/\n\n    //@ requires Value(permits) ** permits\u003e0 ** permits \u003c=100 ** 100%permits==0;\n    //@ ensures !\\result ==\u003e Value(permits) ** permits\u003e0 ** permits \u003c=100 ** 100%permits==0;\n    //@ ensures \\result ==\u003e Value(permits) ** permits \u003c=100 ** permits\u003e0  ** tae: inv(100/permits);\n    private boolean tryAcquire(){\n        boolean r = false;\n        //@ witness tcri:inv(*);\n        //@ witness tcepi:inv(*);\n        //@ witness tceni:inv(*);\n        int c = get();\n        if( c \u003e 0 ){\n            int nextc = c-1;\n            //@ assume c \u003c= permits;\n\n            //@    fold tcri: inv(part(0,nextc,permits)-part(0,c,permits));\n            r = compareAndSet(c,nextc) /*@ with { max=permits; cri = tcri; } then { tcepi = cepi; tceni = ceni; } @*/;\n            //@    assert (c*100)/permits-(nextc*100)/permits == 100/permits;\n\n            /*@\n             if(r){\n                tae = tcepi;\n             }else{\n                unfold tceni: inv(part(0,nextc,permits)-part(0,c,permits));\n             }\n             @*/\n\n        }\n        return r;\n    }\n\n    //@ requires Value(permits)**permits\u003e0** permits\u003c=100 ** 100%permits==0;\n    //@ ensures Value(permits)**permits\u003e0** permits\u003c=100 ** 100%permits==0 ** dae:inv(100/permits);\n    public void doAcquire(){\n        //@ witness tri:inv(*);\n        boolean stop = tryAcquire() /*@ with{} then{ tri = tae; } @*/;\n        /*\n         if(stop)\n            dae = tri;\n         */\n\n        //@ loop_invariant stop ==\u003e Value(permits)** permits\u003e0 ** permits\u003c=100 ** 100%permits==0 ** lri:inv(100/permits);\n        //@ loop_invariant !stop ==\u003e Value(permits)** permits\u003e0 ** permits\u003c=100 ** 100%permits==0;\n        while(!stop) /*@ with { lri=tri; } then { dae =lri ;} @*/{\n            stop = tryAcquire() /*@ with {} then { lri=tae; } @*/;\n        }\n    }\n\n    //@ requires Value(permits) ** permits\u003e0 ** permits\u003c=100 ** 100%permits==0 ** trr:inv(100/permits);\n    //@ ensures \\result ==\u003e Value(permits) ** permits\u003e0 ** permits\u003c=100;\n    //@ ensures !\\result ==\u003e Value(permits) ** permits\u003e0 ** permits\u003c=100 ** tre:inv(100/permits);\n    private boolean tryRelease(){\n        boolean r = false;\n        //@ witness tcri:inv(*);\n        //@ witness tcepi:inv(*);\n        //@ witness tceni:inv(*);\n        int c = get();\n        //@ assume c\u003cpermits \u0026\u0026 c\u003e=0;\n        int nextc = c+1;\n        //@    assert (nextc*100)/permits-(c*100)/permits == 100/permits;\n        // fold tcri: inv(part(0,nextc,permits)-part(0,c,permits));\n        r = compareAndSet(c,nextc) /*@ with { max = permits; cri = trr; } then { tcepi = cepi; tceni = ceni; } @*/;\n        /*@ if(r){\n            unfold tcepi:inv(part(0,c,permits)-part(0,nextc,permits));\n         }else{\n             tre=tceni;\n         }@*/\n        return r;\n    }\n\n    //@ requires Value(permits)**permits\u003e0 ** permits\u003c=100 ** 100%permits==0 ** dar:inv(100/permits);\n    //@ ensures Value(permits)**permits\u003e0 ** permits\u003c=100 ** 100%permits==0;\n    public void doRelease(){\n        //@ witness tri:inv(*);\n        boolean stop = tryRelease() /*@ with { trr = dar; } then { tri=tre; } @*/;\n        /*\n         if(!stop)\n            dae = tri;\n         */\n\n        //@ loop_invariant (!stop) ==\u003e Value(permits)**permits\u003e0**permits\u003c=100**100%permits==0**lri:inv(100/permits);\n        //@ loop_invariant (stop) ==\u003e Value(permits)**permits\u003e0**permits\u003c=100**100%permits==0;\n        while(!stop) /*@ with { lri = tri; } then {} @*/{\n            stop = tryRelease() /*@ with { trr=lri; } then { lri=tre; } @*/;\n        }\n    }\n}\n",
        "name": "Semaphore.java",
        "path": "examples/archive/chalice/synchronizers/Semaphore.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/archive/chalice/synchronizers/Semaphore.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 32,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 33,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 37,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires max \u003e0 \u0026\u0026 x \u003c=max \u0026\u0026 n\u003c=max \u0026\u0026 100%max==0;"
        },
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires cri:inv(part(0,n,max)-part(0,x,max));"
        },
        {
          "limitHit": false,
          "lineNumber": 40,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures !\\result ==\u003e ceni:inv(part(0,n,max)-part(0,x,max));"
        },
        {
          "limitHit": false,
          "lineNumber": 45,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires Value(permits) ** permits\u003e0 ** permits \u003c=100 ** 100%permits==0;"
        },
        {
          "limitHit": false,
          "lineNumber": 46,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures !\\result ==\u003e Value(permits) ** permits\u003e0 ** permits \u003c=100 ** 100%permits==0;"
        },
        {
          "limitHit": false,
          "lineNumber": 47,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result ==\u003e Value(permits) ** permits \u003c=100 ** permits\u003e0  ** tae: inv(100/permits);"
        },
        {
          "limitHit": false,
          "lineNumber": 74,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires Value(permits)**permits\u003e0** permits\u003c=100 ** 100%permits==0;"
        },
        {
          "limitHit": false,
          "lineNumber": 75,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures Value(permits)**permits\u003e0** permits\u003c=100 ** 100%permits==0 ** dae:inv(100/permits);"
        },
        {
          "limitHit": false,
          "lineNumber": 91,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires Value(permits) ** permits\u003e0 ** permits\u003c=100 ** 100%permits==0 ** trr:inv(100/permits);"
        },
        {
          "limitHit": false,
          "lineNumber": 92,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result ==\u003e Value(permits) ** permits\u003e0 ** permits\u003c=100;"
        },
        {
          "limitHit": false,
          "lineNumber": 93,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures !\\result ==\u003e Value(permits) ** permits\u003e0 ** permits\u003c=100 ** tre:inv(100/permits);"
        },
        {
          "limitHit": false,
          "lineNumber": 113,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires Value(permits)**permits\u003e0 ** permits\u003c=100 ** 100%permits==0 ** dar:inv(100/permits);"
        },
        {
          "limitHit": false,
          "lineNumber": 114,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures Value(permits)**permits\u003e0 ** permits\u003c=100 ** 100%permits==0;"
        },
        {
          "limitHit": false,
          "lineNumber": 39,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  \\result ==\u003e cepi:inv(part(0,x,max)-part(0,n,max));"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "//:: cases CatchWhile\n//:: tools silicon\n//:: verdict Pass\n\nclass CatchWhile {\n    boolean randomBoolean();\n\n    //@ requires n \u003e= 0;\n    void m (int n) {\n        boolean[] xs = new boolean[n];\n        boolean throwB = randomBoolean();\n\n        try {\n            if (throwB) {\n                throw new Exception();\n            }\n        } catch (Exception e) {\n            int i = 0;\n            //@ loop_invariant 0 \u003c= i \u0026\u0026 i \u003c= n;\n            //@ loop_invariant xs != null ** xs.length == n;\n            //@ loop_invariant (\\forall* int j = 0 .. n; Perm(xs[j], write));\n            //@ loop_invariant (\\forall int j = 0 .. i; xs[j]);\n            while (i \u003c n) {\n                xs[i] = true;\n                i++;\n            }\n        }\n\n        //@ assert xs != null ** xs.length == n;\n        //@ assert (\\forall* int j = 0 .. n; Perm(xs[j], write));\n\n        if (throwB) {\n            //@ assert (\\forall int j = 0 .. n; xs[j]);\n        } else {\n            //@ assert (\\forall int j = 0 .. n; !xs[j]);\n        }\n    }\n}\n\n\n\n",
        "name": "CatchWhile.java",
        "path": "examples/technical/exception-patterns/CatchWhile.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/technical/exception-patterns/CatchWhile.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires n \u003e= 0;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "package casino;\n\nimport org.javabip.annotations.*;\nimport org.javabip.api.DataOut;\nimport org.javabip.api.PortType;\n\nimport static casino.Constants.*;\n\n@Port(name = CREATE_GAME, type = PortType.enforceable)\n@Port(name = ADD_TO_POT, type = PortType.enforceable)\n@Port(name = REMOVE_FROM_POT, type = PortType.enforceable)\n@Port(name = DECIDE_BET, type = PortType.enforceable)\n@Port(name = PREPARE_TO_ADD, type = PortType.enforceable)\n@Port(name = PREPARE_TO_REMOVE, type = PortType.enforceable)\n@ComponentType(initial = WORKING, name = OPERATOR_SPEC)\n@Invariant(\"pot \u003e= 0 \u0026\u0026 wallet \u003e= 0 \u0026\u0026 id != null\")\n@StatePredicate(state = PUT_FUNDS, expr = \"amountToMove \u003e= 0\")\n@StatePredicate(state = WITHDRAW_FUNDS, expr = \"0 \u003c= amountToMove \u0026\u0026 amountToMove \u003c= pot\")\npublic class Operator {\n    final Integer id;\n    int wallet;\n    int pot;\n    int amountToMove;\n\n    //@ requires id != null;\n    Operator (Integer id, int funds) throws Exception {\n        this.id = id;\n        if (funds \u003c 0) throw new Exception(\"Cannot have negative funds\");\n        wallet = funds;\n        amountToMove = 0;\n        //@ ghost System.staticInvariant();\n        System.out.println(\"OPERATOR\" + id.toString() + \" created with wallet: \" + new Integer(wallet).toString());\n    }\n\n    @Transition(name = CREATE_GAME, source = WORKING, target = WORKING, requires = \"newPot \u003e= 0\")\n    @Transition(name = CREATE_GAME, source = PUT_FUNDS, target = PUT_FUNDS, requires = \"newPot \u003e= 0\")\n    @Transition(name = CREATE_GAME, source = WITHDRAW_FUNDS, target = WITHDRAW_FUNDS, requires = \"newPot \u003e= 0\", guard = SAFE_GAME_STEP)\n    @Transition(name = DECIDE_BET, source = WORKING, target = WORKING, requires = \"newPot \u003e= 0\")\n    @Transition(name = DECIDE_BET, source = PUT_FUNDS, target = PUT_FUNDS, requires = \"newPot \u003e= 0\")\n    @Transition(name = DECIDE_BET, source = WITHDRAW_FUNDS, target = WITHDRAW_FUNDS, requires = \"newPot \u003e= 0\", guard = SAFE_GAME_STEP)\n    public void gameStep(@Data(name = AVAILABLE_FUNDS) int newPot) {\n        this.pot = newPot;\n        //@ ghost System.staticInvariant();\n        System.out.println(\"OPERATOR\" + id.toString() + \": making one step in the game\");\n    }\n\n    @Transition(name = PREPARE_TO_ADD, source = WORKING, target = PUT_FUNDS, guard = ENOUGH_FUNDS)\n    public void prepareAmountToPut() {\n        amountToMove = (int) (Math.random() * wallet); // Note: Math.random is replaced with 0 here (temporary workaround for static method access)\n        wallet -= amountToMove;\n        //@ ghost System.staticInvariant();\n        System.out.println(\"OPERATOR\" + id.toString()\n                + \": decided to put \" + new Integer(amountToMove).toString()\n                + \", wallet: \" + new Integer(wallet).toString());\n    }\n\n    @Transition(name = PREPARE_TO_REMOVE, source = WORKING, target = WITHDRAW_FUNDS)\n    public void prepareAmountToWithdraw() {\n        amountToMove = (int) (Math.random() * pot); // Note: Math.random is replaced with 0 here (temporary workaround for static method access)\n        //@ ghost System.staticInvariant();\n        System.out.println(\"OPERATOR\" + id.toString()\n                + \": decided to withdraw \" + new Integer(amountToMove).toString()\n                + \", wallet: \" + new Integer(wallet).toString());\n    }\n\n    @Transition(name = ADD_TO_POT, source = PUT_FUNDS, target = WORKING, requires = \"newPot \u003e= 0\")\n    public void addToPot (@Data(name = AVAILABLE_FUNDS) int newPot) {\n        this.pot = newPot + amountToMove;\n        //@ ghost System.staticInvariant();\n        System.out.println(\"OPERATOR\" + id.toString()\n                + \": added \" + new Integer(amountToMove).toString()\n                + \" to pot, wallet: \" + new Integer(wallet).toString());\n    }\n\n    @Transition(name = REMOVE_FROM_POT, source = WITHDRAW_FUNDS, target = WORKING, requires = \"amountToMove \u003c= newPot\")\n    public void removeFromPot (@Data(name = AVAILABLE_FUNDS) int newPot) {\n        wallet += amountToMove;\n        this.pot = newPot - amountToMove;\n        //@ ghost System.staticInvariant();\n        System.out.println(\"OPERATOR\" + id.toString() +\n                \": removed \" + new Integer(amountToMove).toString()\n                + \" from pot, wallet: \" + new Integer(wallet).toString());\n    }\n\n    @Pure\n    @Guard(name = SAFE_GAME_STEP)\n    public boolean safeGameStep(@Data(name = AVAILABLE_FUNDS) int newPot) {\n        return amountToMove \u003c= newPot;\n    }\n\n    @Pure\n    @Guard(name = ENOUGH_FUNDS)\n    public boolean haveMoney() {\n        return wallet \u003e 0;\n    }\n\n    @Pure\n    @Data(name = OUTGOING_FUNDS, accessTypePort = /*@ \\replacing(0) */ DataOut.AccessType.allowed /*@ \\replacing_done */, ports = {ADD_TO_POT, REMOVE_FROM_POT})\n    public int funds() {\n        return amountToMove;\n    }\n\n    @Pure\n    @Data(name = ID)\n    public Integer id() {\n        return id;\n    }\n}\n",
        "name": "Operator.java",
        "path": "examples/concepts/javabip/casinoAdjusted/Operator.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/javabip/casinoAdjusted/Operator.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 24,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires id != null;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "//:: cases CatchThrowE\n//:: tools silicon\n//:: verdict Pass\n\nclass CatchThrowE {\n    int x;\n    Exception chosenE;\n\n    boolean randomBoolean();\n    \n    //@ context_everywhere Perm(x, write);\n    //@ context_everywhere Perm(chosenE, write);\n    //@ signals (Exception e) Perm(x, write) ** Perm(chosenE, write) ** x == 5 ** e == chosenE;\n    //@ ensures x == 3;\n    void  m() throws Exception {\n        boolean throwB = randomBoolean();\n\n        try {\n            x = 3;\n            chosenE = new Exception();\n\n            if (throwB) {\n                throw chosenE;\n            }\n        } catch (Exception e) {\n            x += 2;\n            throw e;\n            //@ assert false;\n        }\n\n        //@ assert x == 3;\n    }\n}\n\n\n\n\n\n\n\n\n",
        "name": "CatchThrowE.java",
        "path": "examples/technical/exception-patterns/CatchThrowE.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/technical/exception-patterns/CatchThrowE.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures x == 3;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "//:: cases CatchSwitch\n//:: tools silicon\n//:: verdict Pass\n\nclass CatchSwitch {\n    boolean randomBoolean();\n    \n    //@ ensures start \u003c= \\result \u0026\u0026 \\result \u003c end;\n    int pickBetween(int start, int end);\n\n    void m () {\n        boolean throwB = randomBoolean();\n        int picked = pickBetween(0, 3);\n        int switchResult = 0;\n\n        try {\n            if (throwB) {\n                throw new Exception();\n            }\n        } catch (Exception e) {\n            switch (picked) {\n                case 0:\n                    switchResult = 10;\n                    break;\n                case 1:\n                    switchResult = 11;\n                    break;\n                case 2:\n                    switchResult = 12;\n                    break;\n                default:\n                    //@ assert false;\n                    break;\n            }\n        }\n\n        if (throwB) {\n            //@ assert picked == 0 ==\u003e switchResult == 10;\n            //@ assert picked == 1 ==\u003e switchResult == 11;\n            //@ assert picked == 2 ==\u003e switchResult == 12;\n        } else {\n            //@ assert switchResult == 0;\n        }\n    }\n}\n\n\n\n\n",
        "name": "CatchSwitch.java",
        "path": "examples/technical/exception-patterns/CatchSwitch.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/technical/exception-patterns/CatchSwitch.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures start \u003c= \\result \u0026\u0026 \\result \u003c end;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "//:: cases ControlFlowCatchReturn\n//:: tools silicon\n//:: verdict Pass\n\nclass ControlFlowCatchReturn {\n    //@ context_everywhere xs != null ** Perm(xs[*], write);\n    //@ ensures \\result != null ==\u003e \\result == xs;\n    //@ ensures \\result != null ==\u003e (\\forall int j = 0 .. \\result.length; xs[j] == 1);\n    //@ ensures \\result == null ==\u003e (\\exists int j = 0 .. xs.length; xs[j] == 0);\n    int[]  m(int[] xs) {\n        int i = 0;\n\n        //@ loop_invariant 0 \u003c= i \u0026\u0026 i \u003c= xs.length;\n        //@ loop_invariant (\\forall int j = 0 .. i; xs[j] == 1);\n        //@ loop_invariant (\\forall int j = i .. xs.length; xs[j] == \\old(xs[j]));\n        while (i \u003c xs.length) {\n            try {\n                if (xs[i] != 0) {\n                    xs[i] = xs[i] / xs[i];\n                } else {\n                    throw new ArithmeticException();\n                }\n            } catch (ArithmeticException e) {\n                return null;\n            }\n            i++;\n        }\n\n        return xs;\n    }\n}\n\n\n\n\n\n",
        "name": "CatchReturn.java",
        "path": "examples/technical/exception-patterns/CatchReturn.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/technical/exception-patterns/CatchReturn.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result != null ==\u003e \\result == xs;"
        },
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result != null ==\u003e (\\forall int j = 0 .. \\result.length; xs[j] == 1);"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result == null ==\u003e (\\exists int j = 0 .. xs.length; xs[j] == 0);"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "//:: cases ExceptionAbortsAssignment\n//:: tools silicon\n//:: verdict Pass\n\nclass C {\n    //@ ensures false;\n    //@ signals (RuntimeException e) true;\n    int e();\n\n    void m1() {\n        int x = 0;\n        try {\n            x = e();\n            //@ assert false; // Cannot be triggered, as exception is guaranteed\n        } catch (RuntimeException e) {\n\n        }\n        //@ assert x == 0;\n    }\n}\n",
        "name": "ExceptionAbortsAssignment.java",
        "path": "examples/concepts/abrupt/ExceptionAbortsAssignment.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/abrupt/ExceptionAbortsAssignment.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures false;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:2 ; indent-tabs-mode:nil -*-\n//:: case NoSendAfterRead\n//:: suite puptol\n//:: tool silicon\n//:: option --check-history\n/*@\nmodel Future {\n  boolean flag;\n  \n  accessible flag; //skip(all)\n  requires flag;\n  action p_send();\n  \n  accessible flag; //skip(all)\n  requires !flag;  //skip(all)\n  action receive();\n\n  modifies flag;  //skip(all)\n  ensures !flag;\n  action clear();\n  \n  requires true; //skip(all)\n  ensures true;  //skip(all)\n  process nsar()=p_send()*nsar() + clear()*rs();\n  \n  process rs()=clear()*rs() + receive()*rs();\n}\n@*/\n\nclass Device {\n  Future F;\n\n/*@\n  ensures Value(F) ** HPerm(F.flag,1) ** F.flag;\n  ensures F.state(1,F.nsar());\n@*/\n  public Device() {\n    /*@ghost {\n      F = new Future();\n      F.flag = true;\n      F.create(F.nsar());\n    }@*/\n  }\n\n/*@\n  given frac p; //skip(all)\n  given process P; //skip(all)\n  requires p!=none ** Value(F); //skip(all)\n  requires HPerm(F.flag,p) ** F.flag ** F.state(p,F.p_send()*P);\n  ensures  p!=none ** Value(F); //skip(all)\n  ensures HPerm(F.flag,p) ** F.flag ** F.state(p,P);\n@*/\n  void send();\n\n/*@ \n  given frac p; //skip(all)\n  given process P; //skip(all)\n  requires p!=none ** Value(F) ** HPerm(F.flag,p)//skip(all)\n    ** !F.flag; //skip(all)\n  requires F.state(p,F.receive()*P);\n  ensures  p!=none ** Value(F) ** HPerm(F.flag,p) ** !F.flag; //skip(all)\n  ensures F.state(p,P);\n@*/\n  void receive();\n}\n\nclass Lock {\n  //@ ghost Device d;\n  \n  boolean flag;\n  \n  /*@ inline resource inv()=\n        Value(d)**Perm(flag,write)**Value(d.F)**\n        HPerm(d.F.flag,write)**d.F.flag==flag; @*/\n  \n  //@ ensures inv();\n  void lock();\n  \n  //@ requires inv();\n  void unlock();\n\n}\n\nclass Sender {\n  Device d;\n\n  Lock l;\n\n/*@  \n     requires Value(d) ** Value(d.F); //skip(run)\n     requires d.F.state(1\\2,d.F.nsar());\n  requires Value(l) ** Value(l.d) ** l.d==d; //skip(run)\n@*/ public void run(){\n/*@ loop_invariant Value(d) ** Value(d.F) ** Value(l)//skip(run)\n    ** Value(l.d) ** l.d==d; //skip(run)\n    loop_invariant d.F.state(1\\2,d.F.nsar());\n@*/ while(true){\n      l.lock();\n      if (l.flag){\n        //@ ghost d.F.choose(1\\2,d.F.nsar(),d.F.p_send()*d.F.nsar()); //skip(run)\n        d.send()/*@ given { p = 1\\2, P = d.F.nsar() } @*/;\n      }\n      l.unlock();\n    }\n  }\n}\n\nclass Reader {\n  Device d;\n\n  Lock l;\n/*@ requires Value(d) ** Value(l) ** Value(l.d) ** //skip(run)\n     l.d==d ** Value(d.F); //skip(run)\n    requires d.F.state(1\\2,d.F.rs());\n@*/ public void run(){\n/*@ loop_invariant Value(d) ** Value(d.F) ** Value(l) ** //skip(run)\n      Value(l.d) ** l.d==d; // skip(run)  \n    loop_invariant d.F.state(1\\2,d.F.rs()); @*/\n    while(true){\n      l.lock();\n      //@ ghost d.F.choose(1\\2,d.F.rs(),d.F.clear()*d.F.rs()); //skip(run)\n      { //@ action(d.F,1\\2,d.F.rs(),d.F.clear());\n        l.flag=false;\n        //@ ghost d.F.flag=false;\n      }\n      //@ ghost d.F.choose(1\\2,d.F.rs(),d.F.receive()*d.F.rs()); //skip(run)\n      d.receive()/*@ given { p = 1\\2, P = d.F.rs() } @*/;\n      l.unlock();\n    }\n  }\n}\n\n",
        "name": "NoSendAfterRead.java",
        "path": "examples/archive/known-problems/822/NoSendAfterRead.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/archive/known-problems/822/NoSendAfterRead.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 75,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures inv();"
        },
        {
          "limitHit": false,
          "lineNumber": 78,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires inv();"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "//:: cases FinallyReturn\n//:: tools silicon\n//:: verdict Pass\n\nclass FinallyReturn {\n    //@ ensures \\result == 3;\n    int  m() {\n        int x = 0;\n\n        try {\n            x += 1;   \n        } finally {\n            x += 2;\n            return x;\n        }\n\n        //@ assert false;\n    }\n}\n\n\n\n\n\n\n\n",
        "name": "FinallyReturn.java",
        "path": "examples/technical/exception-patterns/FinallyReturn.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/technical/exception-patterns/FinallyReturn.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result == 3;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "//:: cases CatchContinue\n//:: tools silicon\n//:: verdict Pass\n\nclass CatchContinue {\n    //@ requires n \u003e= 0;\n    void m (int n) {\n        int i = 0;\n        int[] xs = new int[n];\n\n        //@ loop_invariant 0 \u003c= i \u0026\u0026 i \u003c= n;\n        //@ loop_invariant xs != null \u0026\u0026 xs.length == n;\n        //@ loop_invariant (\\forall* int j = 0 .. n; Perm(xs[j], write));\n        //@ loop_invariant (\\forall int j = 0 .. i; j % 2 == 0 ==\u003e xs[j] == 0);\n        while (i \u003c n) {\n            try {\n                int currentI = i;\n                i++;\n                if (currentI % 2 != 0) {\n                    throw new Exception();\n                } \n                xs[currentI] = 0;\n            } catch (Exception e) {\n                continue;\n            }\n        }\n\n        //@ assert (\\forall int j = 0 .. n; j % 2 == 0 ==\u003e xs[j] == 0);\n    }\n}\n\n",
        "name": "CatchContinue.java",
        "path": "examples/technical/exception-patterns/CatchContinue.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/technical/exception-patterns/CatchContinue.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires n \u003e= 0;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:2 ; indent-tabs-mode:nil -*-\n//:: cases ReentLock\n//:: tools chalice\n//:: verdict Pass\n//:: options --explicit\n /*\n Example: ReentLock\n Description: ReentLock is the re-entrant lock using AtomicInteger as synchronizer.\n Author: Afshin Amighi\n Status: Pass.\n command: vct --chalice --explicit ReentrantLock.java\n */\n\npublic class ReentLock{\n\n    //shared resource\n    private int data;\n\n    //  int SynchronizerRole (S) = 0, ThreadRole = 1;\n    //    int UNLOCKED = 0 , LOCKED = threadid;\n\n    //@ resource handle(int role,int val);\n    //@ resource trans(int role,int last,int next)=( role == 1  ==\u003e true );\n    //@ pure zfrac part(int r, int v,int M){ return (r == 0 \u0026\u0026 v == 0) ? 100:0; }\n    // for simplicity we take resource_invariant=Perm(data,p)\n    //@ resource inv(zfrac p)= Perm(data,p) ** Perm(count,p);\n\n    private int        count;\n\n    //@ resource state(int id , int held) = (held \u003e 0 )==\u003e Perm(count,100);\n\n    /*@\n     given int r, l, max;\n     requires (srh:handle(r,l)) ** (sra:trans(r,l,x)) ** (srp:inv(part(r,l,max))) ** (srs:inv(part(0,x,max)));\n     ensures (seh:handle(r,x)) ** (sep:inv(part(r,x,max)));\n     */\n    void set(int x);\n\n    /*@\n     given int r,l,max;\n     requires (grh:handle(r,l)) ** grp:inv(part(r,l,max));\n     ensures (geh:handle(r,\\result)) ** gep:inv(part(r,\\result,max));\n     */\n    int get();\n\n    /*@\n     given int r, l, max;\n     requires (crh:handle(r,l)) ** (cra:trans(r,x,n)) ** (crp:inv(part(r,l,max))) ** (crs:inv(part(0,n,max)-part(0,x,max)));\n     ensures \\result ==\u003e (cehp:handle(r,n)) ** (cepp:inv(part(r,n,max))) ** cesp:inv(part(0,x,max)-part(0,n,max));\n     ensures !\\result ==\u003e (cehn:handle(r,l)) ** (cepn:inv(part(r,l,max))) ** cesn:inv(part(0,n,max)-part(0,x,max));\n     */\n    boolean compareAndSet(int x,int n);\n\n    /*\n     requires Perm(owner,100) * Perm(holds,100) * P ; where P is what is needed for lock constructor\n     ensures Perm(owner,100) * Perm(holds,100) * P * (\\forall* handles(T,UNLOCKED));\n     */\n    /*ReentLock(){\n\n        state = new AtomicInteger(UNLOCKED);\n        // handles for all the threads\n        owner = null;\n        holds = 0;\n\n    }*/\n\n    //@ given int last;\n    //@ given int held;\n    //@ requires tid \u003e 0;\n    //@ requires lrs: state(tid,held);\n    //@ requires lrh: handle(1,last);\n    //@ ensures les: state(tid,held+1);\n    //@ ensures (held == 0) ==\u003e Perm(data,100) ;\n    //@ ensures leh: handle(1,tid);\n    public void dolock(int tid){\n        boolean res = false;\n\n        //@ int role = 1, S=0, M=1;\n\n        /*@ witness tgrp:inv(*);\n            fold tgrp:inv(part(role,last,M));\n\n            witness tgep:inv(*);\n            witness tgeh:handle(*,*);\n         */\n\n        int curr = get() /*@ with { max = M; r=role; l = last; grh = lrh;  grp = tgrp; } then { tgeh = geh; tgep = gep; } */;\n        // check re-entrant\n        if ( tid == curr ) {\n            //@ assume (held \u003e 0);\n            //@ unfold lrs:state(tid,held);\n            //@ assume (held == count);\n\n            count = count+1;\n\n            //@ leh=tgeh;\n        }\n        // check first-entrant\n        if( tid != curr){\n            //@ assume (held == 0);\n\n            boolean succ = false;\n            //@ witness tcra:trans(*,*,*);\n            //@ witness tcrs:inv(*);\n            //@ witness tces:inv(*);\n            //@ witness tcepp:inv(*);\n            //@ fold tcrs:inv(part(S,tid,M)-part(S,0,M));\n            //@ loop_invariant  !succ    ==\u003e (invhn:handle(role,curr)) ** (invpn: inv(part(role,curr,M))) ** invsn: inv(part(S,tid,M)-part(S,0,M));\n            //@ loop_invariant  succ    ==\u003e    (invhp:handle(role,tid)) ** (invpp: inv(part(role,tid,M))) ** invsp: inv(part(S,0,M)-part(S,tid,M));\n            while (!succ) /*@ with{ invhn = tgeh; invpn = tgep; invpp = tgep;  invsn = tcrs; }\n                           then { tces = invsp; tcepp = invpp; leh = invhp;   } @*/ {\n\n               //@     fold tcra:trans(role,0,tid);\n                succ = compareAndSet(0,tid) /*@ with{ max = 1; r = role; l = curr; crh = invhn; crp = invpn; cra = tcra; crs = invsn; }\n                                        then{ invhn = cehn; invpn = cepn; invsn = cesn; invhp = cehp; invpp = cepp; invsp = cesp;  } @*/ ;\n            }\n            //@ unfold tces: inv(part(S,0,1)-part(S,tid,1));\n            //@ assume (held == count);\n            count = count+1;\n        }\n        //@ fold les:state(tid,held+1);\n        return;\n    }\n\n    // unlock is only called with a valid tid (tid \u003e 0) and valid held (held \u003e 0)\n    //@ given int held;\n    //@ requires tid \u003e 0;\n    //@ requires held \u003e 0;\n    //@ requires urs: state(tid,held);\n    //@ requires urh:handle(1,tid);\n    //@ requires held \u003e 0 ==\u003e Perm(data,100);\n    //@ ensures held == 1 ==\u003e ueuh: handle(1,0);\n    //@ ensures held \u003e 1 ==\u003e (uelh: handle(1,tid)) ** Perm(data,100);\n    //@ ensures ues:state(tid,held-1);\n    public void unlock(int tid){\n        //@ int role = 1, S=0, M=1;\n        //@ int last = tid;\n\n        //@ witness tgrp:inv(*);\n        //@ fold tgrp:inv(part(role,last,M));\n        //@ witness tgep:inv(*);\n        //@ witness tgeh:handle(*,*);\n        int curr = get() /*@ with { max = M; r=role; l=last; grh=urh;  grp=tgrp; } then { tgeh=geh; tgep=gep; } @*/;\n\n        // this should be a global invariant\n        //@ assume( curr==tid );\n\n        if ( curr == tid) {\n\n            //@ unfold urs:state(tid,held);\n            //@ assume (count == held);\n            if (count == 1) {\n                count = count-1;\n                //@ fold ues:state(tid,count);\n                //@ witness tsrp:inv(*);\n                //@ witness tsrs:inv(*);\n                //@ fold tsrp:inv(part(role,curr,M));\n                //@ fold tsrs:inv(part(S,0,M));\n                //@ witness tsra:trans(*,*,*);\n                //@ fold tsra:trans(role,curr,0);\n                set(0) /*@ with{ max = M; r = role; l = curr; srh = tgeh; srp = tsrp; sra = tsra; srs = tsrs; } then { ueuh = seh; } @*/;\n            }\n            else{\n                if (count \u003e 1) {\n                    count = count-1;\n                    //@ fold ues:state(tid,held-1);\n                    //@ uelh = tgeh;\n                }\n            }\n        }\n    }\n}\n",
        "name": "ReentrantLock.java",
        "path": "examples/archive/chalice/synchronizers/ReentrantLock.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/archive/chalice/synchronizers/ReentrantLock.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 68,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires tid \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 69,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires lrs: state(tid,held);"
        },
        {
          "limitHit": false,
          "lineNumber": 70,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires lrh: handle(1,last);"
        },
        {
          "limitHit": false,
          "lineNumber": 71,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures les: state(tid,held+1);"
        },
        {
          "limitHit": false,
          "lineNumber": 72,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures (held == 0) ==\u003e Perm(data,100) ;"
        },
        {
          "limitHit": false,
          "lineNumber": 73,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures leh: handle(1,tid);"
        },
        {
          "limitHit": false,
          "lineNumber": 126,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires tid \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 127,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires held \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 128,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires urs: state(tid,held);"
        },
        {
          "limitHit": false,
          "lineNumber": 129,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires urh:handle(1,tid);"
        },
        {
          "limitHit": false,
          "lineNumber": 130,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires held \u003e 0 ==\u003e Perm(data,100);"
        },
        {
          "limitHit": false,
          "lineNumber": 131,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures held == 1 ==\u003e ueuh: handle(1,0);"
        },
        {
          "limitHit": false,
          "lineNumber": 132,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures held \u003e 1 ==\u003e (uelh: handle(1,tid)) ** Perm(data,100);"
        },
        {
          "limitHit": false,
          "lineNumber": 133,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures ues:state(tid,held-1);"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "//:: cases CatchThrowNewE\n//:: tools silicon\n//:: verdict Pass\n\nclass CatchThrowNewE {\n    int x;\n\n    boolean randomBoolean();\n    \n    //@ context_everywhere Perm(x, write);\n    //@ signals (RuntimeException e) Perm(x, write) ** x == 5;\n    //@ ensures x == 3;\n    int  m() {\n        try {\n            x = 3;\n\n            if (randomBoolean()) {\n                throw new Exception();\n            }\n        } catch (Exception e) {\n            x += 2;\n            throw new RuntimeException();\n            //@ assert false;\n        }\n\n        //@ assert x == 3;\n    }\n}\n\n\n\n\n\n\n\n\n\n",
        "name": "CatchThrowNewE.java",
        "path": "examples/technical/exception-patterns/CatchThrowNewE.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/technical/exception-patterns/CatchThrowNewE.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures x == 3;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:2 ; indent-tabs-mode:nil -*-\n//:: cases CountDownLatch\n//:: tools chalice\n//:: verdict Pass\n//:: options --explicit\n\n/*\n Example: CountDownLatch \n Description: CountDownLatch using AtomicInteger as synchronizer. \n  The specification is a special case of the contracts provided in the FMCAD'13 paper: p==1/count.\n Author: Afshin Amighi\n Status: Pass.\n command: vct --chalice --explicit CountDownLatch.java\n */\n\npublic class CountDownLatch{\n\n/* -------------- AtomicInteger ---------------*/\n\n    /*@\n     given int r,l,max;\n     requires max \u003e0 \u0026\u0026 100%max==0;\n     requires grp:inv(part(r,l,max));\n     ensures gep:inv(part(r,\\result,max));\n     */\n    int get();\n\n    /*@\n     given int r, l, max;\n     requires max \u003e0 \u0026\u0026 x \u003c=max \u0026\u0026 n\u003c=max \u0026\u0026 100%max==0;\n     requires (crp:inv(part(r,l,max))) ** crs:inv(part(0,n,max)-part(0,x,max));\n     ensures \\result ==\u003e (cepp:inv(part(r,n,max))) ** cesp:inv(part(0,x,max)-part(0,n,max));\n     ensures !\\result ==\u003e (cepn:inv(part(r,l,max))) ** cesn:inv(part(0,n,max)-part(0,x,max));\n     */\n    boolean compareAndSet(int x,int n);\n/* -------------- CoundDownLatch --------------*/\n\n    //@ resource inv(zfrac p)=Perm(data,p);\n    /*@ pure zfrac part(int r,int v, int M){ \n            return    (r==2 \u0026\u0026 v==0 \u0026\u0026 M\u003e0 \u0026\u0026 M\u003c=100) ? (100/M):\n                    ((r==0 \u0026\u0026 v\u003e=0 \u0026\u0026 M\u003e0 \u0026\u0026 v\u003c=M \u0026\u0026 M\u003c=100) ? (((M-v)*100)/M) : 0 ); }\n    @*/\n    //shared resource\n    int data;\n    // count is actually ghost final!\n    //@ int count;\n\n    // role AT = 1;\n    //@ requires Value(count) ** count\u003e0 ** count\u003c=100 ** 100%count==0 ** crri:inv(100/count);\n    //@ ensures \\result ==\u003e Value(count) ** count\u003e0 ** count\u003c=100 ** 100%count==0;\n    //@ ensures !\\result ==\u003e Value(count) ** count\u003e0 ** count\u003c=100 ** 100%count==0 ** ceri:inv(100/count);\n    public boolean tryCountDown(){\n    // Decrement count; signal when transition to zero\n        boolean r = false;\n        //int res = -1;\n        //@ int AT=1;\n\n        //@ witness tgrp:inv(*);\n        //@ witness tgep:inv(*);\n        //@ witness tce:inv(*);\n        //@ fold tgrp: inv(part(AT,count,count));\n\n        int c = get() /*@ with{ max=count; r = AT; l = count; grp = tgrp; } then { tgep = gep; } @*/ ;\n\n        if (c \u003e 0){\n            //@ assume c\u003c=count;\n            int nextc = c-1;\n            //@ witness tcesp:inv(*);\n            //@ witness tcesn:inv(*);\n            //@ witness tcepp:inv(*);\n            //@ witness tcepn:inv(*);\n            //@ assert ((count-nextc)*100)/count-((count-c)*100)/count == 100/count;\n            //@ assert part(AT,c,count)==0;\n\n            r = compareAndSet(c, nextc)/*@ with{ max=count; r=AT; l=c; crp = tgep; crs = crri; } then { tcesp = cesp; tcesn = cesn; tcepp = cepp; tcepn=cepn;} @*/;\n\n        /*@    if(r){\n                unfold tcesp: inv(part(0,c,count)-part(0,nextc,count));\n                unfold tcepp: inv(part(AT,nextc,count));\n            }else{\n                ceri = tcesn;\n                unfold tcepn: inv(part(AT,c,count));\n            }\n         @*/\n        }\n        /*@\n         if(c\u003c=0)\n            ceri = crri;\n         @*/\n        return r;\n    }\n\n    // role AT = 1;\n    //@ requires Value(count) ** count\u003e0 ** count\u003c=100 ** count%100==0 ** crri:inv(100/count);\n    //@ ensures Value(count) ** count\u003e0 ** count\u003c=100 ** count%100==0;\n    public void countDown(){\n\n        boolean stop = false;\n        //@ loop_invariant (!stop) ==\u003e Value(count)**count\u003e0**count\u003c=100 ** count%100==0 **linv:inv(100/count);\n        //@ loop_invariant (stop) ==\u003e Value(count)**count\u003e0**count\u003c=100 ** count%100==0;\n        while(!stop) /*@ with { linv = crri; } @*/{\n            stop = tryCountDown() /*@ with { crri = linv; } then { linv = ceri; } @*/;\n        }\n\n    }\n\n    // role PT = 2;\n    //@ requires Value(count) ** count\u003e0 ** count\u003c=100 ** count%100==0;\n    //@ ensures  Value(count) ** count\u003e0 ** count\u003c=100 ** count%100==0 ** aeri:inv(100/count);\n    public void await(){\n        //@ int last = count;\n        //@ int max = count;\n        //@ int PT = 2;\n        //@ witness tgrp:inv(*);\n        //@ witness tgep:inv(*);\n        //@ fold tgrp:inv(part(PT,last,max));\n        int s = get() /*@ with{ max = max; r = PT; l=last; grp = tgrp; } then { tgep=gep; } @*/;\n\n        //@ loop_invariant linv:inv(part(PT,s,max));\n        while(s!=0) /*@ with { linv = tgep; } then { aeri = linv; } @*/ {\n          s = get() /*@ with { max = max; r=PT; l=s; grp=linv; } then { linv=gep; } @*/;\n        }\n    }  \n}\n",
        "name": "CountDownLatch.java",
        "path": "examples/archive/chalice/synchronizers/CountDownLatch.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/archive/chalice/synchronizers/CountDownLatch.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 48,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires Value(count) ** count\u003e0 ** count\u003c=100 ** 100%count==0 ** crri:inv(100/count);"
        },
        {
          "limitHit": false,
          "lineNumber": 49,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result ==\u003e Value(count) ** count\u003e0 ** count\u003c=100 ** 100%count==0;"
        },
        {
          "limitHit": false,
          "lineNumber": 50,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures !\\result ==\u003e Value(count) ** count\u003e0 ** count\u003c=100 ** 100%count==0 ** ceri:inv(100/count);"
        },
        {
          "limitHit": false,
          "lineNumber": 93,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires Value(count) ** count\u003e0 ** count\u003c=100 ** count%100==0 ** crri:inv(100/count);"
        },
        {
          "limitHit": false,
          "lineNumber": 94,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures Value(count) ** count\u003e0 ** count\u003c=100 ** count%100==0;"
        },
        {
          "limitHit": false,
          "lineNumber": 107,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires Value(count) ** count\u003e0 ** count\u003c=100 ** count%100==0;"
        },
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  Value(count) ** count\u003e0 ** count\u003c=100 ** count%100==0 ** aeri:inv(100/count);"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "//:: cases FinallyContinue\n//:: tools silicon\n//:: verdict Pass\n\nclass FinallyContinue {\n    //@ requires n \u003e= 0;\n    void  m(int n) {\n        int i = 0;\n        boolean[] xs = new boolean[n];\n\n        //@ loop_invariant 0 \u003c= i \u0026\u0026 i \u003c= n;\n        //@ loop_invariant xs != null ** xs.length == n;\n        //@ loop_invariant (\\forall* int j = 0 .. n; Perm(xs[j], write));\n        //@ loop_invariant (\\forall int j = 0 .. i; xs[j]);\n        while (i \u003c n) {\n            try {\n                try {\n                    xs[i] = true;\n                    throw new Exception();\n                    //@ assert false;\n                } finally {\n                    i++;\n                    continue;\n                    //@ assert false;\n                }\n            } catch (Exception e) {\n                //@ assert false;\n            }\n        }\n\n        //@ assert (\\forall int j = 0 .. n; xs[j]);\n    }\n}\n\n\n\n\n\n\n",
        "name": "FinallyContinue.java",
        "path": "examples/technical/exception-patterns/FinallyContinue.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/technical/exception-patterns/FinallyContinue.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires n \u003e= 0;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "//:: cases FinallyThrowNewE\n//:: tools silicon\n//:: verdict Pass\n\nclass FinallyThrowNewE {\n    int x;\n\n    boolean randomBoolean();\n    \n    //@ context_everywhere Perm(x, write);\n    //@ signals (Exception e) Perm(x, write) ** x == 5;\n    //@ ensures false;\n    int  m() throws Exception {\n        boolean throwB = randomBoolean();\n\n        try {\n            x = 3;\n\n            if (throwB) {\n                throw new Exception();\n            }\n        } finally {\n            x += 2;\n            throw new Exception();\n            //@ assert false;\n        }\n\n        //@ assert false;\n    }\n}\n\n\n\n\n\n\n\n\n",
        "name": "FinallyThrowNewE.java",
        "path": "examples/technical/exception-patterns/FinallyThrowNewE.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/technical/exception-patterns/FinallyThrowNewE.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures false;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "//:: cases FinallyNestedTry\n//:: tools silicon\n//:: verdict Pass\n\n\nimport java.io.IOException;\n\nclass FinallyNestedTry {\n    int x;\n\n    boolean randomBoolean();\n    \n    //@ signals (ArithmeticException e) Perm(x, write) ** (x == 31 || x == 32);\n    //@ signals (ArrayStoreException e) Perm(x, write) ** (x == 111 || x == 112);\n    //@ context_everywhere Perm(x, write);\n    //@ ensures x == 32;\n    int  m() {\n        x = 0;\n\n        boolean throwB1 = randomBoolean();\n        boolean throwB2 = randomBoolean();\n\n        try {\n            if (throwB1) {\n                x += 1;\n                throw new ArithmeticException();\n            }\n\n            x += 2;\n        } finally {\n            try {\n                x += 10;\n\n                if (throwB2) {\n                    throw new Exception();\n                }\n                \n                x += 20;\n            } catch (Exception e) {\n                x += 100;\n                throw new ArrayStoreException();\n            }\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\n",
        "name": "FinallyNestedTry.java",
        "path": "examples/technical/exception-patterns/FinallyNestedTry.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/technical/exception-patterns/FinallyNestedTry.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures x == 32;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "//:: cases CatchThrowNewEWrap\n//:: tools silicon\n//:: verdict Pass\n\nclass CatchThrowNewEWrap {\n    int x;\n\n    boolean randomBoolean();\n    \n    //@ context_everywhere Perm(x, write);\n    //@ signals (Exception e) Perm(x, write) ** x == 5;\n    //@ ensures x == 3;\n    int  m() throws Exception {\n        boolean throwB = randomBoolean();\n\n        try {\n            x = 3;\n\n            if (throwB) {\n                throw new Exception();\n            }\n        } catch (Exception e) {\n            x += 2;\n            throw new RuntimeException(e);\n            //@ assert false;\n        }\n\n        //@ assert x == 3;\n    }\n}\n\n\n\n\n\n\n\n\n",
        "name": "CatchThrowNewEWrap.java",
        "path": "examples/technical/exception-patterns/CatchThrowNewEWrap.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/technical/exception-patterns/CatchThrowNewEWrap.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures x == 3;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "package staticResolve.subPackage;\nimport static staticResolve.Test.*;\n\npublic class StaticImport {\n\n    //@ requires Perm(x, write);\n    public void test() {\n        int val = x;\n        int val2 = five();\n    }\n\n}",
        "name": "StaticImport.java",
        "path": "examples/technical/staticResolve/subPackage/StaticImport.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/technical/staticResolve/subPackage/StaticImport.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires Perm(x, write);"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "//:: cases ContractSatisfiableIntentionalJava\n//:: tools silicon\n//:: verdict Pass\n\nclass MyClass {\n  // User indicates false assumption is required\n  //@ requires false;\n  void foo() {\n    // Should therefore not be triggered.\n    //@ assert 5 == 6;\n  }\n}\n",
        "name": "ContractUnsatisfiableIntentional.java",
        "path": "examples/concepts/basic/ContractUnsatisfiableIntentional.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/basic/ContractUnsatisfiableIntentional.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires false;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "//:: cases ContractSatisfiableUnintentionalJava\n//:: tools silicon\n//:: verdict Fail\n\nclass MyClass {\n  // User makes a mistake here, this should be detected.\n  /*[/expect unsatisfiable]*/\n  //@ requires 3 == 4;\n  void bar() {\n    //@ assert 5 == 6;\n  }\n  /*[/end]*/\n}\n",
        "name": "ContractUnsatisfiableUnintentional.java",
        "path": "examples/concepts/basic/ContractUnsatisfiableUnintentional.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/basic/ContractUnsatisfiableUnintentional.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 3 == 4;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:4 ; indent-tabs-mode:nil -*-\n//:: cases KeYAbruptTerminationChallengeCarbon\n//:: tools carbon\n//:: verdict Pass\n\n// This is an adaptation of a file from the examples directory of key.\n// Original file path: KEY_ROOT/key/key.ui/examples/standard_key/challenges/jacobsEtAl/abruptTermination/AbruptTermination.java\n// It has been adapted to use the vercors syntax for specifications.\n\nclass AbruptTermination {\n    int[] ia;\n\n    //@ context_everywhere Perm(ia, read) ** ia != null;\n    //@ context_everywhere (\\forall* int i; 0 \u003c= i \u0026\u0026 i \u003c ia.length; Perm(ia[i], write));\n    //@ ensures ia.length == \\old(ia.length); // Extra contract needed for VerCors\n    // ensure i is the first position with negative value\n    /*@ ensures (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c ia.length;\n                    (\\old(ia[i]) \u003c 0 \u0026\u0026 (\\forall int j; 0 \u003c= j \u0026\u0026 j \u003c i; \\old(ia[j]) \u003e= 0))\n                        ? (ia[i] == -\\old(ia[i]))\n                        : (ia[i] == \\old(ia[i]))\n                );\n    @*/\n    void negatefirst() {\n        /*@\n            loop_invariant 0 \u003c= i \u0026\u0026 i \u003c= ia.length;\n            loop_invariant (\\forall int j; 0\u003c=j \u0026\u0026 j\u003ci; ia[j] \u003e= 0 \u0026\u0026 ia[j] == \\old(ia[j]));\n            loop_invariant (\\forall int j; i\u003c=j \u0026\u0026 j\u003cia.length; ia[j] == \\old(ia[j])); // Extra invariant needed\n         */\n        for (int i = 0 ; i \u003c ia.length; i++) {\n            //@ assert ia == \\old(ia);\n            if (ia[i] \u003c 0) {\n                ia[i] = -ia[i] ;\n                break ;\n            }\n        }\n        //@ assert ia == \\old(ia);\n    }\n}\n",
        "name": "KeYAbruptTerminationChallengeCarbon.java",
        "path": "examples/concepts/abrupt/KeYAbruptTerminationChallengeCarbon.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/abrupt/KeYAbruptTerminationChallengeCarbon.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures ia.length == \\old(ia.length); // Extra contract needed for VerCors"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "// -*- tab-width:4 ; indent-tabs-mode:nil -*-\n//:: cases KeYAbruptTerminationChallengeSilicon\n//:: tools silicon\n//:: verdict Fail\n\n// This is an adaptation of a file from the examples directory of key.\n// Original file path: KEY_ROOT/key/key.ui/examples/standard_key/challenges/jacobsEtAl/abruptTermination/AbruptTermination.java\n// It has been adapted to use the vercors syntax for specifications.\n\nclass AbruptTermination {\n    int[] ia;\n\n    //@ context_everywhere Perm(ia, read) ** ia != null;\n    //@ context_everywhere (\\forall* int i; 0 \u003c= i \u0026\u0026 i \u003c ia.length; Perm(ia[i], write));\n    //@ ensures ia.length == \\old(ia.length); // Extra contract needed for VerCors\n    // ensure i is the first position with negative value\n    /*@ ensures (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c ia.length;\n                    (\\old(ia[i]) \u003c 0 \u0026\u0026 (\\forall int j; 0 \u003c= j \u0026\u0026 j \u003c i; \\old(ia[j]) \u003e= 0))\n                        ? (ia[i] == -\\old(ia[i]))\n                        : (ia[i] == \\old(ia[i]))\n                );\n    @*/\n    void negatefirst() {\n        /*@\n            loop_invariant 0 \u003c= i \u0026\u0026 i \u003c= ia.length;\n            // See: https://github.com/utwente-fmt/vercors/issues/511\n            // loop_invariant ia == \\old(ia); // Extra invariant needed for Pass with silicon.\n            loop_invariant (\\forall int j; 0\u003c=j \u0026\u0026 j\u003ci; ia[j] \u003e= 0 \u0026\u0026 ia[j] == \\old([/expect arrayBounds] ia[j] [/end]));\n            loop_invariant (\\forall int j; i\u003c=j \u0026\u0026 j\u003cia.length; ia[j] == \\old(ia[j])); // Extra invariant needed\n         */\n        for (int i = 0 ; i \u003c ia.length; i++) {\n            //@ assert ia == \\old(ia);\n            if (ia[i] \u003c 0) {\n                ia[i] = -ia[i] ;\n                break ;\n            }\n        }\n        //@ assert ia == \\old(ia);\n    }\n}\n",
        "name": "KeYAbruptTerminationChallengeSilicon.java",
        "path": "examples/concepts/abrupt/KeYAbruptTerminationChallengeSilicon.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/concepts/abrupt/KeYAbruptTerminationChallengeSilicon.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures ia.length == \\old(ia.length); // Extra contract needed for VerCors"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "package staticResolve.subPackage;\nimport staticResolve.*;\n\npublic class DidNotForgetImport {\n\n    //@ requires Perm(Test.x, write);\n    public void test() {\n        int val = Test.x;\n        int val2 = Test.five();\n    }\n\n}",
        "name": "DidNotForgetImport.java",
        "path": "examples/technical/staticResolve/subPackage/DidNotForgetImport.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/technical/staticResolve/subPackage/DidNotForgetImport.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires Perm(Test.x, write);"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "//:: case QuickSelect\n//:: tools silicon\n//:: verdict Pass\n//:: suite slow problem-fail\npackage quickselect;\n\nimport static quickselect.RandomBetween.random_between;\nimport static quickselect.ArrayPrinter.printArray;\n\n/**\n* Quickselect is an algorithm to find the `k-th` smallest element, and it has an expected runtime of `O(n)`. It uses constant memory and in-place updates in the function 'partition', partially sorting the array during execution.\n* Sequential version.\n* @Author Henk Mulder.\n*/\npublic class QuickSelect {\n\n    //@ requires low\u003c=high;\n    //@ ensures low\u003c=\\result \u0026\u0026 \\result\u003c=high;\n    static int random_between(int low, int high);\n    \n    //@ context a != null;\n    //@ context Perm(a[*], 1\\2);\n    static void printArray(int[] a, int l, int h);\n\n    //@ requires 0 \u003c= l ** l \u003c a.length;\n    //@ context a != null;\n    //@ context Perm(a[l], write) ** Perm(a[h], write);\n    //@ ensures a[l] == \\old(a[h]);\n    //@ ensures a[h] == \\old(a[l]);\n    public static void swap(int[] a, int l, int h) {\n        int t = a[l];\n        a[l] = a[h];\n        a[h] = t;\n    }\n\n    //@ context_everywhere a != null;\n    //@ context_everywhere 0\u003c=low \u0026\u0026 low\u003c=high \u0026\u0026 high\u003ca.length;\n    //@ context_everywhere (\\forall* int i; 0\u003c=i \u0026\u0026 i\u003ca.length \u0026\u0026 (i\u003clow || i\u003ehigh); Perm(a[i], 1\\2));\n    //@ context_everywhere (\\forall* int i; low\u003c=i \u0026\u0026 i\u003c=high; Perm(a[i], write));\n    //@ requires (\\exists int i; low\u003c=i \u0026\u0026 i\u003c=high; a[i] == pivot);\n    //@ ensures low\u003c=\\result \u0026\u0026 \\result\u003c=high;\n    //@ ensures (\\forall int i; low\u003c=i \u0026\u0026 i\u003c\\result; a[i] \u003c pivot);\n    //@ ensures (\\forall int i; \\result\u003c=i \u0026\u0026 i\u003c=high; pivot \u003c= a[i]);\n    //@ ensures a[\\result] == pivot;\n    //@ ensures (\\forall int i; low\u003c=i \u0026\u0026 i\u003c\\result; (\\forall int j; \\result\u003c=j \u0026\u0026 j\u003c=high; a[i] \u003c a[j]));\n    //@ ensures (\\forall int i; low\u003c=i \u0026\u0026 i\u003c=\\result; (\\forall int j; \\result\u003c=j \u0026\u0026 j\u003c=high; a[i] \u003c= a[j]));\n    //@ ensures (\\forall int i; 0\u003c=i \u0026\u0026 i\u003clow; (\\forall int j; low\u003c=j \u0026\u0026 j\u003ca.length; \\old(a[i]) \u003c= \\old(a[j]))) ==\u003e (\\forall int k; 0\u003c=k \u0026\u0026 k\u003clow; (\\forall int l; low\u003c=l \u0026\u0026 l\u003ca.length; a[k] \u003c= a[l]));\n    //@ ensures (\\forall int i; 0\u003c=i \u0026\u0026 i\u003c=high; (\\forall int j; high\u003cj \u0026\u0026 j\u003ca.length; \\old(a[i]) \u003c= \\old(a[j]))) ==\u003e (\\forall int k; 0\u003c=k \u0026\u0026 k\u003c=high; (\\forall int m; high\u003cm \u0026\u0026 m\u003ca.length; a[k] \u003c= a[m]));\n    public static int partition(int[] a, int low, int high, int pivot) {\n        int l = low;\n        int h = high;\n        //@ loop_invariant low\u003c=l \u0026\u0026 l\u003c=high;\n        //@ loop_invariant low\u003c=h \u0026\u0026 h\u003c=high;\n        //@ loop_invariant (\\forall int i; low\u003c=i \u0026\u0026 i\u003cl; a[i]\u003cpivot);\n        //@ loop_invariant (\\forall int i; l\u003c=i \u0026\u0026 h\u003ci \u0026\u0026 i\u003c=high; pivot \u003c= a[i]);\n        //@ loop_invariant l\u003c=h;\n        //@ loop_invariant (\\exists int i; l\u003c=i \u0026\u0026 i\u003c=h; a[i] == pivot);\n        //@ loop_invariant (\\forall int i; 0\u003c=i \u0026\u0026 i\u003clow; (\\forall int j; low\u003c=j \u0026\u0026 j\u003ca.length; \\old(a[i]) \u003c= \\old(a[j]))) ==\u003e (\\forall int k; 0\u003c=k \u0026\u0026 k\u003clow; (\\forall int m; low\u003c=m \u0026\u0026 m\u003ca.length; a[k] \u003c= a[m]));\n        //@ loop_invariant (\\forall int i; 0\u003c=i \u0026\u0026 i\u003c=high; (\\forall int j; high\u003cj \u0026\u0026 j\u003ca.length; \\old(a[i]) \u003c= \\old(a[j]))) ==\u003e (\\forall int k; 0\u003c=k \u0026\u0026 k\u003c=high; (\\forall int m; high\u003cm \u0026\u0026 m\u003ca.length; a[k] \u003c= a[m]));\n        while(true){\n            //@ loop_invariant low\u003c=l \u0026\u0026 l\u003c=high;\n            //@ loop_invariant low\u003c=h \u0026\u0026 h\u003c=high;\n            //@ loop_invariant (\\forall int i; low\u003c=i \u0026\u0026 i\u003cl; a[i]\u003cpivot);\n            //@ loop_invariant (\\forall int i; l\u003c=i \u0026\u0026 h\u003ci \u0026\u0026 i\u003c=high; pivot \u003c= a[i]);\n            //@ loop_invariant l\u003c=h;\n            //@ loop_invariant (\\exists int i; l\u003c=i \u0026\u0026 i\u003c=h; a[i] == pivot);\n            //@ loop_invariant (\\forall int i; 0\u003c=i \u0026\u0026 i\u003clow; (\\forall int j; low\u003c=j \u0026\u0026 j\u003ca.length; \\old(a[i]) \u003c= \\old(a[j]))) ==\u003e (\\forall int k; 0\u003c=k \u0026\u0026 k\u003clow; (\\forall int m; low\u003c=m \u0026\u0026 m\u003ca.length; a[k] \u003c= a[m]));\n            //@ loop_invariant (\\forall int i = 0 ..high, int j = high ..a.length; \\old(a[i]) \u003c= \\old(a[j]) ) ==\u003e (\\forall int k = 0 ..high, int m = high ..a.length; a[k] \u003c= a[m]);\n            while(a[l] \u003c pivot \u0026\u0026 l\u003ch){\n                l = l+1;\n            }\n            //@ loop_invariant low\u003c=l \u0026\u0026 l\u003c=high;\n            //@ loop_invariant a[l]\u003e=pivot || l\u003e=h;\n            //@ loop_invariant low\u003c=h \u0026\u0026 h\u003c=high;\n            //@ loop_invariant (\\forall int i; low\u003c=i \u0026\u0026 i\u003cl; a[i]\u003cpivot);\n            //@ loop_invariant (\\forall int i; l\u003c=i \u0026\u0026 h\u003ci \u0026\u0026 i\u003c=high; pivot \u003c= a[i]);\n            //@ loop_invariant l\u003c=h;\n            //@ loop_invariant a[l] \u003e= pivot;\n            //@ loop_invariant (\\exists int i; l\u003c=i \u0026\u0026 i\u003c=h; a[i] == pivot);\n            //@ loop_invariant (\\forall int i; 0\u003c=i \u0026\u0026 i\u003clow; (\\forall int j; low\u003c=j \u0026\u0026 j\u003ca.length; \\old(a[i]) \u003c= \\old(a[j]))) ==\u003e (\\forall int k; 0\u003c=k \u0026\u0026 k\u003clow; (\\forall int m; low\u003c=m \u0026\u0026 m\u003ca.length; a[k] \u003c= a[m]));\n            //@ loop_invariant (\\forall int i; 0\u003c=i \u0026\u0026 i\u003c=high; (\\forall int j; high\u003cj \u0026\u0026 j\u003ca.length; \\old(a[i]) \u003c= \\old(a[j]))) ==\u003e (\\forall int k; 0\u003c=k \u0026\u0026 k\u003c=high; (\\forall int m; high\u003cm \u0026\u0026 m\u003ca.length; a[k] \u003c= a[m]));\n            while(a[h] \u003e pivot \u0026\u0026 h\u003el){\n                h = h-1;\n            }\n            if(l\u003e=h) {\n                return l;\n            }else{\n                swap(a, l, h);\n                if(a[l] \u003c pivot) {\n                    l = l+1;\n                } else {\n                    h = h-1;\n                }\n            }\n        }\n    }\n\n    //@ context_everywhere list != null;\n    //@ context_everywhere list.length \u003e 0;\n    //@ context  0\u003c=k \u0026\u0026 k\u003clist.length;\n    //@ context_everywhere (\\forall* int i; 0\u003c=i \u0026\u0026 i\u003clist.length; Perm(list[i], write));\n    //@ ensures (\\exists int i; 0\u003c=i \u0026\u0026 i\u003clist.length; list[i] == \\result);\n    //@ ensures (\\forall int i; 0\u003c=i \u0026\u0026 i\u003c=k; list[i] \u003c= \\result);\n    //@ ensures (\\forall int i; k\u003c= i \u0026\u0026 i\u003clist.length; \\result \u003c= list[i]);\n    public static int select(int[] list, int k){\n        int left = 0;\n        int right = list.length-1;\n        int pivotIndex = k;\n        int pivot = list[pivotIndex];\n        //@ loop_invariant 0\u003c=left \u0026\u0026 left\u003clist.length;\n        //@ loop_invariant 0\u003c=right \u0026\u0026 right\u003clist.length;\n        //@ loop_invariant left\u003c=pivotIndex \u0026\u0026 pivotIndex\u003c=right;\n        //@ loop_invariant left \u003c= k \u0026\u0026 right \u003e= k;\n        //@ loop_invariant (\\forall int i; 0\u003c=i \u0026\u0026 i\u003cleft; (\\forall int j; left\u003c=j \u0026\u0026 j\u003clist.length; list[i] \u003c= list[j]));\n        //@ loop_invariant (\\forall int i; 0\u003c=i \u0026\u0026 i\u003c=right; (\\forall int j; right\u003cj \u0026\u0026 j\u003clist.length; list[i] \u003c= list[j]));\n        while (left \u003c right) {\n            pivot = list[pivotIndex];\n            pivotIndex = partition(list, left, right, pivot);\n            if (k == pivotIndex) {\n                return list[k];\n            }           else  {\n                if (k \u003c pivotIndex) {\n                    right = pivotIndex - 1;\n                }else{\n                    left = pivotIndex + 1;\n                }\n            }\n            printArray(list, left, right);\n            pivotIndex = random_between(left, right);\n        }\n        return list[left];\n    } \n    \n    //@ requires false;\n    public static void main(String[] args) {\n        int[] nums = new int[20];\n        for(int i=0; i\u003cnums.length; i++){\n            nums[i] = (int)(100*Math.random());\n        }\n        int k = (int)(nums.length*Math.random());\n        String ks = \"th\";\n        if(k==0) ks = \"st\";\n        if(k==1) ks = \"nd\";\n        System.out.println(String.format(\"Find the %d%s smallest number in\", k+1, ks));\n        printArray(nums, 0, nums.length-1);\n        System.out.println(\"...\");\n        int kth = select(nums, k);\n        printArray(nums, k, k);\n    }\n    \n}\n",
        "name": "QuickSelect.java",
        "path": "examples/archive/known-problems/no-issue/quickselect/QuickSelect.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/archive/known-problems/no-issue/quickselect/QuickSelect.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires low\u003c=high;"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures low\u003c=\\result \u0026\u0026 \\result\u003c=high;"
        },
        {
          "limitHit": false,
          "lineNumber": 24,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= l ** l \u003c a.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures a[l] == \\old(a[h]);"
        },
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures a[h] == \\old(a[l]);"
        },
        {
          "limitHit": false,
          "lineNumber": 39,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires (\\exists int i; low\u003c=i \u0026\u0026 i\u003c=high; a[i] == pivot);"
        },
        {
          "limitHit": false,
          "lineNumber": 40,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures low\u003c=\\result \u0026\u0026 \\result\u003c=high;"
        },
        {
          "limitHit": false,
          "lineNumber": 41,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures (\\forall int i; low\u003c=i \u0026\u0026 i\u003c\\result; a[i] \u003c pivot);"
        },
        {
          "limitHit": false,
          "lineNumber": 42,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures (\\forall int i; \\result\u003c=i \u0026\u0026 i\u003c=high; pivot \u003c= a[i]);"
        },
        {
          "limitHit": false,
          "lineNumber": 43,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures a[\\result] == pivot;"
        },
        {
          "limitHit": false,
          "lineNumber": 44,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures (\\forall int i; low\u003c=i \u0026\u0026 i\u003c\\result; (\\forall int j; \\result\u003c=j \u0026\u0026 j\u003c=high; a[i] \u003c a[j]));"
        },
        {
          "limitHit": false,
          "lineNumber": 45,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures (\\forall int i; low\u003c=i \u0026\u0026 i\u003c=\\result; (\\forall int j; \\result\u003c=j \u0026\u0026 j\u003c=high; a[i] \u003c= a[j]));"
        },
        {
          "limitHit": false,
          "lineNumber": 46,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures (\\forall int i; 0\u003c=i \u0026\u0026 i\u003clow; (\\forall int j; low\u003c=j \u0026\u0026 j\u003ca.length; \\old(a[i]) \u003c= \\old(a[j]))) ==\u003e (\\forall int k; 0\u003c=k \u0026\u0026 k\u003clow; (\\forall int l; low\u003c=l \u0026\u0026 l\u003ca.length; a[k] \u003c= a[l]));"
        },
        {
          "limitHit": false,
          "lineNumber": 47,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures (\\forall int i; 0\u003c=i \u0026\u0026 i\u003c=high; (\\forall int j; high\u003cj \u0026\u0026 j\u003ca.length; \\old(a[i]) \u003c= \\old(a[j]))) ==\u003e (\\forall int k; 0\u003c=k \u0026\u0026 k\u003c=high; (\\forall int m; high\u003cm \u0026\u0026 m\u003ca.length; a[k] \u003c= a[m]));"
        },
        {
          "limitHit": false,
          "lineNumber": 101,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures (\\exists int i; 0\u003c=i \u0026\u0026 i\u003clist.length; list[i] == \\result);"
        },
        {
          "limitHit": false,
          "lineNumber": 102,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures (\\forall int i; 0\u003c=i \u0026\u0026 i\u003c=k; list[i] \u003c= \\result);"
        },
        {
          "limitHit": false,
          "lineNumber": 103,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures (\\forall int i; k\u003c= i \u0026\u0026 i\u003clist.length; \\result \u003c= list[i]);"
        },
        {
          "limitHit": false,
          "lineNumber": 133,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires false;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "//:: case QuickSelectImpl\n//:: tools silicon\n//:: suite helper-file\n// File is not included in testing: it is only there as a helper to execute a verified file.\n\npackage quickselect;\n\n/**\n* Helper class to print arrays for the QuickSelect example.\n*/\npublic class ArrayPrinter {\n\n    //@ requires false;\n    public static void printArray(int[] a, int l, int h){\n        for(int i=0; i \u003c a.length; i++){\n            if(i==l || i==h+1) {\n                System.out.print(\"|\");\n            } else {\n                System.out.print(\" \");\n            }\n            System.out.print(String.format(\"%2d\", a[i]));\n        }\n        if(h==a.length-1) {\n            System.out.print(\"|\");\n        }\n        System.out.println();\n    }\n    \n}",
        "name": "ArrayPrinter.java",
        "path": "examples/archive/known-problems/no-issue/quickselect/ArrayPrinter.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/archive/known-problems/no-issue/quickselect/ArrayPrinter.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires false;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "//:: case QuickSelectImpl\n//:: suite helper-file\n// File is not included in testing: it is only there as a helper to execute a verified file.\n\npackage quickselect;\n\n/**\n* Implementation of random_between from the QuickSelect example.\n*/\npublic class RandomBetween {\n    \n    //@ requires low\u003c=high;\n    //@ ensures low\u003c=\\result \u0026\u0026 \\result\u003c=high;\n    public static int random_between(int low, int high) {\n        return ((int)Math.random()*(high+1-low))+low;\n    }\n    \n}",
        "name": "RandomBetween.java",
        "path": "examples/archive/known-problems/no-issue/quickselect/RandomBetween.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/archive/known-problems/no-issue/quickselect/RandomBetween.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires low\u003c=high;"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures low\u003c=\\result \u0026\u0026 \\result\u003c=high;"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "package staticResolve;\n\npublic class Test {\n\n    static int x = 5;\n\n    //@ requires Perm(x, write);\n    public static int five() {\n        return x;\n    }\n\n    public Test () {\n        String test = null;\n    }\n}",
        "name": "Test.java",
        "path": "examples/technical/staticResolve/Test.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/technical/staticResolve/Test.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires Perm(x, write);"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ebacf81c484d8d5f83e112461156e32a2b4c48d5"
        },
        "content": "package staticResolve;\npublic class TestImport {\n\n    //@ requires Perm(Test.x, write);\n    public void test() {\n\n        int val = Test.x;\n\n        int val = Test.five();\n\n    }\n\n}",
        "name": "TestImport.java",
        "path": "examples/technical/staticResolve/TestImport.java",
        "url": "/github.com/utwente-fmt/vercors/-/blob/examples/technical/staticResolve/TestImport.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires Perm(Test.x, write);"
        }
      ],
      "repository": {
        "name": "github.com/utwente-fmt/vercors",
        "url": "/github.com/utwente-fmt/vercors"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 165,
  "ElapsedMilliseconds": 897,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
