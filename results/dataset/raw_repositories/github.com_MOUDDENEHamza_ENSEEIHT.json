{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/MOUDDENEHamza/ENSEEIHT lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23074e1f35de3e26a17ea425a53e1ec74722f1ed"
        },
        "content": "/**\n * Définition du « modèle » du jeu du Morpion.\n *\n * @author Xavier Crégut\n * @version $Revision: 1.2 $\n */\npublic interface ModeleMorpion {\n\n    // Modéliser (coder !) le contenu d'une case\n    enum Etat {\n        VIDE, CROIX, ROND\n    }\n\n    ;\n\n    int TAILLE = 3;    // taille du jeu de Morpion\n\n// Définition des événements qui vont influencer le modèle.\n\n    /**\n     * Quitter le jeu.\n     */\n    void quitter();\n\n    /**\n     * Recommencer une nouvelle partie.\n     */\n    void recommencer();\n\n    /**\n     * Cocher la case (x,y).\n     */\n    //@ requires x \u003e= 0 \u0026\u0026 x \u003c TAILLE;\n    //@ requires y \u003e= 0 \u0026\u0026 y \u003c TAILLE;\n    void cocher(int x, int y) throws CaseOccupeeException;\n\n// Requêtes sur le modèle\n\n    /**\n     * Est-ce que la partie est terminée ?\n     */\n    boolean estTerminee();\n\n    /**\n     * Est-ce qu'il y a un gagnant ?\n     */\n    boolean estGagnee();\n\n    /**\n     * Obtenir le joueur dont c'est le tour de jouer.\n     */\n    Etat getJoueur();\n\n    /**\n     * Obtenir le contenu d'une case.\n     *\n     * @param x colonne de la case\n     * @param y ligne de la case\n     */\n    //@ requires x \u003e= 0 \u0026\u0026 x \u003c TAILLE;\n    //@ requires y \u003e= 0 \u0026\u0026 y \u003c TAILLE;\n    Etat getValeur(int x, int y);\n\n}\n",
        "name": "ModeleMorpion.java",
        "path": "1A/S6/TOB/TPs/TP13/ModeleMorpion.java",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT/-/blob/1A/S6/TOB/TPs/TP13/ModeleMorpion.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 32,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires x \u003e= 0 \u0026\u0026 x \u003c TAILLE;"
        },
        {
          "limitHit": false,
          "lineNumber": 33,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires y \u003e= 0 \u0026\u0026 y \u003c TAILLE;"
        },
        {
          "limitHit": false,
          "lineNumber": 59,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires x \u003e= 0 \u0026\u0026 x \u003c TAILLE;"
        },
        {
          "limitHit": false,
          "lineNumber": 60,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires y \u003e= 0 \u0026\u0026 y \u003c TAILLE;"
        }
      ],
      "repository": {
        "name": "github.com/MOUDDENEHamza/ENSEEIHT",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23074e1f35de3e26a17ea425a53e1ec74722f1ed"
        },
        "content": "/**\n * ModeleMorpionSimple est une réalisation de l'interface ModeleMorpion en\n * utilisant un damier (tableau 3 par 3) pour stocker les symboles...\n *\n * @author Xavier Crégut\n * @version $Revision: 1.2 $\n */\n\npublic class ModeleMorpionSimple implements ModeleMorpion {\n\n    /**\n     * La zone de jeu\n     */\n    private Etat[][] cases;\n\n    /**\n     * Le joueur dont c'est le tour de jouer\n     */\n    private Etat joueur;\n\n    /**\n     * Le nombres de cases cochées\n     */\n    private int nbCoups;\n\n    /**\n     * Est-ce que la partie est gagnée ?\n     */\n    private boolean gagnee;\n\n    public ModeleMorpionSimple() {\n        // Créer le damier\n        this.cases = new Etat[ModeleMorpion.TAILLE][ModeleMorpion.TAILLE];\n\n        // Commencer une partie\n        initialiser();\n    }\n\n    /**\n     * Est-ce que la partie est terminée ?\n     */\n    public boolean estTerminee() {\n        return estGagnee()\n                || this.nbCoups \u003e= ModeleMorpion.TAILLE * ModeleMorpion.TAILLE;\n    }\n\n    /**\n     * Est-ce qu'il y a un gagnant ?\n     */\n    public boolean estGagnee() {\n        return gagnee;\n    }\n\n    /**\n     * Est-ce que la case (i,j) est vide ?\n     */\n    private boolean estVide(int i, int j) {\n        return getValeur(i, j) == Etat.VIDE;\n    }\n\n    public Etat getValeur(int x, int y) {\n        return this.cases[x][y];\n    }\n\n    /**\n     * Initialiser le jeu pour faire une nouvelle partie\n     */\n    private void initialiser() {\n        // Initialiser les cases\n        for (int i = 0; i \u003c this.cases.length; i++) {\n            for (int j = 0; j \u003c this.cases[i].length; j++) {\n                this.cases[i][j] = Etat.VIDE;\n            }\n        }\n\n        // Initialiser le nb de coups\n        this.nbCoups = 0;\n\n        // Initialiser gagnée\n        gagnee = false;\n\n        // Initialiser le joueur\n        this.joueur = Etat.CROIX;\n    }\n\n    public Etat getJoueur() {\n        return this.joueur;\n    }\n\n    /**\n     * Changer de joueur\n     */\n    private void changer() {\n        if (this.joueur == Etat.CROIX) {\n            this.joueur = Etat.ROND;\n        } else {\n            this.joueur = Etat.CROIX;\n        }\n    }\n\n    /**\n     * Jouer en (i,j) pour le joueur\n     */\n    //@ requires estVide(i,j);\n    //@ ensures getValeur(i,j) == joueur;\n    private void jouer(int i, int j) {\n        this.cases[i][j] = this.joueur;\n        this.nbCoups++;\n\n        // Mettre à jour gagnee\n        // XXX: Ceci ne marche que pour un Morpion de taille 3 !\n        gagnee = gagnee ||\n                ((cases[i][0] == cases[i][1]    // ligne pleine\n                        \u0026\u0026 cases[i][1] == cases[i][2])\n                        || (cases[0][j] == cases[1][j]    // colonne pleine\n                        \u0026\u0026 cases[1][j] == cases[2][j])\n                        || (i == j    // première diagonale pleine\n                        \u0026\u0026 cases[0][0] == cases[1][1]\n                        \u0026\u0026 cases[1][1] == cases[2][2])\n                        || (i + j == 2    // deuxième diagonale pleine\n                        \u0026\u0026 cases[0][2] == cases[1][1]\n                        \u0026\u0026 cases[1][1] == cases[2][0]));\n    }\n\n\n/////// « Événements » de haut niveau déclenchées par l'utilisateur ////////////\n\n\n    // Remarque : dans cette partie j'ai laissé le paramètre implicite this car\n    // il me semble qu'il faudrait mettre tout ceci dans une classe spécifique,\n    // par exemple LogiqueMorpion.  Dans ce cas, this serait remplacé par\n    // getModele() ou getMorpion().\n\n\n    public void quitter() {\n    }\n\n    public void recommencer() {\n        this.initialiser();\n    }\n\n    public void cocher(int x, int y) throws CaseOccupeeException {\n        if (!this.estTerminee()) {    // La partie est en cours\n            if (this.estVide(x, y)) {\n                // Jouer la case\n                this.jouer(x, y);\n\n                // Passer à la suite\n                if (!this.estTerminee()) {\n                    // Faire jouer l'autre joueur\n                    this.changer();\n                }\n            } else {\n                throw new CaseOccupeeException(\"Impossible, la case est occupée !\");\n            }\n        }\n    }\n\n}\n",
        "name": "ModeleMorpionSimple.java",
        "path": "1A/S6/TOB/TPs/TP13/ModeleMorpionSimple.java",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT/-/blob/1A/S6/TOB/TPs/TP13/ModeleMorpionSimple.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 103,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires estVide(i,j);"
        },
        {
          "limitHit": false,
          "lineNumber": 104,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures getValeur(i,j) == joueur;"
        }
      ],
      "repository": {
        "name": "github.com/MOUDDENEHamza/ENSEEIHT",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23074e1f35de3e26a17ea425a53e1ec74722f1ed"
        },
        "content": "/**\n * Définition d'une date dans le calendrier grégorien.\n *\n * @author\tXavier Crégut\n * @version\t1.5\n */\npublic class Date {\n\n\t/*@ // le jour, le mois et l'année sont valides\n\t\tpublic invariant\n\t\tDate.estValide(this.getJour(), this.getMois(), this.getAnnee());\n\t\t\n\t\t// le quantième est valide\n\t\tpublic invariant\n\t\tDate.estQuantiemeValide(this.getQuantieme(), this.getAnnee());\n\n\t\tprivate invariant\t// cumulJoursMois est cohérent avec nbJoursDansMois\n\t\t\t(\\forall int mois; 0 \u003c= mois \u0026\u0026 mois \u003c Date.cumulJoursMois.length;\n\t\t\t\tDate.cumulJoursMois[mois] ==\n\t\t\t\t\t\t(\\sum int m; 0 \u003c= m \u0026\u0026 m \u003c mois; Date.nbJoursMois[m]));\n\t@*/\n\n\t/** Tableau du nombre de jours par mois (sans prendre en compte les\n\t\t* années bissextiles). nbJoursMois[i] est le nombre de jours du\n\t\t* mois de numéro i+1.\n\t\t*/\n\tprivate static int nbJoursMois[] =\n\t\t\t{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n\t/** Cumul des jours des mois précédents. cumulJoursMois[i] est le\n\t\t* nombre cumulé des jours des mois dont les numéros sont dans\n\t\t* l'intervalle 1..i-1.\n\t\t*/\n\tprivate static int cumulJoursMois[] =\n\t\t\t{ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };\n\n\t/** le numéro du jour dans le mois */\n\tprivate int jour;\n\n\t/** le numéro du mois dans l'année */\n\tprivate int mois;\n\n\t/** l'année */\n\tprivate int annee;\n\n\t/** Construire une date à partir du numéro du jour, du numéro du mois et de\n\t\t* l'année (qui doivent former une date valide).\n\t\t* @param j le numéro du jour dans le mois m\n\t\t* @param m le numéro du mois\n\t\t* @param a l'année\n\t\t*/\n\t//@ requires Date.estValide(j, m, a);\n\t//@ ensures getJour() == j;\n\t//@ ensures getMois() == m;\n\t//@ ensures getAnnee() == a;\n\tpublic Date(int j, int m, int a) {\n\t\tthis._set(j, m, a);\n\t\t\t// On ne peut pas appeler directement set(j, m, a) car comme elle est\n\t\t\t// publique, elle provoque la vérification des invariants.\n\t}\n\n\t/** Construire une date à partir du quantième du jour dans l'année et de\n\t * l'année.\n\t * @param q le quantième du jour dans l'année\n\t * @param a l'année\n\t */\n\t//@ requires Date.estAnneeValide(a);\n\t//@ requires Date.estQuantiemeValide(q, a);\n\t//@ ensures getQuantieme() == q;\n\t//@ ensures getAnnee() == a;\n\tpublic Date(int q, int a) {\n\t\tthis._set(q, a);\n\t}\n\n\t/** Changer la date à partir du numéro du jour, du numéro du mois et de\n\t * l'année.\n\t * @param j le numéro du jour dans le mois m\n\t * @param m le numéro du mois\n\t * @param a l'année\n\t */\n\t// Cette méthode est privée et déclarée comme \u003cem\u003ehelper\u003c/em\u003e de manière à\n\t// ce que les invariants de la classe ne soient pas vérifiés quand elle\n\t// appelée depuis une autre méthode de la classe.\n\t//@ requires Date.estValide(j, m, a);\n\t//@ ensures this.jour == j;\n\t//@ ensures this.mois == m;\n\t//@ ensures this.annee == a;\n\t//@ helper\n\tprivate void _set(int j, int m, int a) {\n\t\tthis.jour = j;\n\t\tthis.mois = m;\n\t\tthis.annee = a;\n\t}\n\n\t/** Changer la date à partir du numéro du jour, du numéro du mois et de\n\t * l'année.\n\t * @param j le numéro du jour dans le mois m\n\t * @param m le numéro du mois\n\t * @param a l'année\n\t */\n\t//@ requires Date.estValide(j, m, a);\n\t//@ ensures getJour() == j;\n\t//@ ensures getMois() == m;\n\t//@ ensures getAnnee() == a;\n\tpublic void set(int j, int m, int a) {\n\t\tthis._set(j, m, a);\n\t}\n\n\t/** Changer la date à partir du quantième du jour dans l'année et de\n\t * l'année.\n\t * @param q le quantième du jour dans l'année\n\t * @param a l'année\n\t */\n\t//@ requires Date.estAnneeValide(a);\n\t//@ requires Date.estQuantiemeValide(q, a);\n\t//@ ensures getQuantieme() == q;\n\t//@ ensures getAnnee() == a;\n\t//@ helper\n\tprivate void _set(int q, int a) {\n\t\t// Initialiser l'année\n\t\tthis.annee = a;\n\n\t\t// Initialiser le mois\n\t\tthis.mois = 1;\n\t\twhile (q \u003e nbJoursDansMois(this.mois, a)) { //  le mois est terminé\n\t\t\tq = q - nbJoursDansMois(this.mois, a);\n\t\t\tthis.mois++;\n\t\t}\n\n\t\t// Initialiser les jours\n\t\tthis.jour = q;\n\t}\n\n\t/** Changer la date à partir du quantième du jour dans l'année et de\n\t * l'année.\n\t * @param q le quantième du jour dans l'année\n\t * @param a l'année\n\t */\n\t//@ requires Date.estAnneeValide(a);\n\t//@ requires Date.estQuantiemeValide(q, a);\n\t//@ ensures getQuantieme() == q;\n\t//@ ensures getAnnee() == a;\n\tpublic void set(int q, int a) {\n\t\tthis._set(q, a);\n\t}\n\n\t/** Obtenir le numéro du jour dans le mois.\n\t * @return le numéro du jour dans le mois\n\t */\n\t//@ pure\n\t//@ helper\n\tpublic int getJour() {\n\t\treturn this.jour;\n\t}\n\n\t/** Obtenir le numéro du mois dans l'année.\n\t * @return le numéro du mois dans l'année\n\t */\n\t//@ pure\n\t//@ helper\n\tpublic int getMois() {\n\t\treturn this.mois;\n\t}\n\n\t/** Obtenir l'année.\n\t * @return l'année\n\t */\n\t//@ pure\n\t//@ helper\n\tpublic int getAnnee() {\n\t\treturn this.annee;\n\t}\n\n\t/** Obtenir le quantième du jour dans l'année.\n\t * @return le quantième du jour dans l'année\n\t */\n\t//@ pure\n\t//@ helper\n\tpublic int getQuantieme() {\n\t\tint resultat = this.jour\t// nb de jours dans le mois en cours\n\t\t\t\t+ cumulJoursMois[this.mois-1]; // nb de jours des mois précédents\n\t\t// Prendre en compte le cas de l'année bissextile\n\t\tif (this.mois \u003e 2 \u0026\u0026 estBissextile(this.annee)) {\n\t\t\tresultat++;\n\t\t}\n\n\t\treturn resultat;\n\t}\n\n\t/** Obtenir le nombres de jours depuis l'an 0.\n\t * @return nombres de jours depuis l'an 0.\n\t */\n\t//@ pure\n\tpublic int getNbJoursDepuisAn0() {\n\t\tint a = this.annee - 1;\t// nb d'années pleines\n\t\treturn this.getQuantieme()\t// nb de jours dans l'année en cours\n\t\t\t\t+ 365 * a\t\t\t\t// années considérées non bissextiles\n\t\t\t\t+ (a / 4 - a / 100 + a / 400);\t// nb d'années bissextiles\n\t}\n\n\t/** Afficher la date sous la forme jour/mois/année.  */\n\tpublic void afficher() {\n\t\tSystem.out.println(this);\n\t}\n\n\t// Méthode définie dans objet.  Je n'utilise pas un commentaire javadoc car\n\t// le commentaire défini dans la classe parente est le commentaire à\n\t// utiliser.\n\tpublic String toString() {\n\t\treturn \"\" + int2String(this.jour)\n\t\t\t\t\t\t+ '/' + int2String(this.mois)\n\t\t\t\t\t\t+ '/' + this.annee;\n\t\t\t\t// le \"\" intial est là pour forcer la conversion en String,\n\t\t\t\t// les caractères sont en effet compatibles avec les entiers !\n\t}\n\n\t/** Obtenir la représentation d'un entier sous la forme d'une chaîne de\n\t * caractères avec au moins 2 caractères.\n\t * @param entier l'entier à convertir\n\t * @return  la chaîne de caractères correspondant à entier\n\t */\n\tprivate static String int2String(int entier) {\n\t\tString prefixe = (entier \u003e= 0 \u0026\u0026 entier \u003c 10) ? \"0\" : \"\";\n\t\treturn  prefixe + entier;\n\t}\n\n\t/** L'année a est-elle bissextile ?\n\t * @param a l'année\n\t * @return vrai si l'année est bissextile\n\t */\n\t//@ pure\n\tpublic static boolean estBissextile(int a) {\n\t\treturn (a % 4 == 0)\t\t\t// divisible par 4\n\t\t\t\t\u0026\u0026 ((a % 100 != 0)\t\t// et non divible par 100\n\t\t\t\t\t|| (a % 400 == 0));\t// sauf si divisible par 400\n\t}\n\n\t/** Nombre de jours dans le mois m de l'année a.\n\t * @param m le numéro du mois\n\t * @param a l'année\n\t * @return le nombre de jours dans le mois m de l'année a\n\t */\n\t//@ pure\n\tpublic static int nbJoursDansMois(int m, int a) {\n\t\tint resultat = nbJoursMois[m-1];\t// nb de jours dans le mois\n\t\tif (m == 2 \u0026\u0026 estBissextile(a)) {\t// cas du mois de février\n\t\t\tresultat++;\n\t\t}\n\t\treturn resultat;\n\t}\n\n\t/** Est-ce que le numéro de jour j est valide pour le mois m de l'année a ?\n\t * @param j le numéro du jour dans le mois m\n\t * @param m le numéro du mois\n\t * @param a l'année\n\t */\n\t//@ requires Date.estAnneeValide(a);\n\t//@ requires Date.estMoisValide(m);\n\t//@ pure\n\tpublic static boolean estJourValide(int j, int m, int a) {\n\t\treturn 1 \u003c= j \u0026\u0026 j \u003c= nbJoursDansMois(m, a);\n\t}\n\n\t/** Est-ce que le numéro de mois m est valide ?\n\t * @param m le numéro du mois\n\t */\n\t//@ ensures \\result \u003c==\u003e (1 \u003c= m \u0026\u0026 m \u003c= 12);\n\t//@ pure\n\tpublic static boolean estMoisValide(int m) {\n\t\treturn 1 \u003c= m \u0026\u0026 m \u003c= 12;\n\t}\n\n\t/** Est-ce que le quantième est valide ?\n\t\t* @param q le numéro du jour dans l'année\n\t\t* @param a l'année\n\t\t*/\n\t//@ pure\n\t//@ helper\n\tpublic static boolean estQuantiemeValide(int q, int a) {\n\t\tboolean resultat = estAnneeValide(a);\n\t\tint nbJours = 365;\t// nb de jours dans l'année a;\n\t\tif (estBissextile(a)) {\n\t\t\tnbJours++;\n\t\t}\n\t\tresultat = resultat \u0026\u0026 1 \u003c= q \u0026\u0026 q \u003c= nbJours;\n\t\treturn resultat;\n\t}\n\n\t/** Est-ce que l'année est valide ?\n\t * @param a l'année\n\t */\n\t//@ ensures \\result \u003c==\u003e a \u003e 0;\n\t//@ pure\n\tpublic static boolean estAnneeValide(int a) {\n\t\treturn a \u003e 0;\n\t}\n\n\t/** Est-ce que la date définie par le jour j, le mois m et l'année a est\n\t * valide ?\n\t * @param j le numéro du jour dans le mois m\n\t * @param m le numéro du mois\n\t * @param a l'année\n\t */\n\t//@ pure\n\t//@ helper\n\tpublic static boolean estValide(int j, int m, int a) {\n\t\treturn estAnneeValide(a)\n\t\t\t\t\u0026\u0026  estMoisValide(m)\n\t\t\t\t\u0026\u0026  estJourValide(j, m, a);\n\t}\n\n//\tRelation d'ordre sur les dates\n//\t------------------------------\n\n\t/** Déterminer si une date est antérieure strictement à une autre date.\n\t * @param autre l'autre date (non nulle)\n\t * @return cette date est-elle strictement antérieure à l'autre date ?\n\t */\n\t/*@ requires autre != null;\t// l'autre date est définie\n\t    ensures \\result == this.getAnnee() \u003c autre.getAnnee()\n\t   \t || (this.getAnnee() == autre.getAnnee()\n\t   \t \t\u0026\u0026 getMois() \u003c autre.getMois())\n\t   \t || (this.getAnnee() == autre.getAnnee()\n\t   \t\t   \u0026\u0026 this.getMois() == autre.getMois()\n\t   \t\t   \u0026\u0026 this.getJour() \u003c autre.getJour());\n\t    pure\n\t@*/\n\tpublic boolean lt(Date autre) {\n\t\tif (this.getAnnee() != autre.getAnnee()) {\n\t\t\treturn this.getAnnee() \u003c autre.getAnnee();\n\t\t} else if (this.getMois() != autre.getMois()) {\n\t\t\treturn  this.getMois() \u003c autre.getMois();\n\t\t} else {\n\t\t\treturn  this.getJour() \u003c autre.getJour();\n\t\t}\n\t}\n\n\t/** Déterminer si une date est postérieure ou égale à une autre date.\n\t * @param autre l'autre date (non nulle)\n\t * @return cette date est-elle postérieure ou égale à l'autre date\n\t */\n\t//@ ensures \\result == ! lt(autre);\n\t//@ pure\n\tpublic boolean ge(Date autre) {\n\t\treturn ! this.lt(autre);\n\t}\n\n\t/** Déterminer si une date est strictement postérieure à une autre date.\n\t * @param autre l'autre date (non nulle)\n\t * @return cette date est-elle strictement postérieure à l'autre date\n\t */\n\t//@ ensures \\result == autre.lt(this);\n\t//@ pure\n\tpublic boolean gt(Date autre) {\n\t\treturn autre.lt(this);\n\t\t\t\t// Utilisation obligatoire de this (on ne peut pas s'en passer).\n\t}\n\n\t/** Déterminer si une date est antérieure ou égale à une autre date.\n\t * @param autre l'autre date (non nulle)\n\t * @return cette date est-elle antérieure ou égale à l'autre date\n\t */\n\t//@ ensures \\result == !autre.lt(this);\n\t//@ pure\n\tpublic boolean le(Date autre) {\n\t\treturn  ! autre.lt(this);\n\t}\n\n//\tÉgalité de deux dates\n//\t---------------------\n\n\t/** Déterminer si deux dates sont égales.\n\t * @param autre l'autre date\n\t * @return cette date est égale à l'autre date\n\t */\n\t//@ ensures \\result == (le(autre) \u0026\u0026 ge(autre));\n\t//@ pure\n\tpublic boolean equals(Date autre) {\n\t\treturn autre != null\n\t\t\t\t\u0026\u0026 this.getAnnee() == autre.getAnnee()\n\t\t\t\t\u0026\u0026 this.getMois() == autre.getMois()\n\t\t\t\t\u0026\u0026 this.getJour() == autre.getJour();\n\t}\n\n\t/** Déterminer si cette date est égale à un autre objet.\n\t * Ceci est une redéfinition de la méthode définie dans Object\n\t * @param objet l'autre objet\n\t * @return cette date est égale à l'autre objet\n\t */\n\t//@ pure\n\tpublic boolean equals(/*@ nullable @*/ Object objet) {\n\t\treturn objet != null\n\t\t\t\t\u0026\u0026 (objet instanceof Date)\n\t\t\t\t// XXX on pourrait faire aussi objet.getClass() == this.getClass()\n\t\t\t\t\u0026\u0026 equals((Date) objet);\n\t}\n\n}\n// vi: sw=4 ts=4\n",
        "name": "Date.java",
        "path": "1A/S6/TOB/TPs/TP07/Date.java",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT/-/blob/1A/S6/TOB/TPs/TP07/Date.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 51,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires Date.estValide(j, m, a);"
        },
        {
          "limitHit": false,
          "lineNumber": 52,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getJour() == j;"
        },
        {
          "limitHit": false,
          "lineNumber": 53,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getMois() == m;"
        },
        {
          "limitHit": false,
          "lineNumber": 54,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getAnnee() == a;"
        },
        {
          "limitHit": false,
          "lineNumber": 66,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires Date.estAnneeValide(a);"
        },
        {
          "limitHit": false,
          "lineNumber": 67,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires Date.estQuantiemeValide(q, a);"
        },
        {
          "limitHit": false,
          "lineNumber": 68,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getQuantieme() == q;"
        },
        {
          "limitHit": false,
          "lineNumber": 69,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getAnnee() == a;"
        },
        {
          "limitHit": false,
          "lineNumber": 83,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires Date.estValide(j, m, a);"
        },
        {
          "limitHit": false,
          "lineNumber": 84,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures this.jour == j;"
        },
        {
          "limitHit": false,
          "lineNumber": 85,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures this.mois == m;"
        },
        {
          "limitHit": false,
          "lineNumber": 86,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures this.annee == a;"
        },
        {
          "limitHit": false,
          "lineNumber": 100,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires Date.estValide(j, m, a);"
        },
        {
          "limitHit": false,
          "lineNumber": 101,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getJour() == j;"
        },
        {
          "limitHit": false,
          "lineNumber": 102,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getMois() == m;"
        },
        {
          "limitHit": false,
          "lineNumber": 103,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getAnnee() == a;"
        },
        {
          "limitHit": false,
          "lineNumber": 113,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires Date.estAnneeValide(a);"
        },
        {
          "limitHit": false,
          "lineNumber": 114,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires Date.estQuantiemeValide(q, a);"
        },
        {
          "limitHit": false,
          "lineNumber": 115,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getQuantieme() == q;"
        },
        {
          "limitHit": false,
          "lineNumber": 116,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getAnnee() == a;"
        },
        {
          "limitHit": false,
          "lineNumber": 138,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires Date.estAnneeValide(a);"
        },
        {
          "limitHit": false,
          "lineNumber": 139,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires Date.estQuantiemeValide(q, a);"
        },
        {
          "limitHit": false,
          "lineNumber": 140,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getQuantieme() == q;"
        },
        {
          "limitHit": false,
          "lineNumber": 141,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getAnnee() == a;"
        },
        {
          "limitHit": false,
          "lineNumber": 256,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires Date.estAnneeValide(a);"
        },
        {
          "limitHit": false,
          "lineNumber": 257,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires Date.estMoisValide(m);"
        },
        {
          "limitHit": false,
          "lineNumber": 266,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result \u003c==\u003e (1 \u003c= m \u0026\u0026 m \u003c= 12);"
        },
        {
          "limitHit": false,
          "lineNumber": 291,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result \u003c==\u003e a \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 341,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result == ! lt(autre);"
        },
        {
          "limitHit": false,
          "lineNumber": 351,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result == autre.lt(this);"
        },
        {
          "limitHit": false,
          "lineNumber": 362,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result == !autre.lt(this);"
        },
        {
          "limitHit": false,
          "lineNumber": 375,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result == (le(autre) \u0026\u0026 ge(autre));"
        }
      ],
      "repository": {
        "name": "github.com/MOUDDENEHamza/ENSEEIHT",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23074e1f35de3e26a17ea425a53e1ec74722f1ed"
        },
        "content": "package TP08;\n\n/**L'implantation de la classe Cellule\n * @author Hamza MOUDDENE\n */\n\npublic class Cellule\u003cT extends Comparable\u003cT\u003e\u003e {\n\n\t// Valeur de la cellule\n\tprivate T valeur;\n\n\t// Cellule suivante\n\tprivate Cellule\u003cT\u003e suiv;\n\n\t/** Constructeur de la classe Cellule\n\t */\n\tpublic Cellule(T valeur, Cellule\u003cT\u003e suiv) {\n\t\tthis.valeur = valeur;\n\t\tthis.suiv = suiv;\n\t}\n\n\t/**Obtenir la valeur de la cellule\n\t * @return T : la valeur de la celule\n\t */\n\tpublic T getValeur() {\n\t\treturn this.valeur;\n\t}\n\n\t/**Obtenir la cellule suivante\n\t * @return Cellule : la celule suivante\n\t */\n\t//@ requires this.suiv != null;\n\tpublic Cellule\u003cT\u003e getSuiv() {\n\t\treturn this.suiv;\n\t}\n\n\t/**Changer la valeur de la cellule\n\t * @param valeur : la valeur qu'on souhaite mettre dans la celule\n\t */\n\tpublic void setValeur(T valeur) {\n\t\tthis.valeur = valeur;\n\t}\n\n\t/**Changer la cellule suivante\n\t * @param Cellule : la valeur de la celule\n\t */\n\tpublic void setSuiv(Cellule\u003cT\u003e suiv) {\n\t\tthis.suiv = suiv;\n\t}\n\n}\n",
        "name": "Cellule.java",
        "path": "1A/S6/TOB/TPs/TP08/Cellule.java",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT/-/blob/1A/S6/TOB/TPs/TP08/Cellule.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires this.suiv != null;"
        }
      ],
      "repository": {
        "name": "github.com/MOUDDENEHamza/ENSEEIHT",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23074e1f35de3e26a17ea425a53e1ec74722f1ed"
        },
        "content": "package TP08;\n\npublic interface Ensemble\u003cT extends Comparable\u003cT\u003e\u003e {\n\t//@ public invariant estVide() \u003c==\u003e cardinal() == 0;\n\t\t//@ public invariant 0 \u003c= cardinal();\n\n\t\t/** Obtenir le nombre d'éléments dans l'ensemble.\n\t\t * @return nombre d'éléments dans l'ensemble.  */\n\t\t/*@ pure helper @*/ int cardinal();\n\n\t\t/** Savoir si l'ensemble est vide.\n\t\t * @return Est-ce que l'ensemble est vide ? */\n\t\t/*@ pure helper @*/ boolean estVide();\n\n\t\t/** Savoir si un élément est présent dans l'ensemble.\n\t\t * @param x l'élément cherché\n\t\t * @return x est dans l'ensemble */\n\t\t/*@ pure helper @*/ boolean contient(T x);\n\n\t\t/** Ajouter un élément dans l'ensemble.\n\t\t * @param x l'élément à ajouter */\n\t\t//@ ensures contient(x);        // élément ajouté\n\t\tvoid ajouter(T x);\n\n\t\t/** Enlever un élément de l'ensemble.\n\t\t  * @param x l'élément à supprimer */\n\t\t//@ ensures ! contient(x);      // élément supprimé\n\t\tvoid supprimer(T x);\n\n}\n",
        "name": "Ensemble.java",
        "path": "1A/S6/TOB/TPs/TP08/Ensemble.java",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT/-/blob/1A/S6/TOB/TPs/TP08/Ensemble.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures contient(x);        // élément ajouté"
        },
        {
          "limitHit": false,
          "lineNumber": 26,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures ! contient(x);      // élément supprimé"
        }
      ],
      "repository": {
        "name": "github.com/MOUDDENEHamza/ENSEEIHT",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23074e1f35de3e26a17ea425a53e1ec74722f1ed"
        },
        "content": "package menu;\n\nimport java.util.*;\nimport util.Console;\nimport menu.commande.*;\n\n/** Définition de menus textuels avec les entrées non\n  * sélectionnables désactivées.\n  * @author\tXavier Crégut (cregut@enseeiht.fr)\n  * @version\t1.9\n  */\npublic class Menu  {\n\n\t//@ public invariant 0 \u003c= getNbEntrees();\n\n\t//@ private invariant titre != null;\n\t//@ private invariant selection != CMD_QUITTER \u0026\u0026 selection != null ==\u003e\n\t//@ \t(\\exists int i; i \u003e= 0 \u0026\u0026 i \u003c= getNbEntrees();\n\t//@\t\t\tselection == getEntree(i).getCommande());\n\t//@ private invariant estQuitte() ==\u003e selection == CMD_QUITTER;\n\t//@ private invariant getNbEntrees() == entrees.size();\n\t//@ private invariant entreeQuitter != null;\n\n\tprivate String titre;\t// Le titre\n\tprivate List\u003cEntree\u003e entrees;\t// Les entrées du menu\n\tstatic final private Commande CMD_QUITTER = new CommandeNOP();\n\tstatic final private Entree entreeQuitter = new Entree(\"Quitter\", CMD_QUITTER);\n\tprivate Commande selection;\t// Commande sélectionnée\n\tprivate boolean estQuitte;\t// le menu a-t-il  été quitté ?\n\n\t/** Construire un menu vide (sans entrées).\n\t * @param sonTitre le titre du menu\n\t */\n\t//@ requires sonTitre != null;\t// le titre existe\n\t//@ ensures getNbEntrees() == 0;\t// le menu est vide\n\t//@ ensures estQuitte() == false;\t// pas encore quitter !\n\tpublic Menu(String sonTitre) {\n\t\tthis.entrees = new ArrayList\u003cEntree\u003e();\n\t\tthis.titre = sonTitre;\n\t\tthis.selection = null;\n\t\tthis.estQuitte = false;\n\t}\n\n\t/** le nombre d'entrées du menu.  */\n\tpublic /*@ pure @*/ int getNbEntrees() {\n\t\treturn this.entrees.size();\n\t}\n\n\t/** Obtenir une entrée du menu.\n\t  * @param i position de l'entrée\n\t  * @retrun l'entrée correspondant à i\n\t  */\n\t//@ requires  0 \u003c= i \u0026\u0026 i \u003c= getNbEntrees();\n\tprivate /*@ pure @*/ Entree getEntree(int i) {\n\t\tif (i \u003e 0) {\n\t\t\treturn this.entrees.get(i-1);\n\t\t} else {\n\t\t\treturn entreeQuitter;\n\t\t}\n\t}\n\n\tpublic /*@ pure @*/ boolean estQuitte() {\n\t\treturn this.estQuitte;\n\t}\n\n\t/** Ajouter une entrée dans le menu.\n\t * @param texte l'intitulé dans le menu\n\t * @param cmd la commande associée\n\t */\n\t//@ requires texte != null \u0026\u0026 texte.length() \u003e 0; // texte défini\n\t//@ requires cmd != null;\t\t// commande définie\n\tpublic void ajouter(String texte, Commande cmd) {\n\t\tthis.entrees.add(new Entree(texte, cmd));\n\t}\n\n\t/** Tracer une séparation du menu. */\n\tprivate static void tracerSeparation() {\n\t\tString separation =\n\t\t\t\t\"----------------------------------------------------\";\n\t\tSystem.out.println(separation);\n\t}\n\n\t/** Afficher le menu.  Les numéros des commandes non\n\t  * exécutables ne sont pas affichés.\n\t  */\n\tpublic /*@ pure @*/ void afficher() {\n\t\t// Afficher le titre du menu\n\t\ttracerSeparation();\n\t\tSystem.out.println(titre);\n\t\ttracerSeparation();\n\n\t\t// Afficher les entrées de l'utilisateur\n\t\tfor (int i = 1; i \u003c= this.getNbEntrees(); i++) {\n\t\t\tthis.getEntree(i).afficher(i);\n\t\t}\n\n\t\t// Afficher la possibilité de quitter\n\t\tthis.getEntree(0).afficher(0);\n\n\t\t// Dessiner la fin du menu\n\t\ttracerSeparation();\n\t}\n\n\t/** Saisir le choix de l'utilisateur.  Le choix correspond à\n\t * une entrée du menu (y compris 0 pour quitter).\n\t * L'utilisateur peut sélectionner une entrée dont la\n\t * commande associée n'est pas exécutable.\n\t */\n\t//@ ensures ! estQuitte();\n\tpublic void selectionner() {\n\t\t// Choisir une entrée\n\t\tthis.estQuitte = false;\n\t\tint choix;\n\t\tboolean choix_valide = false;\n\t\tdo {\n\t\t\tchoix = Console.readInt(\"Votre choix : \");\n\t\t\tchoix_valide = 0 \u003c= choix\n\t\t\t\t\t\t\t\u0026\u0026 choix \u003c= this.getNbEntrees();\n\t\t\tif (!choix_valide) {\n\t\t\t\tSystem.out.println(\"Le numéro doit être compris entre \"\n\t\t\t\t\t\t+ 0 + \" et \"\n\t\t\t\t\t\t+ this.getNbEntrees() + \" !\");\n\t\t\t}\n\t\t} while (!choix_valide);\n\n\t\tthis.selection = this.getEntree(choix).getCommande();\n\t}\n\n\t/** Valider la sélection.  Ceci consiste à exécuter la\n\t * commande associée à l'entrée sélectionnée.  Si l'entrée\n\t * sélectionnée est non exécutable, un message d'erreur est\n\t * signalé.\n\t */\n\tpublic void valider() {\n\t\tif (this.selection == CMD_QUITTER) {\n\t\t\tthis.estQuitte = true;\n\t\t} else {\n\t\t\tif (this.selection.estExecutable ()) {\n\t\t\t\tthis.selection.executer();\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"Opération non réalisable !\");\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
        "name": "Menu.java",
        "path": "1A/S6/TOB/TPs/TP10/menu/Menu.java",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT/-/blob/1A/S6/TOB/TPs/TP10/menu/Menu.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 33,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires sonTitre != null;\t// le titre existe"
        },
        {
          "limitHit": false,
          "lineNumber": 34,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getNbEntrees() == 0;\t// le menu est vide"
        },
        {
          "limitHit": false,
          "lineNumber": 35,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures estQuitte() == false;\t// pas encore quitter !"
        },
        {
          "limitHit": false,
          "lineNumber": 69,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires texte != null \u0026\u0026 texte.length() \u003e 0; // texte défini"
        },
        {
          "limitHit": false,
          "lineNumber": 70,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires cmd != null;\t\t// commande définie"
        },
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures ! estQuitte();"
        },
        {
          "limitHit": false,
          "lineNumber": 52,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires  0 \u003c= i \u0026\u0026 i \u003c= getNbEntrees();"
        }
      ],
      "repository": {
        "name": "github.com/MOUDDENEHamza/ENSEEIHT",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23074e1f35de3e26a17ea425a53e1ec74722f1ed"
        },
        "content": "/** Une personne est simplement définie par son nom, son prénom et son sexe qui\n *  sont les informations nécessaires pour pouvoir la construire.\n */\npublic class Personne {\n\n\t//@ public invariant\t// prénom défini\n\t//@\t\tgetPrenom() != null \u0026\u0026 getPrenom().length() \u003e 0;\n\t//@ public invariant \t// nom défini\n\t//@\t\tgetNom() != null \u0026\u0026 getNom().length() \u003e 0;\n\n\t/** le nom */\n\tprivate String nom;\n\t/** le prénom */\n\tprivate String prenom;\n\t/** est-ce un homme ? */\n\tprivate boolean masculin;\n\n\t/** Construire une personne à partir de nom, son prénom et son sexe.\n\t * @param prenom_ le prénom de la personne\n\t * @param nom_ le nom de la personne\n\t * @param masculin_ est-ce un homme ?\n\t */\n\t//@ requires nom != null \u0026\u0026 nom.length() \u003e 0;\t// nom défini\n\t//@ requires prenom != null \u0026\u0026 prenom.length() \u003e 0;\t// prénom défini\n\t//@\n\t//@ ensures getPrenom() == prenom;\n\t//@ ensures getNom() == nom;\n\t//@ ensures masculin ==\u003e estHomme();\n\t//@ ensures !masculin ==\u003e estFemme();\n\tpublic Personne(String prenom, String nom, boolean masculin) {\n\t\tthis.nom = nom;\n\t\tthis.prenom = prenom;\n\t\tthis.masculin = masculin;\n\t}\n\n\t/** Le nom de la personne.\n\t * @return le nom de la personne\n\t */\n\t/*@ pure @*/ public String getNom() {\n\t\treturn this.nom;\n\t}\n\n\t/** Le prénom de la personne.\n\t * @return le prénom de la personne\n\t */\n\t/*@ pure @*/ public String getPrenom() {\n\t\treturn this.prenom;\n\t}\n\n\t/** La personne est-elle un homme ?\n\t * @return la personne est-elle un homme ?\n\t */\n\t/*@ pure @*/ public boolean estHomme() {\n\t\treturn this.masculin;\n\t}\n\n\t/** La personne est-elle une femme ?\n\t * @return la personne est-elle une femme ?\n\t */\n\t/*@ pure @*/ public boolean estFemme() {\n\t\treturn ! this.estHomme();\n\t}\n\n\t/** Afficher le nom et le prénom.  */\n\tpublic void afficher() {\n\t\tSystem.out.print(this);\n\t}\n\n\t/*@ pure @*/ public String toString() {\n\t\treturn (this.masculin ? \"M.\" : \"Mme\")\n\t\t\t+ ' ' + this.prenom + ' ' + this.nom;\n\t}\n\n}\n",
        "name": "Personne.java",
        "path": "2A/S8/PAT/TP4/comptes/Personne.java",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT/-/blob/2A/S8/PAT/TP4/comptes/Personne.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 22,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires nom != null \u0026\u0026 nom.length() \u003e 0;\t// nom défini"
        },
        {
          "limitHit": false,
          "lineNumber": 23,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires prenom != null \u0026\u0026 prenom.length() \u003e 0;\t// prénom défini"
        },
        {
          "limitHit": false,
          "lineNumber": 25,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getPrenom() == prenom;"
        },
        {
          "limitHit": false,
          "lineNumber": 26,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getNom() == nom;"
        },
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures masculin ==\u003e estHomme();"
        },
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures !masculin ==\u003e estFemme();"
        }
      ],
      "repository": {
        "name": "github.com/MOUDDENEHamza/ENSEEIHT",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23074e1f35de3e26a17ea425a53e1ec74722f1ed"
        },
        "content": "package menu;\n\n// À NOTER : La classe n'est pas déclarée « public » car elle n'a\n// pas à être utilisée à l'extérieur du paquetage.  Plus\n// précisément, elle n'est utilisée que par la classe Menu.  À ce\n// titre, il aurait été possible d'en faire une classe interne à\n// la classe Menu.  Elle aurait alors été déclarée \u003c\u003c static \u003e\u003e.\n\n/** Définition d'une entrée de Menu.\n * @author\tXavier Crégut\n * @version\t1.6\n */\nclass Entree {\n\n\t/** L'intitulé de l'entrée. */\n\tprivate String intitule;\n\n\t/** La commande associée à l'entrée. */\n\tprivate Commande commande;\n\n\t/** Construire une entrée à partir d'un intitulé et d'une commande.\n\t * @param unIntitule l'intitulé de l'entrée\n\t * @param uneCommande l'intitulé de la commande\n\t */\n\t//@ requires uneCommande != null;\t// la commande existe\n\t//@ requires unIntitule != null \u0026\u0026 unIntitule.length() \u003e 0;\n\t//@\t\t\t\t\t// l'intitulé existe\n\t//@ ensures getIntitule() == unIntitule;\n\t//@ ensures getCommande() == uneCommande;\n\tpublic Entree(String unIntitule, Commande uneCommande) {\n\t\tintitule = unIntitule;\n\t\tcommande = uneCommande;\n\t}\n\n\t/** L'intitulé de l'entrée. */\n\tpublic /*@ pure @*/ String getIntitule() {\n\t\treturn intitule;\n\t}\n\n\t/** La commande associée à l'entrée. */\n\tpublic /*@ pure @*/ Commande getCommande() {\n\t\treturn commande;\n\t}\n\n\t/** Afficher l'entrée.\n\t * @param numero le numéro de l'entrée dans le menu\n\t */\n\tpublic /*@ pure @*/ void afficher(int numero) {\n\t\tif (commande.estExecutable()) {\n\t\t\tString num = \"\" + numero;\n\t\t\tif (num.length() \u003c 2) {\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t}\n\t\t\tSystem.out.print(num);\n\t\t} else {\n\t\t\tSystem.out.print(\" -\");\n\t\t}\n\t\tSystem.out.print(\") \");\n\t\tSystem.out.print(getIntitule());\n\t\tSystem.out.println();\n\t}\n\n}\n",
        "name": "Entree.java",
        "path": "1A/S6/TOB/TPs/TP10/menu/Entree.java",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT/-/blob/1A/S6/TOB/TPs/TP10/menu/Entree.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 24,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires uneCommande != null;\t// la commande existe"
        },
        {
          "limitHit": false,
          "lineNumber": 25,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires unIntitule != null \u0026\u0026 unIntitule.length() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getIntitule() == unIntitule;"
        },
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getCommande() == uneCommande;"
        }
      ],
      "repository": {
        "name": "github.com/MOUDDENEHamza/ENSEEIHT",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23074e1f35de3e26a17ea425a53e1ec74722f1ed"
        },
        "content": "package editeur;\n\n/** Spécification d'une ligne de texte.\n  * @author\tXavier Crégut (cregut@enseeiht.fr)\n  * @version\t1.5\n  */\npublic interface Ligne {\n\t//@ public invariant 0 \u003c= getLongueur();\t// La longueur est positive\n\t//@\n\t//@ // Le curseur est toujours sur un caractère sauf si la ligne est vide.\n\t//@ public invariant 0 \u003c= getCurseur()  \u0026\u0026 getCurseur() \u003c= getLongueur();\n\t//@ public invariant getCurseur() == 0 \u003c==\u003e getLongueur() == 0;\n\n\t/** nombre de caractères dans la ligne */\n\t/*@ pure @*/ int getLongueur();\n\n\t/** Position du curseur sur la ligne */\n\t/*@ pure @*/ int getCurseur();\n\n\t/** le ième caractère de la ligne\n\t * @param i l'indice du caractère\n\t * @return le ième caractère de la ligne\n\t */\n\t//@ requires 1 \u003c= i \u0026\u0026 i \u003c= getLongueur();\t// indice valide\n\t/*@ pure @*/ char ieme(int i);\n\n\t/** Le caractère sous le curseur\n\t */\n\t//@ requires getLongueur() \u003e 0;\t// la ligne est non vide\n\t/*@ pure @*/ char getCourant();\n\n\t/** Avancer le curseur d'une position à droite.  */\n\t//@ requires getCurseur() \u003c getLongueur();\t\t// pas à la fin\n\t//@ ensures getCurseur() == \\old(getCurseur()) + 1;\t// curseur avancé\n\tvoid avancer();\n\n\t/** Avancer le curseur d'une position à gauche. */\n\t//@ requires getCurseur() \u003e 1;\t\t\t// pas en début de ligne\n\t//@ ensures getCurseur() == \\old(getCurseur()) - 1;\t// curseur reculé\n\tvoid reculer();\n\n\t/** Placer le curseur sur le premier caractère.  */\n\t//@ requires getLongueur() \u003e 0;\t// ligne non vide\n\t//@ ensures getCurseur() == 1;\t// curseur sur la première position\n\tvoid raz();\n\n\t/** Remplacer le caractère sous le curseur par le caractère c. */\n\t//@ requires getLongueur() \u003e 0;\n\t//@ ensures getCourant() == c;\n\tvoid remplacer(char c);\n\n\t/** Supprimer le caractère sous le curseur.  La position du curseur reste\n\t * inchangée.\n\t */\n\t//@ requires getLongueur() \u003e 0;\n\t//@ ensures getLongueur() == \\old(getLongueur()) - 1; // un caractère ôté\n\t//@ ensures getCurseur() == Math.min(\\old(getCurseur()), getLongueur());\n\tvoid supprimer();\n\n\t/** Ajouter le caractère c avant le curseur.\n\t * Le curseur reste sur le même caractère.\n\t */\n\t//@ requires getLongueur() \u003e 0;\t\t// curseur positionné\n\t//@ \n\t//@ ensures getLongueur() == \\old(getLongueur()) + 1; // un caractère ajouté\n\t//@ ensures getCurseur() == \\old(getCurseur()) + 1;   // curseur inchangé\n\t//@ ensures getCourant() == \\old(getCourant());\n\tvoid ajouterAvant(char c);\n\n\t/** Ajouter le caractère c après le curseur.\n\t * Le curseur reste sur le même caractère.\n\t */\n\t//@ requires getLongueur() \u003e 0;\t\t// curseur positionné\n\t//@ ensures getLongueur() == \\old(getLongueur()) + 1;   // caractère ajouté\n\t//@ ensures getCurseur() == \\old(getCurseur());\t    // curseur inchangé\n\t//@ ensures getCourant() == \\old(getCourant());\n\tvoid ajouterApres(char c);\n\n\t/** Afficher la ligne en mettant entre crochets [] le caractère courant.\n\t * Si la ligne est vide, un seul caractère tilde(~) est affiché.\n\t */\n\t/*@ pure @*/ void afficher();\n\n\t/** Ajouter le caractère c à la fin de la ligne.\n\t * Le curseur reste sur le même caractère.\n\t */\n\t//@ ensures getLongueur() == \\old(getLongueur()) + 1;    // caractère ajouté\n\t//@ ensures ieme(getLongueur()) == c;\t\t     // à la fin\n\t//@ ensures (\\forall int i; 1 \u003c= i \u0026\u0026 i \u003c= \\old(getLongueur());\n\t//@\t\t\t\t\t\tieme(i) == \\old(ieme(i)));\n\t//@ ensures getLongueur() \u003e 1 ==\u003e getCourant() == \\old(getCourant());\n\t//@ ensures getCurseur() == Math.max(1, \\old(getCurseur()));\n\tvoid ajouterFin(char c);\n\n\t/** Ajouter le caractère c au début de la ligne\n\t * Le curseur reste sur le même caractère.\n\t */\n\t//@ ensures getLongueur() == \\old(getLongueur()) + 1;   // caractère ajouté\n\t//@ ensures ieme(1) == c;\t\t\t\t// en première position\n\t//@  ensures (\\forall int j; j \u003e= 2 \u0026\u0026 j \u003c= getLongueur();\n\t//@\t\t\t\t\tieme((int)j) == \\old(ieme((int)(j-1))));\n\t//@ ensures getLongueur() \u003e 1 ==\u003e getCourant() == \\old(getCourant());\n\t//@ ensures getCurseur() == \\old(getCurseur()) + 1;\n\tvoid ajouterDebut(char c);\n\n\t/** supprimer le premier caractère de la ligne.  Le curseur reste sur le\n\t * même caractère.\n\t */\n\t//@ requires getLongueur() \u003e 0;\n\t//@ ensures getLongueur() == \\old(getLongueur()) - 1;\n\t//@ ensures \\old(getCurseur()) != 1 ==\u003e getCourant() == \\old(getCourant());\n\t//@ ensures getCurseur()\n\t//@\t\t== Math.min(Math.max((int)(\\old(getCurseur())-1), 1), getLongueur());\n\tvoid supprimerPremier();\n\n\t/** supprimer le dernier caractère de la ligne. Le curseur reste sur le même\n\t  * caractère.\n\t  */\n\t//@ requires getLongueur() \u003e 0;\n\t//@ ensures getLongueur() == \\old(getLongueur()) - 1;\n\t//@ ensures \\old(getCurseur()) \u003c \\old(getLongueur())\n\t//@\t\t\t\t==\u003e getCourant() == \\old(getCourant());\n\t//@ ensures getCurseur() == Math.min(\\old(getCurseur()), getLongueur());\n\tvoid supprimerDernier();\n\n}\n",
        "name": "Ligne.java",
        "path": "1A/S6/TOB/TPs/TP10/editeur/Ligne.java",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT/-/blob/1A/S6/TOB/TPs/TP10/editeur/Ligne.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 23,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 1 \u003c= i \u0026\u0026 i \u003c= getLongueur();\t// indice valide"
        },
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires getLongueur() \u003e 0;\t// la ligne est non vide"
        },
        {
          "limitHit": false,
          "lineNumber": 32,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires getCurseur() \u003c getLongueur();\t\t// pas à la fin"
        },
        {
          "limitHit": false,
          "lineNumber": 33,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getCurseur() == \\old(getCurseur()) + 1;\t// curseur avancé"
        },
        {
          "limitHit": false,
          "lineNumber": 37,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires getCurseur() \u003e 1;\t\t\t// pas en début de ligne"
        },
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getCurseur() == \\old(getCurseur()) - 1;\t// curseur reculé"
        },
        {
          "limitHit": false,
          "lineNumber": 42,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires getLongueur() \u003e 0;\t// ligne non vide"
        },
        {
          "limitHit": false,
          "lineNumber": 43,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getCurseur() == 1;\t// curseur sur la première position"
        },
        {
          "limitHit": false,
          "lineNumber": 47,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires getLongueur() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 48,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getCourant() == c;"
        },
        {
          "limitHit": false,
          "lineNumber": 54,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires getLongueur() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 55,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getLongueur() == \\old(getLongueur()) - 1; // un caractère ôté"
        },
        {
          "limitHit": false,
          "lineNumber": 56,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getCurseur() == Math.min(\\old(getCurseur()), getLongueur());"
        },
        {
          "limitHit": false,
          "lineNumber": 62,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires getLongueur() \u003e 0;\t\t// curseur positionné"
        },
        {
          "limitHit": false,
          "lineNumber": 64,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getLongueur() == \\old(getLongueur()) + 1; // un caractère ajouté"
        },
        {
          "limitHit": false,
          "lineNumber": 65,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getCurseur() == \\old(getCurseur()) + 1;   // curseur inchangé"
        },
        {
          "limitHit": false,
          "lineNumber": 66,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getCourant() == \\old(getCourant());"
        },
        {
          "limitHit": false,
          "lineNumber": 72,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires getLongueur() \u003e 0;\t\t// curseur positionné"
        },
        {
          "limitHit": false,
          "lineNumber": 73,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getLongueur() == \\old(getLongueur()) + 1;   // caractère ajouté"
        },
        {
          "limitHit": false,
          "lineNumber": 74,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getCurseur() == \\old(getCurseur());\t    // curseur inchangé"
        },
        {
          "limitHit": false,
          "lineNumber": 75,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getCourant() == \\old(getCourant());"
        },
        {
          "limitHit": false,
          "lineNumber": 86,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getLongueur() == \\old(getLongueur()) + 1;    // caractère ajouté"
        },
        {
          "limitHit": false,
          "lineNumber": 87,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures ieme(getLongueur()) == c;\t\t     // à la fin"
        },
        {
          "limitHit": false,
          "lineNumber": 88,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures (\\forall int i; 1 \u003c= i \u0026\u0026 i \u003c= \\old(getLongueur());"
        },
        {
          "limitHit": false,
          "lineNumber": 90,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getLongueur() \u003e 1 ==\u003e getCourant() == \\old(getCourant());"
        },
        {
          "limitHit": false,
          "lineNumber": 91,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getCurseur() == Math.max(1, \\old(getCurseur()));"
        },
        {
          "limitHit": false,
          "lineNumber": 97,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getLongueur() == \\old(getLongueur()) + 1;   // caractère ajouté"
        },
        {
          "limitHit": false,
          "lineNumber": 98,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures ieme(1) == c;\t\t\t\t// en première position"
        },
        {
          "limitHit": false,
          "lineNumber": 101,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getLongueur() \u003e 1 ==\u003e getCourant() == \\old(getCourant());"
        },
        {
          "limitHit": false,
          "lineNumber": 102,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getCurseur() == \\old(getCurseur()) + 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires getLongueur() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 109,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getLongueur() == \\old(getLongueur()) - 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 110,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\old(getCurseur()) != 1 ==\u003e getCourant() == \\old(getCourant());"
        },
        {
          "limitHit": false,
          "lineNumber": 111,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getCurseur()"
        },
        {
          "limitHit": false,
          "lineNumber": 118,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires getLongueur() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 119,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getLongueur() == \\old(getLongueur()) - 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 120,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\old(getCurseur()) \u003c \\old(getLongueur())"
        },
        {
          "limitHit": false,
          "lineNumber": 122,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getCurseur() == Math.min(\\old(getCurseur()), getLongueur());"
        }
      ],
      "repository": {
        "name": "github.com/MOUDDENEHamza/ENSEEIHT",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23074e1f35de3e26a17ea425a53e1ec74722f1ed"
        },
        "content": "import java.util.ArrayList;\n\n/**\n * Historique gère un historique chronologique des réels enregistrés.\n * L'historique est non borné (utilisation d'une ArrayList), sauf par\n * rapport à la quantité de mémoire disponible (OutOfMemoryException) !\n */\npublic class Historique {\n\n\tprivate ArrayList\u003cDouble\u003e valeurs;\t// les valeurs enregistrées\n\n\t/** Construire un historique vide.  */\n\t//@ ensures getNbValeurs() == 0;\t// historique vide\n\tpublic Historique() {\n\t\tthis.valeurs = new ArrayList\u003cDouble\u003e();\n\t}\n\n\t/** Enregistrer une nouvelle information dans l'historique\n\t * @param info l'information à enregistrer dans l'historique\n\t */\n\t//@ ensures getNbValeurs() == \\old(getNbValeurs()) + 1;\t// entier enregistré\n\t//@ ensures getValeur(getNbValeurs()) == info;\t// n ajouté en fin d'historique\n\tpublic void enregistrer(double info) {\n\t\tthis.valeurs.add(info);\n\t}\n\n\t/** La i\u003cSUP\u003eè\u003c/SUP\u003e valeur de l'historique, 1 correspond à la plus\n\t * ancienne, getNbValeurs() à la plus récente (la dernière).\n\t *\n\t * \u003cb\u003eAttention :\u003c/b\u003e Cette convention est différente de celle\n\t * traditionnellement adoptée en Java pour les tableaux et vecteurs !\n\t * @param i indice de l'opération compris en 1 et getNbValeurs().\n\t */\n\t//@ requires 1 \u003c= i \u0026\u0026 i \u003c= getNbValeurs();\t// indice correct\n\tpublic /*@ pure @*/ double getValeur(int i) {\n\t\treturn this.valeurs.get(i-1);\n\t}\n\n\t/** Le nombre d'entiers enregistrés dans l'historique\n\t * @return le nombre d'entiers dans l'historique\n\t */\n\t//@ ensures getNbValeurs() \u003e= 0;\t// nb positif de valeurs\n\tpublic /*@ pure @*/ int getNbValeurs() {\n\t\treturn this.valeurs.size();\n\t}\n\n\tpublic String toString() {\n\t\treturn this.valeurs.toString();\n\t}\n}\n",
        "name": "Historique.java",
        "path": "2A/S8/PAT/TP4/comptes/Historique.java",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT/-/blob/2A/S8/PAT/TP4/comptes/Historique.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getNbValeurs() == 0;\t// historique vide"
        },
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getNbValeurs() == \\old(getNbValeurs()) + 1;\t// entier enregistré"
        },
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getValeur(getNbValeurs()) == info;\t// n ajouté en fin d'historique"
        },
        {
          "limitHit": false,
          "lineNumber": 33,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 1 \u003c= i \u0026\u0026 i \u003c= getNbValeurs();\t// indice correct"
        },
        {
          "limitHit": false,
          "lineNumber": 41,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getNbValeurs() \u003e= 0;\t// nb positif de valeurs"
        }
      ],
      "repository": {
        "name": "github.com/MOUDDENEHamza/ENSEEIHT",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23074e1f35de3e26a17ea425a53e1ec74722f1ed"
        },
        "content": "/** CompteSimple modélise un compte bancaire simple tenu en euros.\n * Il est caractérisé par un titulaire et un solde (positif ou négatif)\n * et peut être crédité ou débité d'un certain montant.\n * @author\tXavier Crégut\n */\npublic class CompteSimple {\n\t//@ public invariant getTitulaire() != null;\n\t//@ private invariant titulaire == getTitulaire();\n\t//@ private invariant solde == getSolde();\n\n\t/** Titulaire du compte. */\n\tprivate Personne titulaire;\n\n\t/** Solde du compte exprimé en euros. */\n\tprivate double solde;\n\n/* attributs-numero START DELETE */\n\t/** Numéro du compte. */\n\tprivate String numero;\n\t\t// Il est essentiel que le numéro de compte soit privé pour\n\t\t// que la classe puisse contrôler son changement et donc\n\t\t// garantir son unicité.\n\t\t//\n\t\t// Ceci se généralise à toutes les données d'une classe.\n\t\t// C'est la protection des attributs en écriture.\n\n\t/** Le dernier numéro attribué à un compte. */\n\tprivate static int dernierNumero = 10000;\n\t\t //  dernierNumero est un « attribut de classe » car il est\n\t\t //  partagé par toutes les instances (les objets) de la classe\n\t\t //  compte.  C'est lui qui permet d'affecter un numéro unique\n\t\t //  à un compte car il contient le dernier numéro utilisé.\n\n/* attributs-numero STOP DELETE */\n/* constructeur-numero START DELETE */\n\t/** Initialiser un compte.\n\t * @param titulaire le titulaire du compte\n\t * @param depotInitial le montant initial du compte\n\t */\n\t//@ requires leTitulaire != null;\t// le titulaire existe\n\t//@ requires depotInitial \u003e= 0;\t// montant initial strictement positif\n\t//@ ensures getSolde() == depotInitial;\t// solde initialisé\n\t//@ ensures getTitulaire() == leTitulaire;\t// titulaire initialisé\n\tpublic CompteSimple(Personne leTitulaire, double depotInitial) {\n\t\tthis.solde = depotInitial;\n\t\tthis.titulaire = leTitulaire;\n\t\tthis.initialiserNumero();\n\t}\n/* constructeur-numero STOP DELETE */\n\n\t/** Initialiser un compte.\n\t * Son solde est nul.\n\t * @param titulaire le titulaire du compte\n\t */\n\t//@ requires titulaire != null;\t\t// le titulaire existe\n\t//@ ensures getSolde() == 0;\t\t// pas de dépôt initial\n\t//@ ensures getTitulaire() == titulaire;\t// titulaire initialisé\n\tpublic CompteSimple(Personne titulaire) {\n\t\tthis(titulaire, 0);\n\t}\n\n\t/** Numéro du compte. */\n\tpublic String getNumero() {\n\t\treturn this.numero;\n\t}\n\n/* initialiser-numero START DELETE */\n\t/** Affecter un numéro unique au compte. */\n\tprivate void initialiserNumero() {\n\t\tdernierNumero++;\n\t\tthis.numero = String.valueOf(dernierNumero);\n\t}\n/* initialiser-numero STOP DELETE */\n\n\t/** Solde du compte exprimé en euros. */\n\tpublic /*@ pure @*/ double getSolde() {\n\t\treturn this.solde;\n\t}\n\n\t/** Titulaire du compte. */\n\tpublic /*@ pure @*/ Personne getTitulaire() {\n\t\treturn this.titulaire;\n\t}\n\n\t/** Créditer le compte du montant (exprimé en euros).\n\t * @param montant montant déposé sur le compte en euros\n\t */\n\t//@ requires montant \u003e 0;\n\t//@ ensures getSolde() == \\old(getSolde()) + montant; // montant crédité\n\tpublic void crediter(double montant) {\n\t\tthis.solde = this.solde + montant;\n\t}\n\n\t/** Débiter le compte du montant (exprimé en euros).\n\t * @param montant montant retiré du compte en euros\n\t */\n\t//@ requires montant \u003e 0;\n\t//@ ensures getSolde() == \\old(getSolde()) - montant; // montant débité\n\tpublic void debiter(double montant) {\n\t\tthis.solde = this.solde - montant;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"solde=\" + this.solde + \", titulaire=\\\"\" + this.titulaire + \"\\\"\";\n\t}\n\n}\n",
        "name": "CompteSimple.java",
        "path": "2A/S8/PAT/TP4/comptes/CompteSimple.java",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT/-/blob/2A/S8/PAT/TP4/comptes/CompteSimple.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 39,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires leTitulaire != null;\t// le titulaire existe"
        },
        {
          "limitHit": false,
          "lineNumber": 40,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires depotInitial \u003e= 0;\t// montant initial strictement positif"
        },
        {
          "limitHit": false,
          "lineNumber": 41,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getSolde() == depotInitial;\t// solde initialisé"
        },
        {
          "limitHit": false,
          "lineNumber": 42,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getTitulaire() == leTitulaire;\t// titulaire initialisé"
        },
        {
          "limitHit": false,
          "lineNumber": 54,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires titulaire != null;\t\t// le titulaire existe"
        },
        {
          "limitHit": false,
          "lineNumber": 55,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getSolde() == 0;\t\t// pas de dépôt initial"
        },
        {
          "limitHit": false,
          "lineNumber": 56,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getTitulaire() == titulaire;\t// titulaire initialisé"
        },
        {
          "limitHit": false,
          "lineNumber": 87,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires montant \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 88,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getSolde() == \\old(getSolde()) + montant; // montant crédité"
        },
        {
          "limitHit": false,
          "lineNumber": 96,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires montant \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 97,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getSolde() == \\old(getSolde()) - montant; // montant débité"
        }
      ],
      "repository": {
        "name": "github.com/MOUDDENEHamza/ENSEEIHT",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23074e1f35de3e26a17ea425a53e1ec74722f1ed"
        },
        "content": "package TP08;\n\npublic interface EnsembleOrdonne\u003cT extends Comparable\u003cT\u003e\u003e{\n\t//@ public invariant estVide() \u003c==\u003e cardinal() == 0;\n\t//@ public invariant 0 \u003c= cardinal();\n\t/** Obtenir le nombre d'éléments dans l'ensemble.\n\t * @return nombre d'éléments dans l'ensemble. */\n\t/*@ pure helper @*/ int cardinal();\n\t\n\t/** Savoir si l'ensemble est vide.\n\t * @return Est-ce que l'ensemble est vide ? */\n\t/*@ pure helper @*/ boolean estVide();\n\t/** Savoir si un élément est présent dans l'ensemble.\n\t * @param x l'élément cherché\n\t * @return x est dans l'ensemble */\n\t/*@ pure helper @*/ boolean contient(T x);\n\t\n\t/**Obtenir le plus petit element\n\t * @return T le plus petit element*/\n\t//@ requires !estVide();\n\tT petitElement();\n\t\n\t/**Obtenir le plus petit élément strictement plus grand que celui passé en \n\t * paramètre\n\t * @param x l'élement qu'on souhaite trouvé son supérieur\n\t * @return le plus petit élément strictement plus grand que x\n\t */\n\tT justePlusGrandQue(T x);\n\t\n\t/** Ajouter un élément dans l'ensemble.\n\t * @param x l'élément à ajouter */\n\t//@ ensures contient(x); // élément ajouté\n\tvoid ajouter(T x);\n\t\n\t/** Enlever un élément de l'ensemble.\n\t * @param x l'élément à supprimer */\n\t//@ ensures ! contient(x); // élément supprimé\n\tvoid supprimer(T x);\n}\n",
        "name": "EnsembleOrdonne.java",
        "path": "1A/S6/TOB/TPs/TP08/EnsembleOrdonne.java",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT/-/blob/1A/S6/TOB/TPs/TP08/EnsembleOrdonne.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 19,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires !estVide();"
        },
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures contient(x); // élément ajouté"
        },
        {
          "limitHit": false,
          "lineNumber": 36,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures ! contient(x); // élément supprimé"
        }
      ],
      "repository": {
        "name": "github.com/MOUDDENEHamza/ENSEEIHT",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23074e1f35de3e26a17ea425a53e1ec74722f1ed"
        },
        "content": "/** Un compte courant est un compte simple avec un historique des\n * opérations effectuées.\n * @author  Xavier Crégut\n */\npublic class CompteCourant extends CompteSimple {\n\n\t/** L'historique des opérations de crédit et débit réalisées. */\n\tprivate Historique operations;\n\t\n\t/** Construction d'un compte courant dont le solde est nul.\n\t * @param titulaire le titulaire du compte\n\t */\n\t//@ requires titulaire != null;\t\t// le titulaire existe\n\t//@ ensures getSolde() == 0;\t\t// pas de dépôt initial\n\t//@ ensures getTitulaire() == titulaire;\t// titulaire initialisé\n\tpublic CompteCourant(Personne titulaire) {\n\t\tthis(titulaire, 0);\n\t}\n\n\t/** Construction d'un compte courant avec un montant initial.\n\t * @param titulaire le titulaire du compte\n\t * @param depotInitial le montant initial du compte\n\t */\n\t//@ requires titulaire != null;\t// le titulaire existe\n\t//@ requires depotInitial \u003e= 0;\t// montant initial strictement positif\n\t//@ ensures getSolde() == depotInitial;\t// solde initialisé\n\t//@ ensures getTitulaire() == titulaire;\t// titulaire initialisé\n\tpublic CompteCourant(Personne titulaire, double depotInitial) {\n\t\tsuper(titulaire, depotInitial);\n\t\tthis.operations = new Historique();\n\t\tif (depotInitial \u003e 0) {\n\t\t\tthis.operations.enregistrer(depotInitial);\n\t\t}\n\t}\n\n\t/** Créditer le compte du montant (exprimé en euros). L'opération\n\t * est enregistrée.\n\t * @param montant montant déposé sur le compte en euros\n\t */\n\t@Override public void crediter(double montant) {\n\t\tsuper.crediter(montant);\n\t\tthis.operations.enregistrer(montant);\n\t}\n\n\t/** Débiter le compte du montant (exprimé en euros). L'opération\n\t * est  enregistrée.\n\t * @param montant montant retiré du compte en euros\n\t */\n\t@Override public void debiter(double montant) {\n\t\tsuper.debiter(montant);\n\t\tthis.operations.enregistrer(-montant);\n\t}\n\n\t/** Éditer le relevé du compte. */\n\tpublic void editerReleve() {\n\t\tSystem.out.println(\"----------------------------------------\");\n\n\t\t// afficher les caractéristiques du compte\n\t\tSystem.out.print(\"Titulaire : \");\n\t\tthis.getTitulaire().afficher();\n\t\tSystem.out.println();\n\n\t\t// Afficher l'historique des opérations\n\t\tSystem.out.println(\"Historique des opérations : \");\n\t\tfor (int i = 1, nb = this.operations.getNbValeurs(); i \u003c= nb; i++) {\n\t\t\tif (this.operations.getValeur(i) \u003e 0) {\n\t\t\t\tSystem.out.println(\"  o  Dépôt de \" + this.operations.getValeur(i));\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"  o  Retrait de \" + -this.operations.getValeur(i));\n\t\t\t}\n\t\t}\n\n\t\t// Afficher le solde du compte\n\t\tSystem.out.println(\"----------------------------------------\");\n\t\tSystem.out.println(\"Solde du compte : \" + getSolde());\n\t\tSystem.out.println(\"----------------------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\t@Override public String toString() {\n\t\treturn super.toString() + \", opérations=\" + this.operations;\n\t}\n\n}\n",
        "name": "CompteCourant.java",
        "path": "2A/S8/PAT/TP4/comptes/CompteCourant.java",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT/-/blob/2A/S8/PAT/TP4/comptes/CompteCourant.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires titulaire != null;\t\t// le titulaire existe"
        },
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getSolde() == 0;\t\t// pas de dépôt initial"
        },
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getTitulaire() == titulaire;\t// titulaire initialisé"
        },
        {
          "limitHit": false,
          "lineNumber": 23,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires titulaire != null;\t// le titulaire existe"
        },
        {
          "limitHit": false,
          "lineNumber": 24,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires depotInitial \u003e= 0;\t// montant initial strictement positif"
        },
        {
          "limitHit": false,
          "lineNumber": 25,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getSolde() == depotInitial;\t// solde initialisé"
        },
        {
          "limitHit": false,
          "lineNumber": 26,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getTitulaire() == titulaire;\t// titulaire initialisé"
        }
      ],
      "repository": {
        "name": "github.com/MOUDDENEHamza/ENSEEIHT",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23074e1f35de3e26a17ea425a53e1ec74722f1ed"
        },
        "content": "package editeur;\n\n/** Une ligne de texte représentée par un StringBuffer.\n  * @author\tXavier Crégut (cregut@enseeiht.fr)\n  * @version\t1.4\n  */\npublic class LigneStringBuffer implements Ligne {\n\n\t//@ private invariant this.curseur == this.getCurseur();\n\t//@ private invariant this.getLongueur() == this.caracteres.length();\n\t//@ private invariant (\\forall int i; i \u003e= 1 \u0026\u0026 i \u003c= this.getLongueur();\n\t//@\t\t\tthis.ieme(i) == this.caracteres.charAt(i-1));\n\t//@ private invariant caracteres != null;\n\n\t/** Les caractères de la ligne. */\n\tprivate StringBuffer caracteres;\n\n\t/** La position du curseur. */\n\tprivate int curseur;\n\n\t/** Créer une ligne vide.\n\t */\n\t//@ ensures getLongueur() == 0;\t// la ligne est vide\n\tpublic LigneStringBuffer() {\n\t\tcaracteres = new StringBuffer();\n\t\tcurseur = 0;\n\t}\n\n\tpublic int getLongueur() {\n\t\treturn caracteres.length();\n\t}\n\n\tpublic int getCurseur() {\n\t\treturn curseur;\n\t}\n\n\tpublic char ieme(int i) {\n\t\treturn caracteres.charAt(i-1);\n\t}\n\n\tpublic char getCourant() {\n\t\treturn ieme(curseur);\n\t}\n\n\tpublic void avancer() {\n\t\tcurseur++;\n\t}\n\n\tpublic void reculer() {\n\t\tcurseur--;\n\t}\n\n\tpublic void raz() {\n\t\tcurseur = 1;\n\t}\n\n\tpublic void remplacer(char c) {\n\t\tcaracteres.setCharAt(curseur-1, c);\n\t}\n\n\tpublic void supprimer() {\n\t\t// Supprimer le caractère\n\t\tcaracteres.deleteCharAt(curseur-1);\n\n\t\t// Mettre à jour le curseur\n\t\tif (curseur \u003e caracteres.length()) {\n\t\t\tcurseur = caracteres.length();\n\t\t}\n\t}\n\n\tpublic void ajouterAvant(char c) {\n\t\tcaracteres.insert(curseur-1, c);\n\t\tcurseur++;\n\t}\n\n\tpublic void ajouterApres(char c) {\n\t\tcaracteres.insert(curseur, c);\n\t}\n\n\tpublic void afficher() {\n\t\tif (caracteres.length() == 0) {\t// La chaîne est vide\n\t\t\tSystem.out.print(\"~\");\n\t\t} else {\n\t\t\t// Afficher les caractères avant le curseur\n\t\t\tSystem.out.print(caracteres.substring(0, curseur-1));\n\n\t\t\t// Afficher le caractère sous le curseur\n\t\t\tSystem.out.print(\"\" + '[' + ieme(curseur) + ']');\n\n\t\t\t// Afficher les caractères après le curseur\n\t\t\tSystem.out.print(caracteres.substring(curseur));\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic String toString() {\n\t\treturn \"caractères = \\\"\" + caracteres + '\"'\n\t\t\t\t\t+ \" et curseur = \" + curseur;\n\t}\n\n\tpublic void ajouterFin(char c) {\n\t\tcaracteres.append(c);\n\t\tif (curseur == 0) {\n\t\t\tcurseur = 1;\n\t\t}\n\t}\n\n\tpublic void ajouterDebut(char c) {\n\t\tcaracteres.insert(0, c);\t// Ajouter le caractère\n\t\tcurseur++;\t\t\t// Rétablir le curseur\n\t}\n\n\tpublic void supprimerPremier() {\n\t\tcaracteres.deleteCharAt(0);\n\n\t\t// Mettre à jour le curseur\n\t\tif (caracteres.length() == 0) {\n\t\t\tcurseur = 0;\n\t\t} else if (curseur \u003e 1) {\n\t\t\tcurseur--;\n\t\t}\n\t}\n\n\tpublic void supprimerDernier() {\n\t\tcaracteres.deleteCharAt(caracteres.length() - 1);\n\t\tif (curseur \u003e caracteres.length()) {\n\t\t\tcurseur--;\n\t\t}\n\t}\n\n}\n",
        "name": "LigneStringBuffer.java",
        "path": "1A/S6/TOB/TPs/TP10/editeur/LigneStringBuffer.java",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT/-/blob/1A/S6/TOB/TPs/TP10/editeur/LigneStringBuffer.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 22,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures getLongueur() == 0;\t// la ligne est vide"
        }
      ],
      "repository": {
        "name": "github.com/MOUDDENEHamza/ENSEEIHT",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23074e1f35de3e26a17ea425a53e1ec74722f1ed"
        },
        "content": "package editeur.commande;\n\nimport editeur.Ligne;\nimport menu.Commande;\n\n\n/** Une CommandeLigne est une commande qui travaille sur une\n * ligne de l'éditeur orienté ligne.\n * @author\tXavier Crégut\n * @version\t1.4\n */\nabstract public class CommandeLigne\n\timplements Commande\n{\n\t/** La ligne manipulée par la commande. */\n\tprotected Ligne ligne;\n\n\t/** Initialiser la ligne sur laquelle travaille\n\t * cette commande.\n\t * @param l la ligne\n\t */\n\t//@ requires l != null;\t// la ligne doit être définie\n\tpublic CommandeLigne(Ligne l) {\n\t\tligne = l;\n\t}\n\n}\n",
        "name": "CommandeLigne.java",
        "path": "1A/S6/TOB/TPs/TP10/editeur/commande/CommandeLigne.java",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT/-/blob/1A/S6/TOB/TPs/TP10/editeur/commande/CommandeLigne.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires l != null;\t// la ligne doit être définie"
        }
      ],
      "repository": {
        "name": "github.com/MOUDDENEHamza/ENSEEIHT",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23074e1f35de3e26a17ea425a53e1ec74722f1ed"
        },
        "content": "package editeur.commande;\n\nimport editeur.Ligne;\nimport util.Console;\n\n/** Ajouter un caractère à la fin de la ligne.\n * @author\tXavier Crégut\n * @version\t1.4\n */\npublic class CommandeAjouterFin\n\textends CommandeLigne\n{\n\n\t/** Initialiser la ligne sur laquelle travaille\n\t * cette commande.\n\t * @param l la ligne\n\t */\n\t//@ requires l != null;\t// la ligne doit être définie\n\tpublic CommandeAjouterFin(Ligne l) {\n\t\tsuper(l);\n\t}\n\n\tpublic void executer() {\n\t\tString texte = Console.readLine(\"Texte à insérer : \");\n\t\tfor (int i = 0; i \u003c texte.length(); i++) {\n\t\t\tligne.ajouterFin(texte.charAt(i));\n\t\t}\n\t}\n\n\tpublic boolean estExecutable() {\n\t\treturn true;\n\t}\n\n}\n",
        "name": "CommandeAjouterFin.java",
        "path": "1A/S6/TOB/TPs/TP10/editeur/commande/CommandeAjouterFin.java",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT/-/blob/1A/S6/TOB/TPs/TP10/editeur/commande/CommandeAjouterFin.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires l != null;\t// la ligne doit être définie"
        }
      ],
      "repository": {
        "name": "github.com/MOUDDENEHamza/ENSEEIHT",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23074e1f35de3e26a17ea425a53e1ec74722f1ed"
        },
        "content": "package editeur.commande;\n\nimport editeur.Ligne;\n\n/** Reculer le curseur d'une position.\n * @author\tXavier Crégut\n * @version\t1.4\n */\npublic class CommandeCurseurReculer\n\textends CommandeLigne\n{\n\n\t/** Initialiser la ligne sur laquelle travaille\n\t * cette commande.\n\t * @param l la ligne\n\t */\n\t//@ requires l != null;\t// la ligne doit être définie\n\tpublic CommandeCurseurReculer(Ligne l) {\n\t\tsuper(l);\n\t}\n\n\tpublic void executer() {\n\t\tligne.reculer();\n\t}\n\n\tpublic boolean estExecutable() {\n\t\treturn ligne.getCurseur() \u003e 1;\n\t}\n\n}\n",
        "name": "CommandeCurseurReculer.java",
        "path": "1A/S6/TOB/TPs/TP10/editeur/commande/CommandeCurseurReculer.java",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT/-/blob/1A/S6/TOB/TPs/TP10/editeur/commande/CommandeCurseurReculer.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires l != null;\t// la ligne doit être définie"
        }
      ],
      "repository": {
        "name": "github.com/MOUDDENEHamza/ENSEEIHT",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23074e1f35de3e26a17ea425a53e1ec74722f1ed"
        },
        "content": "package editeur.commande;\n\nimport editeur.Ligne;\n\n/** Avancer le curseur d'une position.\n * @author\tXavier Crégut\n * @version\t1.4\n */\npublic class CommandeCurseurAvancer\n\textends CommandeLigne\n{\n\n\t/** Initialiser la ligne sur laquelle travaille\n\t * cette commande.\n\t * @param l la ligne\n\t */\n\t//@ requires l != null;\t// la ligne doit être définie\n\tpublic CommandeCurseurAvancer(Ligne l) {\n\t\tsuper(l);\n\t}\n\n\tpublic void executer() {\n\t\tligne.avancer();\n\t}\n\n\tpublic boolean estExecutable() {\n\t\treturn ligne.getCurseur() \u003c ligne.getLongueur();\n\t}\n\n}\n",
        "name": "CommandeCurseurAvancer.java",
        "path": "1A/S6/TOB/TPs/TP10/editeur/commande/CommandeCurseurAvancer.java",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT/-/blob/1A/S6/TOB/TPs/TP10/editeur/commande/CommandeCurseurAvancer.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires l != null;\t// la ligne doit être définie"
        }
      ],
      "repository": {
        "name": "github.com/MOUDDENEHamza/ENSEEIHT",
        "url": "/github.com/MOUDDENEHamza/ENSEEIHT"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 127,
  "ElapsedMilliseconds": 62,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
