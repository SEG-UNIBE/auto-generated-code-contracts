{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/ralphrecto/xic lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "7dddfc855775467244a7949ee6d311dd8150f748"
        },
        "content": "/*******************************************************************************\n * This file is part of the Polyglot extensible compiler framework.\n *\n * Copyright (c) 2000-2012 Polyglot project group, Cornell University\n * Copyright (c) 2006-2012 IBM Corporation\n * All rights reserved.\n *\n * This program and the accompanying materials are made available under\n * the terms of the Eclipse Public License v1.0 which accompanies this\n * distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * This program and the accompanying materials are made available under\n * the terms of the Lesser GNU Public License v2.0 which accompanies this\n * distribution.\n *\n * The development of the Polyglot project has been supported by a\n * number of funding sources, including DARPA Contract F30602-99-1-0533,\n * monitored by USAF Rome Laboratory, ONR Grants N00014-01-1-0968 and\n * N00014-09-1-0652, NSF Grants CNS-0208642, CNS-0430161, CCF-0133302,\n * and CCF-1054172, AFRL Contract FA8650-10-C-7022, an Alfred P. Sloan\n * Research Fellowship, and an Intel Research Ph.D. Fellowship.\n *\n * See README for contributors.\n ******************************************************************************/\n\npackage polyglot.util;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * The pretty-printing algorithm is loosely based on the Modula-3\n * pretty-printer, and on notes by Greg Nelson. It was extended to support\n * breaks at multiple levels.\n *\n * OptimalCodeWriter follows the \"break from root\" rule: if a break is broken,\n * breaks of equal or lower level in all containing blocks must also be\n * broken, and breaks in the same block must also be broken if they are\n * of strictly lower level or if they are of the same level but marked as\n * \"unified\".\n */\npublic class OptimalCodeWriter extends CodeWriter {\n    /**\n     * Create a OptimalCodeWriter object with output stream {@code o}\n     * and width {@code width_}.\n     * @param o the writer to write to. Must be non-null.\n     * @param width_ the formatting width. Must be positive.\n     */\n    public OptimalCodeWriter(OutputStream o, int width_) {\n        this(new PrintWriter(new OutputStreamWriter(o)), width_);\n    }\n\n    /**\n     * Create a OptimalCodeWriter object.\n     * @param o the writer to write to. Must be non-null.\n     * @param width_ the formatting width. Must be positive.\n     */\n    public OptimalCodeWriter(PrintWriter o, int width_) {\n        output = o;\n        width = width_;\n        current = input = new BlockItem(0);\n        if (OptimalCodeWriter.showInput) {\n            trace(\"new OptimalCodeWriter: width = \" + width);\n        }\n    }\n\n    /**\n     * Create a OptimalCodeWriter object.\n     * @param o the writer to write to. Must be non-null.\n     * @param width_ the formatting width. Must be positive.\n     */\n    public OptimalCodeWriter(Writer o, int width_) {\n        this(new PrintWriter(o), width_);\n    }\n\n    @Override\n    public void write(String s) {\n        if (s.length() \u003e 0) write(s, s.length());\n    }\n\n    @Override\n    public void write(String s, int length) {\n        if (OptimalCodeWriter.showInput) {\n            trace(\"write '\" + s + \"' (\" + length + \")\");\n        }\n        current.add(new TextItem(s, length));\n    }\n\n    protected List\u003cBlockItem\u003e blockStack = new LinkedList\u003c\u003e();\n\n    /**\n     * Start a new block with a relative indentation of {@code n}\n     * characters.\n     * \u003cp\u003e\n     * A block is a formatting unit. The formatting algorithm will try to put\n     * the whole block in one line unless\n     * \u003cul\u003e\n     * \u003cli\u003ethere is a level-0 break in the block, or\u003c/li\u003e\n     * \u003cli\u003ethe block cannot fit in one line.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * If either of the two conditions is satisfied, the formatting algorithm\n     * will break the block into lines by generating newlines for some of the\n     * inserted breaks. The first line is printed at the current cursor\n     * position {@code pos}, all the following lines are printed at the\n     * position {@code pos+n}.\n     *\n     * @param n\n     *            the number of characters increased on indentation (relative\n     *            to the current position) for all lines in the block.\n     *            Requires: {@code n \u003e= 0}.\n     */\n    @Override\n    public void begin(int n) {\n        if (OptimalCodeWriter.showInput) {\n            trace(\"begin \" + n);\n            incIndent();\n        }\n        BlockItem b = new BlockItem(n);\n        current.add(b);\n        blockStack.add(0, current);\n        current = b;\n    }\n\n    /**\n     * Terminate the most recent outstanding {@code begin}.\n     */\n    @Override\n    public void end() {\n        if (OptimalCodeWriter.showInput) {\n            decIndent();\n            trace(\"end\");\n        }\n        if (blockStack.isEmpty())\n            throw new InternalCompilerError(\"Mismatched blocks\");\n        current = blockStack.remove(0);\n    }\n\n    @Override\n    public void allowBreak(int n, int level, String alt, int altlen) {\n        if (OptimalCodeWriter.showInput) {\n            trace(\"allowBreak \" + n + \" level=\" + level);\n        }\n        current.add(new AllowBreak(n, level, alt, altlen, false));\n    }\n\n    /** @see polyglot.util.CodeWriter#unifiedBreak */\n    @Override\n    public void unifiedBreak(int n, int level, String alt, int altlen) {\n        if (OptimalCodeWriter.showInput) {\n            trace(\"unifiedBreak \" + n + \" level=\" + level);\n        }\n        current.add(new AllowBreak(n, level, alt, altlen, true));\n    }\n\n    /**\n     * Like newline(), but forces a newline with a specified indentation.\n     */\n    @Override\n    public void newline(int n, int level) {\n        if (OptimalCodeWriter.showInput) {\n            trace(\"newline \" + n);\n        }\n        current.add(new Newline(n, level));\n    }\n\n    /**\n     * Send out the current batch of text to be formatted. All outstanding\n     * {@code begin}'s are closed and the current indentation level is\n     * reset to 0. Returns true if formatting was completely successful (the\n     * margins were obeyed).\n     */\n    @Override\n    public boolean flush() throws IOException {\n        return flush(true);\n    }\n\n    /** Like {@code flush}, but passing {@code format=false}\n     * causes output to be generated in the fastest way possible, with\n     * all breaks broken.\n     * @param format whether to pretty-print the output\n     * @return whether formatting was completely successful.\n     * @throws IOException when io goes bad\n     */\n    @Override\n    public boolean flush(boolean format) throws IOException {\n        if (OptimalCodeWriter.showInput) {\n            trace(\"flush\");\n        }\n        if (!blockStack.isEmpty())\n            throw new InternalCompilerError(\"Mismatched blocks\");\n        boolean success = true;\n        format_calls = 0;\n\n        Map\u003cAllowBreak, Boolean\u003e brkAssignment;\n        if (format)\n            brkAssignment = OCItem.format(input, width);\n        else brkAssignment = Collections.emptyMap();\n        input.sendOutput(output, 0, 0, brkAssignment);\n\n        output.flush();\n        if (OptimalCodeWriter.debug) {\n            System.err.println(\"Total calls to format = \" + format_calls);\n            System.err.flush();\n        }\n        current = input = new BlockItem(0);\n        return success;\n    }\n\n    @Override\n    public void close() throws IOException {\n        flush();\n        output.close();\n    }\n\n    /**\n     * Return a readable representation of all the structured input given to\n     * the CodeWriter since the last flush.\n     */\n    @Override\n    public String toString() {\n        return input.toString();\n    }\n\n    protected BlockItem input;\n    protected BlockItem current;\n\n    protected static OCItem top;\n\n    protected PrintWriter output;\n    protected int width;\n    protected static int format_calls = 0;\n    public static final boolean debug = false; // show every step\n    public static final boolean showInput = false; // show input\n    public static final boolean visualize = false; // visualize formatting\n    // (requires VT100 terminal)\n\n    public static final boolean precompute = true; // use memoization\n\n    // Debugging methods\n\n    /** Amount to indent during tracing. */\n    protected int trace_indent = 0;\n\n    /** Increment tracing indentation. */\n    void incIndent() {\n        trace_indent++;\n    }\n\n    /** Decrement tracing indentation. */\n    void decIndent() {\n        trace_indent--;\n        if (trace_indent \u003c 0) throw new RuntimeException(\"unmatched end\");\n    }\n\n    /** Print a debug message. */\n    void trace(String s) {\n        for (int i = 0; i \u003c trace_indent; i++)\n            System.out.print(\" \");\n        System.out.println(s);\n    }\n\n}\n\nclass ConsList\u003cT\u003e {\n    static \u003cT\u003e ConsList\u003cT\u003e empty() {\n        return new ConsList\u003c\u003e();\n    }\n\n    static \u003cT\u003e ConsList\u003cT\u003e cons(T elem, ConsList\u003cT\u003e next) {\n        return new ConsList\u003c\u003e(elem, next);\n    }\n\n    T elem;\n    ConsList\u003cT\u003e next;\n\n    private ConsList() {\n    }\n\n    private ConsList(T elem, ConsList\u003cT\u003e next) {\n        this.elem = elem;\n        this.next = next;\n    }\n\n    boolean isEmpty() {\n        return next == null;\n    }\n\n    private int length = -1;\n\n    int length() {\n        if (length == -1) length = next == null ? 0 : 1 + next.length();\n        return length;\n    }\n\n    String toStringAux() {\n        if (next == null) return \"\";\n        return elem + \", \" + next.toStringAux();\n    }\n\n    @Override\n    public String toString() {\n        return \"[\" + toStringAux() + \"]\";\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof ConsList\u003c?\u003e) {\n            ConsList\u003c?\u003e l = (ConsList\u003c?\u003e) o;\n            if (length() != l.length()) return false;\n            if (elem == null || l.elem == null) {\n                if (elem != l.elem) return false;\n            }\n            else if (!elem.equals(l.elem)) return false;\n            if (next == null || l.next == null) return next == l.next;\n            return next.equals(l.next);\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        int hc = 0;\n        if (next == null) hc = next.hashCode() * 31;\n        return hc + elem.hashCode();\n    }\n}\n\nclass SearchState implements Cloneable {\n\n    int lmargin, rmargin, pos;\n    int minbr, minbu, minbo, maxbr, maxbi;\n    boolean forward;\n    boolean findminovf;\n    int minovf;\n\n    Map\u003cAllowBreak, Boolean\u003e brkAssignment;\n    ConsList\u003cBoolean\u003e afterBrkAssignment;\n\n    ConsList\u003cBlockItem\u003e blks;\n    ConsList\u003cInteger\u003e lmargins, rmargins;\n    ConsList\u003cInteger\u003e minbrs, minbus, minbos, maxbrs, maxbis;\n\n    AllowBreak it;\n    SearchState prevBreak;\n\n    SearchState(int lmargin, int rmargin, int pos, int minbr, int minbu,\n            int minbo, int maxbr, int maxbi) {\n        this.lmargin = lmargin;\n        this.rmargin = rmargin;\n        this.pos = pos;\n        this.minbr = minbr;\n        this.minbu = minbu;\n        this.minbo = minbo;\n        this.maxbr = maxbr;\n        this.maxbi = maxbi;\n        forward = true;\n        findminovf = false;\n        brkAssignment = new LinkedHashMap\u003c\u003e();\n        afterBrkAssignment = ConsList.empty();\n\n        blks = ConsList.empty();\n        lmargins = ConsList.empty();\n        rmargins = ConsList.empty();\n        minbrs = ConsList.empty();\n        minbus = ConsList.empty();\n        minbos = ConsList.empty();\n        maxbrs = ConsList.empty();\n        maxbis = ConsList.empty();\n    }\n\n    void pushBlock(BlockItem it) {\n        blks = ConsList.cons(it, blks);\n        lmargins = ConsList.cons(lmargin, lmargins);\n        rmargins = ConsList.cons(rmargin, rmargins);\n        minbrs = ConsList.cons(minbr, minbrs);\n        minbus = ConsList.cons(minbu, minbus);\n        minbos = ConsList.cons(minbo, minbos);\n        maxbrs = ConsList.cons(maxbr, maxbrs);\n        maxbis = ConsList.cons(maxbi, maxbis);\n    }\n\n    BlockItem popBlock() {\n        // Restore search parameters.\n        BlockItem result = blks.elem;\n        blks = blks.next;\n        lmargin = lmargins.elem;\n        lmargins = lmargins.next;\n        rmargin = rmargins.elem;\n        rmargins = rmargins.next;\n        int outerminbr = minbrs.elem;\n        minbrs = minbrs.next;\n        int outerminbu = minbus.elem;\n        minbus = minbus.next;\n        // The min break levels are the max required levels so far.\n        minbr = minbu = minbo;\n        if (minbr \u003c outerminbr) minbr = outerminbr;\n        if (minbu \u003c outerminbu) minbu = outerminbu;\n        minbo = minbos.elem;\n        minbos = minbos.next;\n        maxbr = maxbrs.elem;\n        maxbrs = maxbrs.next;\n        maxbi = maxbis.elem;\n        maxbis = maxbis.next;\n        return result;\n    }\n\n    SearchState copy() {\n        try {\n            SearchState s = (SearchState) clone();\n            return s;\n        }\n        catch (CloneNotSupportedException e) {\n            throw new InternalCompilerError(\"Java clone weirdness\", e);\n        }\n    }\n}\n\n/**\n * An {@code OCItem} is a piece of input handed to the formatter. It\n * contains a reference to a possibly empty list of items that follow it.\n */\nabstract class OCItem {\n    /** next is null if this is the last item in the list. */\n    OCItem next;\n\n    protected OCItem() {\n        next = null;\n    }\n\n    /**\n     * Try to format a whole sequence of items in the manner of formatN. Unlike\n     * for formatN, The initial position may be an overrun (this is the only\n     * way that overruns are checked!). The item {@code it} may be also\n     * null, signifying an empty list. Requires: lmargin \u0026lt; rmargin, pos \u0026le;\n     * rmargin, lmargin \u0026ge; 0.\n     *\n     * @see formatN\n     */\n    static Map\u003cAllowBreak, Boolean\u003e format(OCItem it, int rmargin) {\n        SearchState s =\n                new SearchState(0,\n                                rmargin,\n                                0,\n                                0,\n                                0,\n                                0,\n                                Integer.MAX_VALUE,\n                                Integer.MAX_VALUE);\n        for (OCItem cur = it; cur != null;) {\n            OptimalCodeWriter.format_calls++;\n            if (OptimalCodeWriter.debug) {\n                if (cur != OptimalCodeWriter.top) {\n                    System.err.println(\"SNAPSHOT:\");\n                    PrintWriter w =\n                            new PrintWriter(new OutputStreamWriter(System.err));\n                    cur.sendOutput(w,\n                                   0,\n                                   0,\n                                   Collections.\u003cAllowBreak, Boolean\u003e emptyMap());\n                    w.write(\"\u003cEND\u003e\\n\");\n                    w.flush();\n                }\n                System.err.println(\"Format: \" + cur + \"\\n  lmargin = \"\n                        + s.lmargin + \" pos = \" + s.pos + \" max break levels: \"\n                        + s.maxbr + \"/\" + s.maxbi + \" min break levels: \"\n                        + s.minbr + \"/\" + s.minbu);\n\n                System.err.flush();\n            }\n            cur.selfFormat(s);\n            if (s.forward) {\n                if (cur instanceof BlockItem) {\n                    BlockItem bi = (BlockItem) cur;\n                    cur = bi.first;\n                }\n                else cur = cur.next;\n                while (cur == null \u0026\u0026 !s.blks.isEmpty()) {\n                    // Retrieve next item in the outer block.\n                    cur = s.popBlock().next;\n                }\n            }\n            else {\n                SearchState prev = s.prevBreak;\n                cur = prev.it;\n                // Restore search parameters.\n                s.lmargin = prev.lmargin;\n                s.rmargin = prev.rmargin;\n                s.pos = prev.pos;\n                s.minbr = prev.minbr;\n                s.minbu = prev.minbu;\n                s.minbo = prev.minbo;\n                s.maxbr = prev.maxbr;\n                s.maxbi = prev.maxbi;\n                s.blks = prev.blks;\n                s.lmargins = prev.lmargins;\n                s.rmargins = prev.rmargins;\n                s.minbrs = prev.minbrs;\n                s.minbus = prev.minbus;\n                s.minbos = prev.minbos;\n                s.maxbrs = prev.maxbrs;\n                s.maxbis = prev.maxbis;\n            }\n        }\n        return s.brkAssignment;\n    }\n\n    /**\n     * Try to format this item.\n     *\n     * @param lmargin\n     *            is the current left margin.\n     * @param pos\n     *            is the current cursor position.\n     * @param rmargin\n     *            is the current right margin.\n     * @param fin\n     *            is a bound on the final cursor position after formatting the\n     *            whole item.\n     * @param maxLevel\n     *            is the maximum level at which breaks may be broken in the\n     *            current block.\n     * @param maxLevelInner\n     *            is the maximum level at which breaks may be broken in nested\n     *            blocks.\n     * @param minLevel\n     *            is the minimum level at which breaks must be broken.\n     * @param minLevelUnified\n     *            is the minimum level at which unified breaks must be broken.\n     *\n     * \u003cp\u003e\n     * Breaks may be broken up to level maxLevel, which is set whenever a break\n     * is not broken. Not breaking an ordinary break means that equal or\n     * higher-level breaks in all contained blocks must not be broken either,\n     * and breaks of strictly higher level in the same block must not be\n     * broken.  Not breaking a unified break means that breaks of the same\n     * level in the same block must not also be broken. The parameter\n     * maxLevelInner controls the maxLevel in nested blocks; it is equal to\n     * either maxLevel or maxLevel-1.\n     *\n     * \u003cp\u003e\n     * \u003cdl\u003e\n     * \u003cdt\u003eExample 1:\n     * \u003cdd\u003eSuppose we have a current maxLevel of 4, and an ordinary,\n     * non-unified break of level 2 is not broken. Then for that block,\n     * maxLevel is set to 2 and maxLevelInner is set to 1. This permits further\n     * breaks of level 1 or 2 in the same block, but only level-1 breaks in\n     * inner blocks.\n     *\n     * \u003cdt\u003eExample 2:\u003c/dt\u003e\n     * \u003cdd\u003eSuppose we have a current maxLevel of 4, and a unified break of\n     * level 2 is not broken. Then for that block, maxLevel and maxLevelInner\n     * are set to 1. This permits no breaks in this block or in any nested\n     * blocks.\u003c/dd\u003e\n     * \u003c/dl\u003e\n     *\n     * \u003cp\u003e\n     * When a break is broken in a nested block, it means that all equal or\n     * higher-level breaks in containing blocks must be broken. However, these\n     * breaks may be encountered after the nested block. The parameter\n     * {@code minLevel} is used to communicate the level of breaks broken\n     * in nested blocks (and earlier in the current block). Any break of level\n     * \u003c= minLevel \u003cem\u003emust\u003c/em\u003e be broken. The parameter\n     * {@code minLevelUnified} is the minimum level at which unified breaks must\n     * be broken.  minLevelUnified is equal to either minLevel or minLevel+1.\n     * \u003c/p\u003e\n     *\n     * \u003cdl\u003e\n     * \u003cdt\u003eExample 3:\n     * \u003cdd\u003eSuppose we have a current maxLevel of 4, and a break of level 2 is\n     * broken. Then for its block, minLevel is at least 1, and minLevelUnified\n     * is at least 2. For containing blocks, minLevel is at least 2.\u003c/dd\u003e\n     * \u003c/dl\u003e\n     *\n     * \u003cb\u003eNote: \u003c/b\u003e It is important that formatN not necessarily convert\n     * overruns in its final position into exceptions. This allows the calling\n     * routine to distinguish between 'internal' overruns and ones that it can\n     * tack on a conservative estimate of how much formatting the rest of the\n     * list will make the overrun go up by. Also, it simplifies the coding of\n     * formatN.\n     * \u003c/p\u003e\n     *\n     * Requires: rmargin \u0026lt; lmargin, pos \u0026lt;= rmargin, lmargin \u0026lt; rmargin,\n     * pos \u0026le; rmargin, lmargin \u0026ge; 0\n     */\n    abstract void selfFormat(SearchState s);\n\n    /**\n     * Send the output associated with this item to {@code out}, using the\n     * given break settings.\n     *\n     * @param success\n     */\n    abstract int sendOutput(PrintWriter out, int lmargin, int pos,\n            Map\u003cAllowBreak, Boolean\u003e brkAssignment);\n\n    public String summarize(String s) {\n        if (s.length() \u003c= 79) return s;\n        return s.substring(0, 76) + \"...\";\n    }\n\n    @Override\n    public String toString() {\n        if (next == null) return summarize(selfToString());\n        return summarize(selfToString() + next.toString());\n    }\n\n    abstract String selfToString();\n\n    /**\n     * Returns an integer array of length at least 3 such that\n     * - [0] is the minimum break level that any break in the containing block\n     *   of the containing block of this item must break\n     * - [1] is the minimum break level that any break in the containing block\n     *   of this item must break\n     * - [2] is the minimum break level that any unified break in the containing\n     *   block of this item must break\n     */\n    abstract int[] minBreakLevels();\n}\n\n/** A simple string. */\nclass TextItem extends OCItem {\n    String s; //@ invariant s != null\n    int length;\n\n    TextItem(String s_, int length_) {\n        s = s_;\n        length = length_;\n    }\n\n    @Override\n    void selfFormat(SearchState s) {\n        if (s.findminovf \u0026\u0026 s.pos + length \u003e s.rmargin) {\n            // If break assignments causing minimal overflow is being sought,\n            // and this item overflows, backtrack.\n            s.forward = false;\n            s.minovf = s.pos + length - s.rmargin;\n        }\n        else {\n            // Otherwise, all preceding break assignments have done their best jobs,\n            // so move forward.\n            s.pos += length;\n        }\n    }\n\n    @Override\n    int sendOutput(PrintWriter o, int lmargin, int pos,\n            Map\u003cAllowBreak, Boolean\u003e brkAssignment) {\n        o.write(s);\n        return pos + length;\n    }\n\n    int[] minBreakLevels = { 0, 0, 0 };\n\n    @Override\n    int[] minBreakLevels() {\n        return minBreakLevels;\n    }\n\n    @Override\n    String selfToString() {\n        java.io.StringWriter sw = new java.io.StringWriter();\n        for (int i = 0; i \u003c s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == ' ')\n                sw.write(\"\\\\ \");\n            else sw.write(c);\n        }\n        return sw.toString();\n    }\n\n    /**\n     * @param item\n     */\n    public void appendTextItem(TextItem item) {\n        s += item.s;\n        length += item.length;\n    }\n}\n\nclass AllowBreak extends OCItem {\n    final int indent;\n    final int level;\n    final boolean unified;\n    final String alt;\n    final int altlen;\n\n    //@ invariant indent \u003e= 0\n    //@ invariant alt != null\n\n    //@ requires n_ \u003e= 0\n    //@ requires alt_ != null\n    AllowBreak(int n_, int level_, String alt_, int altlen_, boolean u) {\n        indent = n_;\n        alt = alt_;\n        altlen = altlen_;\n        level = level_;\n        unified = u;\n    }\n\n    /* maxbr -\u003e pos -\u003e minovf * afterBrkAssignment */\n    Map\u003cConsList\u003cInteger\u003e, Map\u003cInteger, Pair\u003cInteger, ConsList\u003cBoolean\u003e\u003e\u003e\u003e cache =\n            new HashMap\u003c\u003e();\n\n    int minovf;\n    ConsList\u003cBoolean\u003e afterBrkAssignment;\n\n    @Override\n    void selfFormat(SearchState s) {\n        boolean backtrack = false;\n        boolean findminovf = false;\n        boolean assignment;\n        if (s.forward) {\n            if (s.findminovf) {\n                // First, check the cache if we have done tried the given\n                // search parameters.  If so, just return the memoized\n                // result and backtrack.\n                if (cache.containsKey(s.maxbrs)) {\n                    Map\u003cInteger, Pair\u003cInteger, ConsList\u003cBoolean\u003e\u003e\u003e brCache =\n                            cache.get(s.maxbrs);\n                    if (brCache.containsKey(s.pos)) {\n                        Pair\u003cInteger, ConsList\u003cBoolean\u003e\u003e result =\n                                brCache.get(s.pos);\n                        s.forward = false;\n                        s.minovf = result.part1();\n                        s.afterBrkAssignment = result.part2();\n                        return;\n                    }\n                }\n            }\n            // First, check if there is already an assignment for us.\n            if (s.afterBrkAssignment.length() \u003e 0) {\n                // Just take the specified assignment.\n                assignment = s.afterBrkAssignment.elem;\n                s.afterBrkAssignment = s.afterBrkAssignment.next;\n            }\n            else if (canLeaveUnbroken(s.minbr, s.minbu)\n                    \u0026\u0026 s.pos + altlen \u003c= s.rmargin) {\n                // This break can be left unbroken without causing immediate overflow.\n                assignment = false;\n                findminovf = true;\n            }\n            else if (canBreak(s.maxbr)) {\n                // This break must be broken.\n                // If not breaking causes immediate overflow, it is better to\n                // break now and possibly overflow later.\n                assignment = true;\n                findminovf = s.findminovf;\n            }\n            else if (canLeaveUnbroken(s.minbr, s.minbu)) {\n                // Overflow always happens, and we could not break.\n                assignment = false;\n                if (s.findminovf) {\n                    // If an earlier break is finding minimal overflow, punt to that break.\n                    backtrack = true;\n                    // Since we could not break, the amount of minimal overflow is by not breaking.\n                    s.minovf = s.pos + altlen - s.rmargin;\n                }\n            }\n            else throw new InternalCompilerError(\"Could not either break or not break.\"\n                    + this);\n        }\n        else {\n            // Later item failed to stay within width limit\n            // Plan to move forward for now.\n            // If this is impossible, later code will reset.\n            s.forward = true;\n            if (!s.brkAssignment.get(this) \u0026\u0026 canBreak(s.maxbr)) {\n                // We tried not breaking and did not work.\n                // Save later assignments that cause the overflow when not breaking.\n                minovf = s.minovf;\n                afterBrkAssignment = s.afterBrkAssignment;\n                s.afterBrkAssignment = ConsList.empty();\n                // Now we try breaking.\n                assignment = true;\n            }\n            else {\n                // We tried all options, and overflow always happens.\n                if (afterBrkAssignment != null) {\n                    // We tried both breaking and not breaking.\n                    if (afterBrkAssignment.length() \u003e s.afterBrkAssignment.length()\n                            || afterBrkAssignment.length() == s.afterBrkAssignment.length()\n                                    \u0026\u0026 minovf \u003c= s.minovf) {\n                        // Not breaking causes overflow later.\n                        //  or\n                        // Overflow at the same location,\n                        // but breaking does not cause less overflow.\n                        assignment = false;\n                        // Restore saved assignments.\n                        s.minovf = minovf;\n                        s.afterBrkAssignment = afterBrkAssignment;\n                    }\n                    else assignment = true;\n                }\n                else {\n                    // We did not save assignments.\n                    // If we can break, then we could not break, so we must break.\n                    // Otherwise, we must not break.\n                    assignment = canBreak(s.maxbr);\n                }\n                SearchState prev = s.prevBreak;\n                s.prevBreak = prev.prevBreak;\n                if (prev.findminovf) {\n                    // If an earlier break is finding minimal overflow, punt to that break.\n                    backtrack = true;\n                }\n                else {\n                    // All earlier breaks have tried their best job,\n                    // so we continue on with our best break assignment.\n                    s.findminovf = false;\n                }\n            }\n        }\n        if (backtrack) {\n            // Reset saved assignments.\n            afterBrkAssignment = null;\n            // Prepare best assignment causing minimal overflow for earlier break.\n            s.forward = false;\n            s.brkAssignment.remove(this);\n            s.afterBrkAssignment =\n                    ConsList.cons(assignment, s.afterBrkAssignment);\n\n            // Memoize overflow results before backtracking.\n            Map\u003cInteger, Pair\u003cInteger, ConsList\u003cBoolean\u003e\u003e\u003e brCache;\n            if (cache.containsKey(s.maxbr))\n                brCache = cache.get(s.maxbr);\n            else {\n                brCache = new HashMap\u003c\u003e();\n                cache.put(s.maxbrs, brCache);\n            }\n            Pair\u003cInteger, ConsList\u003cBoolean\u003e\u003e result =\n                    new Pair\u003c\u003e(s.minovf, s.afterBrkAssignment);\n            brCache.put(s.pos, result);\n        }\n        else {\n            if (findminovf) {\n                // Set backtracking point to this break.\n                s.it = this;\n                // Save provided information.\n                s.prevBreak = s.copy();\n                s.findminovf = true;\n                s.minovf = 0;\n            }\n            s.brkAssignment.put(this, assignment);\n            if (assignment) {\n                // Break is broken.\n                s.pos = s.lmargin + indent;\n                // Since we are breaking, all breaks of lower levels must also be broken.\n                if (s.minbr \u003c level) s.minbr = level - 1;\n                // If this is a unified break, all unified breaks of our level must also be broken.\n                if (unified \u0026\u0026 s.minbu \u003c level) s.minbu = level;\n                // The min break level of outer block must be at least this level.\n                if (s.minbo \u003c level) s.minbo = level;\n            }\n            else {\n                // Break is not broken.\n                s.pos += altlen;\n                // Since we are not breaking, the max break level must be adjusted.\n                if (s.maxbr \u003e= level) {\n                    if (unified) {\n                        // If this is a unified break, the max break level must be less than our level.\n                        s.maxbr = level - 1;\n                    }\n                    else {\n                        // Otherwise, the max break level must be at most our level.\n                        s.maxbr = level;\n                    }\n                }\n                // The max break level of inner block must be less than our level.\n                if (s.maxbi \u003e= level) s.maxbi = level - 1;\n            }\n        }\n    }\n\n    @Override\n    int sendOutput(PrintWriter o, int lmargin, int pos,\n            Map\u003cAllowBreak, Boolean\u003e brkAssignment) {\n        if (brkAssignment.containsKey(this) \u0026\u0026 !brkAssignment.get(this)) {\n            // Do not break.\n            o.print(alt);\n            return pos + altlen;\n        }\n        else {\n            // Break.\n            o.println();\n            for (int i = 0; i \u003c lmargin + indent; i++)\n                o.print(\" \");\n            return lmargin + indent;\n        }\n    }\n\n    boolean canBreak(int maxb) {\n        return level \u003c= maxb;\n    }\n\n    boolean canLeaveUnbroken(int minLevel, int minLevelUnified) {\n        return level \u003e minLevelUnified || !unified \u0026\u0026 level \u003e minLevel;\n    }\n\n    int[] minBreakLevels = { 0, 0, 0 };\n\n    @Override\n    int[] minBreakLevels() {\n        return minBreakLevels;\n    }\n\n    @Override\n    String selfToString() {\n        String result = unified ? \"@\u003c\" : \"\u003c\";\n        result += level + \"\u003e\";\n        if (indent == 0)\n            return result + \" \";\n        else return result + \"^\" + indent;\n    }\n}\n\n/**\n * A Newline is simply an {@code AllowBreak} that must be broken.\n */\nclass Newline extends AllowBreak {\n    Newline(int n, int level) {\n        super(n, level, \"\\n\", 0, true);\n    }\n\n    @Override\n    void selfFormat(SearchState s) {\n        if (!canBreak(s.maxbr))\n            throw new InternalCompilerError(\"Newline cannot be broken.\");\n        // Break is broken.\n        s.pos = s.lmargin + indent;\n        // Since we are breaking, all breaks of lower levels must also be broken.\n        if (s.minbr \u003c level) s.minbr = level - 1;\n        // If this is a unified break, all unified breaks of our level must also be broken.\n        if (unified \u0026\u0026 s.minbu \u003c level) s.minbu = level;\n    }\n\n    @Override\n    boolean canLeaveUnbroken(int minLevel, int minLevelUnified) {\n        return false;\n    }\n\n    @Override\n    String selfToString() {\n        if (indent == 0)\n            return \"\\\\n\";\n        else return \"\\\\n[\" + indent + \"]\";\n    }\n\n    int[] minBreakLevels = { level, level \u003e 0 ? level - 1 : 0, level };\n\n    @Override\n    int[] minBreakLevels() {\n        return minBreakLevels;\n    }\n}\n\n/**\n * A BlockItem is a formatting unit containing a list of other items to be\n * formatted.\n */\nclass BlockItem extends OCItem {\n    OCItem first;\n    OCItem last;\n    int indent; //@ invariant indent \u003e= 0\n\n    BlockItem(int indent_) {\n        first = last = null;\n        indent = indent_;\n    }\n\n    /**\n     * Add a new item to the end of the block. Successive StringItems are\n     * concatenated together to limit recursion depth when formatting.\n     */\n    void add(OCItem it) {\n        if (first == null) {\n            first = it;\n        }\n        else {\n            if (it instanceof TextItem \u0026\u0026 last instanceof TextItem) {\n                TextItem lasts = (TextItem) last;\n                lasts.appendTextItem((TextItem) it);\n                return;\n            }\n            else {\n                last.next = it;\n            }\n        }\n        last = it;\n    }\n\n    @Override\n    void selfFormat(SearchState s) {\n        // We are going into a block.\n        // Save parameters for the outer block.\n        s.pushBlock(this);\n        // The new indentation is relative to the current position.\n        s.lmargin = s.pos + indent;\n        // The min break levels reset.\n        int[] minBreakLevels = minBreakLevels();\n        s.minbr = minBreakLevels[3];\n        s.minbu = minBreakLevels[4];\n        s.minbo = minBreakLevels[1];\n        // The max break level is now maxbi.\n        s.maxbr = s.maxbi;\n    }\n\n    @Override\n    int sendOutput(PrintWriter o, int lmargin, int pos,\n            Map\u003cAllowBreak, Boolean\u003e brkAssignment) {\n        lmargin = pos + indent;\n        for (OCItem it = first; it != null; it = it.next)\n            pos = it.sendOutput(o, lmargin, pos, brkAssignment);\n        return pos;\n    }\n\n    int[] minBreakLevels = null;\n\n    /**\n     * Returns an integer array of length 5 such that\n     * - [0] is the minimum break level that any break in the containing block\n     *   of the containing block of this item must break\n     * - [1] is the minimum break level that any break in the containing block\n     *   of this item must break\n     * - [2] is the minimum break level that any unified break in the containing\n     *   block of this item must break\n     * - [3] is the minimum break level that any break in this block must break\n     * - [4] is the minimum break level that any unified break in this block\n     *   must break\n     */\n    @Override\n    int[] minBreakLevels() {\n        if (minBreakLevels == null) {\n            minBreakLevels = new int[] { 0, 0, 0, 0, 0 };\n            for (OCItem it = first; it != null; it = it.next) {\n                int[] mbls = it.minBreakLevels();\n                if (minBreakLevels[2] \u003c mbls[0]) minBreakLevels[2] = mbls[0];\n                if (minBreakLevels[3] \u003c mbls[1]) minBreakLevels[3] = mbls[1];\n                if (minBreakLevels[4] \u003c mbls[2]) minBreakLevels[4] = mbls[2];\n            }\n            minBreakLevels[0] = minBreakLevels[1] = minBreakLevels[2];\n        }\n        return minBreakLevels;\n    }\n\n    @Override\n    String selfToString() {\n        if (indent == 0)\n            return \"[\" + first + \"]\";\n        else return \"[\" + indent + first + \"]\";\n    }\n}\n",
        "name": "OptimalCodeWriter.java",
        "path": "src/polyglot/util/OptimalCodeWriter.java",
        "url": "/github.com/ralphrecto/xic/-/blob/src/polyglot/util/OptimalCodeWriter.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 701,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires n_ \u003e= 0"
        },
        {
          "limitHit": false,
          "lineNumber": 702,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires alt_ != null"
        }
      ],
      "repository": {
        "name": "github.com/ralphrecto/xic",
        "url": "/github.com/ralphrecto/xic"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 2,
  "ElapsedMilliseconds": 134,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
