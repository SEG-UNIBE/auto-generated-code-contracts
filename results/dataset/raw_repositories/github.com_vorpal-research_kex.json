{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/vorpal-research/kex lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "4e43a6868f2a3f70094b8119cff31135a620f6b7"
        },
        "content": "package org.vorpal.research.kex.test.javadebug;\n\nimport java.util.NoSuchElementException;\n\nclass Range {\n    final int lower;\n    final int upper;\n    final boolean isPositiveInfinity;\n    final boolean isNegativeInfinity;\n\n    public Range() {\n        this(0, 0, true, true);\n    }\n\n    private Range(final int u, final int l, final boolean ip, final boolean in) {\n        this.upper = u;\n        this.lower = l;\n        this.isPositiveInfinity = ip;\n        this.isNegativeInfinity = in;\n    }\n\n    public boolean inRange(final int value) {\n        boolean ret = true;\n        if (!this.isPositiveInfinity) {\n            ret = value \u003c this.upper;\n        }\n        if (!this.isNegativeInfinity) {\n            ret = ret \u0026\u0026 (value \u003e this.lower);\n        }\n        return ret;\n    }\n\n    public Range setLower(final int l) {\n        assert this.isNegativeInfinity || (l \u003e this.lower);\n        return new Range(this.upper, l, this.isPositiveInfinity, false);\n    }\n\n    public Range setUpper(final int u) {\n        assert this.isPositiveInfinity || (u \u003c this.upper);\n        return new Range(u, this.lower, false, this.isNegativeInfinity);\n    }\n}\n\n@SuppressWarnings(\"ALL\")\npublic class TreeMap\u003cV\u003e {\n    /**\n     * Node in the Tree. Doubles as a means to pass key-value pairs back to user\n     * (see Map.Entry).\n     */\n\n    static public class Entry\u003cV\u003e {\n        int key;\n\n        V value;\n\n        Entry\u003cV\u003e left = null;\n\n        Entry\u003cV\u003e right = null;\n\n        Entry\u003cV\u003e parent;\n\n        boolean color = TreeMap.BLACK;\n\n        public Entry() {\n            this.parent = null;\n            this.value = null;\n            this.key = -1;\n        }\n\n        /**\n         * Make a new cell with given key, value, and parent, and with \u003ctt\u003enull\u003c/tt\u003e\n         * child links, and BLACK color.\n         */\n        Entry(final int key, final V value, final Entry\u003cV\u003e parent) {\n            this.key = key;\n            this.value = value;\n            this.parent = parent;\n        }\n\n        /**\n         * Returns true if black properties of tree are correct\n         *\n         * @post returns true if black properties of tree are correct\n         */\n        protected boolean blackConsistency() {\n\n            if (this.color != TreeMap.BLACK) // root must be black\n            {\n                return false;\n            }\n            // the number of black nodes on way to any leaf must be same\n            if (!consistentlyBlackHeight(blackHeight())) {\n                return false;\n            }\n            return true;\n        }\n\n        /**\n         * Returns the black height of this subtree.\n         *\n         * @pre\n         * @post returns the black height of this subtree\n         */\n        private int blackHeight() {\n            int ret = 0;\n            if (this.color == TreeMap.BLACK) {\n                ret = 1;\n            }\n            if (this.left != null) {\n                ret += this.left.blackHeight();\n            }\n            return ret;\n        }\n\n        boolean consistency() {\n            return wellConnected(null) \u0026\u0026 redConsistency() \u0026\u0026 blackConsistency()\n                    \u0026\u0026 ordered();\n        }\n\n        /**\n         * Checks to make sure that the black height of tree is height\n         *\n         * @post checks to make sure that the black height of tree is height\n         */\n        private boolean consistentlyBlackHeight(int height) {\n            boolean ret = true;\n            if (this.color == TreeMap.BLACK) {\n                height--;\n            }\n            if (this.left == null) {\n                ret = ret \u0026\u0026 (height == 0);\n            } else {\n                ret = ret \u0026\u0026 (this.left.consistentlyBlackHeight(height));\n            }\n            if (this.right == null) {\n                ret = ret \u0026\u0026 (height == 0);\n            } else {\n                ret = ret \u0026\u0026 (this.right.consistentlyBlackHeight(height));\n            }\n\n            return ret;\n        }\n\n        @Override\n        public boolean equals(final Object o) {\n            if (!(o instanceof Entry)) {\n                return false;\n            }\n            @SuppressWarnings(\"unchecked\")\n            final Entry e = (Entry) o;\n\n            return (this.key == e.getKey())\n                    \u0026\u0026 TreeMap.valEquals(this.value, e.getValue());\n        }\n\n        /**\n         * Returns the key.\n         *\n         * @return the key.\n         */\n        public int getKey() {\n            return this.key;\n        }\n\n        /**\n         * Returns the value associated with the key.\n         *\n         * @return the value associated with the key.\n         */\n        public V getValue() {\n            return this.value;\n        }\n\n        @Override\n        public int hashCode() {\n            final int keyHash = this.key;\n            final int valueHash = (this.value == null ? 0 : this.value.hashCode());\n            return keyHash ^ valueHash;\n        }\n\n        private boolean ordered() {\n            return ordered(this, new Range());\n        }\n\n        private boolean ordered(final Entry\u003cV\u003e t, final Range range) {\n            if (t == null) {\n                return true;\n            }\n            if (!range.inRange(t.key)) {\n                return false;\n            }\n            boolean ret = true;\n            ret = ret \u0026\u0026 ordered(t.left, range.setUpper(t.key));\n            ret = ret \u0026\u0026 ordered(t.right, range.setLower(t.key));\n            return ret;\n        }\n\n        /**\n         * Returns true if no red node in subtree has red children\n         *\n         * @post returns true if no red node in subtree has red children\n         */\n        private boolean redConsistency() {\n            boolean ret = true;\n            if ((this.color == TreeMap.RED)\n                    \u0026\u0026 (((this.left != null) \u0026\u0026 (this.left.color == TreeMap.RED)) || ((this.right != null) \u0026\u0026 (this.right.color == TreeMap.RED)))) {\n                return false;\n            }\n            if (this.left != null) {\n                ret = ret \u0026\u0026 this.left.redConsistency();\n            }\n            if (this.right != null) {\n                ret = ret \u0026\u0026 this.right.redConsistency();\n            }\n            return ret;\n        }\n\n        /**\n         * Replaces the value currently associated with the key with the given\n         * value.\n         *\n         * @return the value associated with the key before this method was called.\n         */\n        public V setValue(final V value) {\n            final V oldValue = this.value;\n            this.value = value;\n            return oldValue;\n        }\n\n        int size() {\n            int ls = 0, rs = 0;\n            if (this.left != null) {\n                ls = this.left.size();\n            }\n            if (this.right != null) {\n                rs = this.right.size();\n            }\n            return 1 + ls + rs;\n        }\n\n        @Override\n        public String toString() {\n            return this.key + \"=\" + this.value;\n        }\n\n        /**\n         * Returns true iff this tree is well-connected.\n         */\n\n        private boolean wellConnected(final Entry\u003cV\u003e expectedParent) {\n            boolean ok = true;\n            if (expectedParent != this.parent) {\n\n                return false;\n            }\n\n            if (this.right != null) {\n                // ok \u0026\u0026 is redundant because ok is assigned true\n                ok = ok \u0026\u0026 this.right.wellConnected(this);\n            }\n\n            if (this.left != null) {\n\n                ok = ok \u0026\u0026 this.left.wellConnected(this);\n            }\n\n            if ((this.right == this.left) \u0026\u0026 (this.right != null)\n                    \u0026\u0026 (this.left != null)) {// left!=null\n                // is\n                // redundant\n                // because\n                // left==right\n                // \u0026\u0026\n                // right!=null\n                return false;\n            }\n\n            return ok;\n        }\n    }\n\n    private static final boolean RED = false;\n\n    private static final boolean BLACK = true;\n\n    /**\n     * Balancing operations.\n     *\n     * Implementations of rebalancings during insertion and deletion are slightly\n     * different than the CLR version. Rather than using dummy nilnodes, we use a\n     * set of accessors that deal properly with null. They are used to avoid\n     * messiness surrounding nullness checks in the main algorithms.\n     */\n\n    private static \u003cV\u003e boolean colorOf(final Entry\u003cV\u003e p) {\n        return (p == null ? TreeMap.BLACK : p.color);\n    }\n\n    /**\n     * Returns the key corresponding to the specified Entry. Throw\n     * NoSuchElementException if the Entry is \u003ctt\u003enull\u003c/tt\u003e.\n     */\n    private static int key(final Entry\u003c?\u003e e) {\n        if (e == null) {\n            throw new NoSuchElementException();\n        }\n        return e.key;\n    }\n\n    // Query Operations\n\n    private static \u003cV\u003e Entry\u003cV\u003e leftOf(final Entry\u003cV\u003e p) {\n        return (p == null) ? null : p.left;\n    }\n\n    private static \u003cV\u003e Entry\u003cV\u003e parentOf(final Entry\u003cV\u003e p) {\n        return (p == null ? null : p.parent);\n    }\n\n    private static \u003cV\u003e Entry\u003cV\u003e rightOf(final Entry\u003cV\u003e p) {\n        return (p == null) ? null : p.right;\n    }\n\n    private static \u003cV\u003e void setColor(final Entry\u003cV\u003e p, final boolean c) {\n        if (p != null) {\n            p.color = c;\n        }\n    }\n\n    /**\n     * Test two values for equality. Differs from o1.equals(o2) only in that it\n     * copes with \u003ctt\u003enull\u003c/tt\u003e o1 properly.\n     */\n    private static boolean valEquals(final Object o1, final Object o2) {\n        return (o1 == null ? o2 == null : o1.equals(o2));\n    }\n\n    /**\n     * The Comparator used to maintain order in this TreeMapGeneric, or null if\n     * this TreeMapGeneric uses its elements natural ordering.\n     *\n     * @serial\n     */\n\n    private transient Entry\u003cV\u003e root = null;\n\n    /**\n     * The number of entries in the tree\n     */\n    private transient int size = 0;\n\n    /**\n     * The number of structural modifications to the tree.\n     */\n    private transient int modCount = 0;\n\n    /**\n     * Removes all mappings from this TreeMapGeneric.\n     */\n    public void clear() {\n        this.modCount++;\n        this.size = 0;\n        this.root = null;\n    }\n\n    /**\n     * Compares two keys using the correct comparison method for this\n     * TreeMapGeneric.\n     */\n    private int compare(final int k1, final int k2) {\n        if (k1 \u003c k2) {\n            return -1;\n\n        } else if (k1 == k2) {\n            return 0;\n        } else {\n            return 1;\n        }\n    }\n\n    /**\n     * Returns \u003ctt\u003etrue\u003c/tt\u003e if this map contains a mapping for the specified key.\n     *\n     * @param key\n     *          key whose presence in this map is to be tested.\n     *\n     * @return \u003ctt\u003etrue\u003c/tt\u003e if this map contains a mapping for the specified key.\n     * @throws ClassCastException\n     *           if the key cannot be compared with the keys currently in the map.\n     * @throws NullPointerException\n     *           key is \u003ctt\u003enull\u003c/tt\u003e and this map uses natural ordering, or its\n     *           comparator does not tolerate \u003ctt\u003enull\u003c/tt\u003e keys.\n     */\n    public boolean containsKey(final int key) {\n        return getEntry(key) != null;\n    }\n\n    /**\n     * Returns \u003ctt\u003etrue\u003c/tt\u003e if this map maps one or more keys to the specified\n     * value. More formally, returns \u003ctt\u003etrue\u003c/tt\u003e if and only if this map\n     * contains at least one mapping to a value \u003ctt\u003evalue\u003c/tt\u003e such that\n     * \u003ctt\u003e(value==null ? value==null : value.equals(value))\u003c/tt\u003e. This operation\n     * will probably require time linear in the Map size for most implementations\n     * of Map.\n     *\n     * @param value\n     *          value whose presence in this Map is to be tested.\n     * @return \u003ctt\u003etrue\u003c/tt\u003e if a mapping to \u003ctt\u003evalue\u003c/tt\u003e exists; \u003ctt\u003efalse\u003c/tt\u003e\n     *         otherwise.\n     * @since 1.2\n     */\n    public boolean containsValue(final Object value) {\n        return (this.root == null ? false\n                : (value == null ? valueSearchNull(this.root) : valueSearchNonNull(\n                this.root, value)));\n    }\n\n    private void decrementSize() {\n        this.modCount++;\n        this.size--;\n    }\n\n    /**\n     * Delete node p, and then rebalance the tree.\n     */\n\n    private void deleteEntry(Entry\u003cV\u003e p) {\n        decrementSize();\n\n        // If strictly internal, copy successor's element to p and then make p\n        // point to successor.\n        if ((p.left != null) \u0026\u0026 (p.right != null)) {\n            final Entry\u003cV\u003e s = successor(p);\n            p.key = s.key;\n            p.value = s.value;\n            p = s;\n        } // p has 2 children\n\n        // Start fixup at replacement node, if it exists.\n        final Entry\u003cV\u003e replacement = (p.left != null ? p.left : p.right);\n\n        if (replacement != null) {\n            // Link replacement to parent\n            replacement.parent = p.parent;\n            if (p.parent == null) {\n                this.root = replacement;\n            } else if (p == p.parent.left) {\n                p.parent.left = replacement;\n            } else {\n                p.parent.right = replacement;\n            }\n\n            // Null out links so they are OK to use by fixAfterDeletion.\n            p.left = p.right = p.parent = null;\n\n            // Fix replacement\n            if (p.color == TreeMap.BLACK) {\n                fixAfterDeletion(replacement);\n            }\n        } else if (p.parent == null) { // return if we are the only node.\n            this.root = null;\n        } else { // No children. Use self as phantom replacement and unlink.\n            if (p.color == TreeMap.BLACK) {\n                fixAfterDeletion(p);\n            }\n\n            if (p.parent != null) {\n                if (p == p.parent.left) {\n                    p.parent.left = null;\n                } else if (p == p.parent.right) {\n                    p.parent.right = null;\n                }\n                p.parent = null;\n            }\n        }\n    }\n\n    /**\n     * Returns the first Entry in the TreeMapGeneric (according to the\n     * TreeMapGeneric's key-sort function). Returns null if the TreeMapGeneric is\n     * empty.\n     */\n    private Entry\u003cV\u003e firstEntry() {\n        Entry\u003cV\u003e p = this.root;\n        if (p != null) {\n            while (p.left != null) {\n                p = p.left;\n            }\n        }\n        return p;\n    }\n\n    /**\n     * Returns the first (lowest) key currently in this sorted map.\n     *\n     * @return the first (lowest) key currently in this sorted map.\n     * @throws NoSuchElementException\n     *           Map is empty.\n     */\n    public int firstKey() {\n        return TreeMap.key(firstEntry());\n    }\n\n    /** From CLR * */\n    private void fixAfterDeletion(Entry\u003cV\u003e x) {\n        while ((x != this.root) \u0026\u0026 (TreeMap.colorOf(x) == TreeMap.BLACK)) {\n            if (x == TreeMap.leftOf(TreeMap.parentOf(x))) {\n                Entry\u003cV\u003e sib = TreeMap.rightOf(TreeMap.parentOf(x));\n\n                if (TreeMap.colorOf(sib) == TreeMap.RED) {\n                    TreeMap.setColor(sib, TreeMap.BLACK);\n                    TreeMap.setColor(TreeMap.parentOf(x), TreeMap.RED);\n                    rotateLeft(TreeMap.parentOf(x));\n                    sib = TreeMap.rightOf(TreeMap.parentOf(x));\n                }\n\n                if ((TreeMap.colorOf(TreeMap.leftOf(sib)) == TreeMap.BLACK)\n                        \u0026\u0026 (TreeMap.colorOf(TreeMap.rightOf(sib)) == TreeMap.BLACK)) {\n                    TreeMap.setColor(sib, TreeMap.RED);\n                    x = TreeMap.parentOf(x);\n                } else {\n                    if (TreeMap.colorOf(TreeMap.rightOf(sib)) == TreeMap.BLACK) {\n                        TreeMap.setColor(TreeMap.leftOf(sib), TreeMap.BLACK);\n                        TreeMap.setColor(sib, TreeMap.RED);\n                        rotateRight(sib);\n                        sib = TreeMap.rightOf(TreeMap.parentOf(x));\n                    }\n                    TreeMap.setColor(sib, TreeMap.colorOf(TreeMap.parentOf(x)));\n                    TreeMap.setColor(TreeMap.parentOf(x), TreeMap.BLACK);\n                    TreeMap.setColor(TreeMap.rightOf(sib), TreeMap.BLACK);\n                    rotateLeft(TreeMap.parentOf(x));\n                    x = this.root;\n                }\n            } else { // symmetric\n                Entry\u003cV\u003e sib = TreeMap.leftOf(TreeMap.parentOf(x));\n\n                if (TreeMap.colorOf(sib) == TreeMap.RED) {\n                    TreeMap.setColor(sib, TreeMap.BLACK);\n                    TreeMap.setColor(TreeMap.parentOf(x), TreeMap.RED);\n                    rotateRight(TreeMap.parentOf(x));\n                    sib = TreeMap.leftOf(TreeMap.parentOf(x));\n                }\n\n                if ((TreeMap.colorOf(TreeMap.rightOf(sib)) == TreeMap.BLACK)\n                        \u0026\u0026 (TreeMap.colorOf(TreeMap.leftOf(sib)) == TreeMap.BLACK)) {\n                    TreeMap.setColor(sib, TreeMap.RED);\n                    x = TreeMap.parentOf(x);\n                } else {\n                    if (TreeMap.colorOf(TreeMap.leftOf(sib)) == TreeMap.BLACK) {\n                        TreeMap.setColor(TreeMap.rightOf(sib), TreeMap.BLACK);\n                        TreeMap.setColor(sib, TreeMap.RED);\n                        rotateLeft(sib);\n                        sib = TreeMap.leftOf(TreeMap.parentOf(x));\n                    }\n                    TreeMap.setColor(sib, TreeMap.colorOf(TreeMap.parentOf(x)));\n                    TreeMap.setColor(TreeMap.parentOf(x), TreeMap.BLACK);\n                    TreeMap.setColor(TreeMap.leftOf(sib), TreeMap.BLACK);\n                    rotateRight(TreeMap.parentOf(x));\n                    x = this.root;\n                }\n            }\n        }\n\n        TreeMap.setColor(x, TreeMap.BLACK);\n    }\n\n    /** From CLR * */\n    private void fixAfterInsertion(Entry\u003cV\u003e x) {\n        x.color = TreeMap.RED;\n\n        while ((x != null) \u0026\u0026 (x != this.root) \u0026\u0026 (x.parent.color == TreeMap.RED)) {\n            if (TreeMap.parentOf(x) == TreeMap.leftOf(TreeMap.parentOf(TreeMap\n                    .parentOf(x)))) {\n                final Entry\u003cV\u003e y = TreeMap.rightOf(TreeMap\n                        .parentOf(TreeMap.parentOf(x)));\n                if (TreeMap.colorOf(y) == TreeMap.RED) {\n                    TreeMap.setColor(TreeMap.parentOf(x), TreeMap.BLACK);\n                    TreeMap.setColor(y, TreeMap.BLACK);\n                    TreeMap.setColor(TreeMap.parentOf(TreeMap.parentOf(x)), TreeMap.RED);\n                    x = TreeMap.parentOf(TreeMap.parentOf(x));\n                } else {\n                    if (x == TreeMap.rightOf(TreeMap.parentOf(x))) {\n                        x = TreeMap.parentOf(x);\n                        rotateLeft(x);\n                    }\n                    TreeMap.setColor(TreeMap.parentOf(x), TreeMap.BLACK);// bug\n                    // seeded\n                    TreeMap.setColor(TreeMap.parentOf(TreeMap.parentOf(x)), TreeMap.RED);\n                    if (TreeMap.parentOf(TreeMap.parentOf(x)) != null) {\n                        rotateRight(TreeMap.parentOf(TreeMap.parentOf(x)));\n                    }\n                }\n            } else {\n                final Entry\u003cV\u003e y = TreeMap\n                        .leftOf(TreeMap.parentOf(TreeMap.parentOf(x)));\n                if (TreeMap.colorOf(y) == TreeMap.RED) {\n                    TreeMap.setColor(TreeMap.parentOf(x), TreeMap.BLACK);\n                    TreeMap.setColor(y, TreeMap.BLACK);\n                    TreeMap.setColor(TreeMap.parentOf(TreeMap.parentOf(x)), TreeMap.RED);\n                    x = TreeMap.parentOf(TreeMap.parentOf(x));\n                } else {\n                    if (x == TreeMap.leftOf(TreeMap.parentOf(x))) {\n                        x = TreeMap.parentOf(x);\n                        rotateRight(x);\n                    }\n                    TreeMap.setColor(TreeMap.parentOf(x), TreeMap.BLACK);\n                    TreeMap.setColor(TreeMap.parentOf(TreeMap.parentOf(x)), TreeMap.RED);\n                    if (TreeMap.parentOf(TreeMap.parentOf(x)) != null) {\n                        rotateLeft(TreeMap.parentOf(TreeMap.parentOf(x)));\n                    }\n                }\n            }\n        }\n        this.root.color = TreeMap.BLACK;\n    }\n\n    /**\n     * Returns the value to which this map maps the specified key. Returns\n     * \u003ctt\u003enull\u003c/tt\u003e if the map contains no mapping for this key. A return value\n     * of \u003ctt\u003enull\u003c/tt\u003e does not \u003ci\u003enecessarily\u003c/i\u003e indicate that the map contains\n     * no mapping for the key; it's also possible that the map explicitly maps the\n     * key to \u003ctt\u003enull\u003c/tt\u003e. The \u003ctt\u003econtainsKey\u003c/tt\u003e operation may be used to\n     * distinguish these two cases.\n     *\n     * @param key\n     *          key whose associated value is to be returned.\n     * @return the value to which this map maps the specified key, or\n     *         \u003ctt\u003enull\u003c/tt\u003e if the map contains no mapping for the key.\n     * @throws ClassCastException\n     *           key cannot be compared with the keys currently in the map.\n     * @throws NullPointerException\n     *           key is \u003ctt\u003enull\u003c/tt\u003e and this map uses natural ordering, or its\n     *           comparator does not tolerate \u003ctt\u003enull\u003c/tt\u003e keys.\n     *\n     * @see #containsKey(Object)\n     */\n    //@ requires ((this.root == null) || this.root.consistency()) \u0026\u0026 (this.size == this.realSize());\n    //@ ensures true;\n    public V get(final int key) {\n        final Entry\u003cV\u003e p = getEntry(key);\n        return (p == null ? null : p.value);\n    }\n\n    /**\n     * Returns this map's entry for the given key, or \u003ctt\u003enull\u003c/tt\u003e if the map\n     * does not contain an entry for the key.\n     *\n     * @return this map's entry for the given key, or \u003ctt\u003enull\u003c/tt\u003e if the map\n     *         does not contain an entry for the key.\n     * @throws ClassCastException\n     *           if the key cannot be compared with the keys currently in the map.\n     * @throws NullPointerException\n     *           key is \u003ctt\u003enull\u003c/tt\u003e and this map uses natural order, or its\n     *           comparator does not tolerate * \u003ctt\u003enull\u003c/tt\u003e keys.\n     */\n    private Entry\u003cV\u003e getEntry(final int key) {\n        Entry\u003cV\u003e p = this.root;\n        final int k = key;\n        while (p != null) {\n            // int cmp = compare(k, p.key);\n            if (k == p.key) {\n                return p;\n            } else if (k \u003c p.key) {\n                p = p.left;\n            } else {\n                p = p.right;\n            }\n        }\n        return null;\n    }\n\n    private void incrementSize() {\n        this.modCount++;\n        this.size++;\n    }\n\n    /**\n     * Returns the last Entry in the TreeMapGeneric (according to the\n     * TreeMapGeneric's key-sort function). Returns null if the TreeMapGeneric is\n     * empty.\n     */\n    private Entry\u003cV\u003e lastEntry() {\n        Entry\u003cV\u003e p = this.root;\n        if (p != null) {\n            while (p.right != null) {\n                p = p.right;\n            }\n        }\n        return p;\n    }\n\n    /**\n     * Returns the last (highest) key currently in this sorted map.\n     *\n     * @return the last (highest) key currently in this sorted map.\n     * @throws NoSuchElementException\n     *           Map is empty.\n     */\n    //@ requires ((this.root == null) || this.root.consistency()) \u0026\u0026 (this.size == this.realSize());\n    //@ ensures true;\n    public int lastKey() {\n        return TreeMap.key(lastEntry());\n    }\n\n    //@ requires ((this.root == null) || this.root.consistency()) \u0026\u0026 (this.size == this.realSize());\n    //@ ensures ((this.root != null) \u0026\u0026 this.root.consistency());\n    public V put(final int key, final V value) {\n        Entry\u003cV\u003e t = this.root;\n\n        if (t == null) {\n            incrementSize();\n            this.root = new Entry\u003cV\u003e(key, value, null);\n            return null;\n        }\n\n        while (true) {\n            final int cmp = compare(key, t.key);\n            if (cmp == 0) {\n                return t.setValue(value);\n            } else if (cmp \u003c 0) {\n                if (t.left != null) {\n                    t = t.left;\n                } else {\n                    incrementSize();\n                    t.left = new Entry\u003cV\u003e(key, value, t);\n                    fixAfterInsertion(t.left);\n                    return null;\n                }\n            } else { // cmp \u003e 0\n                if (t.right != null) {\n                    t = t.right;\n                } else {\n                    incrementSize();\n                    t.right = new Entry\u003cV\u003e(key, value, t);\n                    fixAfterInsertion(t.right);\n                    return null;\n                }\n            }\n        }\n        // return null;\n    }\n\n    /**\n     * Associates the specified value with the specified key in this map. If the\n     * map previously contained a mapping for this key, the old value is replaced.\n     *\n     * @param key\n     *          key with which the specified value is to be associated.\n     * @param value\n     *          value to be associated with the specified key.\n     *\n     * @return previous value associated with specified key, or \u003ctt\u003enull\u003c/tt\u003e if\n     *         there was no mapping for key. A \u003ctt\u003enull\u003c/tt\u003e return can also\n     *         indicate that the map previously associated \u003ctt\u003enull\u003c/tt\u003e with the\n     *         specified key.\n     * @throws ClassCastException\n     *           key cannot be compared with the keys currently in the map.\n     * @throws NullPointerException\n     *           key is \u003ctt\u003enull\u003c/tt\u003e and this map uses natural order, or its\n     *           comparator does not tolerate \u003ctt\u003enull\u003c/tt\u003e keys.\n     */\n\n    public int realSize() {\n        if (this.root == null) {\n            return 0;\n        }\n        return this.root.size();\n    }\n\n    /**\n     * Removes the mapping for this key from this TreeMapGeneric if present.\n     *\n     * @param key\n     *          key for which mapping should be removed\n     * @return previous value associated with specified key, or \u003ctt\u003enull\u003c/tt\u003e if\n     *         there was no mapping for key. A \u003ctt\u003enull\u003c/tt\u003e return can also\n     *         indicate that the map previously associated \u003ctt\u003enull\u003c/tt\u003e with the\n     *         specified key.\n     *\n     * @throws ClassCastException\n     *           key cannot be compared with the keys currently in the map.\n     * @throws NullPointerException\n     *           key is \u003ctt\u003enull\u003c/tt\u003e and this map uses natural order, or its\n     *           comparator does not tolerate \u003ctt\u003enull\u003c/tt\u003e keys.\n     */\n    //@ requires ((this.root == null) || this.root.consistency()) \u0026\u0026 (this.size == this.realSize());\n    //@ ensures ((this.root == null) || this.root.consistency()) \u0026\u0026 (this.size == this.realSize());\n    public V remove(final int key) {\n        final Entry\u003cV\u003e p = getEntry(key);\n        if (p == null) {\n            return null;\n        }\n\n        final V oldValue = p.value;\n        deleteEntry(p);\n        return oldValue;\n    }\n\n    /** From CLR * */\n    private void rotateLeft(final Entry\u003cV\u003e p) {\n        final Entry\u003cV\u003e r = p.right;\n        p.right = r.left;\n        if (r.left != null) {\n            r.left.parent = p;\n        }\n        r.parent = p.parent;\n        if (p.parent == null) {\n            this.root = r;\n        } else if (p.parent.left == p) {\n            p.parent.left = r;\n        } else {\n            p.parent.right = r;\n        }\n        r.left = p;\n        p.parent = r;\n    }\n\n    /** From CLR * */\n    private void rotateRight(final Entry\u003cV\u003e p) {\n        final Entry\u003cV\u003e l = p.left;\n        p.left = l.right;\n        if (l.right != null) {\n            l.right.parent = p;\n        }\n        l.parent = p.parent;\n        if (p.parent == null) {\n            this.root = l;\n        } else if (p.parent.right == p) {\n            p.parent.right = l;\n        } else {\n            p.parent.left = l;\n        }\n        l.right = p;\n        p.parent = l;\n    }\n\n    /**\n     * Returns the number of key-value mappings in this map.\n     *\n     * @return the number of key-value mappings in this map.\n     */\n\n    public int size() {\n        return this.size;\n    }\n\n    /**\n     * Returns the successor of the specified Entry, or null if no such.\n     */\n    private Entry\u003cV\u003e successor(final Entry\u003cV\u003e t) {\n        if (t == null) {\n            return null;\n        } else if (t.right != null) {\n            Entry\u003cV\u003e p = t.right;\n            while (p.left != null) {\n                p = p.left;\n            }\n            return p;\n        } else {\n            Entry\u003cV\u003e p = t.parent;\n            Entry\u003cV\u003e ch = t;\n            while ((p != null) \u0026\u0026 (ch == p.right)) {\n                ch = p;\n                p = p.parent;\n            }\n            return p;\n        }\n    }\n\n    private boolean valueSearchNonNull(final Entry\u003cV\u003e n, final Object value) {\n        // Check this node for the value\n        if (value.equals(n.value)) {\n            return true;\n        }\n\n        // Check left and right subtrees for value\n        return ((n.left != null) \u0026\u0026 valueSearchNonNull(n.left, value))\n                || ((n.right != null) \u0026\u0026 valueSearchNonNull(n.right, value));\n    }\n\n    private boolean valueSearchNull(final Entry\u003cV\u003e n) {\n        if (n.value == null) {\n            return true;\n        }\n\n        // Check left and right subtrees for value\n        return ((n.left != null) \u0026\u0026 valueSearchNull(n.left))\n                || ((n.right != null) \u0026\u0026 valueSearchNull(n.right));\n    }\n\n}\n",
        "name": "TreeMap.java",
        "path": "kex-test/src/main/kotlin/org/vorpal/research/kex/test/javadebug/TreeMap.java",
        "url": "/github.com/vorpal-research/kex/-/blob/kex-test/src/main/kotlin/org/vorpal/research/kex/test/javadebug/TreeMap.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 636,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires ((this.root == null) || this.root.consistency()) \u0026\u0026 (this.size == this.realSize());"
        },
        {
          "limitHit": false,
          "lineNumber": 637,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 698,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires ((this.root == null) || this.root.consistency()) \u0026\u0026 (this.size == this.realSize());"
        },
        {
          "limitHit": false,
          "lineNumber": 699,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 704,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires ((this.root == null) || this.root.consistency()) \u0026\u0026 (this.size == this.realSize());"
        },
        {
          "limitHit": false,
          "lineNumber": 705,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures ((this.root != null) \u0026\u0026 this.root.consistency());"
        },
        {
          "limitHit": false,
          "lineNumber": 785,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires ((this.root == null) || this.root.consistency()) \u0026\u0026 (this.size == this.realSize());"
        },
        {
          "limitHit": false,
          "lineNumber": 786,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures ((this.root == null) || this.root.consistency()) \u0026\u0026 (this.size == this.realSize());"
        }
      ],
      "repository": {
        "name": "github.com/vorpal-research/kex",
        "url": "/github.com/vorpal-research/kex"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 8,
  "ElapsedMilliseconds": 2905,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
