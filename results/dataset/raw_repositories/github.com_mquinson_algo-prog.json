{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/mquinson/algo-prog lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ef516995edf39ba4a3e325e401bac3c5733e2a37"
        },
        "content": "/* -*- coding: utf-8 -*-  */\n/**\n * Cette classe décrit une pyramide d'entiers\n * @author Martine Gautier  Faculté des Sciences - UHP Nancy I\n * @author Martin Quinson ESIAL - UHP Nancy I\n * @version Janvier 2006\n */   \npackage pyramide ;\npublic class Pyramide {\n\n    /* **********\n     * * Champs *\n     * **********/\n    protected int hauteur;\n    protected int[] elements;\n\n\n    /* *****************\n     * * Constructeurs *\n     * *****************/\n\n    /** Construire une pyramide de hauteur donnée\n     *  @param h hauteur de la pyramide\n     */\n    //@ requires h \u003e= 1 ;\n    //@ ensures hauteur() == h ;\n    public Pyramide (int h) {\n        hauteur = h;\n        int nbElements = (hauteur *(hauteur + 1))/2;\n        elements = new int [nbElements];\n    } // Pyramide(int)  \n\n\n    /* ****************************\n     * * Opérations d'observation *\n     * ****************************/\n\n    /** @return hauteur de la pyramide */\n    public /*@pure@*/ int hauteur(){\n        return hauteur ;\n    } \n\n    /** @return le nombre de cases de la pyramide */\n    public /*@pure@*/ int count(){\n        return elements.length ;\n    }\n\n    /** @return une chaine représentant graphiquement la pyramide */\n    public String toString(){\n        String res = \"Pyramide de hauteur \"+hauteur()+\"\\n\";\n        for (int ligne=1; ligne \u003c= hauteur(); ligne++) {\n            for (int colonne=ligne; colonne \u003c= hauteur(); colonne++) {\n                res += valueAt(ligne, colonne)+\" \" ;\n            }\n            res += \"\\n\";\n            for (int nb_blancs=1 ; nb_blancs\u003c=ligne ; nb_blancs++) \n                res+=\" \";\n        }\n        return res;\n    } // toString()\n\n\n\n    /** @return l'indice correspondant à la ligne lig et la diagonale diag */\n    //@ requires lig \u003e= 1 \u0026\u0026 lig \u003c= hauteur() \n    //@          \u0026\u0026 diag \u003e= lig \u0026\u0026 diag \u003c= hauteur();\n    private  /*@pure@*/ int indice(int lig, int diag){\n        /* BEGINKILL */\n        return (diag * (diag - 1 ) / 2 + lig - 1);\n        /* ENDKILL */\n    } \n\n    /** @return l'entier situé en ligne lig et diagonale diag */\n    //@ requires lig \u003e= 1 \u0026\u0026 lig \u003c= hauteur()\n    //@          \u0026\u0026 diag \u003e= lig \u0026\u0026 diag \u003c= hauteur() ;\n    private  /*@pure@*/ int valueAt(int lig, int diag){\n        return (elements[indice(lig,diag)]);\n    }\n\n    /* Range v en ligne lig et diagonale diag */\n    //@ requires nombreAutorise(v) \u0026\u0026 lig\u003e=1 \u0026\u0026 lig\u003c=hauteur() \n    //@          \u0026\u0026  diag\u003e=lig \u0026\u0026 diag\u003c=hauteur();\n    //@ ensures valueAt(lig,diag) == v ;\n    private void setValueAt(int v, int lig, int diag){\n        elements[indice(lig,diag)] = v;\n    }\n\n    /* *****************************\n     * * Pour tester la correction *\n     * *****************************/\n\n    /* Renvoi vrai si la pyramide est correctement construite\n     * \n     *  càd respecte les deux contraintes :\n     *   - contient tous les entiers entre 1 et count\n     *   - une case contient le nombre égal à la différence en valeur \n     *     absolue des valeurs des 2 cases situées juste au-dessus d'elle\n     */\n    public /*@ pure @*/ boolean correcte(){\n        return correcte(hauteur);\n    } \n\n    /* Renvoi vrai si la pyramide est correctement construite jusqu`à la diagonale diag */\n    //@ requires diag \u003e= 0 \u0026\u0026 diag \u003c= hauteur() ;\n    //@ ensures correcte() ;\n    private  /*@pure@*/ boolean correcte(int diag){\n        // Récursivité portant sur les diagonales de 1 à diag\n        /* BEGINKILL */\n        if (diag == 0)\n          return true;\n\n\n        for (int lig=1; lig\u003c=diag;lig++)\n          if (posCorrecte(lig,diag) == false)\n            return false;\n\n        return correcte(diag-1);\n        /* ENDKILL */\n    } // correcte(int)\n\n\n    /* Renvoi vrai si la position pointée est correcte */        \n    //@ requires lig \u003e= 1\u0026\u0026 lig \u003c= diag+1 \n    //@          \u0026\u0026 diag \u003e= 1 \u0026\u0026 diag \u003c= hauteur() ;\n    public  /*@pure@*/  boolean posCorrecte(int lig, int diag) {\n        /* BEGINKILL */\n        // Récursivité portant sur les lignes de 1 à lig\n        if (lig == diag + 1) \n            return true;\n\n        int nbre = valueAt(lig,diag);\n\n        /* jamais le droit de sortir de [1..count] */\n        if (!nombreAutorise(nbre)) \n            return false;\n\n        /* Aucune [autre] contrainte sur la premiere case */\n        if (lig == 1 \u0026\u0026 diag == 1)\n            return true;\n\n        /* il faut toujours être original */\n        if (contains(nbre,lig-1,diag)) \n            return false;\n\n        /* Il faut être la différence des ancêtres (sauf sur la première ligne) */\n        if (lig \u003e 1) {\n            int n1 = valueAt(lig-1,diag-1);\n            int n2 = valueAt(lig-1,diag);\n\n            if (nbre != Math.abs(n1 - n2) )\n                return false;\n        }\n\n        /* Tous les tests ont été passés avec succès */\n        return true;\n        /* ENDKILL */\n    } // posCorrecte(int, int)\n\n\n    /* Renvoie vrai si val est dans la pyramide avant la position (lig,diag) */\n    //@ requires lig \u003e= 1 \u0026\u0026 lig \u003c= hauteur() \n    //@          \u0026\u0026 diag \u003e= 1 \u0026\u0026 diag \u003c= hauteur();\n    private  /*@pure@*/ boolean contains(int val, int lig, int diag) {\n        /* On tient compte de l'implantation de la pyramide par soucis d'optimisation */\n\n        int fin = indice(lig,diag);\n        for (int i=0; i \u003c fin; i++) {\n\n            if (val == elements[i])\n                return true;\n        }\n\n        return false;\n    }//contains\n\n    /* Renvoi vrai si le nombre val est dans l'intervalle [ 1 .. count] */\n    private  /*@pure@*/ boolean nombreAutorise(int v){\n        return (v \u003e= 1 \u0026\u0026 v \u003c= count());\n    } \n\n\n\n    /* ********************************\n     * * Opérations de transformation *\n     * ********************************/\n\n    /* Remplir une pyramide de façon correcte */\n    //@ ensures correcte() ;\n    public void remplir(){\n        remplir(1);         // on commence a la diagonale 1\n    } \n\n    /* Remplir a partir de la diagonale diag */\n    //@ requires diag \u003e= 1 \u0026\u0026 diag \u003c= hauteur() + 1 \u0026\u0026 correcte(diag-1) ;\n    //@ ensures  (\\result \u0026\u0026 correcte()) || !\\result  ;  \n    private boolean remplir(int diag){\n        /* BEGINKILL */\n        // Itération conditionnelle parcourt le domaine [count .. 1]\n        // Arret lorsqu'une solution est trouvee\n\n        if (diag \u003e hauteur) \n            return true;\n\n        for (int k=count(); k\u003e=1; k--) {\n\n            // si k est déjà utilisé, on passe au tour de boucle suivant\n            if (!contains(k,1,diag)) {\n\n                // Essayer de propager k sur la diagonale\n\n                if (propager(diag,k)) {\n                    // La propagation a été faite, on essaie de remplir la suite\n                    if (remplir(diag+1)) {\n                        // L'appel récursif est une réussite : on tient une solution\n                        return true;\n                    }\n                }\n              \n            } // k n'est pas encore pris\n        }\n        return false;\n        /* ENDKILL */\n    }//remplir(int)\n\n\n    /*\n     * si la propagation de val est possible sur la diagonale diag\n     * modifie elements en conséquence et renvoie vrai.\n     * si la propagation ne peut pas se faire, renvoie faux\n     *\n     *   FIXME: on peut utiliser \\ensure \\forall ici.\n     *\n     */ \n    //@ requires diag \u003e= 1 \u0026\u0026 diag \u003c= hauteur() \u0026\u0026 val \u003e= 1 \u0026\u0026 val \u003c= count();\n    //@ ensures !\\result  || (\\result \u0026\u0026 posCorrecte(diag,diag)) ;\n    private boolean propager(int diag, int val){\n        // On pose val en haut de la diagonale\n        setValueAt(val,1,diag);\n\n        // On essaie de propager sur le reste de la diagonale\n\n        /* BEGINKILL */\n        // Itération conditionnelle portant sur le domaine [ 2 .. diag ]\n        // On s'arrête dès que les contraintes ne sont plus respectées\n\n        int nbre = val;\n        for (int lig=2; lig \u003c= diag; lig++) {\n            /** invariant\n                -- la diagonale diag est \u003c\u003cbien construite\u003e\u003e jusqu'en lig-1\n                diagonale_correcte(lig-1,diag)\n            **/\n            /** variant         diag - lig  **/\n            nbre -= valueAt(lig-1,diag-1);    // économise les accès au tableau\n            nbre = Math.abs(nbre);\n            // On s'assure que le nombre ainsi calculé n'est pas déjà utilisé\n            if (contains(nbre,lig,diag))\n                return false;\n\n            // Le nombre n'est pas utilisé; on le pose et on continue\n            setValueAt(nbre,lig,diag);\n\n        }\n        return true;\n        /* ENDKILL */\n    }//propager(int,int)\n\n\n} // class Pyramide\n",
        "name": "Pyramide.java",
        "path": "TD/04-tdp-pyramides/java/old/Pyramide.java",
        "url": "/github.com/mquinson/algo-prog/-/blob/TD/04-tdp-pyramides/java/old/Pyramide.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 24,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires h \u003e= 1 ;"
        },
        {
          "limitHit": false,
          "lineNumber": 25,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures hauteur() == h ;"
        },
        {
          "limitHit": false,
          "lineNumber": 64,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires lig \u003e= 1 \u0026\u0026 lig \u003c= hauteur() "
        },
        {
          "limitHit": false,
          "lineNumber": 73,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires lig \u003e= 1 \u0026\u0026 lig \u003c= hauteur()"
        },
        {
          "limitHit": false,
          "lineNumber": 80,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires nombreAutorise(v) \u0026\u0026 lig\u003e=1 \u0026\u0026 lig\u003c=hauteur() "
        },
        {
          "limitHit": false,
          "lineNumber": 82,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures valueAt(lig,diag) == v ;"
        },
        {
          "limitHit": false,
          "lineNumber": 103,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires diag \u003e= 0 \u0026\u0026 diag \u003c= hauteur() ;"
        },
        {
          "limitHit": false,
          "lineNumber": 104,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures correcte() ;"
        },
        {
          "limitHit": false,
          "lineNumber": 122,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires lig \u003e= 1\u0026\u0026 lig \u003c= diag+1 "
        },
        {
          "limitHit": false,
          "lineNumber": 160,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires lig \u003e= 1 \u0026\u0026 lig \u003c= hauteur() "
        },
        {
          "limitHit": false,
          "lineNumber": 187,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures correcte() ;"
        },
        {
          "limitHit": false,
          "lineNumber": 193,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires diag \u003e= 1 \u0026\u0026 diag \u003c= hauteur() + 1 \u0026\u0026 correcte(diag-1) ;"
        },
        {
          "limitHit": false,
          "lineNumber": 233,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires diag \u003e= 1 \u0026\u0026 diag \u003c= hauteur() \u0026\u0026 val \u003e= 1 \u0026\u0026 val \u003c= count();"
        },
        {
          "limitHit": false,
          "lineNumber": 234,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures !\\result  || (\\result \u0026\u0026 posCorrecte(diag,diag)) ;"
        },
        {
          "limitHit": false,
          "lineNumber": 194,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  (\\result \u0026\u0026 correcte()) || !\\result  ;  "
        }
      ],
      "repository": {
        "name": "github.com/mquinson/algo-prog",
        "url": "/github.com/mquinson/algo-prog"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ef516995edf39ba4a3e325e401bac3c5733e2a37"
        },
        "content": "/* -*- coding: utf-8 -*-  */\n/**\n * Cette classe décrit une pyramide d'entiers\n * @author Martine Gautier  Faculté des Sciences - UHP Nancy I\n * @author Martin Quinson ESIAL - UHP Nancy I\n * @version Janvier 2006\n */   \npackage pyramide ;\npublic class PyramideVite {\n\n    /* **********\n     * * Champs *\n     * **********/\n    protected int hauteur;\n    protected int[] elements;\n    protected boolean[] nbPris;\n\n\n    /* *****************\n     * * Constructeurs *\n     * *****************/\n\n    /** Construire une pyramide de hauteur donnée\n     *  @param h hauteur de la pyramide \n     */\n    //@ requires h \u003e= 1 ;\n    //@ ensures hauteur() == h ;\n\n    public PyramideVite (int h) {\n\thauteur = h;\n\tint nbElements = (hauteur *(hauteur + 1))/2;\n\telements = new int [nbElements];\n\n\tnbPris = new boolean [nbElements];\n\tfor (int i=0; i\u003cnbElements; i++)\n\t    nbPris[i]=false;\n    } // Pyramide(int)  \n\n\n    /* ****************************\n     * * Opérations d'observation *\n     * ****************************/\n\n    /** @return hauteur de la pyramide */\n    public /*@pure@*/ int hauteur(){\n\treturn hauteur ;\n    } \n\n    /** @return le nombre de cases de la pyramide */\n    public /*@pure@*/ int count(){\n\treturn elements.length ;\n    }\n\n    /** @return une chaine représentant graphiquement la pyramide */\n    public String toString(){\n\tString res = \"Pyramide de hauteur \"+hauteur()+\"\\n\";\n\tfor (int ligne=1; ligne \u003c= hauteur(); ligne++) {\n\t    for (int colonne=ligne; colonne \u003c= hauteur(); colonne++) {\n\t\tres += valueAt(ligne, colonne)+\" \" ;\n\t    }\n\t    res += \"\\n\";\n\t    for (int nb_blancs=1 ; nb_blancs\u003c=ligne ; nb_blancs++) \n\t\tres+=\" \";\n\t}\n\treturn res;\n    } // toString()\n\n\n    /** @return l'entier situé en ligne lig et diagonale diag */\n    //@ requires lig \u003e= 1 \u0026\u0026 lig \u003c= hauteur() \u0026\u0026 diag \u003e= lig \u0026\u0026 diag \u003c= hauteur() ;\n    private  /*@pure@*/ int valueAt(int lig, int diag){\n\treturn (elements[indice(lig,diag)]);\n    }\n\n    /** @return l'indice correspondant à la ligne lig et la diagonale diag */\n    //@ requires lig \u003e= 1 \u0026\u0026 lig \u003c= hauteur() \u0026\u0026 diag \u003e= lig \u0026\u0026 diag \u003c= hauteur();\n    private  /*@pure@*/ int indice(int lig, int diag){\n        return (diag * (diag - 1 ) / 2 + lig - 1);\n    } \n\n    /* *****************************\n     * * Pour tester la correction *\n     * *****************************/\n\n    /** @return vrai si la pyramide est correctement construite\n     * \n     *  càd respecte les deux contraintes :\n     *   - contient tous les entiers entre 1 et count\n     *   - une case contient le nombre égal à la différence en valeur \n     *     absolue des valeurs des 2 cases situées juste au-dessus d'elle\n     */\n    public /*@ pure @*/ boolean correcte(){\n\treturn correcte(hauteur);\n    } \n\n    /** @return vrai si la pyramide est correctement construite jusqu`à la diagonale diag */\n    //@ requires diag \u003e= 0 \u0026\u0026 diag \u003c= hauteur() ;\n    //@ ensures correcte() ;\n    private  /*@pure@*/ boolean correcte(int diag){\n\t// Récursivité portant sur les diagonales de 1 à diag\n\treturn ((diag == 0) || \n\t\t(diagonaleCorrecte(diag,diag) \u0026\u0026 correcte(diag-1)));\n    } // correcte(int)\n\n\n    /** @return vrai si la diagonale diag est correcte jusqu'à la ligne lig */\n    //@ requires lig \u003e= 1\u0026\u0026 lig \u003c= diag+1 \u0026\u0026 diag \u003e= 1 \u0026\u0026 diag \u003c= hauteur() ;\n    public  /*@pure@*/  boolean diagonaleCorrecte(int lig, int diag) {\n\t// Récursivité portant sur les lignes de 1 à lig\n\tif (lig == diag + 1) \n\t    return true;\n\n\tint nbre = valueAt(lig,diag);\n\n\t/* jamais le droit de sortir de [1..count] */\n\tif (!nombreAutorise(nbre)) {\n\t    System.out.println(\"Nombre invalide \"+nbre);\n\t    return false;\n\t}\n\n\t/* Aucune [autre] contrainte sur la premiere case */\n\tif (lig == 1 \u0026\u0026 diag == 1)\n\t    return true;\n\n\t/* il faut toujours être original */\n\tif (contains(nbre,lig-1,diag)) {\n\t    System.out.println(\"Nombre duppliqué \"+nbre);\n\t    return false;\n\t}\n\n\t/* Il faut être la différence des ancêtres (sauf sur la première ligne) */\n\tif (lig \u003e 1) {\n\t    int n1 = valueAt(lig-1,diag-1);\n\t    int n2 = valueAt(lig-1,diag);\n\n\t    if (nbre != Math.abs(n1 - n2) ) {\n\t\tSystem.out.println(\"soustraction ratée \"+nbre);\n\t\treturn false;\n\t    }\n\t}\n\n\t/* Tous les tests ont été passés avec succès */\n\treturn true;\n    } // diagonaleCorrecte(int, int)\n\n\n    /** @return vrai si val est dans la pyramide avant la position (lig,diag) */\n    private  /*@pure@*/ boolean contains(int val) {\n\t//\tSystem.out.println(\"Verifie \"+val);\n\treturn nbPris[val-1];\n    }\n\n    /** @return vrai si val est dans la pyramide avant la position (lig,diag) */\n    //@ requires lig \u003e= 1 \u0026\u0026 lig \u003c= hauteur() \u0026\u0026 diag \u003e= 1 \u0026\u0026 diag \u003c= hauteur();\n    private  /*@pure@*/ boolean contains(int val, int lig, int diag) {\n\t/* On tient compte de l'implantation de la pyramide par soucis d'optimisation */\n\n\tint fin = indice(lig,diag);\n\tfor (int i=0; i \u003c fin; i++) {\n\n\t    if (val == elements[i])\n\t\treturn true;\n\t}\n\n\treturn false;\n    }//contains\n\n    /** @return vrai si le nombre val est dans l'intervalle [ 1 .. count] */\n    private  /*@pure@*/ boolean nombreAutorise(int v){\n\treturn (v \u003e= 1 \u0026\u0026 v \u003c= count());\n    } \n\n\n\n    /* ********************************\n     * * Opérations de transformation *\n     * ********************************/\n    /* Range v en ligne lig et diagonale diag */\n    //@ requires nombreAutorise(v) \u0026\u0026 lig \u003e= 1 \n    //@          \u0026\u0026 lig \u003c= hauteur() \u0026\u0026  diag \u003e= lig \u0026\u0026 diag \u003c= hauteur() ;\n    //@ ensures valueAt(lig,diag) == v ;\n    private void setValueAt(int v, int lig, int diag){\n\telements[indice(lig,diag)] = v;\n\tnbPris[v-1] = true;\n    }//setValueAt\n\n    private void unsetValueAt(int lig, int diag){\n\tint id = indice(lig,diag);\n\tnbPris[elements[id] -1] = false;\n\telements[id]=0;\n\t\n    }//unsetValueAt\n\n\n    /** Remplir une pyramide de façon correcte */\n    //@ ensures correcte() ;\n    public void remplir(){\n\tremplir(1); \t// on commence a la diagonale 1\n    } \n\n    /** Remplir a partir de la diagonale diag */\n    //@ requires diag \u003e= 1 \u0026\u0026 diag \u003c= hauteur() + 1 \u0026\u0026 correcte(diag-1);\n    //@ ensures  (\\result \u0026\u0026 correcte()) || !\\result  ;\n    private boolean remplir(int diag){\n\t// Itération conditionnelle parcourt le domaine [count .. 1]\n        // Arret lorsqu'une solution est trouvee\n\n\tif (diag \u003e hauteur) \n\t    return true;\n\n\tfor (int k=count(); k\u003e=1; k--) {\n\n\t    // si k est déjà utilisé, on passe au tour de boucle suivant\n\t    if (!contains(k)) {\n\n\t\t// Essayer de propager k sur la diagonale\n\n\t\tif (propager(diag,k)) {\n\t\t    // La propagation a été faite, on essaie de remplir la suite\n\t\t    if (remplir(diag+1)) {\n\t\t\t// L'appel récursif est une réussite : on tient une solution\n\t\t\treturn true;\n\t\t    }\n\t\t}\n\t      \n\t    } // k n'est pas encore pris\n        }//while\n\treturn false;\n    }//remplir(int)\n\n    //---------------------------------------------\n    /**\n     * si la propagation de val est possible sur la diagonale diag\n     * modifie elements en conséquence et renvoie vrai.\n     * si la propagation ne peut pas se faire, renvoie faux\n     */ \n    //@ requires diag \u003e= 1 \u0026\u0026 diag \u003c= hauteur() \u0026\u0026 val \u003e= 1 \u0026\u0026 val \u003c= count();\n    //@ ensures (!\\result)  || (\\result \u0026\u0026 diagonaleCorrecte(diag,diag)) ;\n    private boolean propager(int diag, int val){\n\t// On pose val en haut de la diagonale\n        setValueAt(val,1,diag);\n\n        // On essaie de propager sur le reste de la diagonale\n\n        // Itération conditionnelle portant sur le domaine [ 2 .. diag ]\n        // On s'arrête dès que les contraintes ne sont plus respectées\n\n\tint lig = 2;\n\tint nbre = val;\n\twhile (lig \u003c= diag) {\n\t    /** invariant\n\t\t-- la diagonale diag est \u003c\u003cbien construite\u003e\u003e jusqu'en lig-1\n\t\tdiagonaleCorrecte(lig-1,diag)\n\t    **/\n\t    /** variant         diag - lig  **/\n\n\t    nbre -= valueAt(lig-1,diag-1);    // évite deux accès dans elements\n\t    nbre = Math.abs(nbre);\n            // On s'assure que le nombre ainsi calculé n'est pas déjà utilisé\n\t    if (contains(nbre)) {\n\t\tlig--;\n\t\twhile (lig\u003e=1) {\n\t\t    unsetValueAt(lig,diag);\n\t\t    lig--;\n\t\t}\n\t\treturn false;\n\t    }\n\n\t    // Le nombre n'est pas utilisé; on le pose et on continue\n\t    setValueAt(nbre,lig,diag);\n\t    lig++;\n\t}//while\n\treturn true;\n    }//propager(int,int)\n\n    //---------------------------------------------\n\n\n    /**\n       invariant\n       hauteur \u003e= 1;\n       count = (hauteur *(hauteur + 1))//2;\n\n       -- de representation\n       elements.upper = count\n\n    **/\n\n} // class Pyramide\n \n\t       \n\t    \n\t    \n\t    \n\n\t    \n\t    \n",
        "name": "PyramideVite.java",
        "path": "TD/04-tdp-pyramides/java/old/PyramideVite.java",
        "url": "/github.com/mquinson/algo-prog/-/blob/TD/04-tdp-pyramides/java/old/PyramideVite.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 25,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires h \u003e= 1 ;"
        },
        {
          "limitHit": false,
          "lineNumber": 26,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures hauteur() == h ;"
        },
        {
          "limitHit": false,
          "lineNumber": 69,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires lig \u003e= 1 \u0026\u0026 lig \u003c= hauteur() \u0026\u0026 diag \u003e= lig \u0026\u0026 diag \u003c= hauteur() ;"
        },
        {
          "limitHit": false,
          "lineNumber": 75,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires lig \u003e= 1 \u0026\u0026 lig \u003c= hauteur() \u0026\u0026 diag \u003e= lig \u0026\u0026 diag \u003c= hauteur();"
        },
        {
          "limitHit": false,
          "lineNumber": 96,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires diag \u003e= 0 \u0026\u0026 diag \u003c= hauteur() ;"
        },
        {
          "limitHit": false,
          "lineNumber": 97,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures correcte() ;"
        },
        {
          "limitHit": false,
          "lineNumber": 106,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires lig \u003e= 1\u0026\u0026 lig \u003c= diag+1 \u0026\u0026 diag \u003e= 1 \u0026\u0026 diag \u003c= hauteur() ;"
        },
        {
          "limitHit": false,
          "lineNumber": 153,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires lig \u003e= 1 \u0026\u0026 lig \u003c= hauteur() \u0026\u0026 diag \u003e= 1 \u0026\u0026 diag \u003c= hauteur();"
        },
        {
          "limitHit": false,
          "lineNumber": 178,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires nombreAutorise(v) \u0026\u0026 lig \u003e= 1 "
        },
        {
          "limitHit": false,
          "lineNumber": 180,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures valueAt(lig,diag) == v ;"
        },
        {
          "limitHit": false,
          "lineNumber": 195,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures correcte() ;"
        },
        {
          "limitHit": false,
          "lineNumber": 201,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires diag \u003e= 1 \u0026\u0026 diag \u003c= hauteur() + 1 \u0026\u0026 correcte(diag-1);"
        },
        {
          "limitHit": false,
          "lineNumber": 236,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires diag \u003e= 1 \u0026\u0026 diag \u003c= hauteur() \u0026\u0026 val \u003e= 1 \u0026\u0026 val \u003c= count();"
        },
        {
          "limitHit": false,
          "lineNumber": 237,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures (!\\result)  || (\\result \u0026\u0026 diagonaleCorrecte(diag,diag)) ;"
        },
        {
          "limitHit": false,
          "lineNumber": 202,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  (\\result \u0026\u0026 correcte()) || !\\result  ;"
        }
      ],
      "repository": {
        "name": "github.com/mquinson/algo-prog",
        "url": "/github.com/mquinson/algo-prog"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "ef516995edf39ba4a3e325e401bac3c5733e2a37"
        },
        "content": "/** Classe implémentant une solution au problème du sac à dos.\n *\n * Elle peut également être utilisée pour manipuler des solutions partielles \n *(ie, en cours de construction).\n */\n\npublic class KnapsackSolution {\n    /** pour chaque objet i, il est dans le sac à dos ssi pris[i] est vrai */\n    private boolean [] pris;\n    /** valeur totale du contenu du sac */\n    private int valeurTotale;\n\n    /** valeurs de chaque objet (dans un tableau).\n     * Pratique pour les methodes prendObjet et poseObjet */\n    private int valeur[];\n\n    /******************************************/\n    /*** Constructeur et fonctions basiques ***/\n\n    /* Initialise une solution à partir de l'instance du problème passée en paramètre */\n    public KnapsackSolution(int valeur[]) {\n\tpris = new boolean[valeur.length];\n\n\tfor (int i=0; i\u003cpris.length; i++) \n\t    pris[i]=false;\n\n\tvaleurTotale = 0;\n\tthis.valeur = valeur;\t\n    }\n\n    /* un getter ou deux */\n    public boolean [] getPris() { return pris; }\n    public /*@pure@*/ boolean getPris(int i) { return pris[i]; }\n    public /*@pure@*/ int getValeur() { return valeurTotale; }\n\n    public String toString() {\n\treturn toString(pris.length);\n    }\n\n    /* N'affiche que jusqu'à un certain objet (affiche une solution partielle) */\n    public String toString(int objMax) {\n\tString s = \"\";\n       //s += \"Solution Courante:  \";\n\tfor (int i=0; i\u003cobjMax; i++)\n\t    if (pris[i])\n\t\ts += \" O \";\n\t    else\n\t\ts += \" N \";\n        while (s.length() \u003c valeur.length*3) \n\t  s+= \"...\";\n\ts += \"; Valeur: \" + valeurTotale;\n\treturn s;\n    }\n\n\n    /***********************************/\n    /*** Methodes d'usage et d'acces ***/\n\n    //@ requires !getPris(i) ;\n    public void prendObjet(int i)   { \n\tpris[i] = true; \n\tvaleurTotale += valeur[i];\n    }\n    //@ requires getPris(i) ;\n    public void poseObjet(int i) {\n\tpris[i] = false; \n\tvaleurTotale -= valeur[i];\n    }\n\n    /**************************/\n    /*** Fonctions avancées ***/\n\n    /* Crée une copie de l'objet courant */\n    public KnapsackSolution duplique() {\n\tKnapsackSolution res = new KnapsackSolution(valeur);\n\tfor (int i=0; i\u003cvaleur.length; i++) {\n\t    if (pris[i]) {\n\t\tres.prendObjet(i);\n\t    }\n\t}\n\treturn res;\n    }\n}\n",
        "name": "KnapsackSolution.java",
        "path": "TD/03-tdp-dicho-knapsack/src/knap/KnapsackSolution.java",
        "url": "/github.com/mquinson/algo-prog/-/blob/TD/03-tdp-dicho-knapsack/src/knap/KnapsackSolution.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 58,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires !getPris(i) ;"
        },
        {
          "limitHit": false,
          "lineNumber": 63,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires getPris(i) ;"
        }
      ],
      "repository": {
        "name": "github.com/mquinson/algo-prog",
        "url": "/github.com/mquinson/algo-prog"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 32,
  "ElapsedMilliseconds": 598,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
