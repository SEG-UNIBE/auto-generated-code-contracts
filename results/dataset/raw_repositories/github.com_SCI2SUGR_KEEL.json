{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/SCI2SUGR/KEEL lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "/***********************************************************************\r\n\r\n\tThis file is part of KEEL-software, the Data Mining tool for regression, \r\n\tclassification, clustering, pattern mining and so on.\r\n\r\n\tCopyright (C) 2004-2010\r\n\t\r\n\tF. Herrera (herrera@decsai.ugr.es)\r\n    L. Sánchez (luciano@uniovi.es)\r\n    J. Alcalá-Fdez (jalcala@decsai.ugr.es)\r\n    S. García (sglopez@ujaen.es)\r\n    A. Fernández (alberto.fernandez@ujaen.es)\r\n    J. Luengo (julianlm@decsai.ugr.es)\r\n\r\n\tThis program is free software: you can redistribute it and/or modify\r\n\tit under the terms of the GNU General Public License as published by\r\n\tthe Free Software Foundation, either version 3 of the License, or\r\n\t(at your option) any later version.\r\n\r\n\tThis program is distributed in the hope that it will be useful,\r\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\tGNU General Public License for more details.\r\n\r\n\tYou should have received a copy of the GNU General Public License\r\n\talong with this program.  If not, see http://www.gnu.org/licenses/\r\n  \r\n**********************************************************************/\r\n\r\n/*\r\n *    This program is free software; you can redistribute it and/or modify\r\n *    it under the terms of the GNU General Public License as published by\r\n *    the Free Software Foundation; either version 2 of the License, or\r\n *    (at your option) any later version.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU General Public License\r\n *    along with this program; if not, write to the Free Software\r\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\r\n */\r\n\r\n/*\r\n *    Utils.java\r\n *    Copyright (C) 1999-2004 University of Waikato, Hamilton, New Zealand\r\n *\r\n */\r\n\r\npackage keel.Algorithms.SVM.SMO.core;\r\n\r\nimport java.lang.Math;\r\nimport java.lang.reflect.Array;\r\nimport java.util.Properties;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.util.Random;\r\n\r\n/**\r\n * Class implementing some simple utility methods.\r\n *\r\n * @author Eibe Frank \r\n * @author Yong Wang \r\n * @author Len Trigg \r\n * @author Julien Prados\r\n * @version $Revision: 1.1 $\r\n */\r\npublic final class Utils {\r\n\r\n  /** The natural logarithm of 2. */\r\n  public static double log2 = Math.log(2);\r\n\r\n  /** The small deviation allowed in double comparisons */\r\n  public static double SMALL = 1e-6;\r\n\r\n  \r\n  /**\r\n   * Reads properties that inherit from three locations. Properties\r\n   * are first defined in the system resource location (i.e. in the\r\n   * CLASSPATH).  These default properties must exist. Properties\r\n   * defined in the users home directory (optional) override default\r\n   * settings. Properties defined in the current directory (optional)\r\n   * override all these settings.\r\n   *\r\n   * @param resourceName the location of the resource that should be\r\n   * loaded.  e.g.: \"weka/core/Utils.props\". (The use of hardcoded\r\n   * forward slashes here is OK - see\r\n   * jdk1.1/docs/guide/misc/resources.html) This routine will also\r\n   * look for the file (in this case) \"Utils.props\" in the users home\r\n   * directory and the current directory.\r\n   * @return the Properties\r\n   * @exception Exception if no default properties are defined, or if\r\n   * an error occurs reading the properties files.  \r\n   */\r\n  public static Properties readProperties(String resourceName)\r\n    throws Exception {\r\n\r\n    Properties defaultProps = new Properties();\r\n    try {\r\n      // Apparently hardcoded slashes are OK here\r\n      // jdk1.1/docs/guide/misc/resources.html\r\n      defaultProps.load(ClassLoader.getSystemResourceAsStream(resourceName));\r\n    } catch (Exception ex) {\r\n/*      throw new Exception(\"Problem reading default properties: \"\r\n\t+ ex.getMessage()); */\r\n      System.err.println(\"Warning, unable to load properties file from \"\r\n\t\t\t +\"system resource (Utils.java)\");\r\n    }\r\n\r\n    // Hardcoded slash is OK here\r\n    // eg: see jdk1.1/docs/guide/misc/resources.html\r\n    int slInd = resourceName.lastIndexOf('/');\r\n    if (slInd != -1) {\r\n      resourceName = resourceName.substring(slInd + 1);\r\n    }\r\n\r\n    // Allow a properties file in the home directory to override\r\n    Properties userProps = new Properties(defaultProps);    \r\n    File propFile = new File(System.getProperties().getProperty(\"user.home\")\r\n                             + File.separatorChar\r\n                             + resourceName);\r\n    if (propFile.exists()) {\r\n      try {\r\n        userProps.load(new FileInputStream(propFile));\r\n      } catch (Exception ex) {\r\n        throw new Exception(\"Problem reading user properties: \" + propFile);\r\n      }\r\n    }\r\n\r\n    // Allow a properties file in the current directory to override\r\n    Properties localProps = new Properties(userProps);\r\n    propFile = new File(resourceName);\r\n    if (propFile.exists()) {\r\n      try {\r\n        localProps.load(new FileInputStream(propFile));\r\n      } catch (Exception ex) {\r\n        throw new Exception(\"Problem reading local properties: \" + propFile);\r\n      }\r\n    }\r\n    \r\n    return localProps;\r\n  }\r\n\r\n  /**\r\n   * Returns the correlation coefficient of two double vectors.\r\n   *\r\n   * @param y1 double vector 1\r\n   * @param y2 double vector 2\r\n   * @param n the length of two double vectors\r\n   * @return the correlation coefficient\r\n   */\r\n  public static final double correlation(double y1[],double y2[],int n) {\r\n\r\n    int i;\r\n    double av1 = 0.0, av2 = 0.0, y11 = 0.0, y22 = 0.0, y12 = 0.0, c;\r\n    \r\n    if (n \u003c= 1) {\r\n      return 1.0;\r\n    }\r\n    for (i = 0; i \u003c n; i++) {\r\n      av1 += y1[i];\r\n      av2 += y2[i];\r\n    }\r\n    av1 /= (double) n;\r\n    av2 /= (double) n;\r\n    for (i = 0; i \u003c n; i++) {\r\n      y11 += (y1[i] - av1) * (y1[i] - av1);\r\n      y22 += (y2[i] - av2) * (y2[i] - av2);\r\n      y12 += (y1[i] - av1) * (y2[i] - av2);\r\n    }\r\n    if (y11 * y22 == 0.0) {\r\n      c=1.0;\r\n    } else {\r\n      c = y12 / Math.sqrt(Math.abs(y11 * y22));\r\n    }\r\n    \r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * Removes all occurrences of a string from another string.\r\n   *\r\n   * @param inString the string to remove substrings from.\r\n   * @param substring the substring to remove.\r\n   * @return the input string with occurrences of substring removed.\r\n   */\r\n  public static String removeSubstring(String inString, String substring) {\r\n\r\n    StringBuffer result = new StringBuffer();\r\n    int oldLoc = 0, loc = 0;\r\n    while ((loc = inString.indexOf(substring, oldLoc))!= -1) {\r\n      result.append(inString.substring(oldLoc, loc));\r\n      oldLoc = loc + substring.length();\r\n    }\r\n    result.append(inString.substring(oldLoc));\r\n    return result.toString();\r\n  }\r\n\r\n  /**\r\n   * Replaces with a new string, all occurrences of a string from \r\n   * another string.\r\n   *\r\n   * @param inString the string to replace substrings in.\r\n   * @param subString the substring to replace.\r\n   * @param replaceString the replacement substring\r\n   * @return the input string with occurrences of substring replaced.\r\n   */\r\n  public static String replaceSubstring(String inString, String subString,\r\n\t\t\t\t\tString replaceString) {\r\n\r\n    StringBuffer result = new StringBuffer();\r\n    int oldLoc = 0, loc = 0;\r\n    while ((loc = inString.indexOf(subString, oldLoc))!= -1) {\r\n      result.append(inString.substring(oldLoc, loc));\r\n      result.append(replaceString);\r\n      oldLoc = loc + subString.length();\r\n    }\r\n    result.append(inString.substring(oldLoc));\r\n    return result.toString();\r\n  }\r\n\r\n\r\n  /**\r\n   * Pads a string to a specified length, inserting spaces on the left\r\n   * as required. If the string is too long, characters are removed (from\r\n   * the right).\r\n   *\r\n   * @param inString the input string\r\n   * @param length the desired length of the output string\r\n   * @return the output string\r\n   */\r\n  public static String padLeft(String inString, int length) {\r\n\r\n    return fixStringLength(inString, length, false);\r\n  }\r\n  \r\n  /**\r\n   * Pads a string to a specified length, inserting spaces on the right\r\n   * as required. If the string is too long, characters are removed (from\r\n   * the right).\r\n   *\r\n   * @param inString the input string\r\n   * @param length the desired length of the output string\r\n   * @return the output string\r\n   */\r\n  public static String padRight(String inString, int length) {\r\n\r\n    return fixStringLength(inString, length, true);\r\n  }\r\n  \r\n  /**\r\n   * Pads a string to a specified length, inserting spaces as\r\n   * required. If the string is too long, characters are removed (from\r\n   * the right).\r\n   *\r\n   * @param inString the input string\r\n   * @param length the desired length of the output string\r\n   * @param right true if inserted spaces should be added to the right\r\n   * @return the output string\r\n   */\r\n  private static /*@pure@*/ String fixStringLength(String inString, int length,\r\n\t\t\t\t\tboolean right) {\r\n\r\n    if (inString.length() \u003c length) {\r\n      while (inString.length() \u003c length) {\r\n\tinString = (right ? inString.concat(\" \") : \" \".concat(inString));\r\n      }\r\n    } else if (inString.length() \u003e length) {\r\n      inString = inString.substring(0, length);\r\n    }\r\n    return inString;\r\n  }\r\n \r\n  /**\r\n   * Rounds a double and converts it into String.\r\n   *\r\n   * @param value the double value\r\n   * @param afterDecimalPoint the (maximum) number of digits permitted\r\n   * after the decimal point\r\n   * @return the double as a formatted string\r\n   */\r\n  public static /*@pure@*/ String doubleToString(double value, int afterDecimalPoint) {\r\n    \r\n    StringBuffer stringBuffer;\r\n    double temp;\r\n    int dotPosition;\r\n    long precisionValue;\r\n    \r\n    temp = value * Math.pow(10.0, afterDecimalPoint);\r\n    if (Math.abs(temp) \u003c Long.MAX_VALUE) {\r\n      precisionValue = \t(temp \u003e 0) ? (long)(temp + 0.5) \r\n                                   : -(long)(Math.abs(temp) + 0.5);\r\n      if (precisionValue == 0) {\r\n\tstringBuffer = new StringBuffer(String.valueOf(0));\r\n      } else {\r\n\tstringBuffer = new StringBuffer(String.valueOf(precisionValue));\r\n      }\r\n      if (afterDecimalPoint == 0) {\r\n\treturn stringBuffer.toString();\r\n      }\r\n      dotPosition = stringBuffer.length() - afterDecimalPoint;\r\n      while (((precisionValue \u003c 0) \u0026\u0026 (dotPosition \u003c 1)) ||\r\n\t     (dotPosition \u003c 0)) {\r\n\tif (precisionValue \u003c 0) {\r\n\t  stringBuffer.insert(1, '0');\r\n\t} else {\r\n\t  stringBuffer.insert(0, '0');\r\n\t}\r\n\tdotPosition++;\r\n      }\r\n      stringBuffer.insert(dotPosition, '.');\r\n      if ((precisionValue \u003c 0) \u0026\u0026 (stringBuffer.charAt(1) == '.')) {\r\n\tstringBuffer.insert(1, '0');\r\n      } else if (stringBuffer.charAt(0) == '.') {\r\n\tstringBuffer.insert(0, '0');\r\n      }\r\n      int currentPos = stringBuffer.length() - 1;\r\n      while ((currentPos \u003e dotPosition) \u0026\u0026\r\n\t     (stringBuffer.charAt(currentPos) == '0')) {\r\n\tstringBuffer.setCharAt(currentPos--, ' ');\r\n      }\r\n      if (stringBuffer.charAt(currentPos) == '.') {\r\n\tstringBuffer.setCharAt(currentPos, ' ');\r\n      }\r\n      \r\n      return stringBuffer.toString().trim();\r\n    }\r\n    return new String(\"\" + value);\r\n  }\r\n\r\n  /**\r\n   * Rounds a double and converts it into a formatted decimal-justified String.\r\n   * Trailing 0's are replaced with spaces.\r\n   *\r\n   * @param value the double value\r\n   * @param width the width of the string\r\n   * @param afterDecimalPoint the number of digits after the decimal point\r\n   * @return the double as a formatted string\r\n   */\r\n  public static /*@pure@*/ String doubleToString(double value, int width,\r\n\t\t\t\t      int afterDecimalPoint) {\r\n    \r\n    String tempString = doubleToString(value, afterDecimalPoint);\r\n    char[] result;\r\n    int dotPosition;\r\n\r\n    if ((afterDecimalPoint \u003e= width) \r\n        || (tempString.indexOf('E') != -1)) { // Protects sci notation\r\n      return tempString;\r\n    }\r\n\r\n    // Initialize result\r\n    result = new char[width];\r\n    for (int i = 0; i \u003c result.length; i++) {\r\n      result[i] = ' ';\r\n    }\r\n\r\n    if (afterDecimalPoint \u003e 0) {\r\n      // Get position of decimal point and insert decimal point\r\n      dotPosition = tempString.indexOf('.');\r\n      if (dotPosition == -1) {\r\n\tdotPosition = tempString.length();\r\n      } else {\r\n\tresult[width - afterDecimalPoint - 1] = '.';\r\n      }\r\n    } else {\r\n      dotPosition = tempString.length();\r\n    }\r\n    \r\n\r\n    int offset = width - afterDecimalPoint - dotPosition;\r\n    if (afterDecimalPoint \u003e 0) {\r\n      offset--;\r\n    }\r\n\r\n    // Not enough room to decimal align within the supplied width\r\n    if (offset \u003c 0) {\r\n      return tempString;\r\n    }\r\n\r\n    // Copy characters before decimal point\r\n    for (int i = 0; i \u003c dotPosition; i++) {\r\n      result[offset + i] = tempString.charAt(i);\r\n    }\r\n\r\n    // Copy characters after decimal point\r\n    for (int i = dotPosition + 1; i \u003c tempString.length(); i++) {\r\n      result[offset + i] = tempString.charAt(i);\r\n    }\r\n\r\n    return new String(result);\r\n  }\r\n\r\n  /**\r\n   * Returns the basic class of an array class (handles multi-dimensional\r\n   * arrays).\r\n   * @param c        the array to inspect\r\n   * @return         the class of the innermost elements\r\n   */\r\n  public static Class getArrayClass(Class c) {\r\n     if (c.getComponentType().isArray())\r\n        return getArrayClass(c.getComponentType());\r\n     else\r\n        return c.getComponentType();\r\n  }\r\n\r\n  /**\r\n   * Returns the dimensions of the given array. Even though the\r\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\r\n   * int[3] or double[2][4].\r\n   *\r\n   * @param array       the array to determine the dimensions for\r\n   * @return            the dimensions of the array\r\n   */\r\n  public static int getArrayDimensions(Class array) {\r\n    if (array.getComponentType().isArray())\r\n      return 1 + getArrayDimensions(array.getComponentType());\r\n    else\r\n      return 1;\r\n  }\r\n\r\n  /**\r\n   * Returns the dimensions of the given array. Even though the\r\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\r\n   * int[3] or double[2][4].\r\n   *\r\n   * @param array       the array to determine the dimensions for\r\n   * @return            the dimensions of the array\r\n   */\r\n  public static int getArrayDimensions(Object array) {\r\n    return getArrayDimensions(array.getClass());\r\n  }\r\n\r\n  /**\r\n   * Returns the given Array in a string representation. Even though the\r\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\r\n   * int[3] or double[2][4].\r\n   * \r\n   * @param array       the array to return in a string representation\r\n   * @return            the array as string\r\n   */\r\n  public static String arrayToString(Object array) {\r\n    String        result;\r\n    int           dimensions;\r\n    int           i;       \r\n\r\n    result     = \"\";\r\n    dimensions = getArrayDimensions(array);\r\n    \r\n    if (dimensions == 0) {\r\n      result = \"null\";\r\n    }\r\n    else if (dimensions == 1) {\r\n      for (i = 0; i \u003c Array.getLength(array); i++) {\r\n        if (i \u003e 0)\r\n          result += \",\";\r\n        if (Array.get(array, i) == null)\r\n          result += \"null\";\r\n        else\r\n          result += Array.get(array, i).toString();\r\n      }\r\n    }\r\n    else {\r\n      for (i = 0; i \u003c Array.getLength(array); i++) {\r\n        if (i \u003e 0)\r\n          result += \",\";\r\n        result += \"[\" + arrayToString(Array.get(array, i)) + \"]\";\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Tests if a is equal to b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n     * @return True if a is equal to b, False otherwise. \r\n   */\r\n  public static /*@pure@*/ boolean eq(double a, double b){\r\n    \r\n    return (a - b \u003c SMALL) \u0026\u0026 (b - a \u003c SMALL); \r\n  }\r\n\r\n  /**\r\n   * Checks if the given array contains any non-empty options.\r\n   *\r\n   * @param options an array of strings\r\n   * @exception Exception if there are any non-empty options\r\n   */\r\n  public static void checkForRemainingOptions(String[] options) \r\n    throws Exception {\r\n    \r\n    int illegalOptionsFound = 0;\r\n    StringBuffer text = new StringBuffer();\r\n\r\n    if (options == null) {\r\n      return;\r\n    }\r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if (options[i].length() \u003e 0) {\r\n\tillegalOptionsFound++;\r\n\ttext.append(options[i] + ' ');\r\n      }\r\n    }\r\n    if (illegalOptionsFound \u003e 0) {\r\n      throw new Exception(\"Illegal options: \" + text);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Checks if the given array contains the flag \"-Char\". Stops\r\n   * searching at the first marker \"--\". If the flag is found,\r\n   * it is replaced with the empty string.\r\n   *\r\n   * @param flag the character indicating the flag.\r\n   * @param options the array of strings containing all the options.\r\n   * @return true if the flag was found\r\n   * @exception Exception if an illegal option was found\r\n   */\r\n  public static boolean getFlag(char flag, String[] options) \r\n    throws Exception {\r\n    \r\n    return getFlag(\"\" + flag, options);\r\n  }\r\n  \r\n  /**\r\n   * Checks if the given array contains the flag \"-String\". Stops\r\n   * searching at the first marker \"--\". If the flag is found,\r\n   * it is replaced with the empty string.\r\n   *\r\n   * @param flag the String indicating the flag.\r\n   * @param options the array of strings containing all the options.\r\n   * @return true if the flag was found\r\n   * @exception Exception if an illegal option was found\r\n   */\r\n  public static boolean getFlag(String flag, String[] options) \r\n    throws Exception {\r\n    \r\n    int pos = getOptionPos(flag, options);\r\n\r\n    if (pos \u003e -1)\r\n      options[pos] = \"\";\r\n    \r\n    return (pos \u003e -1);\r\n  }\r\n\r\n  /**\r\n   * Gets an option indicated by a flag \"-Char\" from the given array\r\n   * of strings. Stops searching at the first marker \"--\". Replaces \r\n   * flag and option with empty strings.\r\n   *\r\n   * @param flag the character indicating the option.\r\n   * @param options the array of strings containing all the options.\r\n   * @return the indicated option or an empty string\r\n   * @exception Exception if the option indicated by the flag can't be found\r\n   */\r\n  public static /*@non_null@*/ String getOption(char flag, String[] options) \r\n    throws Exception {\r\n    \r\n    return getOption(\"\" + flag, options);\r\n  }\r\n\r\n  /**\r\n   * Gets an option indicated by a flag \"-String\" from the given array\r\n   * of strings. Stops searching at the first marker \"--\". Replaces \r\n   * flag and option with empty strings.\r\n   *\r\n   * @param flag the String indicating the option.\r\n   * @param options the array of strings containing all the options.\r\n   * @return the indicated option or an empty string\r\n   * @exception Exception if the option indicated by the flag can't be found\r\n   */\r\n  public static /*@non_null@*/ String getOption(String flag, String[] options) \r\n    throws Exception {\r\n\r\n    String newString;\r\n    int i = getOptionPos(flag, options);\r\n\r\n    if (i \u003e -1) {\r\n      if (options[i].equals(\"-\" + flag)) {\r\n\tif (i + 1 == options.length) {\r\n\t  throw new Exception(\"No value given for -\" + flag + \" option.\");\r\n\t}\r\n\toptions[i] = \"\";\r\n\tnewString = new String(options[i + 1]);\r\n\toptions[i + 1] = \"\";\r\n\treturn newString;\r\n      }\r\n      if (options[i].charAt(1) == '-') {\r\n\treturn \"\";\r\n      }\r\n    }\r\n    \r\n    return \"\";\r\n  }\r\n\r\n  /**\r\n   * Gets the index of an option or flag indicated by a flag \"-Char\" from \r\n   * the given array of strings. Stops searching at the first marker \"--\".\r\n   *\r\n   * @param flag \tthe character indicating the option.\r\n   * @param options \tthe array of strings containing all the options.\r\n   * @return \t\tthe position if found, or -1 otherwise\r\n   */\r\n  public static int getOptionPos(char flag, String[] options) {\r\n     return getOptionPos(\"\" + flag, options);\r\n  }\r\n\r\n  /**\r\n   * Gets the index of an option or flag indicated by a flag \"-String\" from \r\n   * the given array of strings. Stops searching at the first marker \"--\".\r\n   *\r\n   * @param flag \tthe String indicating the option.\r\n   * @param options \tthe array of strings containing all the options.\r\n   * @return \t\tthe position if found, or -1 otherwise\r\n   */\r\n  public static int getOptionPos(String flag, String[] options) {\r\n    if (options == null)\r\n      return -1;\r\n    \r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if ((options[i].length() \u003e 0) \u0026\u0026 (options[i].charAt(0) == '-')) {\r\n\t// Check if it is a negative number\r\n\ttry {\r\n\t  Double.valueOf(options[i]);\r\n\t} \r\n\tcatch (NumberFormatException e) {\r\n\t  // found?\r\n\t  if (options[i].equals(\"-\" + flag))\r\n\t    return i;\r\n\t  // did we reach \"--\"?\r\n\t  if (options[i].charAt(1) == '-')\r\n\t    return -1;\r\n\t}\r\n      }\r\n    }\r\n    \r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Quotes a string if it contains special characters.\r\n   * \r\n   * The following rules are applied:\r\n   *\r\n   * A character is backquoted version of it is one \r\n   * of \u003ctt\u003e\" ' % \\ \\n \\r \\t\u003c/tt\u003e.\r\n   *\r\n   * A string is enclosed within single quotes if a character has been\r\n   * backquoted using the previous rule above or contains \r\n   * \u003ctt\u003e{ }\u003c/tt\u003e or is exactly equal to the strings \r\n   * \u003ctt\u003e, ? space or \"\"\u003c/tt\u003e (empty string).\r\n   *\r\n   * A quoted question mark distinguishes it from the missing value which\r\n   * is represented as an unquoted question mark in arff files.\r\n   *\r\n   * @param string \tthe string to be quoted\r\n   * @return \t\tthe string (possibly quoted)\r\n   * @see\t\t#unquote(String)\r\n   */\r\n  public static /*@pure@*/ String quote(String string) {\r\n      boolean quote = false;\r\n\r\n      // backquote the following characters \r\n      if ((string.indexOf('\\n') != -1) || (string.indexOf('\\r') != -1) || \r\n\t  (string.indexOf('\\'') != -1) || (string.indexOf('\"') != -1) || \r\n\t  (string.indexOf('\\\\') != -1) || \r\n\t  (string.indexOf('\\t') != -1) || (string.indexOf('%') != -1)) {\r\n\t  string = backQuoteChars(string);\r\n\t  quote = true;\r\n      }\r\n\r\n      // Enclose the string in 's if the string contains a recently added\r\n      // backquote or contains one of the following characters.\r\n      if((quote == true) || \r\n\t (string.indexOf('{') != -1) || (string.indexOf('}') != -1) ||\r\n\t (string.indexOf(',') != -1) || (string.equals(\"?\")) ||\r\n\t (string.indexOf(' ') != -1) || (string.equals(\"\"))) {\r\n\t  string = (\"'\".concat(string)).concat(\"'\");\r\n      }\r\n\r\n      return string;\r\n  }\r\n\r\n  /**\r\n   * unquotes are previously quoted string (but only if necessary), i.e., it\r\n   * removes the single quotes around it. Inverse to quote(String).\r\n   * \r\n   * @param string\tthe string to process\r\n   * @return\t\tthe unquoted string\r\n   * @see\t\t#quote(String)\r\n   */\r\n  public static String unquote(String string) {\r\n    if (string.startsWith(\"'\") \u0026\u0026 string.endsWith(\"'\")) {\r\n      string = string.substring(1, string.length() - 1);\r\n      \r\n      if ((string.indexOf(\"\\\\n\") != -1) || (string.indexOf(\"\\\\r\") != -1) || \r\n\t  (string.indexOf(\"\\\\'\") != -1) || (string.indexOf(\"\\\\\\\"\") != -1) || \r\n\t  (string.indexOf(\"\\\\\\\\\") != -1) || \r\n\t  (string.indexOf(\"\\\\t\") != -1) || (string.indexOf(\"\\\\%\") != -1)) {\r\n\tstring = unbackQuoteChars(string);\r\n      }\r\n    }\r\n\r\n    return string;\r\n  }\r\n\r\n  /**\r\n   * Converts carriage returns and new lines in a string into \\r and \\n.\r\n   * Backquotes the following characters: ` \" \\ \\t and %\r\n   * \r\n   * @param string \tthe string\r\n   * @return \t\tthe converted string\r\n   * @see\t\t#unbackQuoteChars(String)\r\n   */\r\n  public static /*@pure@*/ String backQuoteChars(String string) {\r\n\r\n    int index;\r\n    StringBuffer newStringBuffer;\r\n\r\n    // replace each of the following characters with the backquoted version\r\n    char   charsFind[] =    {'\\\\',   '\\'',  '\\t',  '\\n',  '\\r',  '\"',    '%'};\r\n    String charsReplace[] = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\n\", \"\\\\r\", \"\\\\\\\"\", \"\\\\%\"};\r\n    for (int i = 0; i \u003c charsFind.length; i++) {\r\n      if (string.indexOf(charsFind[i]) != -1 ) {\r\n\tnewStringBuffer = new StringBuffer();\r\n\twhile ((index = string.indexOf(charsFind[i])) != -1) {\r\n\t  if (index \u003e 0) {\r\n\t    newStringBuffer.append(string.substring(0, index));\r\n\t  }\r\n\t  newStringBuffer.append(charsReplace[i]);\r\n\t  if ((index + 1) \u003c string.length()) {\r\n\t    string = string.substring(index + 1);\r\n\t  } else {\r\n\t    string = \"\";\r\n\t  }\r\n\t}\r\n\tnewStringBuffer.append(string);\r\n\tstring = newStringBuffer.toString();\r\n      }\r\n    }\r\n\r\n    return string;\r\n  }\r\n\r\n  /**\r\n   * Converts carriage returns and new lines in a string into \\r and \\n.\r\n   *\r\n   * @param string the string\r\n   * @return the converted string\r\n   */\r\n  public static String convertNewLines(String string) {\r\n    int index;\r\n\r\n    // Replace with \\n\r\n    StringBuffer newStringBuffer = new StringBuffer();\r\n    while ((index = string.indexOf('\\n')) != -1) {\r\n      if (index \u003e 0) {\r\n\tnewStringBuffer.append(string.substring(0, index));\r\n      }\r\n      newStringBuffer.append('\\\\');\r\n      newStringBuffer.append('n');\r\n      if ((index + 1) \u003c string.length()) {\r\n\tstring = string.substring(index + 1);\r\n      } else {\r\n\tstring = \"\";\r\n      }\r\n    }\r\n    newStringBuffer.append(string);\r\n    string = newStringBuffer.toString();\r\n\r\n    // Replace with \\r\r\n    newStringBuffer = new StringBuffer();\r\n    while ((index = string.indexOf('\\r')) != -1) {\r\n      if (index \u003e 0) {\r\n\tnewStringBuffer.append(string.substring(0, index));\r\n      }\r\n      newStringBuffer.append('\\\\');\r\n      newStringBuffer.append('r');\r\n      if ((index + 1) \u003c string.length()){\r\n\tstring = string.substring(index + 1);\r\n      } else {\r\n\tstring = \"\";\r\n      }\r\n    }\r\n    newStringBuffer.append(string);\r\n    return newStringBuffer.toString();\r\n  }\r\n\r\n  /**\r\n   * Reverts \\r and \\n in a string into carriage returns and new lines.\r\n   * \r\n   * @param string the string\r\n   * @return the converted string\r\n   */\r\n  public static String revertNewLines(String string) {\r\n    int index;\r\n\r\n    // Replace with \\n\r\n    StringBuffer newStringBuffer = new StringBuffer();\r\n    while ((index = string.indexOf(\"\\\\n\")) != -1) {\r\n      if (index \u003e 0) {\r\n\tnewStringBuffer.append(string.substring(0, index));\r\n      }\r\n      newStringBuffer.append('\\n');\r\n      if ((index + 2) \u003c string.length()) {\r\n\tstring = string.substring(index + 2);\r\n      } else {\r\n\tstring = \"\";\r\n      }\r\n    }\r\n    newStringBuffer.append(string);\r\n    string = newStringBuffer.toString();\r\n\r\n    // Replace with \\r\r\n    newStringBuffer = new StringBuffer();\r\n    while ((index = string.indexOf(\"\\\\r\")) != -1) {\r\n      if (index \u003e 0) {\r\n\tnewStringBuffer.append(string.substring(0, index));\r\n      }\r\n      newStringBuffer.append('\\r');\r\n      if ((index + 2) \u003c string.length()){\r\n\tstring = string.substring(index + 2);\r\n      } else {\r\n\tstring = \"\";\r\n      }\r\n    }\r\n    newStringBuffer.append(string);\r\n    \r\n    return newStringBuffer.toString();\r\n  }\r\n\r\n  /**\r\n   * Returns the secondary set of options (if any) contained in\r\n   * the supplied options array. The secondary set is defined to\r\n   * be any options after the first \"--\". These options are removed from\r\n   * the original options array.\r\n   *\r\n   * @param options the input array of options\r\n   * @return the array of secondary options\r\n   */\r\n  public static String[] partitionOptions(String[] options) {\r\n\r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if (options[i].equals(\"--\")) {\r\n\toptions[i++] = \"\";\r\n\tString[] result = new String [options.length - i];\r\n\tfor (int j = i; j \u003c options.length; j++) {\r\n\t  result[j - i] = options[j];\r\n\t  options[j] = \"\";\r\n\t}\r\n\treturn result;\r\n      }\r\n    }\r\n    return new String [0];\r\n  }\r\n    \r\n  /**\r\n   * The inverse operation of backQuoteChars().\r\n   * Converts back-quoted carriage returns and new lines in a string \r\n   * to the corresponding character ('\\r' and '\\n').\r\n   * Also \"un\"-back-quotes the following characters: ` \" \\ \\t and %\r\n   *\r\n   * @param string \tthe string\r\n   * @return \t\tthe converted string\r\n   * @see\t\t#backQuoteChars(String)\r\n   */\r\n  public static String unbackQuoteChars(String string) {\r\n\r\n    int index;\r\n    StringBuffer newStringBuffer;\r\n    \r\n    // replace each of the following characters with the backquoted version\r\n    String charsFind[]    = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\n\", \"\\\\r\", \"\\\\\\\"\", \"\\\\%\"};\r\n    char   charsReplace[] = {'\\\\',   '\\'',  '\\t',  '\\n',  '\\r',  '\"',    '%'};\r\n    int pos[] = new int[charsFind.length];\r\n    int\tcurPos;\r\n    \r\n    String str = new String(string);\r\n    newStringBuffer = new StringBuffer();\r\n    while (str.length() \u003e 0) {\r\n      // get positions and closest character to replace\r\n      curPos = str.length();\r\n      index  = -1;\r\n      for (int i = 0; i \u003c pos.length; i++) {\r\n\tpos[i] = str.indexOf(charsFind[i]);\r\n\tif ( (pos[i] \u003e -1) \u0026\u0026 (pos[i] \u003c curPos) ) {\r\n\t  index  = i;\r\n\t  curPos = pos[i];\r\n\t}\r\n      }\r\n      \r\n      // replace character if found, otherwise finished\r\n      if (index == -1) {\r\n\tnewStringBuffer.append(str);\r\n\tstr = \"\";\r\n      }\r\n      else {\r\n\tnewStringBuffer.append(str.substring(0, pos[index]));\r\n\tnewStringBuffer.append(charsReplace[index]);\r\n\tstr = str.substring(pos[index] + charsFind[index].length());\r\n      }\r\n    }\r\n\r\n    return newStringBuffer.toString();\r\n  }    \r\n  \r\n  /**\r\n   * Split up a string containing options into an array of strings,\r\n   * one for each option.\r\n   *\r\n   * @param \t\tquotedOptionString the string containing the options\r\n   * @return \t\tthe array of options\r\n   * @throws Exception \tin case of an unterminated string, unknown character or\r\n   * \t\t\ta parse error\r\n   */\r\n  public static String[] splitOptions(String quotedOptionString) throws Exception{\r\n\r\n    FastVector optionsVec = new FastVector();\r\n    String str = new String(quotedOptionString);\r\n    int i;\r\n    \r\n    while (true){\r\n\r\n      //trimLeft \r\n      i = 0;\r\n      while ((i \u003c str.length()) \u0026\u0026 (Character.isWhitespace(str.charAt(i)))) i++;\r\n      str = str.substring(i);\r\n      \r\n      //stop when str is empty\r\n      if (str.length() == 0) break;\r\n      \r\n      //if str start with a double quote\r\n      if (str.charAt(0) == '\"'){\r\n\t\r\n\t//find the first not anti-slached double quote\r\n\ti = 1;\r\n\twhile(i \u003c str.length()){\r\n\t  if (str.charAt(i) == str.charAt(0)) break;\r\n\t  if (str.charAt(i) == '\\\\'){\r\n\t    i += 1;\r\n\t    if (i \u003e= str.length()) \r\n\t      throw new Exception(\"String should not finish with \\\\\");\r\n\t  }\r\n\t  i += 1;\r\n\t}\r\n\tif (i \u003e= str.length()) throw new Exception(\"Quote parse error.\");\r\n\t\r\n\t//add the founded string to the option vector (without quotes)\r\n\tString optStr = str.substring(1,i);\r\n\toptStr = unbackQuoteChars(optStr);\r\n\toptionsVec.addElement(optStr);\r\n\tstr = str.substring(i+1);\r\n      } else {\r\n\t//find first whiteSpace\r\n\ti=0;\r\n\twhile((i \u003c str.length()) \u0026\u0026 (!Character.isWhitespace(str.charAt(i)))) i++;\r\n\t\r\n\t//add the founded string to the option vector\r\n\tString optStr = str.substring(0,i);\r\n\toptionsVec.addElement(optStr);\r\n\tstr = str.substring(i);\r\n      }\r\n    }\r\n    \r\n    //convert optionsVec to an array of String\r\n    String[] options = new String[optionsVec.size()];\r\n    for (i = 0; i \u003c optionsVec.size(); i++) {\r\n      options[i] = (String)optionsVec.elementAt(i);\r\n    }\r\n    return options;\r\n  }    \r\n\r\n  /**\r\n   * Joins all the options in an option array into a single string,\r\n   * as might be used on the command line.\r\n   *\r\n   * @param optionArray the array of options\r\n   * @return the string containing all options.\r\n   */\r\n  public static String joinOptions(String[] optionArray) {\r\n\r\n    String optionString = \"\";\r\n    for (int i = 0; i \u003c optionArray.length; i++) {\r\n      if (optionArray[i].equals(\"\")) {\r\n\tcontinue;\r\n      }\r\n      boolean escape = false;\r\n      for (int n = 0; n \u003c optionArray[i].length(); n++) {\r\n\tif (Character.isWhitespace(optionArray[i].charAt(n))) {\r\n\t  escape = true;\r\n\t  break;\r\n\t}\r\n      }\r\n      if (escape) {\r\n\toptionString += '\"' + backQuoteChars(optionArray[i]) + '\"';\r\n      } else {\r\n\toptionString += optionArray[i];\r\n      }\r\n      optionString += \" \";\r\n    }\r\n    return optionString.trim();\r\n  }\r\n  \r\n  /**\r\n   * Creates a new instance of an object given it's class name and\r\n   * (optional) arguments to pass to it's setOptions method. If the\r\n   * object implements OptionHandler and the options parameter is\r\n   * non-null, the object will have it's options set. Example use:\u003cp\u003e\r\n   *\r\n   * \u003ccode\u003e \u003cpre\u003e\r\n   * String classifierName = Utils.getOption('W', options);\r\n   * Classifier c = (Classifier)Utils.forName(Classifier.class,\r\n   *                                          classifierName,\r\n   *                                          options);\r\n   * setClassifier(c);\r\n   * \u003c/pre\u003e\u003c/code\u003e\r\n   *\r\n   * @param classType the class that the instantiated object should\r\n   * be assignable to -- an exception is thrown if this is not the case\r\n   * @param className the fully qualified class name of the object\r\n   * @param options an array of options suitable for passing to setOptions. May\r\n   * be null. Any options accepted by the object will be removed from the\r\n   * array.\r\n   * @return the newly created object, ready for use.\r\n   * @exception Exception if the class name is invalid, or if the\r\n   * class is not assignable to the desired class type, or the options\r\n   * supplied are not acceptable to the object\r\n   */\r\n  public static Object forName(Class classType,\r\n\t\t\t       String className,\r\n\t\t\t       String[] options) throws Exception {\r\n\r\n    Class c = null;\r\n    try {\r\n      c = Class.forName(className);\r\n    } catch (Exception ex) {\r\n      throw new Exception(\"Can't find class called: \" + className);\r\n    }\r\n    if (!classType.isAssignableFrom(c)) {\r\n      throw new Exception(classType.getName() + \" is not assignable from \"\r\n\t\t\t  + className);\r\n    }\r\n    Object o = c.newInstance();\r\n    if ((o instanceof OptionHandler)\r\n\t\u0026\u0026 (options != null)) {\r\n      ((OptionHandler)o).setOptions(options);\r\n      Utils.checkForRemainingOptions(options);\r\n    }\r\n    return o;\r\n  }\r\n\r\n  /**\r\n   * Computes entropy for an array of integers.\r\n   *\r\n   * @param counts array of counts\r\n   * @return - a log2 a - b log2 b - c log2 c + (a+b+c) log2 (a+b+c)\r\n   * when given array [a b c]\r\n   */\r\n  public static /*@pure@*/ double info(int counts[]) {\r\n    \r\n    int total = 0;\r\n    double x = 0;\r\n    for (int j = 0; j \u003c counts.length; j++) {\r\n      x -= xlogx(counts[j]);\r\n      total += counts[j];\r\n    }\r\n    return x + xlogx(total);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is smaller or equal to b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n     * @return True if a is smaller or equal to b, False otherwise. \r\n   */\r\n  public static /*@pure@*/ boolean smOrEq(double a,double b) {\r\n    \r\n    return (a-b \u003c SMALL);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is greater or equal to b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n     * @return True if a is greater or equal to b, False otherwise. \r\n   */\r\n  public static /*@pure@*/ boolean grOrEq(double a,double b) {\r\n    \r\n    return (b-a \u003c SMALL);\r\n  }\r\n  \r\n  /**\r\n   * Tests if a is smaller than b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n     * @return True if a is smaller than b, False otherwise.\r\n   */\r\n  public static /*@pure@*/ boolean sm(double a,double b) {\r\n    \r\n    return (b-a \u003e SMALL);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is greater than b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double \r\n     * @return True if a is greater than b, False otherwise. \r\n   */\r\n  public static /*@pure@*/ boolean gr(double a,double b) {\r\n    \r\n    return (a-b \u003e SMALL);\r\n  }\r\n\r\n  /**\r\n   * Returns the kth-smallest value in the array.\r\n   *\r\n   * @param array the array of integers\r\n   * @param k the value of k\r\n   * @return the kth-smallest value\r\n   */\r\n  public static double kthSmallestValue(int[] array, int k) {\r\n\r\n    int[] index = new int[array.length];\r\n    \r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n    }\r\n\r\n    return array[index[select(array, index, 0, array.length - 1, k)]];\r\n  }\r\n\r\n  /**\r\n   * Returns the kth-smallest value in the array\r\n   *\r\n   * @param array the array of double\r\n   * @param k the value of k\r\n   * @return the kth-smallest value\r\n   */\r\n  public static double kthSmallestValue(double[] array, int k) {\r\n\r\n    int[] index = new int[array.length];\r\n    \r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n    }\r\n\r\n    return array[index[select(array, index, 0, array.length - 1, k)]];\r\n  }\r\n\r\n  /**\r\n   * Returns the logarithm of a for base 2.\r\n   *\r\n   * @param a \ta double\r\n   * @return\tthe logarithm for base 2\r\n   */\r\n  public static /*@pure@*/ double log2(double a) {\r\n    \r\n    return Math.log(a) / log2;\r\n  }\r\n\r\n  /**\r\n   * Returns index of maximum element in a given\r\n   * array of doubles. First maximum is returned.\r\n   *\r\n   * @param doubles the array of doubles\r\n   * @return the index of the maximum element\r\n   */\r\n  public static /*@pure@*/ int maxIndex(double[] doubles) {\r\n\r\n    double maximum = 0;\r\n    int maxIndex = 0;\r\n\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      if ((i == 0) || (doubles[i] \u003e maximum)) {\r\n\tmaxIndex = i;\r\n\tmaximum = doubles[i];\r\n      }\r\n    }\r\n\r\n    return maxIndex;\r\n  }\r\n\r\n  /**\r\n   * Returns index of maximum element in a given\r\n   * array of integers. First maximum is returned.\r\n   *\r\n   * @param ints the array of integers\r\n   * @return the index of the maximum element\r\n   */\r\n  public static /*@pure@*/ int maxIndex(int[] ints) {\r\n\r\n    int maximum = 0;\r\n    int maxIndex = 0;\r\n\r\n    for (int i = 0; i \u003c ints.length; i++) {\r\n      if ((i == 0) || (ints[i] \u003e maximum)) {\r\n\tmaxIndex = i;\r\n\tmaximum = ints[i];\r\n      }\r\n    }\r\n\r\n    return maxIndex;\r\n  }\r\n\r\n  /**\r\n   * Computes the mean for an array of doubles.\r\n   *\r\n   * @param vector the array\r\n   * @return the mean\r\n   */\r\n  public static /*@pure@*/ double mean(double[] vector) {\r\n  \r\n    double sum = 0;\r\n\r\n    if (vector.length == 0) {\r\n      return 0;\r\n    }\r\n    for (int i = 0; i \u003c vector.length; i++) {\r\n      sum += vector[i];\r\n    }\r\n    return sum / (double) vector.length;\r\n  }\r\n\r\n  /**\r\n   * Returns index of minimum element in a given\r\n   * array of integers. First minimum is returned.\r\n   *\r\n   * @param ints the array of integers\r\n   * @return the index of the minimum element\r\n   */\r\n  public static /*@pure@*/ int minIndex(int[] ints) {\r\n\r\n    int minimum = 0;\r\n    int minIndex = 0;\r\n\r\n    for (int i = 0; i \u003c ints.length; i++) {\r\n      if ((i == 0) || (ints[i] \u003c minimum)) {\r\n\tminIndex = i;\r\n\tminimum = ints[i];\r\n      }\r\n    }\r\n\r\n    return minIndex;\r\n  }\r\n\r\n  /**\r\n   * Returns index of minimum element in a given\r\n   * array of doubles. First minimum is returned.\r\n   *\r\n   * @param doubles the array of doubles\r\n   * @return the index of the minimum element\r\n   */\r\n  public static /*@pure@*/ int minIndex(double[] doubles) {\r\n\r\n    double minimum = 0;\r\n    int minIndex = 0;\r\n\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      if ((i == 0) || (doubles[i] \u003c minimum)) {\r\n\tminIndex = i;\r\n\tminimum = doubles[i];\r\n      }\r\n    }\r\n\r\n    return minIndex;\r\n  }\r\n\r\n  /**\r\n   * Normalizes the doubles in the array by their sum.\r\n   *\r\n   * @param doubles the array of double\r\n   * @exception IllegalArgumentException if sum is Zero or NaN\r\n   */\r\n  public static void normalize(double[] doubles) {\r\n\r\n    double sum = 0;\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      sum += doubles[i];\r\n    }\r\n    normalize(doubles, sum);\r\n  }\r\n\r\n  /**\r\n   * Normalizes the doubles in the array using the given value.\r\n   *\r\n   * @param doubles the array of double\r\n   * @param sum the value by which the doubles are to be normalized\r\n   * @exception IllegalArgumentException if sum is zero or NaN\r\n   */\r\n  public static void normalize(double[] doubles, double sum) {\r\n\r\n    if (Double.isNaN(sum)) {\r\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is NaN.\");\r\n    }\r\n    if (sum == 0) {\r\n      // Maybe this should just be a return.\r\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is zero.\");\r\n    }\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      doubles[i] /= sum;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts an array containing the natural logarithms of\r\n   * probabilities stored in a vector back into probabilities.\r\n   * The probabilities are assumed to sum to one.\r\n   *\r\n   * @param a an array holding the natural logarithms of the probabilities\r\n   * @return the converted array \r\n   */\r\n  public static double[] logs2probs(double[] a) {\r\n\r\n    double max = a[maxIndex(a)];\r\n    double sum = 0.0;\r\n\r\n    double[] result = new double[a.length];\r\n    for(int i = 0; i \u003c a.length; i++) {\r\n      result[i] = Math.exp(a[i] - max);\r\n      sum += result[i];\r\n    }\r\n\r\n    normalize(result, sum);\r\n\r\n    return result;\r\n  } \r\n\r\n  /**\r\n   * Returns the log-odds for a given probabilitiy.\r\n   *\r\n   * @param prob the probabilitiy\r\n   *\r\n   * @return the log-odds after the probability has been mapped to\r\n   * [Utils.SMALL, 1-Utils.SMALL]\r\n   */\r\n  public static /*@pure@*/ double probToLogOdds(double prob) {\r\n\r\n    if (gr(prob, 1) || (sm(prob, 0))) {\r\n      throw new IllegalArgumentException(\"probToLogOdds: probability must \" +\r\n\t\t\t\t     \"be in [0,1] \"+prob);\r\n    }\r\n    double p = SMALL + (1.0 - 2 * SMALL) * prob;\r\n    return Math.log(p / (1 - p));\r\n  }\r\n\r\n  /**\r\n   * Rounds a double to the next nearest integer value. The JDK version\r\n   * of it doesn't work properly.\r\n   *\r\n   * @param value the double value\r\n   * @return the resulting integer value\r\n   */\r\n  public static /*@pure@*/ int round(double value) {\r\n\r\n    int roundedValue = value \u003e 0\r\n      ? (int)(value + 0.5)\r\n      : -(int)(Math.abs(value) + 0.5);\r\n    \r\n    return roundedValue;\r\n  }\r\n\r\n  /**\r\n   * Rounds a double to the next nearest integer value in a probabilistic\r\n   * fashion (e.g. 0.8 has a 20% chance of being rounded down to 0 and a\r\n   * 80% chance of being rounded up to 1). In the limit, the average of\r\n   * the rounded numbers generated by this procedure should converge to\r\n   * the original double.\r\n   *\r\n   * @param value the double value\r\n   * @param rand the random number generator\r\n   * @return the resulting integer value\r\n   */\r\n  public static int probRound(double value, Random rand) {\r\n\r\n    if (value \u003e= 0) {\r\n      double lower = Math.floor(value);\r\n      double prob = value - lower;\r\n      if (rand.nextDouble() \u003c prob) {\r\n\treturn (int)lower + 1;\r\n      } else {\r\n\treturn (int)lower;\r\n      }\r\n    } else {\r\n      double lower = Math.floor(Math.abs(value));\r\n      double prob = Math.abs(value) - lower;\r\n      if (rand.nextDouble() \u003c prob) {\r\n\treturn -((int)lower + 1);\r\n      } else {\r\n\treturn -(int)lower;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rounds a double to the given number of decimal places.\r\n   *\r\n   * @param value the double value\r\n   * @param afterDecimalPoint the number of digits after the decimal point\r\n   * @return the double rounded to the given precision\r\n   */\r\n  public static /*@pure@*/ double roundDouble(double value,int afterDecimalPoint) {\r\n\r\n    double mask = Math.pow(10.0, (double)afterDecimalPoint);\r\n\r\n    return (double)(Math.round(value * mask)) / mask;\r\n  }\r\n\r\n  /**\r\n   * Sorts a given array of integers in ascending order and returns an \r\n   * array of integers with the positions of the elements of the original \r\n   * array in the sorted array. The sort is stable. (Equal elements remain\r\n   * in their original order.)\r\n   *\r\n   * @param array this array is not changed by the method!\r\n   * @return an array of integers with the positions in the sorted\r\n   * array.\r\n   */\r\n  public static /*@pure@*/ int[] sort(int[] array) {\r\n\r\n    int[] index = new int[array.length];\r\n    int[] newIndex = new int[array.length];\r\n    int[] helpIndex;\r\n    int numEqual;\r\n    \r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n    }\r\n    quickSort(array, index, 0, array.length - 1);\r\n\r\n    // Make sort stable\r\n    int i = 0;\r\n    while (i \u003c index.length) {\r\n      numEqual = 1;\r\n      for (int j = i + 1; ((j \u003c index.length)\r\n\t\t\t   \u0026\u0026 (array[index[i]] == array[index[j]]));\r\n\t   j++) {\r\n\tnumEqual++;\r\n      }\r\n      if (numEqual \u003e 1) {\r\n\thelpIndex = new int[numEqual];\r\n\tfor (int j = 0; j \u003c numEqual; j++) {\r\n\t  helpIndex[j] = i + j;\r\n\t}\r\n\tquickSort(index, helpIndex, 0, numEqual - 1);\r\n\tfor (int j = 0; j \u003c numEqual; j++) {\r\n\t  newIndex[i + j] = index[helpIndex[j]];\r\n\t}\r\n\ti += numEqual;\r\n      } else {\r\n\tnewIndex[i] = index[i];\r\n\ti++;\r\n      }\r\n    }\r\n    return newIndex;\r\n  }\r\n\r\n  /**\r\n   * Sorts a given array of doubles in ascending order and returns an\r\n   * array of integers with the positions of the elements of the\r\n   * original array in the sorted array. NOTE THESE CHANGES: the sort\r\n   * is no longer stable and it doesn't use safe floating-point\r\n   * comparisons anymore. Occurrences of Double.NaN are treated as \r\n   * Double.MAX_VALUE\r\n   *\r\n   * @param array this array is not changed by the method!\r\n   * @return an array of integers with the positions in the sorted\r\n   * array.  \r\n   */\r\n  public static /*@pure@*/ int[] sort(/*@non_null@*/ double[] array) {\r\n\r\n    int[] index = new int[array.length];\r\n    array = (double[])array.clone();\r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n      if (Double.isNaN(array[i])) {\r\n        array[i] = Double.MAX_VALUE;\r\n      }\r\n    }\r\n    quickSort(array, index, 0, array.length - 1);\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Sorts a given array of doubles in ascending order and returns an \r\n   * array of integers with the positions of the elements of the original \r\n   * array in the sorted array. The sort is stable (Equal elements remain\r\n   * in their original order.) Occurrences of Double.NaN are treated as \r\n   * Double.MAX_VALUE\r\n   *\r\n   * @param array this array is not changed by the method!\r\n   * @return an array of integers with the positions in the sorted\r\n   * array.\r\n   */\r\n  public static /*@pure@*/ int[] stableSort(double[] array){\r\n\r\n    int[] index = new int[array.length];\r\n    int[] newIndex = new int[array.length];\r\n    int[] helpIndex;\r\n    int numEqual;\r\n    \r\n    array = (double[])array.clone();\r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n      if (Double.isNaN(array[i])) {\r\n        array[i] = Double.MAX_VALUE;\r\n      }\r\n    }\r\n    quickSort(array,index,0,array.length-1);\r\n\r\n    // Make sort stable\r\n\r\n    int i = 0;\r\n    while (i \u003c index.length) {\r\n      numEqual = 1;\r\n      for (int j = i+1; ((j \u003c index.length) \u0026\u0026 Utils.eq(array[index[i]],\r\n\t\t\t\t\t\t\tarray[index[j]])); j++)\r\n\tnumEqual++;\r\n      if (numEqual \u003e 1) {\r\n\thelpIndex = new int[numEqual];\r\n\tfor (int j = 0; j \u003c numEqual; j++)\r\n\t  helpIndex[j] = i+j;\r\n\tquickSort(index, helpIndex, 0, numEqual-1);\r\n\tfor (int j = 0; j \u003c numEqual; j++) \r\n\t  newIndex[i+j] = index[helpIndex[j]];\r\n\ti += numEqual;\r\n      } else {\r\n\tnewIndex[i] = index[i];\r\n\ti++;\r\n      }\r\n    }\r\n\r\n    return newIndex;\r\n  }\r\n\r\n  /**\r\n   * Computes the variance for an array of doubles.\r\n   *\r\n   * @param vector the array\r\n   * @return the variance\r\n   */\r\n  public static /*@pure@*/ double variance(double[] vector) {\r\n  \r\n    double sum = 0, sumSquared = 0;\r\n\r\n    if (vector.length \u003c= 1) {\r\n      return 0;\r\n    }\r\n    for (int i = 0; i \u003c vector.length; i++) {\r\n      sum += vector[i];\r\n      sumSquared += (vector[i] * vector[i]);\r\n    }\r\n    double result = (sumSquared - (sum * sum / (double) vector.length)) / \r\n      (double) (vector.length - 1);\r\n\r\n    // We don't like negative variance\r\n    if (result \u003c 0) {\r\n      return 0;\r\n    } else {\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Computes the sum of the elements of an array of doubles.\r\n   *\r\n   * @param doubles the array of double\r\n   * @return the sum of the elements\r\n   */\r\n  public static /*@pure@*/ double sum(double[] doubles) {\r\n\r\n    double sum = 0;\r\n\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      sum += doubles[i];\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * Computes the sum of the elements of an array of integers.\r\n   *\r\n   * @param ints the array of integers\r\n   * @return the sum of the elements\r\n   */\r\n  public static /*@pure@*/ int sum(int[] ints) {\r\n\r\n    int sum = 0;\r\n\r\n    for (int i = 0; i \u003c ints.length; i++) {\r\n      sum += ints[i];\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * Returns c*log2(c) for a given integer value c.\r\n   *\r\n   * @param c an integer value\r\n   * @return c*log2(c) (but is careful to return 0 if c is 0)\r\n   */\r\n  public static /*@pure@*/ double xlogx(int c) {\r\n    \r\n    if (c == 0) {\r\n      return 0.0;\r\n    }\r\n    return c * Utils.log2((double) c);\r\n  }\r\n\r\n  /**\r\n   * Partitions the instances around a pivot. Used by quicksort and\r\n   * kthSmallestValue.\r\n   *\r\n   * @param array the array of doubles to be sorted\r\n   * @param index the index into the array of doubles\r\n   * @param l the first index of the subset \r\n   * @param r the last index of the subset \r\n   *\r\n   * @return the index of the middle element\r\n   */\r\n  private static int partition(double[] array, int[] index, int l, int r) {\r\n    \r\n    double pivot = array[index[(l + r) / 2]];\r\n    int help;\r\n\r\n    while (l \u003c r) {\r\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\r\n        l++;\r\n      }\r\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\r\n        r--;\r\n      }\r\n      if (l \u003c r) {\r\n        help = index[l];\r\n        index[l] = index[r];\r\n        index[r] = help;\r\n        l++;\r\n        r--;\r\n      }\r\n    }\r\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\r\n      r--;\r\n    } \r\n\r\n    return r;\r\n  }\r\n\r\n  /**\r\n   * Partitions the instances around a pivot. Used by quicksort and\r\n   * kthSmallestValue.\r\n   *\r\n   * @param array the array of integers to be sorted\r\n   * @param index the index into the array of integers\r\n   * @param l the first index of the subset \r\n   * @param r the last index of the subset \r\n   *\r\n   * @return the index of the middle element\r\n   */\r\n  private static int partition(int[] array, int[] index, int l, int r) {\r\n    \r\n    double pivot = array[index[(l + r) / 2]];\r\n    int help;\r\n\r\n    while (l \u003c r) {\r\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\r\n        l++;\r\n      }\r\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\r\n        r--;\r\n      }\r\n      if (l \u003c r) {\r\n        help = index[l];\r\n        index[l] = index[r];\r\n        index[r] = help;\r\n        l++;\r\n        r--;\r\n      }\r\n    }\r\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\r\n      r--;\r\n    } \r\n\r\n    return r;\r\n  }\r\n  \r\n  /**\r\n   * Implements quicksort according to Manber's \"Introduction to\r\n   * Algorithms\".\r\n   *\r\n   * @param array the array of doubles to be sorted\r\n   * @param index the index into the array of doubles\r\n   * @param left the first index of the subset to be sorted\r\n   * @param right the last index of the subset to be sorted\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r\n  //@ requires array != index;\r\n  //  assignable index;\r\n  private static void quickSort(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \r\n                                int left, int right) {\r\n\r\n    if (left \u003c right) {\r\n      int middle = partition(array, index, left, right);\r\n      quickSort(array, index, left, middle);\r\n      quickSort(array, index, middle + 1, right);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Implements quicksort according to Manber's \"Introduction to\r\n   * Algorithms\".\r\n   *\r\n   * @param array the array of integers to be sorted\r\n   * @param index the index into the array of integers\r\n   * @param left the first index of the subset to be sorted\r\n   * @param right the last index of the subset to be sorted\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r\n  //@ requires array != index;\r\n  //  assignable index;\r\n  private static void quickSort(/*@non_null@*/ int[] array, /*@non_null@*/  int[] index, \r\n                                int left, int right) {\r\n\r\n    if (left \u003c right) {\r\n      int middle = partition(array, index, left, right);\r\n      quickSort(array, index, left, middle);\r\n      quickSort(array, index, middle + 1, right);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Implements computation of the kth-smallest element according\r\n   * to Manber's \"Introduction to Algorithms\".\r\n   *\r\n   * @param array the array of double\r\n   * @param index the index into the array of doubles\r\n   * @param left the first index of the subset \r\n   * @param right the last index of the subset \r\n   * @param k the value of k\r\n   *\r\n   * @return the index of the kth-smallest element\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  private static int select(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \r\n                            int left, int right, int k) {\r\n    \r\n    if (left == right) {\r\n      return left;\r\n    } else {\r\n      int middle = partition(array, index, left, right);\r\n      if ((middle - left + 1) \u003e= k) {\r\n        return select(array, index, left, middle, k);\r\n      } else {\r\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Implements computation of the kth-smallest element according\r\n   * to Manber's \"Introduction to Algorithms\".\r\n   *\r\n   * @param array the array of integers\r\n   * @param index the index into the array of integers\r\n   * @param left the first index of the subset \r\n   * @param right the last index of the subset \r\n   * @param k the value of k\r\n   *\r\n   * @return the index of the kth-smallest element\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  private static int select(/*@non_null@*/ int[] array, /*@non_null@*/ int[] index, \r\n                            int left, int right, int k) {\r\n    \r\n    if (left == right) {\r\n      return left;\r\n    } else {\r\n      int middle = partition(array, index, left, right);\r\n      if ((middle - left + 1) \u003e= k) {\r\n        return select(array, index, left, middle, k);\r\n      } else {\r\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Main method for testing this class.\r\n   *\r\n   * @param ops some dummy options\r\n   */\r\n  public static void main(String[] ops) {\r\n\r\n    double[] doublesWithNaN = {4.5, 6.7, Double.NaN, 3.4, 4.8, 1.2, 3.4};\r\n    double[] doubles = {4.5, 6.7, 6.7, 3.4, 4.8, 1.2, 3.4, 6.7, 6.7, 3.4};\r\n    int[] ints = {12, 6, 2, 18, 16, 6, 7, 5, 18, 18, 17};\r\n\r\n    try {\r\n\r\n      // Option handling\r\n      System.out.println(\"First option split up:\");\r\n      if (ops.length \u003e 0) {\r\n\tString[] firstOptionSplitUp = Utils.splitOptions(ops[0]);\r\n\tfor (int i = 0; i \u003c firstOptionSplitUp.length; i ++) {\r\n\t  System.out.println(firstOptionSplitUp[i]);\r\n\t}\r\n      }\t\t\t\t\t       \r\n      System.out.println(\"Partitioned options: \");\r\n      String[] partitionedOptions = Utils.partitionOptions(ops);\r\n      for (int i  = 0; i \u003c partitionedOptions.length; i++) {\r\n\tSystem.out.println(partitionedOptions[i]);\r\n      }\r\n      System.out.println(\"Get position of flag -f: \" + Utils.getOptionPos('f', ops));\r\n      System.out.println(\"Get flag -f: \" + Utils.getFlag('f', ops));\r\n      System.out.println(\"Get position of option -o: \" + Utils.getOptionPos('o', ops));\r\n      System.out.println(\"Get option -o: \" + Utils.getOption('o', ops));\r\n      System.out.println(\"Checking for remaining options... \");\r\n      Utils.checkForRemainingOptions(ops);\r\n      \r\n      // Statistics\r\n      System.out.println(\"Original array with NaN (doubles): \");\r\n      for (int i = 0; i \u003c doublesWithNaN.length; i++) {\r\n\tSystem.out.print(doublesWithNaN[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Original array (doubles): \");\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(doubles[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Original array (ints): \");\r\n      for (int i = 0; i \u003c ints.length; i++) {\r\n\tSystem.out.print(ints[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Correlation: \" + Utils.correlation(doubles, doubles, \r\n\t\t\t\t\t\t\t     doubles.length));\r\n      System.out.println(\"Mean: \" + Utils.mean(doubles));\r\n      System.out.println(\"Variance: \" + Utils.variance(doubles));\r\n      System.out.println(\"Sum (doubles): \" + Utils.sum(doubles));\r\n      System.out.println(\"Sum (ints): \" + Utils.sum(ints));\r\n      System.out.println(\"Max index (doubles): \" + Utils.maxIndex(doubles));\r\n      System.out.println(\"Max index (ints): \" + Utils.maxIndex(ints));\r\n      System.out.println(\"Min index (doubles): \" + Utils.minIndex(doubles));\r\n      System.out.println(\"Min index (ints): \" + Utils.minIndex(ints));\r\n      System.out.println(\"Median (doubles): \" + \r\n                         Utils.kthSmallestValue(doubles, doubles.length / 2));\r\n      System.out.println(\"Median (ints): \" + \r\n                         Utils.kthSmallestValue(ints, ints.length / 2));\r\n\r\n      // Sorting and normalizing\r\n      System.out.println(\"Sorted array with NaN (doubles): \");\r\n      int[] sorted = Utils.sort(doublesWithNaN);\r\n      for (int i = 0; i \u003c doublesWithNaN.length; i++) {\r\n\tSystem.out.print(doublesWithNaN[sorted[i]] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Sorted array (doubles): \");\r\n      sorted = Utils.sort(doubles);\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(doubles[sorted[i]] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Sorted array (ints): \");\r\n      sorted = Utils.sort(ints);\r\n      for (int i = 0; i \u003c ints.length; i++) {\r\n\tSystem.out.print(ints[sorted[i]] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Indices from stable sort (doubles): \");\r\n      sorted = Utils.stableSort(doubles);\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(sorted[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Indices from sort (ints): \");\r\n      sorted = Utils.sort(ints);\r\n      for (int i = 0; i \u003c ints.length; i++) {\r\n\tSystem.out.print(sorted[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Normalized array (doubles): \");\r\n      Utils.normalize(doubles);\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(doubles[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Normalized again (doubles): \");\r\n      Utils.normalize(doubles, Utils.sum(doubles));\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(doubles[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      \r\n      // Pretty-printing\r\n      System.out.println(\"-4.58: \" + Utils.doubleToString(-4.57826535, 2));\r\n      System.out.println(\"-6.78: \" + Utils.doubleToString(-6.78214234, 6,2));\r\n      \r\n      // Comparisons\r\n      System.out.println(\"5.70001 == 5.7 ? \" + Utils.eq(5.70001, 5.7));\r\n      System.out.println(\"5.70001 \u003e 5.7 ? \" + Utils.gr(5.70001, 5.7));\r\n      System.out.println(\"5.70001 \u003e= 5.7 ? \" + Utils.grOrEq(5.70001, 5.7));\r\n      System.out.println(\"5.7 \u003c 5.70001 ? \" + Utils.sm(5.7, 5.70001));\r\n      System.out.println(\"5.7 \u003c= 5.70001 ? \" + Utils.smOrEq(5.7, 5.70001));\r\n      \r\n      // Math\r\n      System.out.println(\"Info (ints): \" + Utils.info(ints));\r\n      System.out.println(\"log2(4.6): \" + Utils.log2(4.6));\r\n      System.out.println(\"5 * log(5): \" + Utils.xlogx(5));\r\n      System.out.println(\"5.5 rounded: \" + Utils.round(5.5));\r\n      System.out.println(\"5.55555 rounded to 2 decimal places: \" + \r\n\t\t\t Utils.roundDouble(5.55555, 2));\r\n      \r\n      // Arrays\r\n      System.out.println(\"Array-Dimensions of 'new int[][]': \" + Utils.getArrayDimensions(new int[][]{}));\r\n      System.out.println(\"Array-Dimensions of 'new int[][]{{1,2,3},{4,5,6}}': \" + Utils.getArrayDimensions(new int[][]{{1,2,3},{4,5,6}}));\r\n      String[][][] s = new String[3][4][];\r\n      System.out.println(\"Array-Dimensions of 'new String[3][4][]': \" + Utils.getArrayDimensions(s));\r\n    } catch (Exception e) {\r\n      e.printStackTrace();\r\n    }\r\n  }\r\n}\r\n  \r\n\r\n",
        "name": "Utils.java",
        "path": "src/keel/Algorithms/SVM/SMO/core/Utils.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/SVM/SMO/core/Utils.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 1702,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1703,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1704,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1725,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1726,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1727,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1751,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1779,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "/***********************************************************************\r\n\r\n\tThis file is part of KEEL-software, the Data Mining tool for regression, \r\n\tclassification, clustering, pattern mining and so on.\r\n\r\n\tCopyright (C) 2004-2010\r\n\t\r\n\tF. Herrera (herrera@decsai.ugr.es)\r\n    L. Sánchez (luciano@uniovi.es)\r\n    J. Alcalá-Fdez (jalcala@decsai.ugr.es)\r\n    S. García (sglopez@ujaen.es)\r\n    A. Fernández (alberto.fernandez@ujaen.es)\r\n    J. Luengo (julianlm@decsai.ugr.es)\r\n\r\n\tThis program is free software: you can redistribute it and/or modify\r\n\tit under the terms of the GNU General Public License as published by\r\n\tthe Free Software Foundation, either version 3 of the License, or\r\n\t(at your option) any later version.\r\n\r\n\tThis program is distributed in the hope that it will be useful,\r\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\tGNU General Public License for more details.\r\n\r\n\tYou should have received a copy of the GNU General Public License\r\n\talong with this program.  If not, see http://www.gnu.org/licenses/\r\n  \r\n**********************************************************************/\r\n\r\n/*\r\n *    This program is free software; you can redistribute it and/or modify\r\n *    it under the terms of the GNU General Public License as published by\r\n *    the Free Software Foundation; either version 2 of the License, or\r\n *    (at your option) any later version.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU General Public License\r\n *    along with this program; if not, write to the Free Software\r\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\r\n */\r\n\r\n/*\r\n *    Queue.java\r\n *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand\r\n *\r\n *    Modified March-May 2004 by Mark Utting to add JML specs\r\n *    (this was done as the example solution of an assignment for a\r\n *     software engineering course, so the specifications are more precise\r\n *     and complete than one would normally do).\r\n *    Passed a static analysis using ESC/Java-2.0a6 with no warnings.\r\n */\r\n\r\npackage keel.Algorithms.SVM.SMO.core;\r\n\r\nimport java.io.Serializable;\r\n\r\n/** \r\n * Class representing a FIFO queue.\r\n *\r\n * @author Len Trigg (trigg@cs.waikato.ac.nz)\r\n * @version $Revision: 1.1 $\r\n */\r\npublic class Queue\r\n  extends Object\r\n  implements Serializable {\r\n\r\n  /** for serialization */\r\n  private static final long serialVersionUID = -1141282001146389780L;\r\n\r\n  /**\r\n   * Represents one node in the queue.\r\n   */\r\n  protected class QueueNode\r\n    implements Serializable {\r\n\r\n    /** for serialization */\r\n    private static final long serialVersionUID = -5119358279412097455L;\r\n\r\n    /** The next node in the queue */\r\n    protected /*@ spec_public @*/ QueueNode m_Next;\r\n\r\n    /** The nodes contents\r\n     */\r\n    protected /*@ non_null spec_public @*/ Object m_Contents;\r\n\r\n    /** \r\n     * Creates a queue node with the given contents \r\n     *\r\n     * @param contents given contents.\r\n     * @requires contents != null;\r\n     * @assignable m_Contents, m_Next;\r\n     * @ensures m_Contents == contents;\r\n     * @ensures m_Next == null;\r\n     */\r\n    //@ requires contents != null;\r\n    //@ assignable m_Contents, m_Next;\r\n    //@ ensures m_Contents == contents;\r\n    //@ ensures m_Next == null;\r\n    public QueueNode(Object contents) {\r\n      m_Contents = contents;\r\n      next(null);\r\n    }\r\n\r\n    /**\r\n     * Sets the next node in the queue, and returns it.\r\n     * @param next node to set as next.\r\n     * @return the next noded already set.\r\n     * @requires next != this ;\r\n     * @assignable m_Next;\r\n     * @ensures m_Next==next \u0026\u0026 \\result==next;\r\n     */\r\n    public QueueNode next(QueueNode next) {\r\n      return m_Next = next;\r\n    } //@ nowarn Invariant; // Because it stupidly checks the Queue invariant!\r\n\r\n    /**\r\n     * Gets the next node in the queue. \r\n       * @return the next node in the queue.  \r\n       * @ensures \\result == m_Next;\r\n     */\r\n    public /*@ pure @*/ QueueNode next() {\r\n      return m_Next;\r\n    }\r\n\r\n    /**\r\n     * Sets the contents of the node.\r\n       * @param contents  the contents to set.\r\n       * @return the contents already set\r\n       * @requires contents != null;\r\n       * @assignable m_Contents;\r\n       * @ensures  m_Contents == contents \u0026\u0026 \\result == contents;\r\n     */\r\n    public Object contents(Object contents) {\r\n      return m_Contents = contents;\r\n    }\r\n\r\n    /**\r\n     * Returns the contents in the node.\r\n       * @return the contents in the node.\r\n       * @ensures \\result == m_Contents;\r\n     */\r\n    public /*@ pure @*/ Object contents() {\r\n      return m_Contents;\r\n    }\r\n  }\r\n\r\n  /** Store a reference to the head of the queue */\r\n  protected /*@ spec_public @*/ QueueNode m_Head = null;\r\n\r\n  /** Store a reference to the tail of the queue */\r\n  protected /*@ spec_public @*/ QueueNode m_Tail = null;\r\n\r\n  /** Store the c m_Tail.m_Nexturrent number of elements in the queue */\r\n  protected /*@ spec_public @*/ int m_Size = 0;\r\n\r\n  //@ public invariant m_Head == null \u003c==\u003e m_Tail == null;\r\n  //@public invariant m_Tail != null ==\u003e m_Tail.m_Next == null;\r\n  //@ public invariant m_Size \u003e= 0;\r\n  //@ public invariant m_Size == 0 \u003c==\u003e m_Head == null;\r\n  //@ public invariant m_Size == 1 \u003c==\u003e m_Head != null \u0026\u0026 m_Head == m_Tail;\r\n  //@ public invariant m_Size \u003e 1 ==\u003e m_Head != m_Tail;\r\n  //@ public invariant m_Size \u003e 1 \u003c== m_Head != m_Tail;\r\n\r\n\r\n\r\n  /**\r\n   * Removes all objects from the queue m_Tail.m_Next.\r\n   */\r\n  //@ assignable m_Size, m_Head, m_Tail;\r\n  //@ ensures m_Size == 0;\r\n  //@ ensures m_Head == null;\r\n  //@ ensures m_Tail == null;\r\n  public final synchronized void removeAllElements() {\r\n    m_Size = 0;\r\n    m_Head = null;\r\n    m_Tail = null;\r\n  }\r\n\r\n  /**\r\n   * Appends an object to the back of the queue.\r\n   *\r\n   * @param item the object to be appended\r\n   * @return the object appended\r\n   */\r\n  //@ requires item != null;\r\n  //@ assignable m_Head, m_Tail, m_Tail.m_Next, m_Head.m_Next, m_Size;\r\n  //@ ensures m_Head != null;\r\n  //@ ensures m_Tail != \\old(m_Tail);\r\n  //@ ensures m_Size == \\old(m_Size) + 1;\r\n  //@ ensures \\old(m_Size) == 0 ==\u003e m_Head == m_Tail; \r\n  //@ ensures \\old(m_Size) != 0 ==\u003e m_Head == \\old(m_Head);\r\n  //@ ensures m_Tail.contents() == \\old(item);\r\n  //@ ensures \\result == item;\r\n  public synchronized Object push(Object item) {\r\n    QueueNode newNode = new QueueNode(item);\r\n    \r\n    if (m_Head == null) {\r\n      m_Head = m_Tail = newNode;\r\n    } else {\r\n      m_Tail = m_Tail.next(newNode);\r\n    }\r\n    m_Size++;\r\n    return item;\r\n  }\r\n\r\n  /**\r\n   * Pops an object from the front of the queue.\r\n   *\r\n   * @return the object at the front of the queue\r\n   * @exception RuntimeException if the queue is empty\r\n   */\r\n  //@ assignable m_Head, m_Tail, m_Size;\r\n  //@ ensures m_Size == \\old(m_Size) - 1;\r\n  //@ ensures m_Head == \\old(m_Head.m_Next);\r\n  //@ ensures m_Head != null ==\u003e m_Tail == \\old(m_Tail);\r\n  //@ ensures \\result == \\old(m_Head.m_Contents);\r\n  //@ signals (RuntimeException) \\old(m_Head) == null;\r\n  public synchronized Object pop() \r\n      throws RuntimeException   // REDUNDANT, BUT ESCJAVA REQUIRES THIS\r\n  {\r\n    if (m_Head == null) {\r\n\tthrow new RuntimeException(\"Queue is empty\");\r\n    }\r\n    Object retval = m_Head.contents();\r\n    m_Size--;\r\n    m_Head = m_Head.next();\r\n    // Here we need to either tell ESC/Java some facts about\r\n    // the contents of the list after popping off the head,\r\n    // or turn off the 'invariant' warnings.\r\n    //\r\n    //@ assume m_Size == 0 \u003c==\u003e m_Head == null;\r\n    //@ assume m_Size == 1 \u003c==\u003e m_Head == m_Tail;\r\n    if (m_Head == null) {\r\n      m_Tail = null;\r\n    }\r\n    return retval;\r\n  }\r\n\r\n  /**\r\n   * Gets object from the front of the queue.\r\n   *\r\n   * @return the object at the front of the queue\r\n   * @exception RuntimeException if the queue is empty\r\n   */\r\n  //@ ensures \\result == \\old(m_Head.m_Contents);\r\n  //@ signals (RuntimeException) \\old(m_Head) == null;\r\n  public /*@ pure @*/ synchronized Object peek() \r\n    throws RuntimeException\r\n  { \r\n    if (m_Head == null) {\r\n      throw new RuntimeException(\"Queue is empty\");\r\n    }\r\n    return m_Head.contents();\r\n  }\r\n\r\n  /**\r\n   * Checks if queue is empty.\r\n   * \r\n   * @return true if queue is empty\r\n   */\r\n  //@ ensures \\result \u003c==\u003e m_Head == null;\r\n  public /*@ pure @*/ boolean empty() {\r\n    return m_Head == null;\r\n  }\r\n\r\n  /**\r\n   * Gets queue's size.\r\n   *\r\n   * @return size of queue\r\n   */\r\n  //@ ensures \\result == m_Size;\r\n  public /*@ pure @*/ int size() {\r\n    return m_Size;\r\n  }\r\n\r\n  /**\r\n   * Produces textual description of queue.\r\n   *\r\n   * @return textual description of queue\r\n   */\r\n  //@ also\r\n  //@ ensures \\result != null;\r\n  //@ ensures (* \\result == textual description of the queue *);\r\n  public  /*@ pure @*/ String toString() {\r\n\r\n    String retval = \"Queue Contents \"+m_Size+\" elements\\n\";\r\n    QueueNode current = m_Head;\r\n    if (current == null) {\r\n      return retval + \"Empty\\n\";\r\n    } else {\r\n      while (current != null) {\r\n        retval += current.contents().toString()+\"\\n\"; //@nowarn Modifies;\r\n\tcurrent = current.next();\r\n      }\r\n    }\r\n    return retval;\r\n  } //@ nowarn Post;\r\n\r\n  /**\r\n   * Main method for testing this class.\r\n   *\r\n   * @param argv a set of strings that are pushed on a test queue\r\n   */\r\n  //@ requires argv.length \u003e= 0;\r\n  //@ requires argv != null;\r\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c argv.length; argv[i] != null);\r\n  public static void main(String [] argv) {\r\n\r\n    try {\r\n      Queue queue = new Queue();\r\n      for(int i = 0; i \u003c argv.length; i++) {\r\n\tqueue.push(argv[i]);\r\n      }\r\n      System.out.println(\"After pushing command line arguments\");\r\n      System.out.println(queue.toString());\r\n      while (!queue.empty()) {\r\n\tSystem.out.println(\"Pop: \" + queue.pop().toString());\r\n      }\r\n      // try one more pop, to make sure we get an exception\r\n      try \r\n\t{\r\n\t  queue.pop();\r\n\t  System.out.println(\"ERROR: pop did not throw exception!\");\r\n\t}\r\n      catch (RuntimeException ex)\r\n        {\r\n\t  System.out.println(\"Pop on empty queue correctly gave exception.\");\r\n\t}\r\n    } catch (Exception ex) {\r\n      System.out.println(ex.getMessage());\r\n    }\r\n  }\r\n}\r\n\r\n",
        "name": "Queue.java",
        "path": "src/keel/Algorithms/SVM/SMO/core/Queue.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/SVM/SMO/core/Queue.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 98,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires contents != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 100,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures m_Contents == contents;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 101,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures m_Next == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 173,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Size == 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 174,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 175,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Tail == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 188,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires item != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 190,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 191,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Tail != \\old(m_Tail);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 192,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Size == \\old(m_Size) + 1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 193,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\old(m_Size) == 0 ==\u003e m_Head == m_Tail; \r"
        },
        {
          "limitHit": false,
          "lineNumber": 194,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\old(m_Size) != 0 ==\u003e m_Head == \\old(m_Head);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 195,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Tail.contents() == \\old(item);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 196,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == item;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 216,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Size == \\old(m_Size) - 1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 217,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head == \\old(m_Head.m_Next);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 218,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head != null ==\u003e m_Tail == \\old(m_Tail);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 219,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == \\old(m_Head.m_Contents);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 248,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == \\old(m_Head.m_Contents);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 264,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e m_Head == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 274,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Size;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 285,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 286,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures (* \\result == textual description of the queue *);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 307,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires argv.length \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 308,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires argv != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 309,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c argv.length; argv[i] != null);\r"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "/***********************************************************************\r\n\r\n\tThis file is part of KEEL-software, the Data Mining tool for regression, \r\n\tclassification, clustering, pattern mining and so on.\r\n\r\n\tCopyright (C) 2004-2010\r\n\t\r\n\tF. Herrera (herrera@decsai.ugr.es)\r\n    L. Sánchez (luciano@uniovi.es)\r\n    J. Alcalá-Fdez (jalcala@decsai.ugr.es)\r\n    S. García (sglopez@ujaen.es)\r\n    A. Fernández (alberto.fernandez@ujaen.es)\r\n    J. Luengo (julianlm@decsai.ugr.es)\r\n\r\n\tThis program is free software: you can redistribute it and/or modify\r\n\tit under the terms of the GNU General Public License as published by\r\n\tthe Free Software Foundation, either version 3 of the License, or\r\n\t(at your option) any later version.\r\n\r\n\tThis program is distributed in the hope that it will be useful,\r\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\tGNU General Public License for more details.\r\n\r\n\tYou should have received a copy of the GNU General Public License\r\n\talong with this program.  If not, see http://www.gnu.org/licenses/\r\n  \r\n**********************************************************************/\r\n\r\n/*\r\n *    This program is free software; you can redistribute it and/or modify\r\n *    it under the terms of the GNU General Public License as published by\r\n *    the Free Software Foundation; either version 2 of the License, or\r\n *    (at your option) any later version.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU General Public License\r\n *    along with this program; if not, write to the Free Software\r\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\r\n */\r\n\r\n/*\r\n *    FastVector.java\r\n *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand\r\n *\r\n */\r\n\r\npackage keel.Algorithms.SVM.SMO.core;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.Enumeration;\r\n\r\n/**\r\n * Implements a fast vector class without synchronized\r\n * methods. Replaces java.util.Vector. (Synchronized methods tend to\r\n * be slow.)\r\n *\r\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\r\n * @version $Revision: 1.1 $\r\n */\r\npublic class FastVector\r\n  implements Copyable, Serializable {\r\n\r\n  /** for serialization */\r\n  private static final long serialVersionUID = -2173635135622930169L;\r\n\r\n  /**\r\n   * Class for enumerating the vector's elements.\r\n   */\r\n  public class FastVectorEnumeration implements Enumeration {\r\n\r\n    /** The counter. */\r\n    private int m_Counter;\r\n    // These JML commands say how m_Counter implements Enumeration\r\n    //@ in moreElements;\r\n    //@ private represents moreElements = m_Counter \u003c m_Vector.size();\r\n    //@ private invariant 0 \u003c= m_Counter \u0026\u0026 m_Counter \u003c= m_Vector.size();\r\n\r\n    /** The vector. */\r\n    private /*@non_null@*/ FastVector m_Vector;\r\n\r\n    /** Special element. Skipped during enumeration. */\r\n    private int m_SpecialElement;\r\n    //@ private invariant -1 \u003c= m_SpecialElement;\r\n    //@ private invariant m_SpecialElement \u003c m_Vector.size();\r\n    //@ private invariant m_SpecialElement\u003e=0 ==\u003e m_Counter!=m_SpecialElement;\r\n\r\n    /**\r\n     * Constructs an enumeration.\r\n     *\r\n     * @param vector the vector which is to be enumerated\r\n     */\r\n    public FastVectorEnumeration(/*@non_null@*/FastVector vector) {\r\n\r\n      m_Counter = 0;\r\n      m_Vector = vector;\r\n      m_SpecialElement = -1;\r\n    }\r\n\r\n    /**\r\n     * Constructs an enumeration with a special element.\r\n     * The special element is skipped during the enumeration.\r\n     *\r\n     * @param vector the vector which is to be enumerated\r\n     * @param special the index of the special element\r\n     */\r\n    //@ requires 0 \u003c= special \u0026\u0026 special \u003c vector.size();\r\n    public FastVectorEnumeration(/*@non_null@*/FastVector vector, int special){\r\n\r\n      m_Vector = vector;\r\n      m_SpecialElement = special;\r\n      if (special == 0) {\r\n\tm_Counter = 1;\r\n      } else {\r\n\tm_Counter = 0;\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * Tests if there are any more elements to enumerate.\r\n     *\r\n     * @return true if there are some elements left\r\n     */\r\n    public final /*@pure@*/ boolean hasMoreElements() {\r\n\r\n      if (m_Counter \u003c m_Vector.size()) {\r\n\treturn true;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Returns the next element.\r\n     *\r\n     * @return the next element to be enumerated\r\n     */\r\n    //@ also requires hasMoreElements();\r\n    public final Object nextElement() {\r\n  \r\n      Object result = m_Vector.elementAt(m_Counter);\r\n\r\n      m_Counter++;\r\n      if (m_Counter == m_SpecialElement) {\r\n\tm_Counter++;\r\n      }\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /** The array of objects. */\r\n  private /*@spec_public@*/ Object[] m_Objects;\r\n  //@ invariant m_Objects != null;\r\n  //@ invariant m_Objects.length \u003e= 0;\r\n\r\n  /** The current size; */\r\n  private /*@spec_public@*/ int m_Size = 0;\r\n  //@ invariant 0 \u003c= m_Size;\r\n  //@ invariant m_Size \u003c= m_Objects.length;\r\n\r\n  /** The capacity increment */\r\n  private /*@spec_public@*/ int m_CapacityIncrement = 1;\r\n  //@ invariant 1 \u003c= m_CapacityIncrement;\r\n  \r\n  /** The capacity multiplier. */\r\n  private /*@spec_public@*/ int m_CapacityMultiplier = 2;\r\n  //@ invariant 1 \u003c= m_CapacityMultiplier;\r\n\r\n  // Make sure the size will increase...\r\n  //@ invariant 3 \u003c= m_CapacityMultiplier + m_CapacityIncrement;\r\n\r\n  /**\r\n   * Constructs an empty vector with initial\r\n   * capacity zero.\r\n   */\r\n  public FastVector() {\r\n  \r\n    m_Objects = new Object[0];\r\n  }\r\n\r\n  /**\r\n   * Constructs a vector with the given capacity.\r\n   *\r\n   * @param capacity the vector's initial capacity\r\n   */\r\n  //@ requires capacity \u003e= 0;\r\n  public FastVector(int capacity) {\r\n\r\n    m_Objects = new Object[capacity];\r\n  }\r\n\r\n  /**\r\n   * Adds an element to this vector. Increases its\r\n   * capacity if its not large enough.\r\n   *\r\n   * @param element the element to add\r\n   */\r\n  public final void addElement(Object element) {\r\n\r\n    Object[] newObjects;\r\n\r\n    if (m_Size == m_Objects.length) {\r\n      newObjects = new Object[m_CapacityMultiplier *\r\n\t\t\t     (m_Objects.length +\r\n\t\t\t      m_CapacityIncrement)];\r\n      System.arraycopy(m_Objects, 0, newObjects, 0, m_Size);\r\n      m_Objects = newObjects;\r\n    }\r\n    m_Objects[m_Size] = element;\r\n    m_Size++;\r\n  }\r\n\r\n  /**\r\n   * Returns the capacity of the vector.\r\n   *\r\n   * @return the capacity of the vector\r\n   */\r\n  //@ ensures \\result == m_Objects.length;\r\n  public final /*@pure@*/ int capacity() {\r\n  \r\n    return m_Objects.length;\r\n  }\r\n\r\n  /**\r\n   * Produces a shallow copy of this vector.\r\n   *\r\n   * @return the new vector\r\n   */\r\n  public final Object copy() {\r\n\r\n    FastVector copy = new FastVector(m_Objects.length);\r\n\r\n    copy.m_Size = m_Size;\r\n    copy.m_CapacityIncrement = m_CapacityIncrement;\r\n    copy.m_CapacityMultiplier = m_CapacityMultiplier;\r\n    System.arraycopy(m_Objects, 0, copy.m_Objects, 0, m_Size);\r\n    return copy;\r\n  }\r\n\r\n  /**\r\n   * Clones the vector and shallow copies all its elements.\r\n   * The elements have to implement the Copyable interface.\r\n   * \r\n   * @return the new vector\r\n   */\r\n  public final Object copyElements() {\r\n\r\n    FastVector copy = new FastVector(m_Objects.length);\r\n\r\n    copy.m_Size = m_Size;\r\n    copy.m_CapacityIncrement = m_CapacityIncrement;\r\n    copy.m_CapacityMultiplier = m_CapacityMultiplier;\r\n    for (int i = 0; i \u003c m_Size; i++) {\r\n      copy.m_Objects[i] = ((Copyable)m_Objects[i]).copy();\r\n    }\r\n    return copy;\r\n  }\r\n\r\n  /**\r\n   * Returns the element at the given position.\r\n   *\r\n   * @param index the element's index\r\n   * @return the element with the given index\r\n   */\r\n  //@ requires 0 \u003c= index;\r\n  //@ requires index \u003c m_Objects.length;\r\n  public final /*@pure@*/ Object elementAt(int index) {\r\n\r\n    return m_Objects[index];\r\n  }\r\n\r\n  /**\r\n   * Returns an enumeration of this vector.\r\n   *\r\n   * @return an enumeration of this vector\r\n   */\r\n  public final /*@pure@*/ Enumeration elements() {\r\n  \r\n    return new FastVectorEnumeration(this);\r\n  }\r\n\r\n  /**\r\n   * Returns an enumeration of this vector, skipping the\r\n   * element with the given index.\r\n   *\r\n   * @param index the element to skip\r\n   * @return an enumeration of this vector\r\n   */\r\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();\r\n  public final /*@pure@*/ Enumeration elements(int index) {\r\n  \r\n    return new FastVectorEnumeration(this, index);\r\n  }\r\n\r\n    /** \r\n     * Checks if the object given as parameter is contained in the vector.\r\n     * @param o object given to check.\r\n     * @return True if the object given is contained in the vector, False otherwise.\r\n     */\r\n  public /*@pure@*/ boolean contains(Object o) {\r\n      if(o==null)\r\n\t  return false;\r\n\r\n      for(int i=0; i\u003cm_Objects.length; i++) \r\n\t  if(o.equals(m_Objects[i]))\r\n\t      return true;\r\n      \r\n      return false;\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns the first element of the vector.\r\n   *\r\n   * @return the first element of the vector\r\n   */\r\n  //@ requires m_Size \u003e 0;\r\n  public final /*@pure@*/ Object firstElement() {\r\n\r\n    return m_Objects[0];\r\n  }\r\n\r\n  /**\r\n   * Searches for the first occurence of the given argument, \r\n   * testing for equality using the equals method. \r\n   *\r\n   * @param element the element to be found\r\n   * @return the index of the first occurrence of the argument \r\n   * in this vector; returns -1 if the object is not found\r\n   */\r\n  public final /*@pure@*/ int indexOf(/*@non_null@*/ Object element) {\r\n\r\n    for (int i = 0; i \u003c m_Size; i++) {\r\n      if (element.equals(m_Objects[i])) {\r\n\treturn i;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Inserts an element at the given position.\r\n   *\r\n   * @param element the element to be inserted\r\n   * @param index the element's index\r\n   */\r\n  public final void insertElementAt(Object element, int index) {\r\n\r\n    Object[] newObjects;\r\n\r\n    if (m_Size \u003c m_Objects.length) {\r\n      System.arraycopy(m_Objects, index, m_Objects, index + 1, \r\n                       m_Size - index);\r\n      m_Objects[index] = element;\r\n    } else {\r\n      newObjects = new Object[m_CapacityMultiplier *\r\n\t\t\t     (m_Objects.length +\r\n\t\t\t      m_CapacityIncrement)];\r\n      System.arraycopy(m_Objects, 0, newObjects, 0, index);\r\n      newObjects[index] = element;\r\n      System.arraycopy(m_Objects, index, newObjects, index + 1,\r\n\t\t       m_Size - index);\r\n      m_Objects = newObjects;\r\n    }\r\n    m_Size++;\r\n  }\r\n\r\n  /**\r\n   * Returns the last element of the vector.\r\n   *\r\n   * @return the last element of the vector\r\n   */\r\n  //@ requires m_Size \u003e 0;\r\n  public final /*@pure@*/ Object lastElement() {\r\n\r\n    return m_Objects[m_Size - 1];\r\n  }\r\n\r\n  /**\r\n   * Deletes an element from this vector.\r\n   *\r\n   * @param index the index of the element to be deleted\r\n   */\r\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Size;\r\n  public final void removeElementAt(int index) {\r\n\r\n    System.arraycopy(m_Objects, index + 1, m_Objects, index, \r\n                     m_Size - index - 1);\r\n    m_Size--;\r\n  }\r\n\r\n  /**\r\n   * Removes all components from this vector and sets its \r\n   * size to zero. \r\n   */\r\n  public final void removeAllElements() {\r\n\r\n    m_Objects = new Object[m_Objects.length];\r\n    m_Size = 0;\r\n  }\r\n\r\n  /**\r\n   * Appends all elements of the supplied vector to this vector.\r\n   *\r\n   * @param toAppend the FastVector containing elements to append.\r\n   */\r\n  public final void appendElements(FastVector toAppend) {\r\n\r\n    setCapacity(size() + toAppend.size());\r\n    System.arraycopy(toAppend.m_Objects, 0, m_Objects, size(), toAppend.size());\r\n    m_Size = m_Objects.length;\r\n  }\r\n\r\n  /** \r\n   * Returns all the elements of this vector as an array\r\n   *\r\n   * @return an array containing all the elements of this vector\r\n   */\r\n  public final Object [] toArray() {\r\n\r\n    Object [] newObjects = new Object[size()];\r\n    System.arraycopy(m_Objects, 0, newObjects, 0, size());\r\n    return newObjects;\r\n  }\r\n\r\n  /**\r\n   * Sets the vector's capacity to the given value.\r\n   *\r\n   * @param capacity the new capacity\r\n   */\r\n  public final void setCapacity(int capacity) {\r\n\r\n    Object[] newObjects = new Object[capacity];\r\n   \r\n    System.arraycopy(m_Objects, 0, newObjects, 0, Math.min(capacity, m_Size));\r\n    m_Objects = newObjects;\r\n    if (m_Objects.length \u003c m_Size)\r\n      m_Size = m_Objects.length;\r\n  }\r\n\r\n  /**\r\n   * Sets the element at the given index.\r\n   *\r\n   * @param element the element to be put into the vector\r\n   * @param index the index at which the element is to be placed\r\n   */\r\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();\r\n  public final void setElementAt(Object element, int index) {\r\n\r\n    m_Objects[index] = element;\r\n  }\r\n\r\n  /**\r\n   * Returns the vector's current size.\r\n   *\r\n   * @return the vector's current size\r\n   */\r\n  //@ ensures \\result == m_Size;\r\n  public final /*@pure@*/ int size() {\r\n\r\n    return m_Size;\r\n  }\r\n\r\n  /**\r\n   * Swaps two elements in the vector.\r\n   *\r\n   * @param first index of the first element\r\n   * @param second index of the second element\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c size();\r\n  //@ requires 0 \u003c= second \u0026\u0026 second \u003c size();\r\n  public final void swap(int first, int second) {\r\n\r\n    Object help = m_Objects[first];\r\n\r\n    m_Objects[first] = m_Objects[second];\r\n    m_Objects[second] = help;\r\n  }\r\n\r\n  /**\r\n   * Sets the vector's capacity to its size.\r\n   */\r\n  public final void trimToSize() {\r\n\r\n    Object[] newObjects = new Object[m_Size];\r\n    \r\n    System.arraycopy(m_Objects, 0, newObjects, 0, m_Size);\r\n    m_Objects = newObjects;\r\n  }\r\n}\r\n\r\n\r\n",
        "name": "FastVector.java",
        "path": "src/keel/Algorithms/SVM/SMO/core/FastVector.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/SVM/SMO/core/FastVector.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 110,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= special \u0026\u0026 special \u003c vector.size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 189,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires capacity \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 221,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Objects.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 268,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 269,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003c m_Objects.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 292,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 320,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Size \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 376,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Size \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 387,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Size;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 450,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 461,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Size;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 473,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 474,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= second \u0026\u0026 second \u003c size();\r"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "/***********************************************************************\r\n\r\n\tThis file is part of KEEL-software, the Data Mining tool for regression, \r\n\tclassification, clustering, pattern mining and so on.\r\n\r\n\tCopyright (C) 2004-2010\r\n\t\r\n\tF. Herrera (herrera@decsai.ugr.es)\r\n    L. Sánchez (luciano@uniovi.es)\r\n    J. Alcalá-Fdez (jalcala@decsai.ugr.es)\r\n    S. García (sglopez@ujaen.es)\r\n    A. Fernández (alberto.fernandez@ujaen.es)\r\n    J. Luengo (julianlm@decsai.ugr.es)\r\n\r\n\tThis program is free software: you can redistribute it and/or modify\r\n\tit under the terms of the GNU General Public License as published by\r\n\tthe Free Software Foundation, either version 3 of the License, or\r\n\t(at your option) any later version.\r\n\r\n\tThis program is distributed in the hope that it will be useful,\r\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\tGNU General Public License for more details.\r\n\r\n\tYou should have received a copy of the GNU General Public License\r\n\talong with this program.  If not, see http://www.gnu.org/licenses/\r\n  \r\n**********************************************************************/\r\n\r\n/*\r\n *    This program is free software; you can redistribute it and/or modify\r\n *    it under the terms of the GNU General Public License as published by\r\n *    the Free Software Foundation; either version 2 of the License, or\r\n *    (at your option) any later version.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU General Public License\r\n *    along with this program; if not, write to the Free Software\r\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\r\n */\r\n\r\n/*\r\n *    OptionHandler.java\r\n *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand\r\n *\r\n */\r\n\r\npackage keel.Algorithms.SVM.SMO.core;\r\n\r\nimport java.util.*;\r\n\r\n/** \r\n * Interface to something that understands options.\r\n *\r\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\r\n * @author Len Trigg (trigg@cs.waikato.ac.nz)\r\n * @version $Revision: 1.1 $\r\n */\r\npublic interface OptionHandler {\r\n\r\n  /**\r\n   * Returns an enumeration of all the available options..\r\n   *\r\n   * @return an enumeration of all available options.\r\n   */\r\n  Enumeration listOptions();\r\n\r\n  /**\r\n   * Sets the OptionHandler's options using the given list. All options\r\n   * will be set (or reset) during this call (i.e. incremental setting\r\n   * of options is not possible).\r\n   *\r\n   * @param options the list of options as an array of strings\r\n   * @exception Exception if an option is not supported\r\n   */\r\n  //@ requires options != null;\r\n  //@ requires \\nonnullelements(options);\r\n  void setOptions(String[] options) throws Exception;\r\n\r\n  /**\r\n   * Gets the current option settings for the OptionHandler.\r\n   *\r\n   * @return the list of current option settings as an array of strings\r\n   */\r\n  //@ ensures \\result != null;\r\n  //@ ensures \\nonnullelements(\\result);\r\n  /*@pure@*/ String[] getOptions();\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
        "name": "OptionHandler.java",
        "path": "src/keel/Algorithms/SVM/SMO/core/OptionHandler.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/SVM/SMO/core/OptionHandler.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 79,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires options != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 80,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires \\nonnullelements(options);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 88,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 89,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\nonnullelements(\\result);\r"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "/***********************************************************************\n\n\tThis file is part of KEEL-software, the Data Mining tool for regression, \n\tclassification, clustering, pattern mining and so on.\n\n\tCopyright (C) 2004-2010\n\n\tF. Herrera (herrera@decsai.ugr.es)\n    L. Sánchez (luciano@uniovi.es)\n    J. Alcalá-Fdez (jalcala@decsai.ugr.es)\n    S. García (sglopez@ujaen.es)\n    A. Fernández (alberto.fernandez@ujaen.es)\n    J. Luengo (julianlm@decsai.ugr.es)\n\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see http://www.gnu.org/licenses/\n\n **********************************************************************/\n\n/*\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; either version 2 of the License, or\n *    (at your option) any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n/*\n *    Utils.java\n *    Copyright (C) 1999-2004 University of Waikato, Hamilton, New Zealand\n *\n */\n\npackage keel.Algorithms.Semi_Supervised_Learning.CLCC;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.lang.reflect.Array;\nimport java.net.URL;\nimport java.util.Enumeration;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Vector;\n\n/**\n * Class implementing some simple utility methods.\n *\n * @author Eibe Frank \n * @author Yong Wang \n * @author Len Trigg \n * @author Julien Prados\n * @version $Revision: 6959 $\n */\npublic final class Utils{\n\n  /** The natural logarithm of 2. */\n  public static double log2 = Math.log(2);\n\n  /** The small deviation allowed in double comparisons. */\n  public static double SMALL = 1e-6;\n  \n  /**\n   * Tests if the given value codes \"missing\".\n   *\n   * @param val the value to be tested\n   * @return true if val codes \"missing\"\n   */\n  public static boolean isMissingValue(double val) {\n\n    return Double.isNaN(val);\n  }\n\n  /**\n   * Returns the value used to code a missing value.  Note that\n   * equality tests on this value will always return false, so use\n   * isMissingValue(double val) for testing..\n   *\n   * @return the value used as missing value.\n   */\n  public static double missingValue() {\n    \n    return Double.NaN;\n  }\n\n  /**\n   * Casting an object without \"unchecked\" compile-time warnings.\n   * Use only when absolutely necessary (e.g. when using clone()).\n     * @param \u003cT\u003e Type of the Object to be casted.\n     * @param x Object to be casted.\n     * @return object casted.\n   */\n  @SuppressWarnings(\"unchecked\")\n    public static \u003cT\u003e T cast(Object x) {\n    return (T) x;\n  }\n  \n  /**\n   * Reads properties that inherit from three locations. Properties\n   * are first defined in the system resource location (i.e. in the\n   * CLASSPATH).  These default properties must exist. Properties optionally\n   * defined in the user properties location (WekaPackageManager.PROPERTIES_DIR) \n   * override default settings. Properties defined in the current directory (optional)\n   * override all these settings.\n   *\n   * @param resourceName the location of the resource that should be\n   * loaded.  e.g.: \"weka/core/Utils.props\". (The use of hardcoded\n   * forward slashes here is OK - see\n   * jdk1.1/docs/guide/misc/resources.html) This routine will also\n   * look for the file (in this case) \"Utils.props\" in the users home\n   * directory and the current directory.\n   * @return the Properties\n   * @exception Exception if no default properties are defined, or if\n   * an error occurs reading the properties files.  \n   \n  public static Properties readProperties(String resourceName)\n    throws Exception {\n\n    Properties defaultProps = new Properties();\n    try {\n      // Apparently hardcoded slashes are OK here\n      // jdk1.1/docs/guide/misc/resources.html\n      Utils utils = new Utils();\n      Enumeration\u003cURL\u003e urls = utils.getClass().getClassLoader().getResources(resourceName);\n      boolean first = true;\n      while (urls.hasMoreElements()) {\n\tURL url = urls.nextElement();\n\tif (first) {\n\t  defaultProps.load(url.openStream());\n\t  first = false;\n\t}\n\telse {\n\t  Properties props = new Properties(defaultProps);\n\t  props.load(url.openStream());\n\t  defaultProps = props;\n\t}\n      }\n    } catch (Exception ex) {\n      System.err.println(\"Warning, unable to load properties file(s) from \"\n\t\t\t +\"system resource (Utils.java): \" + resourceName);\n    }\n\n    // Hardcoded slash is OK here\n    // eg: see jdk1.1/docs/guide/misc/resources.html\n    int slInd = resourceName.lastIndexOf('/');\n    if (slInd != -1) {\n      resourceName = resourceName.substring(slInd + 1);\n    }\n\n    // Allow a properties file in the WekaPackageManager.PROPERTIES_DIR to override\n    Properties userProps = new Properties(defaultProps);\n    if (!WekaPackageManager.PROPERTIES_DIR.exists()) {\n      WekaPackageManager.PROPERTIES_DIR.mkdir();\n    }\n    //File propFile = new File(WekaPackageManager.PROPERTIES_DIR.toString()\n      //                       + File.separator\n        //                     + resourceName);\n\n    if (propFile.exists()) {\n      try {\n        userProps.load(new FileInputStream(propFile));\n      } catch (Exception ex) {\n        throw new Exception(\"Problem reading user properties: \" + propFile);\n      }\n    }\n\n    // Allow a properties file in the current directory to override\n    Properties localProps = new Properties(userProps);\n    propFile = new File(resourceName);\n    if (propFile.exists()) {\n      try {\n        localProps.load(new FileInputStream(propFile));\n      } catch (Exception ex) {\n        throw new Exception(\"Problem reading local properties: \" + propFile);\n      }\n    }\n    \n    return localProps;\n  }\n*/\n  /**\n   * Returns the correlation coefficient of two double vectors.\n   *\n   * @param y1 double vector 1\n   * @param y2 double vector 2\n   * @param n the length of two double vectors\n   * @return the correlation coefficient\n   */\n  public static final double correlation(double y1[],double y2[],int n) {\n\n    int i;\n    double av1 = 0.0, av2 = 0.0, y11 = 0.0, y22 = 0.0, y12 = 0.0, c;\n    \n    if (n \u003c= 1) {\n      return 1.0;\n    }\n    for (i = 0; i \u003c n; i++) {\n      av1 += y1[i];\n      av2 += y2[i];\n    }\n    av1 /= (double) n;\n    av2 /= (double) n;\n    for (i = 0; i \u003c n; i++) {\n      y11 += (y1[i] - av1) * (y1[i] - av1);\n      y22 += (y2[i] - av2) * (y2[i] - av2);\n      y12 += (y1[i] - av1) * (y2[i] - av2);\n    }\n    if (y11 * y22 == 0.0) {\n      c=1.0;\n    } else {\n      c = y12 / Math.sqrt(Math.abs(y11 * y22));\n    }\n    \n    return c;\n  }\n\n  /**\n   * Removes all occurrences of a string from another string.\n   *\n   * @param inString the string to remove substrings from.\n   * @param substring the substring to remove.\n   * @return the input string with occurrences of substring removed.\n   */\n  public static String removeSubstring(String inString, String substring) {\n\n    StringBuffer result = new StringBuffer();\n    int oldLoc = 0, loc = 0;\n    while ((loc = inString.indexOf(substring, oldLoc))!= -1) {\n      result.append(inString.substring(oldLoc, loc));\n      oldLoc = loc + substring.length();\n    }\n    result.append(inString.substring(oldLoc));\n    return result.toString();\n  }\n\n  /**\n   * Replaces with a new string, all occurrences of a string from \n   * another string.\n   *\n   * @param inString the string to replace substrings in.\n   * @param subString the substring to replace.\n   * @param replaceString the replacement substring\n   * @return the input string with occurrences of substring replaced.\n   */\n  public static String replaceSubstring(String inString, String subString,\n\t\t\t\t\tString replaceString) {\n\n    StringBuffer result = new StringBuffer();\n    int oldLoc = 0, loc = 0;\n    while ((loc = inString.indexOf(subString, oldLoc))!= -1) {\n      result.append(inString.substring(oldLoc, loc));\n      result.append(replaceString);\n      oldLoc = loc + subString.length();\n    }\n    result.append(inString.substring(oldLoc));\n    return result.toString();\n  }\n\n\n  /**\n   * Pads a string to a specified length, inserting spaces on the left\n   * as required. If the string is too long, characters are removed (from\n   * the right).\n   *\n   * @param inString the input string\n   * @param length the desired length of the output string\n   * @return the output string\n   */\n  public static String padLeft(String inString, int length) {\n\n    return fixStringLength(inString, length, false);\n  }\n  \n  /**\n   * Pads a string to a specified length, inserting spaces on the right\n   * as required. If the string is too long, characters are removed (from\n   * the right).\n   *\n   * @param inString the input string\n   * @param length the desired length of the output string\n   * @return the output string\n   */\n  public static String padRight(String inString, int length) {\n\n    return fixStringLength(inString, length, true);\n  }\n  \n  /**\n   * Pads a string to a specified length, inserting spaces as\n   * required. If the string is too long, characters are removed (from\n   * the right).\n   *\n   * @param inString the input string\n   * @param length the desired length of the output string\n   * @param right true if inserted spaces should be added to the right\n   * @return the output string\n   */\n  private static /*@pure@*/ String fixStringLength(String inString, int length,\n\t\t\t\t\tboolean right) {\n\n    if (inString.length() \u003c length) {\n      while (inString.length() \u003c length) {\n\tinString = (right ? inString.concat(\" \") : \" \".concat(inString));\n      }\n    } else if (inString.length() \u003e length) {\n      inString = inString.substring(0, length);\n    }\n    return inString;\n  }\n \n  /**\n   * Rounds a double and converts it into String.\n   *\n   * @param value the double value\n   * @param afterDecimalPoint the (maximum) number of digits permitted\n   * after the decimal point\n   * @return the double as a formatted string\n   */\n  public static /*@pure@*/ String doubleToString(double value, int afterDecimalPoint) {\n    \n    StringBuffer stringBuffer;\n    double temp;\n    int dotPosition;\n    long precisionValue;\n    \n    temp = value * Math.pow(10.0, afterDecimalPoint);\n    if (Math.abs(temp) \u003c Long.MAX_VALUE) {\n      precisionValue = \t(temp \u003e 0) ? (long)(temp + 0.5) \n                                   : -(long)(Math.abs(temp) + 0.5);\n      if (precisionValue == 0) {\n\tstringBuffer = new StringBuffer(String.valueOf(0));\n      } else {\n\tstringBuffer = new StringBuffer(String.valueOf(precisionValue));\n      }\n      if (afterDecimalPoint == 0) {\n\treturn stringBuffer.toString();\n      }\n      dotPosition = stringBuffer.length() - afterDecimalPoint;\n      while (((precisionValue \u003c 0) \u0026\u0026 (dotPosition \u003c 1)) ||\n\t     (dotPosition \u003c 0)) {\n\tif (precisionValue \u003c 0) {\n\t  stringBuffer.insert(1, '0');\n\t} else {\n\t  stringBuffer.insert(0, '0');\n\t}\n\tdotPosition++;\n      }\n      stringBuffer.insert(dotPosition, '.');\n      if ((precisionValue \u003c 0) \u0026\u0026 (stringBuffer.charAt(1) == '.')) {\n\tstringBuffer.insert(1, '0');\n      } else if (stringBuffer.charAt(0) == '.') {\n\tstringBuffer.insert(0, '0');\n      }\n      int currentPos = stringBuffer.length() - 1;\n      while ((currentPos \u003e dotPosition) \u0026\u0026\n\t     (stringBuffer.charAt(currentPos) == '0')) {\n\tstringBuffer.setCharAt(currentPos--, ' ');\n      }\n      if (stringBuffer.charAt(currentPos) == '.') {\n\tstringBuffer.setCharAt(currentPos, ' ');\n      }\n      \n      return stringBuffer.toString().trim();\n    }\n    return new String(\"\" + value);\n  }\n\n  /**\n   * Rounds a double and converts it into a formatted decimal-justified String.\n   * Trailing 0's are replaced with spaces.\n   *\n   * @param value the double value\n   * @param width the width of the string\n   * @param afterDecimalPoint the number of digits after the decimal point\n   * @return the double as a formatted string\n   */\n  public static /*@pure@*/ String doubleToString(double value, int width,\n\t\t\t\t      int afterDecimalPoint) {\n    \n    String tempString = doubleToString(value, afterDecimalPoint);\n    char[] result;\n    int dotPosition;\n\n    if ((afterDecimalPoint \u003e= width) \n        || (tempString.indexOf('E') != -1)) { // Protects sci notation\n      return tempString;\n    }\n\n    // Initialize result\n    result = new char[width];\n    for (int i = 0; i \u003c result.length; i++) {\n      result[i] = ' ';\n    }\n\n    if (afterDecimalPoint \u003e 0) {\n      // Get position of decimal point and insert decimal point\n      dotPosition = tempString.indexOf('.');\n      if (dotPosition == -1) {\n\tdotPosition = tempString.length();\n      } else {\n\tresult[width - afterDecimalPoint - 1] = '.';\n      }\n    } else {\n      dotPosition = tempString.length();\n    }\n    \n\n    int offset = width - afterDecimalPoint - dotPosition;\n    if (afterDecimalPoint \u003e 0) {\n      offset--;\n    }\n\n    // Not enough room to decimal align within the supplied width\n    if (offset \u003c 0) {\n      return tempString;\n    }\n\n    // Copy characters before decimal point\n    for (int i = 0; i \u003c dotPosition; i++) {\n      result[offset + i] = tempString.charAt(i);\n    }\n\n    // Copy characters after decimal point\n    for (int i = dotPosition + 1; i \u003c tempString.length(); i++) {\n      result[offset + i] = tempString.charAt(i);\n    }\n\n    return new String(result);\n  }\n\n  /**\n   * Returns the basic class of an array class (handles multi-dimensional\n   * arrays).\n   * @param c        the array to inspect\n   * @return         the class of the innermost elements\n   */\n  public static Class getArrayClass(Class c) {\n     if (c.getComponentType().isArray())\n        return getArrayClass(c.getComponentType());\n     else\n        return c.getComponentType();\n  }\n\n  /**\n   * Returns the dimensions of the given array. Even though the\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\n   * int[3] or double[2][4].\n   *\n   * @param array       the array to determine the dimensions for\n   * @return            the dimensions of the array\n   */\n  public static int getArrayDimensions(Class array) {\n    if (array.getComponentType().isArray())\n      return 1 + getArrayDimensions(array.getComponentType());\n    else\n      return 1;\n  }\n\n  /**\n   * Returns the dimensions of the given array. Even though the\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\n   * int[3] or double[2][4].\n   *\n   * @param array       the array to determine the dimensions for\n   * @return            the dimensions of the array\n   */\n  public static int getArrayDimensions(Object array) {\n    return getArrayDimensions(array.getClass());\n  }\n\n  /**\n   * Returns the given Array in a string representation. Even though the\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\n   * int[3] or double[2][4].\n   * \n   * @param array       the array to return in a string representation\n   * @return            the array as string\n   */\n  public static String arrayToString(Object array) {\n    String        result;\n    int           dimensions;\n    int           i;       \n\n    result     = \"\";\n    dimensions = getArrayDimensions(array);\n    \n    if (dimensions == 0) {\n      result = \"null\";\n    }\n    else if (dimensions == 1) {\n      for (i = 0; i \u003c Array.getLength(array); i++) {\n        if (i \u003e 0)\n          result += \",\";\n        if (Array.get(array, i) == null)\n          result += \"null\";\n        else\n          result += Array.get(array, i).toString();\n      }\n    }\n    else {\n      for (i = 0; i \u003c Array.getLength(array); i++) {\n        if (i \u003e 0)\n          result += \",\";\n        result += \"[\" + arrayToString(Array.get(array, i)) + \"]\";\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * Tests if a is equal to b.\n   *\n   * @param a a double\n   * @param b a double\n     * @return True if a is equal to b. \n   */\n  public static /*@pure@*/ boolean eq(double a, double b){\n    \n    return (a - b \u003c SMALL) \u0026\u0026 (b - a \u003c SMALL); \n  }\n\n  /**\n   * Checks if the given array contains any non-empty options.\n   *\n   * @param options an array of strings\n   * @exception Exception if there are any non-empty options\n   */\n  public static void checkForRemainingOptions(String[] options) \n    throws Exception {\n    \n    int illegalOptionsFound = 0;\n    StringBuffer text = new StringBuffer();\n\n    if (options == null) {\n      return;\n    }\n    for (int i = 0; i \u003c options.length; i++) {\n      if (options[i].length() \u003e 0) {\n\tillegalOptionsFound++;\n\ttext.append(options[i] + ' ');\n      }\n    }\n    if (illegalOptionsFound \u003e 0) {\n      throw new Exception(\"Illegal options: \" + text);\n    }\n  }\n  \n  /**\n   * Checks if the given array contains the flag \"-Char\". Stops\n   * searching at the first marker \"--\". If the flag is found,\n   * it is replaced with the empty string.\n   *\n   * @param flag the character indicating the flag.\n   * @param options the array of strings containing all the options.\n   * @return true if the flag was found\n   * @exception Exception if an illegal option was found\n   */\n  public static boolean getFlag(char flag, String[] options) \n    throws Exception {\n    \n    return getFlag(\"\" + flag, options);\n  }\n  \n  /**\n   * Checks if the given array contains the flag \"-String\". Stops\n   * searching at the first marker \"--\". If the flag is found,\n   * it is replaced with the empty string.\n   *\n   * @param flag the String indicating the flag.\n   * @param options the array of strings containing all the options.\n   * @return true if the flag was found\n   * @exception Exception if an illegal option was found\n   */\n  public static boolean getFlag(String flag, String[] options) \n    throws Exception {\n    \n    int pos = getOptionPos(flag, options);\n\n    if (pos \u003e -1)\n      options[pos] = \"\";\n    \n    return (pos \u003e -1);\n  }\n\n  /**\n   * Gets an option indicated by a flag \"-Char\" from the given array\n   * of strings. Stops searching at the first marker \"--\". Replaces \n   * flag and option with empty strings.\n   *\n   * @param flag the character indicating the option.\n   * @param options the array of strings containing all the options.\n   * @return the indicated option or an empty string\n   * @exception Exception if the option indicated by the flag can't be found\n   */\n  public static /*@non_null@*/ String getOption(char flag, String[] options) \n    throws Exception {\n    \n    return getOption(\"\" + flag, options);\n  }\n\n  /**\n   * Gets an option indicated by a flag \"-String\" from the given array\n   * of strings. Stops searching at the first marker \"--\". Replaces \n   * flag and option with empty strings.\n   *\n   * @param flag the String indicating the option.\n   * @param options the array of strings containing all the options.\n   * @return the indicated option or an empty string\n   * @exception Exception if the option indicated by the flag can't be found\n   */\n  public static /*@non_null@*/ String getOption(String flag, String[] options) \n    throws Exception {\n\n    String newString;\n    int i = getOptionPos(flag, options);\n\n    if (i \u003e -1) {\n      if (options[i].equals(\"-\" + flag)) {\n\tif (i + 1 == options.length) {\n\t  throw new Exception(\"No value given for -\" + flag + \" option.\");\n\t}\n\toptions[i] = \"\";\n\tnewString = new String(options[i + 1]);\n\toptions[i + 1] = \"\";\n\treturn newString;\n      }\n      if (options[i].charAt(1) == '-') {\n\treturn \"\";\n      }\n    }\n    \n    return \"\";\n  }\n\n  /**\n   * Gets the index of an option or flag indicated by a flag \"-Char\" from \n   * the given array of strings. Stops searching at the first marker \"--\".\n   *\n   * @param flag \tthe character indicating the option.\n   * @param options \tthe array of strings containing all the options.\n   * @return \t\tthe position if found, or -1 otherwise\n   */\n  public static int getOptionPos(char flag, String[] options) {\n     return getOptionPos(\"\" + flag, options);\n  }\n\n  /**\n   * Gets the index of an option or flag indicated by a flag \"-String\" from \n   * the given array of strings. Stops searching at the first marker \"--\".\n   *\n   * @param flag \tthe String indicating the option.\n   * @param options \tthe array of strings containing all the options.\n   * @return \t\tthe position if found, or -1 otherwise\n   */\n  public static int getOptionPos(String flag, String[] options) {\n    if (options == null)\n      return -1;\n    \n    for (int i = 0; i \u003c options.length; i++) {\n      if ((options[i].length() \u003e 0) \u0026\u0026 (options[i].charAt(0) == '-')) {\n\t// Check if it is a negative number\n\ttry {\n\t  Double.valueOf(options[i]);\n\t} \n\tcatch (NumberFormatException e) {\n\t  // found?\n\t  if (options[i].equals(\"-\" + flag))\n\t    return i;\n\t  // did we reach \"--\"?\n\t  if (options[i].charAt(1) == '-')\n\t    return -1;\n\t}\n      }\n    }\n    \n    return -1;\n  }\n\n  /**\n   * Quotes a string if it contains special characters.\n   * \n   * The following rules are applied:\n   *\n   * A character is backquoted version of it is one \n   * of \u003ctt\u003e\" ' % \\ \\n \\r \\t\u003c/tt\u003e.\n   *\n   * A string is enclosed within single quotes if a character has been\n   * backquoted using the previous rule above or contains \n   * \u003ctt\u003e{ }\u003c/tt\u003e or is exactly equal to the strings \n   * \u003ctt\u003e, ? space or \"\"\u003c/tt\u003e (empty string).\n   *\n   * A quoted question mark distinguishes it from the missing value which\n   * is represented as an unquoted question mark in arff files.\n   *\n   * @param string \tthe string to be quoted\n   * @return \t\tthe string (possibly quoted)\n   * @see\t\t#unquote(String)\n   */\n  public static /*@pure@*/ String quote(String string) {\n      boolean quote = false;\n\n      // backquote the following characters \n      if ((string.indexOf('\\n') != -1) || (string.indexOf('\\r') != -1) || \n\t  (string.indexOf('\\'') != -1) || (string.indexOf('\"') != -1) || \n\t  (string.indexOf('\\\\') != -1) || \n\t  (string.indexOf('\\t') != -1) || (string.indexOf('%') != -1)) {\n\t  string = backQuoteChars(string);\n\t  quote = true;\n      }\n\n      // Enclose the string in 's if the string contains a recently added\n      // backquote or contains one of the following characters.\n      if((quote == true) || \n\t (string.indexOf('{') != -1) || (string.indexOf('}') != -1) ||\n\t (string.indexOf(',') != -1) || (string.equals(\"?\")) ||\n\t (string.indexOf(' ') != -1) || (string.equals(\"\"))) {\n\t  string = (\"'\".concat(string)).concat(\"'\");\n      }\n\n      return string;\n  }\n\n  /**\n   * unquotes are previously quoted string (but only if necessary), i.e., it\n   * removes the single quotes around it. Inverse to quote(String).\n   * \n   * @param string\tthe string to process\n   * @return\t\tthe unquoted string\n   * @see\t\t#quote(String)\n   */\n  public static String unquote(String string) {\n    if (string.startsWith(\"'\") \u0026\u0026 string.endsWith(\"'\")) {\n      string = string.substring(1, string.length() - 1);\n      \n      if ((string.indexOf(\"\\\\n\") != -1) || (string.indexOf(\"\\\\r\") != -1) || \n\t  (string.indexOf(\"\\\\'\") != -1) || (string.indexOf(\"\\\\\\\"\") != -1) || \n\t  (string.indexOf(\"\\\\\\\\\") != -1) || \n\t  (string.indexOf(\"\\\\t\") != -1) || (string.indexOf(\"\\\\%\") != -1)) {\n\tstring = unbackQuoteChars(string);\n      }\n    }\n\n    return string;\n  }\n\n  /**\n   * Converts carriage returns and new lines in a string into \\r and \\n.\n   * Backquotes the following characters: ` \" \\ \\t and %\n   * \n   * @param string \tthe string\n   * @return \t\tthe converted string\n   * @see\t\t#unbackQuoteChars(String)\n   */\n  public static /*@pure@*/ String backQuoteChars(String string) {\n\n    int index;\n    StringBuffer newStringBuffer;\n\n    // replace each of the following characters with the backquoted version\n    char   charsFind[] =    {'\\\\',   '\\'',  '\\t',  '\\n',  '\\r',  '\"',    '%'};\n    String charsReplace[] = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\n\", \"\\\\r\", \"\\\\\\\"\", \"\\\\%\"};\n    for (int i = 0; i \u003c charsFind.length; i++) {\n      if (string.indexOf(charsFind[i]) != -1 ) {\n\tnewStringBuffer = new StringBuffer();\n\twhile ((index = string.indexOf(charsFind[i])) != -1) {\n\t  if (index \u003e 0) {\n\t    newStringBuffer.append(string.substring(0, index));\n\t  }\n\t  newStringBuffer.append(charsReplace[i]);\n\t  if ((index + 1) \u003c string.length()) {\n\t    string = string.substring(index + 1);\n\t  } else {\n\t    string = \"\";\n\t  }\n\t}\n\tnewStringBuffer.append(string);\n\tstring = newStringBuffer.toString();\n      }\n    }\n\n    return string;\n  }\n\n  /**\n   * Converts carriage returns and new lines in a string into \\r and \\n.\n   *\n   * @param string the string\n   * @return the converted string\n   */\n  public static String convertNewLines(String string) {\n    int index;\n\n    // Replace with \\n\n    StringBuffer newStringBuffer = new StringBuffer();\n    while ((index = string.indexOf('\\n')) != -1) {\n      if (index \u003e 0) {\n\tnewStringBuffer.append(string.substring(0, index));\n      }\n      newStringBuffer.append('\\\\');\n      newStringBuffer.append('n');\n      if ((index + 1) \u003c string.length()) {\n\tstring = string.substring(index + 1);\n      } else {\n\tstring = \"\";\n      }\n    }\n    newStringBuffer.append(string);\n    string = newStringBuffer.toString();\n\n    // Replace with \\r\n    newStringBuffer = new StringBuffer();\n    while ((index = string.indexOf('\\r')) != -1) {\n      if (index \u003e 0) {\n\tnewStringBuffer.append(string.substring(0, index));\n      }\n      newStringBuffer.append('\\\\');\n      newStringBuffer.append('r');\n      if ((index + 1) \u003c string.length()){\n\tstring = string.substring(index + 1);\n      } else {\n\tstring = \"\";\n      }\n    }\n    newStringBuffer.append(string);\n    return newStringBuffer.toString();\n  }\n\n  /**\n   * Reverts \\r and \\n in a string into carriage returns and new lines.\n   * \n   * @param string the string\n   * @return the converted string\n   */\n  public static String revertNewLines(String string) {\n    int index;\n\n    // Replace with \\n\n    StringBuffer newStringBuffer = new StringBuffer();\n    while ((index = string.indexOf(\"\\\\n\")) != -1) {\n      if (index \u003e 0) {\n\tnewStringBuffer.append(string.substring(0, index));\n      }\n      newStringBuffer.append('\\n');\n      if ((index + 2) \u003c string.length()) {\n\tstring = string.substring(index + 2);\n      } else {\n\tstring = \"\";\n      }\n    }\n    newStringBuffer.append(string);\n    string = newStringBuffer.toString();\n\n    // Replace with \\r\n    newStringBuffer = new StringBuffer();\n    while ((index = string.indexOf(\"\\\\r\")) != -1) {\n      if (index \u003e 0) {\n\tnewStringBuffer.append(string.substring(0, index));\n      }\n      newStringBuffer.append('\\r');\n      if ((index + 2) \u003c string.length()){\n\tstring = string.substring(index + 2);\n      } else {\n\tstring = \"\";\n      }\n    }\n    newStringBuffer.append(string);\n    \n    return newStringBuffer.toString();\n  }\n\n  /**\n   * Returns the secondary set of options (if any) contained in\n   * the supplied options array. The secondary set is defined to\n   * be any options after the first \"--\". These options are removed from\n   * the original options array.\n   *\n   * @param options the input array of options\n   * @return the array of secondary options\n   */\n  public static String[] partitionOptions(String[] options) {\n\n    for (int i = 0; i \u003c options.length; i++) {\n      if (options[i].equals(\"--\")) {\n\toptions[i++] = \"\";\n\tString[] result = new String [options.length - i];\n\tfor (int j = i; j \u003c options.length; j++) {\n\t  result[j - i] = options[j];\n\t  options[j] = \"\";\n\t}\n\treturn result;\n      }\n    }\n    return new String [0];\n  }\n    \n  /**\n   * The inverse operation of backQuoteChars().\n   * Converts back-quoted carriage returns and new lines in a string \n   * to the corresponding character ('\\r' and '\\n').\n   * Also \"un\"-back-quotes the following characters: ` \" \\ \\t and %\n   *\n   * @param string \tthe string\n   * @return \t\tthe converted string\n   * @see\t\t#backQuoteChars(String)\n   */\n  public static String unbackQuoteChars(String string) {\n\n    int index;\n    StringBuffer newStringBuffer;\n    \n    // replace each of the following characters with the backquoted version\n    String charsFind[]    = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\n\", \"\\\\r\", \"\\\\\\\"\", \"\\\\%\"};\n    char   charsReplace[] = {'\\\\',   '\\'',  '\\t',  '\\n',  '\\r',  '\"',    '%'};\n    int pos[] = new int[charsFind.length];\n    int\tcurPos;\n    \n    String str = new String(string);\n    newStringBuffer = new StringBuffer();\n    while (str.length() \u003e 0) {\n      // get positions and closest character to replace\n      curPos = str.length();\n      index  = -1;\n      for (int i = 0; i \u003c pos.length; i++) {\n\tpos[i] = str.indexOf(charsFind[i]);\n\tif ( (pos[i] \u003e -1) \u0026\u0026 (pos[i] \u003c curPos) ) {\n\t  index  = i;\n\t  curPos = pos[i];\n\t}\n      }\n      \n      // replace character if found, otherwise finished\n      if (index == -1) {\n\tnewStringBuffer.append(str);\n\tstr = \"\";\n      }\n      else {\n\tnewStringBuffer.append(str.substring(0, pos[index]));\n\tnewStringBuffer.append(charsReplace[index]);\n\tstr = str.substring(pos[index] + charsFind[index].length());\n      }\n    }\n\n    return newStringBuffer.toString();\n  }    \n  \n  /**\n   * Split up a string containing options into an array of strings,\n   * one for each option.\n   *\n   * @param \t\tquotedOptionString the string containing the options\n   * @return \t\tthe array of options\n   * @throws Exception \tin case of an unterminated string, unknown character or\n   * \t\t\ta parse error\n   */\n  public static String[] splitOptions(String quotedOptionString) throws Exception{\n\n    Vector\u003cString\u003e optionsVec = new Vector\u003cString\u003e();\n    String str = new String(quotedOptionString);\n    int i;\n    \n    while (true){\n\n      //trimLeft \n      i = 0;\n      while ((i \u003c str.length()) \u0026\u0026 (Character.isWhitespace(str.charAt(i)))) i++;\n      str = str.substring(i);\n      \n      //stop when str is empty\n      if (str.length() == 0) break;\n      \n      //if str start with a double quote\n      if (str.charAt(0) == '\"'){\n\t\n\t//find the first not anti-slached double quote\n\ti = 1;\n\twhile(i \u003c str.length()){\n\t  if (str.charAt(i) == str.charAt(0)) break;\n\t  if (str.charAt(i) == '\\\\'){\n\t    i += 1;\n\t    if (i \u003e= str.length()) \n\t      throw new Exception(\"String should not finish with \\\\\");\n\t  }\n\t  i += 1;\n\t}\n\tif (i \u003e= str.length()) throw new Exception(\"Quote parse error.\");\n\t\n\t//add the founded string to the option vector (without quotes)\n\tString optStr = str.substring(1,i);\n\toptStr = unbackQuoteChars(optStr);\n\toptionsVec.addElement(optStr);\n\tstr = str.substring(i+1);\n      } else {\n\t//find first whiteSpace\n\ti=0;\n\twhile((i \u003c str.length()) \u0026\u0026 (!Character.isWhitespace(str.charAt(i)))) i++;\n\t\n\t//add the founded string to the option vector\n\tString optStr = str.substring(0,i);\n\toptionsVec.addElement(optStr);\n\tstr = str.substring(i);\n      }\n    }\n    \n    //convert optionsVec to an array of String\n    String[] options = new String[optionsVec.size()];\n    for (i = 0; i \u003c optionsVec.size(); i++) {\n      options[i] = (String)optionsVec.elementAt(i);\n    }\n    return options;\n  }    \n\n  /**\n   * Joins all the options in an option array into a single string,\n   * as might be used on the command line.\n   *\n   * @param optionArray the array of options\n   * @return the string containing all options.\n   */\n  public static String joinOptions(String[] optionArray) {\n\n    String optionString = \"\";\n    for (int i = 0; i \u003c optionArray.length; i++) {\n      if (optionArray[i].equals(\"\")) {\n\tcontinue;\n      }\n      boolean escape = false;\n      for (int n = 0; n \u003c optionArray[i].length(); n++) {\n\tif (Character.isWhitespace(optionArray[i].charAt(n))) {\n\t  escape = true;\n\t  break;\n\t}\n      }\n      if (escape) {\n\toptionString += '\"' + backQuoteChars(optionArray[i]) + '\"';\n      } else {\n\toptionString += optionArray[i];\n      }\n      optionString += \" \";\n    }\n    return optionString.trim();\n  }\n  \n  /**\n   * Creates a new instance of an object given it's class name and\n   * (optional) arguments to pass to it's setOptions method. If the\n   * object implements OptionHandler and the options parameter is\n   * non-null, the object will have it's options set. Example use:\u003cp\u003e\n   *\n   * \u003ccode\u003e \u003cpre\u003e\n   * String classifierName = Utils.getOption('W', options);\n   * Classifier c = (Classifier)Utils.forName(Classifier.class,\n   *                                          classifierName,\n   *                                          options);\n   * setClassifier(c);\n   * \u003c/pre\u003e\u003c/code\u003e\n   *\n   * @param classType the class that the instantiated object should\n   * be assignable to -- an exception is thrown if this is not the case\n   * @param className the fully qualified class name of the object\n   * @param options an array of options suitable for passing to setOptions. May\n   * be null. Any options accepted by the object will be removed from the\n   * array.\n   * @return the newly created object, ready for use.\n   * @exception Exception if the class name is invalid, or if the\n   * class is not assignable to the desired class type, or the options\n   * supplied are not acceptable to the object\n  \n  public static Object forName(Class\u003c?\u003e classType,\n\t\t\t       String className,\n\t\t\t       String[] options) throws Exception {\n\n    Class\u003c?\u003e c = null;\n    try {\n      c = Class.forName(className);\n    } catch (Exception ex) {\n      throw new Exception(\"Can't find class called: \" + className);\n    }\n    if (!classType.isAssignableFrom(c)) {\n      throw new Exception(classType.getName() + \" is not assignable from \"\n\t\t\t  + className);\n    }\n    Object o = c.newInstance();\n    if ((o instanceof OptionHandler)\n\t\u0026\u0026 (options != null)) {\n      ((OptionHandler)o).setOptions(options);\n      Utils.checkForRemainingOptions(options);\n    }\n    return o;\n  }\n */\n  /**\n   * Generates a commandline of the given object. If the object is not \n   * implementing OptionHandler, then it will only return the classname,\n   * otherwise also the options.\n   * \n   * @param obj\t\tthe object to turn into a commandline\n   * @return\t\tthe commandline\n  \n  public static String toCommandLine(Object obj) {\n    StringBuffer\tresult;\n    \n    result = new StringBuffer();\n    \n    if (obj != null) {\n      result.append(obj.getClass().getName());\n      if (obj instanceof OptionHandler)\n\tresult.append(\" \" + joinOptions(((OptionHandler) obj).getOptions()));\n    }\n    \n    return result.toString().trim();\n  }\n   */\n  /**\n   * Computes entropy for an array of integers.\n   *\n   * @param counts array of counts\n   * @return - a log2 a - b log2 b - c log2 c + (a+b+c) log2 (a+b+c)\n   * when given array [a b c]\n   */\n  public static /*@pure@*/ double info(int counts[]) {\n    \n    int total = 0;\n    double x = 0;\n    for (int j = 0; j \u003c counts.length; j++) {\n      x -= xlogx(counts[j]);\n      total += counts[j];\n    }\n    return x + xlogx(total);\n  }\n\n  /**\n   * Tests if a is smaller or equal to b.\n   *\n   * @param a a double\n   * @param b a double\n     * @return True if a is smaller or equal to b. \n   */\n  public static /*@pure@*/ boolean smOrEq(double a,double b) {\n    \n    return (a-b \u003c SMALL);\n  }\n\n  /**\n   * Tests if a is greater or equal to b.\n   *\n   * @param a a double\n   * @param b a double\n     * @return True if a is greater or equal to b. \n   */\n  public static /*@pure@*/ boolean grOrEq(double a,double b) {\n    \n    return (b-a \u003c SMALL);\n  }\n  \n  /**\n   * Tests if a is smaller than b.\n   *\n   * @param a a double\n   * @param b a double\n     * @return True if a is smaller than b. \n   */\n  public static /*@pure@*/ boolean sm(double a,double b) {\n    \n    return (b-a \u003e SMALL);\n  }\n\n  /**\n   * Tests if a is greater than b.\n   *\n   * @param a a double\n   * @param b a double \n     * @return True if a is greater than b. \n   */\n  public static /*@pure@*/ boolean gr(double a,double b) {\n    \n    return (a-b \u003e SMALL);\n  }\n\n  /**\n   * Returns the kth-smallest value in the array.\n   *\n   * @param array the array of integers\n   * @param k the value of k\n   * @return the kth-smallest value\n   */\n  public static double kthSmallestValue(int[] array, int k) {\n\n    int[] index = new int[array.length];\n    \n    for (int i = 0; i \u003c index.length; i++) {\n      index[i] = i;\n    }\n\n    return array[index[select(array, index, 0, array.length - 1, k)]];\n  }\n\n  /**\n   * Returns the kth-smallest value in the array\n   *\n   * @param array the array of double\n   * @param k the value of k\n   * @return the kth-smallest value\n   */\n  public static double kthSmallestValue(double[] array, int k) {\n\n    int[] index = new int[array.length];\n    \n    for (int i = 0; i \u003c index.length; i++) {\n      index[i] = i;\n    }\n\n    return array[index[select(array, index, 0, array.length - 1, k)]];\n  }\n\n  /**\n   * Returns the logarithm of a for base 2.\n   *\n   * @param a \ta double\n   * @return\tthe logarithm for base 2\n   */\n  public static /*@pure@*/ double log2(double a) {\n    \n    return Math.log(a) / log2;\n  }\n\n  /**\n   * Returns index of maximum element in a given\n   * array of doubles. First maximum is returned.\n   *\n   * @param doubles the array of doubles\n   * @return the index of the maximum element\n   */\n  public static /*@pure@*/ int maxIndex(double[] doubles) {\n\n    double maximum = 0;\n    int maxIndex = 0;\n\n    for (int i = 0; i \u003c doubles.length; i++) {\n      if ((i == 0) || (doubles[i] \u003e maximum)) {\n\tmaxIndex = i;\n\tmaximum = doubles[i];\n      }\n    }\n\n    return maxIndex;\n  }\n\n  /**\n   * Returns index of maximum element in a given\n   * array of integers. First maximum is returned.\n   *\n   * @param ints the array of integers\n   * @return the index of the maximum element\n   */\n  public static /*@pure@*/ int maxIndex(int[] ints) {\n\n    int maximum = 0;\n    int maxIndex = 0;\n\n    for (int i = 0; i \u003c ints.length; i++) {\n      if ((i == 0) || (ints[i] \u003e maximum)) {\n\tmaxIndex = i;\n\tmaximum = ints[i];\n      }\n    }\n\n    return maxIndex;\n  }\n\n  /**\n   * Computes the mean for an array of doubles.\n   *\n   * @param vector the array\n   * @return the mean\n   */\n  public static /*@pure@*/ double mean(double[] vector) {\n  \n    double sum = 0;\n\n    if (vector.length == 0) {\n      return 0;\n    }\n    for (int i = 0; i \u003c vector.length; i++) {\n      sum += vector[i];\n    }\n    return sum / (double) vector.length;\n  }\n\n  /**\n   * Returns index of minimum element in a given\n   * array of integers. First minimum is returned.\n   *\n   * @param ints the array of integers\n   * @return the index of the minimum element\n   */\n  public static /*@pure@*/ int minIndex(int[] ints) {\n\n    int minimum = 0;\n    int minIndex = 0;\n\n    for (int i = 0; i \u003c ints.length; i++) {\n      if ((i == 0) || (ints[i] \u003c minimum)) {\n\tminIndex = i;\n\tminimum = ints[i];\n      }\n    }\n\n    return minIndex;\n  }\n\n  /**\n   * Returns index of minimum element in a given\n   * array of doubles. First minimum is returned.\n   *\n   * @param doubles the array of doubles\n   * @return the index of the minimum element\n   */\n  public static /*@pure@*/ int minIndex(double[] doubles) {\n\n    double minimum = 0;\n    int minIndex = 0;\n\n    for (int i = 0; i \u003c doubles.length; i++) {\n      if ((i == 0) || (doubles[i] \u003c minimum)) {\n\tminIndex = i;\n\tminimum = doubles[i];\n      }\n    }\n\n    return minIndex;\n  }\n\n  /**\n   * Normalizes the doubles in the array by their sum.\n   *\n   * @param doubles the array of double\n   * @exception IllegalArgumentException if sum is Zero or NaN\n   */\n  public static void normalize(double[] doubles) {\n\n    double sum = 0;\n    for (int i = 0; i \u003c doubles.length; i++) {\n      sum += doubles[i];\n    }\n    normalize(doubles, sum);\n  }\n\n  /**\n   * Normalizes the doubles in the array using the given value.\n   *\n   * @param doubles the array of double\n   * @param sum the value by which the doubles are to be normalized\n   * @exception IllegalArgumentException if sum is zero or NaN\n   */\n  public static void normalize(double[] doubles, double sum) {\n\n    if (Double.isNaN(sum)) {\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is NaN.\");\n    }\n    if (sum == 0) {\n      // Maybe this should just be a return.\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is zero.\");\n    }\n    for (int i = 0; i \u003c doubles.length; i++) {\n      doubles[i] /= sum;\n    }\n  }\n\n  /**\n   * Converts an array containing the natural logarithms of\n   * probabilities stored in a vector back into probabilities.\n   * The probabilities are assumed to sum to one.\n   *\n   * @param a an array holding the natural logarithms of the probabilities\n   * @return the converted array \n   */\n  public static double[] logs2probs(double[] a) {\n\n    double max = a[maxIndex(a)];\n    double sum = 0.0;\n\n    double[] result = new double[a.length];\n    for(int i = 0; i \u003c a.length; i++) {\n      result[i] = Math.exp(a[i] - max);\n      sum += result[i];\n    }\n\n    normalize(result, sum);\n\n    return result;\n  } \n\n  /**\n   * Returns the log-odds for a given probabilitiy.\n   *\n   * @param prob the probabilitiy\n   *\n   * @return the log-odds after the probability has been mapped to\n   * [Utils.SMALL, 1-Utils.SMALL]\n   */\n  public static /*@pure@*/ double probToLogOdds(double prob) {\n\n    if (gr(prob, 1) || (sm(prob, 0))) {\n      throw new IllegalArgumentException(\"probToLogOdds: probability must \" +\n\t\t\t\t     \"be in [0,1] \"+prob);\n    }\n    double p = SMALL + (1.0 - 2 * SMALL) * prob;\n    return Math.log(p / (1 - p));\n  }\n\n  /**\n   * Rounds a double to the next nearest integer value. The JDK version\n   * of it doesn't work properly.\n   *\n   * @param value the double value\n   * @return the resulting integer value\n   */\n  public static /*@pure@*/ int round(double value) {\n\n    int roundedValue = value \u003e 0\n      ? (int)(value + 0.5)\n      : -(int)(Math.abs(value) + 0.5);\n    \n    return roundedValue;\n  }\n\n  /**\n   * Rounds a double to the next nearest integer value in a probabilistic\n   * fashion (e.g. 0.8 has a 20% chance of being rounded down to 0 and a\n   * 80% chance of being rounded up to 1). In the limit, the average of\n   * the rounded numbers generated by this procedure should converge to\n   * the original double.\n   *\n   * @param value the double value\n   * @param rand the random number generator\n   * @return the resulting integer value\n   */\n  public static int probRound(double value, Random rand) {\n\n    if (value \u003e= 0) {\n      double lower = Math.floor(value);\n      double prob = value - lower;\n      if (rand.nextDouble() \u003c prob) {\n\treturn (int)lower + 1;\n      } else {\n\treturn (int)lower;\n      }\n    } else {\n      double lower = Math.floor(Math.abs(value));\n      double prob = Math.abs(value) - lower;\n      if (rand.nextDouble() \u003c prob) {\n\treturn -((int)lower + 1);\n      } else {\n\treturn -(int)lower;\n      }\n    }\n  }\n\n  /**\n   * Rounds a double to the given number of decimal places.\n   *\n   * @param value the double value\n   * @param afterDecimalPoint the number of digits after the decimal point\n   * @return the double rounded to the given precision\n   */\n  public static /*@pure@*/ double roundDouble(double value,int afterDecimalPoint) {\n\n    double mask = Math.pow(10.0, (double)afterDecimalPoint);\n\n    return (double)(Math.round(value * mask)) / mask;\n  }\n\n  /**\n   * Sorts a given array of integers in ascending order and returns an \n   * array of integers with the positions of the elements of the original \n   * array in the sorted array. The sort is stable. (Equal elements remain\n   * in their original order.)\n   *\n   * @param array this array is not changed by the method!\n   * @return an array of integers with the positions in the sorted\n   * array.\n   */\n  public static /*@pure@*/ int[] sort(int[] array) {\n\n    int[] index = new int[array.length];\n    int[] newIndex = new int[array.length];\n    int[] helpIndex;\n    int numEqual;\n    \n    for (int i = 0; i \u003c index.length; i++) {\n      index[i] = i;\n    }\n    quickSort(array, index, 0, array.length - 1);\n\n    // Make sort stable\n    int i = 0;\n    while (i \u003c index.length) {\n      numEqual = 1;\n      for (int j = i + 1; ((j \u003c index.length)\n\t\t\t   \u0026\u0026 (array[index[i]] == array[index[j]]));\n\t   j++) {\n\tnumEqual++;\n      }\n      if (numEqual \u003e 1) {\n\thelpIndex = new int[numEqual];\n\tfor (int j = 0; j \u003c numEqual; j++) {\n\t  helpIndex[j] = i + j;\n\t}\n\tquickSort(index, helpIndex, 0, numEqual - 1);\n\tfor (int j = 0; j \u003c numEqual; j++) {\n\t  newIndex[i + j] = index[helpIndex[j]];\n\t}\n\ti += numEqual;\n      } else {\n\tnewIndex[i] = index[i];\n\ti++;\n      }\n    }\n    return newIndex;\n  }\n\n  /**\n   * Sorts a given array of doubles in ascending order and returns an\n   * array of integers with the positions of the elements of the\n   * original array in the sorted array. NOTE THESE CHANGES: the sort\n   * is no longer stable and it doesn't use safe floating-point\n   * comparisons anymore. Occurrences of Double.NaN are treated as \n   * Double.MAX_VALUE\n   *\n   * @param array this array is not changed by the method!\n   * @return an array of integers with the positions in the sorted\n   * array.  \n   */\n  public static /*@pure@*/ int[] sort(/*@non_null@*/ double[] array) {\n\n    int[] index = new int[array.length];\n    array = (double[])array.clone();\n    for (int i = 0; i \u003c index.length; i++) {\n    \t\n      index[i] = i;\n      if (Double.isNaN(array[i])) {\n        array[i] = Double.MAX_VALUE;\n      }\n    }\n    quickSort(array, index, 0, array.length - 1);\n\n    return index;\n  }\n\n  /**\n   * Sorts a given array of doubles in ascending order and returns an \n   * array of integers with the positions of the elements of the original \n   * array in the sorted array. The sort is stable (Equal elements remain\n   * in their original order.) Occurrences of Double.NaN are treated as \n   * Double.MAX_VALUE\n   *\n   * @param array this array is not changed by the method!\n   * @return an array of integers with the positions in the sorted\n   * array.\n   */\n  public static /*@pure@*/ int[] stableSort(double[] array){\n\n    int[] index = new int[array.length];\n    int[] newIndex = new int[array.length];\n    int[] helpIndex;\n    int numEqual;\n    \n    array = (double[])array.clone();\n    for (int i = 0; i \u003c index.length; i++) {\n      index[i] = i;\n      if (Double.isNaN(array[i])) {\n        array[i] = Double.MAX_VALUE;\n      }\n    }\n    quickSort(array,index,0,array.length-1);\n\n    // Make sort stable\n\n    int i = 0;\n    while (i \u003c index.length) {\n      numEqual = 1;\n      for (int j = i+1; ((j \u003c index.length) \u0026\u0026 Utils.eq(array[index[i]],\n\t\t\t\t\t\t\tarray[index[j]])); j++)\n\tnumEqual++;\n      if (numEqual \u003e 1) {\n\thelpIndex = new int[numEqual];\n\tfor (int j = 0; j \u003c numEqual; j++)\n\t  helpIndex[j] = i+j;\n\tquickSort(index, helpIndex, 0, numEqual-1);\n\tfor (int j = 0; j \u003c numEqual; j++) \n\t  newIndex[i+j] = index[helpIndex[j]];\n\ti += numEqual;\n      } else {\n\tnewIndex[i] = index[i];\n\ti++;\n      }\n    }\n\n    return newIndex;\n  }\n\n  /**\n   * Computes the variance for an array of doubles.\n   *\n   * @param vector the array\n   * @return the variance\n   */\n  public static /*@pure@*/ double variance(double[] vector) {\n  \n    double sum = 0, sumSquared = 0;\n\n    if (vector.length \u003c= 1) {\n      return 0;\n    }\n    for (int i = 0; i \u003c vector.length; i++) {\n      sum += vector[i];\n      sumSquared += (vector[i] * vector[i]);\n    }\n    double result = (sumSquared - (sum * sum / (double) vector.length)) / \n      (double) (vector.length - 1);\n\n    // We don't like negative variance\n    if (result \u003c 0) {\n      return 0;\n    } else {\n      return result;\n    }\n  }\n\n  /**\n   * Computes the sum of the elements of an array of doubles.\n   *\n   * @param doubles the array of double\n   * @return the sum of the elements\n   */\n  public static /*@pure@*/ double sum(double[] doubles) {\n\n    double sum = 0;\n\n    for (int i = 0; i \u003c doubles.length; i++) {\n      sum += doubles[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Computes the sum of the elements of an array of integers.\n   *\n   * @param ints the array of integers\n   * @return the sum of the elements\n   */\n  public static /*@pure@*/ int sum(int[] ints) {\n\n    int sum = 0;\n\n    for (int i = 0; i \u003c ints.length; i++) {\n      sum += ints[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns c*log2(c) for a given integer value c.\n   *\n   * @param c an integer value\n   * @return c*log2(c) (but is careful to return 0 if c is 0)\n   */\n  public static /*@pure@*/ double xlogx(int c) {\n    \n    if (c == 0) {\n      return 0.0;\n    }\n    return c * Utils.log2((double) c);\n  }\n\n  /**\n   * Partitions the instances around a pivot. Used by quicksort and\n   * kthSmallestValue.\n   *\n   * @param array the array of doubles to be sorted\n   * @param index the index into the array of doubles\n   * @param l the first index of the subset \n   * @param r the last index of the subset \n   *\n   * @return the index of the middle element\n   */\n  private static int partition(double[] array, int[] index, int l, int r) {\n    \n    double pivot = array[index[(l + r) / 2]];\n    int help;\n\n    while (l \u003c r) {\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\n        l++;\n      }\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\n        r--;\n      }\n      if (l \u003c r) {\n        help = index[l];\n        index[l] = index[r];\n        index[r] = help;\n        l++;\n        r--;\n      }\n    }\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\n      r--;\n    } \n\n    return r;\n  }\n\n  /**\n   * Partitions the instances around a pivot. Used by quicksort and\n   * kthSmallestValue.\n   *\n   * @param array the array of integers to be sorted\n   * @param index the index into the array of integers\n   * @param l the first index of the subset \n   * @param r the last index of the subset \n   *\n   * @return the index of the middle element\n   */\n  private static int partition(int[] array, int[] index, int l, int r) {\n    \n    double pivot = array[index[(l + r) / 2]];\n    int help;\n\n    while (l \u003c r) {\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\n        l++;\n      }\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\n        r--;\n      }\n      if (l \u003c r) {\n        help = index[l];\n        index[l] = index[r];\n        index[r] = help;\n        l++;\n        r--;\n      }\n    }\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\n      r--;\n    } \n\n    return r;\n  }\n  \n  /**\n   * Implements quicksort according to Manber's \"Introduction to\n   * Algorithms\".\n   *\n   * @param array the array of doubles to be sorted\n   * @param index the index into the array of doubles\n   * @param left the first index of the subset to be sorted\n   * @param right the last index of the subset to be sorted\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\n  //@ requires array != index;\n  //  assignable index;\n  private static void quickSort(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \n                                int left, int right) {\n\n    if (left \u003c right) {\n      int middle = partition(array, index, left, right);\n      quickSort(array, index, left, middle);\n      quickSort(array, index, middle + 1, right);\n    }\n  }\n  \n  /**\n   * Implements quicksort according to Manber's \"Introduction to\n   * Algorithms\".\n   *\n   * @param array the array of integers to be sorted\n   * @param index the index into the array of integers\n   * @param left the first index of the subset to be sorted\n   * @param right the last index of the subset to be sorted\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\n  //@ requires array != index;\n  //  assignable index;\n  private static void quickSort(/*@non_null@*/ int[] array, /*@non_null@*/  int[] index, \n                                int left, int right) {\n\n    if (left \u003c right) {\n      int middle = partition(array, index, left, right);\n      quickSort(array, index, left, middle);\n      quickSort(array, index, middle + 1, right);\n    }\n  }\n  \n  /**\n   * Implements computation of the kth-smallest element according\n   * to Manber's \"Introduction to Algorithms\".\n   *\n   * @param array the array of double\n   * @param index the index into the array of doubles\n   * @param left the first index of the subset \n   * @param right the last index of the subset \n   * @param k the value of k\n   *\n   * @return the index of the kth-smallest element\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n  private static int select(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \n                            int left, int right, int k) {\n    \n    if (left == right) {\n      return left;\n    } else {\n      int middle = partition(array, index, left, right);\n      if ((middle - left + 1) \u003e= k) {\n        return select(array, index, left, middle, k);\n      } else {\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\n      }\n    }\n  }\n\n  /**\n   * Converts a File's absolute path to a path relative to the user\n   * (ie start) directory. Includes an additional workaround for Cygwin, which\n   * doesn't like upper case drive letters.\n   * @param absolute the File to convert to relative path\n   * @return a File with a path that is relative to the user's directory\n   * @exception Exception if the path cannot be constructed\n   */\n  public static File convertToRelativePath(File absolute) throws Exception {\n    File        result;\n    String      fileStr;\n    \n    result = null;\n    \n    // if we're running windows, it could be Cygwin\n    if (File.separator.equals(\"\\\\\")) {\n      // Cygwin doesn't like upper case drives -\u003e try lower case drive\n      try {\n        fileStr = absolute.getPath();\n        fileStr =   fileStr.substring(0, 1).toLowerCase() \n                  + fileStr.substring(1);\n        result = createRelativePath(new File(fileStr));\n      }\n      catch (Exception e) {\n        // no luck with Cygwin workaround, convert it like it is\n        result = createRelativePath(absolute);\n      }\n    }\n    else {\n      result = createRelativePath(absolute);\n    }\n\n    return result;\n  }\n\n  /**\n   * Converts a File's absolute path to a path relative to the user\n   * (ie start) directory.\n   * \n   * @param absolute the File to convert to relative path\n   * @return a File with a path that is relative to the user's directory\n   * @exception Exception if the path cannot be constructed\n   */\n  protected static File createRelativePath(File absolute) throws Exception {\n    File userDir = new File(System.getProperty(\"user.dir\"));\n    String userPath = userDir.getAbsolutePath() + File.separator;\n    String targetPath = (new File(absolute.getParent())).getPath() \n      + File.separator;\n    String fileName = absolute.getName();\n    StringBuffer relativePath = new StringBuffer();\n    //    relativePath.append(\".\"+File.separator);\n    //    System.err.println(\"User dir \"+userPath);\n    //    System.err.println(\"Target path \"+targetPath);\n    \n    // file is in user dir (or subdir)\n    int subdir = targetPath.indexOf(userPath);\n    if (subdir == 0) {\n      if (userPath.length() == targetPath.length()) {\n\trelativePath.append(fileName);\n      } else {\n\tint ll = userPath.length();\n\trelativePath.append(targetPath.substring(ll));\n\trelativePath.append(fileName);\n      }\n    } else {\n      int sepCount = 0;\n      String temp = new String(userPath);\n      while (temp.indexOf(File.separator) != -1) {\n\tint ind = temp.indexOf(File.separator);\n\tsepCount++;\n\ttemp = temp.substring(ind+1, temp.length());\n      }\n      \n      String targetTemp = new String(targetPath);\n      String userTemp = new String(userPath);\n      int tcount = 0;\n      while (targetTemp.indexOf(File.separator) != -1) {\n\tint ind = targetTemp.indexOf(File.separator);\n\tint ind2 = userTemp.indexOf(File.separator);\n\tString tpart = targetTemp.substring(0,ind+1);\n\tString upart = userTemp.substring(0,ind2+1);\n\tif (tpart.compareTo(upart) != 0) {\n\t  if (tcount == 0) {\n\t    tcount = -1;\n\t  }\n\t  break;\n\t}\n\ttcount++;\n\ttargetTemp = targetTemp.substring(ind+1, targetTemp.length());\n\tuserTemp = userTemp.substring(ind2+1, userTemp.length());\n      }\n      if (tcount == -1) {\n\t// then target file is probably on another drive (under windows)\n\tthrow new Exception(\"Can't construct a path to file relative to user \"\n\t\t\t    +\"dir.\");\n      }\n      if (targetTemp.indexOf(File.separator) == -1) {\n\ttargetTemp = \"\";\n      }\n      for (int i = 0; i \u003c sepCount - tcount; i++) {\n\trelativePath.append(\"..\"+File.separator);\n      }\n      relativePath.append(targetTemp + fileName);\n    }\n    //    System.err.println(\"new path : \"+relativePath.toString());\n    return new File(relativePath.toString());\n  }\n  \n  /**\n   * Implements computation of the kth-smallest element according\n   * to Manber's \"Introduction to Algorithms\".\n   *\n   * @param array the array of integers\n   * @param index the index into the array of integers\n   * @param left the first index of the subset \n   * @param right the last index of the subset \n   * @param k the value of k\n   *\n   * @return the index of the kth-smallest element\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n  private static int select(/*@non_null@*/ int[] array, /*@non_null@*/ int[] index, \n                            int left, int right, int k) {\n    \n    if (left == right) {\n      return left;\n    } else {\n      int middle = partition(array, index, left, right);\n      if ((middle - left + 1) \u003e= k) {\n        return select(array, index, left, middle, k);\n      } else {\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\n      }\n    }\n  }\n  \n  /**\n   * For a named dialog, returns true if the user has opted not to view\n   * it again in the future.\n   * \n   * @param dialogName the name of the dialog to check (e.g.\n   * weka.gui.GUICHooser.HowToFindPackageManager).\n   * @return true if the user has opted not to view the named dialog\n   * in the future.\n   \n  public static boolean getDontShowDialog(String dialogName) {\n    File wekaHome = WekaPackageManager.WEKA_HOME;\n    \n    if (!wekaHome.exists()) {\n      return false;\n    }\n    \n    File dialogSubDir = new File(wekaHome.toString() + File.separator + \"systemDialogs\");\n    if (!dialogSubDir.exists()) {\n      return false;\n    }\n    \n    File dialogFile = new File(dialogSubDir.toString() + File.separator + dialogName);\n    \n    return dialogFile.exists();\n  }\n  */\n  \n  /**\n   * Specify that the named dialog is not to be displayed in the future.\n   * \n   * @param dialogName the name of the dialog not to show again (e.g.\n   * weka.gui.GUIChooser.HowToFindPackageManager).\n   * @throws Exception if the marker file that is used to indicate that\n   * a named dialog is not to be shown can't be created. This file lives\n   * in $WEKA_HOME/systemDialogs\n  \n  public static void setDontShowDialog(String dialogName) throws Exception {\n    File wekaHome = WekaPackageManager.WEKA_HOME;\n    \n    if (!wekaHome.exists()) {\n      return;\n    }\n    \n    File dialogSubDir = new File(wekaHome.toString() + File.separator + \"systemDialogs\");\n    if (!dialogSubDir.exists()) {\n      if (!dialogSubDir.mkdir()) {\n        return;\n      }\n    }\n    \n    File dialogFile = new File(dialogSubDir.toString() + File.separator + dialogName);\n    dialogFile.createNewFile();\n  }\n   */\n  /**\n   * For a named dialog, if the user has opted not to view it again, \n   * returns the answer the answer the user supplied when they\n   * closed the dialog. Returns null if the user did opt to view\n   * the dialog again.\n   * \n   * @param dialogName the name of the dialog to check (e.g.\n   * weka.gui.GUICHooser.HowToFindPackageManager).\n   * @return the answer the user supplied the last time they\n   * viewed the named dialog (if they opted not to view it again\n   * in the future) or null if the user opted to view the dialog\n   * again in the future.\n   \n  public static String getDontShowDialogResponse(String dialogName) throws Exception {\n    if (!getDontShowDialog(dialogName)) {\n      return null; // This must be the first time - no file recorded yet.\n    }\n    \n    File wekaHome = WekaPackageManager.WEKA_HOME;\n    File dialogSubDir = new File(wekaHome.toString() + File.separator \n        + \"systemDialogs\" + File.separator + dialogName);\n\n    \n    BufferedReader br = new BufferedReader(new FileReader(dialogSubDir));\n    String response = br.readLine();\n    \n    br.close();\n    return response;\n  }\n  */\n  /**\n   * Specify that the named dialog is not to be shown again in the future. \n   * Also records the answer that the user chose when closing the dialog.\n   * \n   * @param dialogName the name of the dialog to no longer display\n   * @param response the user selected response when they closed the dialog\n   * @throws Exception if there is a problem saving the information\n   \n  public static void setDontShowDialogResponse(String dialogName, String response) \n    throws Exception {\n    \n    File wekaHome = WekaPackageManager.WEKA_HOME;\n    \n    if (!wekaHome.exists()) {\n      return;\n    }\n    \n    File dialogSubDir = new File(wekaHome.toString() + File.separator + \"systemDialogs\");\n    if (!dialogSubDir.exists()) {\n      if (!dialogSubDir.mkdir()) {\n        return;\n      }\n    }\n    \n    File dialogFile = new File(dialogSubDir.toString() + File.separator + dialogName);\n    BufferedWriter br = new BufferedWriter(new FileWriter(dialogFile));\n    br.write(response + \"\\n\");\n    br.flush();\n    br.close();\n  }\n  */\n  /**\n   * Returns the revision string.\n   * \n   * @return\t\tthe revision\n   \n  public String getRevision() {\n    return RevisionUtils.extract(\"$Revision: 6959 $\");\n  }\n*/\n  /**\n   * Main method for testing this class.\n   *\n   * @param ops some dummy options\n   */\n  public static void main(String[] ops) {\n\n    double[] doublesWithNaN = {4.5, 6.7, Double.NaN, 3.4, 4.8, 1.2, 3.4};\n    double[] doubles = {4.5, 6.7, 6.7, 3.4, 4.8, 1.2, 3.4, 6.7, 6.7, 3.4};\n    int[] ints = {12, 6, 2, 18, 16, 6, 7, 5, 18, 18, 17};\n\n    try {\n\n      // Option handling\n      System.out.println(\"First option split up:\");\n      if (ops.length \u003e 0) {\n\tString[] firstOptionSplitUp = Utils.splitOptions(ops[0]);\n\tfor (int i = 0; i \u003c firstOptionSplitUp.length; i ++) {\n\t  System.out.println(firstOptionSplitUp[i]);\n\t}\n      }\t\t\t\t\t       \n      System.out.println(\"Partitioned options: \");\n      String[] partitionedOptions = Utils.partitionOptions(ops);\n      for (int i  = 0; i \u003c partitionedOptions.length; i++) {\n\tSystem.out.println(partitionedOptions[i]);\n      }\n      System.out.println(\"Get position of flag -f: \" + Utils.getOptionPos('f', ops));\n      System.out.println(\"Get flag -f: \" + Utils.getFlag('f', ops));\n      System.out.println(\"Get position of option -o: \" + Utils.getOptionPos('o', ops));\n      System.out.println(\"Get option -o: \" + Utils.getOption('o', ops));\n      System.out.println(\"Checking for remaining options... \");\n      Utils.checkForRemainingOptions(ops);\n      \n      // Statistics\n      System.out.println(\"Original array with NaN (doubles): \");\n      for (int i = 0; i \u003c doublesWithNaN.length; i++) {\n\tSystem.out.print(doublesWithNaN[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Original array (doubles): \");\n      for (int i = 0; i \u003c doubles.length; i++) {\n\tSystem.out.print(doubles[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Original array (ints): \");\n      for (int i = 0; i \u003c ints.length; i++) {\n\tSystem.out.print(ints[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Correlation: \" + Utils.correlation(doubles, doubles, \n\t\t\t\t\t\t\t     doubles.length));\n      System.out.println(\"Mean: \" + Utils.mean(doubles));\n      System.out.println(\"Variance: \" + Utils.variance(doubles));\n      System.out.println(\"Sum (doubles): \" + Utils.sum(doubles));\n      System.out.println(\"Sum (ints): \" + Utils.sum(ints));\n      System.out.println(\"Max index (doubles): \" + Utils.maxIndex(doubles));\n      System.out.println(\"Max index (ints): \" + Utils.maxIndex(ints));\n      System.out.println(\"Min index (doubles): \" + Utils.minIndex(doubles));\n      System.out.println(\"Min index (ints): \" + Utils.minIndex(ints));\n      System.out.println(\"Median (doubles): \" + \n                         Utils.kthSmallestValue(doubles, doubles.length / 2));\n      System.out.println(\"Median (ints): \" + \n                         Utils.kthSmallestValue(ints, ints.length / 2));\n\n      // Sorting and normalizing\n      System.out.println(\"Sorted array with NaN (doubles): \");\n      int[] sorted = Utils.sort(doublesWithNaN);\n      for (int i = 0; i \u003c doublesWithNaN.length; i++) {\n\tSystem.out.print(doublesWithNaN[sorted[i]] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Sorted array (doubles): \");\n      sorted = Utils.sort(doubles);\n      for (int i = 0; i \u003c doubles.length; i++) {\n\tSystem.out.print(doubles[sorted[i]] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Sorted array (ints): \");\n      sorted = Utils.sort(ints);\n      for (int i = 0; i \u003c ints.length; i++) {\n\tSystem.out.print(ints[sorted[i]] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Indices from stable sort (doubles): \");\n      sorted = Utils.stableSort(doubles);\n      for (int i = 0; i \u003c doubles.length; i++) {\n\tSystem.out.print(sorted[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Indices from sort (ints): \");\n      sorted = Utils.sort(ints);\n      for (int i = 0; i \u003c ints.length; i++) {\n\tSystem.out.print(sorted[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Normalized array (doubles): \");\n      Utils.normalize(doubles);\n      for (int i = 0; i \u003c doubles.length; i++) {\n\tSystem.out.print(doubles[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Normalized again (doubles): \");\n      Utils.normalize(doubles, Utils.sum(doubles));\n      for (int i = 0; i \u003c doubles.length; i++) {\n\tSystem.out.print(doubles[i] + \" \");\n      }\n      System.out.println();\n      \n      // Pretty-printing\n      System.out.println(\"-4.58: \" + Utils.doubleToString(-4.57826535, 2));\n      System.out.println(\"-6.78: \" + Utils.doubleToString(-6.78214234, 6,2));\n      \n      // Comparisons\n      System.out.println(\"5.70001 == 5.7 ? \" + Utils.eq(5.70001, 5.7));\n      System.out.println(\"5.70001 \u003e 5.7 ? \" + Utils.gr(5.70001, 5.7));\n      System.out.println(\"5.70001 \u003e= 5.7 ? \" + Utils.grOrEq(5.70001, 5.7));\n      System.out.println(\"5.7 \u003c 5.70001 ? \" + Utils.sm(5.7, 5.70001));\n      System.out.println(\"5.7 \u003c= 5.70001 ? \" + Utils.smOrEq(5.7, 5.70001));\n      \n      // Math\n      System.out.println(\"Info (ints): \" + Utils.info(ints));\n      System.out.println(\"log2(4.6): \" + Utils.log2(4.6));\n      System.out.println(\"5 * log(5): \" + Utils.xlogx(5));\n      System.out.println(\"5.5 rounded: \" + Utils.round(5.5));\n      System.out.println(\"5.55555 rounded to 2 decimal places: \" + \n\t\t\t Utils.roundDouble(5.55555, 2));\n      \n      // Arrays\n      System.out.println(\"Array-Dimensions of 'new int[][]': \" + Utils.getArrayDimensions(new int[][]{}));\n      System.out.println(\"Array-Dimensions of 'new int[][]{{1,2,3},{4,5,6}}': \" + Utils.getArrayDimensions(new int[][]{{1,2,3},{4,5,6}}));\n      String[][][] s = new String[3][4][];\n      System.out.println(\"Array-Dimensions of 'new String[3][4][]': \" + Utils.getArrayDimensions(s));\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n  \n",
        "name": "Utils.java",
        "path": "src/keel/Algorithms/Semi_Supervised_Learning/CLCC/Utils.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/Semi_Supervised_Learning/CLCC/Utils.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 1782,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 1783,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);"
        },
        {
          "limitHit": false,
          "lineNumber": 1784,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1805,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 1806,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);"
        },
        {
          "limitHit": false,
          "lineNumber": 1807,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1831,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 1967,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "/***********************************************************************\n\n\tThis file is part of KEEL-software, the Data Mining tool for regression, \n\tclassification, clustering, pattern mining and so on.\n\n\tCopyright (C) 2004-2010\n\n\tF. Herrera (herrera@decsai.ugr.es)\n    L. Sánchez (luciano@uniovi.es)\n    J. Alcalá-Fdez (jalcala@decsai.ugr.es)\n    S. García (sglopez@ujaen.es)\n    A. Fernández (alberto.fernandez@ujaen.es)\n    J. Luengo (julianlm@decsai.ugr.es)\n\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see http://www.gnu.org/licenses/\n\n **********************************************************************/\n\n/*\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; either version 2 of the License, or\n *    (at your option) any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n/*\n *    Utils.java\n *    Copyright (C) 1999-2004 University of Waikato, Hamilton, New Zealand\n *\n */\n\npackage keel.Algorithms.Semi_Supervised_Learning.CoForest;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.lang.reflect.Array;\nimport java.net.URL;\nimport java.util.Enumeration;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Vector;\n\n/**\n * Class implementing some simple utility methods.\n *\n * @author Eibe Frank \n * @author Yong Wang \n * @author Len Trigg \n * @author Julien Prados\n * @version $Revision: 6959 $\n */\npublic final class Utils{\n\n  /** The natural logarithm of 2. */\n  public static double log2 = Math.log(2);\n\n  /** The small deviation allowed in double comparisons. */\n  public static double SMALL = 1e-6;\n  \n  /**\n   * Tests if the given value codes \"missing\".\n   *\n   * @param val the value to be tested\n   * @return true if val codes \"missing\"\n   */\n  public static boolean isMissingValue(double val) {\n\n    return Double.isNaN(val);\n  }\n\n  /**\n   * Returns the value used to code a missing value.  Note that\n   * equality tests on this value will always return false, so use\n   * isMissingValue(double val) for testing..\n   *\n   * @return the value used as missing value.\n   */\n  public static double missingValue() {\n    \n    return Double.NaN;\n  }\n\n  /**\n   * Casting an object without \"unchecked\" compile-time warnings.\n   * Use only when absolutely necessary (e.g. when using clone()).\n     * @param \u003cT\u003e Type of the Object to be casted.\n     * @param x Object to be casted.\n     * @return object casted.\n   */\n  @SuppressWarnings(\"unchecked\")\n    public static \u003cT\u003e T cast(Object x) {\n    return (T) x;\n  }\n  \n  /**\n   * Reads properties that inherit from three locations. Properties\n   * are first defined in the system resource location (i.e. in the\n   * CLASSPATH).  These default properties must exist. Properties optionally\n   * defined in the user properties location (WekaPackageManager.PROPERTIES_DIR) \n   * override default settings. Properties defined in the current directory (optional)\n   * override all these settings.\n   *\n   * @param resourceName the location of the resource that should be\n   * loaded.  e.g.: \"weka/core/Utils.props\". (The use of hardcoded\n   * forward slashes here is OK - see\n   * jdk1.1/docs/guide/misc/resources.html) This routine will also\n   * look for the file (in this case) \"Utils.props\" in the users home\n   * directory and the current directory.\n   * @return the Properties\n   * @exception Exception if no default properties are defined, or if\n   * an error occurs reading the properties files.  \n   \n  public static Properties readProperties(String resourceName)\n    throws Exception {\n\n    Properties defaultProps = new Properties();\n    try {\n      // Apparently hardcoded slashes are OK here\n      // jdk1.1/docs/guide/misc/resources.html\n      Utils utils = new Utils();\n      Enumeration\u003cURL\u003e urls = utils.getClass().getClassLoader().getResources(resourceName);\n      boolean first = true;\n      while (urls.hasMoreElements()) {\n\tURL url = urls.nextElement();\n\tif (first) {\n\t  defaultProps.load(url.openStream());\n\t  first = false;\n\t}\n\telse {\n\t  Properties props = new Properties(defaultProps);\n\t  props.load(url.openStream());\n\t  defaultProps = props;\n\t}\n      }\n    } catch (Exception ex) {\n      System.err.println(\"Warning, unable to load properties file(s) from \"\n\t\t\t +\"system resource (Utils.java): \" + resourceName);\n    }\n\n    // Hardcoded slash is OK here\n    // eg: see jdk1.1/docs/guide/misc/resources.html\n    int slInd = resourceName.lastIndexOf('/');\n    if (slInd != -1) {\n      resourceName = resourceName.substring(slInd + 1);\n    }\n\n    // Allow a properties file in the WekaPackageManager.PROPERTIES_DIR to override\n    Properties userProps = new Properties(defaultProps);\n    if (!WekaPackageManager.PROPERTIES_DIR.exists()) {\n      WekaPackageManager.PROPERTIES_DIR.mkdir();\n    }\n    //File propFile = new File(WekaPackageManager.PROPERTIES_DIR.toString()\n      //                       + File.separator\n        //                     + resourceName);\n\n    if (propFile.exists()) {\n      try {\n        userProps.load(new FileInputStream(propFile));\n      } catch (Exception ex) {\n        throw new Exception(\"Problem reading user properties: \" + propFile);\n      }\n    }\n\n    // Allow a properties file in the current directory to override\n    Properties localProps = new Properties(userProps);\n    propFile = new File(resourceName);\n    if (propFile.exists()) {\n      try {\n        localProps.load(new FileInputStream(propFile));\n      } catch (Exception ex) {\n        throw new Exception(\"Problem reading local properties: \" + propFile);\n      }\n    }\n    \n    return localProps;\n  }\n*/\n  /**\n   * Returns the correlation coefficient of two double vectors.\n   *\n   * @param y1 double vector 1\n   * @param y2 double vector 2\n   * @param n the length of two double vectors\n   * @return the correlation coefficient\n   */\n  public static final double correlation(double y1[],double y2[],int n) {\n\n    int i;\n    double av1 = 0.0, av2 = 0.0, y11 = 0.0, y22 = 0.0, y12 = 0.0, c;\n    \n    if (n \u003c= 1) {\n      return 1.0;\n    }\n    for (i = 0; i \u003c n; i++) {\n      av1 += y1[i];\n      av2 += y2[i];\n    }\n    av1 /= (double) n;\n    av2 /= (double) n;\n    for (i = 0; i \u003c n; i++) {\n      y11 += (y1[i] - av1) * (y1[i] - av1);\n      y22 += (y2[i] - av2) * (y2[i] - av2);\n      y12 += (y1[i] - av1) * (y2[i] - av2);\n    }\n    if (y11 * y22 == 0.0) {\n      c=1.0;\n    } else {\n      c = y12 / Math.sqrt(Math.abs(y11 * y22));\n    }\n    \n    return c;\n  }\n\n  /**\n   * Removes all occurrences of a string from another string.\n   *\n   * @param inString the string to remove substrings from.\n   * @param substring the substring to remove.\n   * @return the input string with occurrences of substring removed.\n   */\n  public static String removeSubstring(String inString, String substring) {\n\n    StringBuffer result = new StringBuffer();\n    int oldLoc = 0, loc = 0;\n    while ((loc = inString.indexOf(substring, oldLoc))!= -1) {\n      result.append(inString.substring(oldLoc, loc));\n      oldLoc = loc + substring.length();\n    }\n    result.append(inString.substring(oldLoc));\n    return result.toString();\n  }\n\n  /**\n   * Replaces with a new string, all occurrences of a string from \n   * another string.\n   *\n   * @param inString the string to replace substrings in.\n   * @param subString the substring to replace.\n   * @param replaceString the replacement substring\n   * @return the input string with occurrences of substring replaced.\n   */\n  public static String replaceSubstring(String inString, String subString,\n\t\t\t\t\tString replaceString) {\n\n    StringBuffer result = new StringBuffer();\n    int oldLoc = 0, loc = 0;\n    while ((loc = inString.indexOf(subString, oldLoc))!= -1) {\n      result.append(inString.substring(oldLoc, loc));\n      result.append(replaceString);\n      oldLoc = loc + subString.length();\n    }\n    result.append(inString.substring(oldLoc));\n    return result.toString();\n  }\n\n\n  /**\n   * Pads a string to a specified length, inserting spaces on the left\n   * as required. If the string is too long, characters are removed (from\n   * the right).\n   *\n   * @param inString the input string\n   * @param length the desired length of the output string\n   * @return the output string\n   */\n  public static String padLeft(String inString, int length) {\n\n    return fixStringLength(inString, length, false);\n  }\n  \n  /**\n   * Pads a string to a specified length, inserting spaces on the right\n   * as required. If the string is too long, characters are removed (from\n   * the right).\n   *\n   * @param inString the input string\n   * @param length the desired length of the output string\n   * @return the output string\n   */\n  public static String padRight(String inString, int length) {\n\n    return fixStringLength(inString, length, true);\n  }\n  \n  /**\n   * Pads a string to a specified length, inserting spaces as\n   * required. If the string is too long, characters are removed (from\n   * the right).\n   *\n   * @param inString the input string\n   * @param length the desired length of the output string\n   * @param right true if inserted spaces should be added to the right\n   * @return the output string\n   */\n  private static /*@pure@*/ String fixStringLength(String inString, int length,\n\t\t\t\t\tboolean right) {\n\n    if (inString.length() \u003c length) {\n      while (inString.length() \u003c length) {\n\tinString = (right ? inString.concat(\" \") : \" \".concat(inString));\n      }\n    } else if (inString.length() \u003e length) {\n      inString = inString.substring(0, length);\n    }\n    return inString;\n  }\n \n  /**\n   * Rounds a double and converts it into String.\n   *\n   * @param value the double value\n   * @param afterDecimalPoint the (maximum) number of digits permitted\n   * after the decimal point\n   * @return the double as a formatted string\n   */\n  public static /*@pure@*/ String doubleToString(double value, int afterDecimalPoint) {\n    \n    StringBuffer stringBuffer;\n    double temp;\n    int dotPosition;\n    long precisionValue;\n    \n    temp = value * Math.pow(10.0, afterDecimalPoint);\n    if (Math.abs(temp) \u003c Long.MAX_VALUE) {\n      precisionValue = \t(temp \u003e 0) ? (long)(temp + 0.5) \n                                   : -(long)(Math.abs(temp) + 0.5);\n      if (precisionValue == 0) {\n\tstringBuffer = new StringBuffer(String.valueOf(0));\n      } else {\n\tstringBuffer = new StringBuffer(String.valueOf(precisionValue));\n      }\n      if (afterDecimalPoint == 0) {\n\treturn stringBuffer.toString();\n      }\n      dotPosition = stringBuffer.length() - afterDecimalPoint;\n      while (((precisionValue \u003c 0) \u0026\u0026 (dotPosition \u003c 1)) ||\n\t     (dotPosition \u003c 0)) {\n\tif (precisionValue \u003c 0) {\n\t  stringBuffer.insert(1, '0');\n\t} else {\n\t  stringBuffer.insert(0, '0');\n\t}\n\tdotPosition++;\n      }\n      stringBuffer.insert(dotPosition, '.');\n      if ((precisionValue \u003c 0) \u0026\u0026 (stringBuffer.charAt(1) == '.')) {\n\tstringBuffer.insert(1, '0');\n      } else if (stringBuffer.charAt(0) == '.') {\n\tstringBuffer.insert(0, '0');\n      }\n      int currentPos = stringBuffer.length() - 1;\n      while ((currentPos \u003e dotPosition) \u0026\u0026\n\t     (stringBuffer.charAt(currentPos) == '0')) {\n\tstringBuffer.setCharAt(currentPos--, ' ');\n      }\n      if (stringBuffer.charAt(currentPos) == '.') {\n\tstringBuffer.setCharAt(currentPos, ' ');\n      }\n      \n      return stringBuffer.toString().trim();\n    }\n    return new String(\"\" + value);\n  }\n\n  /**\n   * Rounds a double and converts it into a formatted decimal-justified String.\n   * Trailing 0's are replaced with spaces.\n   *\n   * @param value the double value\n   * @param width the width of the string\n   * @param afterDecimalPoint the number of digits after the decimal point\n   * @return the double as a formatted string\n   */\n  public static /*@pure@*/ String doubleToString(double value, int width,\n\t\t\t\t      int afterDecimalPoint) {\n    \n    String tempString = doubleToString(value, afterDecimalPoint);\n    char[] result;\n    int dotPosition;\n\n    if ((afterDecimalPoint \u003e= width) \n        || (tempString.indexOf('E') != -1)) { // Protects sci notation\n      return tempString;\n    }\n\n    // Initialize result\n    result = new char[width];\n    for (int i = 0; i \u003c result.length; i++) {\n      result[i] = ' ';\n    }\n\n    if (afterDecimalPoint \u003e 0) {\n      // Get position of decimal point and insert decimal point\n      dotPosition = tempString.indexOf('.');\n      if (dotPosition == -1) {\n\tdotPosition = tempString.length();\n      } else {\n\tresult[width - afterDecimalPoint - 1] = '.';\n      }\n    } else {\n      dotPosition = tempString.length();\n    }\n    \n\n    int offset = width - afterDecimalPoint - dotPosition;\n    if (afterDecimalPoint \u003e 0) {\n      offset--;\n    }\n\n    // Not enough room to decimal align within the supplied width\n    if (offset \u003c 0) {\n      return tempString;\n    }\n\n    // Copy characters before decimal point\n    for (int i = 0; i \u003c dotPosition; i++) {\n      result[offset + i] = tempString.charAt(i);\n    }\n\n    // Copy characters after decimal point\n    for (int i = dotPosition + 1; i \u003c tempString.length(); i++) {\n      result[offset + i] = tempString.charAt(i);\n    }\n\n    return new String(result);\n  }\n\n  /**\n   * Returns the basic class of an array class (handles multi-dimensional\n   * arrays).\n   * @param c        the array to inspect\n   * @return         the class of the innermost elements\n   */\n  public static Class getArrayClass(Class c) {\n     if (c.getComponentType().isArray())\n        return getArrayClass(c.getComponentType());\n     else\n        return c.getComponentType();\n  }\n\n  /**\n   * Returns the dimensions of the given array. Even though the\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\n   * int[3] or double[2][4].\n   *\n   * @param array       the array to determine the dimensions for\n   * @return            the dimensions of the array\n   */\n  public static int getArrayDimensions(Class array) {\n    if (array.getComponentType().isArray())\n      return 1 + getArrayDimensions(array.getComponentType());\n    else\n      return 1;\n  }\n\n  /**\n   * Returns the dimensions of the given array. Even though the\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\n   * int[3] or double[2][4].\n   *\n   * @param array       the array to determine the dimensions for\n   * @return            the dimensions of the array\n   */\n  public static int getArrayDimensions(Object array) {\n    return getArrayDimensions(array.getClass());\n  }\n\n  /**\n   * Returns the given Array in a string representation. Even though the\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\n   * int[3] or double[2][4].\n   * \n   * @param array       the array to return in a string representation\n   * @return            the array as string\n   */\n  public static String arrayToString(Object array) {\n    String        result;\n    int           dimensions;\n    int           i;       \n\n    result     = \"\";\n    dimensions = getArrayDimensions(array);\n    \n    if (dimensions == 0) {\n      result = \"null\";\n    }\n    else if (dimensions == 1) {\n      for (i = 0; i \u003c Array.getLength(array); i++) {\n        if (i \u003e 0)\n          result += \",\";\n        if (Array.get(array, i) == null)\n          result += \"null\";\n        else\n          result += Array.get(array, i).toString();\n      }\n    }\n    else {\n      for (i = 0; i \u003c Array.getLength(array); i++) {\n        if (i \u003e 0)\n          result += \",\";\n        result += \"[\" + arrayToString(Array.get(array, i)) + \"]\";\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * Tests if a is equal to b.\n   *\n   * @param a a double\n   * @param b a double\n     * @return True if a is equal to b.\n   */\n  public static /*@pure@*/ boolean eq(double a, double b){\n    \n    return (a - b \u003c SMALL) \u0026\u0026 (b - a \u003c SMALL); \n  }\n\n  /**\n   * Checks if the given array contains any non-empty options.\n   *\n   * @param options an array of strings\n   * @exception Exception if there are any non-empty options\n   */\n  public static void checkForRemainingOptions(String[] options) \n    throws Exception {\n    \n    int illegalOptionsFound = 0;\n    StringBuffer text = new StringBuffer();\n\n    if (options == null) {\n      return;\n    }\n    for (int i = 0; i \u003c options.length; i++) {\n      if (options[i].length() \u003e 0) {\n\tillegalOptionsFound++;\n\ttext.append(options[i] + ' ');\n      }\n    }\n    if (illegalOptionsFound \u003e 0) {\n      throw new Exception(\"Illegal options: \" + text);\n    }\n  }\n  \n  /**\n   * Checks if the given array contains the flag \"-Char\". Stops\n   * searching at the first marker \"--\". If the flag is found,\n   * it is replaced with the empty string.\n   *\n   * @param flag the character indicating the flag.\n   * @param options the array of strings containing all the options.\n   * @return true if the flag was found\n   * @exception Exception if an illegal option was found\n   */\n  public static boolean getFlag(char flag, String[] options) \n    throws Exception {\n    \n    return getFlag(\"\" + flag, options);\n  }\n  \n  /**\n   * Checks if the given array contains the flag \"-String\". Stops\n   * searching at the first marker \"--\". If the flag is found,\n   * it is replaced with the empty string.\n   *\n   * @param flag the String indicating the flag.\n   * @param options the array of strings containing all the options.\n   * @return true if the flag was found\n   * @exception Exception if an illegal option was found\n   */\n  public static boolean getFlag(String flag, String[] options) \n    throws Exception {\n    \n    int pos = getOptionPos(flag, options);\n\n    if (pos \u003e -1)\n      options[pos] = \"\";\n    \n    return (pos \u003e -1);\n  }\n\n  /**\n   * Gets an option indicated by a flag \"-Char\" from the given array\n   * of strings. Stops searching at the first marker \"--\". Replaces \n   * flag and option with empty strings.\n   *\n   * @param flag the character indicating the option.\n   * @param options the array of strings containing all the options.\n   * @return the indicated option or an empty string\n   * @exception Exception if the option indicated by the flag can't be found\n   */\n  public static /*@non_null@*/ String getOption(char flag, String[] options) \n    throws Exception {\n    \n    return getOption(\"\" + flag, options);\n  }\n\n  /**\n   * Gets an option indicated by a flag \"-String\" from the given array\n   * of strings. Stops searching at the first marker \"--\". Replaces \n   * flag and option with empty strings.\n   *\n   * @param flag the String indicating the option.\n   * @param options the array of strings containing all the options.\n   * @return the indicated option or an empty string\n   * @exception Exception if the option indicated by the flag can't be found\n   */\n  public static /*@non_null@*/ String getOption(String flag, String[] options) \n    throws Exception {\n\n    String newString;\n    int i = getOptionPos(flag, options);\n\n    if (i \u003e -1) {\n      if (options[i].equals(\"-\" + flag)) {\n\tif (i + 1 == options.length) {\n\t  throw new Exception(\"No value given for -\" + flag + \" option.\");\n\t}\n\toptions[i] = \"\";\n\tnewString = new String(options[i + 1]);\n\toptions[i + 1] = \"\";\n\treturn newString;\n      }\n      if (options[i].charAt(1) == '-') {\n\treturn \"\";\n      }\n    }\n    \n    return \"\";\n  }\n\n  /**\n   * Gets the index of an option or flag indicated by a flag \"-Char\" from \n   * the given array of strings. Stops searching at the first marker \"--\".\n   *\n   * @param flag \tthe character indicating the option.\n   * @param options \tthe array of strings containing all the options.\n   * @return \t\tthe position if found, or -1 otherwise\n   */\n  public static int getOptionPos(char flag, String[] options) {\n     return getOptionPos(\"\" + flag, options);\n  }\n\n  /**\n   * Gets the index of an option or flag indicated by a flag \"-String\" from \n   * the given array of strings. Stops searching at the first marker \"--\".\n   *\n   * @param flag \tthe String indicating the option.\n   * @param options \tthe array of strings containing all the options.\n   * @return \t\tthe position if found, or -1 otherwise\n   */\n  public static int getOptionPos(String flag, String[] options) {\n    if (options == null)\n      return -1;\n    \n    for (int i = 0; i \u003c options.length; i++) {\n      if ((options[i].length() \u003e 0) \u0026\u0026 (options[i].charAt(0) == '-')) {\n\t// Check if it is a negative number\n\ttry {\n\t  Double.valueOf(options[i]);\n\t} \n\tcatch (NumberFormatException e) {\n\t  // found?\n\t  if (options[i].equals(\"-\" + flag))\n\t    return i;\n\t  // did we reach \"--\"?\n\t  if (options[i].charAt(1) == '-')\n\t    return -1;\n\t}\n      }\n    }\n    \n    return -1;\n  }\n\n  /**\n   * Quotes a string if it contains special characters.\n   * \n   * The following rules are applied:\n   *\n   * A character is backquoted version of it is one \n   * of \u003ctt\u003e\" ' % \\ \\n \\r \\t\u003c/tt\u003e.\n   *\n   * A string is enclosed within single quotes if a character has been\n   * backquoted using the previous rule above or contains \n   * \u003ctt\u003e{ }\u003c/tt\u003e or is exactly equal to the strings \n   * \u003ctt\u003e, ? space or \"\"\u003c/tt\u003e (empty string).\n   *\n   * A quoted question mark distinguishes it from the missing value which\n   * is represented as an unquoted question mark in arff files.\n   *\n   * @param string \tthe string to be quoted\n   * @return \t\tthe string (possibly quoted)\n   * @see\t\t#unquote(String)\n   */\n  public static /*@pure@*/ String quote(String string) {\n      boolean quote = false;\n\n      // backquote the following characters \n      if ((string.indexOf('\\n') != -1) || (string.indexOf('\\r') != -1) || \n\t  (string.indexOf('\\'') != -1) || (string.indexOf('\"') != -1) || \n\t  (string.indexOf('\\\\') != -1) || \n\t  (string.indexOf('\\t') != -1) || (string.indexOf('%') != -1)) {\n\t  string = backQuoteChars(string);\n\t  quote = true;\n      }\n\n      // Enclose the string in 's if the string contains a recently added\n      // backquote or contains one of the following characters.\n      if((quote == true) || \n\t (string.indexOf('{') != -1) || (string.indexOf('}') != -1) ||\n\t (string.indexOf(',') != -1) || (string.equals(\"?\")) ||\n\t (string.indexOf(' ') != -1) || (string.equals(\"\"))) {\n\t  string = (\"'\".concat(string)).concat(\"'\");\n      }\n\n      return string;\n  }\n\n  /**\n   * unquotes are previously quoted string (but only if necessary), i.e., it\n   * removes the single quotes around it. Inverse to quote(String).\n   * \n   * @param string\tthe string to process\n   * @return\t\tthe unquoted string\n   * @see\t\t#quote(String)\n   */\n  public static String unquote(String string) {\n    if (string.startsWith(\"'\") \u0026\u0026 string.endsWith(\"'\")) {\n      string = string.substring(1, string.length() - 1);\n      \n      if ((string.indexOf(\"\\\\n\") != -1) || (string.indexOf(\"\\\\r\") != -1) || \n\t  (string.indexOf(\"\\\\'\") != -1) || (string.indexOf(\"\\\\\\\"\") != -1) || \n\t  (string.indexOf(\"\\\\\\\\\") != -1) || \n\t  (string.indexOf(\"\\\\t\") != -1) || (string.indexOf(\"\\\\%\") != -1)) {\n\tstring = unbackQuoteChars(string);\n      }\n    }\n\n    return string;\n  }\n\n  /**\n   * Converts carriage returns and new lines in a string into \\r and \\n.\n   * Backquotes the following characters: ` \" \\ \\t and %\n   * \n   * @param string \tthe string\n   * @return \t\tthe converted string\n   * @see\t\t#unbackQuoteChars(String)\n   */\n  public static /*@pure@*/ String backQuoteChars(String string) {\n\n    int index;\n    StringBuffer newStringBuffer;\n\n    // replace each of the following characters with the backquoted version\n    char   charsFind[] =    {'\\\\',   '\\'',  '\\t',  '\\n',  '\\r',  '\"',    '%'};\n    String charsReplace[] = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\n\", \"\\\\r\", \"\\\\\\\"\", \"\\\\%\"};\n    for (int i = 0; i \u003c charsFind.length; i++) {\n      if (string.indexOf(charsFind[i]) != -1 ) {\n\tnewStringBuffer = new StringBuffer();\n\twhile ((index = string.indexOf(charsFind[i])) != -1) {\n\t  if (index \u003e 0) {\n\t    newStringBuffer.append(string.substring(0, index));\n\t  }\n\t  newStringBuffer.append(charsReplace[i]);\n\t  if ((index + 1) \u003c string.length()) {\n\t    string = string.substring(index + 1);\n\t  } else {\n\t    string = \"\";\n\t  }\n\t}\n\tnewStringBuffer.append(string);\n\tstring = newStringBuffer.toString();\n      }\n    }\n\n    return string;\n  }\n\n  /**\n   * Converts carriage returns and new lines in a string into \\r and \\n.\n   *\n   * @param string the string\n   * @return the converted string\n   */\n  public static String convertNewLines(String string) {\n    int index;\n\n    // Replace with \\n\n    StringBuffer newStringBuffer = new StringBuffer();\n    while ((index = string.indexOf('\\n')) != -1) {\n      if (index \u003e 0) {\n\tnewStringBuffer.append(string.substring(0, index));\n      }\n      newStringBuffer.append('\\\\');\n      newStringBuffer.append('n');\n      if ((index + 1) \u003c string.length()) {\n\tstring = string.substring(index + 1);\n      } else {\n\tstring = \"\";\n      }\n    }\n    newStringBuffer.append(string);\n    string = newStringBuffer.toString();\n\n    // Replace with \\r\n    newStringBuffer = new StringBuffer();\n    while ((index = string.indexOf('\\r')) != -1) {\n      if (index \u003e 0) {\n\tnewStringBuffer.append(string.substring(0, index));\n      }\n      newStringBuffer.append('\\\\');\n      newStringBuffer.append('r');\n      if ((index + 1) \u003c string.length()){\n\tstring = string.substring(index + 1);\n      } else {\n\tstring = \"\";\n      }\n    }\n    newStringBuffer.append(string);\n    return newStringBuffer.toString();\n  }\n\n  /**\n   * Reverts \\r and \\n in a string into carriage returns and new lines.\n   * \n   * @param string the string\n   * @return the converted string\n   */\n  public static String revertNewLines(String string) {\n    int index;\n\n    // Replace with \\n\n    StringBuffer newStringBuffer = new StringBuffer();\n    while ((index = string.indexOf(\"\\\\n\")) != -1) {\n      if (index \u003e 0) {\n\tnewStringBuffer.append(string.substring(0, index));\n      }\n      newStringBuffer.append('\\n');\n      if ((index + 2) \u003c string.length()) {\n\tstring = string.substring(index + 2);\n      } else {\n\tstring = \"\";\n      }\n    }\n    newStringBuffer.append(string);\n    string = newStringBuffer.toString();\n\n    // Replace with \\r\n    newStringBuffer = new StringBuffer();\n    while ((index = string.indexOf(\"\\\\r\")) != -1) {\n      if (index \u003e 0) {\n\tnewStringBuffer.append(string.substring(0, index));\n      }\n      newStringBuffer.append('\\r');\n      if ((index + 2) \u003c string.length()){\n\tstring = string.substring(index + 2);\n      } else {\n\tstring = \"\";\n      }\n    }\n    newStringBuffer.append(string);\n    \n    return newStringBuffer.toString();\n  }\n\n  /**\n   * Returns the secondary set of options (if any) contained in\n   * the supplied options array. The secondary set is defined to\n   * be any options after the first \"--\". These options are removed from\n   * the original options array.\n   *\n   * @param options the input array of options\n   * @return the array of secondary options\n   */\n  public static String[] partitionOptions(String[] options) {\n\n    for (int i = 0; i \u003c options.length; i++) {\n      if (options[i].equals(\"--\")) {\n\toptions[i++] = \"\";\n\tString[] result = new String [options.length - i];\n\tfor (int j = i; j \u003c options.length; j++) {\n\t  result[j - i] = options[j];\n\t  options[j] = \"\";\n\t}\n\treturn result;\n      }\n    }\n    return new String [0];\n  }\n    \n  /**\n   * The inverse operation of backQuoteChars().\n   * Converts back-quoted carriage returns and new lines in a string \n   * to the corresponding character ('\\r' and '\\n').\n   * Also \"un\"-back-quotes the following characters: ` \" \\ \\t and %\n   *\n   * @param string \tthe string\n   * @return \t\tthe converted string\n   * @see\t\t#backQuoteChars(String)\n   */\n  public static String unbackQuoteChars(String string) {\n\n    int index;\n    StringBuffer newStringBuffer;\n    \n    // replace each of the following characters with the backquoted version\n    String charsFind[]    = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\n\", \"\\\\r\", \"\\\\\\\"\", \"\\\\%\"};\n    char   charsReplace[] = {'\\\\',   '\\'',  '\\t',  '\\n',  '\\r',  '\"',    '%'};\n    int pos[] = new int[charsFind.length];\n    int\tcurPos;\n    \n    String str = new String(string);\n    newStringBuffer = new StringBuffer();\n    while (str.length() \u003e 0) {\n      // get positions and closest character to replace\n      curPos = str.length();\n      index  = -1;\n      for (int i = 0; i \u003c pos.length; i++) {\n\tpos[i] = str.indexOf(charsFind[i]);\n\tif ( (pos[i] \u003e -1) \u0026\u0026 (pos[i] \u003c curPos) ) {\n\t  index  = i;\n\t  curPos = pos[i];\n\t}\n      }\n      \n      // replace character if found, otherwise finished\n      if (index == -1) {\n\tnewStringBuffer.append(str);\n\tstr = \"\";\n      }\n      else {\n\tnewStringBuffer.append(str.substring(0, pos[index]));\n\tnewStringBuffer.append(charsReplace[index]);\n\tstr = str.substring(pos[index] + charsFind[index].length());\n      }\n    }\n\n    return newStringBuffer.toString();\n  }    \n  \n  /**\n   * Split up a string containing options into an array of strings,\n   * one for each option.\n   *\n   * @param \t\tquotedOptionString the string containing the options\n   * @return \t\tthe array of options\n   * @throws Exception \tin case of an unterminated string, unknown character or\n   * \t\t\ta parse error\n   */\n  public static String[] splitOptions(String quotedOptionString) throws Exception{\n\n    Vector\u003cString\u003e optionsVec = new Vector\u003cString\u003e();\n    String str = new String(quotedOptionString);\n    int i;\n    \n    while (true){\n\n      //trimLeft \n      i = 0;\n      while ((i \u003c str.length()) \u0026\u0026 (Character.isWhitespace(str.charAt(i)))) i++;\n      str = str.substring(i);\n      \n      //stop when str is empty\n      if (str.length() == 0) break;\n      \n      //if str start with a double quote\n      if (str.charAt(0) == '\"'){\n\t\n\t//find the first not anti-slached double quote\n\ti = 1;\n\twhile(i \u003c str.length()){\n\t  if (str.charAt(i) == str.charAt(0)) break;\n\t  if (str.charAt(i) == '\\\\'){\n\t    i += 1;\n\t    if (i \u003e= str.length()) \n\t      throw new Exception(\"String should not finish with \\\\\");\n\t  }\n\t  i += 1;\n\t}\n\tif (i \u003e= str.length()) throw new Exception(\"Quote parse error.\");\n\t\n\t//add the founded string to the option vector (without quotes)\n\tString optStr = str.substring(1,i);\n\toptStr = unbackQuoteChars(optStr);\n\toptionsVec.addElement(optStr);\n\tstr = str.substring(i+1);\n      } else {\n\t//find first whiteSpace\n\ti=0;\n\twhile((i \u003c str.length()) \u0026\u0026 (!Character.isWhitespace(str.charAt(i)))) i++;\n\t\n\t//add the founded string to the option vector\n\tString optStr = str.substring(0,i);\n\toptionsVec.addElement(optStr);\n\tstr = str.substring(i);\n      }\n    }\n    \n    //convert optionsVec to an array of String\n    String[] options = new String[optionsVec.size()];\n    for (i = 0; i \u003c optionsVec.size(); i++) {\n      options[i] = (String)optionsVec.elementAt(i);\n    }\n    return options;\n  }    \n\n  /**\n   * Joins all the options in an option array into a single string,\n   * as might be used on the command line.\n   *\n   * @param optionArray the array of options\n   * @return the string containing all options.\n   */\n  public static String joinOptions(String[] optionArray) {\n\n    String optionString = \"\";\n    for (int i = 0; i \u003c optionArray.length; i++) {\n      if (optionArray[i].equals(\"\")) {\n\tcontinue;\n      }\n      boolean escape = false;\n      for (int n = 0; n \u003c optionArray[i].length(); n++) {\n\tif (Character.isWhitespace(optionArray[i].charAt(n))) {\n\t  escape = true;\n\t  break;\n\t}\n      }\n      if (escape) {\n\toptionString += '\"' + backQuoteChars(optionArray[i]) + '\"';\n      } else {\n\toptionString += optionArray[i];\n      }\n      optionString += \" \";\n    }\n    return optionString.trim();\n  }\n  \n  /**\n   * Creates a new instance of an object given it's class name and\n   * (optional) arguments to pass to it's setOptions method. If the\n   * object implements OptionHandler and the options parameter is\n   * non-null, the object will have it's options set. Example use:\u003cp\u003e\n   *\n   * \u003ccode\u003e \u003cpre\u003e\n   * String classifierName = Utils.getOption('W', options);\n   * Classifier c = (Classifier)Utils.forName(Classifier.class,\n   *                                          classifierName,\n   *                                          options);\n   * setClassifier(c);\n   * \u003c/pre\u003e\u003c/code\u003e\n   *\n   * @param classType the class that the instantiated object should\n   * be assignable to -- an exception is thrown if this is not the case\n   * @param className the fully qualified class name of the object\n   * @param options an array of options suitable for passing to setOptions. May\n   * be null. Any options accepted by the object will be removed from the\n   * array.\n   * @return the newly created object, ready for use.\n   * @exception Exception if the class name is invalid, or if the\n   * class is not assignable to the desired class type, or the options\n   * supplied are not acceptable to the object\n  \n  public static Object forName(Class\u003c?\u003e classType,\n\t\t\t       String className,\n\t\t\t       String[] options) throws Exception {\n\n    Class\u003c?\u003e c = null;\n    try {\n      c = Class.forName(className);\n    } catch (Exception ex) {\n      throw new Exception(\"Can't find class called: \" + className);\n    }\n    if (!classType.isAssignableFrom(c)) {\n      throw new Exception(classType.getName() + \" is not assignable from \"\n\t\t\t  + className);\n    }\n    Object o = c.newInstance();\n    if ((o instanceof OptionHandler)\n\t\u0026\u0026 (options != null)) {\n      ((OptionHandler)o).setOptions(options);\n      Utils.checkForRemainingOptions(options);\n    }\n    return o;\n  }\n */\n  /**\n   * Generates a commandline of the given object. If the object is not \n   * implementing OptionHandler, then it will only return the classname,\n   * otherwise also the options.\n   * \n   * @param obj\t\tthe object to turn into a commandline\n   * @return\t\tthe commandline\n  \n  public static String toCommandLine(Object obj) {\n    StringBuffer\tresult;\n    \n    result = new StringBuffer();\n    \n    if (obj != null) {\n      result.append(obj.getClass().getName());\n      if (obj instanceof OptionHandler)\n\tresult.append(\" \" + joinOptions(((OptionHandler) obj).getOptions()));\n    }\n    \n    return result.toString().trim();\n  }\n   */\n  /**\n   * Computes entropy for an array of integers.\n   *\n   * @param counts array of counts\n   * @return - a log2 a - b log2 b - c log2 c + (a+b+c) log2 (a+b+c)\n   * when given array [a b c]\n   */\n  public static /*@pure@*/ double info(int counts[]) {\n    \n    int total = 0;\n    double x = 0;\n    for (int j = 0; j \u003c counts.length; j++) {\n      x -= xlogx(counts[j]);\n      total += counts[j];\n    }\n    return x + xlogx(total);\n  }\n\n  /**\n   * Tests if a is smaller or equal to b.\n   *\n   * @param a a double\n   * @param b a double\n     * @return True  if a is smaller or equal to b.\n   */\n  public static /*@pure@*/ boolean smOrEq(double a,double b) {\n    \n    return (a-b \u003c SMALL);\n  }\n\n  /**\n   * Tests if a is greater or equal to b.\n   *\n   * @param a a double\n   * @param b a double\n     * @return True if a is greater or equal to b.\n   */\n  public static /*@pure@*/ boolean grOrEq(double a,double b) {\n    \n    return (b-a \u003c SMALL);\n  }\n  \n  /**\n   * Tests if a is smaller than b.\n   *\n   * @param a a double\n   * @param b a double\n     * @return True if a is smaller than b. \n   */\n  public static /*@pure@*/ boolean sm(double a,double b) {\n    \n    return (b-a \u003e SMALL);\n  }\n\n  /**\n   * Tests if a is greater than b.\n   *\n   * @param a a double\n   * @param b a double \n     * @return True if a is greater than b. \n   */\n  public static /*@pure@*/ boolean gr(double a,double b) {\n    \n    return (a-b \u003e SMALL);\n  }\n\n  /**\n   * Returns the kth-smallest value in the array.\n   *\n   * @param array the array of integers\n   * @param k the value of k\n   * @return the kth-smallest value\n   */\n  public static double kthSmallestValue(int[] array, int k) {\n\n    int[] index = new int[array.length];\n    \n    for (int i = 0; i \u003c index.length; i++) {\n      index[i] = i;\n    }\n\n    return array[index[select(array, index, 0, array.length - 1, k)]];\n  }\n\n  /**\n   * Returns the kth-smallest value in the array\n   *\n   * @param array the array of double\n   * @param k the value of k\n   * @return the kth-smallest value\n   */\n  public static double kthSmallestValue(double[] array, int k) {\n\n    int[] index = new int[array.length];\n    \n    for (int i = 0; i \u003c index.length; i++) {\n      index[i] = i;\n    }\n\n    return array[index[select(array, index, 0, array.length - 1, k)]];\n  }\n\n  /**\n   * Returns the logarithm of a for base 2.\n   *\n   * @param a \ta double\n   * @return\tthe logarithm for base 2\n   */\n  public static /*@pure@*/ double log2(double a) {\n    \n    return Math.log(a) / log2;\n  }\n\n  /**\n   * Returns index of maximum element in a given\n   * array of doubles. First maximum is returned.\n   *\n   * @param doubles the array of doubles\n   * @return the index of the maximum element\n   */\n  public static /*@pure@*/ int maxIndex(double[] doubles) {\n\n    double maximum = 0;\n    int maxIndex = 0;\n\n    for (int i = 0; i \u003c doubles.length; i++) {\n      if ((i == 0) || (doubles[i] \u003e maximum)) {\n\tmaxIndex = i;\n\tmaximum = doubles[i];\n      }\n    }\n\n    return maxIndex;\n  }\n\n  /**\n   * Returns index of maximum element in a given\n   * array of integers. First maximum is returned.\n   *\n   * @param ints the array of integers\n   * @return the index of the maximum element\n   */\n  public static /*@pure@*/ int maxIndex(int[] ints) {\n\n    int maximum = 0;\n    int maxIndex = 0;\n\n    for (int i = 0; i \u003c ints.length; i++) {\n      if ((i == 0) || (ints[i] \u003e maximum)) {\n\tmaxIndex = i;\n\tmaximum = ints[i];\n      }\n    }\n\n    return maxIndex;\n  }\n\n  /**\n   * Computes the mean for an array of doubles.\n   *\n   * @param vector the array\n   * @return the mean\n   */\n  public static /*@pure@*/ double mean(double[] vector) {\n  \n    double sum = 0;\n\n    if (vector.length == 0) {\n      return 0;\n    }\n    for (int i = 0; i \u003c vector.length; i++) {\n      sum += vector[i];\n    }\n    return sum / (double) vector.length;\n  }\n\n  /**\n   * Returns index of minimum element in a given\n   * array of integers. First minimum is returned.\n   *\n   * @param ints the array of integers\n   * @return the index of the minimum element\n   */\n  public static /*@pure@*/ int minIndex(int[] ints) {\n\n    int minimum = 0;\n    int minIndex = 0;\n\n    for (int i = 0; i \u003c ints.length; i++) {\n      if ((i == 0) || (ints[i] \u003c minimum)) {\n\tminIndex = i;\n\tminimum = ints[i];\n      }\n    }\n\n    return minIndex;\n  }\n\n  /**\n   * Returns index of minimum element in a given\n   * array of doubles. First minimum is returned.\n   *\n   * @param doubles the array of doubles\n   * @return the index of the minimum element\n   */\n  public static /*@pure@*/ int minIndex(double[] doubles) {\n\n    double minimum = 0;\n    int minIndex = 0;\n\n    for (int i = 0; i \u003c doubles.length; i++) {\n      if ((i == 0) || (doubles[i] \u003c minimum)) {\n\tminIndex = i;\n\tminimum = doubles[i];\n      }\n    }\n\n    return minIndex;\n  }\n\n  /**\n   * Normalizes the doubles in the array by their sum.\n   *\n   * @param doubles the array of double\n   * @exception IllegalArgumentException if sum is Zero or NaN\n   */\n  public static void normalize(double[] doubles) {\n\n    double sum = 0;\n    for (int i = 0; i \u003c doubles.length; i++) {\n      sum += doubles[i];\n    }\n    normalize(doubles, sum);\n  }\n\n  /**\n   * Normalizes the doubles in the array using the given value.\n   *\n   * @param doubles the array of double\n   * @param sum the value by which the doubles are to be normalized\n   * @exception IllegalArgumentException if sum is zero or NaN\n   */\n  public static void normalize(double[] doubles, double sum) {\n\n    if (Double.isNaN(sum)) {\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is NaN.\");\n    }\n    if (sum == 0) {\n      // Maybe this should just be a return.\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is zero.\");\n    }\n    for (int i = 0; i \u003c doubles.length; i++) {\n      doubles[i] /= sum;\n    }\n  }\n\n  /**\n   * Converts an array containing the natural logarithms of\n   * probabilities stored in a vector back into probabilities.\n   * The probabilities are assumed to sum to one.\n   *\n   * @param a an array holding the natural logarithms of the probabilities\n   * @return the converted array \n   */\n  public static double[] logs2probs(double[] a) {\n\n    double max = a[maxIndex(a)];\n    double sum = 0.0;\n\n    double[] result = new double[a.length];\n    for(int i = 0; i \u003c a.length; i++) {\n      result[i] = Math.exp(a[i] - max);\n      sum += result[i];\n    }\n\n    normalize(result, sum);\n\n    return result;\n  } \n\n  /**\n   * Returns the log-odds for a given probabilitiy.\n   *\n   * @param prob the probabilitiy\n   *\n   * @return the log-odds after the probability has been mapped to\n   * [Utils.SMALL, 1-Utils.SMALL]\n   */\n  public static /*@pure@*/ double probToLogOdds(double prob) {\n\n    if (gr(prob, 1) || (sm(prob, 0))) {\n      throw new IllegalArgumentException(\"probToLogOdds: probability must \" +\n\t\t\t\t     \"be in [0,1] \"+prob);\n    }\n    double p = SMALL + (1.0 - 2 * SMALL) * prob;\n    return Math.log(p / (1 - p));\n  }\n\n  /**\n   * Rounds a double to the next nearest integer value. The JDK version\n   * of it doesn't work properly.\n   *\n   * @param value the double value\n   * @return the resulting integer value\n   */\n  public static /*@pure@*/ int round(double value) {\n\n    int roundedValue = value \u003e 0\n      ? (int)(value + 0.5)\n      : -(int)(Math.abs(value) + 0.5);\n    \n    return roundedValue;\n  }\n\n  /**\n   * Rounds a double to the next nearest integer value in a probabilistic\n   * fashion (e.g. 0.8 has a 20% chance of being rounded down to 0 and a\n   * 80% chance of being rounded up to 1). In the limit, the average of\n   * the rounded numbers generated by this procedure should converge to\n   * the original double.\n   *\n   * @param value the double value\n   * @param rand the random number generator\n   * @return the resulting integer value\n   */\n  public static int probRound(double value, Random rand) {\n\n    if (value \u003e= 0) {\n      double lower = Math.floor(value);\n      double prob = value - lower;\n      if (rand.nextDouble() \u003c prob) {\n\treturn (int)lower + 1;\n      } else {\n\treturn (int)lower;\n      }\n    } else {\n      double lower = Math.floor(Math.abs(value));\n      double prob = Math.abs(value) - lower;\n      if (rand.nextDouble() \u003c prob) {\n\treturn -((int)lower + 1);\n      } else {\n\treturn -(int)lower;\n      }\n    }\n  }\n\n  /**\n   * Rounds a double to the given number of decimal places.\n   *\n   * @param value the double value\n   * @param afterDecimalPoint the number of digits after the decimal point\n   * @return the double rounded to the given precision\n   */\n  public static /*@pure@*/ double roundDouble(double value,int afterDecimalPoint) {\n\n    double mask = Math.pow(10.0, (double)afterDecimalPoint);\n\n    return (double)(Math.round(value * mask)) / mask;\n  }\n\n  /**\n   * Sorts a given array of integers in ascending order and returns an \n   * array of integers with the positions of the elements of the original \n   * array in the sorted array. The sort is stable. (Equal elements remain\n   * in their original order.)\n   *\n   * @param array this array is not changed by the method!\n   * @return an array of integers with the positions in the sorted\n   * array.\n   */\n  public static /*@pure@*/ int[] sort(int[] array) {\n\n    int[] index = new int[array.length];\n    int[] newIndex = new int[array.length];\n    int[] helpIndex;\n    int numEqual;\n    \n    for (int i = 0; i \u003c index.length; i++) {\n      index[i] = i;\n    }\n    quickSort(array, index, 0, array.length - 1);\n\n    // Make sort stable\n    int i = 0;\n    while (i \u003c index.length) {\n      numEqual = 1;\n      for (int j = i + 1; ((j \u003c index.length)\n\t\t\t   \u0026\u0026 (array[index[i]] == array[index[j]]));\n\t   j++) {\n\tnumEqual++;\n      }\n      if (numEqual \u003e 1) {\n\thelpIndex = new int[numEqual];\n\tfor (int j = 0; j \u003c numEqual; j++) {\n\t  helpIndex[j] = i + j;\n\t}\n\tquickSort(index, helpIndex, 0, numEqual - 1);\n\tfor (int j = 0; j \u003c numEqual; j++) {\n\t  newIndex[i + j] = index[helpIndex[j]];\n\t}\n\ti += numEqual;\n      } else {\n\tnewIndex[i] = index[i];\n\ti++;\n      }\n    }\n    return newIndex;\n  }\n\n  /**\n   * Sorts a given array of doubles in ascending order and returns an\n   * array of integers with the positions of the elements of the\n   * original array in the sorted array. NOTE THESE CHANGES: the sort\n   * is no longer stable and it doesn't use safe floating-point\n   * comparisons anymore. Occurrences of Double.NaN are treated as \n   * Double.MAX_VALUE\n   *\n   * @param array this array is not changed by the method!\n   * @return an array of integers with the positions in the sorted\n   * array.  \n   */\n  public static /*@pure@*/ int[] sort(/*@non_null@*/ double[] array) {\n\n    int[] index = new int[array.length];\n    array = (double[])array.clone();\n    for (int i = 0; i \u003c index.length; i++) {\n      index[i] = i;\n      if (Double.isNaN(array[i])) {\n        array[i] = Double.MAX_VALUE;\n      }\n    }\n    quickSort(array, index, 0, array.length - 1);\n    return index;\n  }\n\n  /**\n   * Sorts a given array of doubles in ascending order and returns an \n   * array of integers with the positions of the elements of the original \n   * array in the sorted array. The sort is stable (Equal elements remain\n   * in their original order.) Occurrences of Double.NaN are treated as \n   * Double.MAX_VALUE\n   *\n   * @param array this array is not changed by the method!\n   * @return an array of integers with the positions in the sorted\n   * array.\n   */\n  public static /*@pure@*/ int[] stableSort(double[] array){\n\n    int[] index = new int[array.length];\n    int[] newIndex = new int[array.length];\n    int[] helpIndex;\n    int numEqual;\n    \n    array = (double[])array.clone();\n    for (int i = 0; i \u003c index.length; i++) {\n      index[i] = i;\n      if (Double.isNaN(array[i])) {\n        array[i] = Double.MAX_VALUE;\n      }\n    }\n    quickSort(array,index,0,array.length-1);\n\n    // Make sort stable\n\n    int i = 0;\n    while (i \u003c index.length) {\n      numEqual = 1;\n      for (int j = i+1; ((j \u003c index.length) \u0026\u0026 Utils.eq(array[index[i]],\n\t\t\t\t\t\t\tarray[index[j]])); j++)\n\tnumEqual++;\n      if (numEqual \u003e 1) {\n\thelpIndex = new int[numEqual];\n\tfor (int j = 0; j \u003c numEqual; j++)\n\t  helpIndex[j] = i+j;\n\tquickSort(index, helpIndex, 0, numEqual-1);\n\tfor (int j = 0; j \u003c numEqual; j++) \n\t  newIndex[i+j] = index[helpIndex[j]];\n\ti += numEqual;\n      } else {\n\tnewIndex[i] = index[i];\n\ti++;\n      }\n    }\n\n    return newIndex;\n  }\n\n  /**\n   * Computes the variance for an array of doubles.\n   *\n   * @param vector the array\n   * @return the variance\n   */\n  public static /*@pure@*/ double variance(double[] vector) {\n  \n    double sum = 0, sumSquared = 0;\n\n    if (vector.length \u003c= 1) {\n      return 0;\n    }\n    for (int i = 0; i \u003c vector.length; i++) {\n      sum += vector[i];\n      sumSquared += (vector[i] * vector[i]);\n    }\n    double result = (sumSquared - (sum * sum / (double) vector.length)) / \n      (double) (vector.length - 1);\n\n    // We don't like negative variance\n    if (result \u003c 0) {\n      return 0;\n    } else {\n      return result;\n    }\n  }\n\n  /**\n   * Computes the sum of the elements of an array of doubles.\n   *\n   * @param doubles the array of double\n   * @return the sum of the elements\n   */\n  public static /*@pure@*/ double sum(double[] doubles) {\n\n    double sum = 0;\n\n    for (int i = 0; i \u003c doubles.length; i++) {\n      sum += doubles[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Computes the sum of the elements of an array of integers.\n   *\n   * @param ints the array of integers\n   * @return the sum of the elements\n   */\n  public static /*@pure@*/ int sum(int[] ints) {\n\n    int sum = 0;\n\n    for (int i = 0; i \u003c ints.length; i++) {\n      sum += ints[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns c*log2(c) for a given integer value c.\n   *\n   * @param c an integer value\n   * @return c*log2(c) (but is careful to return 0 if c is 0)\n   */\n  public static /*@pure@*/ double xlogx(int c) {\n    \n    if (c == 0) {\n      return 0.0;\n    }\n    return c * Utils.log2((double) c);\n  }\n\n  /**\n   * Partitions the instances around a pivot. Used by quicksort and\n   * kthSmallestValue.\n   *\n   * @param array the array of doubles to be sorted\n   * @param index the index into the array of doubles\n   * @param l the first index of the subset \n   * @param r the last index of the subset \n   *\n   * @return the index of the middle element\n   */\n  private static int partition(double[] array, int[] index, int l, int r) {\n    \n    double pivot = array[index[(l + r) / 2]];\n    int help;\n\n    while (l \u003c r) {\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\n        l++;\n      }\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\n        r--;\n      }\n      if (l \u003c r) {\n        help = index[l];\n        index[l] = index[r];\n        index[r] = help;\n        l++;\n        r--;\n      }\n    }\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\n      r--;\n    } \n\n    return r;\n  }\n\n  /**\n   * Partitions the instances around a pivot. Used by quicksort and\n   * kthSmallestValue.\n   *\n   * @param array the array of integers to be sorted\n   * @param index the index into the array of integers\n   * @param l the first index of the subset \n   * @param r the last index of the subset \n   *\n   * @return the index of the middle element\n   */\n  private static int partition(int[] array, int[] index, int l, int r) {\n    \n    double pivot = array[index[(l + r) / 2]];\n    int help;\n\n    while (l \u003c r) {\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\n        l++;\n      }\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\n        r--;\n      }\n      if (l \u003c r) {\n        help = index[l];\n        index[l] = index[r];\n        index[r] = help;\n        l++;\n        r--;\n      }\n    }\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\n      r--;\n    } \n\n    return r;\n  }\n  \n  /**\n   * Implements quicksort according to Manber's \"Introduction to\n   * Algorithms\".\n   *\n   * @param array the array of doubles to be sorted\n   * @param index the index into the array of doubles\n   * @param left the first index of the subset to be sorted\n   * @param right the last index of the subset to be sorted\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\n  //@ requires array != index;\n  //  assignable index;\n  private static void quickSort(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \n                                int left, int right) {\n\n    if (left \u003c right) {\n      int middle = partition(array, index, left, right);\n      quickSort(array, index, left, middle);\n      quickSort(array, index, middle + 1, right);\n    }\n  }\n  \n  /**\n   * Implements quicksort according to Manber's \"Introduction to\n   * Algorithms\".\n   *\n   * @param array the array of integers to be sorted\n   * @param index the index into the array of integers\n   * @param left the first index of the subset to be sorted\n   * @param right the last index of the subset to be sorted\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\n  //@ requires array != index;\n  //  assignable index;\n  private static void quickSort(/*@non_null@*/ int[] array, /*@non_null@*/  int[] index, \n                                int left, int right) {\n\n    if (left \u003c right) {\n      int middle = partition(array, index, left, right);\n      quickSort(array, index, left, middle);\n      quickSort(array, index, middle + 1, right);\n    }\n  }\n  \n  /**\n   * Implements computation of the kth-smallest element according\n   * to Manber's \"Introduction to Algorithms\".\n   *\n   * @param array the array of double\n   * @param index the index into the array of doubles\n   * @param left the first index of the subset \n   * @param right the last index of the subset \n   * @param k the value of k\n   *\n   * @return the index of the kth-smallest element\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n  private static int select(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \n                            int left, int right, int k) {\n    \n    if (left == right) {\n      return left;\n    } else {\n      int middle = partition(array, index, left, right);\n      if ((middle - left + 1) \u003e= k) {\n        return select(array, index, left, middle, k);\n      } else {\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\n      }\n    }\n  }\n\n  /**\n   * Converts a File's absolute path to a path relative to the user\n   * (ie start) directory. Includes an additional workaround for Cygwin, which\n   * doesn't like upper case drive letters.\n   * @param absolute the File to convert to relative path\n   * @return a File with a path that is relative to the user's directory\n   * @exception Exception if the path cannot be constructed\n   */\n  public static File convertToRelativePath(File absolute) throws Exception {\n    File        result;\n    String      fileStr;\n    \n    result = null;\n    \n    // if we're running windows, it could be Cygwin\n    if (File.separator.equals(\"\\\\\")) {\n      // Cygwin doesn't like upper case drives -\u003e try lower case drive\n      try {\n        fileStr = absolute.getPath();\n        fileStr =   fileStr.substring(0, 1).toLowerCase() \n                  + fileStr.substring(1);\n        result = createRelativePath(new File(fileStr));\n      }\n      catch (Exception e) {\n        // no luck with Cygwin workaround, convert it like it is\n        result = createRelativePath(absolute);\n      }\n    }\n    else {\n      result = createRelativePath(absolute);\n    }\n\n    return result;\n  }\n\n  /**\n   * Converts a File's absolute path to a path relative to the user\n   * (ie start) directory.\n   * \n   * @param absolute the File to convert to relative path\n   * @return a File with a path that is relative to the user's directory\n   * @exception Exception if the path cannot be constructed\n   */\n  protected static File createRelativePath(File absolute) throws Exception {\n    File userDir = new File(System.getProperty(\"user.dir\"));\n    String userPath = userDir.getAbsolutePath() + File.separator;\n    String targetPath = (new File(absolute.getParent())).getPath() \n      + File.separator;\n    String fileName = absolute.getName();\n    StringBuffer relativePath = new StringBuffer();\n    //    relativePath.append(\".\"+File.separator);\n    //    System.err.println(\"User dir \"+userPath);\n    //    System.err.println(\"Target path \"+targetPath);\n    \n    // file is in user dir (or subdir)\n    int subdir = targetPath.indexOf(userPath);\n    if (subdir == 0) {\n      if (userPath.length() == targetPath.length()) {\n\trelativePath.append(fileName);\n      } else {\n\tint ll = userPath.length();\n\trelativePath.append(targetPath.substring(ll));\n\trelativePath.append(fileName);\n      }\n    } else {\n      int sepCount = 0;\n      String temp = new String(userPath);\n      while (temp.indexOf(File.separator) != -1) {\n\tint ind = temp.indexOf(File.separator);\n\tsepCount++;\n\ttemp = temp.substring(ind+1, temp.length());\n      }\n      \n      String targetTemp = new String(targetPath);\n      String userTemp = new String(userPath);\n      int tcount = 0;\n      while (targetTemp.indexOf(File.separator) != -1) {\n\tint ind = targetTemp.indexOf(File.separator);\n\tint ind2 = userTemp.indexOf(File.separator);\n\tString tpart = targetTemp.substring(0,ind+1);\n\tString upart = userTemp.substring(0,ind2+1);\n\tif (tpart.compareTo(upart) != 0) {\n\t  if (tcount == 0) {\n\t    tcount = -1;\n\t  }\n\t  break;\n\t}\n\ttcount++;\n\ttargetTemp = targetTemp.substring(ind+1, targetTemp.length());\n\tuserTemp = userTemp.substring(ind2+1, userTemp.length());\n      }\n      if (tcount == -1) {\n\t// then target file is probably on another drive (under windows)\n\tthrow new Exception(\"Can't construct a path to file relative to user \"\n\t\t\t    +\"dir.\");\n      }\n      if (targetTemp.indexOf(File.separator) == -1) {\n\ttargetTemp = \"\";\n      }\n      for (int i = 0; i \u003c sepCount - tcount; i++) {\n\trelativePath.append(\"..\"+File.separator);\n      }\n      relativePath.append(targetTemp + fileName);\n    }\n    //    System.err.println(\"new path : \"+relativePath.toString());\n    return new File(relativePath.toString());\n  }\n  \n  /**\n   * Implements computation of the kth-smallest element according\n   * to Manber's \"Introduction to Algorithms\".\n   *\n   * @param array the array of integers\n   * @param index the index into the array of integers\n   * @param left the first index of the subset \n   * @param right the last index of the subset \n   * @param k the value of k\n   *\n   * @return the index of the kth-smallest element\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n  private static int select(/*@non_null@*/ int[] array, /*@non_null@*/ int[] index, \n                            int left, int right, int k) {\n    \n    if (left == right) {\n      return left;\n    } else {\n      int middle = partition(array, index, left, right);\n      if ((middle - left + 1) \u003e= k) {\n        return select(array, index, left, middle, k);\n      } else {\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\n      }\n    }\n  }\n  \n  /**\n   * For a named dialog, returns true if the user has opted not to view\n   * it again in the future.\n   * \n   * @param dialogName the name of the dialog to check (e.g.\n   * weka.gui.GUICHooser.HowToFindPackageManager).\n   * @return true if the user has opted not to view the named dialog\n   * in the future.\n   \n  public static boolean getDontShowDialog(String dialogName) {\n    File wekaHome = WekaPackageManager.WEKA_HOME;\n    \n    if (!wekaHome.exists()) {\n      return false;\n    }\n    \n    File dialogSubDir = new File(wekaHome.toString() + File.separator + \"systemDialogs\");\n    if (!dialogSubDir.exists()) {\n      return false;\n    }\n    \n    File dialogFile = new File(dialogSubDir.toString() + File.separator + dialogName);\n    \n    return dialogFile.exists();\n  }\n  */\n  \n  /**\n   * Specify that the named dialog is not to be displayed in the future.\n   * \n   * @param dialogName the name of the dialog not to show again (e.g.\n   * weka.gui.GUIChooser.HowToFindPackageManager).\n   * @throws Exception if the marker file that is used to indicate that\n   * a named dialog is not to be shown can't be created. This file lives\n   * in $WEKA_HOME/systemDialogs\n  \n  public static void setDontShowDialog(String dialogName) throws Exception {\n    File wekaHome = WekaPackageManager.WEKA_HOME;\n    \n    if (!wekaHome.exists()) {\n      return;\n    }\n    \n    File dialogSubDir = new File(wekaHome.toString() + File.separator + \"systemDialogs\");\n    if (!dialogSubDir.exists()) {\n      if (!dialogSubDir.mkdir()) {\n        return;\n      }\n    }\n    \n    File dialogFile = new File(dialogSubDir.toString() + File.separator + dialogName);\n    dialogFile.createNewFile();\n  }\n   */\n  /**\n   * For a named dialog, if the user has opted not to view it again, \n   * returns the answer the answer the user supplied when they\n   * closed the dialog. Returns null if the user did opt to view\n   * the dialog again.\n   * \n   * @param dialogName the name of the dialog to check (e.g.\n   * weka.gui.GUICHooser.HowToFindPackageManager).\n   * @return the answer the user supplied the last time they\n   * viewed the named dialog (if they opted not to view it again\n   * in the future) or null if the user opted to view the dialog\n   * again in the future.\n   \n  public static String getDontShowDialogResponse(String dialogName) throws Exception {\n    if (!getDontShowDialog(dialogName)) {\n      return null; // This must be the first time - no file recorded yet.\n    }\n    \n    File wekaHome = WekaPackageManager.WEKA_HOME;\n    File dialogSubDir = new File(wekaHome.toString() + File.separator \n        + \"systemDialogs\" + File.separator + dialogName);\n\n    \n    BufferedReader br = new BufferedReader(new FileReader(dialogSubDir));\n    String response = br.readLine();\n    \n    br.close();\n    return response;\n  }\n  */\n  /**\n   * Specify that the named dialog is not to be shown again in the future. \n   * Also records the answer that the user chose when closing the dialog.\n   * \n   * @param dialogName the name of the dialog to no longer display\n   * @param response the user selected response when they closed the dialog\n   * @throws Exception if there is a problem saving the information\n   \n  public static void setDontShowDialogResponse(String dialogName, String response) \n    throws Exception {\n    \n    File wekaHome = WekaPackageManager.WEKA_HOME;\n    \n    if (!wekaHome.exists()) {\n      return;\n    }\n    \n    File dialogSubDir = new File(wekaHome.toString() + File.separator + \"systemDialogs\");\n    if (!dialogSubDir.exists()) {\n      if (!dialogSubDir.mkdir()) {\n        return;\n      }\n    }\n    \n    File dialogFile = new File(dialogSubDir.toString() + File.separator + dialogName);\n    BufferedWriter br = new BufferedWriter(new FileWriter(dialogFile));\n    br.write(response + \"\\n\");\n    br.flush();\n    br.close();\n  }\n  */\n  /**\n   * Returns the revision string.\n   * \n   * @return\t\tthe revision\n   \n  public String getRevision() {\n    return RevisionUtils.extract(\"$Revision: 6959 $\");\n  }\n*/\n  /**\n   * Main method for testing this class.\n   *\n   * @param ops some dummy options\n   */\n  public static void main(String[] ops) {\n\n    double[] doublesWithNaN = {4.5, 6.7, Double.NaN, 3.4, 4.8, 1.2, 3.4};\n    double[] doubles = {4.5, 6.7, 6.7, 3.4, 4.8, 1.2, 3.4, 6.7, 6.7, 3.4};\n    int[] ints = {12, 6, 2, 18, 16, 6, 7, 5, 18, 18, 17};\n\n    try {\n\n      // Option handling\n      System.out.println(\"First option split up:\");\n      if (ops.length \u003e 0) {\n\tString[] firstOptionSplitUp = Utils.splitOptions(ops[0]);\n\tfor (int i = 0; i \u003c firstOptionSplitUp.length; i ++) {\n\t  System.out.println(firstOptionSplitUp[i]);\n\t}\n      }\t\t\t\t\t       \n      System.out.println(\"Partitioned options: \");\n      String[] partitionedOptions = Utils.partitionOptions(ops);\n      for (int i  = 0; i \u003c partitionedOptions.length; i++) {\n\tSystem.out.println(partitionedOptions[i]);\n      }\n      System.out.println(\"Get position of flag -f: \" + Utils.getOptionPos('f', ops));\n      System.out.println(\"Get flag -f: \" + Utils.getFlag('f', ops));\n      System.out.println(\"Get position of option -o: \" + Utils.getOptionPos('o', ops));\n      System.out.println(\"Get option -o: \" + Utils.getOption('o', ops));\n      System.out.println(\"Checking for remaining options... \");\n      Utils.checkForRemainingOptions(ops);\n      \n      // Statistics\n      System.out.println(\"Original array with NaN (doubles): \");\n      for (int i = 0; i \u003c doublesWithNaN.length; i++) {\n\tSystem.out.print(doublesWithNaN[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Original array (doubles): \");\n      for (int i = 0; i \u003c doubles.length; i++) {\n\tSystem.out.print(doubles[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Original array (ints): \");\n      for (int i = 0; i \u003c ints.length; i++) {\n\tSystem.out.print(ints[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Correlation: \" + Utils.correlation(doubles, doubles, \n\t\t\t\t\t\t\t     doubles.length));\n      System.out.println(\"Mean: \" + Utils.mean(doubles));\n      System.out.println(\"Variance: \" + Utils.variance(doubles));\n      System.out.println(\"Sum (doubles): \" + Utils.sum(doubles));\n      System.out.println(\"Sum (ints): \" + Utils.sum(ints));\n      System.out.println(\"Max index (doubles): \" + Utils.maxIndex(doubles));\n      System.out.println(\"Max index (ints): \" + Utils.maxIndex(ints));\n      System.out.println(\"Min index (doubles): \" + Utils.minIndex(doubles));\n      System.out.println(\"Min index (ints): \" + Utils.minIndex(ints));\n      System.out.println(\"Median (doubles): \" + \n                         Utils.kthSmallestValue(doubles, doubles.length / 2));\n      System.out.println(\"Median (ints): \" + \n                         Utils.kthSmallestValue(ints, ints.length / 2));\n\n      // Sorting and normalizing\n      System.out.println(\"Sorted array with NaN (doubles): \");\n      int[] sorted = Utils.sort(doublesWithNaN);\n      for (int i = 0; i \u003c doublesWithNaN.length; i++) {\n\tSystem.out.print(doublesWithNaN[sorted[i]] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Sorted array (doubles): \");\n      sorted = Utils.sort(doubles);\n      for (int i = 0; i \u003c doubles.length; i++) {\n\tSystem.out.print(doubles[sorted[i]] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Sorted array (ints): \");\n      sorted = Utils.sort(ints);\n      for (int i = 0; i \u003c ints.length; i++) {\n\tSystem.out.print(ints[sorted[i]] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Indices from stable sort (doubles): \");\n      sorted = Utils.stableSort(doubles);\n      for (int i = 0; i \u003c doubles.length; i++) {\n\tSystem.out.print(sorted[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Indices from sort (ints): \");\n      sorted = Utils.sort(ints);\n      for (int i = 0; i \u003c ints.length; i++) {\n\tSystem.out.print(sorted[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Normalized array (doubles): \");\n      Utils.normalize(doubles);\n      for (int i = 0; i \u003c doubles.length; i++) {\n\tSystem.out.print(doubles[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Normalized again (doubles): \");\n      Utils.normalize(doubles, Utils.sum(doubles));\n      for (int i = 0; i \u003c doubles.length; i++) {\n\tSystem.out.print(doubles[i] + \" \");\n      }\n      System.out.println();\n      \n      // Pretty-printing\n      System.out.println(\"-4.58: \" + Utils.doubleToString(-4.57826535, 2));\n      System.out.println(\"-6.78: \" + Utils.doubleToString(-6.78214234, 6,2));\n      \n      // Comparisons\n      System.out.println(\"5.70001 == 5.7 ? \" + Utils.eq(5.70001, 5.7));\n      System.out.println(\"5.70001 \u003e 5.7 ? \" + Utils.gr(5.70001, 5.7));\n      System.out.println(\"5.70001 \u003e= 5.7 ? \" + Utils.grOrEq(5.70001, 5.7));\n      System.out.println(\"5.7 \u003c 5.70001 ? \" + Utils.sm(5.7, 5.70001));\n      System.out.println(\"5.7 \u003c= 5.70001 ? \" + Utils.smOrEq(5.7, 5.70001));\n      \n      // Math\n      System.out.println(\"Info (ints): \" + Utils.info(ints));\n      System.out.println(\"log2(4.6): \" + Utils.log2(4.6));\n      System.out.println(\"5 * log(5): \" + Utils.xlogx(5));\n      System.out.println(\"5.5 rounded: \" + Utils.round(5.5));\n      System.out.println(\"5.55555 rounded to 2 decimal places: \" + \n\t\t\t Utils.roundDouble(5.55555, 2));\n      \n      // Arrays\n      System.out.println(\"Array-Dimensions of 'new int[][]': \" + Utils.getArrayDimensions(new int[][]{}));\n      System.out.println(\"Array-Dimensions of 'new int[][]{{1,2,3},{4,5,6}}': \" + Utils.getArrayDimensions(new int[][]{{1,2,3},{4,5,6}}));\n      String[][][] s = new String[3][4][];\n      System.out.println(\"Array-Dimensions of 'new String[3][4][]': \" + Utils.getArrayDimensions(s));\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n  \n",
        "name": "Utils.java",
        "path": "src/keel/Algorithms/Semi_Supervised_Learning/CoForest/Utils.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/Semi_Supervised_Learning/CoForest/Utils.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 1780,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 1781,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);"
        },
        {
          "limitHit": false,
          "lineNumber": 1782,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1803,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 1804,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);"
        },
        {
          "limitHit": false,
          "lineNumber": 1805,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1829,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 1965,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "/***********************************************************************\r\n\r\n\tThis file is part of KEEL-software, the Data Mining tool for regression, \r\n\tclassification, clustering, pattern mining and so on.\r\n\r\n\tCopyright (C) 2004-2010\r\n\r\n\tF. Herrera (herrera@decsai.ugr.es)\r\n    L. SÃ¡nchez (luciano@uniovi.es)\r\n    J. AlcalÃ¡-Fdez (jalcala@decsai.ugr.es)\r\n    S. GarcÃ­a (sglopez@ujaen.es)\r\n    A. FernÃ¡ndez (alberto.fernandez@ujaen.es)\r\n    J. Luengo (julianlm@decsai.ugr.es)\r\n\r\n\tThis program is free software: you can redistribute it and/or modify\r\n\tit under the terms of the GNU General Public License as published by\r\n\tthe Free Software Foundation, either version 3 of the License, or\r\n\t(at your option) any later version.\r\n\r\n\tThis program is distributed in the hope that it will be useful,\r\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\tGNU General Public License for more details.\r\n\r\n\tYou should have received a copy of the GNU General Public License\r\n\talong with this program.  If not, see http://www.gnu.org/licenses/\r\n\r\n **********************************************************************/\r\n\r\npackage keel.Algorithms.Semi_Supervised_Learning.Basic;\r\n\r\nimport keel.Algorithms.Semi_Supervised_Learning.utilities.*;\r\nimport keel.Algorithms.Preprocess.Instance_Selection.SSMA.Cromosoma;\r\nimport keel.Algorithms.Semi_Supervised_Learning.Basic.*;\r\n\r\nimport keel.Dataset.*;\r\n\r\nimport java.util.*;\r\n\r\nimport org.core.*;\r\n\r\n//import Jama.Matrix;\r\n//import Jama.Matrix.*;\r\n\r\n/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\nimport java.util.Arrays;\r\n/**\r\n * Represents a prototype set.\r\n * @author diegoj and Isaac\r\n */\r\npublic class PrototypeSet extends ArrayList\u003cPrototype\u003e implements Comparable\r\n{\r\n    /** Associated instance set to the prototype set. */\r\n    public static InstanceSet associatedInstanceSet = null;\r\n\r\n    /**\r\n     * Features set 1.\r\n     */\r\n    protected static ArrayList\u003cInteger\u003e FeaturesSet1;\r\n    /**\r\n     * Features set 2.\r\n     */\r\n    protected static ArrayList\u003cInteger\u003e FeaturesSet2;  // If you use CO-training\r\n    \r\n    public int compareTo (Object o1) {\r\n        double valor1 = this.size();\r\n        double valor2 = ((PrototypeSet) o1).size();\r\n        if (valor1 \u003c valor2)\r\n          return -1;\r\n        else if (valor1 \u003e valor2)\r\n          return 1;\r\n        else return 0;\r\n      }\r\n\r\n    \r\n    \r\n \r\n    /**\r\n     * Empty constructor\r\n     */\r\n    public PrototypeSet()\r\n    {\r\n        super();\r\n    }\r\n    \r\n    /**\r\n     * Constructs a void set with a number of elements.\r\n     * @param numberOfElements Maximum inicial capacity.\r\n     */\r\n    public PrototypeSet(int numberOfElements)\r\n    {\r\n        super(numberOfElements);\r\n    }\r\n    \r\n    /**\r\n     * Constructs the set based on a instance set\r\n     * @param s InstanceSet used to build the implicit parameter.\r\n     */\r\n    public PrototypeSet(InstanceSet s)\r\n    {\r\n        super(new ArrayList\u003cPrototype\u003e(s.getNumInstances()));\r\n        associatedInstanceSet = new InstanceSet(s);\r\n       \r\n        int num = s.getNumInstances();\r\n        Instance[] instances = s.getInstances();\r\n        for(int i=0; i\u003cnum; ++i)\r\n        {\r\n        \t\r\n            add(new Prototype(instances[i]));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Creates a new set of instances by copying a \r\n     * subset of another set.\r\n     *\r\n     * @param source the set of instances from which a subset \r\n     * is to be created\r\n     * @param first the index of the first instance to be copied\r\n     * @param toCopy the number of instances to be copied\r\n     */\r\n    \r\n    public PrototypeSet(PrototypeSet source, int first, int toCopy)\r\n    {\r\n        super(source.size());\r\n        associatedInstanceSet = source.associatedInstanceSet;\r\n         for(int i=first; i\u003ctoCopy; i++)\r\n             this.add(source.get(i));\r\n    }\r\n    \r\n    /**\r\n     * Transform the prototype set to a instance set object.\r\n     * @return the instance set object.\r\n     */\r\n    public InstanceSet toInstanceSet(){\r\n\r\n    \t\r\n    \tInstanceSet s = new InstanceSet();\r\n    \t\r\n    \ts.setAttributesAsNonStatic();\r\n\r\n        s.setHeader(this.associatedInstanceSet.getHeader());\r\n        s.setAttHeader(this.associatedInstanceSet.getAttHeader());\r\n    \t\r\n    \tfor(int i=0; i\u003c this.size(); ++i)\r\n        {\r\n    \t\t/*\r\n    \t\tInstance anadir = new  Instance(this.get(i).inputs, this.associatedInstanceSet.getAttributeDefinitions());\r\n    \t\t//anadir.setAllOutputValues(this.get(i).outputs);\r\n    \t\t\r\n    \t\tanadir.setOutputNumericValue(0, this.get(i).outputs[0]);\r\n    \t\t//System.out.println(this.get(i).outputs[0]);\r\n            s.addInstance(anadir);\r\n            \r\n            */\r\n    \t\tInstance anadir = new  Instance(this.get(i).inputs, this.associatedInstanceSet.getAttributeDefinitions());\r\n    \t\r\n    \t\t\r\n            //Getting all the attributes\r\n            Attribute[] attrs_input = Attributes.getInputAttributes();\r\n                                                                                                                                     \r\n            //Gettin all the outputs attributes\r\n            Attribute[] attrs_output = Attributes.getOutputAttributes();\r\n\r\n            //Check which is the data type of the inputs\r\n            HashMap\u003cInteger,Boolean\u003e nominalInput = new HashMap\u003cInteger, Boolean\u003e();\r\n            for (int j=0; j\u003cattrs_input.length; j++)\r\n                nominalInput.put(j, (Attributes.getInputAttribute(j).getType()==Attribute.NOMINAL));\r\n\r\n            //Check which is the data type of the outputs\r\n            boolean nominal_output = (Attributes.getOutputAttribute(0).getType()==Attribute.NOMINAL);\r\n            \r\n            \r\n            \r\n           Prototype q = this.get(i).denormalize(); //TOKADO PARA NO NORMALIZAR\r\n               \r\n             for(int j=0; j\u003cthis.get(i).numberOfInputs(); ++j)\r\n                {\r\n                    if(nominalInput.get(j))\r\n                    {\r\n                        anadir.setInputNominalValue(j, q.getInputAsNominal(j));\r\n                        anadir.setInputNumericValue(j, q.getInput(j));\r\n                    }\r\n                    else\r\n                    {\r\n                        double q_i = q.getInput(j); //\r\n                        // p.print();\r\n                        //System.out.println(\"q_i\" + q_i);\r\n                        if(Prototype.getTypeOfAttribute(j) == Prototype.INTEGER)\r\n                        \tanadir.setInputNumericValue(j, Math.round(q_i));\r\n                        else if(Prototype.getTypeOfAttribute(j) == Prototype.DOUBLE)\r\n                        \tanadir.setInputNumericValue(j, q_i);\r\n                    }\r\n                }\r\n             \r\n               if(nominal_output){\r\n                 anadir.setOutputNominalValue(0, q.getOutputAsNominal(0));\r\n                \r\n                    \r\n               }else{\r\n                    anadir.setOutputNumericValue(0, q.label());\r\n               }\r\n            \r\n            s.addInstance(anadir);\r\n            \r\n            \r\n        }\r\n        \r\n        return s;\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n \r\n    /**\r\n     * Build a set using a partition of other.\r\n     * @param parts Partition of other prototype set.\r\n     */\r\n    public PrototypeSet(ArrayList\u003cPrototypeSet\u003e parts)\r\n    {\r\n        super(parts.size());\r\n        for(PrototypeSet ps : parts)\r\n            for(Prototype p : ps)\r\n                add(p);\r\n    }\r\n    \r\n    /**\r\n     * Return all the prototype in (this) that has other like the nearest neighbor\r\n     * @return\r\n     */\r\n    public PrototypeSet isTheNearPrototype(Prototype other){\r\n    \tPrototypeSet result = new PrototypeSet();\r\n    \t\r\n    \tfor(Prototype p: this){\r\n    \t\t\r\n    \t\tPrototype near = this.nearestTo(p);\r\n    \t\t\r\n    \t\tif(near.equals(other)){\r\n    \t\t\tresult.add(p);\r\n    \t\t}\r\n    \t}\r\n    \treturn result;\r\n    \t\r\n    }\r\n  \r\n    /**\r\n     * Return all the prototype in (this) that has other like the nearest neighbor with the class given.\r\n     * @return\r\n     */\r\n    public PrototypeSet isTheNearPrototypeWithClass(Prototype other, double clase){\r\n    \tPrototypeSet result = new PrototypeSet();\r\n    \t\r\n    \tfor(Prototype p: this){\r\n    \t\t\r\n    \t\tPrototype near = this.nearestTo(p);\r\n    \t\t\r\n    \t\tif(near.equals(other) \u0026\u0026 (near.getOutput(0) == clase) ){\r\n    \t\t\tresult.add(p);\r\n    \t\t}\r\n    \t}\r\n    \treturn result;\r\n    \t\r\n    }\r\n    \r\n\r\n    \r\n    /**\r\n     * Return the nearest prototype to all the prototypes of a set.\r\n     * @param current\r\n     * @return\r\n     */\r\n    public Prototype nearestTo(PrototypeSet current)\r\n    {\r\n        double dMin = Double.POSITIVE_INFINITY;\r\n        Prototype nearest = null;\r\n        \r\n        if(current== null)\r\n        \treturn null;\r\n        //Debug.errorln(\"Hay \" + this.size());\r\n        \r\n        \r\n        for(Prototype p : this)\r\n        {\r\n        \tdouble d =0;\r\n        \tfor(Prototype q : current){\r\n        \t\td+= Distance.d(p, q);\r\n        \t}\r\n        \t\r\n        \t            \r\n            if(d \u003c dMin)\r\n            {\r\n                dMin = d;\r\n                nearest = p;\r\n            }\r\n        }\r\n        return nearest;\r\n    }\r\n    \r\n    \r\n    /** \r\n     * Return the nearest prototype to another in the set.\r\n     * @param current Prototype which the algorithm will find its nearest-neighbor.\r\n     * @return Nearest prototype to current in dataSet.\r\n     */\r\n    public Prototype nearestTo(Prototype current)\r\n    {\r\n        double dMin = Double.POSITIVE_INFINITY;\r\n        Prototype nearest = null;\r\n        \r\n        if(current== null)\r\n        \treturn null;\r\n        //Debug.errorln(\"Hay \" + this.size());\r\n        for(Prototype p : this)\r\n        {\r\n            double d = Distance.d(current, p);\r\n            if(d \u003c dMin  ) // \u0026\u0026  !current.equalsInputs(p)\r\n            {\r\n                dMin = d;\r\n                nearest = p;\r\n            }\r\n        }\r\n        return nearest;\r\n    }\r\n    \r\n    \r\n    /** \r\n     * Return the  prototype  containing N from this set.\r\n     * @param current.\r\n     * @return Return the  prototype  containing N from this set.\r\n     */\r\n    public Prototype containing(Prototype current)\r\n    {\r\n        double dMin = Double.POSITIVE_INFINITY;\r\n        Prototype nearest = null;\r\n        //Debug.errorln(\"Hay \" + this.size());\r\n        for(Prototype p : this)\r\n        {\r\n            double d = Distance.d(current, p);\r\n            if(d \u003c dMin)\r\n            {\r\n                dMin = d;\r\n                nearest = p;\r\n            }\r\n        }\r\n        return nearest;\r\n    }\r\n    \r\n    \r\n    /** \r\n     * Return the INDEX off nearest prototype to another in the set.\r\n     * @param current Prototype which the algorithm will find its nearest-neighbor.\r\n     * @return Index of Nearest prototype to current in dataSet.\r\n     */\r\n    public int IndexNearestTo(Prototype current)\r\n    {\r\n        double dMin = Double.POSITIVE_INFINITY;\r\n        Prototype nearest = null;\r\n        int index = 0;\r\n        //Debug.errorln(\"Hay \" + this.size());\r\n        int i=0;\r\n        for(Prototype p : this)\r\n        {\r\n            double d = Distance.d(current, p);\r\n            if(d \u003c dMin  \u0026\u0026  current!=p)\r\n            {\r\n                dMin = d;\r\n                nearest = p;\r\n                index = i;\r\n            }\r\n            i++;\r\n        }\r\n        //System.out.println(\"Index = \" + index);\r\n        return index;\r\n    }\r\n  \r\n    \r\n    /** \r\n     * Return the INDEX of the Second closest prototype to another in the set.\r\n     * @param current Prototype which the algorithm will find its nearest-neighbor.\r\n     * @return Index of Nearest prototype to current in dataSet.\r\n     */\r\n    public int IndexSecondNearestTo(Prototype current)\r\n    {\r\n        double dMin = Double.POSITIVE_INFINITY;\r\n        Prototype nearest = null;\r\n        int index = 0;\r\n        //Debug.errorln(\"Hay \" + this.size());\r\n        int i=0;\r\n        for(Prototype p : this)\r\n        {\r\n            double d = Distance.d(current, p);\r\n            if(d \u003c dMin  \u0026\u0026  current!=p)\r\n            {\r\n                dMin = d;\r\n                nearest = p;\r\n                index = i;\r\n            }\r\n            i++;\r\n        }\r\n        \r\n        // Now we \"eliminate\" the nearest neighbor and look for the second.\r\n        dMin = Double.POSITIVE_INFINITY;\r\n        i =0;\r\n        int index2 = 0;\r\n        for(Prototype p : this)\r\n        {\r\n            double d = Distance.d(current, p);\r\n            if(d \u003c dMin  \u0026\u0026  current!=p \u0026\u0026 i!=index)\r\n            {\r\n                dMin = d;\r\n                nearest = p;\r\n                index2 = i;\r\n            }\r\n            i++;\r\n        }\r\n        //System.out.println(\"Index = \" + index);\r\n        return index2;\r\n    }\r\n    \r\n    \r\n    /** \r\n     * Return the nearest prototype to another in the set.\r\n     * @param current Prototype which the algorithm will find its nearest-neighbor.\r\n     * @return Nearest prototype to current in dataSet and length.\r\n     */\r\n    public Pair\u003cPrototype,Double\u003e minimumLengthAndNearestTo(Prototype current)\r\n    {\r\n        double dMin = Double.POSITIVE_INFINITY;\r\n        Prototype nearest = null;\r\n        //Debug.errorln(\"Hay \" + this.size());\r\n        for(Prototype p : this)\r\n        {\r\n            double d = Distance.d(current, p);\r\n            if(d \u003c dMin  \u0026\u0026  current!=p)\r\n            {\r\n                dMin = d;\r\n                nearest = p;\r\n            }\r\n        }\r\n        return new Pair\u003cPrototype,Double\u003e(nearest,dMin);\r\n    }\r\n    \r\n    /** \r\n     * Return the nearest prototype to another in the set.\r\n     * @param current Prototype which the algorithm will find its nearest-neighbor.\r\n     * @return Nearest prototype to current in dataSet.\r\n     */\r\n    public Pair\u003cPrototype,Double\u003e minimumLengthAndNearestWithSameClassAs(Prototype current)\r\n    {\r\n        double currentLabel = current.label();\r\n        double dMin = Double.POSITIVE_INFINITY;\r\n        Prototype nearest = null;\r\n        //Debug.errorln(\"Hay \" + this.size());\r\n        for(Prototype p : this)\r\n        {\r\n            double d = Distance.d(current, p);\r\n            if(p.label() == currentLabel \u0026\u0026 d \u003c dMin  \u0026\u0026  current!=p)\r\n            {\r\n                dMin = d;\r\n                nearest = p;\r\n            }\r\n        }\r\n        return new Pair\u003cPrototype,Double\u003e(nearest,dMin);\r\n    }\r\n    \r\n    /**\r\n     * Returns the nearest pair of prototypes of the set.\r\n     * @return Pair wich have the nearest pairs of the set.\r\n     */\r\n    public Pair\u003cPrototype,Prototype\u003e nearestPair()\r\n    {\r\n        double dMin = Double.POSITIVE_INFINITY;\r\n        Pair\u003cPrototype,Prototype\u003e nearest = null;\r\n        for(Prototype p : this)\r\n        {\r\n            Pair\u003cPrototype,Double\u003e min = minimumLengthAndNearestWithSameClassAs(p);\r\n            if(min.second()\u003cdMin)\r\n            {\r\n                dMin = min.second();\r\n                nearest = new Pair\u003cPrototype,Prototype\u003e(p, min.first());\r\n            }\r\n            \r\n        }\r\n        return nearest;\r\n    }\r\n    \r\n    /** \r\n     * Return the nearest prototype to another in the set with a specified class.\r\n     * @param current Prototype which the algorithm will find its nearest-neighbor.\r\n     * @param label Class that must have this nearest to current.\r\n     * @return Nearest prototype to current in dataSet.\r\n     */\r\n    public Prototype nearestToWithClass(Prototype current, double label)\r\n    {\r\n        PrototypeSet set = this.getFromClass(label);\r\n        double dMin = Double.POSITIVE_INFINITY;\r\n        Prototype nearest = null;\r\n        for(Prototype p : set)\r\n        {\r\n            double d = Distance.d(current, p);\r\n            if(d \u003c dMin)\r\n            {\r\n                dMin = d;\r\n                nearest = p;\r\n            }\r\n        }\r\n        return nearest;\r\n    }\r\n    \r\n    \r\n    /** \r\n     * Return the nearest prototype to another in the set with a specified class.\r\n     * @param current Prototype which the algorithm will find its nearest-neighbor.\r\n     * @param label Class that must have this nearest to current.\r\n     * @return Nearest prototype to current in dataSet.\r\n     */\r\n    public Prototype nearestToWithDifferentClass(Prototype current, double label)\r\n    {\r\n        PrototypeSet set = this.getAllDifferentFromClass(label);\r\n       \r\n        //System.out.println(\"Set size =\"+ set.size());\r\n        double dMin = Double.POSITIVE_INFINITY;\r\n        Prototype nearest = null;\r\n        for(Prototype p : set)\r\n        {\r\n            double d = Distance.d(current, p);\r\n            if(d \u003c dMin)\r\n            {\r\n                dMin = d;\r\n                nearest = p;\r\n            }\r\n        }\r\n        return nearest;\r\n    }\r\n    \r\n    /**\r\n     * Adds prototype only if it is not already in the set.\r\n     * @param newProt New prototype to be added to the set.\r\n     * @return TRUE if it has been added, FALSE in other chase.\r\n     */\r\n    public boolean uniqueAdd(Prototype newProt)\r\n    {\r\n        boolean found = false;\r\n        int _size = size();\r\n        for(int i=0; !found \u0026\u0026 i\u003c_size; ++i)\r\n        {\r\n            Prototype p = get(i);\r\n            found = (p == newProt) || (p.equals(newProt)) ;\r\n        }\r\n        if(!found)\r\n            add(newProt);\r\n        return found;\r\n    }\r\n    \r\n    /** \r\n     * Return the farthest prototype to another in the set.\r\n     * @param current Prototype which the algorithm will find its farthest-neighbor.\r\n     * @return Farthest prototype to current in dataSet.\r\n     */\r\n    public Prototype farthestTo(Prototype current)\r\n    {\r\n        double dMax = Double.NEGATIVE_INFINITY;\r\n        Prototype farthest = null;\r\n        for(Prototype p : this)\r\n        {\r\n            double d = Distance.d(current, p);\r\n            if(d \u003e dMax)\r\n            {\r\n                dMax = d;\r\n                farthest = p;\r\n            }\r\n        }\r\n        return farthest;\r\n    }\r\n    \r\n    /**\r\n     * Copy constructor. NOTE: soft-copy.\r\n     * @param original Original set to be copied.\r\n     */\r\n    public PrototypeSet(PrototypeSet original)\r\n    {\r\n        super(original.size());\r\n       associatedInstanceSet = original.associatedInstanceSet;\r\n        /*int _size = original.size();\r\n        for(int i=0; i\u003c_size; ++i)\r\n            add(new Prototype(original.get(i)));*/\r\n        for(Prototype p : original)\r\n            add(p);\r\n    }\r\n    \r\n    /**\r\n     * Get a random prototype\r\n     * @return Random prototype of the set\r\n     */\r\n    public Prototype getRandom()\r\n    {\r\n        return get(RandomGenerator.RandintClosed(0, size()-1));\r\n    }\r\n    \r\n    /**\r\n     * Remove a random prototype (and returns it)\r\n     * @return Random removed prototype of the set\r\n     */\r\n    public Prototype removeRandom()\r\n    {\r\n        int i = RandomGenerator.RandintClosed(0, size()-1);\r\n        return remove(i);//returns the removed element\r\n    }\r\n    \r\n    /**\r\n     * Select all the prototypes of a specific class. The class must be a valid!.\r\n     * @param _class Choosen class .\r\n     * @return A prototype set which contains all the prototypes of the original set that are of the choosen class.\r\n     */\r\n    public PrototypeSet getFromClass(double _class)\r\n    {\r\n        PrototypeSet selected = new PrototypeSet(size()/2);\r\n        for(Prototype p : this)\r\n            if(p.label()==_class)\r\n                selected.add(p);\r\n        return selected;\r\n    }\r\n    \r\n    /**\r\n     * Select all the patterns of different classs. The class must be a valid!.\r\n     * @param _class Choosen class .\r\n     * @return A prototype set which contains all the prototypes of the original set that are not of the choosen class.\r\n     */\r\n    public PrototypeSet getAllDifferentFromClass(double _class)\r\n    {\r\n        PrototypeSet selected = new PrototypeSet(size()/2);\r\n        for(Prototype p : this)\r\n            if(p.label()!=_class)\r\n                selected.add(p);\r\n        return selected;\r\n    }\r\n    \r\n    /**\r\n     * Informs if the set contains prototypes with several different classes.\r\n     * @return True if there are two or more prototypes with different classes (labels), False in other case.\r\n     */\r\n    public boolean containsSeveralClasses()\r\n    {\r\n        int _size = size();\r\n        double label = get(0).label();\r\n        boolean foundDifferent = false;\r\n        for(int i=1; i\u003c_size \u0026\u0026 !foundDifferent; ++i)\r\n           foundDifferent = (label != get(i).label());\r\n        return foundDifferent;\r\n    }\r\n    \r\n    /**\r\n     * Count the number of prototypes of each class.\r\n     * @return HashMap of (Class, Number of protoypes with that class assigned)\r\n     */\r\n    public HashMap\u003cDouble, Integer\u003e countPrototypesOfEachOutput()\r\n    {\r\n        HashMap\u003cDouble,Integer\u003e count = new HashMap\u003cDouble,Integer\u003e();\r\n        ArrayList\u003cDouble\u003e values = Prototype.possibleValuesOfOutput();\r\n        for(double d: values)\r\n            count.put(d, 0);\r\n        \r\n        for(Prototype p : this)\r\n            count.put(p.firstOutput(), count.get(p.label())+1);\r\n        \r\n       return count;\r\n    }\r\n    \r\n    /**\r\n     * Inform the frequency of each class of the set\r\n     * @return A hash that informs of the absolute ocurrences of each class\r\n     */\r\n    public HashMap\u003cDouble,Integer\u003e getFrequencyOfClasses()\r\n    {\r\n        return countPrototypesOfEachOutput();\r\n    }\r\n    \r\n    /**\r\n     * Return classes with at least one element.\r\n     * @return Classes that have got at least one prototype.\r\n     */\r\n    public ArrayList\u003cDouble\u003e nonVoidClasses()\r\n    {\r\n        ArrayList\u003cDouble\u003e nonVoidClasses = new ArrayList\u003cDouble\u003e();\r\n        ArrayList\u003cDouble\u003e values = Prototype.possibleValuesOfOutput();\r\n        HashMap\u003cDouble,Integer\u003e freq = getFrequencyOfClasses();\r\n        for(double c : values)\r\n            if(freq.get(c)\u003e0)\r\n                nonVoidClasses.add(c);\r\n        return nonVoidClasses;        \r\n    }\r\n    \r\n    /**\r\n     * Returns classes which there are prototypes with them.\r\n     * @return ArrayList with the classes that has got at least one prototype in the set.\r\n     */\r\n    public ArrayList\u003cDouble\u003e classesWithPrototypes(){ return nonVoidClasses(); }\r\n    \r\n    /**\r\n     * Returns the most frequent class\r\n     * @return The class with more ocurrences in the set.\r\n     */\r\n    public double mostFrequentClass()\r\n    {\r\n        HashMap\u003cDouble,Integer\u003e classes = getFrequencyOfClasses();\r\n        int maxFreq = -1;\r\n        double maxClass = -1.0;\r\n        ArrayList\u003cDouble\u003e array = new ArrayList\u003cDouble\u003e(classes.keySet());\r\n        for(double c : array)\r\n        {\r\n            int ocurr_c = classes.get(c);\r\n            if(ocurr_c \u003e maxFreq)\r\n            {\r\n                maxFreq = ocurr_c;\r\n                maxClass = c;                \r\n            }\r\n            else if(ocurr_c == maxFreq)\r\n            {\r\n                maxClass = RandomGenerator.randomSelector(c,maxClass);\r\n            }\r\n        }\r\n        return maxClass;\r\n    }\r\n    \r\n    /**\r\n     * Converts data set into a String.\r\n     * @return String with a canonical representation of the data set\r\n     */\r\n    @Override\r\n    public String toString()\r\n    {\r\n        String result = \"\";\r\n        \r\n        int n = size();\r\n        for(int i=0; i\u003cn; ++i)\r\n            result += get(i).toString() + \"\\n\";\r\n        return result;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Prints the prototype in the terminal\r\n     */\r\n    public void print()\r\n    {\r\n        System.out.println(\"\\n\"+toString());\r\n    }\r\n    \r\n    /**\r\n     * Override of the clone function\r\n     * @return A new object hard-new-copy of the caller.\r\n     */\r\n    @Override\r\n    public PrototypeSet clone()\r\n    {\r\n        //return new PrototypeSet(this);\r\n        PrototypeSet copy = new PrototypeSet(this.size());\r\n        copy.associatedInstanceSet = this.associatedInstanceSet;\r\n        for(Prototype p : this)\r\n            copy.add(new Prototype(p));\r\n        return copy;\r\n    }\r\n    \r\n    /**\r\n     * Hard-copy of the prototype set.\r\n     * @return A new object hard-new-copy of the caller.\r\n     */\r\n    public PrototypeSet copy()\r\n    {\r\n        return this.clone();\r\n    }\r\n    \r\n    \r\n\r\n    \r\n    \r\n    /**\r\n     * Converts the dataset into a hashset Â¿Para quÃ© cojones se usa?\r\n     * @return Hashset of the dataset\r\n     */\r\n    public HashSet\u003cPrototype\u003e toHashSet()\r\n    {\r\n        HashSet\u003cPrototype\u003e h = new HashSet\u003cPrototype\u003e();\r\n        for(Prototype p : this)\r\n            h.add(p);\r\n        return h;\r\n    }\r\n    \r\n    /**\r\n     * Converts the dataset into a hashmap (Prototype p, index of p in the set)\r\n     * @return Hashmap of the dataset where keys are prototypes and values are index in the data set.\r\n     */\r\n    public HashMap\u003cPrototype,Integer\u003e toHashMap()\r\n    {\r\n        HashMap\u003cPrototype,Integer\u003e h = new HashMap\u003cPrototype,Integer\u003e();\r\n        int _size = size();\r\n        for(int i=0; i\u003c_size; ++i)\r\n            h.put(get(i), i);\r\n        return h;\r\n    }\r\n    \r\n       \r\n    /**\r\n     * Sort the prototype set in ascending distance to current prototype.\r\n     * @param current Prototype base to be compared to every element of the set.\r\n     * @return Sorted set in ascending distance order to current prototype.\r\n     */\r\n    public PrototypeSet sort(Prototype current)\r\n    {\r\n        int _size = size();\r\n        PrototypeSet sorted = new PrototypeSet(_size);\r\n        sorted.add(this);\r\n        Collections.sort(sorted, new Distance(current));        \r\n        return sorted;\r\n    }\r\n\r\n    /**\r\n     * Returns the two nearest to each other prototypes\r\n     * @return A pair with the two fartest prototypes in the set.\r\n     */\r\n    public Pair\u003cPrototype, Prototype\u003e farthestPrototypes()\r\n    {\r\n        int _size = size();        \r\n        double maximumDistance = Double.NEGATIVE_INFINITY;\r\n        Prototype ex1 = null;\r\n        Prototype ex2 = null;\r\n        for(int i=0; i\u003c_size; ++i)\r\n            for(int j=i+1; j\u003c_size; ++j)\r\n                {\r\n                    Prototype p1 = get(i);\r\n                    Prototype p2 = get(j);\r\n                    double cur_dist = Distance.d(p1, p2);\r\n                    if(cur_dist \u003e maximumDistance)\r\n                    {\r\n                        maximumDistance = cur_dist;\r\n                        ex1 = p1;\r\n                        ex2 = p2;\r\n                    }\r\n                }\r\n        return new Pair\u003cPrototype, Prototype\u003e(ex1, ex2); \r\n    }\r\n    \r\n\r\n    /**\r\n     * Generate two subsets of the set t.\r\n     * @param p1 Prototype whose closer prototypes will be in first set.\r\n     * @param p2 Prototype whose closer prototypes will be in second set.\r\n     * @return Two sets of prototypes. Prototype p will be in Pi if pi is nearest to p than pj, for i!=j.\r\n     */\r\n    public Pair\u003cPrototypeSet,PrototypeSet\u003e partIntoSubsetsWhichSeedPointsAre(Prototype p1, Prototype p2)\r\n    {\r\n        return partIntoSubsetsWhichSeedPointsAre(new Pair\u003cPrototype,Prototype\u003e(p1,p2));\r\n    }\r\n   \r\n    /**\r\n     * Generate two subsets of the set t.\r\n     * @param pair Pair of prototypes which will determine the partition.\r\n     * @return Two sets of prototypes. Prototype p will be in Pi if pi is nearest to p than pj, for i!=j.\r\n     */\r\n    public Pair\u003cPrototypeSet,PrototypeSet\u003e partIntoSubsetsWhichSeedPointsAre(Pair\u003cPrototype,Prototype\u003e pair)\r\n    {\r\n        Prototype p1 = pair.first();//seed of the P1 set\r\n        Prototype p2 = pair.second();//seed of the P2 set\r\n        PrototypeSet P1 = new PrototypeSet();\r\n        PrototypeSet P2 = new PrototypeSet();\r\n        P1.add(p1);\r\n        P2.add(p2);\r\n        for(Prototype p : this)\r\n            if(p != p1 \u0026\u0026 p != p2)\r\n            {\r\n                if(Distance.d(p, p2) \u003c Distance.d(p, p1))\r\n                    P2.add(p);\r\n                else\r\n                    P1.add(p);\r\n            }\r\n        Pair\u003cPrototypeSet, PrototypeSet\u003e part = new Pair\u003cPrototypeSet,PrototypeSet\u003e(P1,P2);\r\n        return part;\r\n    }\r\n \r\n    \r\n    /**\r\n     * This method return the ratio of the average distance between instances blongin to different classes of i\r\n     * and the average distance between instances that are from the same class i.\r\n     * @return\r\n     * @note This method is obtain by the exprexion (4) in the paper October 1, 2008 18:43WSPC/INSTRUCTIONFILECano-Garcia-Herrera-Bernado-IJPRAI \r\n \t\tBecause it was imposible to understand in the original PAPER\r\n     */\r\n    public double Overlapping (){\r\n    \tdouble lapping = 0.0;\r\n    \tdouble D1=0.0, D2 =0.0;\r\n    \tPrototype m = new Prototype(this.get(0));\r\n    \tPrototype mi =new Prototype(this.get(0));\r\n     // Inicialize the prototype.\r\n    \t\r\n    \tint numberOfClass = this.getPosibleValuesOfOutput().size();\r\n    \t\r\n    \t//Numerator\r\n    \tfor (int i= 0; i\u003c numberOfClass; i++){\r\n\t    \tPrototypeSet aux = this.getFromClass(i);\r\n\t    \tint ni = aux.size();\r\n\t    \t\r\n\t    \tif( ni != 0){\r\n\t\t    \t m = this.avg(); // overall mean.\r\n\t\t    \t mi = aux.avg();  // mean of class i\r\n\t\t    }\r\n\t    \tD1 += Distance.d(m.formatear(), mi.formatear()) * ni;\r\n\t    \t\r\n\t  \t}\r\n    \t\r\n    \tfor (int i=0; i\u003c numberOfClass; i++){\r\n    \t\tPrototypeSet aux = this.getFromClass(i);\r\n\t    \tint ni = aux.size();\r\n\t    \t\r\n\t    \tif( ni != 0){\r\n\t    \t\t mi = aux.avg();  // mean of class i\r\n\t    \t}\r\n\t    \t\r\n\t     \tfor( int j=0; j\u003c ni; j++){\r\n\t     \t\tPrototype xij = aux.get(j);\r\n\t    \t     D2+=Distance.d(xij.formatear(), mi.formatear());\r\n\t    \t}\r\n\t    \t    \t\r\n    \t}\r\n    \t\r\n    \tlapping = D2 / D1;\r\n    \t\r\n\t     return lapping;\r\n    \t\r\n    }\r\n    \r\n    /**\r\n     * \r\n     * @return If the set contains a mixture of instance return false.\r\n     */\r\n    public boolean homogeneity (){\r\n    \t\r\n    \tif(this.containsSeveralClasses())\r\n    \t\treturn false;\r\n    \treturn true;\r\n    }\r\n    \r\n    /**\r\n     * Generate two subsets of the set t.\r\n     * @param p1 Prototype whose closer prototypes will be in first set.\r\n     * @param p2 Prototype whose closer prototypes will be in second set.\r\n     * @return Two sets of prototypes. Prototype p will be in Pi if pi is nearest to p than pj, for i!=j.\r\n     */\r\n    public Pair\u003cPrototypeSet,PrototypeSet\u003e partIntoSubsetsOverlappingDegree(Prototype p1, Prototype p2)\r\n    {\r\n        return partIntoSubsetsWhichSeedPointsAre(new Pair\u003cPrototype,Prototype\u003e(p1,p2));\r\n    }\r\n    \r\n    /**\r\n     * Generate two subsets of the set t.\r\n     * @param pair Pair of prototypes which will determine the partition.\r\n     * @return Two sets of prototypes. Prototype p will be in Pi if pi is nearest to p than pj, for i!=j.\r\n     */\r\n    public Pair\u003cPrototypeSet,PrototypeSet\u003e partIntoSubsetsOverlappingDegree(Pair\u003cPrototype,Prototype\u003e pair)\r\n    {\r\n        Prototype p1 = pair.first();//seed of the P1 set\r\n        Prototype p2 = pair.second();//seed of the P2 set\r\n        PrototypeSet P1 = new PrototypeSet();\r\n        PrototypeSet P2 = new PrototypeSet();\r\n        P1.add(p1);\r\n        P2.add(p2);\r\n        for(Prototype p : this)\r\n            if(p != p1 \u0026\u0026 p != p2)\r\n            {\r\n                if(Distance.d(p, p2) \u003c Distance.d(p, p1))\r\n                    P2.add(p);\r\n                else\r\n                    P1.add(p);\r\n            }\r\n        Pair\u003cPrototypeSet, PrototypeSet\u003e part = new Pair\u003cPrototypeSet,PrototypeSet\u003e(P1,P2);\r\n        return part;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Makes a partition of the set by class. One part by one class present in the set.\r\n     * @return Class-partition of the current set. That is, one partition for each subset of prototypes with same class.\r\n     */\r\n    public ArrayList\u003cPrototypeSet\u003e classPartition()\r\n    {\r\n        ArrayList\u003cDouble\u003e classes = nonVoidClasses();\r\n        //Debug.errorln(\"Tenemos classes\");\r\n        ArrayList\u003cPrototypeSet\u003e part = new ArrayList\u003cPrototypeSet\u003e(classes.size());\r\n        for(double c : classes)\r\n        {\r\n            PrototypeSet setC = getFromClass(c);\r\n            if(!setC.isEmpty())\r\n                part.add(setC);\r\n        }\r\n        return part;\r\n    }\r\n    \r\n    /**\r\n     * Swaps two elements of the prototype set.\r\n     * @param i1 First element.\r\n     * @param i2 Second element.\r\n     */\r\n    public void swap(int i1, int i2)\r\n    {\r\n        Collections.swap(this, i1, i2);\r\n    }\r\n    \r\n    /**\r\n     * Shuffle the set. Uses PrototypeGenerator random seed.\r\n     * @see PrototypeGenerator\r\n     */\r\n    public void randomize()\r\n    {\r\n        Random r = new Random();\r\n        r.setSeed(PrototypeGenerator.getSeed());\r\n        Collections.shuffle(this, r);\r\n    }\r\n    \r\n    /**\r\n     * Shuffle the set.\r\n     * @param shuffleSeed Seed of the random generator.\r\n     */\r\n    public void randomize(long shuffleSeed)\r\n    {\r\n        Random r = new Random();\r\n        r.setSeed(shuffleSeed);\r\n        Collections.shuffle(this, r);\r\n    }\r\n    \r\n    /**\r\n     * Makes a partition of the set. Keeping the % of prototypes selected for each class.\r\n     * @param percentInFirst Percentile of the prototyepes that willbe in the first set.\r\n     * @return Pair of prototype sets. First element contains percentInFirst prototypes of the original, and second the others.\r\n     */\r\n    public Pair\u003cPrototypeSet,PrototypeSet\u003e makePartitionPerClass(double percentInFirst)\r\n    {\r\n        PrototypeSet first = new PrototypeSet();\r\n        PrototypeSet second = new PrototypeSet();\r\n        PrototypeSet copy = this.copy();\r\n        ArrayList\u003cDouble\u003e classes = copy.nonVoidClasses();\r\n        for(double c : classes)\r\n        {\r\n            PrototypeSet pc = copy.getFromClass(c);\r\n            int pc_size = pc.size();\r\n            int numInFirst = (int)Math.floor(pc_size * percentInFirst/100.0);\r\n            for(int i=0; i\u003cnumInFirst; ++i)\r\n                first.add(pc.get(i));\r\n            for(int i=numInFirst; i\u003cpc_size; ++i)\r\n                second.add(pc.get(i));\r\n        }\r\n        return new Pair\u003cPrototypeSet,PrototypeSet\u003e(first,second);\r\n    }\r\n   \r\n    /**\r\n     * Makes a partition of the set. Keeping the % of prototypes selected for each class.\r\n     * @param percentInFirst Percentile of the prototyepes that willbe in the first set.\r\n     * @return Pair of prototype sets. First element contains percentInFirst prototypes of the original, and second the others.\r\n     */\r\n    public Pair\u003cPrototypeSet,PrototypeSet\u003e makePartition(double percentInFirst)\r\n    {\r\n        PrototypeSet first = new PrototypeSet();\r\n        PrototypeSet second = new PrototypeSet();\r\n        PrototypeSet copy = this.copy();\r\n        copy.randomize();\r\n        int _size = size();\r\n        int numInFirst = (int)Math.floor(_size * percentInFirst/100.0);\r\n        for(int i=0; i\u003cnumInFirst; ++i)\r\n            first.add(copy.get(i));\r\n        for(int i=numInFirst; i\u003c_size; ++i)\r\n            second.add(copy.get(i));   \r\n        return new Pair\u003cPrototypeSet,PrototypeSet\u003e(first,second);\r\n    }\r\n    \r\n    /**\r\n     * Make a partition of a set. numberOfSets sets with the same number of prototypes will be generated.\r\n     * @param numberOfSets Number of subsets of the prototype set to be generated.\r\n     * @return Set of prototype set which is a partition of it.\r\n     */\r\n    public ArrayList\u003cPrototypeSet\u003e partIn(int numberOfSets)\r\n    {\r\n        int _size = size();\r\n        Debug.force(_size \u003e numberOfSets, \"Too much partitions\");\r\n        int _size_1 = _size-1;\r\n        int protsBySet = _size/numberOfSets;\r\n        ArrayList\u003cInteger\u003e shuffle = RandomGenerator.generateDifferentRandomIntegers(0, _size_1, _size);\r\n        ArrayList\u003cPrototypeSet\u003e partitions = new ArrayList\u003cPrototypeSet\u003e(numberOfSets);\r\n        int offset=0;\r\n        for(int i=0; i\u003cnumberOfSets; ++i)\r\n        {\r\n            PrototypeSet partition_i = new PrototypeSet();\r\n            int end = offset+protsBySet;\r\n            for(int index=offset; index\u003cend; ++index)\r\n            {\r\n                int k = shuffle.get(index);\r\n                partition_i.add(get(k));                \r\n            }\r\n            partitions.add(partition_i);\r\n            offset = end;\r\n        }\r\n        return partitions;    \r\n    }\r\n    \r\n    /**\r\n     * Size of the greatest diameter in the set.\r\n     * @return Largest distance between two prototypes in the set.\r\n     */\r\n    public double largestDiameter()\r\n    {\r\n        \r\n        Pair\u003cPrototype, Prototype\u003e p = farthestPrototypes();\r\n        return Distance.d(p.first(), p.second()); \r\n    }\r\n    \r\n    /**\r\n     * Converts data set into a Keelish-String.\r\n     * @param title Title of the data set (required for all keel data files)\r\n     * @return String with the Keel data file representation of the prototype set\r\n     */\r\n    public String asKeelDataFileString(String title)\r\n    {\r\n        String line = \"@relation \"+title+\"\\n\";\r\n                                                                                                                             \r\n        //Getting all the attributes\r\n        Attribute[] attrs_input = Attributes.getInputAttributes();\r\n\r\n        for (int i=0; i\u003cattrs_input.length; i++)\r\n            line += attrs_input[i].toString()+\"\\n\";\r\n                                                                                                                                 \r\n        //Gettin all the outputs attributes\r\n        Attribute[] attrs_output = Attributes.getOutputAttributes();\r\n        line += attrs_output[0].toString()+\"\\n\";\r\n                                                                                                                             \r\n        //Getting @inputs and @outputs\r\n        line += Attributes.getInputHeader()+\"\\n\";\r\n        line += Attributes.getOutputHeader()+\"\\n\";\r\n        \r\n        String text = line;\r\n        \r\n        //Check which is the data type of the inputs\r\n        HashMap\u003cInteger,Boolean\u003e nominalInput = new HashMap\u003cInteger, Boolean\u003e();\r\n        for (int i=0; i\u003cattrs_input.length; i++)\r\n            nominalInput.put(i, (Attributes.getInputAttribute(i).getType()==Attribute.NOMINAL));\r\n\r\n        //Check which is the data type of the outputs\r\n        boolean nominal_output = (Attributes.getOutputAttribute(0).getType()==Attribute.NOMINAL);\r\n        \r\n        text += \"@data\\n\";\r\n        \r\n        if(this.size()!=0){\r\n\t        //The data\r\n\t        int n_attributes = get(0).numberOfInputs();        \r\n\t        \r\n\t\r\n\t        for(Prototype p: this)\r\n\t        {\r\n\t            Prototype q = p.denormalize(); //TOKADO PARA NO NORMALIZAR\r\n\t            for(int i=0; i\u003cn_attributes; ++i)\r\n\t            {\r\n\t                if(nominalInput.get(i))\r\n\t                {\r\n\t                \ttext += q.getInputAsNominal(i) + \", \";\r\n\t                }\r\n\t                else\r\n\t                {\r\n\t                    double q_i = q.getInput(i); //\r\n\t                    // p.print();\r\n\t                    //System.out.println(\"q_i\" + q_i);\r\n\t                   if(Prototype.getTypeOfAttribute(i) == Prototype.INTEGER)\r\n\t                        text += Math.round(q_i) + \", \"; // ERROR de DIEGO!?\r\n\t                    else if(Prototype.getTypeOfAttribute(i) == Prototype.DOUBLE)\r\n\t                        text += q_i + \", \"; \r\n\t                   \r\n\t                   /*\r\n\t                    if(Attributes.getInputAttribute(i).getType() == Attribute.INTEGER)\r\n\t                        text += Math.round(q_i) + \", \"; // ERROR de DIEGO!?\r\n\t                    else if(Attributes.getInputAttribute(i).getType() == Attribute.REAL)\r\n\t                        text += q_i + \", \"; \r\n\t                    else{\r\n\t                        System.out.println(\"QUE POLLAS PAZA AKI\");\r\n\t                    } */\r\n\t                }\r\n\t            }\r\n\t           if(nominal_output)\r\n\t                text += q.getOutputAsNominal(0) + \"\\n\";\r\n\t           else\r\n\t                text += q.label() + \"\\n\";\r\n\t        }\r\n        }// end if\r\n        return text;\r\n    }\r\n    \r\n    /**\r\n     * Converts data set into a Keelish-String.\r\n     * @return String with the Keel data file representation of the prototype set\r\n     */\r\n    public String asKeelDataFileString()\r\n    {\r\n        return asKeelDataFileString(Attributes.getRelationName());\r\n    }\r\n    \r\n    /**\r\n     * Save the data in a file (Keel style)\r\n     * @param filename Name of the output file.\r\n     */\r\n    public void save(String filename)\r\n    {\r\n        KeelFile.write(filename, this.asKeelDataFileString());\r\n    }\r\n    \r\n    /**\r\n     * Join two prototype sets\r\n     * @param other Set to unite.\r\n     * @return PrototypeSet which the elements of the two operands (two prototype sets).\r\n     */\r\n    public PrototypeSet union(PrototypeSet other)\r\n    {\r\n        PrototypeSet result = new PrototypeSet(other.size()+size());\r\n        \r\n        for(Prototype p: this)\r\n            result.add(p);\r\n        \r\n        for(Prototype p: other)\r\n            if(!result.contains(p))\r\n                result.add(p);\r\n        \r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * Performs the union betwenn the set of protoypeset.\r\n     * @return ProtoypeSet which is the union of all the parts.\r\n     \r\n    public static PrototypeSet union(ArrayList\u003cPrototypeSet\u003e parts)\r\n    {\r\n       PrototypeSet result = new PrototypeSet();\r\n       for(PrototypeSet ps : parts)\r\n           result = result.union(ps);\r\n    }*/\r\n    \r\n    /**\r\n     * Join a prototype to a set\r\n     * @param other Other prototype to be joined.\r\n     * @return A new set which is union of the set and the prototype.\r\n     */\r\n    public PrototypeSet join(Prototype other)\r\n    {\r\n        PrototypeSet result = this.copy();\r\n        result.add(other);\r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * Returns a copy of the set without an element.\r\n     * @param other Element to be removed of the returned copy.\r\n     * @return Copy of the set without other element.\r\n     */\r\n    public PrototypeSet without(PrototypeSet other)\r\n    {\r\n        PrototypeSet result = new PrototypeSet(this);\r\n        for(Prototype o : other)\r\n            if(result.contains(o))\r\n                result.remove(o);\r\n        return result;\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n     *  Returns a copy of the set without an prototype.\r\n     */\r\n    public Prototype borrar(int index){\r\n    \tPrototype borrado = null;\r\n    \t\r\n    \tfor(int i=0; i\u003cthis.size(); i++){\r\n    \t\tif(this.get(i).getIndex()==index){\r\n    \t\t\tborrado = new Prototype(this.remove(i));\r\n    \t\t}\r\n    \t}\r\n\t\treturn borrado;\r\n    \r\n    \t\r\n    }\r\n    \r\n    \r\n    /**\r\n     *  Returns a copy of the set without an prototype.\r\n     */\r\n    public boolean remove(Prototype other){\r\n    \t\r\n    \tboolean fin = false;\r\n    \t\r\n    \tfor(int i=0; i\u003cthis.size() \u0026\u0026 !fin; i++){\r\n    \t\tif( this.get(i).equals(other)){\r\n    \t\t\tfin = true;\r\n    \t\t\tthis.remove(i);\r\n    \t\t}\r\n    \t}\r\n    \t\r\n    \treturn fin;\r\n    }\r\n    \r\n    /**\r\n     *  Returns a copy of the set without an prototype.\r\n     */\r\n    public boolean remove(PrototypeSet other){\r\n    \t\r\n    \tboolean fin = false;\r\n    \t\r\n    \tfor(int j=0; j\u003cother.size(); j++){\r\n\t    \tfor(int i=0; i\u003cthis.size() \u0026\u0026 !fin; i++){\r\n\t    \t\tif( this.get(i).equals(other.get(j))){\r\n\t    \t\t\tfin = true;\r\n\t    \t\t\tthis.remove(i);\r\n\t    \t\t}\r\n\t    \t}\r\n    \t}\r\n    \treturn fin;\r\n    }\r\n    \r\n    \r\n    /**\r\n     *  Returns a copy of the set without an prototype without checking the class label\r\n     */\r\n    public boolean removeWithoutClass(Prototype other){\r\n\t\r\n    \tboolean fin = false;\r\n\r\n    \t\r\n    \tfor(int i=0; i\u003cthis.size() \u0026\u0026 !fin; i++){\r\n    \t\tif(this.get(i).equalsInputs(other)){\r\n    \t\t\tfin = true;\r\n    \t\t\tthis.remove(i);\r\n    \t\t}\r\n    \t}\r\n    \t\r\n    \t/*\r\n    \tif(!fin){\r\n    \t\tSystem.err.println(\"ERROR AL BORRAR\");\r\n    \t\tother.print();\r\n\r\n    \t}*/\r\n    \treturn fin;\r\n    }\r\n    \r\n    /**\r\n     *\r\n     * @param other\r\n     * @return\r\n     */\r\n    public boolean removeWithoutClass(PrototypeSet other){\r\n    \t\r\n    \tboolean fin = false;\r\n    \t\r\n    \tfor(int j=0; j\u003cother.size(); j++){\r\n    \t\tthis.removeWithoutClass(other.get(j));\r\n    \t}\r\n    \treturn fin;\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n     *  Comprueba si existen en el conjunto....\r\n     */\r\n    public boolean pertenece(Prototype other){\r\n    \t\r\n    \tboolean fin = false;\r\n    \t\r\n    \tfor(int i=0; i\u003cthis.size() \u0026\u0026 !fin; i++){\r\n    \t\tif( this.get(i).equals(other)){\r\n    \t\t\tfin = true;\r\n    \t\t}\r\n    \t}\r\n    \t\r\n    \treturn fin;\r\n    }\r\n    \r\n    public boolean perteneceSinClass(Prototype other){\r\n    \t\r\n    \tboolean fin = false;\r\n    \t\r\n    \tfor(int i=0; i\u003cthis.size() \u0026\u0026 !fin; i++){\r\n    \t\tif( this.get(i).equalsInputs(other)){\r\n    \t\t\tfin = true;\r\n    \t\t}\r\n    \t}\r\n    \t\r\n    \treturn fin;\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n     * Returns a copy of the set without an prototype.\r\n     * @param other Element to be removed of the returned copy.\r\n     * @return Copy of the set without other element.\r\n     */\r\n    public PrototypeSet without(Prototype other)\r\n    {\r\n        PrototypeSet result = new PrototypeSet(this);\r\n         if(result.contains(other))\r\n                result.remove(other);\r\n         else{\r\n        \t System.err.println(\"Error al borrase\");\r\n         }\r\n        return result;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Returns a copy of the set without an element.\r\n     * @param other Element to be removed of the returned copy.\r\n     * @return Copy of the set without other element.\r\n     */\r\n    public PrototypeSet minus(PrototypeSet other)\r\n    {\r\n        return without(other);\r\n    }\r\n      \r\n    /**\r\n     * Performs avg operation of the prototype set.\r\n     * @return Average prototype of the data set.\r\n     */\r\n    public Prototype avg()\r\n    {\r\n    \tif (this.size() !=0){\r\n\t     int numInputs = get(0).numberOfInputs();\r\n\t     int numOutputs = get(0).numberOfOutputs();     \r\n\t     \r\n\t     double[] inputs = new double[numInputs];\r\n\t     for(int i=0; i\u003cnumInputs; ++i)\r\n\t         inputs[i]=0.0;\r\n\t     \r\n\t     double[] outputs = new double[numOutputs];\r\n\t     for(int i=0; i\u003cnumOutputs; ++i)\r\n\t         outputs[i]=get(0).getOutput(i);\r\n\t     \r\n\t     for(Prototype p: this)\r\n\t         for(int i=0; i\u003cnumInputs; ++i)\r\n\t            inputs[i] += p.getInput(i);\r\n\t\r\n\t     int _size = this.size();\r\n\t     for(int i=0; i\u003cnumInputs; ++i)\r\n\t            inputs[i] /= _size;\r\n\t     return new Prototype(inputs, outputs);\r\n    \t}\r\n     return null;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Performs standard desviation operation of the prototype set.\r\n     * @return SD prototype of the data set.\r\n     * @author Isaac.\r\n     */\r\n    public Prototype sd()\r\n    {\r\n    \tPrototype sd = new Prototype(this.get(0).numberOfInputs(),1);\r\n    \tPrototype diference;\r\n    \t//First\r\n    \tPrototype avg = this.avg();\r\n    \tint N = this.size();\r\n    \t\r\n    \tPrototype Sumatory  = new Prototype(this.get(0).numberOfInputs(),1);\r\n    \tfor(int i=0; i\u003c Sumatory.numberOfInputs(); i++){\r\n    \t\tSumatory.setInput(i,0);\r\n    \t}\r\n    \t\r\n    \tfor(int i = 0; i\u003c this.size(); i++){\r\n    \t\tPrototype Xi = this.get(i);\r\n    \t\tdiference = Xi.sub(avg);\r\n    \t\t\r\n    \t\tdiference = diference.mul(diference);  // ^2\r\n    \t\t\r\n    \t\t//diference.print();\r\n        \tfor(int j=0; j\u003c Sumatory.numberOfInputs(); j++){\r\n        \t\tSumatory.setInput(j, Sumatory.getInput(j)+diference.getInput(j));\r\n        \t}\r\n    \t\t//Sumatory.print();\r\n    \t}\r\n    \t\r\n    \t\r\n    \tfor(int j=0; j\u003c Sumatory.numberOfInputs(); j++){\r\n    \t\tSumatory.setInput(j, Sumatory.getInput(j)/N);\r\n    \t}\r\n    \t//Sumatory.mul(1./N);\r\n    \tsd = Sumatory.sqrt();\r\n    \t\r\n    \treturn sd;\r\n\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Add the elements of a set.\r\n     * @param other Set with the elements to include.\r\n     */\r\n    public void add(PrototypeSet other)\r\n    {\r\n        for(Prototype p: other)\r\n            this.add(p);\r\n    }\r\n  \r\n    \r\n    /**\r\n     * Add the elements of a set.\r\n     * @param other Set with the elements to include.\r\n     */\r\n    public void addNoRepetition(PrototypeSet other)\r\n    {\r\n        for(Prototype p: other)\r\n        \tif(!this.perteneceSinClass(p))\r\n        \t\tthis.add(p);\r\n    }\r\n  \r\n    \r\n    /**\r\n     * Add one prototype to the set..\r\n     * @param one prototype\r\n     * @author isaac\r\n     */\r\n    public void addPrototype(Prototype other)\r\n    {\r\n         this.add(other);\r\n    }\r\n    \r\n    public void addPrototypeNoRepetition(Prototype other)\r\n    {\r\n    \tif(!this.perteneceSinClass(other))\r\n           this.add(other);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * this + other.\r\n     * @param other\r\n     * @return  S U other\r\n     * @author isaac\r\n     */\r\n    public PrototypeSet addPrototype2(Prototype other){\r\n    \tPrototypeSet otro = new PrototypeSet(this);\r\n    \t\r\n    \totro.add(other);\r\n    \treturn otro;\r\n   \r\n    }\r\n    /**\r\n     * Return all the existing classes in our universe.\r\n     * @return All the values of the outputs (clasess) that exists in the dataset.\r\n     * @see Prototype#possibleValuesOfOutput()\r\n     */\r\n    public ArrayList\u003cDouble\u003e getPosibleValuesOfOutput()\r\n    {\r\n        return Prototype.possibleValuesOfOutput();\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n     * Returns the greatest distance between center and other prototype and that prototype.\r\n     * @param center Prototype to be euclidean-distance compared.\r\n     * @return A Pair with the farthest prototype and the distance.\r\n     */\r\n    public Pair\u003cPrototype,Double\u003e radius(Prototype center)\r\n    {\r\n        double max = -1.0;\r\n        Prototype pMax = null;\r\n        for(Prototype p : this)\r\n        {\r\n            double current = Distance.d(p, center);\r\n            if(current \u003e max)\r\n            {\r\n                max = current;\r\n                pMax = p;\r\n            }\r\n        }\r\n        return new Pair\u003cPrototype,Double\u003e(pMax,max);\r\n    }\r\n    \r\n    /**\r\n     * Returns the smallest distance between center and other prototype and that prototype.\r\n     * @param center Prototype to be euclidean-distance compared.\r\n     * @return A Pair with the farthest prototype and the distance.\r\n     */\r\n    public Pair\u003cPrototype,Double\u003e antiRadius(Prototype center)\r\n    {\r\n        double min = 999999999;\r\n        Prototype pMin = null;\r\n        for(Prototype p : this)\r\n        {\r\n            double current = Distance.d(p, center);\r\n            if(current \u003c min)\r\n            {\r\n                min = current;\r\n                pMin = p;\r\n            }\r\n        }\r\n        return new Pair\u003cPrototype,Double\u003e(pMin,min);\r\n    }\r\n    \r\n    /**\r\n     * Returns the greatest distance between center.\r\n     * @param center Prototype to be euclidean-distance compared.\r\n     * @return Greatest distance between center and other prototype of the set.\r\n    */\r\n    public double maxDistanceTo(Prototype center)\r\n    {\r\n        return radius(center).second();\r\n    }\r\n   \r\n    /**\r\n     * Returns the smallest distance between center and other prototype and that prototype.\r\n     * @param center Prototype to be euclidean-distance compared.\r\n     * @return Greatest distance between center and other prototype of the set.\r\n     */\r\n    public double minDistanceTo(Prototype center)\r\n    {\r\n        return antiRadius(center).second();\r\n    }\r\n    \r\n    /**\r\n     * return the smallest distance between uno and all prototypes of the particle.\r\n     * @author Isaac\r\n     */\r\n    \r\n    public double minDist ( Prototype uno)\r\n    {\r\n    \t\r\n        double min = 999999999;\r\n        //Prototype pMin = null;\r\n        for(Prototype p : this)\r\n        {\r\n            double current = Distance.d(p, uno);\r\n            if(current \u003c min)\r\n            {\r\n                min = current;\r\n                \r\n            }\r\n        }\r\n        \r\n    \treturn min;\r\n    }\r\n    \r\n    /**\r\n     * Returns variance of prototype set to the center.\r\n     * @param ps Prototype set to be measured.\r\n     * @param center Average prototype.\r\n     * @return Value of the variance of the set.\r\n     */\r\n    public static double variance(PrototypeSet ps, Prototype center)\r\n    {\r\n        double acc = 0.0;\r\n        for(Prototype p : ps)\r\n            acc += Distance.d(center, p);\r\n        return acc;\r\n    }\r\n    \r\n    /**\r\n     * Change values of the prototypes that are not in the values domain.\r\n     */\r\n    public void applyThresholds()\r\n    {\r\n        for(Prototype p : this)\r\n            p.applyThresholds();\r\n    }\r\n    \r\n    /*public void round()\r\n    {\r\n        for(Prototype p : this)\r\n            p.round();\r\n    }*/\r\n    \r\n    \r\n    /**\r\n     * Print Prototype Set.\r\n     * This function can help to debug the algorithm.\r\n     */\r\n    \r\n    public void printSet(){\r\n    \tSystem.out.println(\"The prototype Set has \"+ this.size() + \" instances\");\r\n    \t\r\n    \tfor(int i=0; i\u003c this.size();i++){\r\n    \t\t\r\n    \t\tfor(int j=0; j\u003cthis.get(i).numberOfInputs();j++){\r\n    \t\t\tSystem.out.print( this.get(i).getInput(j)+ \" \\t \");\r\n    \t\t}\r\n    \t\tSystem.out.print(\"\\n\");\r\n    \t}\r\n    \t\r\n    }\r\n    \r\n\r\n    \r\n    /**\r\n     * \r\n     * @param datosTrain\r\n     * @param C\r\n     * @param centers\r\n     * @return\r\n   \r\n    \r\n    @SuppressWarnings(\"unused\")\r\n\tpublic int[] Cmeans (double datosTrain[][], int C, double centers[][]) {\r\n\r\n\r\n\r\n\t\tint clusters[];\r\n\r\n\t\tint tmp, pos;\r\n\r\n\t\tint baraje[];\r\n\r\n\t\tint i, j;\r\n\r\n\t\tdouble minDist, dist;\r\n\r\n\t\tboolean cambio = true;\r\n\r\n\t\tint nc[];\r\n\r\n\t\t\r\n\r\n\t\tclusters = new int[datosTrain.length];\r\n\r\n\t\tbaraje = new int[datosTrain.length];\r\n\r\n\t\t\r\n\r\n\t\tfor (i=0; i\u003cdatosTrain.length; i++) {\r\n\r\n\t\t\tbaraje[i] = i;\r\n\r\n\t\t}\r\n\r\n\r\n\r\n\t\tfor (i=0; i\u003cdatosTrain.length; i++) {\r\n\r\n\t\t\tpos = Randomize.Randint(i, datosTrain.length);\r\n\r\n\t\t\ttmp = baraje[i];\r\n\r\n\t\t\tbaraje[i] = baraje[pos];\r\n\r\n\t\t\tbaraje[pos] = tmp;\t\t\t\r\n\r\n\t\t}\r\n\r\n\t\t\r\n\r\n\t\tfor (i=0; i\u003cC; i++) {\r\n\r\n\t\t\tfor (j=0; j\u003cdatosTrain[0].length; j++) {\r\n\r\n\t\t\t\tcenters[i][j] = datosTrain[baraje[i]][j];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t\r\n\r\n\t\tfor (i=0; i\u003cdatosTrain.length; i++) {\r\n\r\n\t\t\tpos = 0;\r\n\r\n\t\t\tminDist = KNN.distancia(datosTrain[i], centers[0]);\r\n\r\n\t\t\tfor (j=1; j\u003cC; j++) {\r\n\r\n\t\t\t\tdist = KNN.distancia(datosTrain[i], centers[j]);\r\n\r\n\t\t\t\tif (dist \u003c minDist) {\r\n\r\n\t\t\t\t\tpos = j;\r\n\r\n\t\t\t\t\tminDist = dist;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tclusters[i] = pos;\r\n\r\n\t\t}\r\n\r\n\t\t\r\n\r\n\t\tnc = new int[C];\r\n\r\n\t\twhile (cambio) {\r\n\r\n\t\t\tcambio = false;\r\n\r\n\t\t\t\r\n\r\n\t\t\tArrays.fill(nc, 0);\r\n\r\n\t\t\tfor (i=0; i\u003cC; i++) {\r\n\r\n\t\t\t\tArrays.fill(centers[i], 0.0);\r\n\r\n\t\t\t}\r\n\r\n\t\t\t\r\n\r\n\t\t\tfor (i=0; i\u003cdatosTrain.length; i++) {\r\n\r\n\t\t\t\tnc[clusters[i]]++;\r\n\r\n\t\t\t\tfor (j=0; j\u003cdatosTrain[0].length; j++) {\r\n\r\n\t\t\t\t\tcenters[clusters[i]][j] += datosTrain[i][j];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t\r\n\r\n\t\t\tfor (i=0; i\u003cC; i++) {\r\n\r\n\t\t\t\tfor (j=0; j\u003cdatosTrain[0].length; j++) {\r\n\r\n\t\t\t\t\tcenters[i][j] /= (double)nc[i];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t\r\n\r\n\t\t\tfor (i=0; i\u003cdatosTrain.length; i++) {\r\n\r\n\t\t\t\tpos = 0;\r\n\r\n\t\t\t\tminDist = KNN.distancia(datosTrain[i], centers[0]);\r\n\r\n\t\t\t\tfor (j=1; j\u003cC; j++) {\r\n\r\n\t\t\t\t\tdist = KNN.distancia(datosTrain[i], centers[j]);\r\n\r\n\t\t\t\t\tif (dist \u003c minDist) {\r\n\r\n\t\t\t\t\t\tpos = j;\r\n\r\n\t\t\t\t\t\tminDist = dist;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (clusters[i] != pos) {\r\n\r\n\t\t\t\t\tcambio = true;\r\n\r\n\t\t\t\t\tclusters[i] = pos;\r\n\t\t\t\t\t\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t\r\n\r\n\t\t}\r\n\r\n\r\n\r\n\t\treturn clusters;\r\n\r\n\t}\r\n\r\n  */\r\n\t\r\n    \r\n    /**\r\n     * \r\n     * PrototypeSet to double.\r\n     */\r\n    \r\n    public double[][] prototypeSetTodouble(){\r\n    \tdouble datos[][] = new double[this.size()][];\r\n    \t\r\n    \t //System.out.println(\"Size prototype = \" + this.size());\r\n    \tfor(int i=0; i\u003c this.size();i++){\r\n    \t\t//System.out.println(\"\\n\");\r\n    \t\tdatos[i] = new double[this.get(0).numberOfInputs()];\r\n    \t\t\r\n    \t\tdatos[i] = ((Prototype)this.get(i)).getInputs();  //.denormalize()\r\n\r\n    \t\t/*\r\n    \t\tfor(int j=0; j\u003c datos[i].length; j++){\r\n    \t\t\tSystem.out.print(datos[i][j]+\", \");\r\n    \t\t}\r\n    \t\tSystem.out.println(\"\");\r\n    \t\t*/\r\n    \t}\r\n    \t\r\n    \treturn datos;\r\n    \t\r\n    \t   \t\r\n    }\r\n    \r\n    \r\n    \r\n   \r\n   \r\n    public int[] prototypeSetClasses(){\r\n    \tint datos[] = new int[this.size()];\r\n    \t\r\n    \t\r\n    \t //System.out.println(\"Size prototype = \" + this.size());\r\n    \tfor(int i=0; i\u003c this.size();i++){\r\n    \t\t\r\n    \t\tdatos[i] = (int) this.get(i).getOutput(0);\r\n    \t\t//System.out.println(datos[i]);\r\n    \t\t\r\n    \t}\r\n    \t\r\n    \treturn datos;\r\n    \t\r\n    \t   \t\r\n    }\r\n    \r\n    \r\n    /**\r\n     * \r\n     * PrototypeSet to double.\r\n     */\r\n    \r\n    public void doubleToprototypeSet(double datos[][], int clase){\r\n    \tint j;\r\n    \t\r\n    \t //System.out.println(\"Datos leng = \" + datos.length);\r\n    \t  new PrototypeSet();\r\n    \t \r\n    \tfor(int i=0; i\u003c datos.length;i++){\r\n    \t\t\r\n    \t\tif(!Double.isNaN(datos[i][0])){\r\n\t    \t\tPrototype o = new Prototype(datos[i].length,1);\r\n\t    \t\t\r\n\t    \t\tfor(j= 0; j\u003c datos[i].length; j++){\r\n\t    \t\t\t\r\n\t    \t\t\to.setInput(j, datos[i][j]);\r\n\t    \t\t\t\r\n\t    \t\t}\r\n\t    \t\to.setFirstOutput(clase);\r\n\t    \t\t\r\n\t    \t\tthis.add(o);\r\n    \t\t}\r\n\r\n    \t}\r\n    \t\r\n\t\r\n    \t   \t\r\n    }\r\n    \r\n\r\n    /**********************************************\r\n     * \r\n     * FUNCIONES PARA DIFFERENTIAL EVOLUTION.\r\n     * ********************************************\r\n     */\r\n    \r\n    \r\n    /**\r\n     * SUMAR dos conjuntos de prototipos , uno a uno. De la misma dimension.\r\n     */\r\n \r\n   public PrototypeSet sumar(PrototypeSet other){\r\n   \tPrototypeSet suma = new PrototypeSet();\r\n \r\n   \tif (this.size() == other.size()){\r\n\t    \tfor(int i= 0; i\u003c this.size(); i++){\r\n\t    \t\tsuma.add(this.get(i).add(other.get(i)));\t    \t\t\r\n\t    \t}\r\n   \t}else{\r\n   \t\treturn null;\r\n   \t}   \t\r\n   \t\r\n   \treturn suma;\r\n   }\r\n   \r\n   \r\n     /**\r\n      * Restar dos conjuntos de prototipos , uno a uno. De la misma dimension.\r\n      */\r\n  \r\n    public PrototypeSet restar(PrototypeSet other){\r\n    \tPrototypeSet resta = new PrototypeSet();\r\n  \r\n    \tif (this.size() == other.size()){\r\n\t    \tfor(int i= 0; i\u003c this.size(); i++){\r\n\t    \t\tresta.add(this.get(i).sub(other.get(i)));\t    \t\t\r\n\t    \t}\r\n    \t}else{\r\n    \t\treturn null;\r\n    \t}   \t\r\n    \t\r\n    \treturn resta;\r\n    }\r\n\r\n    /**\r\n     * Multiplicar un conjunto por un Escalar.\r\n     */\r\n \r\n   public PrototypeSet mulEscalar(double escalar){\r\n   \tPrototypeSet result = new PrototypeSet();\r\n \r\n   \tfor(int i= 0; i\u003c this.size(); i++){\r\n    \t\tresult.add(this.get(i).mul(escalar));\t    \t\t\r\n   \t}\r\n   \t\r\n   \treturn result;\r\n   }\r\n\r\n   /**\r\n    * Calculaa el opuesto de un conjunto .\r\n    * @return\r\n    */\r\n   \r\n   public PrototypeSet opposite(){\r\n\t   \r\n\t   PrototypeSet opuesto = new PrototypeSet();\r\n\t   \r\n\t   for(int i=0; i\u003cthis.size(); i++){\r\n\t\t   opuesto.add(this.get(i).opposite());\r\n\t\t   \r\n\t   }\r\n\t   return opuesto;\r\n   }\r\n   \r\n   /**\r\n    * Transform the prototypeSet (this) in a matrix of binary string 8-bit codification.\r\n    * \r\n    */\r\n   public String [][] toBinaryString (){\r\n   \tString datos[][] = new String[this.size()][];\r\n\tdouble number ;\r\n\tInteger num;\r\n\tString aux;\r\n\tdouble parametroConversion = 1./255; // Como vamos a pasar a 8 bits.. 2 ^8 = 256, y representamos num en [0,1]\r\n\t\r\n\t //System.out.println(\"Size prototype = \" + this.size());\r\n\tfor(int i=0; i\u003c this.size();i++){\r\n\t\t//System.out.println(\"\\n\");\r\n\t\tdatos[i] = new String[this.get(0).numberOfInputs()];\r\n\t\t\r\n\t\tfor(int j=0; j\u003c((Prototype)this.get(i)).numberOfInputs(); j++ ){\r\n\t\t\tnumber = ((Prototype)this.get(i)).getInput(j);\r\n\t\t\t\r\n\t\t\tif(number \u003c 0) number = 0;\r\n\t\t\telse if(number \u003e 1) number = 1;\r\n\t\t\tnum = (int) (number/parametroConversion); // Nos quedamos con la parte entera de la conversion\r\n\t\t\t\r\n\t\t\taux = Integer.toBinaryString(num);\r\n\t\t\t//Tendremos que anadir ceros al a derecha...si es menor que 0.\r\n\t\t\twhile(aux.length()\u003c8){\r\n\t\t\t\taux = \"0\"+aux;\r\n\t\t\t}\r\n\t\t\tdatos[i][j] = new String();\r\n\t\t\tdatos[i][j] = aux;\r\n\t\t\t//System.out.println(\"num = \"+ num + \"number = \"+ number + \" and the binary = \"+ aux);\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\treturn datos;\r\n   }\r\n    \r\n   \r\n   \r\n   /**\r\n    * Transform the prototypeSet (this) in a matrix of binary string Gray Code\r\n    * \r\n    */\r\n   public String [][] to8GrayString (){\r\n   \tString datos[][] = new String[this.size()][];\r\n\tdouble number ;\r\n\tInteger num;\r\n\tString aux;\r\n\tdouble parametroConversion = 1./255; // Como vamos a pasar a 8 bits.. 2 ^8 = 256, y representamos num en [0,1]\r\n\t\r\n\t //System.out.println(\"Size prototype = \" + this.size());\r\n\tfor(int i=0; i\u003c this.size();i++){\r\n\t\t//System.out.println(\"\\n\");\r\n\t\tdatos[i] = new String[this.get(0).numberOfInputs()];\r\n\t\t\r\n\t\tfor(int j=0; j\u003c((Prototype)this.get(i)).numberOfInputs(); j++ ){\r\n\t\t\tnumber = ((Prototype)this.get(i)).getInput(j);\r\n\t\t\t\r\n\t\t\tif(number \u003c 0) number = 0;\r\n\t\t\telse if(number \u003e 1) number = 1;\r\n\t\t\tnum = (int) (number/parametroConversion); // Nos quedamos con la parte entera de la conversion\r\n\t\t\t\r\n\t\t\taux = Integer.toBinaryString(num);\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t//Tendremos que anadir ceros al a derecha...si es menor que 0.\r\n\t\t\twhile(aux.length()\u003c8){\r\n\t\t\t\taux = \"0\"+aux;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t//System.out.println(\"Binario = \" + aux);\r\n\t\t\t\r\n\t\t\t// Ahora tengo que pasar de binario a Gray Code\r\n            /* We start at the highest available array element and\r\n             * proceed to 1.\r\n             * If the next (read from right to left) digit is 1, then\r\n             * the actual digit is set to 1 minus its own value.\r\n             * Otherwise nothing has to be done.\r\n             * The last (in array #1) digit will remain untouched.\r\n             */\r\n\t\t\tString gray [] = aux.split(\"\");\r\n\t\t\tfor(int m= (gray.length-1); m\u003e1; m--){\r\n\t\t\t\tif(Integer.parseInt(gray[m-1])== 1){\r\n\t\t\t\t\tgray[m] = Integer.toString(1 - Integer.parseInt(gray[m]));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\taux = \"\";\r\n\t\t\t\r\n\t\t\tfor(int m=0;m\u003c gray.length; m++){\r\n\t\t\t\taux+= gray[m];\r\n\t\t\t}\r\n\t\t\t\r\n\r\n\t\t\tdatos[i][j] = new String();\r\n\t\t\tdatos[i][j] = aux;\r\n\t\t\t//System.out.println(\"num = \"+ num + \"number = \"+ number + \" and the binary  Gray= \"+ aux);\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\treturn datos;\r\n   }\r\n   \r\n    \r\n   /**\r\n    * Transform  a matrix of binary string 8-bit codification in a double PrototypeSEt\r\n    * \r\n    */\r\n   public void toPrototypeSet (String datos[][], double clases[]){\r\n\t   int num;\r\n\t   double valor;\r\n\t   double parametroConversion = 1./255; \r\n\t   new PrototypeSet(datos.length);\r\n\t   \r\n\t   \r\n\t   \r\n\t   for(int i=0; i\u003c datos.length;i++){\r\n\t\t   Prototype aux = new Prototype(datos[0].length,1);\r\n\t\t   \r\n\t\t   for(int j=0; j\u003c datos[i].length; j++){\r\n\t\t\t   num =0;\r\n\t\t\t   String aux2 = \"\"; //datos[i][j];\r\n\t\t\t   \r\n\t\t\t   // Transformacion Gray to binary..\r\n\t\t\t   aux2 += datos[i][j].charAt(0); // El mas a la izquierda es igual\r\n\t\t\t   char uno, dos;\r\n\t\t\t   \r\n\t\t\t   for(int k=1; k\u003c 8;k++){\r\n\t\t\t\t   uno = aux2.charAt(k-1); // El primero de Binary con el 2 de Gray\r\n\t\t\t\t   dos = datos[i][j].charAt(k);\r\n\t\t\t\t   \r\n\t\t\t\t   if(uno == '0' \u0026\u0026 dos == '0')\r\n\t\t\t\t\t   aux2 += \"0\";\r\n\t\t\t\t   else if( uno =='1' \u0026\u0026 dos == '1'){\r\n\t\t\t\t\t   aux2 += \"0\";\r\n\t\t\t\t   }else{\r\n\t\t\t\t\t   aux2 += \"1\";\r\n\t\t\t\t   }\r\n\t\t\t\t\r\n\t\t\t   }\r\n\t\t\t   \r\n\t\t\t  // System.out.println(\"Gray = \" + datos[i][j] +  \" toBinary-\u003e \"+ aux2);\r\n\t\t\t   for(int k=0; k\u003c 8; k++){\r\n\t\t\t\t  int bit= Character.getNumericValue(aux2.charAt(k));\r\n\t\t\t\t  //System.out.println(\"Bit =\" + bit);\r\n\t\t\t\t  num +=  Math.pow(2, 7-k)*bit; \r\n\t\t\t\t  //System.out.println(\"num =\" + num);\r\n\t\t\t   }\r\n\t\t\t  \t\t\t \r\n\t\t\t   valor = num * parametroConversion ;\r\n\t\t\t   //System.out.println(\"datos String \" + datos[i][j] + \"num = \" + num + \" valor = \"+ valor);\r\n\t\t\t   aux.setInput(j, valor);\r\n\t\t\t   \r\n\t\t   }\r\n\t\t   this.add(aux);\r\n\t\t   \r\n\t\t   this.get(i).setFirstOutput(clases[i]);\r\n\t   }\r\n   }\r\n   \r\n   \r\n   \r\n   public void formatear(PrototypeSet initial){\r\n\t   new PrototypeSet();\r\n\t   \r\n\t   for(int i=0; i\u003c initial.size(); i++){\r\n\t\t  // initial.get(i).print();\r\n\t\t   //initial.get(i).formatear().print();\r\n\t\tthis.add(initial.get(i).formatear());  \r\n\t   }\r\n   }\r\n   \r\n   \r\n   /**\r\n    * It return the prototypeset with the features specified in lista.\r\n    * @param lista\r\n    * @return\r\n    */\r\n   public PrototypeSet getFeatures(ArrayList\u003cInteger\u003e lista){\r\n\t   PrototypeSet nuevo = new PrototypeSet();\r\n\t   \r\n\t   for(int i=0; i\u003cthis.size(); i++){\r\n\t\t   nuevo.add(this.get(i).getPrototypeWithSelectedInputs(lista));\r\n\t   }\r\n\t   \r\n\t   return nuevo;\r\n   }\r\n   \r\n   \r\n   /**\r\n    * Sorted a ArrayList of Integers\r\n    * @param numbers\r\n    * @return\r\n    */\r\n   public ArrayList\u003cInteger\u003e quicksort(ArrayList\u003cInteger\u003e numbers) {\r\n       if (numbers.size() \u003c= 1)\r\n           return numbers;\r\n       int pivot = numbers.size() / 2;\r\n       ArrayList\u003cInteger\u003e lesser = new ArrayList\u003cInteger\u003e();\r\n       ArrayList\u003cInteger\u003e greater = new ArrayList\u003cInteger\u003e();\r\n       int sameAsPivot = 0;\r\n       for (int number : numbers) {\r\n           if (number \u003e numbers.get(pivot))\r\n               greater.add(number);\r\n           else if (number \u003c numbers.get(pivot))\r\n               lesser.add(number);\r\n           else\r\n               sameAsPivot++;\r\n       }\r\n       lesser = quicksort(lesser);\r\n       for (int i = 0; i \u003c sameAsPivot; i++)\r\n           lesser.add(numbers.get(pivot));\r\n       greater = quicksort(greater);\r\n       ArrayList\u003cInteger\u003e sorted = new ArrayList\u003cInteger\u003e();\r\n       for (int number : lesser)\r\n           sorted.add(number);\r\n       for (int number: greater)\r\n           sorted.add(number);\r\n       return sorted;\r\n   }\r\n\r\n   \r\n   public ArrayList\u003cInteger\u003e getFeatures1(){\r\n\t   return this.FeaturesSet1;\r\n   }\r\n   \r\n   public ArrayList\u003cInteger\u003e getFeatures2(){\r\n\t   return this.FeaturesSet2;\r\n   }\r\n   /**\r\n    * This method divides the PrototypeSet into two different prototypesets where the original attributes sets are randomly partititoned, with similar sizes.\r\n    * @return\r\n    */\r\n   public Pair\u003cPrototypeSet,PrototypeSet\u003e divideFeaturesRandomly(){\r\n\t   \r\n       PrototypeSet first = new PrototypeSet();\r\n       PrototypeSet second = new PrototypeSet();\r\n\t   \r\n       ArrayList\u003cInteger\u003e indexes =  RandomGenerator.generateDifferentRandomIntegers(0, this.get(0).numberOfInputs()-1);\r\n\r\n       \r\n       \r\n       // If the number of inputs is not par, We choose randomly in which prototype will be include this feature.\r\n    \t   \r\n    \t   int limit=this.get(0).numberOfInputs()/2; //+1;\r\n    \t\t    \r\n    \t   if(this.get(0).numberOfInputs()%2!=0 \u0026\u0026 Randomize.Randdouble(0, 1)\u003c0.5){\r\n    \t\t   limit++;\r\n    \t\t  // System.out.println(\"Entro\");\r\n    \t   }\r\n    \t\r\n       \t   this.FeaturesSet1 = new ArrayList\u003cInteger\u003e(limit);\r\n    \t   this.FeaturesSet2 = new ArrayList\u003cInteger\u003e(indexes.size()-limit);\r\n \r\n    \t  // System.out.println(\"El limite es: \"+limit);\r\n    \t   \r\n    \t   ArrayList\u003cInteger\u003e primeros = new ArrayList\u003cInteger\u003e(limit);\r\n    \t   \r\n\t       for(int i=0; i\u003climit; i++){\r\n\t    \t  primeros.add(i, indexes.get(i));\r\n\t       }\r\n\t       \r\n\t       primeros =new ArrayList\u003cInteger\u003e(this.quicksort(primeros)); // Los ordeno, para evitar problemas con instance set.\r\n\t       \r\n\t       for(int i=0; i\u003climit; i++){\r\n\t\t    \t  this.FeaturesSet1.add(i,primeros.get(i));\r\n\t\t    }\r\n\t\t       \r\n\t       \r\n\t       first = new PrototypeSet(this.getFeatures(primeros).clone());\r\n\t       \r\n\t       ArrayList\u003cInteger\u003e segundos = new ArrayList\u003cInteger\u003e(indexes.size()-limit);\r\n\t       \r\n\t       for(int i=0; i\u003cindexes.size()-limit; i++){\r\n\t    \t   segundos.add(i, indexes.get(limit+i));\r\n\t       }\r\n\t   \r\n\t       segundos =new ArrayList\u003cInteger\u003e(this.quicksort(segundos));\r\n\t       \r\n\t       for(int i=0; i\u003cindexes.size()-limit; i++){\r\n\t    \t \t  this.FeaturesSet2.add(i,segundos.get(i));\r\n\t       }\r\n\t       \r\n\t       \r\n\t       second = new PrototypeSet(this.getFeatures(segundos).clone());\r\n       \r\n\t   return new Pair\u003cPrototypeSet, PrototypeSet\u003e(first,second);\r\n\t   \t   \r\n   }\r\n   \r\n   \r\n   \r\n   /**\r\n    * This method divides the datasets into X subspaces of dimension ''dimension''.\r\n    * @param subspaces\r\n    * @param dimension should be the half of the number of features!\r\n    * @return\r\n    */\r\n \r\n   public PrototypeSet[] divideFeaturesRandomly(int subspaces, int dimension, int [][] indices){\r\n\t   \r\n       PrototypeSet [] divididos = new PrototypeSet[subspaces];\r\n       \r\n\t   \r\n       for(int i=0; i\u003c subspaces; i++){ // For each subspace:\r\n    \t   \r\n    \t   ArrayList\u003cInteger\u003e indexes =  RandomGenerator.generateDifferentRandomIntegers(0, this.get(0).numberOfInputs()-1); \r\n    \t   \r\n    \t   ArrayList\u003cInteger\u003e lista = new ArrayList\u003cInteger\u003e(indexes.subList(0, dimension));\r\n    \t   \r\n    \t   lista =new ArrayList\u003cInteger\u003e(this.quicksort(lista));\r\n    \t   \r\n    \t   \r\n    \t   for(int j=0; j\u003clista.size();j++){\r\n    \t\t   indices[i][j] = (int) lista.get(j);\r\n    \t   }\r\n    \t   \r\n    \t   divididos[i] = new PrototypeSet();\r\n    \t   \r\n    \t   for(int j=0; j\u003cthis.size(); j++){\r\n    \t\t   divididos[i].add(this.get(j).getPrototypeWithSelectedInputs(lista));\r\n    \t   }\r\n    \t   \r\n    \t   \r\n    \t   indexes = null;\r\n    \t   lista = null;\r\n    \t   System.gc();\r\n    \t   \r\n       }\r\n\r\n       divididos[0].get(0).print();\r\n       \r\n\t   return divididos;\r\n\t   \t   \r\n   }\r\n   \r\n   \r\n   /**\r\n    * This method divides the features based on the indexes parameters\r\n    * @param indices\r\n    * @return\r\n    */\r\n   public PrototypeSet[] divideFeaturesRandomly( int [][] indices){\r\n\t   int subspaces = indices.length;\r\n\t   int dimension = indices[0].length;\r\n\t   \r\n       PrototypeSet [] divididos = new PrototypeSet[subspaces];\r\n       \r\n       \r\n\t   \r\n       for(int i=0; i\u003c subspaces; i++){ // For each subspace:\r\n    \t   \r\n\t   \r\n    \t   ArrayList\u003cInteger\u003e lista = new ArrayList\u003cInteger\u003e(dimension);\r\n    \t   \r\n    \t   for(int j=0; j\u003cdimension; j++){\r\n    \t\t   lista.add(indices[i][j]);\r\n    \t   }\r\n    \t   \r\n    \t   lista =new ArrayList\u003cInteger\u003e(this.quicksort(lista));\r\n    \t   \r\n    \t   for(int j=0; j\u003clista.size();j++){ // reorder again\r\n    \t\t   indices[i][j] = (int) lista.get(j);\r\n    \t   }\r\n    \t   \r\n    \t   divididos[i] = new PrototypeSet();\r\n    \t   \r\n    \t   for(int j=0; j\u003cthis.size(); j++){\r\n    \t\t   divididos[i].add(this.get(j).getPrototypeWithSelectedInputs(lista));\r\n    \t   }\r\n    \t   \r\n    \t   \r\n    \t   \r\n    \t   \r\n       }\r\n\r\n       divididos[0].get(0).print();\r\n       \r\n\t   return divididos;\r\n\t   \t   \r\n   }\r\n\r\n   \r\n   \r\n   /**\r\n    * Return a prototype set by Bootstrapping the current PrototypeSet\r\n    * Creates a new dataset of the same size using random sampling\r\n   * with replacement according to the given weight vector. The\r\n   * weights of the instances in the new dataset are set to one.\r\n    */\r\n   \r\n   public PrototypeSet resample(){\r\n\t   PrototypeSet boostrapped = new PrototypeSet();\r\n\t   \r\n\t   \r\n\t    double [] weights = new double[this.size()];\r\n\t    Arrays.fill(weights,1);\r\n\t    \r\n\t    double[] probabilities = new double[this.size()];\r\n\t    double sumProbs = 0, sumOfWeights=0;\r\n\t    \r\n\t    for(int i=0; i\u003cweights.length;i++){\r\n\t    \tsumOfWeights+=weights[i];\r\n\t    }\r\n\t    \r\n\t    for (int i = 0; i \u003c this.size(); i++) {\r\n\t      sumProbs += Randomize.Rand();\r\n\t      probabilities[i] = sumProbs;\r\n\t    }\r\n\t    \r\n\t    for (int i = 0; i \u003c probabilities.length; i++) {\r\n\t    \tprobabilities[i] /= (sumProbs / sumOfWeights);\r\n\t    }\r\n\t   \r\n\t // Make sure that rounding errors don't mess things up\r\n\t    probabilities[this.size() - 1] = sumOfWeights;\r\n\t    int k = 0; int l = 0;\r\n\t    sumProbs = 0;\r\n\t    while ((k \u003c this.size() \u0026\u0026 (l \u003c this.size()))) {\r\n\t      if (weights[l] \u003c 0) {\r\n\t    \t  throw new IllegalArgumentException(\"Weights have to be positive.\");\r\n\t      }\r\n\t      sumProbs += weights[l];\r\n\t      while ((k \u003c this.size()) \u0026\u0026(probabilities[k] \u003c= sumProbs)) { \r\n\t    \t  boostrapped.add(this.get(l));\r\n\t    \t  k++;\r\n\t      }\r\n\t      l++;\r\n\t    } \r\n\t    \r\n\t   \r\n\t   return boostrapped;\r\n\t   \r\n   }\r\n   \r\n   \r\n   public double sumOfWeights(){\r\n\t   double sum=0;\r\n\t   for (int i=0; i\u003cthis.size(); i++){\r\n\t\t   sum+= this.get(i).getWeight();\r\n\t   }\r\n\t   return sum;\r\n   }\r\n   \r\n   \r\n   \r\n   \r\n   /**\r\n    * Help function needed for stratification of set.\r\n    *\r\n    * @param numFolds the number of folds for the stratification\r\n    */\r\n   protected void stratStep (int numFolds){\r\n     \r\n     PrototypeSet newVec = new PrototypeSet();\r\n     int start = 0, j;\r\n\r\n     // create stratified batch\r\n     while (newVec.size() \u003c this.size()) {\r\n       j = start;\r\n       while (j \u003c this.size()) {\r\n \t     newVec.add(this.get(j));\r\n \t     j = j + numFolds;\r\n       }\r\n       start++;\r\n     }\r\n     \r\n     new PrototypeSet(newVec.clone());\r\n   }\r\n   \r\n   /**\r\n    * Stratifies a set of instances according to its class values \r\n    * if the class attribute is nominal (so that afterwards a \r\n    * stratified cross-validation can be performed).\r\n    *\r\n    * @param numFolds the number of folds in the cross-validation\r\n    */\r\n   \r\n   public void stratify(int numFolds) {\r\n\t    \r\n       Attribute[] a = Attributes.getOutputAttributes();\r\n       //System.out.println(\"a \" + a[0]);        \r\n       \r\n\t if (a[0].getType() == Attribute.NOMINAL) {\r\n\r\n\t      // sort by class\r\n\t      int index = 1;\r\n\t  while (index \u003c size()) {\r\n\t\tPrototype instance1 = this.get(index - 1);\r\n\t\tfor (int j = index; j \u003c this.size(); j++) {\r\n\t\t  Prototype instance2 = this.get(j);\r\n\t\t  if ((instance1.getOutput(0) == instance2.getOutput(0)) ) { //||     (instance1.classIsMissing() \u0026\u0026 \t       instance2.classIsMissing())\r\n\t\t    swap(index,j);\r\n\t\t    index++;\r\n\t\t  }\r\n\t\t}\r\n\t\tindex++;\r\n\t      }\r\n\t      stratStep(numFolds);\r\n\t    }\r\n  }\r\n   \r\n   \r\n   /**\r\n    * Creates the training set for one fold of a cross-validation \r\n    * on the dataset. \r\n    *\r\n    * @param numFolds the number of folds in the cross-validation. Must\r\n    * be greater than 1.\r\n    * @param numFold 0 for the first fold, 1 for the second, ...\r\n    * @return the training set \r\n    */\r\n   //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\r\n   //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\r\n   public PrototypeSet trainCV(int numFolds, int numFold) {\r\n\r\n     int numInstForFold, first, offset;\r\n     PrototypeSet train;\r\n  \r\n\r\n     numInstForFold = size() / numFolds;\r\n     if (numFold \u003c size() % numFolds) {\r\n       numInstForFold++;\r\n       offset = numFold;\r\n     }else\r\n       offset = size() % numFolds;\r\n     train = new PrototypeSet(); //this, numInstances() - numInstForFold);\r\n     first = numFold * (size() / numFolds) + offset;\r\n     //copyInstances(0, train, first);\r\n     for(int i=0; i\u003cfirst; i++){\r\n    \t train.add(this.get(i));\r\n     }\r\n     \r\n     //copyInstances(first + numInstForFold, train,  size() - first - numInstForFold);\r\n     for(int i=first + numInstForFold; i\u003c (size() - first - numInstForFold); i++){\r\n    \t train.add(this.get(i));\r\n     }\r\n     \r\n\r\n     train.randomize();\r\n     return train;\r\n   }\r\n   \r\n   \r\n   \r\n   \r\n   /**\r\n    * Creates the test set for one fold of a cross-validation on \r\n    * the dataset.\r\n    *\r\n    * @param numFolds the number of folds in the cross-validation. Must\r\n    * be greater than 1.\r\n    * @param numFold 0 for the first fold, 1 for the second, ...\r\n    * @return the test set as a set of weighted instances\r\n\r\n    */\r\n   //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\r\n   //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\r\n   public  PrototypeSet testCV(int numFolds, int numFold) {\r\n\r\n     int numInstForFold, first, offset;\r\n     PrototypeSet test;\r\n     \r\n\r\n     numInstForFold = size() / numFolds;\r\n     if (numFold \u003c size() % numFolds){\r\n       numInstForFold++;\r\n       offset = numFold;\r\n     }else\r\n       offset = size() % numFolds;\r\n     test = new PrototypeSet(); //Instances(this, numInstForFold);\r\n     first = numFold * (size() / numFolds) + offset;\r\n     \r\n     //copyInstances(first, test, numInstForFold);\r\n     for(int i=first; i\u003cnumInstForFold; i++){\r\n    \t test.add(this.get(i));\r\n     }\r\n\r\n     return test;\r\n   }\r\n   \r\n   \r\n   /**\r\n    * Sorts the instances based on an attribute. For numeric attributes, \r\n    * instances are sorted in ascending order. For nominal attributes, \r\n    * instances are sorted based on the attribute label ordering \r\n    * specified in the header. Instances with missing values for the \r\n    * attribute are placed at the end of the dataset.\r\n    *\r\n    * @param attIndex the attribute's index (index starts with 0)\r\n    */\r\n   public void sort(int attIndex) {\r\n\r\n     int i,j;\r\n\r\n     // move all instances with missing values to end\r\n     j = size() - 1;\r\n     i = 0;\r\n   \r\n     /*while (i \u003c= j) {\r\n       if (get(j).isMissing(attIndex)) {\r\n \tj--;\r\n       } else {\r\n \tif (instance(i).isMissing(attIndex)) {\r\n \t  swap(i,j);\r\n \t  j--;\r\n \t}\r\n \ti++;\r\n       }\r\n     }*/\r\n     \r\n     quickSort(attIndex, 0, j);\r\n   }\r\n   \r\n   \r\n   /**\r\n    * Partitions the instances around a pivot. Used by quicksort and\r\n    * kthSmallestValue.\r\n    *\r\n    * @param attIndex the attribute's index (index starts with 0)\r\n    * @param l the first index of the subset (index starts with 0)\r\n    * @param r the last index of the subset (index starts with 0)\r\n    *\r\n    * @return the index of the middle element\r\n    */\r\n   //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\r\n   //@ requires 0 \u003c= left \u0026\u0026 left \u003c= right \u0026\u0026 right \u003c numInstances();\r\n   protected int partition(int attIndex, int l, int r) {\r\n     \r\n     double pivot = get((l + r) / 2).getInput(attIndex);\r\n\r\n     while (l \u003c r) {\r\n       while ((get(l).getInput(attIndex) \u003c pivot) \u0026\u0026 (l \u003c r)) {\r\n         l++;\r\n       }\r\n       while ((get(r).getInput(attIndex) \u003e pivot) \u0026\u0026 (l \u003c r)) {\r\n         r--;\r\n       }\r\n       if (l \u003c r) {\r\n         swap(l, r);\r\n         l++;\r\n         r--;\r\n       }\r\n     }\r\n     if ((l == r) \u0026\u0026 (get(r).getInput(attIndex) \u003e pivot)) {\r\n       r--;\r\n     } \r\n\r\n     return r;\r\n   }\r\n   \r\n   \r\n   /**\r\n    * Implements quicksort according to Manber's \"Introduction to\r\n    * Algorithms\".\r\n    *\r\n    * @param attIndex the attribute's index (index starts with 0)\r\n    * @param left the first index of the subset to be sorted (index starts with 0)\r\n    * @param right the last index of the subset to be sorted (index starts with 0)\r\n    */\r\n   //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\r\n   //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c numInstances();\r\n   protected void quickSort(int attIndex, int left, int right) {\r\n\r\n     if (left \u003c right) {\r\n       int middle = partition(attIndex, left, right);\r\n       quickSort(attIndex, left, middle);\r\n       quickSort(attIndex, middle + 1, right);\r\n     }\r\n   }\r\n   \r\n   \r\n}\r\n",
        "name": "PrototypeSet.java",
        "path": "src/keel/Algorithms/Semi_Supervised_Learning/Basic/PrototypeSet.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/Semi_Supervised_Learning/Basic/PrototypeSet.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 2550,
          "offsetAndLengths": [
            [
              3,
              13
            ]
          ],
          "preview": "   //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2551,
          "offsetAndLengths": [
            [
              3,
              13
            ]
          ],
          "preview": "   //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2594,
          "offsetAndLengths": [
            [
              3,
              13
            ]
          ],
          "preview": "   //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2595,
          "offsetAndLengths": [
            [
              3,
              13
            ]
          ],
          "preview": "   //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2663,
          "offsetAndLengths": [
            [
              3,
              13
            ]
          ],
          "preview": "   //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2664,
          "offsetAndLengths": [
            [
              3,
              13
            ]
          ],
          "preview": "   //@ requires 0 \u003c= left \u0026\u0026 left \u003c= right \u0026\u0026 right \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2698,
          "offsetAndLengths": [
            [
              3,
              13
            ]
          ],
          "preview": "   //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2699,
          "offsetAndLengths": [
            [
              3,
              13
            ]
          ],
          "preview": "   //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c numInstances();\r"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "/***********************************************************************\n\n\tThis file is part of KEEL-software, the Data Mining tool for regression, \n\tclassification, clustering, pattern mining and so on.\n\n\tCopyright (C) 2004-2010\n\n\tF. Herrera (herrera@decsai.ugr.es)\n    L. Sánchez (luciano@uniovi.es)\n    J. Alcalá-Fdez (jalcala@decsai.ugr.es)\n    S. García (sglopez@ujaen.es)\n    A. Fernández (alberto.fernandez@ujaen.es)\n    J. Luengo (julianlm@decsai.ugr.es)\n\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see http://www.gnu.org/licenses/\n\n **********************************************************************/\n\n/*\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; either version 2 of the License, or\n *    (at your option) any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n/*\n *    Utils.java\n *    Copyright (C) 1999-2004 University of Waikato, Hamilton, New Zealand\n *\n */\n\npackage keel.Algorithms.Semi_Supervised_Learning.ADE_CoForest;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.lang.reflect.Array;\nimport java.net.URL;\nimport java.util.Enumeration;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Vector;\n\n/**\n * Class implementing some simple utility methods.\n *\n * @author Eibe Frank \n * @author Yong Wang \n * @author Len Trigg \n * @author Julien Prados\n * @version $Revision: 6959 $\n */\npublic final class Utils{\n\n  /** The natural logarithm of 2. */\n  public static double log2 = Math.log(2);\n\n  /** The small deviation allowed in double comparisons. */\n  public static double SMALL = 1e-6;\n  \n  /**\n   * Tests if the given value codes \"missing\".\n   *\n   * @param val the value to be tested\n   * @return true if val codes \"missing\"\n   */\n  public static boolean isMissingValue(double val) {\n\n    return Double.isNaN(val);\n  }\n\n  /**\n   * Returns the value used to code a missing value.  Note that\n   * equality tests on this value will always return false, so use\n   * isMissingValue(double val) for testing..\n   *\n   * @return the value used as missing value.\n   */\n  public static double missingValue() {\n    \n    return Double.NaN;\n  }\n\n  /**\n   * Casting an object without \"unchecked\" compile-time warnings.\n   * Use only when absolutely necessary (e.g. when using clone()).\n     * @param \u003cT\u003e type of the object to cast.\n     * @param x object to be casted.\n     * @return object casted.\n   */\n  @SuppressWarnings(\"unchecked\")\n    public static \u003cT\u003e T cast(Object x) {\n    return (T) x;\n  }\n  \n  /**\n   * Reads properties that inherit from three locations. Properties\n   * are first defined in the system resource location (i.e. in the\n   * CLASSPATH).  These default properties must exist. Properties optionally\n   * defined in the user properties location (WekaPackageManager.PROPERTIES_DIR) \n   * override default settings. Properties defined in the current directory (optional)\n   * override all these settings.\n   *\n   * @param resourceName the location of the resource that should be\n   * loaded.  e.g.: \"weka/core/Utils.props\". (The use of hardcoded\n   * forward slashes here is OK - see\n   * jdk1.1/docs/guide/misc/resources.html) This routine will also\n   * look for the file (in this case) \"Utils.props\" in the users home\n   * directory and the current directory.\n   * @return the Properties\n   * @exception Exception if no default properties are defined, or if\n   * an error occurs reading the properties files.  \n   \n  public static Properties readProperties(String resourceName)\n    throws Exception {\n\n    Properties defaultProps = new Properties();\n    try {\n      // Apparently hardcoded slashes are OK here\n      // jdk1.1/docs/guide/misc/resources.html\n      Utils utils = new Utils();\n      Enumeration\u003cURL\u003e urls = utils.getClass().getClassLoader().getResources(resourceName);\n      boolean first = true;\n      while (urls.hasMoreElements()) {\n\tURL url = urls.nextElement();\n\tif (first) {\n\t  defaultProps.load(url.openStream());\n\t  first = false;\n\t}\n\telse {\n\t  Properties props = new Properties(defaultProps);\n\t  props.load(url.openStream());\n\t  defaultProps = props;\n\t}\n      }\n    } catch (Exception ex) {\n      System.err.println(\"Warning, unable to load properties file(s) from \"\n\t\t\t +\"system resource (Utils.java): \" + resourceName);\n    }\n\n    // Hardcoded slash is OK here\n    // eg: see jdk1.1/docs/guide/misc/resources.html\n    int slInd = resourceName.lastIndexOf('/');\n    if (slInd != -1) {\n      resourceName = resourceName.substring(slInd + 1);\n    }\n\n    // Allow a properties file in the WekaPackageManager.PROPERTIES_DIR to override\n    Properties userProps = new Properties(defaultProps);\n    if (!WekaPackageManager.PROPERTIES_DIR.exists()) {\n      WekaPackageManager.PROPERTIES_DIR.mkdir();\n    }\n    //File propFile = new File(WekaPackageManager.PROPERTIES_DIR.toString()\n      //                       + File.separator\n        //                     + resourceName);\n\n    if (propFile.exists()) {\n      try {\n        userProps.load(new FileInputStream(propFile));\n      } catch (Exception ex) {\n        throw new Exception(\"Problem reading user properties: \" + propFile);\n      }\n    }\n\n    // Allow a properties file in the current directory to override\n    Properties localProps = new Properties(userProps);\n    propFile = new File(resourceName);\n    if (propFile.exists()) {\n      try {\n        localProps.load(new FileInputStream(propFile));\n      } catch (Exception ex) {\n        throw new Exception(\"Problem reading local properties: \" + propFile);\n      }\n    }\n    \n    return localProps;\n  }\n*/\n  /**\n   * Returns the correlation coefficient of two double vectors.\n   *\n   * @param y1 double vector 1\n   * @param y2 double vector 2\n   * @param n the length of two double vectors\n   * @return the correlation coefficient\n   */\n  public static final double correlation(double y1[],double y2[],int n) {\n\n    int i;\n    double av1 = 0.0, av2 = 0.0, y11 = 0.0, y22 = 0.0, y12 = 0.0, c;\n    \n    if (n \u003c= 1) {\n      return 1.0;\n    }\n    for (i = 0; i \u003c n; i++) {\n      av1 += y1[i];\n      av2 += y2[i];\n    }\n    av1 /= (double) n;\n    av2 /= (double) n;\n    for (i = 0; i \u003c n; i++) {\n      y11 += (y1[i] - av1) * (y1[i] - av1);\n      y22 += (y2[i] - av2) * (y2[i] - av2);\n      y12 += (y1[i] - av1) * (y2[i] - av2);\n    }\n    if (y11 * y22 == 0.0) {\n      c=1.0;\n    } else {\n      c = y12 / Math.sqrt(Math.abs(y11 * y22));\n    }\n    \n    return c;\n  }\n\n  /**\n   * Removes all occurrences of a string from another string.\n   *\n   * @param inString the string to remove substrings from.\n   * @param substring the substring to remove.\n   * @return the input string with occurrences of substring removed.\n   */\n  public static String removeSubstring(String inString, String substring) {\n\n    StringBuffer result = new StringBuffer();\n    int oldLoc = 0, loc = 0;\n    while ((loc = inString.indexOf(substring, oldLoc))!= -1) {\n      result.append(inString.substring(oldLoc, loc));\n      oldLoc = loc + substring.length();\n    }\n    result.append(inString.substring(oldLoc));\n    return result.toString();\n  }\n\n  /**\n   * Replaces with a new string, all occurrences of a string from \n   * another string.\n   *\n   * @param inString the string to replace substrings in.\n   * @param subString the substring to replace.\n   * @param replaceString the replacement substring\n   * @return the input string with occurrences of substring replaced.\n   */\n  public static String replaceSubstring(String inString, String subString,\n\t\t\t\t\tString replaceString) {\n\n    StringBuffer result = new StringBuffer();\n    int oldLoc = 0, loc = 0;\n    while ((loc = inString.indexOf(subString, oldLoc))!= -1) {\n      result.append(inString.substring(oldLoc, loc));\n      result.append(replaceString);\n      oldLoc = loc + subString.length();\n    }\n    result.append(inString.substring(oldLoc));\n    return result.toString();\n  }\n\n\n  /**\n   * Pads a string to a specified length, inserting spaces on the left\n   * as required. If the string is too long, characters are removed (from\n   * the right).\n   *\n   * @param inString the input string\n   * @param length the desired length of the output string\n   * @return the output string\n   */\n  public static String padLeft(String inString, int length) {\n\n    return fixStringLength(inString, length, false);\n  }\n  \n  /**\n   * Pads a string to a specified length, inserting spaces on the right\n   * as required. If the string is too long, characters are removed (from\n   * the right).\n   *\n   * @param inString the input string\n   * @param length the desired length of the output string\n   * @return the output string\n   */\n  public static String padRight(String inString, int length) {\n\n    return fixStringLength(inString, length, true);\n  }\n  \n  /**\n   * Pads a string to a specified length, inserting spaces as\n   * required. If the string is too long, characters are removed (from\n   * the right).\n   *\n   * @param inString the input string\n   * @param length the desired length of the output string\n   * @param right true if inserted spaces should be added to the right\n   * @return the output string\n   */\n  private static /*@pure@*/ String fixStringLength(String inString, int length,\n\t\t\t\t\tboolean right) {\n\n    if (inString.length() \u003c length) {\n      while (inString.length() \u003c length) {\n\tinString = (right ? inString.concat(\" \") : \" \".concat(inString));\n      }\n    } else if (inString.length() \u003e length) {\n      inString = inString.substring(0, length);\n    }\n    return inString;\n  }\n \n  /**\n   * Rounds a double and converts it into String.\n   *\n   * @param value the double value\n   * @param afterDecimalPoint the (maximum) number of digits permitted\n   * after the decimal point\n   * @return the double as a formatted string\n   */\n  public static /*@pure@*/ String doubleToString(double value, int afterDecimalPoint) {\n    \n    StringBuffer stringBuffer;\n    double temp;\n    int dotPosition;\n    long precisionValue;\n    \n    temp = value * Math.pow(10.0, afterDecimalPoint);\n    if (Math.abs(temp) \u003c Long.MAX_VALUE) {\n      precisionValue = \t(temp \u003e 0) ? (long)(temp + 0.5) \n                                   : -(long)(Math.abs(temp) + 0.5);\n      if (precisionValue == 0) {\n\tstringBuffer = new StringBuffer(String.valueOf(0));\n      } else {\n\tstringBuffer = new StringBuffer(String.valueOf(precisionValue));\n      }\n      if (afterDecimalPoint == 0) {\n\treturn stringBuffer.toString();\n      }\n      dotPosition = stringBuffer.length() - afterDecimalPoint;\n      while (((precisionValue \u003c 0) \u0026\u0026 (dotPosition \u003c 1)) ||\n\t     (dotPosition \u003c 0)) {\n\tif (precisionValue \u003c 0) {\n\t  stringBuffer.insert(1, '0');\n\t} else {\n\t  stringBuffer.insert(0, '0');\n\t}\n\tdotPosition++;\n      }\n      stringBuffer.insert(dotPosition, '.');\n      if ((precisionValue \u003c 0) \u0026\u0026 (stringBuffer.charAt(1) == '.')) {\n\tstringBuffer.insert(1, '0');\n      } else if (stringBuffer.charAt(0) == '.') {\n\tstringBuffer.insert(0, '0');\n      }\n      int currentPos = stringBuffer.length() - 1;\n      while ((currentPos \u003e dotPosition) \u0026\u0026\n\t     (stringBuffer.charAt(currentPos) == '0')) {\n\tstringBuffer.setCharAt(currentPos--, ' ');\n      }\n      if (stringBuffer.charAt(currentPos) == '.') {\n\tstringBuffer.setCharAt(currentPos, ' ');\n      }\n      \n      return stringBuffer.toString().trim();\n    }\n    return new String(\"\" + value);\n  }\n\n  /**\n   * Rounds a double and converts it into a formatted decimal-justified String.\n   * Trailing 0's are replaced with spaces.\n   *\n   * @param value the double value\n   * @param width the width of the string\n   * @param afterDecimalPoint the number of digits after the decimal point\n   * @return the double as a formatted string\n   */\n  public static /*@pure@*/ String doubleToString(double value, int width,\n\t\t\t\t      int afterDecimalPoint) {\n    \n    String tempString = doubleToString(value, afterDecimalPoint);\n    char[] result;\n    int dotPosition;\n\n    if ((afterDecimalPoint \u003e= width) \n        || (tempString.indexOf('E') != -1)) { // Protects sci notation\n      return tempString;\n    }\n\n    // Initialize result\n    result = new char[width];\n    for (int i = 0; i \u003c result.length; i++) {\n      result[i] = ' ';\n    }\n\n    if (afterDecimalPoint \u003e 0) {\n      // Get position of decimal point and insert decimal point\n      dotPosition = tempString.indexOf('.');\n      if (dotPosition == -1) {\n\tdotPosition = tempString.length();\n      } else {\n\tresult[width - afterDecimalPoint - 1] = '.';\n      }\n    } else {\n      dotPosition = tempString.length();\n    }\n    \n\n    int offset = width - afterDecimalPoint - dotPosition;\n    if (afterDecimalPoint \u003e 0) {\n      offset--;\n    }\n\n    // Not enough room to decimal align within the supplied width\n    if (offset \u003c 0) {\n      return tempString;\n    }\n\n    // Copy characters before decimal point\n    for (int i = 0; i \u003c dotPosition; i++) {\n      result[offset + i] = tempString.charAt(i);\n    }\n\n    // Copy characters after decimal point\n    for (int i = dotPosition + 1; i \u003c tempString.length(); i++) {\n      result[offset + i] = tempString.charAt(i);\n    }\n\n    return new String(result);\n  }\n\n  /**\n   * Returns the basic class of an array class (handles multi-dimensional\n   * arrays).\n   * @param c        the array to inspect\n   * @return         the class of the innermost elements\n   */\n  public static Class getArrayClass(Class c) {\n     if (c.getComponentType().isArray())\n        return getArrayClass(c.getComponentType());\n     else\n        return c.getComponentType();\n  }\n\n  /**\n   * Returns the dimensions of the given array. Even though the\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\n   * int[3] or double[2][4].\n   *\n   * @param array       the array to determine the dimensions for\n   * @return            the dimensions of the array\n   */\n  public static int getArrayDimensions(Class array) {\n    if (array.getComponentType().isArray())\n      return 1 + getArrayDimensions(array.getComponentType());\n    else\n      return 1;\n  }\n\n  /**\n   * Returns the dimensions of the given array. Even though the\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\n   * int[3] or double[2][4].\n   *\n   * @param array       the array to determine the dimensions for\n   * @return            the dimensions of the array\n   */\n  public static int getArrayDimensions(Object array) {\n    return getArrayDimensions(array.getClass());\n  }\n\n  /**\n   * Returns the given Array in a string representation. Even though the\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\n   * int[3] or double[2][4].\n   * \n   * @param array       the array to return in a string representation\n   * @return            the array as string\n   */\n  public static String arrayToString(Object array) {\n    String        result;\n    int           dimensions;\n    int           i;       \n\n    result     = \"\";\n    dimensions = getArrayDimensions(array);\n    \n    if (dimensions == 0) {\n      result = \"null\";\n    }\n    else if (dimensions == 1) {\n      for (i = 0; i \u003c Array.getLength(array); i++) {\n        if (i \u003e 0)\n          result += \",\";\n        if (Array.get(array, i) == null)\n          result += \"null\";\n        else\n          result += Array.get(array, i).toString();\n      }\n    }\n    else {\n      for (i = 0; i \u003c Array.getLength(array); i++) {\n        if (i \u003e 0)\n          result += \",\";\n        result += \"[\" + arrayToString(Array.get(array, i)) + \"]\";\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * Tests if a is equal to b.\n   *\n   * @param a a double\n   * @param b a double\n     * @return true  if a is equal to b.\n   */\n  public static /*@pure@*/ boolean eq(double a, double b){\n    \n    return (a - b \u003c SMALL) \u0026\u0026 (b - a \u003c SMALL); \n  }\n\n  /**\n   * Checks if the given array contains any non-empty options.\n   *\n   * @param options an array of strings\n   * @exception Exception if there are any non-empty options\n   */\n  public static void checkForRemainingOptions(String[] options) \n    throws Exception {\n    \n    int illegalOptionsFound = 0;\n    StringBuffer text = new StringBuffer();\n\n    if (options == null) {\n      return;\n    }\n    for (int i = 0; i \u003c options.length; i++) {\n      if (options[i].length() \u003e 0) {\n\tillegalOptionsFound++;\n\ttext.append(options[i] + ' ');\n      }\n    }\n    if (illegalOptionsFound \u003e 0) {\n      throw new Exception(\"Illegal options: \" + text);\n    }\n  }\n  \n  /**\n   * Checks if the given array contains the flag \"-Char\". Stops\n   * searching at the first marker \"--\". If the flag is found,\n   * it is replaced with the empty string.\n   *\n   * @param flag the character indicating the flag.\n   * @param options the array of strings containing all the options.\n   * @return true if the flag was found\n   * @exception Exception if an illegal option was found\n   */\n  public static boolean getFlag(char flag, String[] options) \n    throws Exception {\n    \n    return getFlag(\"\" + flag, options);\n  }\n  \n  /**\n   * Checks if the given array contains the flag \"-String\". Stops\n   * searching at the first marker \"--\". If the flag is found,\n   * it is replaced with the empty string.\n   *\n   * @param flag the String indicating the flag.\n   * @param options the array of strings containing all the options.\n   * @return true if the flag was found\n   * @exception Exception if an illegal option was found\n   */\n  public static boolean getFlag(String flag, String[] options) \n    throws Exception {\n    \n    int pos = getOptionPos(flag, options);\n\n    if (pos \u003e -1)\n      options[pos] = \"\";\n    \n    return (pos \u003e -1);\n  }\n\n  /**\n   * Gets an option indicated by a flag \"-Char\" from the given array\n   * of strings. Stops searching at the first marker \"--\". Replaces \n   * flag and option with empty strings.\n   *\n   * @param flag the character indicating the option.\n   * @param options the array of strings containing all the options.\n   * @return the indicated option or an empty string\n   * @exception Exception if the option indicated by the flag can't be found\n   */\n  public static /*@non_null@*/ String getOption(char flag, String[] options) \n    throws Exception {\n    \n    return getOption(\"\" + flag, options);\n  }\n\n  /**\n   * Gets an option indicated by a flag \"-String\" from the given array\n   * of strings. Stops searching at the first marker \"--\". Replaces \n   * flag and option with empty strings.\n   *\n   * @param flag the String indicating the option.\n   * @param options the array of strings containing all the options.\n   * @return the indicated option or an empty string\n   * @exception Exception if the option indicated by the flag can't be found\n   */\n  public static /*@non_null@*/ String getOption(String flag, String[] options) \n    throws Exception {\n\n    String newString;\n    int i = getOptionPos(flag, options);\n\n    if (i \u003e -1) {\n      if (options[i].equals(\"-\" + flag)) {\n\tif (i + 1 == options.length) {\n\t  throw new Exception(\"No value given for -\" + flag + \" option.\");\n\t}\n\toptions[i] = \"\";\n\tnewString = new String(options[i + 1]);\n\toptions[i + 1] = \"\";\n\treturn newString;\n      }\n      if (options[i].charAt(1) == '-') {\n\treturn \"\";\n      }\n    }\n    \n    return \"\";\n  }\n\n  /**\n   * Gets the index of an option or flag indicated by a flag \"-Char\" from \n   * the given array of strings. Stops searching at the first marker \"--\".\n   *\n   * @param flag \tthe character indicating the option.\n   * @param options \tthe array of strings containing all the options.\n   * @return \t\tthe position if found, or -1 otherwise\n   */\n  public static int getOptionPos(char flag, String[] options) {\n     return getOptionPos(\"\" + flag, options);\n  }\n\n  /**\n   * Gets the index of an option or flag indicated by a flag \"-String\" from \n   * the given array of strings. Stops searching at the first marker \"--\".\n   *\n   * @param flag \tthe String indicating the option.\n   * @param options \tthe array of strings containing all the options.\n   * @return \t\tthe position if found, or -1 otherwise\n   */\n  public static int getOptionPos(String flag, String[] options) {\n    if (options == null)\n      return -1;\n    \n    for (int i = 0; i \u003c options.length; i++) {\n      if ((options[i].length() \u003e 0) \u0026\u0026 (options[i].charAt(0) == '-')) {\n\t// Check if it is a negative number\n\ttry {\n\t  Double.valueOf(options[i]);\n\t} \n\tcatch (NumberFormatException e) {\n\t  // found?\n\t  if (options[i].equals(\"-\" + flag))\n\t    return i;\n\t  // did we reach \"--\"?\n\t  if (options[i].charAt(1) == '-')\n\t    return -1;\n\t}\n      }\n    }\n    \n    return -1;\n  }\n\n  /**\n   * Quotes a string if it contains special characters.\n   * \n   * The following rules are applied:\n   *\n   * A character is backquoted version of it is one \n   * of \u003ctt\u003e\" ' % \\ \\n \\r \\t\u003c/tt\u003e.\n   *\n   * A string is enclosed within single quotes if a character has been\n   * backquoted using the previous rule above or contains \n   * \u003ctt\u003e{ }\u003c/tt\u003e or is exactly equal to the strings \n   * \u003ctt\u003e, ? space or \"\"\u003c/tt\u003e (empty string).\n   *\n   * A quoted question mark distinguishes it from the missing value which\n   * is represented as an unquoted question mark in arff files.\n   *\n   * @param string \tthe string to be quoted\n   * @return \t\tthe string (possibly quoted)\n   * @see\t\t#unquote(String)\n   */\n  public static /*@pure@*/ String quote(String string) {\n      boolean quote = false;\n\n      // backquote the following characters \n      if ((string.indexOf('\\n') != -1) || (string.indexOf('\\r') != -1) || \n\t  (string.indexOf('\\'') != -1) || (string.indexOf('\"') != -1) || \n\t  (string.indexOf('\\\\') != -1) || \n\t  (string.indexOf('\\t') != -1) || (string.indexOf('%') != -1)) {\n\t  string = backQuoteChars(string);\n\t  quote = true;\n      }\n\n      // Enclose the string in 's if the string contains a recently added\n      // backquote or contains one of the following characters.\n      if((quote == true) || \n\t (string.indexOf('{') != -1) || (string.indexOf('}') != -1) ||\n\t (string.indexOf(',') != -1) || (string.equals(\"?\")) ||\n\t (string.indexOf(' ') != -1) || (string.equals(\"\"))) {\n\t  string = (\"'\".concat(string)).concat(\"'\");\n      }\n\n      return string;\n  }\n\n  /**\n   * unquotes are previously quoted string (but only if necessary), i.e., it\n   * removes the single quotes around it. Inverse to quote(String).\n   * \n   * @param string\tthe string to process\n   * @return\t\tthe unquoted string\n   * @see\t\t#quote(String)\n   */\n  public static String unquote(String string) {\n    if (string.startsWith(\"'\") \u0026\u0026 string.endsWith(\"'\")) {\n      string = string.substring(1, string.length() - 1);\n      \n      if ((string.indexOf(\"\\\\n\") != -1) || (string.indexOf(\"\\\\r\") != -1) || \n\t  (string.indexOf(\"\\\\'\") != -1) || (string.indexOf(\"\\\\\\\"\") != -1) || \n\t  (string.indexOf(\"\\\\\\\\\") != -1) || \n\t  (string.indexOf(\"\\\\t\") != -1) || (string.indexOf(\"\\\\%\") != -1)) {\n\tstring = unbackQuoteChars(string);\n      }\n    }\n\n    return string;\n  }\n\n  /**\n   * Converts carriage returns and new lines in a string into \\r and \\n.\n   * Backquotes the following characters: ` \" \\ \\t and %\n   * \n   * @param string \tthe string\n   * @return \t\tthe converted string\n   * @see\t\t#unbackQuoteChars(String)\n   */\n  public static /*@pure@*/ String backQuoteChars(String string) {\n\n    int index;\n    StringBuffer newStringBuffer;\n\n    // replace each of the following characters with the backquoted version\n    char   charsFind[] =    {'\\\\',   '\\'',  '\\t',  '\\n',  '\\r',  '\"',    '%'};\n    String charsReplace[] = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\n\", \"\\\\r\", \"\\\\\\\"\", \"\\\\%\"};\n    for (int i = 0; i \u003c charsFind.length; i++) {\n      if (string.indexOf(charsFind[i]) != -1 ) {\n\tnewStringBuffer = new StringBuffer();\n\twhile ((index = string.indexOf(charsFind[i])) != -1) {\n\t  if (index \u003e 0) {\n\t    newStringBuffer.append(string.substring(0, index));\n\t  }\n\t  newStringBuffer.append(charsReplace[i]);\n\t  if ((index + 1) \u003c string.length()) {\n\t    string = string.substring(index + 1);\n\t  } else {\n\t    string = \"\";\n\t  }\n\t}\n\tnewStringBuffer.append(string);\n\tstring = newStringBuffer.toString();\n      }\n    }\n\n    return string;\n  }\n\n  /**\n   * Converts carriage returns and new lines in a string into \\r and \\n.\n   *\n   * @param string the string\n   * @return the converted string\n   */\n  public static String convertNewLines(String string) {\n    int index;\n\n    // Replace with \\n\n    StringBuffer newStringBuffer = new StringBuffer();\n    while ((index = string.indexOf('\\n')) != -1) {\n      if (index \u003e 0) {\n\tnewStringBuffer.append(string.substring(0, index));\n      }\n      newStringBuffer.append('\\\\');\n      newStringBuffer.append('n');\n      if ((index + 1) \u003c string.length()) {\n\tstring = string.substring(index + 1);\n      } else {\n\tstring = \"\";\n      }\n    }\n    newStringBuffer.append(string);\n    string = newStringBuffer.toString();\n\n    // Replace with \\r\n    newStringBuffer = new StringBuffer();\n    while ((index = string.indexOf('\\r')) != -1) {\n      if (index \u003e 0) {\n\tnewStringBuffer.append(string.substring(0, index));\n      }\n      newStringBuffer.append('\\\\');\n      newStringBuffer.append('r');\n      if ((index + 1) \u003c string.length()){\n\tstring = string.substring(index + 1);\n      } else {\n\tstring = \"\";\n      }\n    }\n    newStringBuffer.append(string);\n    return newStringBuffer.toString();\n  }\n\n  /**\n   * Reverts \\r and \\n in a string into carriage returns and new lines.\n   * \n   * @param string the string\n   * @return the converted string\n   */\n  public static String revertNewLines(String string) {\n    int index;\n\n    // Replace with \\n\n    StringBuffer newStringBuffer = new StringBuffer();\n    while ((index = string.indexOf(\"\\\\n\")) != -1) {\n      if (index \u003e 0) {\n\tnewStringBuffer.append(string.substring(0, index));\n      }\n      newStringBuffer.append('\\n');\n      if ((index + 2) \u003c string.length()) {\n\tstring = string.substring(index + 2);\n      } else {\n\tstring = \"\";\n      }\n    }\n    newStringBuffer.append(string);\n    string = newStringBuffer.toString();\n\n    // Replace with \\r\n    newStringBuffer = new StringBuffer();\n    while ((index = string.indexOf(\"\\\\r\")) != -1) {\n      if (index \u003e 0) {\n\tnewStringBuffer.append(string.substring(0, index));\n      }\n      newStringBuffer.append('\\r');\n      if ((index + 2) \u003c string.length()){\n\tstring = string.substring(index + 2);\n      } else {\n\tstring = \"\";\n      }\n    }\n    newStringBuffer.append(string);\n    \n    return newStringBuffer.toString();\n  }\n\n  /**\n   * Returns the secondary set of options (if any) contained in\n   * the supplied options array. The secondary set is defined to\n   * be any options after the first \"--\". These options are removed from\n   * the original options array.\n   *\n   * @param options the input array of options\n   * @return the array of secondary options\n   */\n  public static String[] partitionOptions(String[] options) {\n\n    for (int i = 0; i \u003c options.length; i++) {\n      if (options[i].equals(\"--\")) {\n\toptions[i++] = \"\";\n\tString[] result = new String [options.length - i];\n\tfor (int j = i; j \u003c options.length; j++) {\n\t  result[j - i] = options[j];\n\t  options[j] = \"\";\n\t}\n\treturn result;\n      }\n    }\n    return new String [0];\n  }\n    \n  /**\n   * The inverse operation of backQuoteChars().\n   * Converts back-quoted carriage returns and new lines in a string \n   * to the corresponding character ('\\r' and '\\n').\n   * Also \"un\"-back-quotes the following characters: ` \" \\ \\t and %\n   *\n   * @param string \tthe string\n   * @return \t\tthe converted string\n   * @see\t\t#backQuoteChars(String)\n   */\n  public static String unbackQuoteChars(String string) {\n\n    int index;\n    StringBuffer newStringBuffer;\n    \n    // replace each of the following characters with the backquoted version\n    String charsFind[]    = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\n\", \"\\\\r\", \"\\\\\\\"\", \"\\\\%\"};\n    char   charsReplace[] = {'\\\\',   '\\'',  '\\t',  '\\n',  '\\r',  '\"',    '%'};\n    int pos[] = new int[charsFind.length];\n    int\tcurPos;\n    \n    String str = new String(string);\n    newStringBuffer = new StringBuffer();\n    while (str.length() \u003e 0) {\n      // get positions and closest character to replace\n      curPos = str.length();\n      index  = -1;\n      for (int i = 0; i \u003c pos.length; i++) {\n\tpos[i] = str.indexOf(charsFind[i]);\n\tif ( (pos[i] \u003e -1) \u0026\u0026 (pos[i] \u003c curPos) ) {\n\t  index  = i;\n\t  curPos = pos[i];\n\t}\n      }\n      \n      // replace character if found, otherwise finished\n      if (index == -1) {\n\tnewStringBuffer.append(str);\n\tstr = \"\";\n      }\n      else {\n\tnewStringBuffer.append(str.substring(0, pos[index]));\n\tnewStringBuffer.append(charsReplace[index]);\n\tstr = str.substring(pos[index] + charsFind[index].length());\n      }\n    }\n\n    return newStringBuffer.toString();\n  }    \n  \n  /**\n   * Split up a string containing options into an array of strings,\n   * one for each option.\n   *\n   * @param \t\tquotedOptionString the string containing the options\n   * @return \t\tthe array of options\n   * @throws Exception \tin case of an unterminated string, unknown character or\n   * \t\t\ta parse error\n   */\n  public static String[] splitOptions(String quotedOptionString) throws Exception{\n\n    Vector\u003cString\u003e optionsVec = new Vector\u003cString\u003e();\n    String str = new String(quotedOptionString);\n    int i;\n    \n    while (true){\n\n      //trimLeft \n      i = 0;\n      while ((i \u003c str.length()) \u0026\u0026 (Character.isWhitespace(str.charAt(i)))) i++;\n      str = str.substring(i);\n      \n      //stop when str is empty\n      if (str.length() == 0) break;\n      \n      //if str start with a double quote\n      if (str.charAt(0) == '\"'){\n\t\n\t//find the first not anti-slached double quote\n\ti = 1;\n\twhile(i \u003c str.length()){\n\t  if (str.charAt(i) == str.charAt(0)) break;\n\t  if (str.charAt(i) == '\\\\'){\n\t    i += 1;\n\t    if (i \u003e= str.length()) \n\t      throw new Exception(\"String should not finish with \\\\\");\n\t  }\n\t  i += 1;\n\t}\n\tif (i \u003e= str.length()) throw new Exception(\"Quote parse error.\");\n\t\n\t//add the founded string to the option vector (without quotes)\n\tString optStr = str.substring(1,i);\n\toptStr = unbackQuoteChars(optStr);\n\toptionsVec.addElement(optStr);\n\tstr = str.substring(i+1);\n      } else {\n\t//find first whiteSpace\n\ti=0;\n\twhile((i \u003c str.length()) \u0026\u0026 (!Character.isWhitespace(str.charAt(i)))) i++;\n\t\n\t//add the founded string to the option vector\n\tString optStr = str.substring(0,i);\n\toptionsVec.addElement(optStr);\n\tstr = str.substring(i);\n      }\n    }\n    \n    //convert optionsVec to an array of String\n    String[] options = new String[optionsVec.size()];\n    for (i = 0; i \u003c optionsVec.size(); i++) {\n      options[i] = (String)optionsVec.elementAt(i);\n    }\n    return options;\n  }    \n\n  /**\n   * Joins all the options in an option array into a single string,\n   * as might be used on the command line.\n   *\n   * @param optionArray the array of options\n   * @return the string containing all options.\n   */\n  public static String joinOptions(String[] optionArray) {\n\n    String optionString = \"\";\n    for (int i = 0; i \u003c optionArray.length; i++) {\n      if (optionArray[i].equals(\"\")) {\n\tcontinue;\n      }\n      boolean escape = false;\n      for (int n = 0; n \u003c optionArray[i].length(); n++) {\n\tif (Character.isWhitespace(optionArray[i].charAt(n))) {\n\t  escape = true;\n\t  break;\n\t}\n      }\n      if (escape) {\n\toptionString += '\"' + backQuoteChars(optionArray[i]) + '\"';\n      } else {\n\toptionString += optionArray[i];\n      }\n      optionString += \" \";\n    }\n    return optionString.trim();\n  }\n  \n  /**\n   * Creates a new instance of an object given it's class name and\n   * (optional) arguments to pass to it's setOptions method. If the\n   * object implements OptionHandler and the options parameter is\n   * non-null, the object will have it's options set. Example use:\u003cp\u003e\n   *\n   * \u003ccode\u003e \u003cpre\u003e\n   * String classifierName = Utils.getOption('W', options);\n   * Classifier c = (Classifier)Utils.forName(Classifier.class,\n   *                                          classifierName,\n   *                                          options);\n   * setClassifier(c);\n   * \u003c/pre\u003e\u003c/code\u003e\n   *\n   * @param classType the class that the instantiated object should\n   * be assignable to -- an exception is thrown if this is not the case\n   * @param className the fully qualified class name of the object\n   * @param options an array of options suitable for passing to setOptions. May\n   * be null. Any options accepted by the object will be removed from the\n   * array.\n   * @return the newly created object, ready for use.\n   * @exception Exception if the class name is invalid, or if the\n   * class is not assignable to the desired class type, or the options\n   * supplied are not acceptable to the object\n  \n  public static Object forName(Class\u003c?\u003e classType,\n\t\t\t       String className,\n\t\t\t       String[] options) throws Exception {\n\n    Class\u003c?\u003e c = null;\n    try {\n      c = Class.forName(className);\n    } catch (Exception ex) {\n      throw new Exception(\"Can't find class called: \" + className);\n    }\n    if (!classType.isAssignableFrom(c)) {\n      throw new Exception(classType.getName() + \" is not assignable from \"\n\t\t\t  + className);\n    }\n    Object o = c.newInstance();\n    if ((o instanceof OptionHandler)\n\t\u0026\u0026 (options != null)) {\n      ((OptionHandler)o).setOptions(options);\n      Utils.checkForRemainingOptions(options);\n    }\n    return o;\n  }\n */\n  /**\n   * Generates a commandline of the given object. If the object is not \n   * implementing OptionHandler, then it will only return the classname,\n   * otherwise also the options.\n   * \n   * @param obj\t\tthe object to turn into a commandline\n   * @return\t\tthe commandline\n  \n  public static String toCommandLine(Object obj) {\n    StringBuffer\tresult;\n    \n    result = new StringBuffer();\n    \n    if (obj != null) {\n      result.append(obj.getClass().getName());\n      if (obj instanceof OptionHandler)\n\tresult.append(\" \" + joinOptions(((OptionHandler) obj).getOptions()));\n    }\n    \n    return result.toString().trim();\n  }\n   */\n  /**\n   * Computes entropy for an array of integers.\n   *\n   * @param counts array of counts\n   * @return - a log2 a - b log2 b - c log2 c + (a+b+c) log2 (a+b+c)\n   * when given array [a b c]\n   */\n  public static /*@pure@*/ double info(int counts[]) {\n    \n    int total = 0;\n    double x = 0;\n    for (int j = 0; j \u003c counts.length; j++) {\n      x -= xlogx(counts[j]);\n      total += counts[j];\n    }\n    return x + xlogx(total);\n  }\n\n  /**\n   * Tests if a is smaller or equal to b.\n   *\n   * @param a a double\n   * @param b a double\n     * @return true  if a is smaller or equal to b.\n   */\n  public static /*@pure@*/ boolean smOrEq(double a,double b) {\n    \n    return (a-b \u003c SMALL);\n  }\n\n  /**\n   * Tests if a is greater or equal to b.\n   *\n   * @param a a double\n   * @param b a double\n     * @return true  if a is greater or equal to b.\n   */\n  public static /*@pure@*/ boolean grOrEq(double a,double b) {\n    \n    return (b-a \u003c SMALL);\n  }\n  \n  /**\n   * Tests if a is smaller than b.\n   *\n   * @param a a double\n   * @param b a double\n     * @return true  if a is smaller than b.\n   */\n  public static /*@pure@*/ boolean sm(double a,double b) {\n    \n    return (b-a \u003e SMALL);\n  }\n\n  /**\n   * Tests if a is greater than b.\n   *\n   * @param a a double\n   * @param b a double \n     * @return true  if a is greater than b.\n   */\n  public static /*@pure@*/ boolean gr(double a,double b) {\n    \n    return (a-b \u003e SMALL);\n  }\n\n  /**\n   * Returns the kth-smallest value in the array.\n   *\n   * @param array the array of integers\n   * @param k the value of k\n   * @return the kth-smallest value\n   */\n  public static double kthSmallestValue(int[] array, int k) {\n\n    int[] index = new int[array.length];\n    \n    for (int i = 0; i \u003c index.length; i++) {\n      index[i] = i;\n    }\n\n    return array[index[select(array, index, 0, array.length - 1, k)]];\n  }\n\n  /**\n   * Returns the kth-smallest value in the array\n   *\n   * @param array the array of double\n   * @param k the value of k\n   * @return the kth-smallest value\n   */\n  public static double kthSmallestValue(double[] array, int k) {\n\n    int[] index = new int[array.length];\n    \n    for (int i = 0; i \u003c index.length; i++) {\n      index[i] = i;\n    }\n\n    return array[index[select(array, index, 0, array.length - 1, k)]];\n  }\n\n  /**\n   * Returns the logarithm of a for base 2.\n   *\n   * @param a \ta double\n   * @return\tthe logarithm for base 2\n   */\n  public static /*@pure@*/ double log2(double a) {\n    \n    return Math.log(a) / log2;\n  }\n\n  /**\n   * Returns index of maximum element in a given\n   * array of doubles. First maximum is returned.\n   *\n   * @param doubles the array of doubles\n   * @return the index of the maximum element\n   */\n  public static /*@pure@*/ int maxIndex(double[] doubles) {\n\n    double maximum = 0;\n    int maxIndex = 0;\n\n    for (int i = 0; i \u003c doubles.length; i++) {\n      if ((i == 0) || (doubles[i] \u003e maximum)) {\n\tmaxIndex = i;\n\tmaximum = doubles[i];\n      }\n    }\n\n    return maxIndex;\n  }\n\n  /**\n   * Returns index of maximum element in a given\n   * array of integers. First maximum is returned.\n   *\n   * @param ints the array of integers\n   * @return the index of the maximum element\n   */\n  public static /*@pure@*/ int maxIndex(int[] ints) {\n\n    int maximum = 0;\n    int maxIndex = 0;\n\n    for (int i = 0; i \u003c ints.length; i++) {\n      if ((i == 0) || (ints[i] \u003e maximum)) {\n\tmaxIndex = i;\n\tmaximum = ints[i];\n      }\n    }\n\n    return maxIndex;\n  }\n\n  /**\n   * Computes the mean for an array of doubles.\n   *\n   * @param vector the array\n   * @return the mean\n   */\n  public static /*@pure@*/ double mean(double[] vector) {\n  \n    double sum = 0;\n\n    if (vector.length == 0) {\n      return 0;\n    }\n    for (int i = 0; i \u003c vector.length; i++) {\n      sum += vector[i];\n    }\n    return sum / (double) vector.length;\n  }\n\n  /**\n   * Returns index of minimum element in a given\n   * array of integers. First minimum is returned.\n   *\n   * @param ints the array of integers\n   * @return the index of the minimum element\n   */\n  public static /*@pure@*/ int minIndex(int[] ints) {\n\n    int minimum = 0;\n    int minIndex = 0;\n\n    for (int i = 0; i \u003c ints.length; i++) {\n      if ((i == 0) || (ints[i] \u003c minimum)) {\n\tminIndex = i;\n\tminimum = ints[i];\n      }\n    }\n\n    return minIndex;\n  }\n\n  /**\n   * Returns index of minimum element in a given\n   * array of doubles. First minimum is returned.\n   *\n   * @param doubles the array of doubles\n   * @return the index of the minimum element\n   */\n  public static /*@pure@*/ int minIndex(double[] doubles) {\n\n    double minimum = 0;\n    int minIndex = 0;\n\n    for (int i = 0; i \u003c doubles.length; i++) {\n      if ((i == 0) || (doubles[i] \u003c minimum)) {\n\tminIndex = i;\n\tminimum = doubles[i];\n      }\n    }\n\n    return minIndex;\n  }\n\n  /**\n   * Normalizes the doubles in the array by their sum.\n   *\n   * @param doubles the array of double\n   * @exception IllegalArgumentException if sum is Zero or NaN\n   */\n  public static void normalize(double[] doubles) {\n\n    double sum = 0;\n    for (int i = 0; i \u003c doubles.length; i++) {\n      sum += doubles[i];\n    }\n    normalize(doubles, sum);\n  }\n\n  /**\n   * Normalizes the doubles in the array using the given value.\n   *\n   * @param doubles the array of double\n   * @param sum the value by which the doubles are to be normalized\n   * @exception IllegalArgumentException if sum is zero or NaN\n   */\n  public static void normalize(double[] doubles, double sum) {\n\n    if (Double.isNaN(sum)) {\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is NaN.\");\n    }\n    if (sum == 0) {\n      // Maybe this should just be a return.\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is zero.\");\n    }\n    for (int i = 0; i \u003c doubles.length; i++) {\n      doubles[i] /= sum;\n    }\n  }\n\n  /**\n   * Converts an array containing the natural logarithms of\n   * probabilities stored in a vector back into probabilities.\n   * The probabilities are assumed to sum to one.\n   *\n   * @param a an array holding the natural logarithms of the probabilities\n   * @return the converted array \n   */\n  public static double[] logs2probs(double[] a) {\n\n    double max = a[maxIndex(a)];\n    double sum = 0.0;\n\n    double[] result = new double[a.length];\n    for(int i = 0; i \u003c a.length; i++) {\n      result[i] = Math.exp(a[i] - max);\n      sum += result[i];\n    }\n\n    normalize(result, sum);\n\n    return result;\n  } \n\n  /**\n   * Returns the log-odds for a given probabilitiy.\n   *\n   * @param prob the probabilitiy\n   *\n   * @return the log-odds after the probability has been mapped to\n   * [Utils.SMALL, 1-Utils.SMALL]\n   */\n  public static /*@pure@*/ double probToLogOdds(double prob) {\n\n    if (gr(prob, 1) || (sm(prob, 0))) {\n      throw new IllegalArgumentException(\"probToLogOdds: probability must \" +\n\t\t\t\t     \"be in [0,1] \"+prob);\n    }\n    double p = SMALL + (1.0 - 2 * SMALL) * prob;\n    return Math.log(p / (1 - p));\n  }\n\n  /**\n   * Rounds a double to the next nearest integer value. The JDK version\n   * of it doesn't work properly.\n   *\n   * @param value the double value\n   * @return the resulting integer value\n   */\n  public static /*@pure@*/ int round(double value) {\n\n    int roundedValue = value \u003e 0\n      ? (int)(value + 0.5)\n      : -(int)(Math.abs(value) + 0.5);\n    \n    return roundedValue;\n  }\n\n  /**\n   * Rounds a double to the next nearest integer value in a probabilistic\n   * fashion (e.g. 0.8 has a 20% chance of being rounded down to 0 and a\n   * 80% chance of being rounded up to 1). In the limit, the average of\n   * the rounded numbers generated by this procedure should converge to\n   * the original double.\n   *\n   * @param value the double value\n   * @param rand the random number generator\n   * @return the resulting integer value\n   */\n  public static int probRound(double value, Random rand) {\n\n    if (value \u003e= 0) {\n      double lower = Math.floor(value);\n      double prob = value - lower;\n      if (rand.nextDouble() \u003c prob) {\n\treturn (int)lower + 1;\n      } else {\n\treturn (int)lower;\n      }\n    } else {\n      double lower = Math.floor(Math.abs(value));\n      double prob = Math.abs(value) - lower;\n      if (rand.nextDouble() \u003c prob) {\n\treturn -((int)lower + 1);\n      } else {\n\treturn -(int)lower;\n      }\n    }\n  }\n\n  /**\n   * Rounds a double to the given number of decimal places.\n   *\n   * @param value the double value\n   * @param afterDecimalPoint the number of digits after the decimal point\n   * @return the double rounded to the given precision\n   */\n  public static /*@pure@*/ double roundDouble(double value,int afterDecimalPoint) {\n\n    double mask = Math.pow(10.0, (double)afterDecimalPoint);\n\n    return (double)(Math.round(value * mask)) / mask;\n  }\n\n  /**\n   * Sorts a given array of integers in ascending order and returns an \n   * array of integers with the positions of the elements of the original \n   * array in the sorted array. The sort is stable. (Equal elements remain\n   * in their original order.)\n   *\n   * @param array this array is not changed by the method!\n   * @return an array of integers with the positions in the sorted\n   * array.\n   */\n  public static /*@pure@*/ int[] sort(int[] array) {\n\n    int[] index = new int[array.length];\n    int[] newIndex = new int[array.length];\n    int[] helpIndex;\n    int numEqual;\n    \n    for (int i = 0; i \u003c index.length; i++) {\n      index[i] = i;\n    }\n    quickSort(array, index, 0, array.length - 1);\n\n    // Make sort stable\n    int i = 0;\n    while (i \u003c index.length) {\n      numEqual = 1;\n      for (int j = i + 1; ((j \u003c index.length)\n\t\t\t   \u0026\u0026 (array[index[i]] == array[index[j]]));\n\t   j++) {\n\tnumEqual++;\n      }\n      if (numEqual \u003e 1) {\n\thelpIndex = new int[numEqual];\n\tfor (int j = 0; j \u003c numEqual; j++) {\n\t  helpIndex[j] = i + j;\n\t}\n\tquickSort(index, helpIndex, 0, numEqual - 1);\n\tfor (int j = 0; j \u003c numEqual; j++) {\n\t  newIndex[i + j] = index[helpIndex[j]];\n\t}\n\ti += numEqual;\n      } else {\n\tnewIndex[i] = index[i];\n\ti++;\n      }\n    }\n    return newIndex;\n  }\n\n  /**\n   * Sorts a given array of doubles in ascending order and returns an\n   * array of integers with the positions of the elements of the\n   * original array in the sorted array. NOTE THESE CHANGES: the sort\n   * is no longer stable and it doesn't use safe floating-point\n   * comparisons anymore. Occurrences of Double.NaN are treated as \n   * Double.MAX_VALUE\n   *\n   * @param array this array is not changed by the method!\n   * @return an array of integers with the positions in the sorted\n   * array.  \n   */\n  public static /*@pure@*/ int[] sort(/*@non_null@*/ double[] array) {\n\n    int[] index = new int[array.length];\n    array = (double[])array.clone();\n    for (int i = 0; i \u003c index.length; i++) {\n      index[i] = i;\n      if (Double.isNaN(array[i])) {\n        array[i] = Double.MAX_VALUE;\n      }\n    }\n    quickSort(array, index, 0, array.length - 1);\n    return index;\n  }\n\n  /**\n   * Sorts a given array of doubles in ascending order and returns an \n   * array of integers with the positions of the elements of the original \n   * array in the sorted array. The sort is stable (Equal elements remain\n   * in their original order.) Occurrences of Double.NaN are treated as \n   * Double.MAX_VALUE\n   *\n   * @param array this array is not changed by the method!\n   * @return an array of integers with the positions in the sorted\n   * array.\n   */\n  public static /*@pure@*/ int[] stableSort(double[] array){\n\n    int[] index = new int[array.length];\n    int[] newIndex = new int[array.length];\n    int[] helpIndex;\n    int numEqual;\n    \n    array = (double[])array.clone();\n    for (int i = 0; i \u003c index.length; i++) {\n      index[i] = i;\n      if (Double.isNaN(array[i])) {\n        array[i] = Double.MAX_VALUE;\n      }\n    }\n    quickSort(array,index,0,array.length-1);\n\n    // Make sort stable\n\n    int i = 0;\n    while (i \u003c index.length) {\n      numEqual = 1;\n      for (int j = i+1; ((j \u003c index.length) \u0026\u0026 Utils.eq(array[index[i]],\n\t\t\t\t\t\t\tarray[index[j]])); j++)\n\tnumEqual++;\n      if (numEqual \u003e 1) {\n\thelpIndex = new int[numEqual];\n\tfor (int j = 0; j \u003c numEqual; j++)\n\t  helpIndex[j] = i+j;\n\tquickSort(index, helpIndex, 0, numEqual-1);\n\tfor (int j = 0; j \u003c numEqual; j++) \n\t  newIndex[i+j] = index[helpIndex[j]];\n\ti += numEqual;\n      } else {\n\tnewIndex[i] = index[i];\n\ti++;\n      }\n    }\n\n    return newIndex;\n  }\n\n  /**\n   * Computes the variance for an array of doubles.\n   *\n   * @param vector the array\n   * @return the variance\n   */\n  public static /*@pure@*/ double variance(double[] vector) {\n  \n    double sum = 0, sumSquared = 0;\n\n    if (vector.length \u003c= 1) {\n      return 0;\n    }\n    for (int i = 0; i \u003c vector.length; i++) {\n      sum += vector[i];\n      sumSquared += (vector[i] * vector[i]);\n    }\n    double result = (sumSquared - (sum * sum / (double) vector.length)) / \n      (double) (vector.length - 1);\n\n    // We don't like negative variance\n    if (result \u003c 0) {\n      return 0;\n    } else {\n      return result;\n    }\n  }\n\n  /**\n   * Computes the sum of the elements of an array of doubles.\n   *\n   * @param doubles the array of double\n   * @return the sum of the elements\n   */\n  public static /*@pure@*/ double sum(double[] doubles) {\n\n    double sum = 0;\n\n    for (int i = 0; i \u003c doubles.length; i++) {\n      sum += doubles[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Computes the sum of the elements of an array of integers.\n   *\n   * @param ints the array of integers\n   * @return the sum of the elements\n   */\n  public static /*@pure@*/ int sum(int[] ints) {\n\n    int sum = 0;\n\n    for (int i = 0; i \u003c ints.length; i++) {\n      sum += ints[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns c*log2(c) for a given integer value c.\n   *\n   * @param c an integer value\n   * @return c*log2(c) (but is careful to return 0 if c is 0)\n   */\n  public static /*@pure@*/ double xlogx(int c) {\n    \n    if (c == 0) {\n      return 0.0;\n    }\n    return c * Utils.log2((double) c);\n  }\n\n  /**\n   * Partitions the instances around a pivot. Used by quicksort and\n   * kthSmallestValue.\n   *\n   * @param array the array of doubles to be sorted\n   * @param index the index into the array of doubles\n   * @param l the first index of the subset \n   * @param r the last index of the subset \n   *\n   * @return the index of the middle element\n   */\n  private static int partition(double[] array, int[] index, int l, int r) {\n    \n    double pivot = array[index[(l + r) / 2]];\n    int help;\n\n    while (l \u003c r) {\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\n        l++;\n      }\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\n        r--;\n      }\n      if (l \u003c r) {\n        help = index[l];\n        index[l] = index[r];\n        index[r] = help;\n        l++;\n        r--;\n      }\n    }\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\n      r--;\n    } \n\n    return r;\n  }\n\n  /**\n   * Partitions the instances around a pivot. Used by quicksort and\n   * kthSmallestValue.\n   *\n   * @param array the array of integers to be sorted\n   * @param index the index into the array of integers\n   * @param l the first index of the subset \n   * @param r the last index of the subset \n   *\n   * @return the index of the middle element\n   */\n  private static int partition(int[] array, int[] index, int l, int r) {\n    \n    double pivot = array[index[(l + r) / 2]];\n    int help;\n\n    while (l \u003c r) {\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\n        l++;\n      }\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\n        r--;\n      }\n      if (l \u003c r) {\n        help = index[l];\n        index[l] = index[r];\n        index[r] = help;\n        l++;\n        r--;\n      }\n    }\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\n      r--;\n    } \n\n    return r;\n  }\n  \n  /**\n   * Implements quicksort according to Manber's \"Introduction to\n   * Algorithms\".\n   *\n   * @param array the array of doubles to be sorted\n   * @param index the index into the array of doubles\n   * @param left the first index of the subset to be sorted\n   * @param right the last index of the subset to be sorted\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\n  //@ requires array != index;\n  //  assignable index;\n  private static void quickSort(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \n                                int left, int right) {\n\n    if (left \u003c right) {\n      int middle = partition(array, index, left, right);\n      quickSort(array, index, left, middle);\n      quickSort(array, index, middle + 1, right);\n    }\n  }\n  \n  /**\n   * Implements quicksort according to Manber's \"Introduction to\n   * Algorithms\".\n   *\n   * @param array the array of integers to be sorted\n   * @param index the index into the array of integers\n   * @param left the first index of the subset to be sorted\n   * @param right the last index of the subset to be sorted\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\n  //@ requires array != index;\n  //  assignable index;\n  private static void quickSort(/*@non_null@*/ int[] array, /*@non_null@*/  int[] index, \n                                int left, int right) {\n\n    if (left \u003c right) {\n      int middle = partition(array, index, left, right);\n      quickSort(array, index, left, middle);\n      quickSort(array, index, middle + 1, right);\n    }\n  }\n  \n  /**\n   * Implements computation of the kth-smallest element according\n   * to Manber's \"Introduction to Algorithms\".\n   *\n   * @param array the array of double\n   * @param index the index into the array of doubles\n   * @param left the first index of the subset \n   * @param right the last index of the subset \n   * @param k the value of k\n   *\n   * @return the index of the kth-smallest element\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n  private static int select(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \n                            int left, int right, int k) {\n    \n    if (left == right) {\n      return left;\n    } else {\n      int middle = partition(array, index, left, right);\n      if ((middle - left + 1) \u003e= k) {\n        return select(array, index, left, middle, k);\n      } else {\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\n      }\n    }\n  }\n\n  /**\n   * Converts a File's absolute path to a path relative to the user\n   * (ie start) directory. Includes an additional workaround for Cygwin, which\n   * doesn't like upper case drive letters.\n   * @param absolute the File to convert to relative path\n   * @return a File with a path that is relative to the user's directory\n   * @exception Exception if the path cannot be constructed\n   */\n  public static File convertToRelativePath(File absolute) throws Exception {\n    File        result;\n    String      fileStr;\n    \n    result = null;\n    \n    // if we're running windows, it could be Cygwin\n    if (File.separator.equals(\"\\\\\")) {\n      // Cygwin doesn't like upper case drives -\u003e try lower case drive\n      try {\n        fileStr = absolute.getPath();\n        fileStr =   fileStr.substring(0, 1).toLowerCase() \n                  + fileStr.substring(1);\n        result = createRelativePath(new File(fileStr));\n      }\n      catch (Exception e) {\n        // no luck with Cygwin workaround, convert it like it is\n        result = createRelativePath(absolute);\n      }\n    }\n    else {\n      result = createRelativePath(absolute);\n    }\n\n    return result;\n  }\n\n  /**\n   * Converts a File's absolute path to a path relative to the user\n   * (ie start) directory.\n   * \n   * @param absolute the File to convert to relative path\n   * @return a File with a path that is relative to the user's directory\n   * @exception Exception if the path cannot be constructed\n   */\n  protected static File createRelativePath(File absolute) throws Exception {\n    File userDir = new File(System.getProperty(\"user.dir\"));\n    String userPath = userDir.getAbsolutePath() + File.separator;\n    String targetPath = (new File(absolute.getParent())).getPath() \n      + File.separator;\n    String fileName = absolute.getName();\n    StringBuffer relativePath = new StringBuffer();\n    //    relativePath.append(\".\"+File.separator);\n    //    System.err.println(\"User dir \"+userPath);\n    //    System.err.println(\"Target path \"+targetPath);\n    \n    // file is in user dir (or subdir)\n    int subdir = targetPath.indexOf(userPath);\n    if (subdir == 0) {\n      if (userPath.length() == targetPath.length()) {\n\trelativePath.append(fileName);\n      } else {\n\tint ll = userPath.length();\n\trelativePath.append(targetPath.substring(ll));\n\trelativePath.append(fileName);\n      }\n    } else {\n      int sepCount = 0;\n      String temp = new String(userPath);\n      while (temp.indexOf(File.separator) != -1) {\n\tint ind = temp.indexOf(File.separator);\n\tsepCount++;\n\ttemp = temp.substring(ind+1, temp.length());\n      }\n      \n      String targetTemp = new String(targetPath);\n      String userTemp = new String(userPath);\n      int tcount = 0;\n      while (targetTemp.indexOf(File.separator) != -1) {\n\tint ind = targetTemp.indexOf(File.separator);\n\tint ind2 = userTemp.indexOf(File.separator);\n\tString tpart = targetTemp.substring(0,ind+1);\n\tString upart = userTemp.substring(0,ind2+1);\n\tif (tpart.compareTo(upart) != 0) {\n\t  if (tcount == 0) {\n\t    tcount = -1;\n\t  }\n\t  break;\n\t}\n\ttcount++;\n\ttargetTemp = targetTemp.substring(ind+1, targetTemp.length());\n\tuserTemp = userTemp.substring(ind2+1, userTemp.length());\n      }\n      if (tcount == -1) {\n\t// then target file is probably on another drive (under windows)\n\tthrow new Exception(\"Can't construct a path to file relative to user \"\n\t\t\t    +\"dir.\");\n      }\n      if (targetTemp.indexOf(File.separator) == -1) {\n\ttargetTemp = \"\";\n      }\n      for (int i = 0; i \u003c sepCount - tcount; i++) {\n\trelativePath.append(\"..\"+File.separator);\n      }\n      relativePath.append(targetTemp + fileName);\n    }\n    //    System.err.println(\"new path : \"+relativePath.toString());\n    return new File(relativePath.toString());\n  }\n  \n  /**\n   * Implements computation of the kth-smallest element according\n   * to Manber's \"Introduction to Algorithms\".\n   *\n   * @param array the array of integers\n   * @param index the index into the array of integers\n   * @param left the first index of the subset \n   * @param right the last index of the subset \n   * @param k the value of k\n   *\n   * @return the index of the kth-smallest element\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n  private static int select(/*@non_null@*/ int[] array, /*@non_null@*/ int[] index, \n                            int left, int right, int k) {\n    \n    if (left == right) {\n      return left;\n    } else {\n      int middle = partition(array, index, left, right);\n      if ((middle - left + 1) \u003e= k) {\n        return select(array, index, left, middle, k);\n      } else {\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\n      }\n    }\n  }\n  \n  /**\n   * For a named dialog, returns true if the user has opted not to view\n   * it again in the future.\n   * \n   * @param dialogName the name of the dialog to check (e.g.\n   * weka.gui.GUICHooser.HowToFindPackageManager).\n   * @return true if the user has opted not to view the named dialog\n   * in the future.\n   \n  public static boolean getDontShowDialog(String dialogName) {\n    File wekaHome = WekaPackageManager.WEKA_HOME;\n    \n    if (!wekaHome.exists()) {\n      return false;\n    }\n    \n    File dialogSubDir = new File(wekaHome.toString() + File.separator + \"systemDialogs\");\n    if (!dialogSubDir.exists()) {\n      return false;\n    }\n    \n    File dialogFile = new File(dialogSubDir.toString() + File.separator + dialogName);\n    \n    return dialogFile.exists();\n  }\n  */\n  \n  /**\n   * Specify that the named dialog is not to be displayed in the future.\n   * \n   * @param dialogName the name of the dialog not to show again (e.g.\n   * weka.gui.GUIChooser.HowToFindPackageManager).\n   * @throws Exception if the marker file that is used to indicate that\n   * a named dialog is not to be shown can't be created. This file lives\n   * in $WEKA_HOME/systemDialogs\n  \n  public static void setDontShowDialog(String dialogName) throws Exception {\n    File wekaHome = WekaPackageManager.WEKA_HOME;\n    \n    if (!wekaHome.exists()) {\n      return;\n    }\n    \n    File dialogSubDir = new File(wekaHome.toString() + File.separator + \"systemDialogs\");\n    if (!dialogSubDir.exists()) {\n      if (!dialogSubDir.mkdir()) {\n        return;\n      }\n    }\n    \n    File dialogFile = new File(dialogSubDir.toString() + File.separator + dialogName);\n    dialogFile.createNewFile();\n  }\n   */\n  /**\n   * For a named dialog, if the user has opted not to view it again, \n   * returns the answer the answer the user supplied when they\n   * closed the dialog. Returns null if the user did opt to view\n   * the dialog again.\n   * \n   * @param dialogName the name of the dialog to check (e.g.\n   * weka.gui.GUICHooser.HowToFindPackageManager).\n   * @return the answer the user supplied the last time they\n   * viewed the named dialog (if they opted not to view it again\n   * in the future) or null if the user opted to view the dialog\n   * again in the future.\n   \n  public static String getDontShowDialogResponse(String dialogName) throws Exception {\n    if (!getDontShowDialog(dialogName)) {\n      return null; // This must be the first time - no file recorded yet.\n    }\n    \n    File wekaHome = WekaPackageManager.WEKA_HOME;\n    File dialogSubDir = new File(wekaHome.toString() + File.separator \n        + \"systemDialogs\" + File.separator + dialogName);\n\n    \n    BufferedReader br = new BufferedReader(new FileReader(dialogSubDir));\n    String response = br.readLine();\n    \n    br.close();\n    return response;\n  }\n  */\n  /**\n   * Specify that the named dialog is not to be shown again in the future. \n   * Also records the answer that the user chose when closing the dialog.\n   * \n   * @param dialogName the name of the dialog to no longer display\n   * @param response the user selected response when they closed the dialog\n   * @throws Exception if there is a problem saving the information\n   \n  public static void setDontShowDialogResponse(String dialogName, String response) \n    throws Exception {\n    \n    File wekaHome = WekaPackageManager.WEKA_HOME;\n    \n    if (!wekaHome.exists()) {\n      return;\n    }\n    \n    File dialogSubDir = new File(wekaHome.toString() + File.separator + \"systemDialogs\");\n    if (!dialogSubDir.exists()) {\n      if (!dialogSubDir.mkdir()) {\n        return;\n      }\n    }\n    \n    File dialogFile = new File(dialogSubDir.toString() + File.separator + dialogName);\n    BufferedWriter br = new BufferedWriter(new FileWriter(dialogFile));\n    br.write(response + \"\\n\");\n    br.flush();\n    br.close();\n  }\n  */\n  /**\n   * Returns the revision string.\n   * \n   * @return\t\tthe revision\n   \n  public String getRevision() {\n    return RevisionUtils.extract(\"$Revision: 6959 $\");\n  }\n*/\n  /**\n   * Main method for testing this class.\n   *\n   * @param ops some dummy options\n   */\n  public static void main(String[] ops) {\n\n    double[] doublesWithNaN = {4.5, 6.7, Double.NaN, 3.4, 4.8, 1.2, 3.4};\n    double[] doubles = {4.5, 6.7, 6.7, 3.4, 4.8, 1.2, 3.4, 6.7, 6.7, 3.4};\n    int[] ints = {12, 6, 2, 18, 16, 6, 7, 5, 18, 18, 17};\n\n    try {\n\n      // Option handling\n      System.out.println(\"First option split up:\");\n      if (ops.length \u003e 0) {\n\tString[] firstOptionSplitUp = Utils.splitOptions(ops[0]);\n\tfor (int i = 0; i \u003c firstOptionSplitUp.length; i ++) {\n\t  System.out.println(firstOptionSplitUp[i]);\n\t}\n      }\t\t\t\t\t       \n      System.out.println(\"Partitioned options: \");\n      String[] partitionedOptions = Utils.partitionOptions(ops);\n      for (int i  = 0; i \u003c partitionedOptions.length; i++) {\n\tSystem.out.println(partitionedOptions[i]);\n      }\n      System.out.println(\"Get position of flag -f: \" + Utils.getOptionPos('f', ops));\n      System.out.println(\"Get flag -f: \" + Utils.getFlag('f', ops));\n      System.out.println(\"Get position of option -o: \" + Utils.getOptionPos('o', ops));\n      System.out.println(\"Get option -o: \" + Utils.getOption('o', ops));\n      System.out.println(\"Checking for remaining options... \");\n      Utils.checkForRemainingOptions(ops);\n      \n      // Statistics\n      System.out.println(\"Original array with NaN (doubles): \");\n      for (int i = 0; i \u003c doublesWithNaN.length; i++) {\n\tSystem.out.print(doublesWithNaN[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Original array (doubles): \");\n      for (int i = 0; i \u003c doubles.length; i++) {\n\tSystem.out.print(doubles[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Original array (ints): \");\n      for (int i = 0; i \u003c ints.length; i++) {\n\tSystem.out.print(ints[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Correlation: \" + Utils.correlation(doubles, doubles, \n\t\t\t\t\t\t\t     doubles.length));\n      System.out.println(\"Mean: \" + Utils.mean(doubles));\n      System.out.println(\"Variance: \" + Utils.variance(doubles));\n      System.out.println(\"Sum (doubles): \" + Utils.sum(doubles));\n      System.out.println(\"Sum (ints): \" + Utils.sum(ints));\n      System.out.println(\"Max index (doubles): \" + Utils.maxIndex(doubles));\n      System.out.println(\"Max index (ints): \" + Utils.maxIndex(ints));\n      System.out.println(\"Min index (doubles): \" + Utils.minIndex(doubles));\n      System.out.println(\"Min index (ints): \" + Utils.minIndex(ints));\n      System.out.println(\"Median (doubles): \" + \n                         Utils.kthSmallestValue(doubles, doubles.length / 2));\n      System.out.println(\"Median (ints): \" + \n                         Utils.kthSmallestValue(ints, ints.length / 2));\n\n      // Sorting and normalizing\n      System.out.println(\"Sorted array with NaN (doubles): \");\n      int[] sorted = Utils.sort(doublesWithNaN);\n      for (int i = 0; i \u003c doublesWithNaN.length; i++) {\n\tSystem.out.print(doublesWithNaN[sorted[i]] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Sorted array (doubles): \");\n      sorted = Utils.sort(doubles);\n      for (int i = 0; i \u003c doubles.length; i++) {\n\tSystem.out.print(doubles[sorted[i]] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Sorted array (ints): \");\n      sorted = Utils.sort(ints);\n      for (int i = 0; i \u003c ints.length; i++) {\n\tSystem.out.print(ints[sorted[i]] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Indices from stable sort (doubles): \");\n      sorted = Utils.stableSort(doubles);\n      for (int i = 0; i \u003c doubles.length; i++) {\n\tSystem.out.print(sorted[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Indices from sort (ints): \");\n      sorted = Utils.sort(ints);\n      for (int i = 0; i \u003c ints.length; i++) {\n\tSystem.out.print(sorted[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Normalized array (doubles): \");\n      Utils.normalize(doubles);\n      for (int i = 0; i \u003c doubles.length; i++) {\n\tSystem.out.print(doubles[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Normalized again (doubles): \");\n      Utils.normalize(doubles, Utils.sum(doubles));\n      for (int i = 0; i \u003c doubles.length; i++) {\n\tSystem.out.print(doubles[i] + \" \");\n      }\n      System.out.println();\n      \n      // Pretty-printing\n      System.out.println(\"-4.58: \" + Utils.doubleToString(-4.57826535, 2));\n      System.out.println(\"-6.78: \" + Utils.doubleToString(-6.78214234, 6,2));\n      \n      // Comparisons\n      System.out.println(\"5.70001 == 5.7 ? \" + Utils.eq(5.70001, 5.7));\n      System.out.println(\"5.70001 \u003e 5.7 ? \" + Utils.gr(5.70001, 5.7));\n      System.out.println(\"5.70001 \u003e= 5.7 ? \" + Utils.grOrEq(5.70001, 5.7));\n      System.out.println(\"5.7 \u003c 5.70001 ? \" + Utils.sm(5.7, 5.70001));\n      System.out.println(\"5.7 \u003c= 5.70001 ? \" + Utils.smOrEq(5.7, 5.70001));\n      \n      // Math\n      System.out.println(\"Info (ints): \" + Utils.info(ints));\n      System.out.println(\"log2(4.6): \" + Utils.log2(4.6));\n      System.out.println(\"5 * log(5): \" + Utils.xlogx(5));\n      System.out.println(\"5.5 rounded: \" + Utils.round(5.5));\n      System.out.println(\"5.55555 rounded to 2 decimal places: \" + \n\t\t\t Utils.roundDouble(5.55555, 2));\n      \n      // Arrays\n      System.out.println(\"Array-Dimensions of 'new int[][]': \" + Utils.getArrayDimensions(new int[][]{}));\n      System.out.println(\"Array-Dimensions of 'new int[][]{{1,2,3},{4,5,6}}': \" + Utils.getArrayDimensions(new int[][]{{1,2,3},{4,5,6}}));\n      String[][][] s = new String[3][4][];\n      System.out.println(\"Array-Dimensions of 'new String[3][4][]': \" + Utils.getArrayDimensions(s));\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n  \n",
        "name": "Utils.java",
        "path": "src/keel/Algorithms/Semi_Supervised_Learning/ADE_CoForest/Utils.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/Semi_Supervised_Learning/ADE_CoForest/Utils.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 1780,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 1781,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);"
        },
        {
          "limitHit": false,
          "lineNumber": 1782,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1803,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 1804,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);"
        },
        {
          "limitHit": false,
          "lineNumber": 1805,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1829,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 1965,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "/***********************************************************************\r\n\r\n\tThis file is part of KEEL-software, the Data Mining tool for regression, \r\n\tclassification, clustering, pattern mining and so on.\r\n\r\n\tCopyright (C) 2004-2010\r\n\t\r\n\tF. Herrera (herrera@decsai.ugr.es)\r\n    L. Sánchez (luciano@uniovi.es)\r\n    J. Alcalá-Fdez (jalcala@decsai.ugr.es)\r\n    S. García (sglopez@ujaen.es)\r\n    A. Fernández (alberto.fernandez@ujaen.es)\r\n    J. Luengo (julianlm@decsai.ugr.es)\r\n\r\n\tThis program is free software: you can redistribute it and/or modify\r\n\tit under the terms of the GNU General Public License as published by\r\n\tthe Free Software Foundation, either version 3 of the License, or\r\n\t(at your option) any later version.\r\n\r\n\tThis program is distributed in the hope that it will be useful,\r\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\tGNU General Public License for more details.\r\n\r\n\tYou should have received a copy of the GNU General Public License\r\n\talong with this program.  If not, see http://www.gnu.org/licenses/\r\n  \r\n**********************************************************************/\r\n\r\n/*\r\n *    This program is free software; you can redistribute it and/or modify\r\n *    it under the terms of the GNU General Public License as published by\r\n *    the Free Software Foundation; either version 2 of the License, or\r\n *    (at your option) any later version.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU General Public License\r\n *    along with this program; if not, write to the Free Software\r\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\r\n */\r\n\r\n/*\r\n *    Utils.java\r\n *    Copyright (C) 1999-2004 University of Waikato, Hamilton, New Zealand\r\n *\r\n */\r\n\r\npackage keel.Algorithms.Fuzzy_Rule_Learning.Hybrid.FURIA.core;\r\n\r\nimport java.lang.Math;\r\nimport java.lang.reflect.Array;\r\nimport java.util.Properties;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.util.Random;\r\n\r\n/**\r\n * Class implementing some simple utility methods.\r\n *\r\n * @author Eibe Frank\r\n * @author Yong Wang\r\n * @author Len Trigg\r\n * @author Julien Prados\r\n * @version $Revision: 1.60 $\r\n */\r\npublic final class Utils {\r\n\r\n  /** The natural logarithm of 2. */\r\n  public static double log2 = Math.log(2);\r\n\r\n  /** The small deviation allowed in double comparisons. */\r\n  public static double SMALL = 1e-6;\r\n\r\n\r\n  /**\r\n   * Reads properties that inherit from three locations. Properties\r\n   * are first defined in the system resource location (i.e. in the\r\n   * CLASSPATH).  These default properties must exist. Properties\r\n   * defined in the users home directory (optional) override default\r\n   * settings. Properties defined in the current directory (optional)\r\n   * override all these settings.\r\n   *\r\n   * @param resourceName the location of the resource that should be\r\n   * loaded.  e.g.: \"weka/core/Utils.props\". (The use of hardcoded\r\n   * forward slashes here is OK - see\r\n   * jdk1.1/docs/guide/misc/resources.html) This routine will also\r\n   * look for the file (in this case) \"Utils.props\" in the users home\r\n   * directory and the current directory.\r\n   * @return the Properties\r\n   * @exception Exception if no default properties are defined, or if\r\n   * an error occurs reading the properties files.\r\n   */\r\n  public static Properties readProperties(String resourceName)\r\n    throws Exception {\r\n\r\n    Properties defaultProps = new Properties();\r\n    try {\r\n      // Apparently hardcoded slashes are OK here\r\n      // jdk1.1/docs/guide/misc/resources.html\r\n      //      defaultProps.load(ClassLoader.getSystemResourceAsStream(resourceName));\r\n      defaultProps.load((new Utils()).getClass().getClassLoader().getResourceAsStream(resourceName));\r\n    } catch (Exception ex) {\r\n/*      throw new Exception(\"Problem reading default properties: \"\r\n\t+ ex.getMessage()); */\r\n      System.err.println(\"Warning, unable to load properties file from \"\r\n\t\t\t +\"system resource (Utils.java)\");\r\n    }\r\n\r\n    // Hardcoded slash is OK here\r\n    // eg: see jdk1.1/docs/guide/misc/resources.html\r\n    int slInd = resourceName.lastIndexOf('/');\r\n    if (slInd != -1) {\r\n      resourceName = resourceName.substring(slInd + 1);\r\n    }\r\n\r\n    // Allow a properties file in the home directory to override\r\n    Properties userProps = new Properties(defaultProps);\r\n    File propFile = new File(System.getProperties().getProperty(\"user.home\")\r\n                             + File.separatorChar\r\n                             + resourceName);\r\n    if (propFile.exists()) {\r\n      try {\r\n        userProps.load(new FileInputStream(propFile));\r\n      } catch (Exception ex) {\r\n        throw new Exception(\"Problem reading user properties: \" + propFile);\r\n      }\r\n    }\r\n\r\n    // Allow a properties file in the current directory to override\r\n    Properties localProps = new Properties(userProps);\r\n    propFile = new File(resourceName);\r\n    if (propFile.exists()) {\r\n      try {\r\n        localProps.load(new FileInputStream(propFile));\r\n      } catch (Exception ex) {\r\n        throw new Exception(\"Problem reading local properties: \" + propFile);\r\n      }\r\n    }\r\n\r\n    return localProps;\r\n  }\r\n\r\n  /**\r\n   * Returns the correlation coefficient of two double vectors.\r\n   *\r\n   * @param y1 double vector 1\r\n   * @param y2 double vector 2\r\n   * @param n the length of two double vectors\r\n   * @return the correlation coefficient\r\n   */\r\n  public static final double correlation(double y1[],double y2[],int n) {\r\n\r\n    int i;\r\n    double av1 = 0.0, av2 = 0.0, y11 = 0.0, y22 = 0.0, y12 = 0.0, c;\r\n\r\n    if (n \u003c= 1) {\r\n      return 1.0;\r\n    }\r\n    for (i = 0; i \u003c n; i++) {\r\n      av1 += y1[i];\r\n      av2 += y2[i];\r\n    }\r\n    av1 /= (double) n;\r\n    av2 /= (double) n;\r\n    for (i = 0; i \u003c n; i++) {\r\n      y11 += (y1[i] - av1) * (y1[i] - av1);\r\n      y22 += (y2[i] - av2) * (y2[i] - av2);\r\n      y12 += (y1[i] - av1) * (y2[i] - av2);\r\n    }\r\n    if (y11 * y22 == 0.0) {\r\n      c=1.0;\r\n    } else {\r\n      c = y12 / Math.sqrt(Math.abs(y11 * y22));\r\n    }\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * Removes all occurrences of a string from another string.\r\n   *\r\n   * @param inString the string to remove substrings from.\r\n   * @param substring the substring to remove.\r\n   * @return the input string with occurrences of substring removed.\r\n   */\r\n  public static String removeSubstring(String inString, String substring) {\r\n\r\n    StringBuffer result = new StringBuffer();\r\n    int oldLoc = 0, loc = 0;\r\n    while ((loc = inString.indexOf(substring, oldLoc))!= -1) {\r\n      result.append(inString.substring(oldLoc, loc));\r\n      oldLoc = loc + substring.length();\r\n    }\r\n    result.append(inString.substring(oldLoc));\r\n    return result.toString();\r\n  }\r\n\r\n  /**\r\n   * Replaces with a new string, all occurrences of a string from\r\n   * another string.\r\n   *\r\n   * @param inString the string to replace substrings in.\r\n   * @param subString the substring to replace.\r\n   * @param replaceString the replacement substring\r\n   * @return the input string with occurrences of substring replaced.\r\n   */\r\n  public static String replaceSubstring(String inString, String subString,\r\n\t\t\t\t\tString replaceString) {\r\n\r\n    StringBuffer result = new StringBuffer();\r\n    int oldLoc = 0, loc = 0;\r\n    while ((loc = inString.indexOf(subString, oldLoc))!= -1) {\r\n      result.append(inString.substring(oldLoc, loc));\r\n      result.append(replaceString);\r\n      oldLoc = loc + subString.length();\r\n    }\r\n    result.append(inString.substring(oldLoc));\r\n    return result.toString();\r\n  }\r\n\r\n\r\n  /**\r\n   * Pads a string to a specified length, inserting spaces on the left\r\n   * as required. If the string is too long, characters are removed (from\r\n   * the right).\r\n   *\r\n   * @param inString the input string\r\n   * @param length the desired length of the output string\r\n   * @return the output string\r\n   */\r\n  public static String padLeft(String inString, int length) {\r\n\r\n    return fixStringLength(inString, length, false);\r\n  }\r\n\r\n  /**\r\n   * Pads a string to a specified length, inserting spaces on the right\r\n   * as required. If the string is too long, characters are removed (from\r\n   * the right).\r\n   *\r\n   * @param inString the input string\r\n   * @param length the desired length of the output string\r\n   * @return the output string\r\n   */\r\n  public static String padRight(String inString, int length) {\r\n\r\n    return fixStringLength(inString, length, true);\r\n  }\r\n\r\n  /**\r\n   * Pads a string to a specified length, inserting spaces as\r\n   * required. If the string is too long, characters are removed (from\r\n   * the right).\r\n   *\r\n   * @param inString the input string\r\n   * @param length the desired length of the output string\r\n   * @param right true if inserted spaces should be added to the right\r\n   * @return the output string\r\n   */\r\n  private static /*@pure@*/ String fixStringLength(String inString, int length,\r\n\t\t\t\t\tboolean right) {\r\n\r\n    if (inString.length() \u003c length) {\r\n      while (inString.length() \u003c length) {\r\n\tinString = (right ? inString.concat(\" \") : \" \".concat(inString));\r\n      }\r\n    } else if (inString.length() \u003e length) {\r\n      inString = inString.substring(0, length);\r\n    }\r\n    return inString;\r\n  }\r\n\r\n  /**\r\n   * Rounds a double and converts it into String.\r\n   *\r\n   * @param value the double value\r\n   * @param afterDecimalPoint the (maximum) number of digits permitted\r\n   * after the decimal point\r\n   * @return the double as a formatted string\r\n   */\r\n  public static /*@pure@*/ String doubleToString(double value, int afterDecimalPoint) {\r\n\r\n    StringBuffer stringBuffer;\r\n    double temp;\r\n    int dotPosition;\r\n    long precisionValue;\r\n\r\n    temp = value * Math.pow(10.0, afterDecimalPoint);\r\n    if (Math.abs(temp) \u003c Long.MAX_VALUE) {\r\n      precisionValue = \t(temp \u003e 0) ? (long)(temp + 0.5)\r\n                                   : -(long)(Math.abs(temp) + 0.5);\r\n      if (precisionValue == 0) {\r\n\tstringBuffer = new StringBuffer(String.valueOf(0));\r\n      } else {\r\n\tstringBuffer = new StringBuffer(String.valueOf(precisionValue));\r\n      }\r\n      if (afterDecimalPoint == 0) {\r\n\treturn stringBuffer.toString();\r\n      }\r\n      dotPosition = stringBuffer.length() - afterDecimalPoint;\r\n      while (((precisionValue \u003c 0) \u0026\u0026 (dotPosition \u003c 1)) ||\r\n\t     (dotPosition \u003c 0)) {\r\n\tif (precisionValue \u003c 0) {\r\n\t  stringBuffer.insert(1, '0');\r\n\t} else {\r\n\t  stringBuffer.insert(0, '0');\r\n\t}\r\n\tdotPosition++;\r\n      }\r\n      stringBuffer.insert(dotPosition, '.');\r\n      if ((precisionValue \u003c 0) \u0026\u0026 (stringBuffer.charAt(1) == '.')) {\r\n\tstringBuffer.insert(1, '0');\r\n      } else if (stringBuffer.charAt(0) == '.') {\r\n\tstringBuffer.insert(0, '0');\r\n      }\r\n      int currentPos = stringBuffer.length() - 1;\r\n      while ((currentPos \u003e dotPosition) \u0026\u0026\r\n\t     (stringBuffer.charAt(currentPos) == '0')) {\r\n\tstringBuffer.setCharAt(currentPos--, ' ');\r\n      }\r\n      if (stringBuffer.charAt(currentPos) == '.') {\r\n\tstringBuffer.setCharAt(currentPos, ' ');\r\n      }\r\n\r\n      return stringBuffer.toString().trim();\r\n    }\r\n    return new String(\"\" + value);\r\n  }\r\n\r\n  /**\r\n   * Rounds a double and converts it into a formatted decimal-justified String.\r\n   * Trailing 0's are replaced with spaces.\r\n   *\r\n   * @param value the double value\r\n   * @param width the width of the string\r\n   * @param afterDecimalPoint the number of digits after the decimal point\r\n   * @return the double as a formatted string\r\n   */\r\n  public static /*@pure@*/ String doubleToString(double value, int width,\r\n\t\t\t\t      int afterDecimalPoint) {\r\n\r\n    String tempString = doubleToString(value, afterDecimalPoint);\r\n    char[] result;\r\n    int dotPosition;\r\n\r\n    if ((afterDecimalPoint \u003e= width)\r\n        || (tempString.indexOf('E') != -1)) { // Protects sci notation\r\n      return tempString;\r\n    }\r\n\r\n    // Initialize result\r\n    result = new char[width];\r\n    for (int i = 0; i \u003c result.length; i++) {\r\n      result[i] = ' ';\r\n    }\r\n\r\n    if (afterDecimalPoint \u003e 0) {\r\n      // Get position of decimal point and insert decimal point\r\n      dotPosition = tempString.indexOf('.');\r\n      if (dotPosition == -1) {\r\n\tdotPosition = tempString.length();\r\n      } else {\r\n\tresult[width - afterDecimalPoint - 1] = '.';\r\n      }\r\n    } else {\r\n      dotPosition = tempString.length();\r\n    }\r\n\r\n\r\n    int offset = width - afterDecimalPoint - dotPosition;\r\n    if (afterDecimalPoint \u003e 0) {\r\n      offset--;\r\n    }\r\n\r\n    // Not enough room to decimal align within the supplied width\r\n    if (offset \u003c 0) {\r\n      return tempString;\r\n    }\r\n\r\n    // Copy characters before decimal point\r\n    for (int i = 0; i \u003c dotPosition; i++) {\r\n      result[offset + i] = tempString.charAt(i);\r\n    }\r\n\r\n    // Copy characters after decimal point\r\n    for (int i = dotPosition + 1; i \u003c tempString.length(); i++) {\r\n      result[offset + i] = tempString.charAt(i);\r\n    }\r\n\r\n    return new String(result);\r\n  }\r\n\r\n  /**\r\n   * Returns the basic class of an array class (handles multi-dimensional\r\n   * arrays).\r\n   * @param c        the array to inspect\r\n   * @return         the class of the innermost elements\r\n   */\r\n  public static Class getArrayClass(Class c) {\r\n     if (c.getComponentType().isArray())\r\n        return getArrayClass(c.getComponentType());\r\n     else\r\n        return c.getComponentType();\r\n  }\r\n\r\n  /**\r\n   * Returns the dimensions of the given array. Even though the\r\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\r\n   * int[3] or double[2][4].\r\n   *\r\n   * @param array       the array to determine the dimensions for\r\n   * @return            the dimensions of the array\r\n   */\r\n  public static int getArrayDimensions(Class array) {\r\n    if (array.getComponentType().isArray())\r\n      return 1 + getArrayDimensions(array.getComponentType());\r\n    else\r\n      return 1;\r\n  }\r\n\r\n  /**\r\n   * Returns the dimensions of the given array. Even though the\r\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\r\n   * int[3] or double[2][4].\r\n   *\r\n   * @param array       the array to determine the dimensions for\r\n   * @return            the dimensions of the array\r\n   */\r\n  public static int getArrayDimensions(Object array) {\r\n    return getArrayDimensions(array.getClass());\r\n  }\r\n\r\n  /**\r\n   * Returns the given Array in a string representation. Even though the\r\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\r\n   * int[3] or double[2][4].\r\n   *\r\n   * @param array       the array to return in a string representation\r\n   * @return            the array as string\r\n   */\r\n  public static String arrayToString(Object array) {\r\n    String        result;\r\n    int           dimensions;\r\n    int           i;\r\n\r\n    result     = \"\";\r\n    dimensions = getArrayDimensions(array);\r\n\r\n    if (dimensions == 0) {\r\n      result = \"null\";\r\n    }\r\n    else if (dimensions == 1) {\r\n      for (i = 0; i \u003c Array.getLength(array); i++) {\r\n        if (i \u003e 0)\r\n          result += \",\";\r\n        if (Array.get(array, i) == null)\r\n          result += \"null\";\r\n        else\r\n          result += Array.get(array, i).toString();\r\n      }\r\n    }\r\n    else {\r\n      for (i = 0; i \u003c Array.getLength(array); i++) {\r\n        if (i \u003e 0)\r\n          result += \",\";\r\n        result += \"[\" + arrayToString(Array.get(array, i)) + \"]\";\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Tests if a is equal to b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n     * @return true if a is equal to b.\r\n   */\r\n  public static /*@pure@*/ boolean eq(double a, double b){\r\n\r\n    return (a - b \u003c SMALL) \u0026\u0026 (b - a \u003c SMALL);\r\n  }\r\n\r\n  /**\r\n   * Checks if the given array contains any non-empty options.\r\n   *\r\n   * @param options an array of strings\r\n   * @exception Exception if there are any non-empty options\r\n   */\r\n  public static void checkForRemainingOptions(String[] options)\r\n    throws Exception {\r\n\r\n    int illegalOptionsFound = 0;\r\n    StringBuffer text = new StringBuffer();\r\n\r\n    if (options == null) {\r\n      return;\r\n    }\r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if (options[i].length() \u003e 0) {\r\n\tillegalOptionsFound++;\r\n\ttext.append(options[i] + ' ');\r\n      }\r\n    }\r\n    if (illegalOptionsFound \u003e 0) {\r\n      throw new Exception(\"Illegal options: \" + text);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the given array contains the flag \"-Char\". Stops\r\n   * searching at the first marker \"--\". If the flag is found,\r\n   * it is replaced with the empty string.\r\n   *\r\n   * @param flag the character indicating the flag.\r\n   * @param options the array of strings containing all the options.\r\n   * @return true if the flag was found\r\n   * @exception Exception if an illegal option was found\r\n   */\r\n  public static boolean getFlag(char flag, String[] options)\r\n    throws Exception {\r\n\r\n    return getFlag(\"\" + flag, options);\r\n  }\r\n\r\n  /**\r\n   * Checks if the given array contains the flag \"-String\". Stops\r\n   * searching at the first marker \"--\". If the flag is found,\r\n   * it is replaced with the empty string.\r\n   *\r\n   * @param flag the String indicating the flag.\r\n   * @param options the array of strings containing all the options.\r\n   * @return true if the flag was found\r\n   * @exception Exception if an illegal option was found\r\n   */\r\n  public static boolean getFlag(String flag, String[] options)\r\n    throws Exception {\r\n\r\n    int pos = getOptionPos(flag, options);\r\n\r\n    if (pos \u003e -1)\r\n      options[pos] = \"\";\r\n\r\n    return (pos \u003e -1);\r\n  }\r\n\r\n  /**\r\n   * Gets an option indicated by a flag \"-Char\" from the given array\r\n   * of strings. Stops searching at the first marker \"--\". Replaces\r\n   * flag and option with empty strings.\r\n   *\r\n   * @param flag the character indicating the option.\r\n   * @param options the array of strings containing all the options.\r\n   * @return the indicated option or an empty string\r\n   * @exception Exception if the option indicated by the flag can't be found\r\n   */\r\n  public static /*@non_null@*/ String getOption(char flag, String[] options)\r\n    throws Exception {\r\n\r\n    return getOption(\"\" + flag, options);\r\n  }\r\n\r\n  /**\r\n   * Gets an option indicated by a flag \"-String\" from the given array\r\n   * of strings. Stops searching at the first marker \"--\". Replaces\r\n   * flag and option with empty strings.\r\n   *\r\n   * @param flag the String indicating the option.\r\n   * @param options the array of strings containing all the options.\r\n   * @return the indicated option or an empty string\r\n   * @exception Exception if the option indicated by the flag can't be found\r\n   */\r\n  public static /*@non_null@*/ String getOption(String flag, String[] options)\r\n    throws Exception {\r\n\r\n    String newString;\r\n    int i = getOptionPos(flag, options);\r\n\r\n    if (i \u003e -1) {\r\n      if (options[i].equals(\"-\" + flag)) {\r\n\tif (i + 1 == options.length) {\r\n\t  throw new Exception(\"No value given for -\" + flag + \" option.\");\r\n\t}\r\n\toptions[i] = \"\";\r\n\tnewString = new String(options[i + 1]);\r\n\toptions[i + 1] = \"\";\r\n\treturn newString;\r\n      }\r\n      if (options[i].charAt(1) == '-') {\r\n\treturn \"\";\r\n      }\r\n    }\r\n\r\n    return \"\";\r\n  }\r\n\r\n  /**\r\n   * Gets the index of an option or flag indicated by a flag \"-Char\" from\r\n   * the given array of strings. Stops searching at the first marker \"--\".\r\n   *\r\n   * @param flag \tthe character indicating the option.\r\n   * @param options \tthe array of strings containing all the options.\r\n   * @return \t\tthe position if found, or -1 otherwise\r\n   */\r\n  public static int getOptionPos(char flag, String[] options) {\r\n     return getOptionPos(\"\" + flag, options);\r\n  }\r\n\r\n  /**\r\n   * Gets the index of an option or flag indicated by a flag \"-String\" from\r\n   * the given array of strings. Stops searching at the first marker \"--\".\r\n   *\r\n   * @param flag \tthe String indicating the option.\r\n   * @param options \tthe array of strings containing all the options.\r\n   * @return \t\tthe position if found, or -1 otherwise\r\n   */\r\n  public static int getOptionPos(String flag, String[] options) {\r\n    if (options == null)\r\n      return -1;\r\n\r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if ((options[i].length() \u003e 0) \u0026\u0026 (options[i].charAt(0) == '-')) {\r\n\t// Check if it is a negative number\r\n\ttry {\r\n\t  Double.valueOf(options[i]);\r\n\t}\r\n\tcatch (NumberFormatException e) {\r\n\t  // found?\r\n\t  if (options[i].equals(\"-\" + flag))\r\n\t    return i;\r\n\t  // did we reach \"--\"?\r\n\t  if (options[i].charAt(1) == '-')\r\n\t    return -1;\r\n\t}\r\n      }\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Quotes a string if it contains special characters.\r\n   *\r\n   * The following rules are applied:\r\n   *\r\n   * A character is backquoted version of it is one\r\n   * of \u003ctt\u003e\" ' % \\ \\n \\r \\t\u003c/tt\u003e.\r\n   *\r\n   * A string is enclosed within single quotes if a character has been\r\n   * backquoted using the previous rule above or contains\r\n   * \u003ctt\u003e{ }\u003c/tt\u003e or is exactly equal to the strings\r\n   * \u003ctt\u003e, ? space or \"\"\u003c/tt\u003e (empty string).\r\n   *\r\n   * A quoted question mark distinguishes it from the missing value which\r\n   * is represented as an unquoted question mark in arff files.\r\n   *\r\n   * @param string \tthe string to be quoted\r\n   * @return \t\tthe string (possibly quoted)\r\n   * @see\t\t#unquote(String)\r\n   */\r\n  public static /*@pure@*/ String quote(String string) {\r\n      boolean quote = false;\r\n\r\n      // backquote the following characters\r\n      if ((string.indexOf('\\n') != -1) || (string.indexOf('\\r') != -1) ||\r\n\t  (string.indexOf('\\'') != -1) || (string.indexOf('\"') != -1) ||\r\n\t  (string.indexOf('\\\\') != -1) ||\r\n\t  (string.indexOf('\\t') != -1) || (string.indexOf('%') != -1)) {\r\n\t  string = backQuoteChars(string);\r\n\t  quote = true;\r\n      }\r\n\r\n      // Enclose the string in 's if the string contains a recently added\r\n      // backquote or contains one of the following characters.\r\n      if((quote == true) ||\r\n\t (string.indexOf('{') != -1) || (string.indexOf('}') != -1) ||\r\n\t (string.indexOf(',') != -1) || (string.equals(\"?\")) ||\r\n\t (string.indexOf(' ') != -1) || (string.equals(\"\"))) {\r\n\t  string = (\"'\".concat(string)).concat(\"'\");\r\n      }\r\n\r\n      return string;\r\n  }\r\n\r\n  /**\r\n   * unquotes are previously quoted string (but only if necessary), i.e., it\r\n   * removes the single quotes around it. Inverse to quote(String).\r\n   *\r\n   * @param string\tthe string to process\r\n   * @return\t\tthe unquoted string\r\n   * @see\t\t#quote(String)\r\n   */\r\n  public static String unquote(String string) {\r\n    if (string.startsWith(\"'\") \u0026\u0026 string.endsWith(\"'\")) {\r\n      string = string.substring(1, string.length() - 1);\r\n\r\n      if ((string.indexOf(\"\\\\n\") != -1) || (string.indexOf(\"\\\\r\") != -1) ||\r\n\t  (string.indexOf(\"\\\\'\") != -1) || (string.indexOf(\"\\\\\\\"\") != -1) ||\r\n\t  (string.indexOf(\"\\\\\\\\\") != -1) ||\r\n\t  (string.indexOf(\"\\\\t\") != -1) || (string.indexOf(\"\\\\%\") != -1)) {\r\n\tstring = unbackQuoteChars(string);\r\n      }\r\n    }\r\n\r\n    return string;\r\n  }\r\n\r\n  /**\r\n   * Converts carriage returns and new lines in a string into \\r and \\n.\r\n   * Backquotes the following characters: ` \" \\ \\t and %\r\n   *\r\n   * @param string \tthe string\r\n   * @return \t\tthe converted string\r\n   * @see\t\t#unbackQuoteChars(String)\r\n   */\r\n  public static /*@pure@*/ String backQuoteChars(String string) {\r\n\r\n    int index;\r\n    StringBuffer newStringBuffer;\r\n\r\n    // replace each of the following characters with the backquoted version\r\n    char   charsFind[] =    {'\\\\',   '\\'',  '\\t',  '\\n',  '\\r',  '\"',    '%'};\r\n    String charsReplace[] = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\n\", \"\\\\r\", \"\\\\\\\"\", \"\\\\%\"};\r\n    for (int i = 0; i \u003c charsFind.length; i++) {\r\n      if (string.indexOf(charsFind[i]) != -1 ) {\r\n\tnewStringBuffer = new StringBuffer();\r\n\twhile ((index = string.indexOf(charsFind[i])) != -1) {\r\n\t  if (index \u003e 0) {\r\n\t    newStringBuffer.append(string.substring(0, index));\r\n\t  }\r\n\t  newStringBuffer.append(charsReplace[i]);\r\n\t  if ((index + 1) \u003c string.length()) {\r\n\t    string = string.substring(index + 1);\r\n\t  } else {\r\n\t    string = \"\";\r\n\t  }\r\n\t}\r\n\tnewStringBuffer.append(string);\r\n\tstring = newStringBuffer.toString();\r\n      }\r\n    }\r\n\r\n    return string;\r\n  }\r\n\r\n  /**\r\n   * Converts carriage returns and new lines in a string into \\r and \\n.\r\n   *\r\n   * @param string the string\r\n   * @return the converted string\r\n   */\r\n  public static String convertNewLines(String string) {\r\n    int index;\r\n\r\n    // Replace with \\n\r\n    StringBuffer newStringBuffer = new StringBuffer();\r\n    while ((index = string.indexOf('\\n')) != -1) {\r\n      if (index \u003e 0) {\r\n\tnewStringBuffer.append(string.substring(0, index));\r\n      }\r\n      newStringBuffer.append('\\\\');\r\n      newStringBuffer.append('n');\r\n      if ((index + 1) \u003c string.length()) {\r\n\tstring = string.substring(index + 1);\r\n      } else {\r\n\tstring = \"\";\r\n      }\r\n    }\r\n    newStringBuffer.append(string);\r\n    string = newStringBuffer.toString();\r\n\r\n    // Replace with \\r\r\n    newStringBuffer = new StringBuffer();\r\n    while ((index = string.indexOf('\\r')) != -1) {\r\n      if (index \u003e 0) {\r\n\tnewStringBuffer.append(string.substring(0, index));\r\n      }\r\n      newStringBuffer.append('\\\\');\r\n      newStringBuffer.append('r');\r\n      if ((index + 1) \u003c string.length()){\r\n\tstring = string.substring(index + 1);\r\n      } else {\r\n\tstring = \"\";\r\n      }\r\n    }\r\n    newStringBuffer.append(string);\r\n    return newStringBuffer.toString();\r\n  }\r\n\r\n  /**\r\n   * Reverts \\r and \\n in a string into carriage returns and new lines.\r\n   *\r\n   * @param string the string\r\n   * @return the converted string\r\n   */\r\n  public static String revertNewLines(String string) {\r\n    int index;\r\n\r\n    // Replace with \\n\r\n    StringBuffer newStringBuffer = new StringBuffer();\r\n    while ((index = string.indexOf(\"\\\\n\")) != -1) {\r\n      if (index \u003e 0) {\r\n\tnewStringBuffer.append(string.substring(0, index));\r\n      }\r\n      newStringBuffer.append('\\n');\r\n      if ((index + 2) \u003c string.length()) {\r\n\tstring = string.substring(index + 2);\r\n      } else {\r\n\tstring = \"\";\r\n      }\r\n    }\r\n    newStringBuffer.append(string);\r\n    string = newStringBuffer.toString();\r\n\r\n    // Replace with \\r\r\n    newStringBuffer = new StringBuffer();\r\n    while ((index = string.indexOf(\"\\\\r\")) != -1) {\r\n      if (index \u003e 0) {\r\n\tnewStringBuffer.append(string.substring(0, index));\r\n      }\r\n      newStringBuffer.append('\\r');\r\n      if ((index + 2) \u003c string.length()){\r\n\tstring = string.substring(index + 2);\r\n      } else {\r\n\tstring = \"\";\r\n      }\r\n    }\r\n    newStringBuffer.append(string);\r\n\r\n    return newStringBuffer.toString();\r\n  }\r\n\r\n  /**\r\n   * Returns the secondary set of options (if any) contained in\r\n   * the supplied options array. The secondary set is defined to\r\n   * be any options after the first \"--\". These options are removed from\r\n   * the original options array.\r\n   *\r\n   * @param options the input array of options\r\n   * @return the array of secondary options\r\n   */\r\n  public static String[] partitionOptions(String[] options) {\r\n\r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if (options[i].equals(\"--\")) {\r\n\toptions[i++] = \"\";\r\n\tString[] result = new String [options.length - i];\r\n\tfor (int j = i; j \u003c options.length; j++) {\r\n\t  result[j - i] = options[j];\r\n\t  options[j] = \"\";\r\n\t}\r\n\treturn result;\r\n      }\r\n    }\r\n    return new String [0];\r\n  }\r\n\r\n  /**\r\n   * The inverse operation of backQuoteChars().\r\n   * Converts back-quoted carriage returns and new lines in a string\r\n   * to the corresponding character ('\\r' and '\\n').\r\n   * Also \"un\"-back-quotes the following characters: ` \" \\ \\t and %\r\n   *\r\n   * @param string \tthe string\r\n   * @return \t\tthe converted string\r\n   * @see\t\t#backQuoteChars(String)\r\n   */\r\n  public static String unbackQuoteChars(String string) {\r\n\r\n    int index;\r\n    StringBuffer newStringBuffer;\r\n\r\n    // replace each of the following characters with the backquoted version\r\n    String charsFind[]    = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\n\", \"\\\\r\", \"\\\\\\\"\", \"\\\\%\"};\r\n    char   charsReplace[] = {'\\\\',   '\\'',  '\\t',  '\\n',  '\\r',  '\"',    '%'};\r\n    int pos[] = new int[charsFind.length];\r\n    int\tcurPos;\r\n\r\n    String str = new String(string);\r\n    newStringBuffer = new StringBuffer();\r\n    while (str.length() \u003e 0) {\r\n      // get positions and closest character to replace\r\n      curPos = str.length();\r\n      index  = -1;\r\n      for (int i = 0; i \u003c pos.length; i++) {\r\n\tpos[i] = str.indexOf(charsFind[i]);\r\n\tif ( (pos[i] \u003e -1) \u0026\u0026 (pos[i] \u003c curPos) ) {\r\n\t  index  = i;\r\n\t  curPos = pos[i];\r\n\t}\r\n      }\r\n\r\n      // replace character if found, otherwise finished\r\n      if (index == -1) {\r\n\tnewStringBuffer.append(str);\r\n\tstr = \"\";\r\n      }\r\n      else {\r\n\tnewStringBuffer.append(str.substring(0, pos[index]));\r\n\tnewStringBuffer.append(charsReplace[index]);\r\n\tstr = str.substring(pos[index] + charsFind[index].length());\r\n      }\r\n    }\r\n\r\n    return newStringBuffer.toString();\r\n  }\r\n\r\n  /**\r\n   * Split up a string containing options into an array of strings,\r\n   * one for each option.\r\n   *\r\n   * @param \t\tquotedOptionString the string containing the options\r\n   * @return \t\tthe array of options\r\n   * @throws Exception \tin case of an unterminated string, unknown character or\r\n   * \t\t\ta parse error\r\n   */\r\n  public static String[] splitOptions(String quotedOptionString) throws Exception{\r\n\r\n    FastVector optionsVec = new FastVector();\r\n    String str = new String(quotedOptionString);\r\n    int i;\r\n\r\n    while (true){\r\n\r\n      //trimLeft\r\n      i = 0;\r\n      while ((i \u003c str.length()) \u0026\u0026 (Character.isWhitespace(str.charAt(i)))) i++;\r\n      str = str.substring(i);\r\n\r\n      //stop when str is empty\r\n      if (str.length() == 0) break;\r\n\r\n      //if str start with a double quote\r\n      if (str.charAt(0) == '\"'){\r\n\r\n\t//find the first not anti-slached double quote\r\n\ti = 1;\r\n\twhile(i \u003c str.length()){\r\n\t  if (str.charAt(i) == str.charAt(0)) break;\r\n\t  if (str.charAt(i) == '\\\\'){\r\n\t    i += 1;\r\n\t    if (i \u003e= str.length())\r\n\t      throw new Exception(\"String should not finish with \\\\\");\r\n\t  }\r\n\t  i += 1;\r\n\t}\r\n\tif (i \u003e= str.length()) throw new Exception(\"Quote parse error.\");\r\n\r\n\t//add the founded string to the option vector (without quotes)\r\n\tString optStr = str.substring(1,i);\r\n\toptStr = unbackQuoteChars(optStr);\r\n\toptionsVec.addElement(optStr);\r\n\tstr = str.substring(i+1);\r\n      } else {\r\n\t//find first whiteSpace\r\n\ti=0;\r\n\twhile((i \u003c str.length()) \u0026\u0026 (!Character.isWhitespace(str.charAt(i)))) i++;\r\n\r\n\t//add the founded string to the option vector\r\n\tString optStr = str.substring(0,i);\r\n\toptionsVec.addElement(optStr);\r\n\tstr = str.substring(i);\r\n      }\r\n    }\r\n\r\n    //convert optionsVec to an array of String\r\n    String[] options = new String[optionsVec.size()];\r\n    for (i = 0; i \u003c optionsVec.size(); i++) {\r\n      options[i] = (String)optionsVec.elementAt(i);\r\n    }\r\n    return options;\r\n  }\r\n\r\n  /**\r\n   * Joins all the options in an option array into a single string,\r\n   * as might be used on the command line.\r\n   *\r\n   * @param optionArray the array of options\r\n   * @return the string containing all options.\r\n   */\r\n  public static String joinOptions(String[] optionArray) {\r\n\r\n    String optionString = \"\";\r\n    for (int i = 0; i \u003c optionArray.length; i++) {\r\n      if (optionArray[i].equals(\"\")) {\r\n\tcontinue;\r\n      }\r\n      boolean escape = false;\r\n      for (int n = 0; n \u003c optionArray[i].length(); n++) {\r\n\tif (Character.isWhitespace(optionArray[i].charAt(n))) {\r\n\t  escape = true;\r\n\t  break;\r\n\t}\r\n      }\r\n      if (escape) {\r\n\toptionString += '\"' + backQuoteChars(optionArray[i]) + '\"';\r\n      } else {\r\n\toptionString += optionArray[i];\r\n      }\r\n      optionString += \" \";\r\n    }\r\n    return optionString.trim();\r\n  }\r\n\r\n  /**\r\n   * Creates a new instance of an object given it's class name and\r\n   * (optional) arguments to pass to it's setOptions method. If the\r\n   * object implements OptionHandler and the options parameter is\r\n   * non-null, the object will have it's options set. Example use:\u003cp\u003e\r\n   *\r\n   * \u003ccode\u003e \u003cpre\u003e\r\n   * String classifierName = Utils.getOption('W', options);\r\n   * Classifier c = (Classifier)Utils.forName(Classifier.class,\r\n   *                                          classifierName,\r\n   *                                          options);\r\n   * setClassifier(c);\r\n   * \u003c/pre\u003e\u003c/code\u003e\r\n   *\r\n   * @param classType the class that the instantiated object should\r\n   * be assignable to -- an exception is thrown if this is not the case\r\n   * @param className the fully qualified class name of the object\r\n   * @param options an array of options suitable for passing to setOptions. May\r\n   * be null. Any options accepted by the object will be removed from the\r\n   * array.\r\n   * @return the newly created object, ready for use.\r\n   * @exception Exception if the class name is invalid, or if the\r\n   * class is not assignable to the desired class type, or the options\r\n   * supplied are not acceptable to the object\r\n   */\r\n  public static Object forName(Class classType,\r\n\t\t\t       String className,\r\n\t\t\t       String[] options) throws Exception {\r\n\r\n    Class c = null;\r\n    try {\r\n      c = Class.forName(className);\r\n    } catch (Exception ex) {\r\n      throw new Exception(\"Can't find class called: \" + className);\r\n    }\r\n    if (!classType.isAssignableFrom(c)) {\r\n      throw new Exception(classType.getName() + \" is not assignable from \"\r\n\t\t\t  + className);\r\n    }\r\n    Object o = c.newInstance();\r\n    /*if ((o instanceof OptionHandler)\r\n\t\u0026\u0026 (options != null)) {\r\n      ((OptionHandler)o).setOptions(options);\r\n      Utils.checkForRemainingOptions(options);\r\n    }*/\r\n    return o;\r\n  }\r\n\r\n  /**\r\n   * Computes entropy for an array of integers.\r\n   *\r\n   * @param counts array of counts\r\n   * @return - a log2 a - b log2 b - c log2 c + (a+b+c) log2 (a+b+c)\r\n   * when given array [a b c]\r\n   */\r\n  public static /*@pure@*/ double info(int counts[]) {\r\n\r\n    int total = 0;\r\n    double x = 0;\r\n    for (int j = 0; j \u003c counts.length; j++) {\r\n      x -= xlogx(counts[j]);\r\n      total += counts[j];\r\n    }\r\n    return x + xlogx(total);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is smaller or equal to b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n     * @return true if a is smaller or equal to b.\r\n   */\r\n  public static /*@pure@*/ boolean smOrEq(double a,double b) {\r\n\r\n    return (a-b \u003c SMALL);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is greater or equal to b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n     * @return true if a is greater or equal to b.\r\n   */\r\n  public static /*@pure@*/ boolean grOrEq(double a,double b) {\r\n\r\n    return (b-a \u003c SMALL);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is smaller than b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n     * @return true if a is smaller than b.\r\n   */\r\n  public static /*@pure@*/ boolean sm(double a,double b) {\r\n\r\n    return (b-a \u003e SMALL);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is greater than b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n     * @return true  if a is greater than b.\r\n   */\r\n  public static /*@pure@*/ boolean gr(double a,double b) {\r\n\r\n    return (a-b \u003e SMALL);\r\n  }\r\n\r\n  /**\r\n   * Returns the kth-smallest value in the array.\r\n   *\r\n   * @param array the array of integers\r\n   * @param k the value of k\r\n   * @return the kth-smallest value\r\n   */\r\n  public static double kthSmallestValue(int[] array, int k) {\r\n\r\n    int[] index = new int[array.length];\r\n\r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n    }\r\n\r\n    return array[index[select(array, index, 0, array.length - 1, k)]];\r\n  }\r\n\r\n  /**\r\n   * Returns the kth-smallest value in the array\r\n   *\r\n   * @param array the array of double\r\n   * @param k the value of k\r\n   * @return the kth-smallest value\r\n   */\r\n  public static double kthSmallestValue(double[] array, int k) {\r\n\r\n    int[] index = new int[array.length];\r\n\r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n    }\r\n\r\n    return array[index[select(array, index, 0, array.length - 1, k)]];\r\n  }\r\n\r\n  /**\r\n   * Returns the logarithm of a for base 2.\r\n   *\r\n   * @param a \ta double\r\n   * @return\tthe logarithm for base 2\r\n   */\r\n  public static /*@pure@*/ double log2(double a) {\r\n\r\n    return Math.log(a) / log2;\r\n  }\r\n\r\n  /**\r\n   * Returns index of maximum element in a given\r\n   * array of doubles. First maximum is returned.\r\n   *\r\n   * @param doubles the array of doubles\r\n   * @return the index of the maximum element\r\n   */\r\n  public static /*@pure@*/ int maxIndex(double[] doubles) {\r\n\r\n    double maximum = 0;\r\n    int maxIndex = 0;\r\n\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      if ((i == 0) || (doubles[i] \u003e maximum)) {\r\n\tmaxIndex = i;\r\n\tmaximum = doubles[i];\r\n      }\r\n    }\r\n\r\n    return maxIndex;\r\n  }\r\n\r\n  /**\r\n   * Returns index of maximum element in a given\r\n   * array of integers. First maximum is returned.\r\n   *\r\n   * @param ints the array of integers\r\n   * @return the index of the maximum element\r\n   */\r\n  public static /*@pure@*/ int maxIndex(int[] ints) {\r\n\r\n    int maximum = 0;\r\n    int maxIndex = 0;\r\n\r\n    for (int i = 0; i \u003c ints.length; i++) {\r\n      if ((i == 0) || (ints[i] \u003e maximum)) {\r\n\tmaxIndex = i;\r\n\tmaximum = ints[i];\r\n      }\r\n    }\r\n\r\n    return maxIndex;\r\n  }\r\n\r\n  /**\r\n   * Computes the mean for an array of doubles.\r\n   *\r\n   * @param vector the array\r\n   * @return the mean\r\n   */\r\n  public static /*@pure@*/ double mean(double[] vector) {\r\n\r\n    double sum = 0;\r\n\r\n    if (vector.length == 0) {\r\n      return 0;\r\n    }\r\n    for (int i = 0; i \u003c vector.length; i++) {\r\n      sum += vector[i];\r\n    }\r\n    return sum / (double) vector.length;\r\n  }\r\n\r\n  /**\r\n   * Returns index of minimum element in a given\r\n   * array of integers. First minimum is returned.\r\n   *\r\n   * @param ints the array of integers\r\n   * @return the index of the minimum element\r\n   */\r\n  public static /*@pure@*/ int minIndex(int[] ints) {\r\n\r\n    int minimum = 0;\r\n    int minIndex = 0;\r\n\r\n    for (int i = 0; i \u003c ints.length; i++) {\r\n      if ((i == 0) || (ints[i] \u003c minimum)) {\r\n\tminIndex = i;\r\n\tminimum = ints[i];\r\n      }\r\n    }\r\n\r\n    return minIndex;\r\n  }\r\n\r\n  /**\r\n   * Returns index of minimum element in a given\r\n   * array of doubles. First minimum is returned.\r\n   *\r\n   * @param doubles the array of doubles\r\n   * @return the index of the minimum element\r\n   */\r\n  public static /*@pure@*/ int minIndex(double[] doubles) {\r\n\r\n    double minimum = 0;\r\n    int minIndex = 0;\r\n\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      if ((i == 0) || (doubles[i] \u003c minimum)) {\r\n\tminIndex = i;\r\n\tminimum = doubles[i];\r\n      }\r\n    }\r\n\r\n    return minIndex;\r\n  }\r\n\r\n  /**\r\n   * Normalizes the doubles in the array by their sum.\r\n   *\r\n   * @param doubles the array of double\r\n   * @exception IllegalArgumentException if sum is Zero or NaN\r\n   */\r\n  public static void normalize(double[] doubles) {\r\n\r\n    double sum = 0;\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      sum += doubles[i];\r\n    }\r\n    normalize(doubles, sum);\r\n  }\r\n\r\n  /**\r\n   * Normalizes the doubles in the array using the given value.\r\n   *\r\n   * @param doubles the array of double\r\n   * @param sum the value by which the doubles are to be normalized\r\n   * @exception IllegalArgumentException if sum is zero or NaN\r\n   */\r\n  public static void normalize(double[] doubles, double sum) {\r\n\r\n    if (Double.isNaN(sum)) {\r\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is NaN.\");\r\n    }\r\n    if (sum == 0) {\r\n      // Maybe this should just be a return.\r\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is zero.\");\r\n    }\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      doubles[i] /= sum;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts an array containing the natural logarithms of\r\n   * probabilities stored in a vector back into probabilities.\r\n   * The probabilities are assumed to sum to one.\r\n   *\r\n   * @param a an array holding the natural logarithms of the probabilities\r\n   * @return the converted array\r\n   */\r\n  public static double[] logs2probs(double[] a) {\r\n\r\n    double max = a[maxIndex(a)];\r\n    double sum = 0.0;\r\n\r\n    double[] result = new double[a.length];\r\n    for(int i = 0; i \u003c a.length; i++) {\r\n      result[i] = Math.exp(a[i] - max);\r\n      sum += result[i];\r\n    }\r\n\r\n    normalize(result, sum);\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns the log-odds for a given probabilitiy.\r\n   *\r\n   * @param prob the probabilitiy\r\n   *\r\n   * @return the log-odds after the probability has been mapped to\r\n   * [Utils.SMALL, 1-Utils.SMALL]\r\n   */\r\n  public static /*@pure@*/ double probToLogOdds(double prob) {\r\n\r\n    if (gr(prob, 1) || (sm(prob, 0))) {\r\n      throw new IllegalArgumentException(\"probToLogOdds: probability must \" +\r\n\t\t\t\t     \"be in [0,1] \"+prob);\r\n    }\r\n    double p = SMALL + (1.0 - 2 * SMALL) * prob;\r\n    return Math.log(p / (1 - p));\r\n  }\r\n\r\n  /**\r\n   * Rounds a double to the next nearest integer value. The JDK version\r\n   * of it doesn't work properly.\r\n   *\r\n   * @param value the double value\r\n   * @return the resulting integer value\r\n   */\r\n  public static /*@pure@*/ int round(double value) {\r\n\r\n    int roundedValue = value \u003e 0\r\n      ? (int)(value + 0.5)\r\n      : -(int)(Math.abs(value) + 0.5);\r\n\r\n    return roundedValue;\r\n  }\r\n\r\n  /**\r\n   * Rounds a double to the next nearest integer value in a probabilistic\r\n   * fashion (e.g. 0.8 has a 20% chance of being rounded down to 0 and a\r\n   * 80% chance of being rounded up to 1). In the limit, the average of\r\n   * the rounded numbers generated by this procedure should converge to\r\n   * the original double.\r\n   *\r\n   * @param value the double value\r\n   * @param rand the random number generator\r\n   * @return the resulting integer value\r\n   */\r\n  public static int probRound(double value, Random rand) {\r\n\r\n    if (value \u003e= 0) {\r\n      double lower = Math.floor(value);\r\n      double prob = value - lower;\r\n      if (rand.nextDouble() \u003c prob) {\r\n\treturn (int)lower + 1;\r\n      } else {\r\n\treturn (int)lower;\r\n      }\r\n    } else {\r\n      double lower = Math.floor(Math.abs(value));\r\n      double prob = Math.abs(value) - lower;\r\n      if (rand.nextDouble() \u003c prob) {\r\n\treturn -((int)lower + 1);\r\n      } else {\r\n\treturn -(int)lower;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rounds a double to the given number of decimal places.\r\n   *\r\n   * @param value the double value\r\n   * @param afterDecimalPoint the number of digits after the decimal point\r\n   * @return the double rounded to the given precision\r\n   */\r\n  public static /*@pure@*/ double roundDouble(double value,int afterDecimalPoint) {\r\n\r\n    double mask = Math.pow(10.0, (double)afterDecimalPoint);\r\n\r\n    return (double)(Math.round(value * mask)) / mask;\r\n  }\r\n\r\n  /**\r\n   * Sorts a given array of integers in ascending order and returns an\r\n   * array of integers with the positions of the elements of the original\r\n   * array in the sorted array. The sort is stable. (Equal elements remain\r\n   * in their original order.)\r\n   *\r\n   * @param array this array is not changed by the method!\r\n   * @return an array of integers with the positions in the sorted\r\n   * array.\r\n   */\r\n  public static /*@pure@*/ int[] sort(int[] array) {\r\n\r\n    int[] index = new int[array.length];\r\n    int[] newIndex = new int[array.length];\r\n    int[] helpIndex;\r\n    int numEqual;\r\n\r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n    }\r\n    quickSort(array, index, 0, array.length - 1);\r\n\r\n    // Make sort stable\r\n    int i = 0;\r\n    while (i \u003c index.length) {\r\n      numEqual = 1;\r\n      for (int j = i + 1; ((j \u003c index.length)\r\n\t\t\t   \u0026\u0026 (array[index[i]] == array[index[j]]));\r\n\t   j++) {\r\n\tnumEqual++;\r\n      }\r\n      if (numEqual \u003e 1) {\r\n\thelpIndex = new int[numEqual];\r\n\tfor (int j = 0; j \u003c numEqual; j++) {\r\n\t  helpIndex[j] = i + j;\r\n\t}\r\n\tquickSort(index, helpIndex, 0, numEqual - 1);\r\n\tfor (int j = 0; j \u003c numEqual; j++) {\r\n\t  newIndex[i + j] = index[helpIndex[j]];\r\n\t}\r\n\ti += numEqual;\r\n      } else {\r\n\tnewIndex[i] = index[i];\r\n\ti++;\r\n      }\r\n    }\r\n    return newIndex;\r\n  }\r\n\r\n  /**\r\n   * Sorts a given array of doubles in ascending order and returns an\r\n   * array of integers with the positions of the elements of the\r\n   * original array in the sorted array. NOTE THESE CHANGES: the sort\r\n   * is no longer stable and it doesn't use safe floating-point\r\n   * comparisons anymore. Occurrences of Double.NaN are treated as\r\n   * Double.MAX_VALUE\r\n   *\r\n   * @param array this array is not changed by the method!\r\n   * @return an array of integers with the positions in the sorted\r\n   * array.\r\n   */\r\n  public static /*@pure@*/ int[] sort(/*@non_null@*/ double[] array) {\r\n\r\n    int[] index = new int[array.length];\r\n    array = (double[])array.clone();\r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n      if (Double.isNaN(array[i])) {\r\n        array[i] = Double.MAX_VALUE;\r\n      }\r\n    }\r\n    quickSort(array, index, 0, array.length - 1);\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Sorts a given array of doubles in ascending order and returns an\r\n   * array of integers with the positions of the elements of the original\r\n   * array in the sorted array. The sort is stable (Equal elements remain\r\n   * in their original order.) Occurrences of Double.NaN are treated as\r\n   * Double.MAX_VALUE\r\n   *\r\n   * @param array this array is not changed by the method!\r\n   * @return an array of integers with the positions in the sorted\r\n   * array.\r\n   */\r\n  public static /*@pure@*/ int[] stableSort(double[] array){\r\n\r\n    int[] index = new int[array.length];\r\n    int[] newIndex = new int[array.length];\r\n    int[] helpIndex;\r\n    int numEqual;\r\n\r\n    array = (double[])array.clone();\r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n      if (Double.isNaN(array[i])) {\r\n        array[i] = Double.MAX_VALUE;\r\n      }\r\n    }\r\n    quickSort(array,index,0,array.length-1);\r\n\r\n    // Make sort stable\r\n\r\n    int i = 0;\r\n    while (i \u003c index.length) {\r\n      numEqual = 1;\r\n      for (int j = i+1; ((j \u003c index.length) \u0026\u0026 Utils.eq(array[index[i]],\r\n\t\t\t\t\t\t\tarray[index[j]])); j++)\r\n\tnumEqual++;\r\n      if (numEqual \u003e 1) {\r\n\thelpIndex = new int[numEqual];\r\n\tfor (int j = 0; j \u003c numEqual; j++)\r\n\t  helpIndex[j] = i+j;\r\n\tquickSort(index, helpIndex, 0, numEqual-1);\r\n\tfor (int j = 0; j \u003c numEqual; j++)\r\n\t  newIndex[i+j] = index[helpIndex[j]];\r\n\ti += numEqual;\r\n      } else {\r\n\tnewIndex[i] = index[i];\r\n\ti++;\r\n      }\r\n    }\r\n\r\n    return newIndex;\r\n  }\r\n\r\n  /**\r\n   * Computes the variance for an array of doubles.\r\n   *\r\n   * @param vector the array\r\n   * @return the variance\r\n   */\r\n  public static /*@pure@*/ double variance(double[] vector) {\r\n\r\n    double sum = 0, sumSquared = 0;\r\n\r\n    if (vector.length \u003c= 1) {\r\n      return 0;\r\n    }\r\n    for (int i = 0; i \u003c vector.length; i++) {\r\n      sum += vector[i];\r\n      sumSquared += (vector[i] * vector[i]);\r\n    }\r\n    double result = (sumSquared - (sum * sum / (double) vector.length)) /\r\n      (double) (vector.length - 1);\r\n\r\n    // We don't like negative variance\r\n    if (result \u003c 0) {\r\n      return 0;\r\n    } else {\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Computes the sum of the elements of an array of doubles.\r\n   *\r\n   * @param doubles the array of double\r\n   * @return the sum of the elements\r\n   */\r\n  public static /*@pure@*/ double sum(double[] doubles) {\r\n\r\n    double sum = 0;\r\n\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      sum += doubles[i];\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * Computes the sum of the elements of an array of integers.\r\n   *\r\n   * @param ints the array of integers\r\n   * @return the sum of the elements\r\n   */\r\n  public static /*@pure@*/ int sum(int[] ints) {\r\n\r\n    int sum = 0;\r\n\r\n    for (int i = 0; i \u003c ints.length; i++) {\r\n      sum += ints[i];\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * Returns c*log2(c) for a given integer value c.\r\n   *\r\n   * @param c an integer value\r\n   * @return c*log2(c) (but is careful to return 0 if c is 0)\r\n   */\r\n  public static /*@pure@*/ double xlogx(int c) {\r\n\r\n    if (c == 0) {\r\n      return 0.0;\r\n    }\r\n    return c * Utils.log2((double) c);\r\n  }\r\n\r\n  /**\r\n   * Partitions the instances around a pivot. Used by quicksort and\r\n   * kthSmallestValue.\r\n   *\r\n   * @param array the array of doubles to be sorted\r\n   * @param index the index into the array of doubles\r\n   * @param l the first index of the subset\r\n   * @param r the last index of the subset\r\n   *\r\n   * @return the index of the middle element\r\n   */\r\n  private static int partition(double[] array, int[] index, int l, int r) {\r\n\r\n    double pivot = array[index[(l + r) / 2]];\r\n    int help;\r\n\r\n    while (l \u003c r) {\r\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\r\n        l++;\r\n      }\r\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\r\n        r--;\r\n      }\r\n      if (l \u003c r) {\r\n        help = index[l];\r\n        index[l] = index[r];\r\n        index[r] = help;\r\n        l++;\r\n        r--;\r\n      }\r\n    }\r\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\r\n      r--;\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n  /**\r\n   * Partitions the instances around a pivot. Used by quicksort and\r\n   * kthSmallestValue.\r\n   *\r\n   * @param array the array of integers to be sorted\r\n   * @param index the index into the array of integers\r\n   * @param l the first index of the subset\r\n   * @param r the last index of the subset\r\n   *\r\n   * @return the index of the middle element\r\n   */\r\n  private static int partition(int[] array, int[] index, int l, int r) {\r\n\r\n    double pivot = array[index[(l + r) / 2]];\r\n    int help;\r\n\r\n    while (l \u003c r) {\r\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\r\n        l++;\r\n      }\r\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\r\n        r--;\r\n      }\r\n      if (l \u003c r) {\r\n        help = index[l];\r\n        index[l] = index[r];\r\n        index[r] = help;\r\n        l++;\r\n        r--;\r\n      }\r\n    }\r\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\r\n      r--;\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n  /**\r\n   * Implements quicksort according to Manber's \"Introduction to\r\n   * Algorithms\".\r\n   *\r\n   * @param array the array of doubles to be sorted\r\n   * @param index the index into the array of doubles\r\n   * @param left the first index of the subset to be sorted\r\n   * @param right the last index of the subset to be sorted\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r\n  //@ requires array != index;\r\n  //  assignable index;\r\n  private static void quickSort(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index,\r\n                                int left, int right) {\r\n\r\n    if (left \u003c right) {\r\n      int middle = partition(array, index, left, right);\r\n      quickSort(array, index, left, middle);\r\n      quickSort(array, index, middle + 1, right);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Implements quicksort according to Manber's \"Introduction to\r\n   * Algorithms\".\r\n   *\r\n   * @param array the array of integers to be sorted\r\n   * @param index the index into the array of integers\r\n   * @param left the first index of the subset to be sorted\r\n   * @param right the last index of the subset to be sorted\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r\n  //@ requires array != index;\r\n  //  assignable index;\r\n  private static void quickSort(/*@non_null@*/ int[] array, /*@non_null@*/  int[] index,\r\n                                int left, int right) {\r\n\r\n    if (left \u003c right) {\r\n      int middle = partition(array, index, left, right);\r\n      quickSort(array, index, left, middle);\r\n      quickSort(array, index, middle + 1, right);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Implements computation of the kth-smallest element according\r\n   * to Manber's \"Introduction to Algorithms\".\r\n   *\r\n   * @param array the array of double\r\n   * @param index the index into the array of doubles\r\n   * @param left the first index of the subset\r\n   * @param right the last index of the subset\r\n   * @param k the value of k\r\n   *\r\n   * @return the index of the kth-smallest element\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  private static int select(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index,\r\n                            int left, int right, int k) {\r\n\r\n    if (left == right) {\r\n      return left;\r\n    } else {\r\n      int middle = partition(array, index, left, right);\r\n      if ((middle - left + 1) \u003e= k) {\r\n        return select(array, index, left, middle, k);\r\n      } else {\r\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts a File's absolute path to a path relative to the user\r\n   * (ie start) directory. Includes an additional workaround for Cygwin, which\r\n   * doesn't like upper case drive letters.\r\n   * @param absolute the File to convert to relative path\r\n   * @return a File with a path that is relative to the user's directory\r\n   * @exception Exception if the path cannot be constructed\r\n   */\r\n  public static File convertToRelativePath(File absolute) throws Exception {\r\n    File        result;\r\n    String      fileStr;\r\n\r\n    result = null;\r\n\r\n    // if we're running windows, it could be Cygwin\r\n    if (File.separator.equals(\"\\\\\")) {\r\n      // Cygwin doesn't like upper case drives -\u003e try lower case drive\r\n      try {\r\n        fileStr = absolute.getPath();\r\n        fileStr =   fileStr.substring(0, 1).toLowerCase()\r\n                  + fileStr.substring(1);\r\n        result = createRelativePath(new File(fileStr));\r\n      }\r\n      catch (Exception e) {\r\n        // no luck with Cygwin workaround, convert it like it is\r\n        result = createRelativePath(absolute);\r\n      }\r\n    }\r\n    else {\r\n      result = createRelativePath(absolute);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Converts a File's absolute path to a path relative to the user\r\n   * (ie start) directory.\r\n   *\r\n   * @param absolute the File to convert to relative path\r\n   * @return a File with a path that is relative to the user's directory\r\n   * @exception Exception if the path cannot be constructed\r\n   */\r\n  protected static File createRelativePath(File absolute) throws Exception {\r\n    File userDir = new File(System.getProperty(\"user.dir\"));\r\n    String userPath = userDir.getAbsolutePath() + File.separator;\r\n    String targetPath = (new File(absolute.getParent())).getPath()\r\n      + File.separator;\r\n    String fileName = absolute.getName();\r\n    StringBuffer relativePath = new StringBuffer();\r\n    //    relativePath.append(\".\"+File.separator);\r\n    //    System.err.println(\"User dir \"+userPath);\r\n    //    System.err.println(\"Target path \"+targetPath);\r\n\r\n    // file is in user dir (or subdir)\r\n    int subdir = targetPath.indexOf(userPath);\r\n    if (subdir == 0) {\r\n      if (userPath.length() == targetPath.length()) {\r\n\trelativePath.append(fileName);\r\n      } else {\r\n\tint ll = userPath.length();\r\n\trelativePath.append(targetPath.substring(ll));\r\n\trelativePath.append(fileName);\r\n      }\r\n    } else {\r\n      int sepCount = 0;\r\n      String temp = new String(userPath);\r\n      while (temp.indexOf(File.separator) != -1) {\r\n\tint ind = temp.indexOf(File.separator);\r\n\tsepCount++;\r\n\ttemp = temp.substring(ind+1, temp.length());\r\n      }\r\n\r\n      String targetTemp = new String(targetPath);\r\n      String userTemp = new String(userPath);\r\n      int tcount = 0;\r\n      while (targetTemp.indexOf(File.separator) != -1) {\r\n\tint ind = targetTemp.indexOf(File.separator);\r\n\tint ind2 = userTemp.indexOf(File.separator);\r\n\tString tpart = targetTemp.substring(0,ind+1);\r\n\tString upart = userTemp.substring(0,ind2+1);\r\n\tif (tpart.compareTo(upart) != 0) {\r\n\t  if (tcount == 0) {\r\n\t    tcount = -1;\r\n\t  }\r\n\t  break;\r\n\t}\r\n\ttcount++;\r\n\ttargetTemp = targetTemp.substring(ind+1, targetTemp.length());\r\n\tuserTemp = userTemp.substring(ind2+1, userTemp.length());\r\n      }\r\n      if (tcount == -1) {\r\n\t// then target file is probably on another drive (under windows)\r\n\tthrow new Exception(\"Can't construct a path to file relative to user \"\r\n\t\t\t    +\"dir.\");\r\n      }\r\n      if (targetTemp.indexOf(File.separator) == -1) {\r\n\ttargetTemp = \"\";\r\n      }\r\n      for (int i = 0; i \u003c sepCount - tcount; i++) {\r\n\trelativePath.append(\"..\"+File.separator);\r\n      }\r\n      relativePath.append(targetTemp + fileName);\r\n    }\r\n    //    System.err.println(\"new path : \"+relativePath.toString());\r\n    return new File(relativePath.toString());\r\n  }\r\n\r\n  /**\r\n   * Implements computation of the kth-smallest element according\r\n   * to Manber's \"Introduction to Algorithms\".\r\n   *\r\n   * @param array the array of integers\r\n   * @param index the index into the array of integers\r\n   * @param left the first index of the subset\r\n   * @param right the last index of the subset\r\n   * @param k the value of k\r\n   *\r\n   * @return the index of the kth-smallest element\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  private static int select(/*@non_null@*/ int[] array, /*@non_null@*/ int[] index,\r\n                            int left, int right, int k) {\r\n\r\n    if (left == right) {\r\n      return left;\r\n    } else {\r\n      int middle = partition(array, index, left, right);\r\n      if ((middle - left + 1) \u003e= k) {\r\n        return select(array, index, left, middle, k);\r\n      } else {\r\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\n",
        "name": "Utils.java",
        "path": "src/keel/Algorithms/Fuzzy_Rule_Learning/Hybrid/FURIA/core/Utils.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/Fuzzy_Rule_Learning/Hybrid/FURIA/core/Utils.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 1703,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1704,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1705,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1726,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1727,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1728,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1752,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1888,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "/***********************************************************************\r\n\r\n\tThis file is part of KEEL-software, the Data Mining tool for regression, \r\n\tclassification, clustering, pattern mining and so on.\r\n\r\n\tCopyright (C) 2004-2010\r\n\t\r\n\tF. Herrera (herrera@decsai.ugr.es)\r\n    L. Sánchez (luciano@uniovi.es)\r\n    J. Alcalá-Fdez (jalcala@decsai.ugr.es)\r\n    S. García (sglopez@ujaen.es)\r\n    A. Fernández (alberto.fernandez@ujaen.es)\r\n    J. Luengo (julianlm@decsai.ugr.es)\r\n\r\n\tThis program is free software: you can redistribute it and/or modify\r\n\tit under the terms of the GNU General Public License as published by\r\n\tthe Free Software Foundation, either version 3 of the License, or\r\n\t(at your option) any later version.\r\n\r\n\tThis program is distributed in the hope that it will be useful,\r\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\tGNU General Public License for more details.\r\n\r\n\tYou should have received a copy of the GNU General Public License\r\n\talong with this program.  If not, see http://www.gnu.org/licenses/\r\n  \r\n**********************************************************************/\r\n\r\n/*\r\n *    This program is free software; you can redistribute it and/or modify\r\n *    it under the terms of the GNU General Public License as published by\r\n *    the Free Software Foundation; either version 2 of the License, or\r\n *    (at your option) any later version.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU General Public License\r\n *    along with this program; if not, write to the Free Software\r\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\r\n */\r\n\r\n/*\r\n *    Utils.java\r\n *    Copyright (C) 1999-2004 University of Waikato, Hamilton, New Zealand\r\n *\r\n */\r\n\r\npackage keel.Algorithms.Statistical_Classifiers.Logistic.core;\r\n\r\nimport java.lang.Math;\r\nimport java.lang.reflect.Array;\r\nimport java.util.Properties;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.util.Random;\r\n\r\n/**\r\n * Class implementing some simple utility methods.\r\n *\r\n * @author Eibe Frank \r\n * @author Yong Wang \r\n * @author Len Trigg \r\n * @author Julien Prados\r\n * @version $Revision: 1.1 $\r\n */\r\npublic final class Utils {\r\n\r\n  /** The natural logarithm of 2. */\r\n  public static double log2 = Math.log(2);\r\n\r\n  /** The small deviation allowed in double comparisons */\r\n  public static double SMALL = 1e-6;\r\n\r\n  \r\n  /**\r\n   * Reads properties that inherit from three locations. Properties\r\n   * are first defined in the system resource location (i.e. in the\r\n   * CLASSPATH).  These default properties must exist. Properties\r\n   * defined in the users home directory (optional) override default\r\n   * settings. Properties defined in the current directory (optional)\r\n   * override all these settings.\r\n   *\r\n   * @param resourceName the location of the resource that should be\r\n   * loaded.  e.g.: \"keel.Algorithms.Statistical_Classifiers.Logistic.core/Utils.props\". (The use of hardcoded\r\n   * forward slashes here is OK - see\r\n   * jdk1.1/docs/guide/misc/resources.html) This routine will also\r\n   * look for the file (in this case) \"Utils.props\" in the users home\r\n   * directory and the current directory.\r\n   * @return the Properties\r\n   * @exception Exception if no default properties are defined, or if\r\n   * an error occurs reading the properties files.  \r\n   */\r\n  public static Properties readProperties(String resourceName)\r\n    throws Exception {\r\n\r\n    Properties defaultProps = new Properties();\r\n    try {\r\n      // Apparently hardcoded slashes are OK here\r\n      // jdk1.1/docs/guide/misc/resources.html\r\n      defaultProps.load(ClassLoader.getSystemResourceAsStream(resourceName));\r\n    } catch (Exception ex) {\r\n/*      throw new Exception(\"Problem reading default properties: \"\r\n\t+ ex.getMessage()); */\r\n      System.err.println(\"Warning, unable to load properties file from \"\r\n\t\t\t +\"system resource (Utils.java)\");\r\n    }\r\n\r\n    // Hardcoded slash is OK here\r\n    // eg: see jdk1.1/docs/guide/misc/resources.html\r\n    int slInd = resourceName.lastIndexOf('/');\r\n    if (slInd != -1) {\r\n      resourceName = resourceName.substring(slInd + 1);\r\n    }\r\n\r\n    // Allow a properties file in the home directory to override\r\n    Properties userProps = new Properties(defaultProps);    \r\n    File propFile = new File(System.getProperties().getProperty(\"user.home\")\r\n                             + File.separatorChar\r\n                             + resourceName);\r\n    if (propFile.exists()) {\r\n      try {\r\n        userProps.load(new FileInputStream(propFile));\r\n      } catch (Exception ex) {\r\n        throw new Exception(\"Problem reading user properties: \" + propFile);\r\n      }\r\n    }\r\n\r\n    // Allow a properties file in the current directory to override\r\n    Properties localProps = new Properties(userProps);\r\n    propFile = new File(resourceName);\r\n    if (propFile.exists()) {\r\n      try {\r\n        localProps.load(new FileInputStream(propFile));\r\n      } catch (Exception ex) {\r\n        throw new Exception(\"Problem reading local properties: \" + propFile);\r\n      }\r\n    }\r\n    \r\n    return localProps;\r\n  }\r\n\r\n  /**\r\n   * Returns the correlation coefficient of two double vectors.\r\n   *\r\n   * @param y1 double vector 1\r\n   * @param y2 double vector 2\r\n   * @param n the length of two double vectors\r\n   * @return the correlation coefficient\r\n   */\r\n  public static final double correlation(double y1[],double y2[],int n) {\r\n\r\n    int i;\r\n    double av1 = 0.0, av2 = 0.0, y11 = 0.0, y22 = 0.0, y12 = 0.0, c;\r\n    \r\n    if (n \u003c= 1) {\r\n      return 1.0;\r\n    }\r\n    for (i = 0; i \u003c n; i++) {\r\n      av1 += y1[i];\r\n      av2 += y2[i];\r\n    }\r\n    av1 /= (double) n;\r\n    av2 /= (double) n;\r\n    for (i = 0; i \u003c n; i++) {\r\n      y11 += (y1[i] - av1) * (y1[i] - av1);\r\n      y22 += (y2[i] - av2) * (y2[i] - av2);\r\n      y12 += (y1[i] - av1) * (y2[i] - av2);\r\n    }\r\n    if (y11 * y22 == 0.0) {\r\n      c=1.0;\r\n    } else {\r\n      c = y12 / Math.sqrt(Math.abs(y11 * y22));\r\n    }\r\n    \r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * Removes all occurrences of a string from another string.\r\n   *\r\n   * @param inString the string to remove substrings from.\r\n   * @param substring the substring to remove.\r\n   * @return the input string with occurrences of substring removed.\r\n   */\r\n  public static String removeSubstring(String inString, String substring) {\r\n\r\n    StringBuffer result = new StringBuffer();\r\n    int oldLoc = 0, loc = 0;\r\n    while ((loc = inString.indexOf(substring, oldLoc))!= -1) {\r\n      result.append(inString.substring(oldLoc, loc));\r\n      oldLoc = loc + substring.length();\r\n    }\r\n    result.append(inString.substring(oldLoc));\r\n    return result.toString();\r\n  }\r\n\r\n  /**\r\n   * Replaces with a new string, all occurrences of a string from \r\n   * another string.\r\n   *\r\n   * @param inString the string to replace substrings in.\r\n   * @param subString the substring to replace.\r\n   * @param replaceString the replacement substring\r\n   * @return the input string with occurrences of substring replaced.\r\n   */\r\n  public static String replaceSubstring(String inString, String subString,\r\n\t\t\t\t\tString replaceString) {\r\n\r\n    StringBuffer result = new StringBuffer();\r\n    int oldLoc = 0, loc = 0;\r\n    while ((loc = inString.indexOf(subString, oldLoc))!= -1) {\r\n      result.append(inString.substring(oldLoc, loc));\r\n      result.append(replaceString);\r\n      oldLoc = loc + subString.length();\r\n    }\r\n    result.append(inString.substring(oldLoc));\r\n    return result.toString();\r\n  }\r\n\r\n\r\n  /**\r\n   * Pads a string to a specified length, inserting spaces on the left\r\n   * as required. If the string is too long, characters are removed (from\r\n   * the right).\r\n   *\r\n   * @param inString the input string\r\n   * @param length the desired length of the output string\r\n   * @return the output string\r\n   */\r\n  public static String padLeft(String inString, int length) {\r\n\r\n    return fixStringLength(inString, length, false);\r\n  }\r\n  \r\n  /**\r\n   * Pads a string to a specified length, inserting spaces on the right\r\n   * as required. If the string is too long, characters are removed (from\r\n   * the right).\r\n   *\r\n   * @param inString the input string\r\n   * @param length the desired length of the output string\r\n   * @return the output string\r\n   */\r\n  public static String padRight(String inString, int length) {\r\n\r\n    return fixStringLength(inString, length, true);\r\n  }\r\n  \r\n  /**\r\n   * Pads a string to a specified length, inserting spaces as\r\n   * required. If the string is too long, characters are removed (from\r\n   * the right).\r\n   *\r\n   * @param inString the input string\r\n   * @param length the desired length of the output string\r\n   * @param right true if inserted spaces should be added to the right\r\n   * @return the output string\r\n   */\r\n  private static /*@pure@*/ String fixStringLength(String inString, int length,\r\n\t\t\t\t\tboolean right) {\r\n\r\n    if (inString.length() \u003c length) {\r\n      while (inString.length() \u003c length) {\r\n\tinString = (right ? inString.concat(\" \") : \" \".concat(inString));\r\n      }\r\n    } else if (inString.length() \u003e length) {\r\n      inString = inString.substring(0, length);\r\n    }\r\n    return inString;\r\n  }\r\n \r\n  /**\r\n   * Rounds a double and converts it into String.\r\n   *\r\n   * @param value the double value\r\n   * @param afterDecimalPoint the (maximum) number of digits permitted\r\n   * after the decimal point\r\n   * @return the double as a formatted string\r\n   */\r\n  public static /*@pure@*/ String doubleToString(double value, int afterDecimalPoint) {\r\n    \r\n    StringBuffer stringBuffer;\r\n    double temp;\r\n    int dotPosition;\r\n    long precisionValue;\r\n    \r\n    temp = value * Math.pow(10.0, afterDecimalPoint);\r\n    if (Math.abs(temp) \u003c Long.MAX_VALUE) {\r\n      precisionValue = \t(temp \u003e 0) ? (long)(temp + 0.5) \r\n                                   : -(long)(Math.abs(temp) + 0.5);\r\n      if (precisionValue == 0) {\r\n\tstringBuffer = new StringBuffer(String.valueOf(0));\r\n      } else {\r\n\tstringBuffer = new StringBuffer(String.valueOf(precisionValue));\r\n      }\r\n      if (afterDecimalPoint == 0) {\r\n\treturn stringBuffer.toString();\r\n      }\r\n      dotPosition = stringBuffer.length() - afterDecimalPoint;\r\n      while (((precisionValue \u003c 0) \u0026\u0026 (dotPosition \u003c 1)) ||\r\n\t     (dotPosition \u003c 0)) {\r\n\tif (precisionValue \u003c 0) {\r\n\t  stringBuffer.insert(1, '0');\r\n\t} else {\r\n\t  stringBuffer.insert(0, '0');\r\n\t}\r\n\tdotPosition++;\r\n      }\r\n      stringBuffer.insert(dotPosition, '.');\r\n      if ((precisionValue \u003c 0) \u0026\u0026 (stringBuffer.charAt(1) == '.')) {\r\n\tstringBuffer.insert(1, '0');\r\n      } else if (stringBuffer.charAt(0) == '.') {\r\n\tstringBuffer.insert(0, '0');\r\n      }\r\n      int currentPos = stringBuffer.length() - 1;\r\n      while ((currentPos \u003e dotPosition) \u0026\u0026\r\n\t     (stringBuffer.charAt(currentPos) == '0')) {\r\n\tstringBuffer.setCharAt(currentPos--, ' ');\r\n      }\r\n      if (stringBuffer.charAt(currentPos) == '.') {\r\n\tstringBuffer.setCharAt(currentPos, ' ');\r\n      }\r\n      \r\n      return stringBuffer.toString().trim();\r\n    }\r\n    return new String(\"\" + value);\r\n  }\r\n\r\n  /**\r\n   * Rounds a double and converts it into a formatted decimal-justified String.\r\n   * Trailing 0's are replaced with spaces.\r\n   *\r\n   * @param value the double value\r\n   * @param width the width of the string\r\n   * @param afterDecimalPoint the number of digits after the decimal point\r\n   * @return the double as a formatted string\r\n   */\r\n  public static /*@pure@*/ String doubleToString(double value, int width,\r\n\t\t\t\t      int afterDecimalPoint) {\r\n    \r\n    String tempString = doubleToString(value, afterDecimalPoint);\r\n    char[] result;\r\n    int dotPosition;\r\n\r\n    if ((afterDecimalPoint \u003e= width) \r\n        || (tempString.indexOf('E') != -1)) { // Protects sci notation\r\n      return tempString;\r\n    }\r\n\r\n    // Initialize result\r\n    result = new char[width];\r\n    for (int i = 0; i \u003c result.length; i++) {\r\n      result[i] = ' ';\r\n    }\r\n\r\n    if (afterDecimalPoint \u003e 0) {\r\n      // Get position of decimal point and insert decimal point\r\n      dotPosition = tempString.indexOf('.');\r\n      if (dotPosition == -1) {\r\n\tdotPosition = tempString.length();\r\n      } else {\r\n\tresult[width - afterDecimalPoint - 1] = '.';\r\n      }\r\n    } else {\r\n      dotPosition = tempString.length();\r\n    }\r\n    \r\n\r\n    int offset = width - afterDecimalPoint - dotPosition;\r\n    if (afterDecimalPoint \u003e 0) {\r\n      offset--;\r\n    }\r\n\r\n    // Not enough room to decimal align within the supplied width\r\n    if (offset \u003c 0) {\r\n      return tempString;\r\n    }\r\n\r\n    // Copy characters before decimal point\r\n    for (int i = 0; i \u003c dotPosition; i++) {\r\n      result[offset + i] = tempString.charAt(i);\r\n    }\r\n\r\n    // Copy characters after decimal point\r\n    for (int i = dotPosition + 1; i \u003c tempString.length(); i++) {\r\n      result[offset + i] = tempString.charAt(i);\r\n    }\r\n\r\n    return new String(result);\r\n  }\r\n\r\n  /**\r\n   * Returns the basic class of an array class (handles multi-dimensional\r\n   * arrays).\r\n   * @param c        the array to inspect\r\n   * @return         the class of the innermost elements\r\n   */\r\n  public static Class getArrayClass(Class c) {\r\n     if (c.getComponentType().isArray())\r\n        return getArrayClass(c.getComponentType());\r\n     else\r\n        return c.getComponentType();\r\n  }\r\n\r\n  /**\r\n   * Returns the dimensions of the given array. Even though the\r\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\r\n   * int[3] or double[2][4].\r\n   *\r\n   * @param array       the array to determine the dimensions for\r\n   * @return            the dimensions of the array\r\n   */\r\n  public static int getArrayDimensions(Class array) {\r\n    if (array.getComponentType().isArray())\r\n      return 1 + getArrayDimensions(array.getComponentType());\r\n    else\r\n      return 1;\r\n  }\r\n\r\n  /**\r\n   * Returns the dimensions of the given array. Even though the\r\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\r\n   * int[3] or double[2][4].\r\n   *\r\n   * @param array       the array to determine the dimensions for\r\n   * @return            the dimensions of the array\r\n   */\r\n  public static int getArrayDimensions(Object array) {\r\n    return getArrayDimensions(array.getClass());\r\n  }\r\n\r\n  /**\r\n   * Returns the given Array in a string representation. Even though the\r\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\r\n   * int[3] or double[2][4].\r\n   * \r\n   * @param array       the array to return in a string representation\r\n   * @return            the array as string\r\n   */\r\n  public static String arrayToString(Object array) {\r\n    String        result;\r\n    int           dimensions;\r\n    int           i;       \r\n\r\n    result     = \"\";\r\n    dimensions = getArrayDimensions(array);\r\n    \r\n    if (dimensions == 0) {\r\n      result = \"null\";\r\n    }\r\n    else if (dimensions == 1) {\r\n      for (i = 0; i \u003c Array.getLength(array); i++) {\r\n        if (i \u003e 0)\r\n          result += \",\";\r\n        if (Array.get(array, i) == null)\r\n          result += \"null\";\r\n        else\r\n          result += Array.get(array, i).toString();\r\n      }\r\n    }\r\n    else {\r\n      for (i = 0; i \u003c Array.getLength(array); i++) {\r\n        if (i \u003e 0)\r\n          result += \",\";\r\n        result += \"[\" + arrayToString(Array.get(array, i)) + \"]\";\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Tests if a is equal to b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n     * @return True if a is equal to b. \r\n   */\r\n  public static /*@pure@*/ boolean eq(double a, double b){\r\n    \r\n    return (a - b \u003c SMALL) \u0026\u0026 (b - a \u003c SMALL); \r\n  }\r\n\r\n  /**\r\n   * Checks if the given array contains any non-empty options.\r\n   *\r\n   * @param options an array of strings\r\n   * @exception Exception if there are any non-empty options\r\n   */\r\n  public static void checkForRemainingOptions(String[] options) \r\n    throws Exception {\r\n    \r\n    int illegalOptionsFound = 0;\r\n    StringBuffer text = new StringBuffer();\r\n\r\n    if (options == null) {\r\n      return;\r\n    }\r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if (options[i].length() \u003e 0) {\r\n\tillegalOptionsFound++;\r\n\ttext.append(options[i] + ' ');\r\n      }\r\n    }\r\n    if (illegalOptionsFound \u003e 0) {\r\n      throw new Exception(\"Illegal options: \" + text);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Checks if the given array contains the flag \"-Char\". Stops\r\n   * searching at the first marker \"--\". If the flag is found,\r\n   * it is replaced with the empty string.\r\n   *\r\n   * @param flag the character indicating the flag.\r\n   * @param options the array of strings containing all the options.\r\n   * @return true if the flag was found\r\n   * @exception Exception if an illegal option was found\r\n   */\r\n  public static boolean getFlag(char flag, String[] options) \r\n    throws Exception {\r\n    \r\n    return getFlag(\"\" + flag, options);\r\n  }\r\n  \r\n  /**\r\n   * Checks if the given array contains the flag \"-String\". Stops\r\n   * searching at the first marker \"--\". If the flag is found,\r\n   * it is replaced with the empty string.\r\n   *\r\n   * @param flag the String indicating the flag.\r\n   * @param options the array of strings containing all the options.\r\n   * @return true if the flag was found\r\n   * @exception Exception if an illegal option was found\r\n   */\r\n  public static boolean getFlag(String flag, String[] options) \r\n    throws Exception {\r\n    \r\n    int pos = getOptionPos(flag, options);\r\n\r\n    if (pos \u003e -1)\r\n      options[pos] = \"\";\r\n    \r\n    return (pos \u003e -1);\r\n  }\r\n\r\n  /**\r\n   * Gets an option indicated by a flag \"-Char\" from the given array\r\n   * of strings. Stops searching at the first marker \"--\". Replaces \r\n   * flag and option with empty strings.\r\n   *\r\n   * @param flag the character indicating the option.\r\n   * @param options the array of strings containing all the options.\r\n   * @return the indicated option or an empty string\r\n   * @exception Exception if the option indicated by the flag can't be found\r\n   */\r\n  public static /*@non_null@*/ String getOption(char flag, String[] options) \r\n    throws Exception {\r\n    \r\n    return getOption(\"\" + flag, options);\r\n  }\r\n\r\n  /**\r\n   * Gets an option indicated by a flag \"-String\" from the given array\r\n   * of strings. Stops searching at the first marker \"--\". Replaces \r\n   * flag and option with empty strings.\r\n   *\r\n   * @param flag the String indicating the option.\r\n   * @param options the array of strings containing all the options.\r\n   * @return the indicated option or an empty string\r\n   * @exception Exception if the option indicated by the flag can't be found\r\n   */\r\n  public static /*@non_null@*/ String getOption(String flag, String[] options) \r\n    throws Exception {\r\n\r\n    String newString;\r\n    int i = getOptionPos(flag, options);\r\n\r\n    if (i \u003e -1) {\r\n      if (options[i].equals(\"-\" + flag)) {\r\n\tif (i + 1 == options.length) {\r\n\t  throw new Exception(\"No value given for -\" + flag + \" option.\");\r\n\t}\r\n\toptions[i] = \"\";\r\n\tnewString = new String(options[i + 1]);\r\n\toptions[i + 1] = \"\";\r\n\treturn newString;\r\n      }\r\n      if (options[i].charAt(1) == '-') {\r\n\treturn \"\";\r\n      }\r\n    }\r\n    \r\n    return \"\";\r\n  }\r\n\r\n  /**\r\n   * Gets the index of an option or flag indicated by a flag \"-Char\" from \r\n   * the given array of strings. Stops searching at the first marker \"--\".\r\n   *\r\n   * @param flag \tthe character indicating the option.\r\n   * @param options \tthe array of strings containing all the options.\r\n   * @return \t\tthe position if found, or -1 otherwise\r\n   */\r\n  public static int getOptionPos(char flag, String[] options) {\r\n     return getOptionPos(\"\" + flag, options);\r\n  }\r\n\r\n  /**\r\n   * Gets the index of an option or flag indicated by a flag \"-String\" from \r\n   * the given array of strings. Stops searching at the first marker \"--\".\r\n   *\r\n   * @param flag \tthe String indicating the option.\r\n   * @param options \tthe array of strings containing all the options.\r\n   * @return \t\tthe position if found, or -1 otherwise\r\n   */\r\n  public static int getOptionPos(String flag, String[] options) {\r\n    if (options == null)\r\n      return -1;\r\n    \r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if ((options[i].length() \u003e 0) \u0026\u0026 (options[i].charAt(0) == '-')) {\r\n\t// Check if it is a negative number\r\n\ttry {\r\n\t  Double.valueOf(options[i]);\r\n\t} \r\n\tcatch (NumberFormatException e) {\r\n\t  // found?\r\n\t  if (options[i].equals(\"-\" + flag))\r\n\t    return i;\r\n\t  // did we reach \"--\"?\r\n\t  if (options[i].charAt(1) == '-')\r\n\t    return -1;\r\n\t}\r\n      }\r\n    }\r\n    \r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Quotes a string if it contains special characters.\r\n   * \r\n   * The following rules are applied:\r\n   *\r\n   * A character is backquoted version of it is one \r\n   * of \u003ctt\u003e\" ' % \\ \\n \\r \\t\u003c/tt\u003e.\r\n   *\r\n   * A string is enclosed within single quotes if a character has been\r\n   * backquoted using the previous rule above or contains \r\n   * \u003ctt\u003e{ }\u003c/tt\u003e or is exactly equal to the strings \r\n   * \u003ctt\u003e, ? space or \"\"\u003c/tt\u003e (empty string).\r\n   *\r\n   * A quoted question mark distinguishes it from the missing value which\r\n   * is represented as an unquoted question mark in arff files.\r\n   *\r\n   * @param string \tthe string to be quoted\r\n   * @return \t\tthe string (possibly quoted)\r\n   * @see\t\t#unquote(String)\r\n   */\r\n  public static /*@pure@*/ String quote(String string) {\r\n      boolean quote = false;\r\n\r\n      // backquote the following characters \r\n      if ((string.indexOf('\\n') != -1) || (string.indexOf('\\r') != -1) || \r\n\t  (string.indexOf('\\'') != -1) || (string.indexOf('\"') != -1) || \r\n\t  (string.indexOf('\\\\') != -1) || \r\n\t  (string.indexOf('\\t') != -1) || (string.indexOf('%') != -1)) {\r\n\t  string = backQuoteChars(string);\r\n\t  quote = true;\r\n      }\r\n\r\n      // Enclose the string in 's if the string contains a recently added\r\n      // backquote or contains one of the following characters.\r\n      if((quote == true) || \r\n\t (string.indexOf('{') != -1) || (string.indexOf('}') != -1) ||\r\n\t (string.indexOf(',') != -1) || (string.equals(\"?\")) ||\r\n\t (string.indexOf(' ') != -1) || (string.equals(\"\"))) {\r\n\t  string = (\"'\".concat(string)).concat(\"'\");\r\n      }\r\n\r\n      return string;\r\n  }\r\n\r\n  /**\r\n   * unquotes are previously quoted string (but only if necessary), i.e., it\r\n   * removes the single quotes around it. Inverse to quote(String).\r\n   * \r\n   * @param string\tthe string to process\r\n   * @return\t\tthe unquoted string\r\n   * @see\t\t#quote(String)\r\n   */\r\n  public static String unquote(String string) {\r\n    if (string.startsWith(\"'\") \u0026\u0026 string.endsWith(\"'\")) {\r\n      string = string.substring(1, string.length() - 1);\r\n      \r\n      if ((string.indexOf(\"\\\\n\") != -1) || (string.indexOf(\"\\\\r\") != -1) || \r\n\t  (string.indexOf(\"\\\\'\") != -1) || (string.indexOf(\"\\\\\\\"\") != -1) || \r\n\t  (string.indexOf(\"\\\\\\\\\") != -1) || \r\n\t  (string.indexOf(\"\\\\t\") != -1) || (string.indexOf(\"\\\\%\") != -1)) {\r\n\tstring = unbackQuoteChars(string);\r\n      }\r\n    }\r\n\r\n    return string;\r\n  }\r\n\r\n  /**\r\n   * Converts carriage returns and new lines in a string into \\r and \\n.\r\n   * Backquotes the following characters: ` \" \\ \\t and %\r\n   * \r\n   * @param string \tthe string\r\n   * @return \t\tthe converted string\r\n   * @see\t\t#unbackQuoteChars(String)\r\n   */\r\n  public static /*@pure@*/ String backQuoteChars(String string) {\r\n\r\n    int index;\r\n    StringBuffer newStringBuffer;\r\n\r\n    // replace each of the following characters with the backquoted version\r\n    char   charsFind[] =    {'\\\\',   '\\'',  '\\t',  '\\n',  '\\r',  '\"',    '%'};\r\n    String charsReplace[] = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\n\", \"\\\\r\", \"\\\\\\\"\", \"\\\\%\"};\r\n    for (int i = 0; i \u003c charsFind.length; i++) {\r\n      if (string.indexOf(charsFind[i]) != -1 ) {\r\n\tnewStringBuffer = new StringBuffer();\r\n\twhile ((index = string.indexOf(charsFind[i])) != -1) {\r\n\t  if (index \u003e 0) {\r\n\t    newStringBuffer.append(string.substring(0, index));\r\n\t  }\r\n\t  newStringBuffer.append(charsReplace[i]);\r\n\t  if ((index + 1) \u003c string.length()) {\r\n\t    string = string.substring(index + 1);\r\n\t  } else {\r\n\t    string = \"\";\r\n\t  }\r\n\t}\r\n\tnewStringBuffer.append(string);\r\n\tstring = newStringBuffer.toString();\r\n      }\r\n    }\r\n\r\n    return string;\r\n  }\r\n\r\n  /**\r\n   * Converts carriage returns and new lines in a string into \\r and \\n.\r\n   *\r\n   * @param string the string\r\n   * @return the converted string\r\n   */\r\n  public static String convertNewLines(String string) {\r\n    int index;\r\n\r\n    // Replace with \\n\r\n    StringBuffer newStringBuffer = new StringBuffer();\r\n    while ((index = string.indexOf('\\n')) != -1) {\r\n      if (index \u003e 0) {\r\n\tnewStringBuffer.append(string.substring(0, index));\r\n      }\r\n      newStringBuffer.append('\\\\');\r\n      newStringBuffer.append('n');\r\n      if ((index + 1) \u003c string.length()) {\r\n\tstring = string.substring(index + 1);\r\n      } else {\r\n\tstring = \"\";\r\n      }\r\n    }\r\n    newStringBuffer.append(string);\r\n    string = newStringBuffer.toString();\r\n\r\n    // Replace with \\r\r\n    newStringBuffer = new StringBuffer();\r\n    while ((index = string.indexOf('\\r')) != -1) {\r\n      if (index \u003e 0) {\r\n\tnewStringBuffer.append(string.substring(0, index));\r\n      }\r\n      newStringBuffer.append('\\\\');\r\n      newStringBuffer.append('r');\r\n      if ((index + 1) \u003c string.length()){\r\n\tstring = string.substring(index + 1);\r\n      } else {\r\n\tstring = \"\";\r\n      }\r\n    }\r\n    newStringBuffer.append(string);\r\n    return newStringBuffer.toString();\r\n  }\r\n\r\n  /**\r\n   * Reverts \\r and \\n in a string into carriage returns and new lines.\r\n   * \r\n   * @param string the string\r\n   * @return the converted string\r\n   */\r\n  public static String revertNewLines(String string) {\r\n    int index;\r\n\r\n    // Replace with \\n\r\n    StringBuffer newStringBuffer = new StringBuffer();\r\n    while ((index = string.indexOf(\"\\\\n\")) != -1) {\r\n      if (index \u003e 0) {\r\n\tnewStringBuffer.append(string.substring(0, index));\r\n      }\r\n      newStringBuffer.append('\\n');\r\n      if ((index + 2) \u003c string.length()) {\r\n\tstring = string.substring(index + 2);\r\n      } else {\r\n\tstring = \"\";\r\n      }\r\n    }\r\n    newStringBuffer.append(string);\r\n    string = newStringBuffer.toString();\r\n\r\n    // Replace with \\r\r\n    newStringBuffer = new StringBuffer();\r\n    while ((index = string.indexOf(\"\\\\r\")) != -1) {\r\n      if (index \u003e 0) {\r\n\tnewStringBuffer.append(string.substring(0, index));\r\n      }\r\n      newStringBuffer.append('\\r');\r\n      if ((index + 2) \u003c string.length()){\r\n\tstring = string.substring(index + 2);\r\n      } else {\r\n\tstring = \"\";\r\n      }\r\n    }\r\n    newStringBuffer.append(string);\r\n    \r\n    return newStringBuffer.toString();\r\n  }\r\n\r\n  /**\r\n   * Returns the secondary set of options (if any) contained in\r\n   * the supplied options array. The secondary set is defined to\r\n   * be any options after the first \"--\". These options are removed from\r\n   * the original options array.\r\n   *\r\n   * @param options the input array of options\r\n   * @return the array of secondary options\r\n   */\r\n  public static String[] partitionOptions(String[] options) {\r\n\r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if (options[i].equals(\"--\")) {\r\n\toptions[i++] = \"\";\r\n\tString[] result = new String [options.length - i];\r\n\tfor (int j = i; j \u003c options.length; j++) {\r\n\t  result[j - i] = options[j];\r\n\t  options[j] = \"\";\r\n\t}\r\n\treturn result;\r\n      }\r\n    }\r\n    return new String [0];\r\n  }\r\n    \r\n  /**\r\n   * The inverse operation of backQuoteChars().\r\n   * Converts back-quoted carriage returns and new lines in a string \r\n   * to the corresponding character ('\\r' and '\\n').\r\n   * Also \"un\"-back-quotes the following characters: ` \" \\ \\t and %\r\n   *\r\n   * @param string \tthe string\r\n   * @return \t\tthe converted string\r\n   * @see\t\t#backQuoteChars(String)\r\n   */\r\n  public static String unbackQuoteChars(String string) {\r\n\r\n    int index;\r\n    StringBuffer newStringBuffer;\r\n    \r\n    // replace each of the following characters with the backquoted version\r\n    String charsFind[]    = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\n\", \"\\\\r\", \"\\\\\\\"\", \"\\\\%\"};\r\n    char   charsReplace[] = {'\\\\',   '\\'',  '\\t',  '\\n',  '\\r',  '\"',    '%'};\r\n    int pos[] = new int[charsFind.length];\r\n    int\tcurPos;\r\n    \r\n    String str = new String(string);\r\n    newStringBuffer = new StringBuffer();\r\n    while (str.length() \u003e 0) {\r\n      // get positions and closest character to replace\r\n      curPos = str.length();\r\n      index  = -1;\r\n      for (int i = 0; i \u003c pos.length; i++) {\r\n\tpos[i] = str.indexOf(charsFind[i]);\r\n\tif ( (pos[i] \u003e -1) \u0026\u0026 (pos[i] \u003c curPos) ) {\r\n\t  index  = i;\r\n\t  curPos = pos[i];\r\n\t}\r\n      }\r\n      \r\n      // replace character if found, otherwise finished\r\n      if (index == -1) {\r\n\tnewStringBuffer.append(str);\r\n\tstr = \"\";\r\n      }\r\n      else {\r\n\tnewStringBuffer.append(str.substring(0, pos[index]));\r\n\tnewStringBuffer.append(charsReplace[index]);\r\n\tstr = str.substring(pos[index] + charsFind[index].length());\r\n      }\r\n    }\r\n\r\n    return newStringBuffer.toString();\r\n  }    \r\n  \r\n  /**\r\n   * Split up a string containing options into an array of strings,\r\n   * one for each option.\r\n   *\r\n   * @param \t\tquotedOptionString the string containing the options\r\n   * @return \t\tthe array of options\r\n   * @throws Exception \tin case of an unterminated string, unknown character or\r\n   * \t\t\ta parse error\r\n   */\r\n  public static String[] splitOptions(String quotedOptionString) throws Exception{\r\n\r\n    FastVector optionsVec = new FastVector();\r\n    String str = new String(quotedOptionString);\r\n    int i;\r\n    \r\n    while (true){\r\n\r\n      //trimLeft \r\n      i = 0;\r\n      while ((i \u003c str.length()) \u0026\u0026 (Character.isWhitespace(str.charAt(i)))) i++;\r\n      str = str.substring(i);\r\n      \r\n      //stop when str is empty\r\n      if (str.length() == 0) break;\r\n      \r\n      //if str start with a double quote\r\n      if (str.charAt(0) == '\"'){\r\n\t\r\n\t//find the first not anti-slached double quote\r\n\ti = 1;\r\n\twhile(i \u003c str.length()){\r\n\t  if (str.charAt(i) == str.charAt(0)) break;\r\n\t  if (str.charAt(i) == '\\\\'){\r\n\t    i += 1;\r\n\t    if (i \u003e= str.length()) \r\n\t      throw new Exception(\"String should not finish with \\\\\");\r\n\t  }\r\n\t  i += 1;\r\n\t}\r\n\tif (i \u003e= str.length()) throw new Exception(\"Quote parse error.\");\r\n\t\r\n\t//add the founded string to the option vector (without quotes)\r\n\tString optStr = str.substring(1,i);\r\n\toptStr = unbackQuoteChars(optStr);\r\n\toptionsVec.addElement(optStr);\r\n\tstr = str.substring(i+1);\r\n      } else {\r\n\t//find first whiteSpace\r\n\ti=0;\r\n\twhile((i \u003c str.length()) \u0026\u0026 (!Character.isWhitespace(str.charAt(i)))) i++;\r\n\t\r\n\t//add the founded string to the option vector\r\n\tString optStr = str.substring(0,i);\r\n\toptionsVec.addElement(optStr);\r\n\tstr = str.substring(i);\r\n      }\r\n    }\r\n    \r\n    //convert optionsVec to an array of String\r\n    String[] options = new String[optionsVec.size()];\r\n    for (i = 0; i \u003c optionsVec.size(); i++) {\r\n      options[i] = (String)optionsVec.elementAt(i);\r\n    }\r\n    return options;\r\n  }    \r\n\r\n  /**\r\n   * Joins all the options in an option array into a single string,\r\n   * as might be used on the command line.\r\n   *\r\n   * @param optionArray the array of options\r\n   * @return the string containing all options.\r\n   */\r\n  public static String joinOptions(String[] optionArray) {\r\n\r\n    String optionString = \"\";\r\n    for (int i = 0; i \u003c optionArray.length; i++) {\r\n      if (optionArray[i].equals(\"\")) {\r\n\tcontinue;\r\n      }\r\n      boolean escape = false;\r\n      for (int n = 0; n \u003c optionArray[i].length(); n++) {\r\n\tif (Character.isWhitespace(optionArray[i].charAt(n))) {\r\n\t  escape = true;\r\n\t  break;\r\n\t}\r\n      }\r\n      if (escape) {\r\n\toptionString += '\"' + backQuoteChars(optionArray[i]) + '\"';\r\n      } else {\r\n\toptionString += optionArray[i];\r\n      }\r\n      optionString += \" \";\r\n    }\r\n    return optionString.trim();\r\n  }\r\n  \r\n  /**\r\n   * Creates a new instance of an object given it's class name and\r\n   * (optional) arguments to pass to it's setOptions method. If the\r\n   * object implements OptionHandler and the options parameter is\r\n   * non-null, the object will have it's options set. Example use:\u003cp\u003e\r\n   *\r\n   * \u003ccode\u003e \u003cpre\u003e\r\n   * String classifierName = Utils.getOption('W', options);\r\n   * Classifier c = (Classifier)Utils.forName(Classifier.class,\r\n   *                                          classifierName,\r\n   *                                          options);\r\n   * setClassifier(c);\r\n   * \u003c/pre\u003e\u003c/code\u003e\r\n   *\r\n   * @param classType the class that the instantiated object should\r\n   * be assignable to -- an exception is thrown if this is not the case\r\n   * @param className the fully qualified class name of the object\r\n   * @param options an array of options suitable for passing to setOptions. May\r\n   * be null. Any options accepted by the object will be removed from the\r\n   * array.\r\n   * @return the newly created object, ready for use.\r\n   * @exception Exception if the class name is invalid, or if the\r\n   * class is not assignable to the desired class type, or the options\r\n   * supplied are not acceptable to the object\r\n   */\r\n  public static Object forName(Class classType,\r\n\t\t\t       String className,\r\n\t\t\t       String[] options) throws Exception {\r\n\r\n    Class c = null;\r\n    try {\r\n      c = Class.forName(className);\r\n    } catch (Exception ex) {\r\n      throw new Exception(\"Can't find class called: \" + className);\r\n    }\r\n    if (!classType.isAssignableFrom(c)) {\r\n      throw new Exception(classType.getName() + \" is not assignable from \"\r\n\t\t\t  + className);\r\n    }\r\n    Object o = c.newInstance();\r\n    if ((o instanceof OptionHandler)\r\n\t\u0026\u0026 (options != null)) {\r\n      ((OptionHandler)o).setOptions(options);\r\n      Utils.checkForRemainingOptions(options);\r\n    }\r\n    return o;\r\n  }\r\n\r\n  /**\r\n   * Computes entropy for an array of integers.\r\n   *\r\n   * @param counts array of counts\r\n   * @return - a log2 a - b log2 b - c log2 c + (a+b+c) log2 (a+b+c)\r\n   * when given array [a b c]\r\n   */\r\n  public static /*@pure@*/ double info(int counts[]) {\r\n    \r\n    int total = 0;\r\n    double x = 0;\r\n    for (int j = 0; j \u003c counts.length; j++) {\r\n      x -= xlogx(counts[j]);\r\n      total += counts[j];\r\n    }\r\n    return x + xlogx(total);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is smaller or equal to b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n     * @return  True if a is smaller or equal to b.\r\n   */\r\n  public static /*@pure@*/ boolean smOrEq(double a,double b) {\r\n    \r\n    return (a-b \u003c SMALL);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is greater or equal to b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n     * @return True if a is greater or equal to b. \r\n   */\r\n  public static /*@pure@*/ boolean grOrEq(double a,double b) {\r\n    \r\n    return (b-a \u003c SMALL);\r\n  }\r\n  \r\n  /**\r\n   * Tests if a is smaller than b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n     * @return True if a is smaller than b.\r\n   */\r\n  public static /*@pure@*/ boolean sm(double a,double b) {\r\n    \r\n    return (b-a \u003e SMALL);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is greater than b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double \r\n     * @return  True  if a is greater than b.\r\n   */\r\n  public static /*@pure@*/ boolean gr(double a,double b) {\r\n    \r\n    return (a-b \u003e SMALL);\r\n  }\r\n\r\n  /**\r\n   * Returns the kth-smallest value in the array.\r\n   *\r\n   * @param array the array of integers\r\n   * @param k the value of k\r\n   * @return the kth-smallest value\r\n   */\r\n  public static double kthSmallestValue(int[] array, int k) {\r\n\r\n    int[] index = new int[array.length];\r\n    \r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n    }\r\n\r\n    return array[index[select(array, index, 0, array.length - 1, k)]];\r\n  }\r\n\r\n  /**\r\n   * Returns the kth-smallest value in the array\r\n   *\r\n   * @param array the array of double\r\n   * @param k the value of k\r\n   * @return the kth-smallest value\r\n   */\r\n  public static double kthSmallestValue(double[] array, int k) {\r\n\r\n    int[] index = new int[array.length];\r\n    \r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n    }\r\n\r\n    return array[index[select(array, index, 0, array.length - 1, k)]];\r\n  }\r\n\r\n  /**\r\n   * Returns the logarithm of a for base 2.\r\n   *\r\n   * @param a \ta double\r\n   * @return\tthe logarithm for base 2\r\n   */\r\n  public static /*@pure@*/ double log2(double a) {\r\n    \r\n    return Math.log(a) / log2;\r\n  }\r\n\r\n  /**\r\n   * Returns index of maximum element in a given\r\n   * array of doubles. First maximum is returned.\r\n   *\r\n   * @param doubles the array of doubles\r\n   * @return the index of the maximum element\r\n   */\r\n  public static /*@pure@*/ int maxIndex(double[] doubles) {\r\n\r\n    double maximum = 0;\r\n    int maxIndex = 0;\r\n\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      if ((i == 0) || (doubles[i] \u003e maximum)) {\r\n\tmaxIndex = i;\r\n\tmaximum = doubles[i];\r\n      }\r\n    }\r\n\r\n    return maxIndex;\r\n  }\r\n\r\n  /**\r\n   * Returns index of maximum element in a given\r\n   * array of integers. First maximum is returned.\r\n   *\r\n   * @param ints the array of integers\r\n   * @return the index of the maximum element\r\n   */\r\n  public static /*@pure@*/ int maxIndex(int[] ints) {\r\n\r\n    int maximum = 0;\r\n    int maxIndex = 0;\r\n\r\n    for (int i = 0; i \u003c ints.length; i++) {\r\n      if ((i == 0) || (ints[i] \u003e maximum)) {\r\n\tmaxIndex = i;\r\n\tmaximum = ints[i];\r\n      }\r\n    }\r\n\r\n    return maxIndex;\r\n  }\r\n\r\n  /**\r\n   * Computes the mean for an array of doubles.\r\n   *\r\n   * @param vector the array\r\n   * @return the mean\r\n   */\r\n  public static /*@pure@*/ double mean(double[] vector) {\r\n  \r\n    double sum = 0;\r\n\r\n    if (vector.length == 0) {\r\n      return 0;\r\n    }\r\n    for (int i = 0; i \u003c vector.length; i++) {\r\n      sum += vector[i];\r\n    }\r\n    return sum / (double) vector.length;\r\n  }\r\n\r\n  /**\r\n   * Returns index of minimum element in a given\r\n   * array of integers. First minimum is returned.\r\n   *\r\n   * @param ints the array of integers\r\n   * @return the index of the minimum element\r\n   */\r\n  public static /*@pure@*/ int minIndex(int[] ints) {\r\n\r\n    int minimum = 0;\r\n    int minIndex = 0;\r\n\r\n    for (int i = 0; i \u003c ints.length; i++) {\r\n      if ((i == 0) || (ints[i] \u003c minimum)) {\r\n\tminIndex = i;\r\n\tminimum = ints[i];\r\n      }\r\n    }\r\n\r\n    return minIndex;\r\n  }\r\n\r\n  /**\r\n   * Returns index of minimum element in a given\r\n   * array of doubles. First minimum is returned.\r\n   *\r\n   * @param doubles the array of doubles\r\n   * @return the index of the minimum element\r\n   */\r\n  public static /*@pure@*/ int minIndex(double[] doubles) {\r\n\r\n    double minimum = 0;\r\n    int minIndex = 0;\r\n\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      if ((i == 0) || (doubles[i] \u003c minimum)) {\r\n\tminIndex = i;\r\n\tminimum = doubles[i];\r\n      }\r\n    }\r\n\r\n    return minIndex;\r\n  }\r\n\r\n  /**\r\n   * Normalizes the doubles in the array by their sum.\r\n   *\r\n   * @param doubles the array of double\r\n   * @exception IllegalArgumentException if sum is Zero or NaN\r\n   */\r\n  public static void normalize(double[] doubles) {\r\n\r\n    double sum = 0;\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      sum += doubles[i];\r\n    }\r\n    normalize(doubles, sum);\r\n  }\r\n\r\n  /**\r\n   * Normalizes the doubles in the array using the given value.\r\n   *\r\n   * @param doubles the array of double\r\n   * @param sum the value by which the doubles are to be normalized\r\n   * @exception IllegalArgumentException if sum is zero or NaN\r\n   */\r\n  public static void normalize(double[] doubles, double sum) {\r\n\r\n    if (Double.isNaN(sum)) {\r\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is NaN.\");\r\n    }\r\n    if (sum == 0) {\r\n      // Maybe this should just be a return.\r\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is zero.\");\r\n    }\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      doubles[i] /= sum;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts an array containing the natural logarithms of\r\n   * probabilities stored in a vector back into probabilities.\r\n   * The probabilities are assumed to sum to one.\r\n   *\r\n   * @param a an array holding the natural logarithms of the probabilities\r\n   * @return the converted array \r\n   */\r\n  public static double[] logs2probs(double[] a) {\r\n\r\n    double max = a[maxIndex(a)];\r\n    double sum = 0.0;\r\n\r\n    double[] result = new double[a.length];\r\n    for(int i = 0; i \u003c a.length; i++) {\r\n      result[i] = Math.exp(a[i] - max);\r\n      sum += result[i];\r\n    }\r\n\r\n    normalize(result, sum);\r\n\r\n    return result;\r\n  } \r\n\r\n  /**\r\n   * Returns the log-odds for a given probabilitiy.\r\n   *\r\n   * @param prob the probabilitiy\r\n   *\r\n   * @return the log-odds after the probability has been mapped to\r\n   * [Utils.SMALL, 1-Utils.SMALL]\r\n   */\r\n  public static /*@pure@*/ double probToLogOdds(double prob) {\r\n\r\n    if (gr(prob, 1) || (sm(prob, 0))) {\r\n      throw new IllegalArgumentException(\"probToLogOdds: probability must \" +\r\n\t\t\t\t     \"be in [0,1] \"+prob);\r\n    }\r\n    double p = SMALL + (1.0 - 2 * SMALL) * prob;\r\n    return Math.log(p / (1 - p));\r\n  }\r\n\r\n  /**\r\n   * Rounds a double to the next nearest integer value. The JDK version\r\n   * of it doesn't work properly.\r\n   *\r\n   * @param value the double value\r\n   * @return the resulting integer value\r\n   */\r\n  public static /*@pure@*/ int round(double value) {\r\n\r\n    int roundedValue = value \u003e 0\r\n      ? (int)(value + 0.5)\r\n      : -(int)(Math.abs(value) + 0.5);\r\n    \r\n    return roundedValue;\r\n  }\r\n\r\n  /**\r\n   * Rounds a double to the next nearest integer value in a probabilistic\r\n   * fashion (e.g. 0.8 has a 20% chance of being rounded down to 0 and a\r\n   * 80% chance of being rounded up to 1). In the limit, the average of\r\n   * the rounded numbers generated by this procedure should converge to\r\n   * the original double.\r\n   *\r\n   * @param value the double value\r\n   * @param rand the random number generator\r\n   * @return the resulting integer value\r\n   */\r\n  public static int probRound(double value, Random rand) {\r\n\r\n    if (value \u003e= 0) {\r\n      double lower = Math.floor(value);\r\n      double prob = value - lower;\r\n      if (rand.nextDouble() \u003c prob) {\r\n\treturn (int)lower + 1;\r\n      } else {\r\n\treturn (int)lower;\r\n      }\r\n    } else {\r\n      double lower = Math.floor(Math.abs(value));\r\n      double prob = Math.abs(value) - lower;\r\n      if (rand.nextDouble() \u003c prob) {\r\n\treturn -((int)lower + 1);\r\n      } else {\r\n\treturn -(int)lower;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rounds a double to the given number of decimal places.\r\n   *\r\n   * @param value the double value\r\n   * @param afterDecimalPoint the number of digits after the decimal point\r\n   * @return the double rounded to the given precision\r\n   */\r\n  public static /*@pure@*/ double roundDouble(double value,int afterDecimalPoint) {\r\n\r\n    double mask = Math.pow(10.0, (double)afterDecimalPoint);\r\n\r\n    return (double)(Math.round(value * mask)) / mask;\r\n  }\r\n\r\n  /**\r\n   * Sorts a given array of integers in ascending order and returns an \r\n   * array of integers with the positions of the elements of the original \r\n   * array in the sorted array. The sort is stable. (Equal elements remain\r\n   * in their original order.)\r\n   *\r\n   * @param array this array is not changed by the method!\r\n   * @return an array of integers with the positions in the sorted\r\n   * array.\r\n   */\r\n  public static /*@pure@*/ int[] sort(int[] array) {\r\n\r\n    int[] index = new int[array.length];\r\n    int[] newIndex = new int[array.length];\r\n    int[] helpIndex;\r\n    int numEqual;\r\n    \r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n    }\r\n    quickSort(array, index, 0, array.length - 1);\r\n\r\n    // Make sort stable\r\n    int i = 0;\r\n    while (i \u003c index.length) {\r\n      numEqual = 1;\r\n      for (int j = i + 1; ((j \u003c index.length)\r\n\t\t\t   \u0026\u0026 (array[index[i]] == array[index[j]]));\r\n\t   j++) {\r\n\tnumEqual++;\r\n      }\r\n      if (numEqual \u003e 1) {\r\n\thelpIndex = new int[numEqual];\r\n\tfor (int j = 0; j \u003c numEqual; j++) {\r\n\t  helpIndex[j] = i + j;\r\n\t}\r\n\tquickSort(index, helpIndex, 0, numEqual - 1);\r\n\tfor (int j = 0; j \u003c numEqual; j++) {\r\n\t  newIndex[i + j] = index[helpIndex[j]];\r\n\t}\r\n\ti += numEqual;\r\n      } else {\r\n\tnewIndex[i] = index[i];\r\n\ti++;\r\n      }\r\n    }\r\n    return newIndex;\r\n  }\r\n\r\n  /**\r\n   * Sorts a given array of doubles in ascending order and returns an\r\n   * array of integers with the positions of the elements of the\r\n   * original array in the sorted array. NOTE THESE CHANGES: the sort\r\n   * is no longer stable and it doesn't use safe floating-point\r\n   * comparisons anymore. Occurrences of Double.NaN are treated as \r\n   * Double.MAX_VALUE\r\n   *\r\n   * @param array this array is not changed by the method!\r\n   * @return an array of integers with the positions in the sorted\r\n   * array.  \r\n   */\r\n  public static /*@pure@*/ int[] sort(/*@non_null@*/ double[] array) {\r\n\r\n    int[] index = new int[array.length];\r\n    array = (double[])array.clone();\r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n      if (Double.isNaN(array[i])) {\r\n        array[i] = Double.MAX_VALUE;\r\n      }\r\n    }\r\n    quickSort(array, index, 0, array.length - 1);\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Sorts a given array of doubles in ascending order and returns an \r\n   * array of integers with the positions of the elements of the original \r\n   * array in the sorted array. The sort is stable (Equal elements remain\r\n   * in their original order.) Occurrences of Double.NaN are treated as \r\n   * Double.MAX_VALUE\r\n   *\r\n   * @param array this array is not changed by the method!\r\n   * @return an array of integers with the positions in the sorted\r\n   * array.\r\n   */\r\n  public static /*@pure@*/ int[] stableSort(double[] array){\r\n\r\n    int[] index = new int[array.length];\r\n    int[] newIndex = new int[array.length];\r\n    int[] helpIndex;\r\n    int numEqual;\r\n    \r\n    array = (double[])array.clone();\r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n      if (Double.isNaN(array[i])) {\r\n        array[i] = Double.MAX_VALUE;\r\n      }\r\n    }\r\n    quickSort(array,index,0,array.length-1);\r\n\r\n    // Make sort stable\r\n\r\n    int i = 0;\r\n    while (i \u003c index.length) {\r\n      numEqual = 1;\r\n      for (int j = i+1; ((j \u003c index.length) \u0026\u0026 Utils.eq(array[index[i]],\r\n\t\t\t\t\t\t\tarray[index[j]])); j++)\r\n\tnumEqual++;\r\n      if (numEqual \u003e 1) {\r\n\thelpIndex = new int[numEqual];\r\n\tfor (int j = 0; j \u003c numEqual; j++)\r\n\t  helpIndex[j] = i+j;\r\n\tquickSort(index, helpIndex, 0, numEqual-1);\r\n\tfor (int j = 0; j \u003c numEqual; j++) \r\n\t  newIndex[i+j] = index[helpIndex[j]];\r\n\ti += numEqual;\r\n      } else {\r\n\tnewIndex[i] = index[i];\r\n\ti++;\r\n      }\r\n    }\r\n\r\n    return newIndex;\r\n  }\r\n\r\n  /**\r\n   * Computes the variance for an array of doubles.\r\n   *\r\n   * @param vector the array\r\n   * @return the variance\r\n   */\r\n  public static /*@pure@*/ double variance(double[] vector) {\r\n  \r\n    double sum = 0, sumSquared = 0;\r\n\r\n    if (vector.length \u003c= 1) {\r\n      return 0;\r\n    }\r\n    for (int i = 0; i \u003c vector.length; i++) {\r\n      sum += vector[i];\r\n      sumSquared += (vector[i] * vector[i]);\r\n    }\r\n    double result = (sumSquared - (sum * sum / (double) vector.length)) / \r\n      (double) (vector.length - 1);\r\n\r\n    // We don't like negative variance\r\n    if (result \u003c 0) {\r\n      return 0;\r\n    } else {\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Computes the sum of the elements of an array of doubles.\r\n   *\r\n   * @param doubles the array of double\r\n   * @return the sum of the elements\r\n   */\r\n  public static /*@pure@*/ double sum(double[] doubles) {\r\n\r\n    double sum = 0;\r\n\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      sum += doubles[i];\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * Computes the sum of the elements of an array of integers.\r\n   *\r\n   * @param ints the array of integers\r\n   * @return the sum of the elements\r\n   */\r\n  public static /*@pure@*/ int sum(int[] ints) {\r\n\r\n    int sum = 0;\r\n\r\n    for (int i = 0; i \u003c ints.length; i++) {\r\n      sum += ints[i];\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * Returns c*log2(c) for a given integer value c.\r\n   *\r\n   * @param c an integer value\r\n   * @return c*log2(c) (but is careful to return 0 if c is 0)\r\n   */\r\n  public static /*@pure@*/ double xlogx(int c) {\r\n    \r\n    if (c == 0) {\r\n      return 0.0;\r\n    }\r\n    return c * Utils.log2((double) c);\r\n  }\r\n\r\n  /**\r\n   * Partitions the instances around a pivot. Used by quicksort and\r\n   * kthSmallestValue.\r\n   *\r\n   * @param array the array of doubles to be sorted\r\n   * @param index the index into the array of doubles\r\n   * @param l the first index of the subset \r\n   * @param r the last index of the subset \r\n   *\r\n   * @return the index of the middle element\r\n   */\r\n  private static int partition(double[] array, int[] index, int l, int r) {\r\n    \r\n    double pivot = array[index[(l + r) / 2]];\r\n    int help;\r\n\r\n    while (l \u003c r) {\r\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\r\n        l++;\r\n      }\r\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\r\n        r--;\r\n      }\r\n      if (l \u003c r) {\r\n        help = index[l];\r\n        index[l] = index[r];\r\n        index[r] = help;\r\n        l++;\r\n        r--;\r\n      }\r\n    }\r\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\r\n      r--;\r\n    } \r\n\r\n    return r;\r\n  }\r\n\r\n  /**\r\n   * Partitions the instances around a pivot. Used by quicksort and\r\n   * kthSmallestValue.\r\n   *\r\n   * @param array the array of integers to be sorted\r\n   * @param index the index into the array of integers\r\n   * @param l the first index of the subset \r\n   * @param r the last index of the subset \r\n   *\r\n   * @return the index of the middle element\r\n   */\r\n  private static int partition(int[] array, int[] index, int l, int r) {\r\n    \r\n    double pivot = array[index[(l + r) / 2]];\r\n    int help;\r\n\r\n    while (l \u003c r) {\r\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\r\n        l++;\r\n      }\r\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\r\n        r--;\r\n      }\r\n      if (l \u003c r) {\r\n        help = index[l];\r\n        index[l] = index[r];\r\n        index[r] = help;\r\n        l++;\r\n        r--;\r\n      }\r\n    }\r\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\r\n      r--;\r\n    } \r\n\r\n    return r;\r\n  }\r\n  \r\n  /**\r\n   * Implements quicksort according to Manber's \"Introduction to\r\n   * Algorithms\".\r\n   *\r\n   * @param array the array of doubles to be sorted\r\n   * @param index the index into the array of doubles\r\n   * @param left the first index of the subset to be sorted\r\n   * @param right the last index of the subset to be sorted\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r\n  //@ requires array != index;\r\n  //  assignable index;\r\n  private static void quickSort(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \r\n                                int left, int right) {\r\n\r\n    if (left \u003c right) {\r\n      int middle = partition(array, index, left, right);\r\n      quickSort(array, index, left, middle);\r\n      quickSort(array, index, middle + 1, right);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Implements quicksort according to Manber's \"Introduction to\r\n   * Algorithms\".\r\n   *\r\n   * @param array the array of integers to be sorted\r\n   * @param index the index into the array of integers\r\n   * @param left the first index of the subset to be sorted\r\n   * @param right the last index of the subset to be sorted\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r\n  //@ requires array != index;\r\n  //  assignable index;\r\n  private static void quickSort(/*@non_null@*/ int[] array, /*@non_null@*/  int[] index, \r\n                                int left, int right) {\r\n\r\n    if (left \u003c right) {\r\n      int middle = partition(array, index, left, right);\r\n      quickSort(array, index, left, middle);\r\n      quickSort(array, index, middle + 1, right);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Implements computation of the kth-smallest element according\r\n   * to Manber's \"Introduction to Algorithms\".\r\n   *\r\n   * @param array the array of double\r\n   * @param index the index into the array of doubles\r\n   * @param left the first index of the subset \r\n   * @param right the last index of the subset \r\n   * @param k the value of k\r\n   *\r\n   * @return the index of the kth-smallest element\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  private static int select(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \r\n                            int left, int right, int k) {\r\n    \r\n    if (left == right) {\r\n      return left;\r\n    } else {\r\n      int middle = partition(array, index, left, right);\r\n      if ((middle - left + 1) \u003e= k) {\r\n        return select(array, index, left, middle, k);\r\n      } else {\r\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Implements computation of the kth-smallest element according\r\n   * to Manber's \"Introduction to Algorithms\".\r\n   *\r\n   * @param array the array of integers\r\n   * @param index the index into the array of integers\r\n   * @param left the first index of the subset \r\n   * @param right the last index of the subset \r\n   * @param k the value of k\r\n   *\r\n   * @return the index of the kth-smallest element\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  private static int select(/*@non_null@*/ int[] array, /*@non_null@*/ int[] index, \r\n                            int left, int right, int k) {\r\n    \r\n    if (left == right) {\r\n      return left;\r\n    } else {\r\n      int middle = partition(array, index, left, right);\r\n      if ((middle - left + 1) \u003e= k) {\r\n        return select(array, index, left, middle, k);\r\n      } else {\r\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Main method for testing this class.\r\n   *\r\n   * @param ops some dummy options\r\n   */\r\n  public static void main(String[] ops) {\r\n\r\n    double[] doublesWithNaN = {4.5, 6.7, Double.NaN, 3.4, 4.8, 1.2, 3.4};\r\n    double[] doubles = {4.5, 6.7, 6.7, 3.4, 4.8, 1.2, 3.4, 6.7, 6.7, 3.4};\r\n    int[] ints = {12, 6, 2, 18, 16, 6, 7, 5, 18, 18, 17};\r\n\r\n    try {\r\n\r\n      // Option handling\r\n      System.out.println(\"First option split up:\");\r\n      if (ops.length \u003e 0) {\r\n\tString[] firstOptionSplitUp = Utils.splitOptions(ops[0]);\r\n\tfor (int i = 0; i \u003c firstOptionSplitUp.length; i ++) {\r\n\t  System.out.println(firstOptionSplitUp[i]);\r\n\t}\r\n      }\t\t\t\t\t       \r\n      System.out.println(\"Partitioned options: \");\r\n      String[] partitionedOptions = Utils.partitionOptions(ops);\r\n      for (int i  = 0; i \u003c partitionedOptions.length; i++) {\r\n\tSystem.out.println(partitionedOptions[i]);\r\n      }\r\n      System.out.println(\"Get position of flag -f: \" + Utils.getOptionPos('f', ops));\r\n      System.out.println(\"Get flag -f: \" + Utils.getFlag('f', ops));\r\n      System.out.println(\"Get position of option -o: \" + Utils.getOptionPos('o', ops));\r\n      System.out.println(\"Get option -o: \" + Utils.getOption('o', ops));\r\n      System.out.println(\"Checking for remaining options... \");\r\n      Utils.checkForRemainingOptions(ops);\r\n      \r\n      // Statistics\r\n      System.out.println(\"Original array with NaN (doubles): \");\r\n      for (int i = 0; i \u003c doublesWithNaN.length; i++) {\r\n\tSystem.out.print(doublesWithNaN[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Original array (doubles): \");\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(doubles[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Original array (ints): \");\r\n      for (int i = 0; i \u003c ints.length; i++) {\r\n\tSystem.out.print(ints[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Correlation: \" + Utils.correlation(doubles, doubles, \r\n\t\t\t\t\t\t\t     doubles.length));\r\n      System.out.println(\"Mean: \" + Utils.mean(doubles));\r\n      System.out.println(\"Variance: \" + Utils.variance(doubles));\r\n      System.out.println(\"Sum (doubles): \" + Utils.sum(doubles));\r\n      System.out.println(\"Sum (ints): \" + Utils.sum(ints));\r\n      System.out.println(\"Max index (doubles): \" + Utils.maxIndex(doubles));\r\n      System.out.println(\"Max index (ints): \" + Utils.maxIndex(ints));\r\n      System.out.println(\"Min index (doubles): \" + Utils.minIndex(doubles));\r\n      System.out.println(\"Min index (ints): \" + Utils.minIndex(ints));\r\n      System.out.println(\"Median (doubles): \" + \r\n                         Utils.kthSmallestValue(doubles, doubles.length / 2));\r\n      System.out.println(\"Median (ints): \" + \r\n                         Utils.kthSmallestValue(ints, ints.length / 2));\r\n\r\n      // Sorting and normalizing\r\n      System.out.println(\"Sorted array with NaN (doubles): \");\r\n      int[] sorted = Utils.sort(doublesWithNaN);\r\n      for (int i = 0; i \u003c doublesWithNaN.length; i++) {\r\n\tSystem.out.print(doublesWithNaN[sorted[i]] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Sorted array (doubles): \");\r\n      sorted = Utils.sort(doubles);\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(doubles[sorted[i]] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Sorted array (ints): \");\r\n      sorted = Utils.sort(ints);\r\n      for (int i = 0; i \u003c ints.length; i++) {\r\n\tSystem.out.print(ints[sorted[i]] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Indices from stable sort (doubles): \");\r\n      sorted = Utils.stableSort(doubles);\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(sorted[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Indices from sort (ints): \");\r\n      sorted = Utils.sort(ints);\r\n      for (int i = 0; i \u003c ints.length; i++) {\r\n\tSystem.out.print(sorted[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Normalized array (doubles): \");\r\n      Utils.normalize(doubles);\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(doubles[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Normalized again (doubles): \");\r\n      Utils.normalize(doubles, Utils.sum(doubles));\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(doubles[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      \r\n      // Pretty-printing\r\n      System.out.println(\"-4.58: \" + Utils.doubleToString(-4.57826535, 2));\r\n      System.out.println(\"-6.78: \" + Utils.doubleToString(-6.78214234, 6,2));\r\n      \r\n      // Comparisons\r\n      System.out.println(\"5.70001 == 5.7 ? \" + Utils.eq(5.70001, 5.7));\r\n      System.out.println(\"5.70001 \u003e 5.7 ? \" + Utils.gr(5.70001, 5.7));\r\n      System.out.println(\"5.70001 \u003e= 5.7 ? \" + Utils.grOrEq(5.70001, 5.7));\r\n      System.out.println(\"5.7 \u003c 5.70001 ? \" + Utils.sm(5.7, 5.70001));\r\n      System.out.println(\"5.7 \u003c= 5.70001 ? \" + Utils.smOrEq(5.7, 5.70001));\r\n      \r\n      // Math\r\n      System.out.println(\"Info (ints): \" + Utils.info(ints));\r\n      System.out.println(\"log2(4.6): \" + Utils.log2(4.6));\r\n      System.out.println(\"5 * log(5): \" + Utils.xlogx(5));\r\n      System.out.println(\"5.5 rounded: \" + Utils.round(5.5));\r\n      System.out.println(\"5.55555 rounded to 2 decimal places: \" + \r\n\t\t\t Utils.roundDouble(5.55555, 2));\r\n      \r\n      // Arrays\r\n      System.out.println(\"Array-Dimensions of 'new int[][]': \" + Utils.getArrayDimensions(new int[][]{}));\r\n      System.out.println(\"Array-Dimensions of 'new int[][]{{1,2,3},{4,5,6}}': \" + Utils.getArrayDimensions(new int[][]{{1,2,3},{4,5,6}}));\r\n      String[][][] s = new String[3][4][];\r\n      System.out.println(\"Array-Dimensions of 'new String[3][4][]': \" + Utils.getArrayDimensions(s));\r\n    } catch (Exception e) {\r\n      e.printStackTrace();\r\n    }\r\n  }\r\n}\r\n  \r\n\r\n",
        "name": "Utils.java",
        "path": "src/keel/Algorithms/Statistical_Classifiers/Logistic/core/Utils.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/Statistical_Classifiers/Logistic/core/Utils.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 1702,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1703,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1704,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1725,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1726,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1727,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1751,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1779,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "/***********************************************************************\r\n\r\n\tThis file is part of KEEL-software, the Data Mining tool for regression, \r\n\tclassification, clustering, pattern mining and so on.\r\n\r\n\tCopyright (C) 2004-2010\r\n\t\r\n\tF. Herrera (herrera@decsai.ugr.es)\r\n    L. Sánchez (luciano@uniovi.es)\r\n    J. Alcalá-Fdez (jalcala@decsai.ugr.es)\r\n    S. García (sglopez@ujaen.es)\r\n    A. Fernández (alberto.fernandez@ujaen.es)\r\n    J. Luengo (julianlm@decsai.ugr.es)\r\n\r\n\tThis program is free software: you can redistribute it and/or modify\r\n\tit under the terms of the GNU General Public License as published by\r\n\tthe Free Software Foundation, either version 3 of the License, or\r\n\t(at your option) any later version.\r\n\r\n\tThis program is distributed in the hope that it will be useful,\r\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\tGNU General Public License for more details.\r\n\r\n\tYou should have received a copy of the GNU General Public License\r\n\talong with this program.  If not, see http://www.gnu.org/licenses/\r\n  \r\n**********************************************************************/\r\n\r\n/*\r\n *    This program is free software; you can redistribute it and/or modify\r\n *    it under the terms of the GNU General Public License as published by\r\n *    the Free Software Foundation; either version 2 of the License, or\r\n *    (at your option) any later version.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU General Public License\r\n *    along with this program; if not, write to the Free Software\r\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\r\n */\r\n\r\n/*\r\n *    Queue.java\r\n *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand\r\n *\r\n *    Modified March-May 2004 by Mark Utting to add JML specs\r\n *    (this was done as the example solution of an assignment for a\r\n *     software engineering course, so the specifications are more precise\r\n *     and complete than one would normally do).\r\n *    Passed a static analysis using ESC/Java-2.0a6 with no warnings.\r\n */\r\n\r\npackage keel.Algorithms.Fuzzy_Rule_Learning.Hybrid.FURIA.core;\r\n\r\nimport java.io.Serializable;\r\n\r\n/**\r\n * Class representing a FIFO queue.\r\n *\r\n * @author Len Trigg (trigg@cs.waikato.ac.nz)\r\n * @version $Revision: 1.10 $\r\n */\r\npublic class Queue extends Object implements Serializable {\r\n\r\n  /** for serialization */\r\n  private static final long serialVersionUID = -1141282001146389780L;\r\n\r\n  /**\r\n   * Represents one node in the queue.\r\n   */\r\n  protected class QueueNode implements Serializable {\r\n\r\n    /** for serialization */\r\n    private static final long serialVersionUID = -5119358279412097455L;\r\n\r\n    /** The next node in the queue */\r\n    protected /*@ spec_public @*/ QueueNode m_Next;\r\n\r\n    /** The nodes contents\r\n     */\r\n    protected /*@ non_null spec_public @*/ Object m_Contents;\r\n\r\n    /**\r\n     * Creates a queue node with the given contents\r\n       * @param contents given contents.\r\n     */\r\n    //@ requires contents != null;\r\n    //@ assignable m_Contents, m_Next;\r\n    //@ ensures m_Contents == contents;\r\n    //@ ensures m_Next == null;\r\n    public QueueNode(Object contents) {\r\n      m_Contents = contents;\r\n      next(null);\r\n    }\r\n\r\n    /**\r\n     * Sets the next node in the queue, and returns it.\r\n       * @param next next queue's node to be set.\r\n       * @return the next node.\r\n     */\r\n    //@ requires next != this ;\r\n    //@ assignable m_Next;\r\n    //@ ensures m_Next==next \u0026\u0026 \\result==next;\r\n    public QueueNode next(QueueNode next) {\r\n      return m_Next = next;\r\n    } //@ nowarn Invariant; // Because it stupidly checks the Queue invariant!\r\n\r\n    /**\r\n     * Gets the next node in the queue.\r\n       * @return the next node in the queue.\r\n     */\r\n    //@ ensures \\result == m_Next;\r\n    public /*@ pure @*/ QueueNode next() {\r\n      return m_Next;\r\n    }\r\n\r\n    /**\r\n     * Sets the contents of the node and returns them.\r\n       * @param contents contents to be set.\r\n       * @return the contents of the node.\r\n     */\r\n    //@ requires contents != null;\r\n    //@ assignable m_Contents;\r\n    //@ ensures  m_Contents == contents \u0026\u0026 \\result == contents;\r\n    public Object contents(Object contents) {\r\n      return m_Contents = contents;\r\n    }\r\n\r\n    /**\r\n     * Returns the contents in the node.\r\n       * @return the contents in the node.\r\n     */\r\n      //@ ensures \\result == m_Contents;\r\n    public /*@ pure @*/ Object contents() {\r\n      return m_Contents;\r\n    }\r\n\r\n  }\r\n\r\n  /** Store a reference to the head of the queue */\r\n  protected /*@ spec_public @*/ QueueNode m_Head = null;\r\n\r\n  /** Store a reference to the tail of the queue */\r\n  protected /*@ spec_public @*/ QueueNode m_Tail = null;\r\n\r\n  /** Store the c m_Tail.m_Nexturrent number of elements in the queue */\r\n  protected /*@ spec_public @*/ int m_Size = 0;\r\n\r\n  //@ public invariant m_Head == null \u003c==\u003e m_Tail == null;\r\n  //@public invariant m_Tail != null ==\u003e m_Tail.m_Next == null;\r\n  //@ public invariant m_Size \u003e= 0;\r\n  //@ public invariant m_Size == 0 \u003c==\u003e m_Head == null;\r\n  //@ public invariant m_Size == 1 \u003c==\u003e m_Head != null \u0026\u0026 m_Head == m_Tail;\r\n  //@ public invariant m_Size \u003e 1 ==\u003e m_Head != m_Tail;\r\n  //@ public invariant m_Size \u003e 1 \u003c== m_Head != m_Tail;\r\n\r\n\r\n\r\n  /**\r\n   * Removes all objects from the queue m_Tail.m_Next.\r\n   */\r\n  //@ assignable m_Size, m_Head, m_Tail;\r\n  //@ ensures m_Size == 0;\r\n  //@ ensures m_Head == null;\r\n  //@ ensures m_Tail == null;\r\n  public final synchronized void removeAllElements() {\r\n    m_Size = 0;\r\n    m_Head = null;\r\n    m_Tail = null;\r\n  }\r\n\r\n  /**\r\n   * Appends an object to the back of the queue.\r\n   *\r\n   * @param item the object to be appended\r\n   * @return the object appended\r\n   */\r\n  //@ requires item != null;\r\n  //@ assignable m_Head, m_Tail, m_Tail.m_Next, m_Head.m_Next, m_Size;\r\n  //@ ensures m_Head != null;\r\n  //@ ensures m_Tail != \\old(m_Tail);\r\n  //@ ensures m_Size == \\old(m_Size) + 1;\r\n  //@ ensures \\old(m_Size) == 0 ==\u003e m_Head == m_Tail;\r\n  //@ ensures \\old(m_Size) != 0 ==\u003e m_Head == \\old(m_Head);\r\n  //@ ensures m_Tail.contents() == \\old(item);\r\n  //@ ensures \\result == item;\r\n  public synchronized Object push(Object item) {\r\n    QueueNode newNode = new QueueNode(item);\r\n\r\n    if (m_Head == null) {\r\n      m_Head = m_Tail = newNode;\r\n    } else {\r\n      m_Tail = m_Tail.next(newNode);\r\n    }\r\n    m_Size++;\r\n    return item;\r\n  }\r\n\r\n  /**\r\n   * Pops an object from the front of the queue.\r\n   *\r\n   * @return the object at the front of the queue\r\n   * @exception RuntimeException if the queue is empty\r\n   */\r\n  //@ assignable m_Head, m_Tail, m_Size;\r\n  //@ ensures m_Size == \\old(m_Size) - 1;\r\n  //@ ensures m_Head == \\old(m_Head.m_Next);\r\n  //@ ensures m_Head != null ==\u003e m_Tail == \\old(m_Tail);\r\n  //@ ensures \\result == \\old(m_Head.m_Contents);\r\n  //@ signals (RuntimeException) \\old(m_Head) == null;\r\n  public synchronized Object pop()\r\n      throws RuntimeException   // REDUNDANT, BUT ESCJAVA REQUIRES THIS\r\n  {\r\n    if (m_Head == null) {\r\n\tthrow new RuntimeException(\"Queue is empty\");\r\n    }\r\n    Object retval = m_Head.contents();\r\n    m_Size--;\r\n    m_Head = m_Head.next();\r\n    // Here we need to either tell ESC/Java some facts about\r\n    // the contents of the list after popping off the head,\r\n    // or turn off the 'invariant' warnings.\r\n    //\r\n    //@ assume m_Size == 0 \u003c==\u003e m_Head == null;\r\n    //@ assume m_Size == 1 \u003c==\u003e m_Head == m_Tail;\r\n    if (m_Head == null) {\r\n      m_Tail = null;\r\n    }\r\n    return retval;\r\n  }\r\n\r\n  /**\r\n   * Gets object from the front of the queue.\r\n   *\r\n   * @return the object at the front of the queue\r\n   * @exception RuntimeException if the queue is empty\r\n   */\r\n  //@ ensures \\result == \\old(m_Head.m_Contents);\r\n  //@ signals (RuntimeException) \\old(m_Head) == null;\r\n  public /*@ pure @*/ synchronized Object peek()\r\n    throws RuntimeException\r\n  {\r\n    if (m_Head == null) {\r\n      throw new RuntimeException(\"Queue is empty\");\r\n    }\r\n    return m_Head.contents();\r\n  }\r\n\r\n  /**\r\n   * Checks if queue is empty.\r\n   *\r\n   * @return true if queue is empty\r\n   */\r\n  //@ ensures \\result \u003c==\u003e m_Head == null;\r\n  public /*@ pure @*/ boolean empty() {\r\n    return m_Head == null;\r\n  }\r\n\r\n  /**\r\n   * Gets queue's size.\r\n   *\r\n   * @return size of queue\r\n   */\r\n  //@ ensures \\result == m_Size;\r\n  public /*@ pure @*/ int size() {\r\n    return m_Size;\r\n  }\r\n\r\n  /**\r\n   * Produces textual description of queue.\r\n   *\r\n   * @return textual description of queue\r\n   */\r\n  //@ also\r\n  //@ ensures \\result != null;\r\n  //@ ensures (* \\result == textual description of the queue *);\r\n  public  /*@ pure @*/ String toString() {\r\n\r\n    String retval = \"Queue Contents \"+m_Size+\" elements\\n\";\r\n    QueueNode current = m_Head;\r\n    if (current == null) {\r\n      return retval + \"Empty\\n\";\r\n    } else {\r\n      while (current != null) {\r\n        retval += current.contents().toString()+\"\\n\"; //@nowarn Modifies;\r\n\tcurrent = current.next();\r\n      }\r\n    }\r\n    return retval;\r\n  } //@ nowarn Post;\r\n\r\n}\r\n",
        "name": "Queue.java",
        "path": "src/keel/Algorithms/Fuzzy_Rule_Learning/Hybrid/FURIA/core/Queue.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/Fuzzy_Rule_Learning/Hybrid/FURIA/core/Queue.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 90,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires contents != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 92,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures m_Contents == contents;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 93,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures m_Next == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 104,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires next != this ;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 106,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures m_Next==next \u0026\u0026 \\result==next;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 115,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result == m_Next;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 125,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires contents != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 136,
          "offsetAndLengths": [
            [
              6,
              12
            ]
          ],
          "preview": "      //@ ensures \\result == m_Contents;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 166,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Size == 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 167,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 168,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Tail == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 181,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires item != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 183,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 184,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Tail != \\old(m_Tail);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 185,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Size == \\old(m_Size) + 1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 186,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\old(m_Size) == 0 ==\u003e m_Head == m_Tail;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 187,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\old(m_Size) != 0 ==\u003e m_Head == \\old(m_Head);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 188,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Tail.contents() == \\old(item);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 189,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == item;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 209,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Size == \\old(m_Size) - 1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 210,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head == \\old(m_Head.m_Next);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 211,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head != null ==\u003e m_Tail == \\old(m_Tail);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 212,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == \\old(m_Head.m_Contents);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 241,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == \\old(m_Head.m_Contents);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 257,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e m_Head == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 267,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Size;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 278,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 279,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures (* \\result == textual description of the queue *);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 127,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  m_Contents == contents \u0026\u0026 \\result == contents;\r"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "/***********************************************************************\r\n\r\n\tThis file is part of KEEL-software, the Data Mining tool for regression, \r\n\tclassification, clustering, pattern mining and so on.\r\n\r\n\tCopyright (C) 2004-2010\r\n\t\r\n\tF. Herrera (herrera@decsai.ugr.es)\r\n    L. Sánchez (luciano@uniovi.es)\r\n    J. Alcalá-Fdez (jalcala@decsai.ugr.es)\r\n    S. García (sglopez@ujaen.es)\r\n    A. Fernández (alberto.fernandez@ujaen.es)\r\n    J. Luengo (julianlm@decsai.ugr.es)\r\n\r\n\tThis program is free software: you can redistribute it and/or modify\r\n\tit under the terms of the GNU General Public License as published by\r\n\tthe Free Software Foundation, either version 3 of the License, or\r\n\t(at your option) any later version.\r\n\r\n\tThis program is distributed in the hope that it will be useful,\r\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\tGNU General Public License for more details.\r\n\r\n\tYou should have received a copy of the GNU General Public License\r\n\talong with this program.  If not, see http://www.gnu.org/licenses/\r\n  \r\n**********************************************************************/\r\n\r\n/*\r\n *    This program is free software; you can redistribute it and/or modify\r\n *    it under the terms of the GNU General Public License as published by\r\n *    the Free Software Foundation; either version 2 of the License, or\r\n *    (at your option) any later version.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU General Public License\r\n *    along with this program; if not, write to the Free Software\r\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\r\n */\r\n\r\n/*\r\n *    Instance.java\r\n *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand\r\n *\r\n */\r\n\r\npackage keel.Algorithms.Fuzzy_Rule_Learning.Hybrid.FURIA.core;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.Enumeration;\r\n\r\n/**\r\n * Class for handling an instance. All values (numeric, date, nominal, string\r\n * or relational) are internally stored as floating-point numbers. If an\r\n * attribute is nominal (or a string or relational), the stored value is the\r\n * index of the corresponding nominal (or string or relational) value in the\r\n * attribute's definition. We have chosen this approach in favor of a more\r\n * elegant object-oriented approach because it is much faster. \u003cp\u003e\r\n *\r\n * Typical usage (code from the main() method of this class): \u003cp\u003e\r\n *\r\n * \u003ccode\u003e\r\n * ... \u003cbr\u003e\r\n *\r\n * // Create empty instance with three attribute values \u003cbr\u003e\r\n * Instance inst = new Instance(3); \u003cbr\u003e\u003cbr\u003e\r\n *\r\n * // Set instance's values for the attributes \"length\", \"weight\", and \"position\"\u003cbr\u003e\r\n * inst.setValue(length, 5.3); \u003cbr\u003e\r\n * inst.setValue(weight, 300); \u003cbr\u003e\r\n * inst.setValue(position, \"first\"); \u003cbr\u003e\u003cbr\u003e\r\n *\r\n * // Set instance's dataset to be the dataset \"race\" \u003cbr\u003e\r\n * inst.setDataset(race); \u003cbr\u003e\u003cbr\u003e\r\n *\r\n * // Print the instance \u003cbr\u003e\r\n * System.out.println(\"The instance: \" + inst); \u003cbr\u003e\r\n *\r\n * ... \u003cbr\u003e\r\n * \u003c/code\u003e\u003cp\u003e\r\n *\r\n * All methods that change an instance are safe, ie. a change of an\r\n * instance does not affect any other instances. All methods that\r\n * change an instance's attribute values clone the attribute value\r\n * vector before it is changed. If your application heavily modifies\r\n * instance values, it may be faster to create a new instance from scratch.\r\n *\r\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\r\n * @version $Revision: 1.28 $\r\n */\r\npublic class Instance implements Serializable {\r\n\r\n  /** for serialization */\r\n  static final long serialVersionUID = 1482635194499365122L;\r\n\r\n  /** Constant representing a missing value. */\r\n  protected static final double MISSING_VALUE = Double.NaN;\r\n\r\n  /**\r\n   * The dataset the instance has access to.  Null if the instance\r\n   * doesn't have access to any dataset.  Only if an instance has\r\n   * access to a dataset, it knows about the actual attribute types.\r\n   */\r\n  protected /*@spec_public@*/ Instances m_Dataset;\r\n\r\n  /** The instance's attribute values. */\r\n  protected /*@spec_public non_null@*/ double[] m_AttValues;\r\n\r\n  /** The instance's weight. */\r\n  protected double m_Weight;\r\n\r\n  /**\r\n   * Constructor that copies the attribute values and the weight from\r\n   * the given instance. Reference to the dataset is set to null.\r\n   * (ie. the instance doesn't have access to information about the\r\n   * attribute types)\r\n   *\r\n   * @param instance the instance from which the attribute\r\n   * values and the weight are to be copied\r\n   */\r\n  //@ ensures m_Dataset == null;\r\n  public Instance(/*@non_null@*/ Instance instance) {\r\n\r\n    m_AttValues = instance.m_AttValues;\r\n    m_Weight = instance.m_Weight;\r\n    m_Dataset = null;\r\n  }\r\n\r\n  /**\r\n   * Constructor that inititalizes instance variable with given\r\n   * values. Reference to the dataset is set to null. (ie. the instance\r\n   * doesn't have access to information about the attribute types)\r\n   *\r\n   * @param weight the instance's weight\r\n   * @param attValues a vector of attribute values\r\n   */\r\n  //@ ensures m_Dataset == null;\r\n  public Instance(double weight,  /*@non_null@*/ double[]attValues){\r\n\r\n    m_AttValues = attValues;\r\n    m_Weight = weight;\r\n    m_Dataset = null;\r\n  }\r\n\r\n  /**\r\n   * Constructor of an instance that sets weight to one, all values to\r\n   * be missing, and the reference to the dataset to null. (ie. the instance\r\n   * doesn't have access to information about the attribute types)\r\n   *\r\n   * @param numAttributes the size of the instance\r\n   */\r\n  //@ requires numAttributes \u003e 0;    // Or maybe == 0 is okay too?\r\n  //@ ensures m_Dataset == null;\r\n  public Instance(int numAttributes) {\r\n\r\n    m_AttValues = new double[numAttributes];\r\n    for (int i = 0; i \u003c m_AttValues.length; i++) {\r\n      m_AttValues[i] = MISSING_VALUE;\r\n    }\r\n    m_Weight = 1;\r\n    m_Dataset = null;\r\n  }\r\n\r\n  /**\r\n   * Returns the attribute with the given index.\r\n   *\r\n   * @param index the attribute's index\r\n   * @return the attribute at the given position\r\n   * @throws UnassignedDatasetException if instance doesn't have access to a\r\n   * dataset\r\n   */\r\n  //@ requires m_Dataset != null;\r\n  public /*@pure@*/ AttributeWeka attribute(int index) {\r\n\r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    }\r\n    return m_Dataset.attribute(index);\r\n  }\r\n\r\n  /**\r\n   * Returns the attribute with the given index. Does the same\r\n   * thing as attribute().\r\n   *\r\n   * @param indexOfIndex the index of the attribute's index\r\n   * @return the attribute at the given position\r\n   * @throws UnassignedDatasetException if instance doesn't have access to a\r\n   * dataset\r\n   */\r\n  //@ requires m_Dataset != null;\r\n  public /*@pure@*/ AttributeWeka attributeSparse(int indexOfIndex) {\r\n\r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    }\r\n    return m_Dataset.attribute(indexOfIndex);\r\n  }\r\n\r\n  /**\r\n   * Returns class attribute.\r\n   *\r\n   * @return the class attribute\r\n   * @throws UnassignedDatasetException if the class is not set or the\r\n   * instance doesn't have access to a dataset\r\n   */\r\n  //@ requires m_Dataset != null;\r\n  public /*@pure@*/ AttributeWeka classAttribute() {\r\n\r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    }\r\n    return m_Dataset.classAttribute();\r\n  }\r\n\r\n  /**\r\n   * Returns the class attribute's index.\r\n   *\r\n   * @return the class index as an integer\r\n   * @throws UnassignedDatasetException if instance doesn't have access to a dataset\r\n   */\r\n  //@ requires m_Dataset != null;\r\n  //@ ensures  \\result == m_Dataset.classIndex();\r\n  public /*@pure@*/ int classIndex() {\r\n\r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    }\r\n    return m_Dataset.classIndex();\r\n  }\r\n\r\n  /**\r\n   * Tests if an instance's class is missing.\r\n   *\r\n   * @return true if the instance's class is missing\r\n   * @throws UnassignedClassException if the class is not set or the instance doesn't\r\n   * have access to a dataset\r\n   */\r\n  //@ requires classIndex() \u003e= 0;\r\n  public /*@pure@*/ boolean classIsMissing() {\r\n\r\n    if (classIndex() \u003c 0) {\r\n      throw new UnassignedClassException(\"Class is not set!\");\r\n    }\r\n    return isMissing(classIndex());\r\n  }\r\n\r\n  /**\r\n   * Returns an instance's class value in internal format. (ie. as a\r\n   * floating-point number)\r\n   *\r\n   * @return the corresponding value as a double (If the\r\n   * corresponding attribute is nominal (or a string) then it returns the\r\n   * value's index as a double).\r\n   * @throws UnassignedClassException if the class is not set or the instance doesn't\r\n   * have access to a dataset\r\n   */\r\n  //@ requires classIndex() \u003e= 0;\r\n  public /*@pure@*/ double classValue() {\r\n\r\n    if (classIndex() \u003c 0) {\r\n      throw new UnassignedClassException(\"Class is not set!\");\r\n    }\r\n    return value(classIndex());\r\n  }\r\n\r\n  /**\r\n   * Produces a shallow copy of this instance. The copy has\r\n   * access to the same dataset. (if you want to make a copy\r\n   * that doesn't have access to the dataset, use\r\n   * \u003ccode\u003enew Instance(instance)\u003c/code\u003e\r\n   *\r\n   * @return the shallow copy\r\n   */\r\n  //@ also ensures \\result != null;\r\n  //@ also ensures \\result instanceof Instance;\r\n  //@ also ensures ((Instance)\\result).m_Dataset == m_Dataset;\r\n  public /*@pure@*/ Object copy() {\r\n\r\n    Instance result = new Instance(this);\r\n    result.m_Dataset = m_Dataset;\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns the dataset this instance has access to. (ie. obtains\r\n   * information about attribute types from) Null if the instance\r\n   * doesn't have access to a dataset.\r\n   *\r\n   * @return the dataset the instance has accesss to\r\n   */\r\n  //@ ensures \\result == m_Dataset;\r\n  public /*@pure@*/ Instances dataset() {\r\n\r\n    return m_Dataset;\r\n  }\r\n\r\n  /**\r\n   * Deletes an attribute at the given position (0 to\r\n   * numAttributes() - 1). Only succeeds if the instance does not\r\n   * have access to any dataset because otherwise inconsistencies\r\n   * could be introduced.\r\n   *\r\n   * @param position the attribute's position\r\n   * @throws RuntimeException if the instance has access to a\r\n   * dataset\r\n   */\r\n  //@ requires m_Dataset != null;\r\n  public void deleteAttributeAt(int position) {\r\n\r\n    if (m_Dataset != null) {\r\n      throw new RuntimeException(\"Instance has access to a dataset!\");\r\n    }\r\n    forceDeleteAttributeAt(position);\r\n  }\r\n\r\n  /**\r\n   * Returns an enumeration of all the attributes.\r\n   *\r\n   * @return enumeration of all the attributes\r\n   * @throws UnassignedDatasetException if the instance doesn't\r\n   * have access to a dataset\r\n   */\r\n  //@ requires m_Dataset != null;\r\n  public /*@pure@*/ Enumeration enumerateAttributes() {\r\n\r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    }\r\n    return m_Dataset.enumerateAttributes();\r\n  }\r\n\r\n  /**\r\n   * Tests if the headers of two instances are equivalent.\r\n   *\r\n   * @param inst another instance\r\n   * @return true if the header of the given instance is\r\n   * equivalent to this instance's header\r\n   * @throws UnassignedDatasetException if instance doesn't have access to any\r\n   * dataset\r\n   */\r\n  //@ requires m_Dataset != null;\r\n  public /*@pure@*/ boolean equalHeaders(Instance inst) {\r\n\r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    }\r\n    return m_Dataset.equalHeaders(inst.m_Dataset);\r\n  }\r\n\r\n  /**\r\n   * Tests whether an instance has a missing value. Skips the class attribute if set.\r\n   * @return true if instance has a missing value.\r\n   * @throws UnassignedDatasetException if instance doesn't have access to any\r\n   * dataset\r\n   */\r\n  //@ requires m_Dataset != null;\r\n  public /*@pure@*/ boolean hasMissingValue() {\r\n\r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    }\r\n    for (int i = 0; i \u003c numAttributes(); i++) {\r\n      if (i != classIndex()) {\r\n\tif (isMissing(i)) {\r\n\t  return true;\r\n\t}\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Returns the index of the attribute stored at the given position.\r\n   * Just returns the given value.\r\n   *\r\n   * @param position the position\r\n   * @return the index of the attribute stored at the given position\r\n   */\r\n  public /*@pure@*/ int index(int position) {\r\n\r\n    return position;\r\n  }\r\n\r\n  /**\r\n   * Inserts an attribute at the given position (0 to\r\n   * numAttributes()). Only succeeds if the instance does not\r\n   * have access to any dataset because otherwise inconsistencies\r\n   * could be introduced.\r\n   *\r\n   * @param position the attribute's position\r\n   * @throws RuntimeException if the instance has accesss to a\r\n   * dataset\r\n   * @throws IllegalArgumentException if the position is out of range\r\n   */\r\n  //@ requires m_Dataset == null;\r\n  //@ requires 0 \u003c= position \u0026\u0026 position \u003c= numAttributes();\r\n  public void insertAttributeAt(int position) {\r\n\r\n    if (m_Dataset != null) {\r\n      throw new RuntimeException(\"Instance has accesss to a dataset!\");\r\n    }\r\n    if ((position \u003c 0) ||\r\n\t(position \u003e numAttributes())) {\r\n      throw new IllegalArgumentException(\"Can't insert attribute: index out \"+\r\n                                         \"of range\");\r\n    }\r\n    forceInsertAttributeAt(position);\r\n  }\r\n\r\n  /**\r\n   * Tests if a specific value is \"missing\".\r\n   *\r\n   * @param attIndex the attribute's index\r\n   * @return true if the value is \"missing\"\r\n   */\r\n  public /*@pure@*/ boolean isMissing(int attIndex) {\r\n\r\n    if (Double.isNaN(m_AttValues[attIndex])) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Tests if a specific value is \"missing\". Does\r\n   * the same thing as isMissing() if applied to an Instance.\r\n   *\r\n   * @param indexOfIndex the index of the attribute's index\r\n   * @return true if the value is \"missing\"\r\n   */\r\n  public /*@pure@*/ boolean isMissingSparse(int indexOfIndex) {\r\n\r\n    if (Double.isNaN(m_AttValues[indexOfIndex])) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Tests if a specific value is \"missing\".\r\n   * The given attribute has to belong to a dataset.\r\n   *\r\n   * @param att the attribute\r\n   * @return true if the value is \"missing\"\r\n   */\r\n  public /*@pure@*/ boolean isMissing(AttributeWeka att) {\r\n\r\n    return isMissing(att.index());\r\n  }\r\n\r\n  /**\r\n   * Tests if the given value codes \"missing\".\r\n   *\r\n   * @param val the value to be tested\r\n   * @return true if val codes \"missing\"\r\n   */\r\n  public static /*@pure@*/ boolean isMissingValue(double val) {\r\n\r\n    return Double.isNaN(val);\r\n  }\r\n\r\n  /**\r\n   * Merges this instance with the given instance and returns\r\n   * the result. Dataset is set to null.\r\n   *\r\n   * @param inst the instance to be merged with this one\r\n   * @return the merged instances\r\n   */\r\n  public Instance mergeInstance(Instance inst) {\r\n\r\n    int m = 0;\r\n    double [] newVals = new double[numAttributes() + inst.numAttributes()];\r\n    for (int j = 0; j \u003c numAttributes(); j++, m++) {\r\n      newVals[m] = value(j);\r\n    }\r\n    for (int j = 0; j \u003c inst.numAttributes(); j++, m++) {\r\n      newVals[m] = inst.value(j);\r\n    }\r\n    return new Instance(1.0, newVals);\r\n  }\r\n\r\n  /**\r\n   * Returns the double that codes \"missing\".\r\n   *\r\n   * @return the double that codes \"missing\"\r\n   */\r\n  public /*@pure@*/ static double missingValue() {\r\n\r\n    return MISSING_VALUE;\r\n  }\r\n\r\n  /**\r\n   * Returns the number of attributes.\r\n   *\r\n   * @return the number of attributes as an integer\r\n   */\r\n  //@ ensures \\result == m_AttValues.length;\r\n  public /*@pure@*/ int numAttributes() {\r\n\r\n    return m_AttValues.length;\r\n  }\r\n\r\n  /**\r\n   * Returns the number of class labels.\r\n   *\r\n   * @return the number of class labels as an integer if the\r\n   * class attribute is nominal, 1 otherwise.\r\n   * @throws UnassignedDatasetException if instance doesn't have access to any\r\n   * dataset\r\n   */\r\n  //@ requires m_Dataset != null;\r\n  public /*@pure@*/ int numClasses() {\r\n\r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    }\r\n    return m_Dataset.numClasses();\r\n  }\r\n\r\n  /**\r\n   * Returns the number of values present. Always the same as numAttributes().\r\n   *\r\n   * @return the number of values\r\n   */\r\n  //@ ensures \\result == m_AttValues.length;\r\n  public /*@pure@*/ int numValues() {\r\n\r\n    return m_AttValues.length;\r\n  }\r\n\r\n  /**\r\n   * Replaces all missing values in the instance with the\r\n   * values contained in the given array. A deep copy of\r\n   * the vector of attribute values is performed before the\r\n   * values are replaced.\r\n   *\r\n   * @param array containing the means and modes\r\n   * @throws IllegalArgumentException if numbers of attributes are unequal\r\n   */\r\n  public void replaceMissingValues(double[] array) {\r\n\r\n    if ((array == null) ||\r\n\t(array.length != m_AttValues.length)) {\r\n      throw new IllegalArgumentException(\"Unequal number of attributes!\");\r\n    }\r\n    freshAttributeVector();\r\n    for (int i = 0; i \u003c m_AttValues.length; i++) {\r\n      if (isMissing(i)) {\r\n\tm_AttValues[i] = array[i];\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the class value of an instance to be \"missing\". A deep copy of\r\n   * the vector of attribute values is performed before the\r\n   * value is set to be missing.\r\n   *\r\n   * @throws UnassignedClassException if the class is not set\r\n   * @throws UnassignedDatasetException if the instance doesn't\r\n   * have access to a dataset\r\n   */\r\n  //@ requires classIndex() \u003e= 0;\r\n  public void setClassMissing() {\r\n\r\n    if (classIndex() \u003c 0) {\r\n      throw new UnassignedClassException(\"Class is not set!\");\r\n    }\r\n    setMissing(classIndex());\r\n  }\r\n\r\n  /**\r\n   * Sets the class value of an instance to the given value (internal\r\n   * floating-point format).  A deep copy of the vector of attribute\r\n   * values is performed before the value is set.\r\n   *\r\n   * @param value the new attribute value (If the corresponding\r\n   * attribute is nominal (or a string) then this is the new value's\r\n   * index as a double).\r\n   * @throws UnassignedClassException if the class is not set\r\n   * @requires classIndex() \u003e= 0;\r\n   * @throws UnassignedClassException if the instance doesn't\r\n   * have access to a dataset\r\n   */\r\n  //@ requires classIndex() \u003e= 0;\r\n  public void setClassValue(double value) {\r\n\r\n    if (classIndex() \u003c 0) {\r\n      throw new UnassignedClassException(\"Class is not set!\");\r\n    }\r\n    setValue(classIndex(), value);\r\n  }\r\n\r\n  /**\r\n   * Sets the class value of an instance to the given value. A deep\r\n   * copy of the vector of attribute values is performed before the\r\n   * value is set.\r\n   *\r\n   * @param value the new class value (If the class\r\n   * is a string attribute and the value can't be found,\r\n   * the value is added to the attribute).\r\n   * @throws UnassignedClassException if the class is not set\r\n   * @throws UnassignedDatasetException if the dataset is not set\r\n   * @throws IllegalArgumentException if the attribute is not\r\n   * nominal or a string, or the value couldn't be found for a nominal\r\n   * attribute\r\n   */\r\n  //@ requires classIndex() \u003e= 0;\r\n  public final void setClassValue(String value) {\r\n\r\n    if (classIndex() \u003c 0) {\r\n      throw new UnassignedClassException(\"Class is not set!\");\r\n    }\r\n    setValue(classIndex(), value);\r\n  }\r\n\r\n  /**\r\n   * Sets the reference to the dataset. Does not check if the instance\r\n   * is compatible with the dataset. Note: the dataset does not know\r\n   * about this instance. If the structure of the dataset's header\r\n   * gets changed, this instance will not be adjusted automatically.\r\n   *\r\n   * @param instances the reference to the dataset\r\n   */\r\n  public final void setDataset(Instances instances) {\r\n\r\n    m_Dataset = instances;\r\n  }\r\n\r\n  /**\r\n   * Sets a specific value to be \"missing\". Performs a deep copy\r\n   * of the vector of attribute values before the value is set to\r\n   * be missing.\r\n   *\r\n   * @param attIndex the attribute's index\r\n   */\r\n  public final void setMissing(int attIndex) {\r\n\r\n    setValue(attIndex, MISSING_VALUE);\r\n  }\r\n\r\n  /**\r\n   * Sets a specific value to be \"missing\". Performs a deep copy\r\n   * of the vector of attribute values before the value is set to\r\n   * be missing. The given attribute has to belong to a dataset.\r\n   *\r\n   * @param att the attribute\r\n   */\r\n  public final void setMissing(AttributeWeka att) {\r\n\r\n    setMissing(att.index());\r\n  }\r\n\r\n  /**\r\n   * Sets a specific value in the instance to the given value\r\n   * (internal floating-point format). Performs a deep copy\r\n   * of the vector of attribute values before the value is set.\r\n   *\r\n   * @param attIndex the attribute's index\r\n   * @param value the new attribute value (If the corresponding\r\n   * attribute is nominal (or a string) then this is the new value's\r\n   * index as a double).\r\n   */\r\n  public void setValue(int attIndex, double value) {\r\n\r\n    freshAttributeVector();\r\n    m_AttValues[attIndex] = value;\r\n  }\r\n\r\n  /**\r\n   * Sets a specific value in the instance to the given value\r\n   * (internal floating-point format). Performs a deep copy\r\n   * of the vector of attribute values before the value is set.\r\n   * Does exactly the same thing as setValue().\r\n   *\r\n   * @param indexOfIndex the index of the attribute's index\r\n   * @param value the new attribute value (If the corresponding\r\n   * attribute is nominal (or a string) then this is the new value's\r\n   * index as a double).\r\n   */\r\n  public void setValueSparse(int indexOfIndex, double value) {\r\n\r\n    freshAttributeVector();\r\n    m_AttValues[indexOfIndex] = value;\r\n  }\r\n\r\n  /**\r\n   * Sets a value of a nominal or string attribute to the given\r\n   * value. Performs a deep copy of the vector of attribute values\r\n   * before the value is set.\r\n   *\r\n   * @param attIndex the attribute's index\r\n   * @param value the new attribute value (If the attribute\r\n   * is a string attribute and the value can't be found,\r\n   * the value is added to the attribute).\r\n   * @throws UnassignedDatasetException if the dataset is not set\r\n   * @throws IllegalArgumentException if the selected\r\n   * attribute is not nominal or a string, or the supplied value couldn't\r\n   * be found for a nominal attribute\r\n   */\r\n  //@ requires m_Dataset != null;\r\n  public final void setValue(int attIndex, String value) {\r\n\r\n    int valIndex;\r\n\r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    }\r\n    if (!attribute(attIndex).isNominal() \u0026\u0026\r\n\t!attribute(attIndex).isString()) {\r\n      throw new IllegalArgumentException(\"AttributeWeka neither nominal nor string!\");\r\n    }\r\n    valIndex = attribute(attIndex).indexOfValue(value);\r\n    if (valIndex == -1) {\r\n      if (attribute(attIndex).isNominal()) {\r\n\tthrow new IllegalArgumentException(\"Value not defined for given nominal attribute!\");\r\n      } else {\r\n\tattribute(attIndex).forceAddValue(value);\r\n\tvalIndex = attribute(attIndex).indexOfValue(value);\r\n      }\r\n    }\r\n    setValue(attIndex, (double)valIndex);\r\n  }\r\n\r\n  /**\r\n   * Sets a specific value in the instance to the given value\r\n   * (internal floating-point format). Performs a deep copy of the\r\n   * vector of attribute values before the value is set, so if you are\r\n   * planning on calling setValue many times it may be faster to\r\n   * create a new instance using toDoubleArray.  The given attribute\r\n   * has to belong to a dataset.\r\n   *\r\n   * @param att the attribute\r\n   * @param value the new attribute value (If the corresponding\r\n   * attribute is nominal (or a string) then this is the new value's\r\n   * index as a double).\r\n   */\r\n  public final void setValue(AttributeWeka att, double value) {\r\n\r\n    setValue(att.index(), value);\r\n  }\r\n\r\n  /**\r\n   * Sets a value of an nominal or string attribute to the given\r\n   * value. Performs a deep copy of the vector of attribute values\r\n   * before the value is set, so if you are planning on calling setValue many\r\n   * times it may be faster to create a new instance using toDoubleArray.\r\n   * The given attribute has to belong to a dataset.\r\n   *\r\n   * @param att the attribute\r\n   * @param value the new attribute value (If the attribute\r\n   * is a string attribute and the value can't be found,\r\n   * the value is added to the attribute).\r\n   * @throws IllegalArgumentException if the the attribute is not\r\n   * nominal or a string, or the value couldn't be found for a nominal\r\n   * attribute\r\n   */\r\n  public final void setValue(AttributeWeka att, String value) {\r\n\r\n    if (!att.isNominal() \u0026\u0026\r\n\t!att.isString()) {\r\n      throw new IllegalArgumentException(\"AttributeWeka neither nominal nor string!\");\r\n    }\r\n    int valIndex = att.indexOfValue(value);\r\n    if (valIndex == -1) {\r\n      if (att.isNominal()) {\r\n\tthrow new IllegalArgumentException(\"Value not defined for given nominal attribute!\");\r\n      } else {\r\n\tatt.forceAddValue(value);\r\n\tvalIndex = att.indexOfValue(value);\r\n      }\r\n    }\r\n    setValue(att.index(), (double)valIndex);\r\n  }\r\n\r\n  /**\r\n   * Modifies the instances value for an attribute (floating point\r\n   * representation). Unlike in \u003ccode\u003esetValue\u003c/code\u003e no deep copy is\r\n   * produced, i.e. the actual value is modified.\r\n   *\r\n   * @param attIndex the attribute's index\r\n   * @param value the new attribute value (If the corresponding\r\n   * attribute is nominal (or a string) then this is the new value's\r\n   * index as a double).\r\n   * @author Arne Muller (arne.muller@gmail.com)\r\n   */\r\n  public void modifyValue(int attIndex, double value) {\r\n\r\n    m_AttValues[attIndex] = value;\r\n  }\r\n\r\n  /**\r\n   * Sets the weight of an instance.\r\n   *\r\n   * @param weight the weight\r\n   */\r\n  public final void setWeight(double weight) {\r\n\r\n    m_Weight = weight;\r\n  }\r\n\r\n  /**\r\n   * Returns the relational value of a relational attribute.\r\n   *\r\n   * @param attIndex the attribute's index\r\n   * @return the corresponding relation as an Instances object\r\n   * @throws IllegalArgumentException if the attribute is not a\r\n   * relation-valued attribute\r\n   * @throws UnassignedDatasetException if the instance doesn't belong\r\n   * to a dataset.\r\n   */\r\n  //@ requires m_Dataset != null;\r\n  public final /*@pure@*/ Instances relationalValue(int attIndex) {\r\n\r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    }\r\n    return relationalValue(m_Dataset.attribute(attIndex));\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns the relational value of a relational attribute.\r\n   *\r\n   * @param att the attribute\r\n   * @return the corresponding relation as an Instances object\r\n   * @throws IllegalArgumentException if the attribute is not a\r\n   * relation-valued attribute\r\n   * @throws UnassignedDatasetException if the instance doesn't belong\r\n   * to a dataset.\r\n   */\r\n  public final /*@pure@*/ Instances relationalValue(AttributeWeka att) {\r\n\r\n    int attIndex = att.index();\r\n    if (att.isRelationValued()) {\r\n      return att.relation((int) value(attIndex));\r\n    } else {\r\n      throw new IllegalArgumentException(\"AttributeWeka isn't relation-valued!\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the value of a nominal, string, date, or relational attribute\r\n   * for the instance as a string.\r\n   *\r\n   * @param attIndex the attribute's index\r\n   * @return the value as a string\r\n   * @throws IllegalArgumentException if the attribute is not a nominal,\r\n   * string, date, or relation-valued attribute.\r\n   * @throws UnassignedDatasetException if the instance doesn't belong\r\n   * to a dataset.\r\n   */\r\n  //@ requires m_Dataset != null;\r\n  public final /*@pure@*/ String stringValue(int attIndex) {\r\n\r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    }\r\n    return stringValue(m_Dataset.attribute(attIndex));\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns the value of a nominal, string, date, or relational attribute\r\n   * for the instance as a string.\r\n   *\r\n   * @param att the attribute\r\n   * @return the value as a string\r\n   * @throws IllegalArgumentException if the attribute is not a nominal,\r\n   * string, date, or relation-valued attribute.\r\n   * @throws UnassignedDatasetException if the instance doesn't belong\r\n   * to a dataset.\r\n   */\r\n  public final /*@pure@*/ String stringValue(AttributeWeka att) {\r\n\r\n    int attIndex = att.index();\r\n    switch (att.type()) {\r\n    case AttributeWeka.NOMINAL:\r\n    case AttributeWeka.STRING:\r\n      return att.value((int) value(attIndex));\r\n    case AttributeWeka.DATE:\r\n      return att.formatDate(value(attIndex));\r\n    case AttributeWeka.RELATIONAL:\r\n      return att.relation((int) value(attIndex)).stringWithoutHeader();\r\n    default:\r\n      throw new IllegalArgumentException(\"AttributeWeka isn't nominal, string or date!\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the values of each attribute as an array of doubles.\r\n   *\r\n   * @return an array containing all the instance attribute values\r\n   */\r\n  public double[] toDoubleArray() {\r\n\r\n    double[] newValues = new double[m_AttValues.length];\r\n    System.arraycopy(m_AttValues, 0, newValues, 0,\r\n\t\t     m_AttValues.length);\r\n    return newValues;\r\n  }\r\n\r\n  /**\r\n   * Returns the description of one instance. If the instance\r\n   * doesn't have access to a dataset, it returns the internal\r\n   * floating-point values. Quotes string\r\n   * values that contain whitespace characters.\r\n   *\r\n   * @return the instance's description as a string\r\n   */\r\n  public String toString() {\r\n\r\n    StringBuffer text = new StringBuffer();\r\n\r\n    for (int i = 0; i \u003c m_AttValues.length; i++) {\r\n      if (i \u003e 0) text.append(\",\");\r\n      text.append(toString(i));\r\n    }\r\n\r\n    if (m_Weight != 1.0) {\r\n      text.append(\",{\" + Utils.doubleToString(m_Weight, 6) + \"}\");\r\n    }\r\n\r\n    return text.toString();\r\n  }\r\n\r\n  /**\r\n   * Returns the description of one value of the instance as a\r\n   * string. If the instance doesn't have access to a dataset, it\r\n   * returns the internal floating-point value. Quotes string\r\n   * values that contain whitespace characters, or if they\r\n   * are a question mark.\r\n   *\r\n   * @param attIndex the attribute's index\r\n   * @return the value's description as a string\r\n   */\r\n  public final /*@pure@*/ String toString(int attIndex) {\r\n\r\n   StringBuffer text = new StringBuffer();\r\n\r\n   if (isMissing(attIndex)) {\r\n     text.append(\"?\");\r\n   } else {\r\n     if (m_Dataset == null) {\r\n       text.append(Utils.doubleToString(m_AttValues[attIndex],6));\r\n     } else {\r\n       switch (m_Dataset.attribute(attIndex).type()) {\r\n       case AttributeWeka.NOMINAL:\r\n       case AttributeWeka.STRING:\r\n       case AttributeWeka.DATE:\r\n       case AttributeWeka.RELATIONAL:\r\n         text.append(Utils.quote(stringValue(attIndex)));\r\n         break;\r\n       case AttributeWeka.NUMERIC:\r\n\t text.append(Utils.doubleToString(value(attIndex),6));\r\n         break;\r\n       default:\r\n         throw new IllegalStateException(\"Unknown attribute type\");\r\n       }\r\n     }\r\n   }\r\n   return text.toString();\r\n  }\r\n\r\n  /**\r\n   * Returns the description of one value of the instance as a\r\n   * string. If the instance doesn't have access to a dataset it\r\n   * returns the internal floating-point value. Quotes string\r\n   * values that contain whitespace characters, or if they\r\n   * are a question mark.\r\n   * The given attribute has to belong to a dataset.\r\n   *\r\n   * @param att the attribute\r\n   * @return the value's description as a string\r\n   */\r\n  public final String toString(AttributeWeka att) {\r\n\r\n   return toString(att.index());\r\n  }\r\n\r\n  /**\r\n   * Returns an instance's attribute value in internal format.\r\n   *\r\n   * @param attIndex the attribute's index\r\n   * @return the specified value as a double (If the corresponding\r\n   * attribute is nominal (or a string) then it returns the value's index as a\r\n   * double).\r\n   */\r\n  public /*@pure@*/ double value(int attIndex) {\r\n\r\n    return m_AttValues[attIndex];\r\n  }\r\n\r\n  /**\r\n   * Returns an instance's attribute value in internal format.\r\n   * Does exactly the same thing as value() if applied to an Instance.\r\n   *\r\n   * @param indexOfIndex the index of the attribute's index\r\n   * @return the specified value as a double (If the corresponding\r\n   * attribute is nominal (or a string) then it returns the value's index as a\r\n   * double).\r\n   */\r\n  public /*@pure@*/ double valueSparse(int indexOfIndex) {\r\n\r\n    return m_AttValues[indexOfIndex];\r\n  }\r\n\r\n  /**\r\n   * Returns an instance's attribute value in internal format.\r\n   * The given attribute has to belong to a dataset.\r\n   *\r\n   * @param att the attribute\r\n   * @return the specified value as a double (If the corresponding\r\n   * attribute is nominal (or a string) then it returns the value's index as a\r\n   * double).\r\n   */\r\n  public /*@pure@*/ double value(AttributeWeka att) {\r\n\r\n    return value(att.index());\r\n  }\r\n\r\n  /**\r\n   * Returns the instance's weight.\r\n   *\r\n   * @return the instance's weight as a double\r\n   */\r\n  public final /*@pure@*/ double weight() {\r\n\r\n    return m_Weight;\r\n  }\r\n\r\n  /**\r\n   * Deletes an attribute at the given position (0 to\r\n   * numAttributes() - 1).\r\n   *\r\n   * @param position the attribute's position\r\n   */\r\n  void forceDeleteAttributeAt(int position) {\r\n\r\n    double[] newValues = new double[m_AttValues.length - 1];\r\n\r\n    System.arraycopy(m_AttValues, 0, newValues, 0, position);\r\n    if (position \u003c m_AttValues.length - 1) {\r\n      System.arraycopy(m_AttValues, position + 1,\r\n\t\t       newValues, position,\r\n\t\t       m_AttValues.length - (position + 1));\r\n    }\r\n    m_AttValues = newValues;\r\n  }\r\n\r\n  /**\r\n   * Inserts an attribute at the given position\r\n   * (0 to numAttributes()) and sets its value to be missing.\r\n   *\r\n   * @param position the attribute's position\r\n   */\r\n  void forceInsertAttributeAt(int position)  {\r\n\r\n    double[] newValues = new double[m_AttValues.length + 1];\r\n\r\n    System.arraycopy(m_AttValues, 0, newValues, 0, position);\r\n    newValues[position] = MISSING_VALUE;\r\n    System.arraycopy(m_AttValues, position, newValues,\r\n\t\t     position + 1, m_AttValues.length - position);\r\n    m_AttValues = newValues;\r\n  }\r\n\r\n  /**\r\n   * Private constructor for subclasses. Does nothing.\r\n   */\r\n  protected Instance() {\r\n  }\r\n\r\n  /**\r\n   * Clones the attribute vector of the instance and\r\n   * overwrites it with the clone.\r\n   */\r\n  private void freshAttributeVector() {\r\n\r\n    m_AttValues = toDoubleArray();\r\n  }\r\n\r\n}\r\n",
        "name": "Instance.java",
        "path": "src/keel/Algorithms/Fuzzy_Rule_Learning/Hybrid/FURIA/core/Instance.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/Fuzzy_Rule_Learning/Hybrid/FURIA/core/Instance.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 125,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Dataset == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 141,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Dataset == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 156,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires numAttributes \u003e 0;    // Or maybe == 0 is okay too?\r"
        },
        {
          "limitHit": false,
          "lineNumber": 157,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Dataset == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 176,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 194,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 210,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 225,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 242,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 261,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 295,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Dataset;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 311,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 327,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 345,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 360,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 399,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 400,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= position \u0026\u0026 position \u003c= numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 501,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_AttValues.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 515,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 529,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_AttValues.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 567,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 589,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 612,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 705,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 816,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 857,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 226,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  \\result == m_Dataset.classIndex();\r"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "/***********************************************************************\r\n\r\n\tThis file is part of KEEL-software, the Data Mining tool for regression, \r\n\tclassification, clustering, pattern mining and so on.\r\n\r\n\tCopyright (C) 2004-2010\r\n\t\r\n\tF. Herrera (herrera@decsai.ugr.es)\r\n    L. Sánchez (luciano@uniovi.es)\r\n    J. Alcalá-Fdez (jalcala@decsai.ugr.es)\r\n    S. García (sglopez@ujaen.es)\r\n    A. Fernández (alberto.fernandez@ujaen.es)\r\n    J. Luengo (julianlm@decsai.ugr.es)\r\n\r\n\tThis program is free software: you can redistribute it and/or modify\r\n\tit under the terms of the GNU General Public License as published by\r\n\tthe Free Software Foundation, either version 3 of the License, or\r\n\t(at your option) any later version.\r\n\r\n\tThis program is distributed in the hope that it will be useful,\r\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\tGNU General Public License for more details.\r\n\r\n\tYou should have received a copy of the GNU General Public License\r\n\talong with this program.  If not, see http://www.gnu.org/licenses/\r\n  \r\n**********************************************************************/\r\n\r\n/*\r\n *    This program is free software; you can redistribute it and/or modify\r\n *    it under the terms of the GNU General Public License as published by\r\n *    the Free Software Foundation; either version 2 of the License, or\r\n *    (at your option) any later version.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU General Public License\r\n *    along with this program; if not, write to the Free Software\r\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\r\n */\r\n\r\n/*\r\n *    Instances.java\r\n *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand\r\n *\r\n */\r\n\r\npackage keel.Algorithms.Fuzzy_Rule_Learning.Hybrid.FURIA.core;\r\n\r\nimport org.core.Randomize;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\nimport java.io.Reader;\r\nimport java.io.Serializable;\r\nimport java.util.Enumeration;\r\n//import java.util.Random;\r\n\r\n/**\r\n * Class for handling an ordered set of weighted instances. \u003cp\u003e\r\n *\r\n * Typical usage: \u003cp\u003e\r\n * \u003cpre\u003e\r\n * import weka.core.converters.ConverterUtils.DataSource;\r\n * ...\r\n *\r\n * // Read all the instances in the file (ARFF, CSV, XRFF, ...)\r\n * DataSource source = new DataSource(filename);\r\n * Instances instances = source.getDataSet();\r\n *\r\n * // Make the last attribute be the class\r\n * instances.setClassIndex(instances.numAttributes() - 1);\r\n *\r\n * // Print header and instances.\r\n * System.out.println(\"\\nDataset:\\n\");\r\n * System.out.println(instances);\r\n *\r\n * ...\r\n * \u003c/pre\u003e\u003cp\u003e\r\n *\r\n * All methods that change a set of instances are safe, ie. a change\r\n * of a set of instances does not affect any other sets of\r\n * instances. All methods that change a datasets's attribute\r\n * information clone the dataset before it is changed.\r\n *\r\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\r\n * @author Len Trigg (trigg@cs.waikato.ac.nz)\r\n * @author FracPete (fracpete at waikato dot ac dot nz)\r\n * @version $Revision: 1.76 $\r\n */\r\npublic class Instances  implements Serializable {\r\n\r\n  /** for serialization */\r\n  static final long serialVersionUID = -19412345060742748L;\r\n\r\n  /** The filename extension that should be used for arff files */\r\n  public final static String FILE_EXTENSION = \".arff\";\r\n\r\n  /** The filename extension that should be used for bin. serialized instances files */\r\n  public final static String SERIALIZED_OBJ_FILE_EXTENSION = \".bsi\";\r\n\r\n  /** The keyword used to denote the start of an arff header */\r\n  public final static String ARFF_RELATION = \"@relation\";\r\n\r\n  /** The keyword used to denote the start of the arff data section */\r\n  public final static String ARFF_DATA = \"@data\";\r\n\r\n  /** The dataset's name. */\r\n  protected /*@spec_public non_null@*/ String m_RelationName;\r\n\r\n  /** The attribute information. */\r\n  protected /*@spec_public non_null@*/ FastVector m_Attributes;\r\n  /*  public invariant (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c m_Attributes.size();\r\n                    m_Attributes.elementAt(i) != null);\r\n  */\r\n\r\n  /** The instances. */\r\n  protected /*@spec_public non_null@*/ FastVector m_Instances;\r\n\r\n  /** The class attribute's index */\r\n  protected int m_ClassIndex;\r\n  //@ protected invariant classIndex() == m_ClassIndex;\r\n\r\n  /** The lines read so far in case of incremental loading. Since the\r\n   * StreamTokenizer will be re-initialized with every instance that is read,\r\n   * we have to keep track of the number of lines read so far.\r\n   * @see #readInstance(Reader) */\r\n  protected int m_Lines = 0;\r\n\r\n  /** used in randomizeAttribute and undoRandomizeAttribute to store/restore\r\n   * the index of attribute that was last shuffled, and it's original values\r\n   */\r\n  private int attIdx4Randomization = -1;\r\n  private double[] attIdxOrigValues;\r\n\r\n  /**\r\n   * Constructor copying all instances and references to\r\n   * the header information from the given set of instances.\r\n   *\r\n   * @param dataset the set to be copied\r\n   */\r\n  public Instances(/*@non_null@*/Instances dataset) {\r\n\r\n    this(dataset, dataset.numInstances());\r\n\r\n    dataset.copyInstances(0, this, dataset.numInstances());\r\n  }\r\n\r\n  /**\r\n   * Constructor creating an empty set of instances. Copies references\r\n   * to the header information from the given set of instances. Sets\r\n   * the capacity of the set of instances to 0 if its negative.\r\n   *\r\n   * @param dataset the instances from which the header\r\n   * information is to be taken\r\n   * @param capacity the capacity of the new dataset\r\n   */\r\n  public Instances(/*@non_null@*/Instances dataset, int capacity) {\r\n    initialize(dataset, capacity);\r\n  }\r\n\r\n  /**\r\n   * initializes with the header information of the given dataset and sets\r\n   * the capacity of the set of instances.\r\n   *\r\n   * @param dataset the dataset to use as template\r\n   * @param capacity the number of rows to reserve\r\n   */\r\n  protected void initialize(Instances dataset, int capacity) {\r\n    if (capacity \u003c 0)\r\n      capacity = 0;\r\n\r\n    // Strings only have to be \"shallow\" copied because\r\n    // they can't be modified.\r\n    m_ClassIndex   = dataset.m_ClassIndex;\r\n    m_RelationName = dataset.m_RelationName;\r\n    m_Attributes   = dataset.m_Attributes;\r\n    m_Instances    = new FastVector(capacity);\r\n  }\r\n\r\n  /**\r\n   * Creates a new set of instances by copying a\r\n   * subset of another set.\r\n   *\r\n   * @param source the set of instances from which a subset\r\n   * is to be created\r\n   * @param first the index of the first instance to be copied\r\n   * @param toCopy the number of instances to be copied\r\n   * @throws IllegalArgumentException if first and toCopy are out of range\r\n   */\r\n  //@ requires 0 \u003c= first;\r\n  //@ requires 0 \u003c= toCopy;\r\n  //@ requires first + toCopy \u003c= source.numInstances();\r\n  public Instances(/*@non_null@*/Instances source, int first, int toCopy) {\r\n\r\n    this(source, toCopy);\r\n\r\n    if ((first \u003c 0) || ((first + toCopy) \u003e source.numInstances())) {\r\n      throw new IllegalArgumentException(\"Parameters first and/or toCopy out \"+\r\n                                         \"of range\");\r\n    }\r\n    source.copyInstances(first, this, toCopy);\r\n  }\r\n\r\n  /**\r\n   * Creates an empty set of instances. Uses the given\r\n   * attribute information. Sets the capacity of the set of\r\n   * instances to 0 if its negative. Given attribute information\r\n   * must not be changed after this constructor has been used.\r\n   *\r\n   * @param name the name of the relation\r\n   * @param attInfo the attribute information\r\n   * @param capacity the capacity of the set\r\n   */\r\n  public Instances(/*@non_null@*/String name,\r\n\t\t   /*@non_null@*/FastVector attInfo, int capacity) {\r\n\r\n    m_RelationName = name;\r\n    m_ClassIndex = -1;\r\n    m_Attributes = attInfo;\r\n    for (int i = 0; i \u003c numAttributes(); i++) {\r\n      attribute(i).setIndex(i);\r\n    }\r\n    m_Instances = new FastVector(capacity);\r\n  }\r\n\r\n\r\n  /**\r\n   * Create a copy of the structure if the data has string or\r\n   * relational attributes, \"cleanses\" string types (i.e. doesn't\r\n   * contain references to the strings seen in the past) and all\r\n   * relational attributes.\r\n   *\r\n   * @return a copy of the instance structure.\r\n   */\r\n  public Instances stringFreeStructure() {\r\n\r\n    FastVector newAtts = new FastVector();\r\n    for (int i = 0 ; i \u003c m_Attributes.size(); i++) {\r\n      AttributeWeka att = (AttributeWeka)m_Attributes.elementAt(i);\r\n      if (att.type() == AttributeWeka.STRING) {\r\n        newAtts.addElement(new AttributeWeka(att.name(), (FastVector)null, i));\r\n      } else if (att.type() == AttributeWeka.RELATIONAL) {\r\n        newAtts.addElement(new AttributeWeka(att.name(), new Instances(att.relation(), 0), i));\r\n      }\r\n    }\r\n    if (newAtts.size() == 0) {\r\n      return new Instances(this, 0);\r\n    }\r\n    FastVector atts = (FastVector)m_Attributes.copy();\r\n    for (int i = 0; i \u003c newAtts.size(); i++) {\r\n      atts.setElementAt(newAtts.elementAt(i), ((AttributeWeka)newAtts.elementAt(i)).index());\r\n    }\r\n    Instances result = new Instances(this, 0);\r\n    result.m_Attributes = atts;\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Adds one instance to the end of the set.\r\n   * Shallow copies instance before it is added. Increases the\r\n   * size of the dataset if it is not large enough. Does not\r\n   * check if the instance is compatible with the dataset.\r\n   * Note: String or relational values are not transferred.\r\n   *\r\n   * @param instance the instance to be added\r\n   */\r\n  public void add(/*@non_null@*/ Instance instance) {\r\n\r\n    Instance newInstance = (Instance)instance.copy();\r\n\r\n    newInstance.setDataset(this);\r\n    m_Instances.addElement(newInstance);\r\n  }\r\n\r\n  /**\r\n   * Returns an attribute.\r\n   *\r\n   * @param index the attribute's index (index starts with 0)\r\n   * @return the attribute at the given position\r\n   */\r\n  //@ requires 0 \u003c= index;\r\n  //@ requires index \u003c m_Attributes.size();\r\n  //@ ensures \\result != null;\r\n  public /*@pure@*/ AttributeWeka attribute(int index) {\r\n\r\n    return (AttributeWeka) m_Attributes.elementAt(index);\r\n  }\r\n\r\n  /**\r\n   * Returns an attribute given its name. If there is more than\r\n   * one attribute with the same name, it returns the first one.\r\n   * Returns null if the attribute can't be found.\r\n   *\r\n   * @param name the attribute's name\r\n   * @return the attribute with the given name, null if the\r\n   * attribute can't be found\r\n   */\r\n  public /*@pure@*/ AttributeWeka attribute(String name) {\r\n\r\n    for (int i = 0; i \u003c numAttributes(); i++) {\r\n      if (attribute(i).name().equals(name)) {\r\n\treturn attribute(i);\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Checks for attributes of the given type in the dataset\r\n   *\r\n   * @param attType  the attribute type to look for\r\n   * @return         true if attributes of the given type are present\r\n   */\r\n  public boolean checkForAttributeType(int attType) {\r\n\r\n    int i = 0;\r\n\r\n    while (i \u003c m_Attributes.size()) {\r\n      if (attribute(i++).type() == attType) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Checks for string attributes in the dataset\r\n   *\r\n   * @return true if string attributes are present, false otherwise\r\n   */\r\n  public /*@pure@*/ boolean checkForStringAttributes() {\r\n    return checkForAttributeType(AttributeWeka.STRING);\r\n  }\r\n\r\n  /**\r\n   * Checks if the given instance is compatible\r\n   * with this dataset. Only looks at the size of\r\n   * the instance and the ranges of the values for\r\n   * nominal and string attributes.\r\n   *\r\n   * @param instance the instance to check\r\n   * @return true if the instance is compatible with the dataset\r\n   */\r\n  public /*@pure@*/ boolean checkInstance(Instance instance) {\r\n\r\n    if (instance.numAttributes() != numAttributes()) {\r\n      return false;\r\n    }\r\n    for (int i = 0; i \u003c numAttributes(); i++) {\r\n      if (instance.isMissing(i)) {\r\n\tcontinue;\r\n      } else if (attribute(i).isNominal() ||\r\n\t\t attribute(i).isString()) {\r\n\tif (!(Utils.eq(instance.value(i),\r\n\t\t       (double)(int)instance.value(i)))) {\r\n\t  return false;\r\n\t} else if (Utils.sm(instance.value(i), 0) ||\r\n\t\t   Utils.gr(instance.value(i),\r\n\t\t\t    attribute(i).numValues())) {\r\n\t  return false;\r\n\t}\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Returns the class attribute.\r\n   *\r\n   * @return the class attribute\r\n   * @throws UnassignedClassException if the class is not set\r\n   */\r\n  //@ requires classIndex() \u003e= 0;\r\n  public /*@pure@*/ AttributeWeka classAttribute() {\r\n\r\n    if (m_ClassIndex \u003c 0) {\r\n      throw new UnassignedClassException(\"Class index is negative (not set)!\");\r\n    }\r\n    return attribute(m_ClassIndex);\r\n  }\r\n\r\n  /**\r\n   * Returns the class attribute's index. Returns negative number\r\n   * if it's undefined.\r\n   *\r\n   * @return the class index as an integer\r\n   */\r\n  // ensures \\result == m_ClassIndex;\r\n  public /*@pure@*/ int classIndex() {\r\n\r\n    return m_ClassIndex;\r\n  }\r\n\r\n  /**\r\n   * Compactifies the set of instances. Decreases the capacity of\r\n   * the set so that it matches the number of instances in the set.\r\n   */\r\n  public void compactify() {\r\n\r\n    m_Instances.trimToSize();\r\n  }\r\n\r\n  /**\r\n   * Removes all instances from the set.\r\n   */\r\n  public void delete() {\r\n\r\n    m_Instances = new FastVector();\r\n  }\r\n\r\n  /**\r\n   * Removes an instance at the given position from the set.\r\n   *\r\n   * @param index the instance's position (index starts with 0)\r\n   */\r\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numInstances();\r\n  public void delete(int index) {\r\n\r\n    m_Instances.removeElementAt(index);\r\n  }\r\n\r\n  /**\r\n   * Deletes an attribute at the given position\r\n   * (0 to numAttributes() - 1). A deep copy of the attribute\r\n   * information is performed before the attribute is deleted.\r\n   *\r\n   * @param position the attribute's position (position starts with 0)\r\n   * @throws IllegalArgumentException if the given index is out of range\r\n   *            or the class attribute is being deleted\r\n   */\r\n  //@ requires 0 \u003c= position \u0026\u0026 position \u003c numAttributes();\r\n  //@ requires position != classIndex();\r\n  public void deleteAttributeAt(int position) {\r\n\r\n    if ((position \u003c 0) || (position \u003e= m_Attributes.size())) {\r\n      throw new IllegalArgumentException(\"Index out of range\");\r\n    }\r\n    if (position == m_ClassIndex) {\r\n      throw new IllegalArgumentException(\"Can't delete class attribute\");\r\n    }\r\n    freshAttributeInfo();\r\n    if (m_ClassIndex \u003e position) {\r\n      m_ClassIndex--;\r\n    }\r\n    m_Attributes.removeElementAt(position);\r\n    for (int i = position; i \u003c m_Attributes.size(); i++) {\r\n      AttributeWeka current = (AttributeWeka)m_Attributes.elementAt(i);\r\n      current.setIndex(current.index() - 1);\r\n    }\r\n    for (int i = 0; i \u003c numInstances(); i++) {\r\n      instance(i).forceDeleteAttributeAt(position);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deletes all attributes of the given type in the dataset. A deep copy of\r\n   * the attribute information is performed before an attribute is deleted.\r\n   *\r\n   * @param attType the attribute type to delete\r\n   * @throws IllegalArgumentException if attribute couldn't be\r\n   * successfully deleted (probably because it is the class attribute).\r\n   */\r\n  public void deleteAttributeType(int attType) {\r\n    int i = 0;\r\n    while (i \u003c m_Attributes.size()) {\r\n      if (attribute(i).type() == attType) {\r\n        deleteAttributeAt(i);\r\n      } else {\r\n        i++;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deletes all string attributes in the dataset. A deep copy of the attribute\r\n   * information is performed before an attribute is deleted.\r\n   *\r\n   * @throws IllegalArgumentException if string attribute couldn't be\r\n   * successfully deleted (probably because it is the class attribute).\r\n   * @see #deleteAttributeType(int)\r\n   */\r\n  public void deleteStringAttributes() {\r\n    deleteAttributeType(AttributeWeka.STRING);\r\n  }\r\n\r\n  /**\r\n   * Removes all instances with missing values for a particular\r\n   * attribute from the dataset.\r\n   *\r\n   * @param attIndex the attribute's index (index starts with 0)\r\n   */\r\n  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\r\n  public void deleteWithMissing(int attIndex) {\r\n\r\n    FastVector newInstances = new FastVector(numInstances());\r\n\r\n    for (int i = 0; i \u003c numInstances(); i++) {\r\n      if (!instance(i).isMissing(attIndex)) {\r\n\tnewInstances.addElement(instance(i));\r\n      }\r\n    }\r\n    m_Instances = newInstances;\r\n  }\r\n\r\n  /**\r\n   * Removes all instances with missing values for a particular\r\n   * attribute from the dataset.\r\n   *\r\n   * @param att the attribute\r\n   */\r\n  public void deleteWithMissing(/*@non_null@*/ AttributeWeka att) {\r\n\r\n    deleteWithMissing(att.index());\r\n  }\r\n\r\n  /**\r\n   * Removes all instances with a missing class value\r\n   * from the dataset.\r\n   *\r\n   * @throws UnassignedClassException if class is not set\r\n   */\r\n  public void deleteWithMissingClass() {\r\n\r\n    if (m_ClassIndex \u003c 0) {\r\n      throw new UnassignedClassException(\"Class index is negative (not set)!\");\r\n    }\r\n    deleteWithMissing(m_ClassIndex);\r\n  }\r\n\r\n  /**\r\n   * Returns an enumeration of all the attributes.\r\n   *\r\n   * @return enumeration of all the attributes.\r\n   */\r\n  public /*@non_null pure@*/ Enumeration enumerateAttributes() {\r\n\r\n    return m_Attributes.elements(m_ClassIndex);\r\n  }\r\n\r\n  /**\r\n   * Returns an enumeration of all instances in the dataset.\r\n   *\r\n   * @return enumeration of all instances in the dataset\r\n   */\r\n  public /*@non_null pure@*/ Enumeration enumerateInstances() {\r\n\r\n    return m_Instances.elements();\r\n  }\r\n\r\n  /**\r\n   * Checks if two headers are equivalent.\r\n   *\r\n   * @param dataset another dataset\r\n   * @return true if the header of the given dataset is equivalent\r\n   * to this header\r\n   */\r\n  public /*@pure@*/ boolean equalHeaders(Instances dataset){\r\n\r\n    // Check class and all attributes\r\n    if (m_ClassIndex != dataset.m_ClassIndex) {\r\n      return false;\r\n    }\r\n    if (m_Attributes.size() != dataset.m_Attributes.size()) {\r\n      return false;\r\n    }\r\n    for (int i = 0; i \u003c m_Attributes.size(); i++) {\r\n      if (!(attribute(i).equals(dataset.attribute(i)))) {\r\n\treturn false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Returns the first instance in the set.\r\n   *\r\n   * @return the first instance in the set\r\n   */\r\n  //@ requires numInstances() \u003e 0;\r\n  public /*@non_null pure@*/ Instance firstInstance() {\r\n\r\n    return (Instance)m_Instances.firstElement();\r\n  }\r\n\r\n  /**\r\n   * Returns a random number generator. The initial seed of the random\r\n   * number generator depends on the given seed and the hash code of\r\n   * a string representation of a instances chosen based on the given\r\n   * seed.\r\n   *\r\n   * @param seed the given seed\r\n   * @return the random number generator\r\n   */\r\n  /*public Random getRandomNumberGenerator(long seed) {\r\n\r\n    Random r = new Random(seed);\r\n    r.setSeed(instance(r.nextInt(numInstances())).toString().hashCode() + seed);\r\n    return r;\r\n  }*/\r\n\r\n  /**\r\n   * Inserts an attribute at the given position (0 to\r\n   * numAttributes()) and sets all values to be missing.\r\n   * Shallow copies the attribute before it is inserted, and performs\r\n   * a deep copy of the existing attribute information.\r\n   *\r\n   * @param att the attribute to be inserted\r\n   * @param position the attribute's position (position starts with 0)\r\n   * @throws IllegalArgumentException if the given index is out of range\r\n   */\r\n  //@ requires 0 \u003c= position;\r\n  //@ requires position \u003c= numAttributes();\r\n  public void insertAttributeAt(/*@non_null@*/ AttributeWeka att, int position) {\r\n\r\n    if ((position \u003c 0) ||\r\n\t(position \u003e m_Attributes.size())) {\r\n      throw new IllegalArgumentException(\"Index out of range\");\r\n    }\r\n    att = (AttributeWeka)att.copy();\r\n    freshAttributeInfo();\r\n    att.setIndex(position);\r\n    m_Attributes.insertElementAt(att, position);\r\n    for (int i = position + 1; i \u003c m_Attributes.size(); i++) {\r\n      AttributeWeka current = (AttributeWeka)m_Attributes.elementAt(i);\r\n      current.setIndex(current.index() + 1);\r\n    }\r\n    for (int i = 0; i \u003c numInstances(); i++) {\r\n      instance(i).forceInsertAttributeAt(position);\r\n    }\r\n    if (m_ClassIndex \u003e= position) {\r\n      m_ClassIndex++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the instance at the given position.\r\n   *\r\n   * @param index the instance's index (index starts with 0)\r\n   * @return the instance at the given position\r\n   */\r\n  //@ requires 0 \u003c= index;\r\n  //@ requires index \u003c numInstances();\r\n  public /*@non_null pure@*/ Instance instance(int index) {\r\n\r\n    return (Instance)m_Instances.elementAt(index);\r\n  }\r\n\r\n  /**\r\n   * Returns the kth-smallest attribute value of a numeric attribute.\r\n   * Note that calling this method will change the order of the data!\r\n   *\r\n   * @param att the AttributeWeka object\r\n   * @param k the value of k\r\n   * @return the kth-smallest value\r\n   */\r\n  public double kthSmallestValue(AttributeWeka att, int k) {\r\n\r\n    return kthSmallestValue(att.index(), k);\r\n  }\r\n\r\n  /**\r\n   * Returns the kth-smallest attribute value of a numeric attribute.\r\n   * Note that calling this method will change the order of the data!\r\n   * The number of non-missing values in the data must be as least\r\n   * as last as k for this to work.\r\n   *\r\n   * @param attIndex the attribute's index\r\n   * @param k the value of k\r\n   * @return the kth-smallest value\r\n   */\r\n  public double kthSmallestValue(int attIndex, int k) {\r\n\r\n    if (!attribute(attIndex).isNumeric()) {\r\n      throw new IllegalArgumentException(\"Instances: attribute must be numeric to compute kth-smallest value.\");\r\n    }\r\n\r\n    int i,j;\r\n\r\n    // move all instances with missing values to end\r\n    j = numInstances() - 1;\r\n    i = 0;\r\n    while (i \u003c= j) {\r\n      if (instance(j).isMissing(attIndex)) {\r\n\tj--;\r\n      } else {\r\n\tif (instance(i).isMissing(attIndex)) {\r\n\t  swap(i,j);\r\n\t  j--;\r\n\t}\r\n\ti++;\r\n      }\r\n    }\r\n\r\n    if ((k \u003c 1) || (k \u003e j+1)) {\r\n      throw new IllegalArgumentException(\"Instances: value for k for computing kth-smallest value too large.\");\r\n    }\r\n\r\n    return instance(select(attIndex, 0, j, k)).value(attIndex);\r\n  }\r\n\r\n  /**\r\n   * Returns the last instance in the set.\r\n   *\r\n   * @return the last instance in the set\r\n   */\r\n  //@ requires numInstances() \u003e 0;\r\n  public /*@non_null pure@*/ Instance lastInstance() {\r\n\r\n    return (Instance)m_Instances.lastElement();\r\n  }\r\n\r\n  /**\r\n   * Returns the mean (mode) for a numeric (nominal) attribute as\r\n   * a floating-point value. Returns 0 if the attribute is neither nominal nor\r\n   * numeric. If all values are missing it returns zero.\r\n   *\r\n   * @param attIndex the attribute's index (index starts with 0)\r\n   * @return the mean or the mode\r\n   */\r\n  public /*@pure@*/ double meanOrMode(int attIndex) {\r\n\r\n    double result, found;\r\n    int [] counts;\r\n\r\n    if (attribute(attIndex).isNumeric()) {\r\n      result = found = 0;\r\n      for (int j = 0; j \u003c numInstances(); j++) {\r\n\tif (!instance(j).isMissing(attIndex)) {\r\n\t  found += instance(j).weight();\r\n\t  result += instance(j).weight()*instance(j).value(attIndex);\r\n\t}\r\n      }\r\n      if (found \u003c= 0) {\r\n\treturn 0;\r\n      } else {\r\n\treturn result / found;\r\n      }\r\n    } else if (attribute(attIndex).isNominal()) {\r\n      counts = new int[attribute(attIndex).numValues()];\r\n      for (int j = 0; j \u003c numInstances(); j++) {\r\n\tif (!instance(j).isMissing(attIndex)) {\r\n\t  counts[(int) instance(j).value(attIndex)] += instance(j).weight();\r\n\t}\r\n      }\r\n      return (double)Utils.maxIndex(counts);\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the mean (mode) for a numeric (nominal) attribute as a\r\n   * floating-point value.  Returns 0 if the attribute is neither\r\n   * nominal nor numeric.  If all values are missing it returns zero.\r\n   *\r\n   * @param att the attribute\r\n   * @return the mean or the mode\r\n   */\r\n  public /*@pure@*/ double meanOrMode(AttributeWeka att) {\r\n\r\n    return meanOrMode(att.index());\r\n  }\r\n\r\n  /**\r\n   * Returns the number of attributes.\r\n   *\r\n   * @return the number of attributes as an integer\r\n   */\r\n  //@ ensures \\result == m_Attributes.size();\r\n  public /*@pure@*/ int numAttributes() {\r\n\r\n    return m_Attributes.size();\r\n  }\r\n\r\n  /**\r\n   * Returns the number of class labels.\r\n   *\r\n   * @return the number of class labels as an integer if the class\r\n   * attribute is nominal, 1 otherwise.\r\n   * @throws UnassignedClassException if the class is not set\r\n   */\r\n  //@ requires classIndex() \u003e= 0;\r\n  public /*@pure@*/ int numClasses() {\r\n\r\n    if (m_ClassIndex \u003c 0) {\r\n      throw new UnassignedClassException(\"Class index is negative (not set)!\");\r\n    }\r\n    if (!classAttribute().isNominal()) {\r\n      return 1;\r\n    } else {\r\n      return classAttribute().numValues();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the number of distinct values of a given attribute.\r\n   * Returns the number of instances if the attribute is a\r\n   * string attribute. The value 'missing' is not counted.\r\n   *\r\n   * @param attIndex the attribute (index starts with 0)\r\n   * @return the number of distinct values of a given attribute\r\n   */\r\n  //@ requires 0 \u003c= attIndex;\r\n  //@ requires attIndex \u003c numAttributes();\r\n  public /*@pure@*/ int numDistinctValues(int attIndex) {\r\n\r\n    if (attribute(attIndex).isNumeric()) {\r\n      double [] attVals = attributeToDoubleArray(attIndex);\r\n      int [] sorted = Utils.sort(attVals);\r\n      double prev = 0;\r\n      int counter = 0;\r\n      for (int i = 0; i \u003c sorted.length; i++) {\r\n\tInstance current = instance(sorted[i]);\r\n\tif (current.isMissing(attIndex)) {\r\n\t  break;\r\n\t}\r\n\tif ((i == 0) ||\r\n\t    (current.value(attIndex) \u003e prev)) {\r\n\t  prev = current.value(attIndex);\r\n\t  counter++;\r\n\t}\r\n      }\r\n      return counter;\r\n    } else {\r\n      return attribute(attIndex).numValues();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the number of distinct values of a given attribute.\r\n   * Returns the number of instances if the attribute is a\r\n   * string attribute. The value 'missing' is not counted.\r\n   *\r\n   * @param att the attribute\r\n   * @return the number of distinct values of a given attribute\r\n   */\r\n  public /*@pure@*/ int numDistinctValues(/*@non_null@*/AttributeWeka att) {\r\n\r\n    return numDistinctValues(att.index());\r\n  }\r\n\r\n  /**\r\n   * Returns the number of instances in the dataset.\r\n   *\r\n   * @return the number of instances in the dataset as an integer\r\n   */\r\n  //@ ensures \\result == m_Instances.size();\r\n  public /*@pure@*/ int numInstances() {\r\n\r\n    return m_Instances.size();\r\n  }\r\n\r\n  /**\r\n   * Shuffles the instances in the set so that they are ordered\r\n   * randomly.\r\n   *\r\n   * @param random a random number generator\r\n   */\r\n  public void randomize(Randomize random) {\r\n\r\n    for (int j = numInstances() - 1; j \u003e 0; j--)\r\n      //swap(j, random.nextInt(j+1));\r\n      swap(j, random.RandintClosed(0,j));\r\n  }\r\n\r\n  /**\r\n   * Does an undo of a previous call to randomizeAttribute, so that the\r\n   * original values of the attribute are restored. Only the original values\r\n   * before the last call to randomizeAttribute can be restored. Note, the\r\n   * original Instances object is modified.\r\n   *\r\n   * @throws Exception if there was no call to randomizeAttribute or if\r\n   * attributes were added or removed since the last call to\r\n   * \u003ccode\u003erandomizeAttribute\u003c/code\u003e\r\n   * @see randomizeAttribute\r\n   * @author Arne Muller (arne.muller@gmail.com)\r\n   */\r\n  public void undoRandomizeAttribute() throws Exception {\r\n\r\n    if ( attIdx4Randomization \u003c 0 )\r\n      throw new Exception(\"no randomization to undo!\");\r\n\r\n    if ( attIdxOrigValues.length !=  this.numInstances() )\r\n      throw new Exception(\r\n\t  \"meanwhile number of attributes has changed, can't undo!\");\r\n\r\n    for ( int i=0; i\u003cattIdxOrigValues.length; i++ ) {\r\n      Instance instance = (Instance)(m_Instances.elementAt(i));\r\n      instance.modifyValue(attIdx4Randomization, attIdxOrigValues[i]);\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Shuffles the values of a given attribute in all instances. Note,\r\n   * the original Instances object is modified (i.e. no copying), and the\r\n   * method is not thread save. To avoid undefined behavior of an Instances\r\n   * object you should not perform other Instances modifying operations between\r\n   * a call to \u003ccode\u003erandomizeAttribute\u003c/code\u003e and\r\n   * \u003ccode\u003eundoRandomizeAttribute\u003c/code\u003e.\r\n   *\r\n   * @param attIdx the index of the attribute to shuffle\r\n   * @param random a random number generator\r\n   * @param rounds how many rounds of shuffling, minimum must be 1. As more\r\n   * rounds of shuffling the more random your attribute value distribution\r\n   * (e.g. choose 3, but note that the time needed for shuffling is proportional\r\n   * to the number of rounds).\r\n   * @see undoRandomizeAttribute\r\n   * @author Arne Muller (arne.muller@gmail.com)\r\n   */\r\n  public void randomizeAttribute(int attIdx, Randomize random, int rounds) {\r\n\r\n    attIdx4Randomization = attIdx;\r\n    attIdxOrigValues = this.attributeToDoubleArray(attIdx);\r\n    int n = numInstances();\r\n    for ( int j=0; j\u003crounds; j++ ) {\r\n      for ( int i=0; i\u003cn; i++ ) {\r\n\tint r = random.RandintClosed(0,n-1); //random.nextInt(n);\r\n\tInstance iOne = (Instance)(m_Instances.elementAt(i));\r\n\tInstance iTwo = (Instance)(m_Instances.elementAt(r));\r\n\tdouble helper = iOne.value(attIdx);\r\n\tiOne.modifyValue(attIdx, iTwo.value(attIdx));\r\n\tiTwo.modifyValue(attIdx, helper);\r\n      }\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Returns the relation's name.\r\n   *\r\n   * @return the relation's name as a string\r\n   */\r\n  //@ ensures \\result == m_RelationName;\r\n  public /*@pure@*/ String relationName() {\r\n\r\n    return m_RelationName;\r\n  }\r\n\r\n  /**\r\n   * Renames an attribute. This change only affects this\r\n   * dataset.\r\n   *\r\n   * @param att the attribute's index (index starts with 0)\r\n   * @param name the new name\r\n   */\r\n  public void renameAttribute(int att, String name) {\r\n\r\n    AttributeWeka newAtt = attribute(att).copy(name);\r\n    FastVector newVec = new FastVector(numAttributes());\r\n\r\n    for (int i = 0; i \u003c numAttributes(); i++) {\r\n      if (i == att) {\r\n\tnewVec.addElement(newAtt);\r\n      } else {\r\n\tnewVec.addElement(attribute(i));\r\n      }\r\n    }\r\n    m_Attributes = newVec;\r\n  }\r\n\r\n  /**\r\n   * Renames an attribute. This change only affects this\r\n   * dataset.\r\n   *\r\n   * @param att the attribute\r\n   * @param name the new name\r\n   */\r\n  public void renameAttribute(AttributeWeka att, String name) {\r\n\r\n    renameAttribute(att.index(), name);\r\n  }\r\n\r\n  /**\r\n   * Renames the value of a nominal (or string) attribute value. This\r\n   * change only affects this dataset.\r\n   *\r\n   * @param att the attribute's index (index starts with 0)\r\n   * @param val the value's index (index starts with 0)\r\n   * @param name the new name\r\n   */\r\n  public void renameAttributeValue(int att, int val, String name) {\r\n\r\n    AttributeWeka newAtt = (AttributeWeka)attribute(att).copy();\r\n    FastVector newVec = new FastVector(numAttributes());\r\n\r\n    newAtt.setValue(val, name);\r\n    for (int i = 0; i \u003c numAttributes(); i++) {\r\n      if (i == att) {\r\n\tnewVec.addElement(newAtt);\r\n      } else {\r\n\tnewVec.addElement(attribute(i));\r\n      }\r\n    }\r\n    m_Attributes = newVec;\r\n  }\r\n\r\n  /**\r\n   * Renames the value of a nominal (or string) attribute value. This\r\n   * change only affects this dataset.\r\n   *\r\n   * @param att the attribute\r\n   * @param val the value\r\n   * @param name the new name\r\n   */\r\n  public void renameAttributeValue(AttributeWeka att, String val,\r\n                                         String name) {\r\n\r\n    int v = att.indexOfValue(val);\r\n    if (v == -1) throw new IllegalArgumentException(val + \" not found\");\r\n    renameAttributeValue(att.index(), v, name);\r\n  }\r\n\r\n  /**\r\n   * Creates a new dataset of the same size using random sampling\r\n   * with replacement.\r\n   *\r\n   * @param random a random number generator\r\n   * @return the new dataset\r\n   */\r\n  public Instances resample(Randomize random) {\r\n\r\n    Instances newData = new Instances(this, numInstances());\r\n    while (newData.numInstances() \u003c numInstances()) {\r\n      //newData.add(instance(random.nextInt(numInstances())));\r\n      newData.add(instance(random.RandintClosed(0,numInstances()-1)));\r\n    }\r\n    return newData;\r\n  }\r\n\r\n  /**\r\n   * Creates a new dataset of the same size using random sampling\r\n   * with replacement according to the current instance weights. The\r\n   * weights of the instances in the new dataset are set to one.\r\n   *\r\n   * @param random a random number generator\r\n   * @return the new dataset\r\n   */\r\n  public Instances resampleWithWeights(Randomize random) {\r\n\r\n    double [] weights = new double[numInstances()];\r\n    for (int i = 0; i \u003c weights.length; i++) {\r\n      weights[i] = instance(i).weight();\r\n    }\r\n    return resampleWithWeights(random, weights);\r\n  }\r\n\r\n\r\n  /**\r\n   * Creates a new dataset of the same size using random sampling\r\n   * with replacement according to the given weight vector. The\r\n   * weights of the instances in the new dataset are set to one.\r\n   * The length of the weight vector has to be the same as the\r\n   * number of instances in the dataset, and all weights have to\r\n   * be positive.\r\n   *\r\n   * @param random a random number generator\r\n   * @param weights the weight vector\r\n   * @return the new dataset\r\n   * @throws IllegalArgumentException if the weights array is of the wrong\r\n   * length or contains negative weights.\r\n   */\r\n  public Instances resampleWithWeights(Randomize random,\r\n\t\t\t\t\t     double[] weights) {\r\n\r\n    if (weights.length != numInstances()) {\r\n      throw new IllegalArgumentException(\"weights.length != numInstances.\");\r\n    }\r\n    Instances newData = new Instances(this, numInstances());\r\n    if (numInstances() == 0) {\r\n      return newData;\r\n    }\r\n    double[] probabilities = new double[numInstances()];\r\n    double sumProbs = 0, sumOfWeights = Utils.sum(weights);\r\n    for (int i = 0; i \u003c numInstances(); i++) {\r\n      //sumProbs += random.nextDouble();\r\n      sumProbs += random.Rand();\r\n      probabilities[i] = sumProbs;\r\n    }\r\n    Utils.normalize(probabilities, sumProbs / sumOfWeights);\r\n\r\n    // Make sure that rounding errors don't mess things up\r\n    probabilities[numInstances() - 1] = sumOfWeights;\r\n    int k = 0; int l = 0;\r\n    sumProbs = 0;\r\n    while ((k \u003c numInstances() \u0026\u0026 (l \u003c numInstances()))) {\r\n      if (weights[l] \u003c 0) {\r\n\tthrow new IllegalArgumentException(\"Weights have to be positive.\");\r\n      }\r\n      sumProbs += weights[l];\r\n      while ((k \u003c numInstances()) \u0026\u0026\r\n\t     (probabilities[k] \u003c= sumProbs)) {\r\n\tnewData.add(instance(l));\r\n\tnewData.instance(k).setWeight(1);\r\n\tk++;\r\n      }\r\n      l++;\r\n    }\r\n    return newData;\r\n  }\r\n\r\n  /**\r\n   * Sets the class attribute.\r\n   *\r\n   * @param att attribute to be the class\r\n   */\r\n  public void setClass(AttributeWeka att) {\r\n\r\n    m_ClassIndex = att.index();\r\n  }\r\n\r\n  /**\r\n   * Sets the class index of the set.\r\n   * If the class index is negative there is assumed to be no class.\r\n   * (ie. it is undefined)\r\n   *\r\n   * @param classIndex the new class index (index starts with 0)\r\n   * @throws IllegalArgumentException if the class index is too big or \u003c 0\r\n   */\r\n  public void setClassIndex(int classIndex) {\r\n\r\n    if (classIndex \u003e= numAttributes()) {\r\n      throw new IllegalArgumentException(\"Invalid class index: \" + classIndex);\r\n    }\r\n    m_ClassIndex = classIndex;\r\n  }\r\n\r\n  /**\r\n   * Sets the relation's name.\r\n   *\r\n   * @param newName the new relation name.\r\n   */\r\n  public void setRelationName(/*@non_null@*/String newName) {\r\n\r\n    m_RelationName = newName;\r\n  }\r\n\r\n  /**\r\n   * Sorts the instances based on an attribute. For numeric attributes,\r\n   * instances are sorted in ascending order. For nominal attributes,\r\n   * instances are sorted based on the attribute label ordering\r\n   * specified in the header. Instances with missing values for the\r\n   * attribute are placed at the end of the dataset.\r\n   *\r\n   * @param attIndex the attribute's index (index starts with 0)\r\n   */\r\n  public void sort(int attIndex) {\r\n\r\n    int i,j;\r\n\r\n    // move all instances with missing values to end\r\n    j = numInstances() - 1;\r\n    i = 0;\r\n    while (i \u003c= j) {\r\n      if (instance(j).isMissing(attIndex)) {\r\n\tj--;\r\n      } else {\r\n\tif (instance(i).isMissing(attIndex)) {\r\n\t  swap(i,j);\r\n\t  j--;\r\n\t}\r\n\ti++;\r\n      }\r\n    }\r\n    quickSort(attIndex, 0, j);\r\n  }\r\n\r\n  /**\r\n   * Sorts the instances based on an attribute. For numeric attributes,\r\n   * instances are sorted into ascending order. For nominal attributes,\r\n   * instances are sorted based on the attribute label ordering\r\n   * specified in the header. Instances with missing values for the\r\n   * attribute are placed at the end of the dataset.\r\n   *\r\n   * @param att the attribute\r\n   */\r\n  public void sort(AttributeWeka att) {\r\n\r\n    sort(att.index());\r\n  }\r\n\r\n  /**\r\n   * Stratifies a set of instances according to its class values\r\n   * if the class attribute is nominal (so that afterwards a\r\n   * stratified cross-validation can be performed).\r\n   *\r\n   * @param numFolds the number of folds in the cross-validation\r\n   * @throws UnassignedClassException if the class is not set\r\n   */\r\n  public void stratify(int numFolds) {\r\n\r\n    if (numFolds \u003c= 0) {\r\n      throw new IllegalArgumentException(\"Number of folds must be greater than 1\");\r\n    }\r\n    if (m_ClassIndex \u003c 0) {\r\n      throw new UnassignedClassException(\"Class index is negative (not set)!\");\r\n    }\r\n    if (classAttribute().isNominal()) {\r\n\r\n      // sort by class\r\n      int index = 1;\r\n      while (index \u003c numInstances()) {\r\n\tInstance instance1 = instance(index - 1);\r\n\tfor (int j = index; j \u003c numInstances(); j++) {\r\n\t  Instance instance2 = instance(j);\r\n\t  if ((instance1.classValue() == instance2.classValue()) ||\r\n\t      (instance1.classIsMissing() \u0026\u0026\r\n\t       instance2.classIsMissing())) {\r\n\t    swap(index,j);\r\n\t    index++;\r\n\t  }\r\n\t}\r\n\tindex++;\r\n      }\r\n      stratStep(numFolds);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Computes the sum of all the instances' weights.\r\n   *\r\n   * @return the sum of all the instances' weights as a double\r\n   */\r\n  public /*@pure@*/ double sumOfWeights() {\r\n\r\n    double sum = 0;\r\n\r\n    for (int i = 0; i \u003c numInstances(); i++) {\r\n      sum += instance(i).weight();\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * Creates the test set for one fold of a cross-validation on\r\n   * the dataset.\r\n   *\r\n   * @param numFolds the number of folds in the cross-validation. Must\r\n   * be greater than 1.\r\n   * @param numFold 0 for the first fold, 1 for the second, ...\r\n   * @return the test set as a set of weighted instances\r\n   * @throws IllegalArgumentException if the number of folds is less than 2\r\n   * or greater than the number of instances.\r\n   */\r\n  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\r\n  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\r\n  public Instances testCV(int numFolds, int numFold) {\r\n\r\n    int numInstForFold, first, offset;\r\n    Instances test;\r\n\r\n    if (numFolds \u003c 2) {\r\n      throw new IllegalArgumentException(\"Number of folds must be at least 2!\");\r\n    }\r\n    if (numFolds \u003e numInstances()) {\r\n      throw new IllegalArgumentException(\"Can't have more folds than instances!\");\r\n    }\r\n    numInstForFold = numInstances() / numFolds;\r\n    if (numFold \u003c numInstances() % numFolds){\r\n      numInstForFold++;\r\n      offset = numFold;\r\n    }else\r\n      offset = numInstances() % numFolds;\r\n    test = new Instances(this, numInstForFold);\r\n    first = numFold * (numInstances() / numFolds) + offset;\r\n    copyInstances(first, test, numInstForFold);\r\n    return test;\r\n  }\r\n\r\n  /**\r\n   * Returns the dataset as a string in ARFF format. Strings\r\n   * are quoted if they contain whitespace characters, or if they\r\n   * are a question mark.\r\n   *\r\n   * @return the dataset in ARFF format as a string\r\n   */\r\n  public String toString() {\r\n\r\n    StringBuffer text = new StringBuffer();\r\n\r\n    text.append(ARFF_RELATION).append(\" \").\r\n      append(Utils.quote(m_RelationName)).append(\"\\n\\n\");\r\n    for (int i = 0; i \u003c numAttributes(); i++) {\r\n      text.append(attribute(i)).append(\"\\n\");\r\n    }\r\n    text.append(\"\\n\").append(ARFF_DATA).append(\"\\n\");\r\n\r\n    text.append(stringWithoutHeader());\r\n    return text.toString();\r\n  }\r\n\r\n  /**\r\n   * Returns the instances in the dataset as a string in ARFF format. Strings\r\n   * are quoted if they contain whitespace characters, or if they\r\n   * are a question mark.\r\n   *\r\n   * @return the dataset in ARFF format as a string\r\n   */\r\n  protected String stringWithoutHeader() {\r\n\r\n    StringBuffer text = new StringBuffer();\r\n\r\n    for (int i = 0; i \u003c numInstances(); i++) {\r\n      text.append(instance(i));\r\n      if (i \u003c numInstances() - 1) {\r\n\ttext.append('\\n');\r\n      }\r\n    }\r\n    return text.toString();\r\n  }\r\n\r\n  /**\r\n   * Creates the training set for one fold of a cross-validation\r\n   * on the dataset.\r\n   *\r\n   * @param numFolds the number of folds in the cross-validation. Must\r\n   * be greater than 1.\r\n   * @param numFold 0 for the first fold, 1 for the second, ...\r\n   * @return the training set\r\n   * @throws IllegalArgumentException if the number of folds is less than 2\r\n   * or greater than the number of instances.\r\n   */\r\n  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\r\n  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\r\n  public Instances trainCV(int numFolds, int numFold) {\r\n\r\n    int numInstForFold, first, offset;\r\n    Instances train;\r\n\r\n    if (numFolds \u003c 2) {\r\n      throw new IllegalArgumentException(\"Number of folds must be at least 2!\");\r\n    }\r\n    if (numFolds \u003e numInstances()) {\r\n      throw new IllegalArgumentException(\"Can't have more folds than instances!\");\r\n    }\r\n    numInstForFold = numInstances() / numFolds;\r\n    if (numFold \u003c numInstances() % numFolds) {\r\n      numInstForFold++;\r\n      offset = numFold;\r\n    }else\r\n      offset = numInstances() % numFolds;\r\n    train = new Instances(this, numInstances() - numInstForFold);\r\n    first = numFold * (numInstances() / numFolds) + offset;\r\n    copyInstances(0, train, first);\r\n    copyInstances(first + numInstForFold, train,\r\n\t\t  numInstances() - first - numInstForFold);\r\n\r\n    return train;\r\n  }\r\n\r\n  /**\r\n   * Creates the training set for one fold of a cross-validation\r\n   * on the dataset. The data is subsequently randomized based\r\n   * on the given random number generator.\r\n   *\r\n   * @param numFolds the number of folds in the cross-validation. Must\r\n   * be greater than 1.\r\n   * @param numFold 0 for the first fold, 1 for the second, ...\r\n   * @param random the random number generator\r\n   * @return the training set\r\n   * @throws IllegalArgumentException if the number of folds is less than 2\r\n   * or greater than the number of instances.\r\n   */\r\n  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\r\n  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\r\n  public Instances trainCV(int numFolds, int numFold, Randomize random) {\r\n\r\n    Instances train = trainCV(numFolds, numFold);\r\n    train.randomize(random);\r\n    return train;\r\n  }\r\n\r\n  /**\r\n   * Computes the variance for a numeric attribute.\r\n   *\r\n   * @param attIndex the numeric attribute (index starts with 0)\r\n   * @return the variance if the attribute is numeric\r\n   * @throws IllegalArgumentException if the attribute is not numeric\r\n   */\r\n  public /*@pure@*/ double variance(int attIndex) {\r\n\r\n    double sum = 0, sumSquared = 0, sumOfWeights = 0;\r\n\r\n    if (!attribute(attIndex).isNumeric()) {\r\n      throw new IllegalArgumentException(\"Can't compute variance because attribute is \" +\r\n\t\t\t  \"not numeric!\");\r\n    }\r\n    for (int i = 0; i \u003c numInstances(); i++) {\r\n      if (!instance(i).isMissing(attIndex)) {\r\n\tsum += instance(i).weight() *\r\n\t  instance(i).value(attIndex);\r\n\tsumSquared += instance(i).weight() *\r\n\t  instance(i).value(attIndex) *\r\n\t  instance(i).value(attIndex);\r\n\tsumOfWeights += instance(i).weight();\r\n      }\r\n    }\r\n    if (sumOfWeights \u003c= 1) {\r\n      return 0;\r\n    }\r\n    double result = (sumSquared - (sum * sum / sumOfWeights)) /\r\n      (sumOfWeights - 1);\r\n\r\n    // We don't like negative variance\r\n    if (result \u003c 0) {\r\n      return 0;\r\n    } else {\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Computes the variance for a numeric attribute.\r\n   *\r\n   * @param att the numeric attribute\r\n   * @return the variance if the attribute is numeric\r\n   * @throws IllegalArgumentException if the attribute is not numeric\r\n   */\r\n  public /*@pure@*/ double variance(AttributeWeka att) {\r\n\r\n    return variance(att.index());\r\n  }\r\n\r\n  /**\r\n   * Gets the value of all instances in this dataset for a particular\r\n   * attribute. Useful in conjunction with Utils.sort to allow iterating\r\n   * through the dataset in sorted order for some attribute.\r\n   *\r\n   * @param index the index of the attribute.\r\n   * @return an array containing the value of the desired attribute for\r\n   * each instance in the dataset.\r\n   */\r\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numAttributes();\r\n  public /*@pure@*/ double [] attributeToDoubleArray(int index) {\r\n\r\n    double [] result = new double[numInstances()];\r\n    for (int i = 0; i \u003c result.length; i++) {\r\n      result[i] = instance(i).value(index);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Copies instances from one set to the end of another\r\n   * one.\r\n   *\r\n   * @param from the position of the first instance to be copied\r\n   * @param dest the destination for the instances\r\n   * @param num the number of instances to be copied\r\n   */\r\n  //@ requires 0 \u003c= from \u0026\u0026 from \u003c= numInstances() - num;\r\n  //@ requires 0 \u003c= num;\r\n  protected void copyInstances(int from, /*@non_null@*/ Instances dest, int num) {\r\n\r\n    for (int i = 0; i \u003c num; i++) {\r\n      dest.add(instance(from + i));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Replaces the attribute information by a clone of\r\n   * itself.\r\n   */\r\n  protected void freshAttributeInfo() {\r\n\r\n    m_Attributes = (FastVector) m_Attributes.copyElements();\r\n  }\r\n\r\n  /**\r\n   * Returns string including all instances, their weights and\r\n   * their indices in the original dataset.\r\n   *\r\n   * @return description of instance and its weight as a string\r\n   */\r\n  protected /*@pure@*/ String instancesAndWeights(){\r\n\r\n    StringBuffer text = new StringBuffer();\r\n\r\n    for (int i = 0; i \u003c numInstances(); i++) {\r\n      text.append(instance(i) + \" \" + instance(i).weight());\r\n      if (i \u003c numInstances() - 1) {\r\n\ttext.append(\"\\n\");\r\n      }\r\n    }\r\n    return text.toString();\r\n  }\r\n\r\n  /**\r\n   * Partitions the instances around a pivot. Used by quicksort and\r\n   * kthSmallestValue.\r\n   *\r\n   * @param attIndex the attribute's index (index starts with 0)\r\n   * @param l the first index of the subset (index starts with 0)\r\n   * @param r the last index of the subset (index starts with 0)\r\n   *\r\n   * @return the index of the middle element\r\n   */\r\n  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\r\n  //@ requires 0 \u003c= left \u0026\u0026 left \u003c= right \u0026\u0026 right \u003c numInstances();\r\n  protected int partition(int attIndex, int l, int r) {\r\n\r\n    double pivot = instance((l + r) / 2).value(attIndex);\r\n\r\n    while (l \u003c r) {\r\n      while ((instance(l).value(attIndex) \u003c pivot) \u0026\u0026 (l \u003c r)) {\r\n        l++;\r\n      }\r\n      while ((instance(r).value(attIndex) \u003e pivot) \u0026\u0026 (l \u003c r)) {\r\n        r--;\r\n      }\r\n      if (l \u003c r) {\r\n        swap(l, r);\r\n        l++;\r\n        r--;\r\n      }\r\n    }\r\n    if ((l == r) \u0026\u0026 (instance(r).value(attIndex) \u003e pivot)) {\r\n      r--;\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n  /**\r\n   * Implements quicksort according to Manber's \"Introduction to\r\n   * Algorithms\".\r\n   *\r\n   * @param attIndex the attribute's index (index starts with 0)\r\n   * @param left the first index of the subset to be sorted (index starts with 0)\r\n   * @param right the last index of the subset to be sorted (index starts with 0)\r\n   */\r\n  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c numInstances();\r\n  protected void quickSort(int attIndex, int left, int right) {\r\n\r\n    if (left \u003c right) {\r\n      int middle = partition(attIndex, left, right);\r\n      quickSort(attIndex, left, middle);\r\n      quickSort(attIndex, middle + 1, right);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Implements computation of the kth-smallest element according\r\n   * to Manber's \"Introduction to Algorithms\".\r\n   *\r\n   * @param attIndex the attribute's index (index starts with 0)\r\n   * @param left the first index of the subset (index starts with 0)\r\n   * @param right the last index of the subset (index starts with 0)\r\n   * @param k the value of k\r\n   *\r\n   * @return the index of the kth-smallest element\r\n   */\r\n  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c numInstances();\r\n  protected int select(int attIndex, int left, int right, int k) {\r\n\r\n    if (left == right) {\r\n      return left;\r\n    } else {\r\n      int middle = partition(attIndex, left, right);\r\n      if ((middle - left + 1) \u003e= k) {\r\n        return select(attIndex, left, middle, k);\r\n      } else {\r\n        return select(attIndex, middle + 1, right, k - (middle - left + 1));\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Help function needed for stratification of set.\r\n   *\r\n   * @param numFolds the number of folds for the stratification\r\n   */\r\n  protected void stratStep (int numFolds){\r\n\r\n    FastVector newVec = new FastVector(m_Instances.capacity());\r\n    int start = 0, j;\r\n\r\n    // create stratified batch\r\n    while (newVec.size() \u003c numInstances()) {\r\n      j = start;\r\n      while (j \u003c numInstances()) {\r\n\tnewVec.addElement(instance(j));\r\n\tj = j + numFolds;\r\n      }\r\n      start++;\r\n    }\r\n    m_Instances = newVec;\r\n  }\r\n\r\n  /**\r\n   * Swaps two instances in the set.\r\n   *\r\n   * @param i the first instance's index (index starts with 0)\r\n   * @param j the second instance's index (index starts with 0)\r\n   */\r\n  //@ requires 0 \u003c= i \u0026\u0026 i \u003c numInstances();\r\n  //@ requires 0 \u003c= j \u0026\u0026 j \u003c numInstances();\r\n  public void swap(int i, int j){\r\n\r\n    m_Instances.swap(i, j);\r\n  }\r\n\r\n  /**\r\n   * Merges two sets of Instances together. The resulting set will have\r\n   * all the attributes of the first set plus all the attributes of the\r\n   * second set. The number of instances in both sets must be the same.\r\n   *\r\n   * @param first the first set of Instances\r\n   * @param second the second set of Instances\r\n   * @return the merged set of Instances\r\n   * @throws IllegalArgumentException if the datasets are not the same size\r\n   */\r\n  public static Instances mergeInstances(Instances first, Instances second) {\r\n\r\n    if (first.numInstances() != second.numInstances()) {\r\n      throw new IllegalArgumentException(\"Instance sets must be of the same size\");\r\n    }\r\n\r\n    // Create the vector of merged attributes\r\n    FastVector newAttributes = new FastVector();\r\n    for (int i = 0; i \u003c first.numAttributes(); i++) {\r\n      newAttributes.addElement(first.attribute(i));\r\n    }\r\n    for (int i = 0; i \u003c second.numAttributes(); i++) {\r\n      newAttributes.addElement(second.attribute(i));\r\n    }\r\n\r\n    // Create the set of Instances\r\n    Instances merged = new Instances(first.relationName() + '_'\r\n\t\t\t\t     + second.relationName(),\r\n\t\t\t\t     newAttributes,\r\n\t\t\t\t     first.numInstances());\r\n    // Merge each instance\r\n    for (int i = 0; i \u003c first.numInstances(); i++) {\r\n      merged.add(first.instance(i).mergeInstance(second.instance(i)));\r\n    }\r\n    return merged;\r\n  }\r\n\r\n}\r\n",
        "name": "Instances.java",
        "path": "src/keel/Algorithms/Fuzzy_Rule_Learning/Hybrid/FURIA/core/Instances.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/Fuzzy_Rule_Learning/Hybrid/FURIA/core/Instances.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 194,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 195,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= toCopy;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 196,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires first + toCopy \u003c= source.numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 285,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 286,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003c m_Attributes.size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 287,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 377,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 420,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 435,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= position \u0026\u0026 position \u003c numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 436,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires position != classIndex();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 496,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 583,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires numInstances() \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 615,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= position;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 616,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires position \u003c= numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 645,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 646,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 710,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires numInstances() \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 773,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Attributes.size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 786,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 807,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= attIndex;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 808,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attIndex \u003c numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 851,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Instances.size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 940,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_RelationName;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1251,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1252,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1329,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1330,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1370,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1371,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1439,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1457,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= from \u0026\u0026 from \u003c= numInstances() - num;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1458,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= num;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1504,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1505,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= left \u0026\u0026 left \u003c= right \u0026\u0026 right \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1538,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1539,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1560,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1561,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1604,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= i \u0026\u0026 i \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1605,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= j \u0026\u0026 j \u003c numInstances();\r"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "/***********************************************************************\r\n\r\n\tThis file is part of KEEL-software, the Data Mining tool for regression, \r\n\tclassification, clustering, pattern mining and so on.\r\n\r\n\tCopyright (C) 2004-2010\r\n\t\r\n\tF. Herrera (herrera@decsai.ugr.es)\r\n    L. Sánchez (luciano@uniovi.es)\r\n    J. Alcalá-Fdez (jalcala@decsai.ugr.es)\r\n    S. García (sglopez@ujaen.es)\r\n    A. Fernández (alberto.fernandez@ujaen.es)\r\n    J. Luengo (julianlm@decsai.ugr.es)\r\n\r\n\tThis program is free software: you can redistribute it and/or modify\r\n\tit under the terms of the GNU General Public License as published by\r\n\tthe Free Software Foundation, either version 3 of the License, or\r\n\t(at your option) any later version.\r\n\r\n\tThis program is distributed in the hope that it will be useful,\r\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\tGNU General Public License for more details.\r\n\r\n\tYou should have received a copy of the GNU General Public License\r\n\talong with this program.  If not, see http://www.gnu.org/licenses/\r\n  \r\n**********************************************************************/\r\n\r\n/*\r\n *    This program is free software; you can redistribute it and/or modify\r\n *    it under the terms of the GNU General Public License as published by\r\n *    the Free Software Foundation; either version 2 of the License, or\r\n *    (at your option) any later version.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU General Public License\r\n *    along with this program; if not, write to the Free Software\r\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\r\n */\r\n\r\n/*\r\n *    FastVector.java\r\n *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand\r\n *\r\n */\r\n\r\npackage keel.Algorithms.Statistical_Classifiers.Logistic.core;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.Enumeration;\r\n\r\n/**\r\n * Implements a fast vector class without synchronized\r\n * methods. Replaces java.util.Vector. (Synchronized methods tend to\r\n * be slow.)\r\n *\r\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\r\n * @version $Revision: 1.1 $\r\n */\r\npublic class FastVector\r\n  implements Copyable, Serializable {\r\n\r\n  /** for serialization */\r\n  private static final long serialVersionUID = -2173635135622930169L;\r\n\r\n  /**\r\n   * Class for enumerating the vector's elements.\r\n   */\r\n  public class FastVectorEnumeration implements Enumeration {\r\n\r\n    /** The counter. */\r\n    private int m_Counter;\r\n    // These JML commands say how m_Counter implements Enumeration\r\n    //@ in moreElements;\r\n    //@ private represents moreElements = m_Counter \u003c m_Vector.size();\r\n    //@ private invariant 0 \u003c= m_Counter \u0026\u0026 m_Counter \u003c= m_Vector.size();\r\n\r\n    /** The vector. */\r\n    private /*@non_null@*/ FastVector m_Vector;\r\n\r\n    /** Special element. Skipped during enumeration. */\r\n    private int m_SpecialElement;\r\n    //@ private invariant -1 \u003c= m_SpecialElement;\r\n    //@ private invariant m_SpecialElement \u003c m_Vector.size();\r\n    //@ private invariant m_SpecialElement\u003e=0 ==\u003e m_Counter!=m_SpecialElement;\r\n\r\n    /**\r\n     * Constructs an enumeration.\r\n     *\r\n     * @param vector the vector which is to be enumerated\r\n     */\r\n    public FastVectorEnumeration(/*@non_null@*/FastVector vector) {\r\n\r\n      m_Counter = 0;\r\n      m_Vector = vector;\r\n      m_SpecialElement = -1;\r\n    }\r\n\r\n    /**\r\n     * Constructs an enumeration with a special element.\r\n     * The special element is skipped during the enumeration.\r\n     *\r\n     * @param vector the vector which is to be enumerated\r\n     * @param special the index of the special element\r\n     */\r\n    //@ requires 0 \u003c= special \u0026\u0026 special \u003c vector.size();\r\n    public FastVectorEnumeration(/*@non_null@*/FastVector vector, int special){\r\n\r\n      m_Vector = vector;\r\n      m_SpecialElement = special;\r\n      if (special == 0) {\r\n\tm_Counter = 1;\r\n      } else {\r\n\tm_Counter = 0;\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * Tests if there are any more elements to enumerate.\r\n     *\r\n     * @return true if there are some elements left\r\n     */\r\n    public final /*@pure@*/ boolean hasMoreElements() {\r\n\r\n      if (m_Counter \u003c m_Vector.size()) {\r\n\treturn true;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Returns the next element.\r\n     *\r\n     * @return the next element to be enumerated\r\n     */\r\n    //@ also requires hasMoreElements();\r\n    public final Object nextElement() {\r\n  \r\n      Object result = m_Vector.elementAt(m_Counter);\r\n\r\n      m_Counter++;\r\n      if (m_Counter == m_SpecialElement) {\r\n\tm_Counter++;\r\n      }\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /** The array of objects. */\r\n  private /*@spec_public@*/ Object[] m_Objects;\r\n  //@ invariant m_Objects != null;\r\n  //@ invariant m_Objects.length \u003e= 0;\r\n\r\n  /** The current size; */\r\n  private /*@spec_public@*/ int m_Size = 0;\r\n  //@ invariant 0 \u003c= m_Size;\r\n  //@ invariant m_Size \u003c= m_Objects.length;\r\n\r\n  /** The capacity increment */\r\n  private /*@spec_public@*/ int m_CapacityIncrement = 1;\r\n  //@ invariant 1 \u003c= m_CapacityIncrement;\r\n  \r\n  /** The capacity multiplier. */\r\n  private /*@spec_public@*/ int m_CapacityMultiplier = 2;\r\n  //@ invariant 1 \u003c= m_CapacityMultiplier;\r\n\r\n  // Make sure the size will increase...\r\n  //@ invariant 3 \u003c= m_CapacityMultiplier + m_CapacityIncrement;\r\n\r\n  /**\r\n   * Constructs an empty vector with initial\r\n   * capacity zero.\r\n   */\r\n  public FastVector() {\r\n  \r\n    m_Objects = new Object[0];\r\n  }\r\n\r\n  /**\r\n   * Constructs a vector with the given capacity.\r\n   *\r\n   * @param capacity the vector's initial capacity\r\n   */\r\n  //@ requires capacity \u003e= 0;\r\n  public FastVector(int capacity) {\r\n\r\n    m_Objects = new Object[capacity];\r\n  }\r\n\r\n  /**\r\n   * Adds an element to this vector. Increases its\r\n   * capacity if its not large enough.\r\n   *\r\n   * @param element the element to add\r\n   */\r\n  public final void addElement(Object element) {\r\n\r\n    Object[] newObjects;\r\n\r\n    if (m_Size == m_Objects.length) {\r\n      newObjects = new Object[m_CapacityMultiplier *\r\n\t\t\t     (m_Objects.length +\r\n\t\t\t      m_CapacityIncrement)];\r\n      System.arraycopy(m_Objects, 0, newObjects, 0, m_Size);\r\n      m_Objects = newObjects;\r\n    }\r\n    m_Objects[m_Size] = element;\r\n    m_Size++;\r\n  }\r\n\r\n  /**\r\n   * Returns the capacity of the vector.\r\n   *\r\n   * @return the capacity of the vector\r\n   */\r\n  //@ ensures \\result == m_Objects.length;\r\n  public final /*@pure@*/ int capacity() {\r\n  \r\n    return m_Objects.length;\r\n  }\r\n\r\n  /**\r\n   * Produces a shallow copy of this vector.\r\n   *\r\n   * @return the new vector\r\n   */\r\n  public final Object copy() {\r\n\r\n    FastVector copy = new FastVector(m_Objects.length);\r\n\r\n    copy.m_Size = m_Size;\r\n    copy.m_CapacityIncrement = m_CapacityIncrement;\r\n    copy.m_CapacityMultiplier = m_CapacityMultiplier;\r\n    System.arraycopy(m_Objects, 0, copy.m_Objects, 0, m_Size);\r\n    return copy;\r\n  }\r\n\r\n  /**\r\n   * Clones the vector and shallow copies all its elements.\r\n   * The elements have to implement the Copyable interface.\r\n   * \r\n   * @return the new vector\r\n   */\r\n  public final Object copyElements() {\r\n\r\n    FastVector copy = new FastVector(m_Objects.length);\r\n\r\n    copy.m_Size = m_Size;\r\n    copy.m_CapacityIncrement = m_CapacityIncrement;\r\n    copy.m_CapacityMultiplier = m_CapacityMultiplier;\r\n    for (int i = 0; i \u003c m_Size; i++) {\r\n      copy.m_Objects[i] = ((Copyable)m_Objects[i]).copy();\r\n    }\r\n    return copy;\r\n  }\r\n\r\n  /**\r\n   * Returns the element at the given position.\r\n   *\r\n   * @param index the element's index\r\n   * @return the element with the given index\r\n   */\r\n  //@ requires 0 \u003c= index;\r\n  //@ requires index \u003c m_Objects.length;\r\n  public final /*@pure@*/ Object elementAt(int index) {\r\n\r\n    return m_Objects[index];\r\n  }\r\n\r\n  /**\r\n   * Returns an enumeration of this vector.\r\n   *\r\n   * @return an enumeration of this vector\r\n   */\r\n  public final /*@pure@*/ Enumeration elements() {\r\n  \r\n    return new FastVectorEnumeration(this);\r\n  }\r\n\r\n  /**\r\n   * Returns an enumeration of this vector, skipping the\r\n   * element with the given index.\r\n   *\r\n   * @param index the element to skip\r\n   * @return an enumeration of this vector\r\n   */\r\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();\r\n  public final /*@pure@*/ Enumeration elements(int index) {\r\n  \r\n    return new FastVectorEnumeration(this, index);\r\n  }\r\n\r\n    /**\r\n     * added by akibriya\r\n     * Checks if the object given as parameter is contained in the vector.\r\n     * @param o object to be checked.\r\n     * @return True if the object is in the vector.\r\n     */\r\n  public /*@pure@*/ boolean contains(Object o) {\r\n      if(o==null)\r\n\t  return false;\r\n\r\n      for(int i=0; i\u003cm_Objects.length; i++) \r\n\t  if(o.equals(m_Objects[i]))\r\n\t      return true;\r\n      \r\n      return false;\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns the first element of the vector.\r\n   *\r\n   * @return the first element of the vector\r\n   */\r\n  //@ requires m_Size \u003e 0;\r\n  public final /*@pure@*/ Object firstElement() {\r\n\r\n    return m_Objects[0];\r\n  }\r\n\r\n  /**\r\n   * Searches for the first occurence of the given argument, \r\n   * testing for equality using the equals method. \r\n   *\r\n   * @param element the element to be found\r\n   * @return the index of the first occurrence of the argument \r\n   * in this vector; returns -1 if the object is not found\r\n   */\r\n  public final /*@pure@*/ int indexOf(/*@non_null@*/ Object element) {\r\n\r\n    for (int i = 0; i \u003c m_Size; i++) {\r\n      if (element.equals(m_Objects[i])) {\r\n\treturn i;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Inserts an element at the given position.\r\n   *\r\n   * @param element the element to be inserted\r\n   * @param index the element's index\r\n   */\r\n  public final void insertElementAt(Object element, int index) {\r\n\r\n    Object[] newObjects;\r\n\r\n    if (m_Size \u003c m_Objects.length) {\r\n      System.arraycopy(m_Objects, index, m_Objects, index + 1, \r\n                       m_Size - index);\r\n      m_Objects[index] = element;\r\n    } else {\r\n      newObjects = new Object[m_CapacityMultiplier *\r\n\t\t\t     (m_Objects.length +\r\n\t\t\t      m_CapacityIncrement)];\r\n      System.arraycopy(m_Objects, 0, newObjects, 0, index);\r\n      newObjects[index] = element;\r\n      System.arraycopy(m_Objects, index, newObjects, index + 1,\r\n\t\t       m_Size - index);\r\n      m_Objects = newObjects;\r\n    }\r\n    m_Size++;\r\n  }\r\n\r\n  /**\r\n   * Returns the last element of the vector.\r\n   *\r\n   * @return the last element of the vector\r\n   */\r\n  //@ requires m_Size \u003e 0;\r\n  public final /*@pure@*/ Object lastElement() {\r\n\r\n    return m_Objects[m_Size - 1];\r\n  }\r\n\r\n  /**\r\n   * Deletes an element from this vector.\r\n   *\r\n   * @param index the index of the element to be deleted\r\n   */\r\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Size;\r\n  public final void removeElementAt(int index) {\r\n\r\n    System.arraycopy(m_Objects, index + 1, m_Objects, index, \r\n                     m_Size - index - 1);\r\n    m_Size--;\r\n  }\r\n\r\n  /**\r\n   * Removes all components from this vector and sets its \r\n   * size to zero. \r\n   */\r\n  public final void removeAllElements() {\r\n\r\n    m_Objects = new Object[m_Objects.length];\r\n    m_Size = 0;\r\n  }\r\n\r\n  /**\r\n   * Appends all elements of the supplied vector to this vector.\r\n   *\r\n   * @param toAppend the FastVector containing elements to append.\r\n   */\r\n  public final void appendElements(FastVector toAppend) {\r\n\r\n    setCapacity(size() + toAppend.size());\r\n    System.arraycopy(toAppend.m_Objects, 0, m_Objects, size(), toAppend.size());\r\n    m_Size = m_Objects.length;\r\n  }\r\n\r\n  /** \r\n   * Returns all the elements of this vector as an array\r\n   *\r\n   * @return an array containing all the elements of this vector\r\n   */\r\n  public final Object [] toArray() {\r\n\r\n    Object [] newObjects = new Object[size()];\r\n    System.arraycopy(m_Objects, 0, newObjects, 0, size());\r\n    return newObjects;\r\n  }\r\n\r\n  /**\r\n   * Sets the vector's capacity to the given value.\r\n   *\r\n   * @param capacity the new capacity\r\n   */\r\n  public final void setCapacity(int capacity) {\r\n\r\n    Object[] newObjects = new Object[capacity];\r\n   \r\n    System.arraycopy(m_Objects, 0, newObjects, 0, Math.min(capacity, m_Size));\r\n    m_Objects = newObjects;\r\n    if (m_Objects.length \u003c m_Size)\r\n      m_Size = m_Objects.length;\r\n  }\r\n\r\n  /**\r\n   * Sets the element at the given index.\r\n   *\r\n   * @param element the element to be put into the vector\r\n   * @param index the index at which the element is to be placed\r\n   */\r\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();\r\n  public final void setElementAt(Object element, int index) {\r\n\r\n    m_Objects[index] = element;\r\n  }\r\n\r\n  /**\r\n   * Returns the vector's current size.\r\n   *\r\n   * @return the vector's current size\r\n   */\r\n  //@ ensures \\result == m_Size;\r\n  public final /*@pure@*/ int size() {\r\n\r\n    return m_Size;\r\n  }\r\n\r\n  /**\r\n   * Swaps two elements in the vector.\r\n   *\r\n   * @param first index of the first element\r\n   * @param second index of the second element\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c size();\r\n  //@ requires 0 \u003c= second \u0026\u0026 second \u003c size();\r\n  public final void swap(int first, int second) {\r\n\r\n    Object help = m_Objects[first];\r\n\r\n    m_Objects[first] = m_Objects[second];\r\n    m_Objects[second] = help;\r\n  }\r\n\r\n  /**\r\n   * Sets the vector's capacity to its size.\r\n   */\r\n  public final void trimToSize() {\r\n\r\n    Object[] newObjects = new Object[m_Size];\r\n    \r\n    System.arraycopy(m_Objects, 0, newObjects, 0, m_Size);\r\n    m_Objects = newObjects;\r\n  }\r\n}\r\n\r\n\r\n",
        "name": "FastVector.java",
        "path": "src/keel/Algorithms/Statistical_Classifiers/Logistic/core/FastVector.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/Statistical_Classifiers/Logistic/core/FastVector.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 110,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= special \u0026\u0026 special \u003c vector.size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 189,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires capacity \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 221,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Objects.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 268,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 269,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003c m_Objects.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 292,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 321,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Size \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 377,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Size \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 388,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Size;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 451,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 462,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Size;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 474,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 475,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= second \u0026\u0026 second \u003c size();\r"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "/***********************************************************************\r\n\r\n\tThis file is part of KEEL-software, the Data Mining tool for regression, \r\n\tclassification, clustering, pattern mining and so on.\r\n\r\n\tCopyright (C) 2004-2010\r\n\t\r\n\tF. Herrera (herrera@decsai.ugr.es)\r\n    L. Sánchez (luciano@uniovi.es)\r\n    J. Alcalá-Fdez (jalcala@decsai.ugr.es)\r\n    S. García (sglopez@ujaen.es)\r\n    A. Fernández (alberto.fernandez@ujaen.es)\r\n    J. Luengo (julianlm@decsai.ugr.es)\r\n\r\n\tThis program is free software: you can redistribute it and/or modify\r\n\tit under the terms of the GNU General Public License as published by\r\n\tthe Free Software Foundation, either version 3 of the License, or\r\n\t(at your option) any later version.\r\n\r\n\tThis program is distributed in the hope that it will be useful,\r\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\tGNU General Public License for more details.\r\n\r\n\tYou should have received a copy of the GNU General Public License\r\n\talong with this program.  If not, see http://www.gnu.org/licenses/\r\n  \r\n**********************************************************************/\r\n\r\n/*\r\n *    This program is free software; you can redistribute it and/or modify\r\n *    it under the terms of the GNU General Public License as published by\r\n *    the Free Software Foundation; either version 2 of the License, or\r\n *    (at your option) any later version.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU General Public License\r\n *    along with this program; if not, write to the Free Software\r\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\r\n */\r\n\r\n/*\r\n *    FastVector.java\r\n *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand\r\n *\r\n */\r\n\r\npackage keel.Algorithms.Fuzzy_Rule_Learning.Hybrid.FURIA.core;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.Enumeration;\r\n\r\n/**\r\n * Implements a fast vector class without synchronized\r\n * methods. Replaces java.util.Vector. (Synchronized methods tend to\r\n * be slow.)\r\n *\r\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\r\n * @version $Revision: 1.16 $\r\n */\r\npublic class FastVector implements Copyable, Serializable {\r\n\r\n  /** for serialization */\r\n  private static final long serialVersionUID = -2173635135622930169L;\r\n\r\n  /**\r\n   * Class for enumerating the vector's elements.\r\n   */\r\n  public class FastVectorEnumeration\r\n    implements Enumeration {\r\n\r\n    /** The counter. */\r\n    private int m_Counter;\r\n    // These JML commands say how m_Counter implements Enumeration\r\n    //@ in moreElements;\r\n    //@ private represents moreElements = m_Counter \u003c m_Vector.size();\r\n    //@ private invariant 0 \u003c= m_Counter \u0026\u0026 m_Counter \u003c= m_Vector.size();\r\n\r\n    /** The vector. */\r\n    private /*@non_null@*/ FastVector m_Vector;\r\n\r\n    /** Special element. Skipped during enumeration. */\r\n    private int m_SpecialElement;\r\n    //@ private invariant -1 \u003c= m_SpecialElement;\r\n    //@ private invariant m_SpecialElement \u003c m_Vector.size();\r\n    //@ private invariant m_SpecialElement\u003e=0 ==\u003e m_Counter!=m_SpecialElement;\r\n\r\n    /**\r\n     * Constructs an enumeration.\r\n     *\r\n     * @param vector the vector which is to be enumerated\r\n     */\r\n    public FastVectorEnumeration(/*@non_null@*/FastVector vector) {\r\n\r\n      m_Counter = 0;\r\n      m_Vector = vector;\r\n      m_SpecialElement = -1;\r\n    }\r\n\r\n    /**\r\n     * Constructs an enumeration with a special element.\r\n     * The special element is skipped during the enumeration.\r\n     *\r\n     * @param vector the vector which is to be enumerated\r\n     * @param special the index of the special element\r\n     */\r\n    //@ requires 0 \u003c= special \u0026\u0026 special \u003c vector.size();\r\n    public FastVectorEnumeration(/*@non_null@*/FastVector vector, int special){\r\n\r\n      m_Vector = vector;\r\n      m_SpecialElement = special;\r\n      if (special == 0) {\r\n\tm_Counter = 1;\r\n      } else {\r\n\tm_Counter = 0;\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * Tests if there are any more elements to enumerate.\r\n     *\r\n     * @return true if there are some elements left\r\n     */\r\n    public final /*@pure@*/ boolean hasMoreElements() {\r\n\r\n      if (m_Counter \u003c m_Vector.size()) {\r\n\treturn true;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Returns the next element.\r\n     *\r\n     * @return the next element to be enumerated\r\n     */\r\n    //@ also requires hasMoreElements();\r\n    public final Object nextElement() {\r\n\r\n      Object result = m_Vector.elementAt(m_Counter);\r\n\r\n      m_Counter++;\r\n      if (m_Counter == m_SpecialElement) {\r\n\tm_Counter++;\r\n      }\r\n      return result;\r\n    }\r\n\r\n  }\r\n\r\n  /** The array of objects. */\r\n  private /*@spec_public@*/ Object[] m_Objects;\r\n  //@ invariant m_Objects != null;\r\n  //@ invariant m_Objects.length \u003e= 0;\r\n\r\n  /** The current size; */\r\n  private /*@spec_public@*/ int m_Size = 0;\r\n  //@ invariant 0 \u003c= m_Size;\r\n  //@ invariant m_Size \u003c= m_Objects.length;\r\n\r\n  /** The capacity increment */\r\n  private /*@spec_public@*/ int m_CapacityIncrement = 1;\r\n  //@ invariant 1 \u003c= m_CapacityIncrement;\r\n\r\n  /** The capacity multiplier. */\r\n  private /*@spec_public@*/ int m_CapacityMultiplier = 2;\r\n  //@ invariant 1 \u003c= m_CapacityMultiplier;\r\n\r\n  // Make sure the size will increase...\r\n  //@ invariant 3 \u003c= m_CapacityMultiplier + m_CapacityIncrement;\r\n\r\n  /**\r\n   * Constructs an empty vector with initial\r\n   * capacity zero.\r\n   */\r\n  public FastVector() {\r\n\r\n    m_Objects = new Object[0];\r\n  }\r\n\r\n  /**\r\n   * Constructs a vector with the given capacity.\r\n   *\r\n   * @param capacity the vector's initial capacity\r\n   */\r\n  //@ requires capacity \u003e= 0;\r\n  public FastVector(int capacity) {\r\n\r\n    m_Objects = new Object[capacity];\r\n  }\r\n\r\n  /**\r\n   * Adds an element to this vector. Increases its\r\n   * capacity if its not large enough.\r\n   *\r\n   * @param element the element to add\r\n   */\r\n  public final void addElement(Object element) {\r\n\r\n    Object[] newObjects;\r\n\r\n    if (m_Size == m_Objects.length) {\r\n      newObjects = new Object[m_CapacityMultiplier *\r\n\t\t\t     (m_Objects.length +\r\n\t\t\t      m_CapacityIncrement)];\r\n      System.arraycopy(m_Objects, 0, newObjects, 0, m_Size);\r\n      m_Objects = newObjects;\r\n    }\r\n    m_Objects[m_Size] = element;\r\n    m_Size++;\r\n  }\r\n\r\n  /**\r\n   * Returns the capacity of the vector.\r\n   *\r\n   * @return the capacity of the vector\r\n   */\r\n  //@ ensures \\result == m_Objects.length;\r\n  public final /*@pure@*/ int capacity() {\r\n\r\n    return m_Objects.length;\r\n  }\r\n\r\n  /**\r\n   * Produces a shallow copy of this vector.\r\n   *\r\n   * @return the new vector\r\n   */\r\n  public final Object copy() {\r\n\r\n    FastVector copy = new FastVector(m_Objects.length);\r\n\r\n    copy.m_Size = m_Size;\r\n    copy.m_CapacityIncrement = m_CapacityIncrement;\r\n    copy.m_CapacityMultiplier = m_CapacityMultiplier;\r\n    System.arraycopy(m_Objects, 0, copy.m_Objects, 0, m_Size);\r\n    return copy;\r\n  }\r\n\r\n  /**\r\n   * Clones the vector and shallow copies all its elements.\r\n   * The elements have to implement the Copyable interface.\r\n   *\r\n   * @return the new vector\r\n   */\r\n  public final Object copyElements() {\r\n\r\n    FastVector copy = new FastVector(m_Objects.length);\r\n\r\n    copy.m_Size = m_Size;\r\n    copy.m_CapacityIncrement = m_CapacityIncrement;\r\n    copy.m_CapacityMultiplier = m_CapacityMultiplier;\r\n    for (int i = 0; i \u003c m_Size; i++) {\r\n        copy.m_Objects[i] = ((Copyable)m_Objects[i]).copy();\r\n    }\r\n    return copy;\r\n  }\r\n\r\n  /**\r\n   * Returns the element at the given position.\r\n   *\r\n   * @param index the element's index\r\n   * @return the element with the given index\r\n   */\r\n  //@ requires 0 \u003c= index;\r\n  //@ requires index \u003c m_Objects.length;\r\n  public final /*@pure@*/ Object elementAt(int index) {\r\n\r\n    return m_Objects[index];\r\n  }\r\n\r\n  /**\r\n   * Returns an enumeration of this vector.\r\n   *\r\n   * @return an enumeration of this vector\r\n   */\r\n  public final /*@pure@*/ Enumeration elements() {\r\n\r\n    return new FastVectorEnumeration(this);\r\n  }\r\n\r\n  /**\r\n   * Returns an enumeration of this vector, skipping the\r\n   * element with the given index.\r\n   *\r\n   * @param index the element to skip\r\n   * @return an enumeration of this vector\r\n   */\r\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();\r\n  public final /*@pure@*/ Enumeration elements(int index) {\r\n\r\n    return new FastVectorEnumeration(this, index);\r\n  }\r\n\r\n    /**\r\n     * Checks if the given object is contained in the vector.\r\n     * @param o given object to be checked.\r\n     * @return True if it is contained, fale otherwise.\r\n     */\r\n    public /*@pure@*/ boolean contains(Object o) {\r\n      if(o==null)\r\n\t  return false;\r\n\r\n      for(int i=0; i\u003cm_Objects.length; i++)\r\n\t  if(o.equals(m_Objects[i]))\r\n\t      return true;\r\n\r\n      return false;\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns the first element of the vector.\r\n   *\r\n   * @return the first element of the vector\r\n   */\r\n  //@ requires m_Size \u003e 0;\r\n  public final /*@pure@*/ Object firstElement() {\r\n\r\n    return m_Objects[0];\r\n  }\r\n\r\n  /**\r\n   * Searches for the first occurence of the given argument,\r\n   * testing for equality using the equals method.\r\n   *\r\n   * @param element the element to be found\r\n   * @return the index of the first occurrence of the argument\r\n   * in this vector; returns -1 if the object is not found\r\n   */\r\n  public final /*@pure@*/ int indexOf(/*@non_null@*/ Object element) {\r\n\r\n    for (int i = 0; i \u003c m_Size; i++) {\r\n      if (element.equals(m_Objects[i])) {\r\n\treturn i;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Inserts an element at the given position.\r\n   *\r\n   * @param element the element to be inserted\r\n   * @param index the element's index\r\n   */\r\n  public final void insertElementAt(Object element, int index) {\r\n\r\n    Object[] newObjects;\r\n\r\n    if (m_Size \u003c m_Objects.length) {\r\n      System.arraycopy(m_Objects, index, m_Objects, index + 1,\r\n                       m_Size - index);\r\n      m_Objects[index] = element;\r\n    } else {\r\n      newObjects = new Object[m_CapacityMultiplier *\r\n\t\t\t     (m_Objects.length +\r\n\t\t\t      m_CapacityIncrement)];\r\n      System.arraycopy(m_Objects, 0, newObjects, 0, index);\r\n      newObjects[index] = element;\r\n      System.arraycopy(m_Objects, index, newObjects, index + 1,\r\n\t\t       m_Size - index);\r\n      m_Objects = newObjects;\r\n    }\r\n    m_Size++;\r\n  }\r\n\r\n  /**\r\n   * Returns the last element of the vector.\r\n   *\r\n   * @return the last element of the vector\r\n   */\r\n  //@ requires m_Size \u003e 0;\r\n  public final /*@pure@*/ Object lastElement() {\r\n\r\n    return m_Objects[m_Size - 1];\r\n  }\r\n\r\n  /**\r\n   * Deletes an element from this vector.\r\n   *\r\n   * @param index the index of the element to be deleted\r\n   */\r\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Size;\r\n  public final void removeElementAt(int index) {\r\n\r\n    System.arraycopy(m_Objects, index + 1, m_Objects, index,\r\n                     m_Size - index - 1);\r\n\r\n    // clear the last reference\r\n    m_Objects[m_Size - 1] = null;\r\n\r\n    m_Size--;\r\n  }\r\n\r\n  /**\r\n   * Removes all components from this vector and sets its\r\n   * size to zero.\r\n   */\r\n  public final void removeAllElements() {\r\n\r\n    m_Objects = new Object[m_Objects.length];\r\n    m_Size = 0;\r\n  }\r\n\r\n  /**\r\n   * Appends all elements of the supplied vector to this vector.\r\n   *\r\n   * @param toAppend the FastVector containing elements to append.\r\n   */\r\n  public final void appendElements(FastVector toAppend) {\r\n\r\n    setCapacity(size() + toAppend.size());\r\n    System.arraycopy(toAppend.m_Objects, 0, m_Objects, size(), toAppend.size());\r\n    m_Size = m_Objects.length;\r\n  }\r\n\r\n  /**\r\n   * Returns all the elements of this vector as an array\r\n   *\r\n   * @return an array containing all the elements of this vector\r\n   */\r\n  public final Object [] toArray() {\r\n\r\n    Object [] newObjects = new Object[size()];\r\n    System.arraycopy(m_Objects, 0, newObjects, 0, size());\r\n    return newObjects;\r\n  }\r\n\r\n  /**\r\n   * Sets the vector's capacity to the given value.\r\n   *\r\n   * @param capacity the new capacity\r\n   */\r\n  public final void setCapacity(int capacity) {\r\n\r\n    Object[] newObjects = new Object[capacity];\r\n\r\n    System.arraycopy(m_Objects, 0, newObjects, 0, Math.min(capacity, m_Size));\r\n    m_Objects = newObjects;\r\n    if (m_Objects.length \u003c m_Size)\r\n      m_Size = m_Objects.length;\r\n  }\r\n\r\n  /**\r\n   * Sets the element at the given index.\r\n   *\r\n   * @param element the element to be put into the vector\r\n   * @param index the index at which the element is to be placed\r\n   */\r\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();\r\n  public final void setElementAt(Object element, int index) {\r\n\r\n    m_Objects[index] = element;\r\n  }\r\n\r\n  /**\r\n   * Returns the vector's current size.\r\n   *\r\n   * @return the vector's current size\r\n   */\r\n  //@ ensures \\result == m_Size;\r\n  public final /*@pure@*/ int size() {\r\n\r\n    return m_Size;\r\n  }\r\n\r\n  /**\r\n   * Swaps two elements in the vector.\r\n   *\r\n   * @param first index of the first element\r\n   * @param second index of the second element\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c size();\r\n  //@ requires 0 \u003c= second \u0026\u0026 second \u003c size();\r\n  public final void swap(int first, int second) {\r\n\r\n    Object help = m_Objects[first];\r\n\r\n    m_Objects[first] = m_Objects[second];\r\n    m_Objects[second] = help;\r\n  }\r\n\r\n  /**\r\n   * Sets the vector's capacity to its size.\r\n   */\r\n  public final void trimToSize() {\r\n\r\n    Object[] newObjects = new Object[m_Size];\r\n\r\n    System.arraycopy(m_Objects, 0, newObjects, 0, m_Size);\r\n    m_Objects = newObjects;\r\n  }\r\n}\r\n\r\n",
        "name": "FastVector.java",
        "path": "src/keel/Algorithms/Fuzzy_Rule_Learning/Hybrid/FURIA/core/FastVector.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/Fuzzy_Rule_Learning/Hybrid/FURIA/core/FastVector.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 110,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= special \u0026\u0026 special \u003c vector.size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 190,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires capacity \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 222,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Objects.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 269,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 270,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003c m_Objects.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 293,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 321,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Size \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 377,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Size \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 388,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Size;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 455,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 466,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Size;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 478,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 479,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= second \u0026\u0026 second \u003c size();\r"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "/***********************************************************************\r\n\r\n\tThis file is part of KEEL-software, the Data Mining tool for regression, \r\n\tclassification, clustering, pattern mining and so on.\r\n\r\n\tCopyright (C) 2004-2010\r\n\t\r\n\tF. Herrera (herrera@decsai.ugr.es)\r\n    L. Sánchez (luciano@uniovi.es)\r\n    J. Alcalá-Fdez (jalcala@decsai.ugr.es)\r\n    S. García (sglopez@ujaen.es)\r\n    A. Fernández (alberto.fernandez@ujaen.es)\r\n    J. Luengo (julianlm@decsai.ugr.es)\r\n\r\n\tThis program is free software: you can redistribute it and/or modify\r\n\tit under the terms of the GNU General Public License as published by\r\n\tthe Free Software Foundation, either version 3 of the License, or\r\n\t(at your option) any later version.\r\n\r\n\tThis program is distributed in the hope that it will be useful,\r\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\tGNU General Public License for more details.\r\n\r\n\tYou should have received a copy of the GNU General Public License\r\n\talong with this program.  If not, see http://www.gnu.org/licenses/\r\n  \r\n**********************************************************************/\r\n\r\n/*\r\n *    This program is free software; you can redistribute it and/or modify\r\n *    it under the terms of the GNU General Public License as published by\r\n *    the Free Software Foundation; either version 2 of the License, or\r\n *    (at your option) any later version.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU General Public License\r\n *    along with this program; if not, write to the Free Software\r\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\r\n */\r\n\r\n/*\r\n *    SingleIndex.java\r\n *    Copyright (C) 2003 University of Waikato, Hamilton, New Zealand\r\n *\r\n */\r\n\r\npackage keel.Algorithms.Fuzzy_Rule_Learning.Hybrid.FURIA.core;\r\n\r\nimport java.io.Serializable;\r\n\r\n/**\r\n * Class representing a single cardinal number. The number is set by a\r\n * string representation such as: \u003cP\u003e\r\n *\r\n * \u003ccode\u003e\r\n *   first\r\n *   last\r\n *   1\r\n *   3\r\n * \u003c/code\u003e \u003cP\u003e\r\n * The number is internally converted from 1-based to 0-based (so methods that\r\n * set or get numbers not in string format should use 0-based numbers).\r\n *\r\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\r\n * @version $Revision: 1.8 $\r\n */\r\npublic class SingleIndex implements Serializable {\r\n\r\n  /** for serialization */\r\n  static final long serialVersionUID = 5285169134430839303L;\r\n\r\n  /** Record the string representation of the number */\r\n  protected /*@non_null spec_public@*/ String m_IndexString = \"\";\r\n\r\n  /** The selected index */\r\n  protected /*@ spec_public @*/ int m_SelectedIndex = -1;\r\n\r\n  /** Store the maximum value permitted. -1 indicates that no upper\r\n      value has been set */\r\n  protected /*@ spec_public @*/ int m_Upper = -1;\r\n\r\n  /**\r\n   * Default constructor.\r\n   *\r\n   */\r\n  //@ assignable m_IndexString, m_SelectedIndex, m_Upper;\r\n  //@ ensures m_SelectedIndex == -1;\r\n  //@ ensures m_Upper == -1;\r\n  public SingleIndex() {\r\n  }\r\n\r\n  /**\r\n   * Constructor to set initial index.\r\n   *\r\n   * @param index the initial index\r\n   * @throws IllegalArgumentException if the index is invalid\r\n   */\r\n  //@ assignable m_IndexString, m_SelectedIndex, m_Upper;\r\n  //@ ensures m_IndexString == index;\r\n  //@ ensures m_SelectedIndex == -1;\r\n  //@ ensures m_Upper == -1;\r\n  public SingleIndex(/*@non_null@*/ String index) {\r\n\r\n    setSingleIndex(index);\r\n  }\r\n\r\n  /**\r\n   * Sets the value of \"last\".\r\n   *\r\n   * @param newUpper the value of \"last\"\r\n   */\r\n  //@ assignable m_Upper, m_IndexString, m_SelectedIndex;\r\n  //@ ensures newUpper \u003c 0 ==\u003e m_Upper == \\old(m_Upper);\r\n  //@ ensures newUpper \u003e= 0 ==\u003e m_Upper == newUpper;\r\n  public void setUpper(int newUpper) {\r\n\r\n    if (newUpper \u003e= 0) {\r\n      m_Upper = newUpper;\r\n      setValue();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the string representing the selected range of values\r\n   *\r\n   * @return the range selection string\r\n   */\r\n  //@ ensures \\result == m_IndexString;\r\n  public /*@pure@*/ String getSingleIndex() {\r\n\r\n    return m_IndexString;\r\n  }\r\n\r\n  /**\r\n   * Sets the index from a string representation. Note that setUpper()\r\n   * must be called for the value to be actually set\r\n   *\r\n   * @param index the index set\r\n   * @throws IllegalArgumentException if the index was not well formed\r\n   */\r\n  //@ assignable m_IndexString, m_SelectedIndex;\r\n  //@ ensures m_IndexString == index;\r\n  //@ ensures m_SelectedIndex == -1;\r\n  public void setSingleIndex(/*@non_null@*/ String index) {\r\n\r\n    m_IndexString = index;\r\n    m_SelectedIndex = -1;\r\n  }\r\n\r\n  /**\r\n   * Constructs a representation of the current range. Being a string\r\n   * representation, the numbers are based from 1.\r\n   *\r\n   * @return the string representation of the current range\r\n   */\r\n  //@ also signals (RuntimeException e) \\old(m_Upper) \u003c 0;\r\n  //@ ensures \\result != null;\r\n  public /*@pure@*/ String toString() {\r\n\r\n    if (m_IndexString.equals(\"\")) {\r\n      return \"No index set\";\r\n    }\r\n    if (m_Upper == -1) {\r\n      throw new RuntimeException(\"Upper limit has not been specified\");\r\n    }\r\n    return m_IndexString;\r\n  }\r\n\r\n  /**\r\n   * Gets the selected index\r\n   *\r\n   * @return the selected index\r\n   * @throws RuntimeException if the upper limit of the index hasn't been defined\r\n   */\r\n  //@ requires m_Upper \u003e= 0;\r\n  //@ requires m_IndexString.length() \u003e 0;\r\n  //@ ensures \\result == m_SelectedIndex;\r\n  public /*@pure@*/ int getIndex() {\r\n\r\n    if (m_IndexString.equals(\"\")) {\r\n      throw new RuntimeException(\"No index set\");\r\n    }\r\n    if (m_Upper == -1) {\r\n      throw new RuntimeException(\"No upper limit has been specified for index\");\r\n    }\r\n    return m_SelectedIndex;\r\n  }\r\n\r\n  /**\r\n   * Creates a string representation of the given index.\r\n   *\r\n   * @param index the index to turn into a string.\r\n   * Since the index will typically come from a program, indices are assumed\r\n   * from 0, and thus will have 1 added in the String representation.\r\n   * @return the string representation\r\n   */\r\n  //@ requires index \u003e= 0;\r\n  public static /*@pure non_null@*/ String indexToString(int index) {\r\n\r\n    return \"\" + (index + 1);\r\n  }\r\n\r\n  /**\r\n   * Translates a single string selection into it's internal 0-based equivalent\r\n   */\r\n  //@ assignable m_SelectedIndex, m_IndexString;\r\n  protected void setValue() {\r\n\r\n    if (m_IndexString.equals(\"\")) {\r\n      throw new RuntimeException(\"No index set\");\r\n    }\r\n    if (m_IndexString.toLowerCase().equals(\"first\")) {\r\n      m_SelectedIndex = 0;\r\n    } else if (m_IndexString.toLowerCase().equals(\"last\")) {\r\n      m_SelectedIndex = m_Upper;\r\n    } else {\r\n      m_SelectedIndex = Integer.parseInt(m_IndexString) - 1;\r\n      if (m_SelectedIndex \u003c 0) {\r\n\tm_IndexString = \"\";\r\n\tthrow new IllegalArgumentException(\"Index must be greater than zero\");\r\n      }\r\n      if (m_SelectedIndex \u003e m_Upper) {\r\n\tm_IndexString = \"\";\r\n\tthrow new IllegalArgumentException(\"Index is too large\");\r\n      }\r\n    }\r\n  }\r\n}\r\n",
        "name": "SingleIndex.java",
        "path": "src/keel/Algorithms/Fuzzy_Rule_Learning/Hybrid/FURIA/core/SingleIndex.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/Fuzzy_Rule_Learning/Hybrid/FURIA/core/SingleIndex.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 91,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_SelectedIndex == -1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 92,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Upper == -1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 103,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_IndexString == index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 104,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_SelectedIndex == -1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 105,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Upper == -1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 117,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures newUpper \u003c 0 ==\u003e m_Upper == \\old(m_Upper);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 118,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures newUpper \u003e= 0 ==\u003e m_Upper == newUpper;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 132,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_IndexString;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 146,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_IndexString == index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 147,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_SelectedIndex == -1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 161,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 179,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Upper \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 180,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_IndexString.length() \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 181,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_SelectedIndex;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 201,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;\r"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "/***********************************************************************\r\n\r\n\tThis file is part of KEEL-software, the Data Mining tool for regression, \r\n\tclassification, clustering, pattern mining and so on.\r\n\r\n\tCopyright (C) 2004-2010\r\n\t\r\n\tF. Herrera (herrera@decsai.ugr.es)\r\n    L. Sánchez (luciano@uniovi.es)\r\n    J. Alcalá-Fdez (jalcala@decsai.ugr.es)\r\n    S. García (sglopez@ujaen.es)\r\n    A. Fernández (alberto.fernandez@ujaen.es)\r\n    J. Luengo (julianlm@decsai.ugr.es)\r\n\r\n\tThis program is free software: you can redistribute it and/or modify\r\n\tit under the terms of the GNU General Public License as published by\r\n\tthe Free Software Foundation, either version 3 of the License, or\r\n\t(at your option) any later version.\r\n\r\n\tThis program is distributed in the hope that it will be useful,\r\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\tGNU General Public License for more details.\r\n\r\n\tYou should have received a copy of the GNU General Public License\r\n\talong with this program.  If not, see http://www.gnu.org/licenses/\r\n  \r\n**********************************************************************/\r\n\r\n/*\r\n *    This program is free software; you can redistribute it and/or modify\r\n *    it under the terms of the GNU General Public License as published by\r\n *    the Free Software Foundation; either version 2 of the License, or\r\n *    (at your option) any later version.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU General Public License\r\n *    along with this program; if not, write to the Free Software\r\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\r\n */\r\n\r\n/*\r\n *    Attribute.java\r\n *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand\r\n *\r\n */\r\n\r\npackage keel.Algorithms.Fuzzy_Rule_Learning.Hybrid.FURIA.core;\r\n\r\n//import keel.Algorithms.SVM.SMO.core.*;\r\n\r\nimport java.io.IOException;\r\nimport java.io.Serializable;\r\nimport java.io.StreamTokenizer;\r\nimport java.io.StringReader;\r\nimport java.text.ParseException;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\nimport java.util.Enumeration;\r\nimport java.util.Hashtable;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * Class for handling an attribute. Once an attribute has been created,\r\n * it can't be changed. \u003cp\u003e\r\n *\r\n * The following attribute types are supported:\r\n * \u003cul\u003e\r\n *    \u003cli\u003e numeric: \u003cbr/\u003e\r\n *         This type of attribute represents a floating-point number.\r\n *    \u003c/li\u003e\r\n *    \u003cli\u003e nominal: \u003cbr/\u003e\r\n *         This type of attribute represents a fixed set of nominal values.\r\n *    \u003c/li\u003e\r\n *    \u003cli\u003e string: \u003cbr/\u003e\r\n *         This type of attribute represents a dynamically expanding set of\r\n *         nominal values. Usually used in text classification.\r\n *    \u003c/li\u003e\r\n *    \u003cli\u003e date: \u003cbr/\u003e\r\n *         This type of attribute represents a date, internally represented as\r\n *         floating-point number storing the milliseconds since January 1,\r\n *         1970, 00:00:00 GMT. The string representation of the date must be\r\n *         \u003ca href=\"http://www.iso.org/iso/en/prods-services/popstds/datesandtime.html\" target=\"_blank\"\u003e\r\n *         ISO-8601\u003c/a\u003e compliant, the default is \u003ccode\u003eyyyy-MM-dd'T'HH:mm:ss\u003c/code\u003e.\r\n *    \u003c/li\u003e\r\n *    \u003cli\u003e relational: \u003cbr/\u003e\r\n *         This type of attribute can contain other attributes and is, e.g.,\r\n *         used for representing Multi-Instance data. (Multi-Instance data\r\n *         consists of a nominal attribute containing the bag-id, then a\r\n *         relational attribute with all the attributes of the bag, and\r\n *         finally the class attribute.)\r\n *    \u003c/li\u003e\r\n * \u003c/ul\u003e\r\n *\r\n * Typical usage (code from the main() method of this class): \u003cp\u003e\r\n *\r\n * \u003ccode\u003e\r\n * ... \u003cbr\u003e\r\n *\r\n * // Create numeric attributes \"length\" and \"weight\" \u003cbr\u003e\r\n * Attribute length = new Attribute(\"length\"); \u003cbr\u003e\r\n * Attribute weight = new Attribute(\"weight\"); \u003cbr\u003e\u003cbr\u003e\r\n *\r\n * // Create vector to hold nominal values \"first\", \"second\", \"third\" \u003cbr\u003e\r\n * FastVector my_nominal_values = new FastVector(3); \u003cbr\u003e\r\n * my_nominal_values.addElement(\"first\"); \u003cbr\u003e\r\n * my_nominal_values.addElement(\"second\"); \u003cbr\u003e\r\n * my_nominal_values.addElement(\"third\"); \u003cbr\u003e\u003cbr\u003e\r\n *\r\n * // Create nominal attribute \"position\" \u003cbr\u003e\r\n * Attribute position = new Attribute(\"position\", my_nominal_values);\u003cbr\u003e\r\n *\r\n * ... \u003cbr\u003e\r\n * \u003c/code\u003e\u003cp\u003e\r\n *\r\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\r\n * @version $Revision: 1.45 $\r\n */\r\npublic class AttributeWeka  implements Serializable {\r\n\r\n  /** for serialization */\r\n  static final long serialVersionUID = -742180568732916383L;\r\n\r\n  /** Constant set for numeric attributes. */\r\n  public static final int NUMERIC = 0;\r\n\r\n  /** Constant set for nominal attributes. */\r\n  public static final int NOMINAL = 1;\r\n\r\n  /** Constant set for attributes with string values. */\r\n  public static final int STRING = 2;\r\n\r\n  /** Constant set for attributes with date values. */\r\n  public static final int DATE = 3;\r\n\r\n  /** Constant set for relation-valued attributes. */\r\n  public static final int RELATIONAL = 4;\r\n\r\n  /** Constant set for symbolic attributes. */\r\n  public static final int ORDERING_SYMBOLIC = 0;\r\n\r\n  /** Constant set for ordered attributes. */\r\n  public static final int ORDERING_ORDERED  = 1;\r\n\r\n  /** Constant set for modulo-ordered attributes. */\r\n  public static final int ORDERING_MODULO   = 2;\r\n\r\n  /** The keyword used to denote the start of an arff attribute declaration */\r\n  public final static String ARFF_ATTRIBUTE = \"@attribute\";\r\n\r\n  /** A keyword used to denote a numeric attribute */\r\n  public final static String ARFF_ATTRIBUTE_INTEGER = \"integer\";\r\n\r\n  /** A keyword used to denote a numeric attribute */\r\n  public final static String ARFF_ATTRIBUTE_REAL = \"real\";\r\n\r\n  /** A keyword used to denote a numeric attribute */\r\n  public final static String ARFF_ATTRIBUTE_NUMERIC = \"numeric\";\r\n\r\n  /** The keyword used to denote a string attribute */\r\n  public final static String ARFF_ATTRIBUTE_STRING = \"string\";\r\n\r\n  /** The keyword used to denote a date attribute */\r\n  public final static String ARFF_ATTRIBUTE_DATE = \"date\";\r\n\r\n  /** The keyword used to denote a relation-valued attribute */\r\n  public final static String ARFF_ATTRIBUTE_RELATIONAL = \"relational\";\r\n\r\n  /** The keyword used to denote the end of the declaration of a subrelation */\r\n  public final static String ARFF_END_SUBRELATION = \"@end\";\r\n\r\n  /** Strings longer than this will be stored compressed. */\r\n  private static final int STRING_COMPRESS_THRESHOLD = 200;\r\n\r\n  /** The attribute's name. */\r\n  private /*@ spec_public non_null @*/ String m_Name;\r\n\r\n  /** The attribute's type. */\r\n  private /*@ spec_public @*/ int m_Type;\r\n  /*@ invariant m_Type == NUMERIC ||\r\n                m_Type == DATE ||\r\n                m_Type == STRING ||\r\n                m_Type == NOMINAL ||\r\n                m_Type == RELATIONAL;\r\n  */\r\n\r\n  /** The attribute's values (if nominal or string). */\r\n  private /*@ spec_public @*/ FastVector m_Values;\r\n\r\n  /** Mapping of values to indices (if nominal or string). */\r\n  private Hashtable m_Hashtable;\r\n\r\n  /** The header information for a relation-valued attribute. */\r\n  private Instances m_Header;\r\n\r\n  /** Date format specification for date attributes */\r\n  private SimpleDateFormat m_DateFormat;\r\n\r\n  /** The attribute's index. */\r\n  private /*@ spec_public @*/ int m_Index;\r\n\r\n  /** The attribute's metadata. */\r\n  private ProtectedProperties m_Metadata;\r\n\r\n  /** The attribute's ordering. */\r\n  private int m_Ordering;\r\n\r\n  /** Whether the attribute is regular. */\r\n  private boolean m_IsRegular;\r\n\r\n  /** Whether the attribute is averagable. */\r\n  private boolean m_IsAveragable;\r\n\r\n  /** Whether the attribute has a zeropoint. */\r\n  private boolean m_HasZeropoint;\r\n\r\n  /** The attribute's weight. */\r\n  private double m_Weight;\r\n\r\n  /** The attribute's lower numeric bound. */\r\n  private double m_LowerBound;\r\n\r\n  /** Whether the lower bound is open. */\r\n  private boolean m_LowerBoundIsOpen;\r\n\r\n  /** The attribute's upper numeric bound. */\r\n  private double m_UpperBound;\r\n\r\n  /** Whether the upper bound is open */\r\n  private boolean m_UpperBoundIsOpen;\r\n\r\n  /**\r\n   * Constructor for a numeric attribute.\r\n   *\r\n   * @param attributeName the name for the attribute\r\n   */\r\n  //@ requires attributeName != null;\r\n  //@ ensures  m_Name == attributeName;\r\n  public AttributeWeka(String attributeName) {\r\n\r\n    this(attributeName, new ProtectedProperties(new Properties()));\r\n  }\r\n\r\n  /**\r\n   * Constructor for a numeric attribute, where metadata is supplied.\r\n   *\r\n   * @param attributeName the name for the attribute\r\n   * @param metadata the attribute's properties\r\n   */\r\n  //@ requires attributeName != null;\r\n  //@ requires metadata != null;\r\n  //@ ensures  m_Name == attributeName;\r\n  public AttributeWeka(String attributeName, ProtectedProperties metadata) {\r\n\r\n    m_Name = attributeName;\r\n    m_Index = -1;\r\n    m_Values = null;\r\n    m_Hashtable = null;\r\n    m_Header = null;\r\n    m_Type = NUMERIC;\r\n    setMetadata(metadata);\r\n  }\r\n\r\n  /**\r\n   * Constructor for a date attribute.\r\n   *\r\n   * @param attributeName the name for the attribute\r\n   * @param dateFormat a string suitable for use with\r\n   * SimpleDateFormatter for parsing dates.\r\n   */\r\n  //@ requires attributeName != null;\r\n  //@ requires dateFormat != null;\r\n  //@ ensures  m_Name == attributeName;\r\n  public AttributeWeka(String attributeName, String dateFormat) {\r\n\r\n    this(attributeName, dateFormat,\r\n\t new ProtectedProperties(new Properties()));\r\n  }\r\n\r\n  /**\r\n   * Constructor for a date attribute, where metadata is supplied.\r\n   *\r\n   * @param attributeName the name for the attribute\r\n   * @param dateFormat a string suitable for use with\r\n   * SimpleDateFormatter for parsing dates.\r\n   * @param metadata the attribute's properties\r\n   */\r\n  //@ requires attributeName != null;\r\n  //@ requires dateFormat != null;\r\n  //@ requires metadata != null;\r\n  //@ ensures  m_Name == attributeName;\r\n  public AttributeWeka(String attributeName, String dateFormat,\r\n\t\t   ProtectedProperties metadata) {\r\n\r\n    m_Name = attributeName;\r\n    m_Index = -1;\r\n    m_Values = null;\r\n    m_Hashtable = null;\r\n    m_Header = null;\r\n    m_Type = DATE;\r\n    if (dateFormat != null) {\r\n      m_DateFormat = new SimpleDateFormat(dateFormat);\r\n    } else {\r\n      m_DateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\r\n    }\r\n    m_DateFormat.setLenient(false);\r\n    setMetadata(metadata);\r\n  }\r\n\r\n  /**\r\n   * Constructor for nominal attributes and string attributes.\r\n   * If a null vector of attribute values is passed to the method,\r\n   * the attribute is assumed to be a string.\r\n   *\r\n   * @param attributeName the name for the attribute\r\n   * @param attributeValues a vector of strings denoting the\r\n   * attribute values. Null if the attribute is a string attribute.\r\n   */\r\n  //@ requires attributeName != null;\r\n  //@ ensures  m_Name == attributeName;\r\n  public AttributeWeka(String attributeName,\r\n\t\t   FastVector attributeValues) {\r\n\r\n    this(attributeName, attributeValues,\r\n\t new ProtectedProperties(new Properties()));\r\n  }\r\n\r\n  /**\r\n   * Constructor for nominal attributes and string attributes, where\r\n   * metadata is supplied. If a null vector of attribute values is passed\r\n   * to the method, the attribute is assumed to be a string.\r\n   *\r\n   * @param attributeName the name for the attribute\r\n   * @param attributeValues a vector of strings denoting the\r\n   * attribute values. Null if the attribute is a string attribute.\r\n   * @param metadata the attribute's properties\r\n   */\r\n  //@ requires attributeName != null;\r\n  //@ requires metadata != null;\r\n  /*@ ensures  m_Name == attributeName;\r\n      ensures  m_Index == -1;\r\n      ensures  attributeValues == null \u0026\u0026 m_Type == STRING\r\n            || attributeValues != null \u0026\u0026 m_Type == NOMINAL\r\n                  \u0026\u0026 m_Values.size() == attributeValues.size();\r\n      signals (IllegalArgumentException ex)\r\n                 (* if duplicate strings in attributeValues *);\r\n  */\r\n  public AttributeWeka(String attributeName,\r\n\t\t   FastVector attributeValues,\r\n\t\t   ProtectedProperties metadata) {\r\n\r\n    m_Name = attributeName;\r\n    m_Index = -1;\r\n    if (attributeValues == null) {\r\n      m_Values = new FastVector();\r\n      m_Hashtable = new Hashtable();\r\n      m_Header = null;\r\n      m_Type = STRING;\r\n    } else {\r\n      m_Values = new FastVector(attributeValues.size());\r\n      m_Hashtable = new Hashtable(attributeValues.size());\r\n      m_Header = null;\r\n      for (int i = 0; i \u003c attributeValues.size(); i++) {\r\n\tObject store = attributeValues.elementAt(i);\r\n\tif (((String)store).length() \u003e STRING_COMPRESS_THRESHOLD) {\r\n\t  try {\r\n\t    store = new SerializedObject(attributeValues.elementAt(i), true);\r\n\t  } catch (Exception ex) {\r\n\t    System.err.println(\"Couldn't compress nominal attribute value -\"\r\n\t\t\t       + \" storing uncompressed.\");\r\n\t  }\r\n\t}\r\n\tif (m_Hashtable.containsKey(store)) {\r\n\t  throw new IllegalArgumentException(\"A nominal attribute (\" +\r\n\t\t\t\t\t     attributeName + \") cannot\"\r\n\t\t\t\t\t     + \" have duplicate labels (\" + store + \").\");\r\n\t}\r\n\tm_Values.addElement(store);\r\n\tm_Hashtable.put(store, new Integer(i));\r\n      }\r\n      m_Type = NOMINAL;\r\n    }\r\n    setMetadata(metadata);\r\n  }\r\n\r\n  /**\r\n   * Constructor for relation-valued attributes.\r\n   *\r\n   * @param attributeName the name for the attribute\r\n   * @param header an Instances object specifying the header of the relation.\r\n   */\r\n  public AttributeWeka(String attributeName, Instances header) {\r\n\r\n    this(attributeName, header,\r\n\t new ProtectedProperties(new Properties()));\r\n  }\r\n\r\n  /**\r\n   * Constructor for relation-valued attributes.\r\n   *\r\n   * @param attributeName the name for the attribute\r\n   * @param header an Instances object specifying the header of the relation.\r\n   * @param metadata the attribute's properties\r\n   */\r\n  public AttributeWeka(String attributeName,\r\n\t\t   Instances header,\r\n\t\t   ProtectedProperties metadata) {\r\n\r\n    if (header.numInstances() \u003e 0) {\r\n      throw new IllegalArgumentException(\"Header for relation-valued \" +\r\n                                         \"attribute should not contain \" +\r\n                                         \"any instances\");\r\n    }\r\n    m_Name = attributeName;\r\n    m_Index = -1;\r\n    m_Values = new FastVector();\r\n    m_Hashtable = new Hashtable();\r\n    m_Header = header;\r\n    m_Type = RELATIONAL;\r\n    setMetadata(metadata);\r\n  }\r\n\r\n  /**\r\n   * Produces a shallow copy of this attribute.\r\n   *\r\n   * @return a copy of this attribute with the same index\r\n   */\r\n  //@ also ensures \\result instanceof Attribute;\r\n  public /*@ pure non_null @*/ Object copy() {\r\n\r\n    AttributeWeka copy = new AttributeWeka(m_Name);\r\n\r\n    copy.m_Index = m_Index;\r\n    copy.m_Type = m_Type;\r\n    copy.m_Values = m_Values;\r\n    copy.m_Hashtable = m_Hashtable;\r\n    copy.m_DateFormat = m_DateFormat;\r\n    copy.m_Header = m_Header;\r\n    copy.setMetadata(m_Metadata);\r\n\r\n    return copy;\r\n  }\r\n\r\n  /**\r\n   * Returns an enumeration of all the attribute's values if the\r\n   * attribute is nominal, string, or relation-valued, null otherwise.\r\n   *\r\n   * @return enumeration of all the attribute's values\r\n   */\r\n  public final /*@ pure @*/ Enumeration enumerateValues() {\r\n\r\n    if (isNominal() || isString()) {\r\n      final Enumeration ee = m_Values.elements();\r\n      return new Enumeration () {\r\n          public boolean hasMoreElements() {\r\n            return ee.hasMoreElements();\r\n          }\r\n          public Object nextElement() {\r\n            Object oo = ee.nextElement();\r\n            if (oo instanceof SerializedObject) {\r\n              return ((SerializedObject)oo).getObject();\r\n            } else {\r\n              return oo;\r\n            }\r\n          }\r\n        };\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Tests if given attribute is equal to this attribute.\r\n   *\r\n   * @param other the Object to be compared to this attribute\r\n   * @return true if the given attribute is equal to this attribute\r\n   */\r\n  public final /*@ pure @*/ boolean equals(Object other) {\r\n\r\n    if ((other == null) || !(other.getClass().equals(this.getClass()))) {\r\n      return false;\r\n    }\r\n    AttributeWeka att = (AttributeWeka) other;\r\n    if (!m_Name.equals(att.m_Name)) {\r\n      return false;\r\n    }\r\n    if (isNominal() \u0026\u0026 att.isNominal()) {\r\n      if (m_Values.size() != att.m_Values.size()) {\r\n        return false;\r\n      }\r\n      for (int i = 0; i \u003c m_Values.size(); i++) {\r\n        if (!m_Values.elementAt(i).equals(att.m_Values.elementAt(i))) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n    if (isRelationValued() \u0026\u0026 att.isRelationValued()) {\r\n      if (!m_Header.equalHeaders(att.m_Header)) {\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n    return (type() == att.type());\r\n  }\r\n\r\n  /**\r\n   * Returns the index of this attribute.\r\n   *\r\n   * @return the index of this attribute\r\n   */\r\n  //@ ensures \\result == m_Index;\r\n  public final /*@ pure @*/ int index() {\r\n\r\n    return m_Index;\r\n  }\r\n\r\n  /**\r\n   * Returns the index of a given attribute value. (The index of\r\n   * the first occurence of this value.)\r\n   *\r\n   * @param value the value for which the index is to be returned\r\n   * @return the index of the given attribute value if attribute\r\n   * is nominal or a string, -1 if it is not or the value\r\n   * can't be found\r\n   */\r\n  public final int indexOfValue(String value) {\r\n\r\n    if (!isNominal() \u0026\u0026 !isString())\r\n      return -1;\r\n    Object store = value;\r\n    if (value.length() \u003e STRING_COMPRESS_THRESHOLD) {\r\n      try {\r\n        store = new SerializedObject(value, true);\r\n      } catch (Exception ex) {\r\n        System.err.println(\"Couldn't compress string attribute value -\"\r\n                           + \" searching uncompressed.\");\r\n      }\r\n    }\r\n    Integer val = (Integer)m_Hashtable.get(store);\r\n    if (val == null) return -1;\r\n    else return val.intValue();\r\n  }\r\n\r\n  /**\r\n   * Test if the attribute is nominal.\r\n   *\r\n   * @return true if the attribute is nominal\r\n   */\r\n  //@ ensures \\result \u003c==\u003e (m_Type == NOMINAL);\r\n  public final /*@ pure @*/ boolean isNominal() {\r\n\r\n    return (m_Type == NOMINAL);\r\n  }\r\n\r\n  /**\r\n   * Tests if the attribute is numeric.\r\n   *\r\n   * @return true if the attribute is numeric\r\n   */\r\n  //@ ensures \\result \u003c==\u003e ((m_Type == NUMERIC) || (m_Type == DATE));\r\n  public final /*@ pure @*/ boolean isNumeric() {\r\n\r\n    return ((m_Type == NUMERIC) || (m_Type == DATE));\r\n  }\r\n\r\n  /**\r\n   * Tests if the attribute is relation valued.\r\n   *\r\n   * @return true if the attribute is relation valued\r\n   */\r\n  //@ ensures \\result \u003c==\u003e (m_Type == RELATIONAL);\r\n  public final /*@ pure @*/ boolean isRelationValued() {\r\n\r\n    return (m_Type == RELATIONAL);\r\n  }\r\n\r\n  /**\r\n   * Tests if the attribute is a string.\r\n   *\r\n   * @return true if the attribute is a string\r\n   */\r\n  //@ ensures \\result \u003c==\u003e (m_Type == STRING);\r\n  public final /*@ pure @*/ boolean isString() {\r\n\r\n    return (m_Type == STRING);\r\n  }\r\n\r\n  /**\r\n   * Tests if the attribute is a date type.\r\n   *\r\n   * @return true if the attribute is a date type\r\n   */\r\n  //@ ensures \\result \u003c==\u003e (m_Type == DATE);\r\n  public final /*@ pure @*/ boolean isDate() {\r\n\r\n    return (m_Type == DATE);\r\n  }\r\n\r\n  /**\r\n   * Returns the attribute's name.\r\n   *\r\n   * @return the attribute's name as a string\r\n   */\r\n  //@ ensures \\result == m_Name;\r\n  public final /*@ pure @*/ String name() {\r\n\r\n    return m_Name;\r\n  }\r\n\r\n  /**\r\n   * Returns the number of attribute values. Returns 0 for\r\n   * attributes that are not either nominal, string, or\r\n   * relation-valued.\r\n   *\r\n   * @return the number of attribute values\r\n   */\r\n  public final /*@ pure @*/ int numValues() {\r\n\r\n    if (!isNominal() \u0026\u0026 !isString() \u0026\u0026 !isRelationValued()) {\r\n      return 0;\r\n    } else {\r\n      return m_Values.size();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a description of this attribute in ARFF format. Quotes\r\n   * strings if they contain whitespace characters, or if they\r\n   * are a question mark.\r\n   *\r\n   * @return a description of this attribute as a string\r\n   */\r\n  public final String toString() {\r\n\r\n    StringBuffer text = new StringBuffer();\r\n\r\n    text.append(ARFF_ATTRIBUTE).append(\" \").append(Utils.quote(m_Name)).append(\" \");\r\n    switch (m_Type) {\r\n    case NOMINAL:\r\n      text.append('{');\r\n      Enumeration enu = enumerateValues();\r\n      while (enu.hasMoreElements()) {\r\n\ttext.append(Utils.quote((String) enu.nextElement()));\r\n\tif (enu.hasMoreElements())\r\n\t  text.append(',');\r\n      }\r\n      text.append('}');\r\n      break;\r\n    case NUMERIC:\r\n      text.append(ARFF_ATTRIBUTE_NUMERIC);\r\n      break;\r\n    case STRING:\r\n      text.append(ARFF_ATTRIBUTE_STRING);\r\n      break;\r\n    case DATE:\r\n      text.append(ARFF_ATTRIBUTE_DATE).append(\" \").append(Utils.quote(m_DateFormat.toPattern()));\r\n      break;\r\n    case RELATIONAL:\r\n      text.append(ARFF_ATTRIBUTE_RELATIONAL).append(\"\\n\");\r\n      Enumeration enm = m_Header.enumerateAttributes();\r\n      while (enm.hasMoreElements()) {\r\n        text.append(enm.nextElement()).append(\"\\n\");\r\n      }\r\n      text.append(ARFF_END_SUBRELATION).append(\" \").append(Utils.quote(m_Name));\r\n      break;\r\n    default:\r\n      text.append(\"UNKNOWN\");\r\n      break;\r\n    }\r\n    return text.toString();\r\n  }\r\n\r\n  /**\r\n   * Returns the attribute's type as an integer.\r\n   *\r\n   * @return the attribute's type.\r\n   */\r\n  //@ ensures \\result == m_Type;\r\n  public final /*@ pure @*/ int type() {\r\n\r\n    return m_Type;\r\n  }\r\n\r\n  /**\r\n   * Returns the Date format pattern in case this attribute is of type DATE,\r\n   * otherwise an empty string.\r\n   *\r\n   * @return the date format pattern\r\n   * @see SimpleDateFormat\r\n   */\r\n  public final String getDateFormat() {\r\n    if (isDate())\r\n      return m_DateFormat.toPattern();\r\n    else\r\n      return \"\";\r\n  }\r\n\r\n  /**\r\n   * Returns a value of a nominal or string attribute.  Returns an\r\n   * empty string if the attribute is neither a string nor a nominal\r\n   * attribute.\r\n   *\r\n   * @param valIndex the value's index\r\n   * @return the attribute's value as a string\r\n   */\r\n  public final /*@ non_null pure @*/ String value(int valIndex) {\r\n\r\n    if (!isNominal() \u0026\u0026 !isString()) {\r\n      return \"\";\r\n    } else {\r\n      Object val = m_Values.elementAt(valIndex);\r\n\r\n      // If we're storing strings compressed, uncompress it.\r\n      if (val instanceof SerializedObject) {\r\n        val = ((SerializedObject)val).getObject();\r\n      }\r\n      return (String) val;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the header info for a relation-valued attribute,\r\n   * null if the attribute is not relation-valued.\r\n   *\r\n   * @return the attribute's value as an Instances object\r\n   */\r\n  public final /*@ non_null pure @*/ Instances relation() {\r\n\r\n    if (!isRelationValued()) {\r\n      return null;\r\n    } else {\r\n      return m_Header;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a value of a relation-valued attribute. Returns\r\n   * null if the attribute is not relation-valued.\r\n   *\r\n   * @param valIndex the value's index\r\n   * @return the attribute's value as an Instances object\r\n   */\r\n  public final /*@ non_null pure @*/ Instances relation(int valIndex) {\r\n\r\n    if (!isRelationValued()) {\r\n      return null;\r\n    } else {\r\n      return (Instances) m_Values.elementAt(valIndex);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Constructor for a numeric attribute with a particular index.\r\n   *\r\n   * @param attributeName the name for the attribute\r\n   * @param index the attribute's index\r\n   */\r\n  //@ requires attributeName != null;\r\n  //@ requires index \u003e= 0;\r\n  //@ ensures  m_Name == attributeName;\r\n  //@ ensures  m_Index == index;\r\n  public AttributeWeka(String attributeName, int index) {\r\n\r\n    this(attributeName);\r\n    m_Index = index;\r\n  }\r\n\r\n  /**\r\n   * Constructor for date attributes with a particular index.\r\n   *\r\n   * @param attributeName the name for the attribute\r\n   * @param dateFormat a string suitable for use with\r\n   * SimpleDateFormatter for parsing dates.  Null for a default format\r\n   * string.\r\n   * @param index the attribute's index\r\n   */\r\n  //@ requires attributeName != null;\r\n  //@ requires index \u003e= 0;\r\n  //@ ensures  m_Name == attributeName;\r\n  //@ ensures  m_Index == index;\r\n  public AttributeWeka(String attributeName, String dateFormat,\r\n\t    int index) {\r\n\r\n    this(attributeName, dateFormat);\r\n    m_Index = index;\r\n  }\r\n\r\n  /**\r\n   * Constructor for nominal attributes and string attributes with\r\n   * a particular index.\r\n   * If a null vector of attribute values is passed to the method,\r\n   * the attribute is assumed to be a string.\r\n   *\r\n   * @param attributeName the name for the attribute\r\n   * @param attributeValues a vector of strings denoting the attribute values.\r\n   * Null if the attribute is a string attribute.\r\n   * @param index the attribute's index\r\n   */\r\n  //@ requires attributeName != null;\r\n  //@ requires index \u003e= 0;\r\n  //@ ensures  m_Name == attributeName;\r\n  //@ ensures  m_Index == index;\r\n  public AttributeWeka(String attributeName, FastVector attributeValues,\r\n\t    int index) {\r\n\r\n    this(attributeName, attributeValues);\r\n    m_Index = index;\r\n  }\r\n\r\n  /**\r\n   * Constructor for a relation-valued attribute with a particular index.\r\n   *\r\n   * @param attributeName the name for the attribute\r\n   * @param header the header information for this attribute\r\n   * @param index the attribute's index\r\n   */\r\n  //@ requires attributeName != null;\r\n  //@ requires index \u003e= 0;\r\n  //@ ensures  m_Name == attributeName;\r\n  //@ ensures  m_Index == index;\r\n  public AttributeWeka(String attributeName, Instances header,\r\n\t    int index) {\r\n\r\n    this(attributeName, header);\r\n    m_Index = index;\r\n  }\r\n\r\n  /**\r\n   * Adds a string value to the list of valid strings for attributes\r\n   * of type STRING and returns the index of the string.\r\n   *\r\n   * @param value The string value to add\r\n   * @return the index assigned to the string, or -1 if the attribute is not\r\n   * of type Attribute.STRING\r\n   */\r\n  /*@ requires value != null;\r\n      ensures  isString() \u0026\u0026 0 \u003c= \\result \u0026\u0026 \\result \u003c m_Values.size() ||\r\n             ! isString() \u0026\u0026 \\result == -1;\r\n  */\r\n  public int addStringValue(String value) {\r\n\r\n    if (!isString()) {\r\n      return -1;\r\n    }\r\n    Object store = value;\r\n\r\n    if (value.length() \u003e STRING_COMPRESS_THRESHOLD) {\r\n      try {\r\n        store = new SerializedObject(value, true);\r\n      } catch (Exception ex) {\r\n        System.err.println(\"Couldn't compress string attribute value -\"\r\n                           + \" storing uncompressed.\");\r\n      }\r\n    }\r\n    Integer index = (Integer)m_Hashtable.get(store);\r\n    if (index != null) {\r\n      return index.intValue();\r\n    } else {\r\n      int intIndex = m_Values.size();\r\n      m_Values.addElement(store);\r\n      m_Hashtable.put(store, new Integer(intIndex));\r\n      return intIndex;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a string value to the list of valid strings for attributes\r\n   * of type STRING and returns the index of the string. This method is\r\n   * more efficient than addStringValue(String) for long strings.\r\n   *\r\n   * @param src The Attribute containing the string value to add.\r\n   * @param index the index of the string value in the source attribute.\r\n   * @return the index assigned to the string, or -1 if the attribute is not\r\n   * of type Attribute.STRING\r\n   */\r\n  /*@ requires src != null;\r\n      requires 0 \u003c= index \u0026\u0026 index \u003c src.m_Values.size();\r\n      ensures  isString() \u0026\u0026 0 \u003c= \\result \u0026\u0026 \\result \u003c m_Values.size() ||\r\n             ! isString() \u0026\u0026 \\result == -1;\r\n  */\r\n  public int addStringValue(AttributeWeka src, int index) {\r\n\r\n    if (!isString()) {\r\n      return -1;\r\n    }\r\n    Object store = src.m_Values.elementAt(index);\r\n    Integer oldIndex = (Integer)m_Hashtable.get(store);\r\n    if (oldIndex != null) {\r\n      return oldIndex.intValue();\r\n    } else {\r\n      int intIndex = m_Values.size();\r\n      m_Values.addElement(store);\r\n      m_Hashtable.put(store, new Integer(intIndex));\r\n      return intIndex;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a relation to a relation-valued attribute.\r\n   *\r\n   * @param value The value to add\r\n   * @return the index assigned to the value, or -1 if the attribute is not\r\n   * of type Attribute.RELATIONAL\r\n   */\r\n  public int addRelation(Instances value) {\r\n\r\n    if (!isRelationValued()) {\r\n      return -1;\r\n    }\r\n    if (!m_Header.equalHeaders(value)) {\r\n      throw new IllegalArgumentException(\"Incompatible value for \" +\r\n                                         \"relation-valued attribute.\");\r\n    }\r\n    Integer index = (Integer)m_Hashtable.get(value);\r\n    if (index != null) {\r\n      return index.intValue();\r\n    } else {\r\n      int intIndex = m_Values.size();\r\n      m_Values.addElement(value);\r\n      m_Hashtable.put(value, new Integer(intIndex));\r\n      return intIndex;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds an attribute value. Creates a fresh list of attribute\r\n   * values before adding it.\r\n   *\r\n   * @param value the attribute value\r\n   */\r\n  final void addValue(String value) {\r\n\r\n    m_Values = (FastVector)m_Values.copy();\r\n    m_Hashtable = (Hashtable)m_Hashtable.clone();\r\n    forceAddValue(value);\r\n  }\r\n\r\n  /**\r\n   * Produces a shallow copy of this attribute with a new name.\r\n   *\r\n   * @param newName the name of the new attribute\r\n   * @return a copy of this attribute with the same index\r\n   */\r\n  //@ requires newName != null;\r\n  //@ ensures \\result.m_Name  == newName;\r\n  //@ ensures \\result.m_Index == m_Index;\r\n  //@ ensures \\result.m_Type  == m_Type;\r\n  public final /*@ pure non_null @*/ AttributeWeka copy(String newName) {\r\n\r\n    AttributeWeka copy = new AttributeWeka(newName);\r\n\r\n    copy.m_Index = m_Index;\r\n    copy.m_DateFormat = m_DateFormat;\r\n    copy.m_Type = m_Type;\r\n    copy.m_Values = m_Values;\r\n    copy.m_Hashtable = m_Hashtable;\r\n    copy.m_Header = m_Header;\r\n    copy.setMetadata(m_Metadata);\r\n\r\n    return copy;\r\n  }\r\n\r\n  /**\r\n   * Removes a value of a nominal, string, or relation-valued\r\n   * attribute. Creates a fresh list of attribute values before\r\n   * removing it.\r\n   *\r\n   * @param index the value's index\r\n   * @throws IllegalArgumentException if the attribute is not\r\n   * of the correct type\r\n   */\r\n  //@ requires isNominal() || isString() || isRelationValued();\r\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Values.size();\r\n  final void delete(int index) {\r\n\r\n    if (!isNominal() \u0026\u0026 !isString() \u0026\u0026 !isRelationValued())\r\n      throw new IllegalArgumentException(\"Can only remove value of \" +\r\n                                         \"nominal, string or relation-\" +\r\n                                         \" valued attribute!\");\r\n    else {\r\n      m_Values = (FastVector)m_Values.copy();\r\n      m_Values.removeElementAt(index);\r\n      if (!isRelationValued()) {\r\n        Hashtable hash = new Hashtable(m_Hashtable.size());\r\n        Enumeration enu = m_Hashtable.keys();\r\n        while (enu.hasMoreElements()) {\r\n          Object string = enu.nextElement();\r\n          Integer valIndexObject = (Integer)m_Hashtable.get(string);\r\n          int valIndex = valIndexObject.intValue();\r\n          if (valIndex \u003e index) {\r\n            hash.put(string, new Integer(valIndex - 1));\r\n          } else if (valIndex \u003c index) {\r\n            hash.put(string, valIndexObject);\r\n          }\r\n        }\r\n        m_Hashtable = hash;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds an attribute value.\r\n   *\r\n   * @param value the attribute value\r\n   */\r\n  //@ requires value != null;\r\n  //@ ensures  m_Values.size() == \\old(m_Values.size()) + 1;\r\n  final void forceAddValue(String value) {\r\n\r\n    Object store = value;\r\n    if (value.length() \u003e STRING_COMPRESS_THRESHOLD) {\r\n      try {\r\n        store = new SerializedObject(value, true);\r\n      } catch (Exception ex) {\r\n        System.err.println(\"Couldn't compress string attribute value -\"\r\n                           + \" storing uncompressed.\");\r\n      }\r\n    }\r\n    m_Values.addElement(store);\r\n    m_Hashtable.put(store, new Integer(m_Values.size() - 1));\r\n  }\r\n\r\n  /**\r\n   * Sets the index of this attribute.\r\n   *\r\n   * @param index the index of this attribute\r\n   */\r\n  //@ requires 0 \u003c= index;\r\n  //@ assignable m_Index;\r\n  //@ ensures m_Index == index;\r\n  final void setIndex(int index) {\r\n\r\n    m_Index = index;\r\n  }\r\n\r\n  /**\r\n   * Sets a value of a nominal attribute or string attribute.\r\n   * Creates a fresh list of attribute values before it is set.\r\n   *\r\n   * @param index the value's index\r\n   * @param string the value\r\n   * @throws IllegalArgumentException if the attribute is not nominal or\r\n   * string.\r\n   */\r\n  //@ requires string != null;\r\n  //@ requires isNominal() || isString();\r\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Values.size();\r\n  final void setValue(int index, String string) {\r\n\r\n    switch (m_Type) {\r\n    case NOMINAL:\r\n    case STRING:\r\n      m_Values = (FastVector)m_Values.copy();\r\n      m_Hashtable = (Hashtable)m_Hashtable.clone();\r\n      Object store = string;\r\n      if (string.length() \u003e STRING_COMPRESS_THRESHOLD) {\r\n        try {\r\n          store = new SerializedObject(string, true);\r\n        } catch (Exception ex) {\r\n          System.err.println(\"Couldn't compress string attribute value -\"\r\n                             + \" storing uncompressed.\");\r\n        }\r\n      }\r\n      m_Hashtable.remove(m_Values.elementAt(index));\r\n      m_Values.setElementAt(store, index);\r\n      m_Hashtable.put(store, new Integer(index));\r\n      break;\r\n    default:\r\n      throw new IllegalArgumentException(\"Can only set values for nominal\"\r\n                                         + \" or string attributes!\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets a value of a relation-valued attribute.\r\n   * Creates a fresh list of attribute values before it is set.\r\n   *\r\n   * @param index the value's index\r\n   * @param data the value\r\n   * @throws IllegalArgumentException if the attribute is not\r\n   * relation-valued.\r\n   */\r\n  final void setValue(int index, Instances data) {\r\n\r\n    if (isRelationValued()) {\r\n      if (!data.equalHeaders(m_Header)) {\r\n        throw new IllegalArgumentException(\"Can't set relational value. \" +\r\n                                           \"Headers not compatible.\");\r\n      }\r\n      m_Values = (FastVector)m_Values.copy();\r\n      m_Values.setElementAt(data, index);\r\n    } else {\r\n      throw new IllegalArgumentException(\"Can only set value for\"\r\n                                         + \" relation-valued attributes!\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the given amount of milliseconds formatted according to the\r\n   * current Date format.\r\n   *\r\n   * @param date \tthe date, represented in milliseconds since\r\n   * \t\t\tJanuary 1, 1970, 00:00:00 GMT, to return as string\r\n   * @return \t\tthe formatted date\r\n   */\r\n  //@ requires isDate();\r\n  public /*@pure@*/ String formatDate(double date) {\r\n    switch (m_Type) {\r\n    case DATE:\r\n      return m_DateFormat.format(new Date((long)date));\r\n    default:\r\n      throw new IllegalArgumentException(\"Can only format date values for date\"\r\n                                         + \" attributes!\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parses the given String as Date, according to the current format and\r\n   * returns the corresponding amount of milliseconds.\r\n   *\r\n   * @param string the date to parse\r\n   * @return the date in milliseconds since January 1, 1970, 00:00:00 GMT\r\n   * @throws ParseException if parsing fails\r\n   */\r\n  //@ requires isDate();\r\n  //@ requires string != null;\r\n  public double parseDate(String string) throws ParseException {\r\n    switch (m_Type) {\r\n    case DATE:\r\n      long time = m_DateFormat.parse(string).getTime();\r\n      // TODO put in a safety check here if we can't store the value in a double.\r\n      return (double)time;\r\n    default:\r\n      throw new IllegalArgumentException(\"Can only parse date values for date\"\r\n                                         + \" attributes!\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the properties supplied for this attribute.\r\n   *\r\n   * @return metadata for this attribute\r\n   */\r\n  public final /*@ pure @*/ ProtectedProperties getMetadata() {\r\n\r\n    return m_Metadata;\r\n  }\r\n\r\n  /**\r\n   * Returns the ordering of the attribute. One of the following:\r\n   *\r\n   * ORDERING_SYMBOLIC - attribute values should be treated as symbols.\r\n   * ORDERING_ORDERED  - attribute values have a global ordering.\r\n   * ORDERING_MODULO   - attribute values have an ordering which wraps.\r\n   *\r\n   * @return the ordering type of the attribute\r\n   */\r\n  public final /*@ pure @*/ int ordering() {\r\n\r\n    return m_Ordering;\r\n  }\r\n\r\n  /**\r\n   * Returns whether the attribute values are equally spaced.\r\n   *\r\n   * @return whether the attribute is regular or not\r\n   */\r\n  public final /*@ pure @*/ boolean isRegular() {\r\n\r\n    return m_IsRegular;\r\n  }\r\n\r\n  /**\r\n   * Returns whether the attribute can be averaged meaningfully.\r\n   *\r\n   * @return whether the attribute can be averaged or not\r\n   */\r\n  public final /*@ pure @*/ boolean isAveragable() {\r\n\r\n    return m_IsAveragable;\r\n  }\r\n\r\n  /**\r\n   * Returns whether the attribute has a zeropoint and may be\r\n   * added meaningfully.\r\n   *\r\n   * @return whether the attribute has a zeropoint or not\r\n   */\r\n  public final /*@ pure @*/ boolean hasZeropoint() {\r\n\r\n    return m_HasZeropoint;\r\n  }\r\n\r\n  /**\r\n   * Returns the attribute's weight.\r\n   *\r\n   * @return the attribute's weight as a double\r\n   */\r\n  public final /*@ pure @*/ double weight() {\r\n\r\n    return m_Weight;\r\n  }\r\n\r\n  /**\r\n   * Sets the new attribute's weight\r\n   *\r\n   * @param value\tthe new weight\r\n   */\r\n  public void setWeight(double value) {\r\n    Properties\tprops;\r\n    Enumeration names;\r\n    String\tname;\r\n\r\n    m_Weight = value;\r\n\r\n    // generate new metadata object\r\n    props = new Properties();\r\n    names = m_Metadata.propertyNames();\r\n    while (names.hasMoreElements()) {\r\n      name = (String) names.nextElement();\r\n      if (!name.equals(\"weight\"))\r\n\tprops.setProperty(name, m_Metadata.getProperty(name));\r\n    }\r\n    props.setProperty(\"weight\", \"\" + m_Weight);\r\n    m_Metadata = new ProtectedProperties(props);\r\n  }\r\n\r\n  /**\r\n   * Returns the lower bound of a numeric attribute.\r\n   *\r\n   * @return the lower bound of the specified numeric range\r\n   */\r\n  public final /*@ pure @*/ double getLowerNumericBound() {\r\n\r\n    return m_LowerBound;\r\n  }\r\n\r\n  /**\r\n   * Returns whether the lower numeric bound of the attribute is open.\r\n   *\r\n   * @return whether the lower numeric bound is open or not (closed)\r\n   */\r\n  public final /*@ pure @*/ boolean lowerNumericBoundIsOpen() {\r\n\r\n    return m_LowerBoundIsOpen;\r\n  }\r\n\r\n  /**\r\n   * Returns the upper bound of a numeric attribute.\r\n   *\r\n   * @return the upper bound of the specified numeric range\r\n   */\r\n  public final /*@ pure @*/ double getUpperNumericBound() {\r\n\r\n    return m_UpperBound;\r\n  }\r\n\r\n  /**\r\n   * Returns whether the upper numeric bound of the attribute is open.\r\n   *\r\n   * @return whether the upper numeric bound is open or not (closed)\r\n   */\r\n  public final /*@ pure @*/ boolean upperNumericBoundIsOpen() {\r\n\r\n    return m_UpperBoundIsOpen;\r\n  }\r\n\r\n  /**\r\n   * Determines whether a value lies within the bounds of the attribute.\r\n   *\r\n   * @param value the value to check\r\n   * @return whether the value is in range\r\n   */\r\n  public final /*@ pure @*/ boolean isInRange(double value) {\r\n\r\n    // dates and missing values are a special case\r\n    if (m_Type == DATE || value == Instance.missingValue()) return true;\r\n    if (m_Type != NUMERIC) {\r\n      // do label range check\r\n      int intVal = (int) value;\r\n      if (intVal \u003c 0 || intVal \u003e= m_Hashtable.size()) return false;\r\n    } else {\r\n      // do numeric bounds check\r\n      if (m_LowerBoundIsOpen) {\r\n\tif (value \u003c= m_LowerBound) return false;\r\n      } else {\r\n\tif (value \u003c m_LowerBound) return false;\r\n      }\r\n      if (m_UpperBoundIsOpen) {\r\n\tif (value \u003e= m_UpperBound) return false;\r\n      } else {\r\n\tif (value \u003e m_UpperBound) return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Sets the metadata for the attribute. Processes the strings stored in the\r\n   * metadata of the attribute so that the properties can be set up for the\r\n   * easy-access metadata methods. Any strings sought that are omitted will\r\n   * cause default values to be set.\r\n   *\r\n   * The following properties are recognised:\r\n   * ordering, averageable, zeropoint, regular, weight, and range.\r\n   *\r\n   * All other properties can be queried and handled appropriately by classes\r\n   * calling the getMetadata() method.\r\n   *\r\n   * @param metadata the metadata\r\n   * @throws IllegalArgumentException if the properties are not consistent\r\n   */\r\n  //@ requires metadata != null;\r\n  private void setMetadata(ProtectedProperties metadata) {\r\n\r\n    m_Metadata = metadata;\r\n\r\n    if (m_Type == DATE) {\r\n      m_Ordering = ORDERING_ORDERED;\r\n      m_IsRegular = true;\r\n      m_IsAveragable = false;\r\n      m_HasZeropoint = false;\r\n    } else {\r\n\r\n      // get ordering\r\n      String orderString = m_Metadata.getProperty(\"ordering\",\"\");\r\n\r\n      // numeric ordered attributes are averagable and zeropoint by default\r\n      String def;\r\n      if (m_Type == NUMERIC\r\n\t  \u0026\u0026 orderString.compareTo(\"modulo\") != 0\r\n\t  \u0026\u0026 orderString.compareTo(\"symbolic\") != 0)\r\n\tdef = \"true\";\r\n      else def = \"false\";\r\n\r\n      // determine boolean states\r\n      m_IsAveragable =\r\n\t(m_Metadata.getProperty(\"averageable\",def).compareTo(\"true\") == 0);\r\n      m_HasZeropoint =\r\n\t(m_Metadata.getProperty(\"zeropoint\",def).compareTo(\"true\") == 0);\r\n      // averagable or zeropoint implies regular\r\n      if (m_IsAveragable || m_HasZeropoint) def = \"true\";\r\n      m_IsRegular =\r\n\t(m_Metadata.getProperty(\"regular\",def).compareTo(\"true\") == 0);\r\n\r\n      // determine ordering\r\n      if (orderString.compareTo(\"symbolic\") == 0)\r\n\tm_Ordering = ORDERING_SYMBOLIC;\r\n      else if (orderString.compareTo(\"ordered\") == 0)\r\n\tm_Ordering = ORDERING_ORDERED;\r\n      else if (orderString.compareTo(\"modulo\") == 0)\r\n\tm_Ordering = ORDERING_MODULO;\r\n      else {\r\n\tif (m_Type == NUMERIC || m_IsAveragable || m_HasZeropoint)\r\n\t  m_Ordering = ORDERING_ORDERED;\r\n\telse m_Ordering = ORDERING_SYMBOLIC;\r\n      }\r\n    }\r\n\r\n    // consistency checks\r\n    if (m_IsAveragable \u0026\u0026 !m_IsRegular)\r\n      throw new IllegalArgumentException(\"An averagable attribute must be\"\r\n\t\t\t\t\t + \" regular\");\r\n    if (m_HasZeropoint \u0026\u0026 !m_IsRegular)\r\n      throw new IllegalArgumentException(\"A zeropoint attribute must be\"\r\n\t\t\t\t\t + \" regular\");\r\n    if (m_IsRegular \u0026\u0026 m_Ordering == ORDERING_SYMBOLIC)\r\n      throw new IllegalArgumentException(\"A symbolic attribute cannot be\"\r\n\t\t\t\t\t + \" regular\");\r\n    if (m_IsAveragable \u0026\u0026 m_Ordering != ORDERING_ORDERED)\r\n      throw new IllegalArgumentException(\"An averagable attribute must be\"\r\n\t\t\t\t\t + \" ordered\");\r\n    if (m_HasZeropoint \u0026\u0026 m_Ordering != ORDERING_ORDERED)\r\n      throw new IllegalArgumentException(\"A zeropoint attribute must be\"\r\n\t\t\t\t\t + \" ordered\");\r\n\r\n    // determine weight\r\n    m_Weight = 1.0;\r\n    String weightString = m_Metadata.getProperty(\"weight\");\r\n    if (weightString != null) {\r\n      try{\r\n\tm_Weight = Double.valueOf(weightString).doubleValue();\r\n      } catch (NumberFormatException e) {\r\n\t// Check if value is really a number\r\n\tthrow new IllegalArgumentException(\"Not a valid attribute weight: '\"\r\n\t\t\t\t\t   + weightString + \"'\");\r\n      }\r\n    }\r\n\r\n    // determine numeric range\r\n    if (m_Type == NUMERIC) setNumericRange(m_Metadata.getProperty(\"range\"));\r\n  }\r\n\r\n  /**\r\n   * Sets the numeric range based on a string. If the string is null the range\r\n   * will default to [-inf,+inf]. A square brace represents a closed interval, a\r\n   * curved brace represents an open interval, and 'inf' represents infinity.\r\n   * Examples of valid range strings: \"[-inf,20)\",\"(-13.5,-5.2)\",\"(5,inf]\"\r\n   *\r\n   * @param rangeString the string to parse as the attribute's numeric range\r\n   * @throws IllegalArgumentException if the range is not valid\r\n   */\r\n  //@ requires rangeString != null;\r\n  public void setNumericRange(String rangeString)\r\n  {\r\n    // set defaults\r\n    m_LowerBound = Double.NEGATIVE_INFINITY;\r\n    m_LowerBoundIsOpen = false;\r\n    m_UpperBound = Double.POSITIVE_INFINITY;\r\n    m_UpperBoundIsOpen = false;\r\n\r\n    if (rangeString == null) return;\r\n\r\n    // set up a tokenzier to parse the string\r\n    StreamTokenizer tokenizer =\r\n      new StreamTokenizer(new StringReader(rangeString));\r\n    tokenizer.resetSyntax();\r\n    tokenizer.whitespaceChars(0, ' ');\r\n    tokenizer.wordChars(' '+1,'\\u00FF');\r\n    tokenizer.ordinaryChar('[');\r\n    tokenizer.ordinaryChar('(');\r\n    tokenizer.ordinaryChar(',');\r\n    tokenizer.ordinaryChar(']');\r\n    tokenizer.ordinaryChar(')');\r\n\r\n    try {\r\n\r\n      // get opening brace\r\n      tokenizer.nextToken();\r\n\r\n      if (tokenizer.ttype == '[') m_LowerBoundIsOpen = false;\r\n      else if (tokenizer.ttype == '(') m_LowerBoundIsOpen = true;\r\n      else throw new IllegalArgumentException(\"Expected opening brace on range,\"\r\n\t\t\t\t\t      + \" found: \"\r\n\t\t\t\t\t      + tokenizer.toString());\r\n\r\n      // get lower bound\r\n      tokenizer.nextToken();\r\n      if (tokenizer.ttype != tokenizer.TT_WORD)\r\n\tthrow new IllegalArgumentException(\"Expected lower bound in range,\"\r\n\t\t\t\t\t   + \" found: \"\r\n\t\t\t\t\t   + tokenizer.toString());\r\n      if (tokenizer.sval.compareToIgnoreCase(\"-inf\") == 0)\r\n\tm_LowerBound = Double.NEGATIVE_INFINITY;\r\n      else if (tokenizer.sval.compareToIgnoreCase(\"+inf\") == 0)\r\n\tm_LowerBound = Double.POSITIVE_INFINITY;\r\n      else if (tokenizer.sval.compareToIgnoreCase(\"inf\") == 0)\r\n\tm_LowerBound = Double.NEGATIVE_INFINITY;\r\n      else try {\r\n\tm_LowerBound = Double.valueOf(tokenizer.sval).doubleValue();\r\n      } catch (NumberFormatException e) {\r\n\tthrow new IllegalArgumentException(\"Expected lower bound in range,\"\r\n\t\t\t\t\t   + \" found: '\" + tokenizer.sval + \"'\");\r\n      }\r\n\r\n      // get separating comma\r\n      if (tokenizer.nextToken() != ',')\r\n\tthrow new IllegalArgumentException(\"Expected comma in range,\"\r\n\t\t\t\t\t   + \" found: \"\r\n\t\t\t\t\t   + tokenizer.toString());\r\n\r\n      // get upper bound\r\n      tokenizer.nextToken();\r\n      if (tokenizer.ttype != tokenizer.TT_WORD)\r\n\tthrow new IllegalArgumentException(\"Expected upper bound in range,\"\r\n\t\t\t\t\t   + \" found: \"\r\n\t\t\t\t\t   + tokenizer.toString());\r\n      if (tokenizer.sval.compareToIgnoreCase(\"-inf\") == 0)\r\n\tm_UpperBound = Double.NEGATIVE_INFINITY;\r\n      else if (tokenizer.sval.compareToIgnoreCase(\"+inf\") == 0)\r\n\tm_UpperBound = Double.POSITIVE_INFINITY;\r\n      else if (tokenizer.sval.compareToIgnoreCase(\"inf\") == 0)\r\n\tm_UpperBound = Double.POSITIVE_INFINITY;\r\n      else try {\r\n\tm_UpperBound = Double.valueOf(tokenizer.sval).doubleValue();\r\n      } catch (NumberFormatException e) {\r\n\tthrow new IllegalArgumentException(\"Expected upper bound in range,\"\r\n\t\t\t\t\t   + \" found: '\" + tokenizer.sval + \"'\");\r\n      }\r\n\r\n      // get closing brace\r\n      tokenizer.nextToken();\r\n\r\n      if (tokenizer.ttype == ']') m_UpperBoundIsOpen = false;\r\n      else if (tokenizer.ttype == ')') m_UpperBoundIsOpen = true;\r\n      else throw new IllegalArgumentException(\"Expected closing brace on range,\"\r\n\t\t\t\t\t      + \" found: \"\r\n\t\t\t\t\t      + tokenizer.toString());\r\n\r\n      // check for rubbish on end\r\n      if (tokenizer.nextToken() != tokenizer.TT_EOF)\r\n\tthrow new IllegalArgumentException(\"Expected end of range string,\"\r\n\t\t\t\t\t   + \" found: \"\r\n\t\t\t\t\t   + tokenizer.toString());\r\n\r\n    } catch (IOException e) {\r\n      throw new IllegalArgumentException(\"IOException reading attribute range\"\r\n\t\t\t\t\t + \" string: \" + e.getMessage());\r\n    }\r\n\r\n    if (m_UpperBound \u003c m_LowerBound)\r\n      throw new IllegalArgumentException(\"Upper bound (\" + m_UpperBound\r\n\t\t\t\t\t + \") on numeric range is\"\r\n\t\t\t\t\t + \" less than lower bound (\"\r\n\t\t\t\t\t + m_LowerBound + \")!\");\r\n  }\r\n}\r\n\r\n",
        "name": "AttributeWeka.java",
        "path": "src/keel/Algorithms/Fuzzy_Rule_Learning/Hybrid/FURIA/core/AttributeWeka.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/Fuzzy_Rule_Learning/Hybrid/FURIA/core/AttributeWeka.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 240,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 253,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 254,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires metadata != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 274,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 275,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires dateFormat != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 291,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 292,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires dateFormat != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 293,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires metadata != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 322,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 341,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 342,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires metadata != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 514,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 552,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e (m_Type == NOMINAL);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 563,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e ((m_Type == NUMERIC) || (m_Type == DATE));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 574,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e (m_Type == RELATIONAL);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 585,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e (m_Type == STRING);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 596,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e (m_Type == DATE);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 607,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Name;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 681,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Type;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 761,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 762,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 780,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 781,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 802,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 803,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 820,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 821,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 947,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires newName != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 948,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result.m_Name  == newName;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 949,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result.m_Index == m_Index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 950,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result.m_Type  == m_Type;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 975,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires isNominal() || isString() || isRelationValued();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 976,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Values.size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1009,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires value != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1031,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1033,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Index == index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1048,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires string != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1049,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires isNominal() || isString();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1050,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Values.size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1109,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires isDate();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1128,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires isDate();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1129,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires string != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1316,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires metadata != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1406,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires rangeString != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 241,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 255,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 276,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 294,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 323,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 763,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 764,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Index == index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 782,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 783,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Index == index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 804,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 805,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Index == index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 822,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 823,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Index == index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1010,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Values.size() == \\old(m_Values.size()) + 1;\r"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "/***********************************************************************\r\n\r\n\tThis file is part of KEEL-software, the Data Mining tool for regression, \r\n\tclassification, clustering, pattern mining and so on.\r\n\r\n\tCopyright (C) 2004-2010\r\n\t\r\n\tF. Herrera (herrera@decsai.ugr.es)\r\n    L. Sánchez (luciano@uniovi.es)\r\n    J. Alcalá-Fdez (jalcala@decsai.ugr.es)\r\n    S. García (sglopez@ujaen.es)\r\n    A. Fernández (alberto.fernandez@ujaen.es)\r\n    J. Luengo (julianlm@decsai.ugr.es)\r\n\r\n\tThis program is free software: you can redistribute it and/or modify\r\n\tit under the terms of the GNU General Public License as published by\r\n\tthe Free Software Foundation, either version 3 of the License, or\r\n\t(at your option) any later version.\r\n\r\n\tThis program is distributed in the hope that it will be useful,\r\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\tGNU General Public License for more details.\r\n\r\n\tYou should have received a copy of the GNU General Public License\r\n\talong with this program.  If not, see http://www.gnu.org/licenses/\r\n  \r\n**********************************************************************/\r\n\r\n/*\r\n *    This program is free software; you can redistribute it and/or modify\r\n *    it under the terms of the GNU General Public License as published by\r\n *    the Free Software Foundation; either version 2 of the License, or\r\n *    (at your option) any later version.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU General Public License\r\n *    along with this program; if not, write to the Free Software\r\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\r\n */\r\n\r\n/*\r\n *    OptionHandler.java\r\n *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand\r\n *\r\n */\r\n\r\npackage keel.Algorithms.Statistical_Classifiers.Logistic.core;\r\n\r\nimport java.util.*;\r\n\r\n/** \r\n * Interface to something that understands options.\r\n *\r\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\r\n * @author Len Trigg (trigg@cs.waikato.ac.nz)\r\n * @version $Revision: 1.1 $\r\n */\r\npublic interface OptionHandler {\r\n\r\n  /**\r\n   * Returns an enumeration of all the available options..\r\n   *\r\n   * @return an enumeration of all available options.\r\n   */\r\n  Enumeration listOptions();\r\n\r\n  /**\r\n   * Sets the OptionHandler's options using the given list. All options\r\n   * will be set (or reset) during this call (i.e. incremental setting\r\n   * of options is not possible).\r\n   *\r\n   * @param options the list of options as an array of strings\r\n   * @exception Exception if an option is not supported\r\n   */\r\n  //@ requires options != null;\r\n  //@ requires \\nonnullelements(options);\r\n  void setOptions(String[] options) throws Exception;\r\n\r\n  /**\r\n   * Gets the current option settings for the OptionHandler.\r\n   *\r\n   * @return the list of current option settings as an array of strings\r\n   */\r\n  //@ ensures \\result != null;\r\n  //@ ensures \\nonnullelements(\\result);\r\n  /*@pure@*/ String[] getOptions();\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
        "name": "OptionHandler.java",
        "path": "src/keel/Algorithms/Statistical_Classifiers/Logistic/core/OptionHandler.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/Statistical_Classifiers/Logistic/core/OptionHandler.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 79,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires options != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 80,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires \\nonnullelements(options);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 88,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 89,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\nonnullelements(\\result);\r"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "package keel.Algorithms.ImbalancedClassification.Resampling.SMOTE_RSB.Rough_Sets;\r\n\r\n\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.lang.reflect.Array;\r\nimport java.util.Properties;\r\nimport java.util.Random;\r\n\r\n/**\r\n * Class implementing some simple utility methods.\r\n *\r\n * @author Eibe Frank \r\n * @author Yong Wang \r\n * @author Len Trigg \r\n * @author Julien Prados\r\n * @version $Revision: 1.1 $\r\n */\r\npublic final class Utils {\r\n\r\n  /** The natural logarithm of 2. */\r\n  public static double log2 = Math.log(2);\r\n\r\n  /** The small deviation allowed in double comparisons */\r\n  public static double SMALL = 1e-6;\r\n\r\n  \r\n  /**\r\n   * Reads properties that inherit from three locations. Properties\r\n   * are first defined in the system resource location (i.e. in the\r\n   * CLASSPATH).  These default properties must exist. Properties\r\n   * defined in the users home directory (optional) override default\r\n   * settings. Properties defined in the current directory (optional)\r\n   * override all these settings.\r\n   *\r\n   * @param resourceName the location of the resource that should be\r\n   * loaded.  e.g.: \"weka/core/Utils.props\". (The use of hardcoded\r\n   * forward slashes here is OK - see\r\n   * jdk1.1/docs/guide/misc/resources.html) This routine will also\r\n   * look for the file (in this case) \"Utils.props\" in the users home\r\n   * directory and the current directory.\r\n   * @return the Properties\r\n   * @exception Exception if no default properties are defined, or if\r\n   * an error occurs reading the properties files.  \r\n   */\r\n  public static Properties readProperties(String resourceName)\r\n    throws Exception {\r\n\r\n    Properties defaultProps = new Properties();\r\n    try {\r\n      // Apparently hardcoded slashes are OK here\r\n      // jdk1.1/docs/guide/misc/resources.html\r\n      defaultProps.load(ClassLoader.getSystemResourceAsStream(resourceName));\r\n    } catch (Exception ex) {\r\n/*      throw new Exception(\"Problem reading default properties: \"\r\n\t+ ex.getMessage()); */\r\n      System.err.println(\"Warning, unable to load properties file from \"\r\n\t\t\t +\"system resource (Utils.java)\");\r\n    }\r\n\r\n    // Hardcoded slash is OK here\r\n    // eg: see jdk1.1/docs/guide/misc/resources.html\r\n    int slInd = resourceName.lastIndexOf('/');\r\n    if (slInd != -1) {\r\n      resourceName = resourceName.substring(slInd + 1);\r\n    }\r\n\r\n    // Allow a properties file in the home directory to override\r\n    Properties userProps = new Properties(defaultProps);    \r\n    File propFile = new File(System.getProperties().getProperty(\"user.home\")\r\n                             + File.separatorChar\r\n                             + resourceName);\r\n    if (propFile.exists()) {\r\n      try {\r\n        userProps.load(new FileInputStream(propFile));\r\n      } catch (Exception ex) {\r\n        throw new Exception(\"Problem reading user properties: \" + propFile);\r\n      }\r\n    }\r\n\r\n    // Allow a properties file in the current directory to override\r\n    Properties localProps = new Properties(userProps);\r\n    propFile = new File(resourceName);\r\n    if (propFile.exists()) {\r\n      try {\r\n        localProps.load(new FileInputStream(propFile));\r\n      } catch (Exception ex) {\r\n        throw new Exception(\"Problem reading local properties: \" + propFile);\r\n      }\r\n    }\r\n    \r\n    return localProps;\r\n  }\r\n\r\n  /**\r\n   * Returns the correlation coefficient of two double vectors.\r\n   *\r\n   * @param y1 double vector 1\r\n   * @param y2 double vector 2\r\n   * @param n the length of two double vectors\r\n   * @return the correlation coefficient\r\n   */\r\n  public static final double correlation(double y1[],double y2[],int n) {\r\n\r\n    int i;\r\n    double av1 = 0.0, av2 = 0.0, y11 = 0.0, y22 = 0.0, y12 = 0.0, c;\r\n    \r\n    if (n \u003c= 1) {\r\n      return 1.0;\r\n    }\r\n    for (i = 0; i \u003c n; i++) {\r\n      av1 += y1[i];\r\n      av2 += y2[i];\r\n    }\r\n    av1 /= (double) n;\r\n    av2 /= (double) n;\r\n    for (i = 0; i \u003c n; i++) {\r\n      y11 += (y1[i] - av1) * (y1[i] - av1);\r\n      y22 += (y2[i] - av2) * (y2[i] - av2);\r\n      y12 += (y1[i] - av1) * (y2[i] - av2);\r\n    }\r\n    if (y11 * y22 == 0.0) {\r\n      c=1.0;\r\n    } else {\r\n      c = y12 / Math.sqrt(Math.abs(y11 * y22));\r\n    }\r\n    \r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * Removes all occurrences of a string from another string.\r\n   *\r\n   * @param inString the string to remove substrings from.\r\n   * @param substring the substring to remove.\r\n   * @return the input string with occurrences of substring removed.\r\n   */\r\n  public static String removeSubstring(String inString, String substring) {\r\n\r\n    StringBuffer result = new StringBuffer();\r\n    int oldLoc = 0, loc = 0;\r\n    while ((loc = inString.indexOf(substring, oldLoc))!= -1) {\r\n      result.append(inString.substring(oldLoc, loc));\r\n      oldLoc = loc + substring.length();\r\n    }\r\n    result.append(inString.substring(oldLoc));\r\n    return result.toString();\r\n  }\r\n\r\n  /**\r\n   * Replaces with a new string, all occurrences of a string from \r\n   * another string.\r\n   *\r\n   * @param inString the string to replace substrings in.\r\n   * @param subString the substring to replace.\r\n   * @param replaceString the replacement substring\r\n   * @return the input string with occurrences of substring replaced.\r\n   */\r\n  public static String replaceSubstring(String inString, String subString,\r\n\t\t\t\t\tString replaceString) {\r\n\r\n    StringBuffer result = new StringBuffer();\r\n    int oldLoc = 0, loc = 0;\r\n    while ((loc = inString.indexOf(subString, oldLoc))!= -1) {\r\n      result.append(inString.substring(oldLoc, loc));\r\n      result.append(replaceString);\r\n      oldLoc = loc + subString.length();\r\n    }\r\n    result.append(inString.substring(oldLoc));\r\n    return result.toString();\r\n  }\r\n\r\n\r\n  /**\r\n   * Pads a string to a specified length, inserting spaces on the left\r\n   * as required. If the string is too long, characters are removed (from\r\n   * the right).\r\n   *\r\n   * @param inString the input string\r\n   * @param length the desired length of the output string\r\n   * @return the output string\r\n   */\r\n  public static String padLeft(String inString, int length) {\r\n\r\n    return fixStringLength(inString, length, false);\r\n  }\r\n  \r\n  /**\r\n   * Pads a string to a specified length, inserting spaces on the right\r\n   * as required. If the string is too long, characters are removed (from\r\n   * the right).\r\n   *\r\n   * @param inString the input string\r\n   * @param length the desired length of the output string\r\n   * @return the output string\r\n   */\r\n  public static String padRight(String inString, int length) {\r\n\r\n    return fixStringLength(inString, length, true);\r\n  }\r\n  \r\n  /**\r\n   * Pads a string to a specified length, inserting spaces as\r\n   * required. If the string is too long, characters are removed (from\r\n   * the right).\r\n   *\r\n   * @param inString the input string\r\n   * @param length the desired length of the output string\r\n   * @param right true if inserted spaces should be added to the right\r\n   * @return the output string\r\n   */\r\n  private static /*@pure@*/ String fixStringLength(String inString, int length,\r\n\t\t\t\t\tboolean right) {\r\n\r\n    if (inString.length() \u003c length) {\r\n      while (inString.length() \u003c length) {\r\n\tinString = (right ? inString.concat(\" \") : \" \".concat(inString));\r\n      }\r\n    } else if (inString.length() \u003e length) {\r\n      inString = inString.substring(0, length);\r\n    }\r\n    return inString;\r\n  }\r\n \r\n  /**\r\n   * Rounds a double and converts it into String.\r\n   *\r\n   * @param value the double value\r\n   * @param afterDecimalPoint the (maximum) number of digits permitted\r\n   * after the decimal point\r\n   * @return the double as a formatted string\r\n   */\r\n  public static /*@pure@*/ String doubleToString(double value, int afterDecimalPoint) {\r\n    \r\n    StringBuffer stringBuffer;\r\n    double temp;\r\n    int i,dotPosition;\r\n    long precisionValue;\r\n    \r\n    temp = value * Math.pow(10.0, afterDecimalPoint);\r\n    if (Math.abs(temp) \u003c Long.MAX_VALUE) {\r\n      precisionValue = \t(temp \u003e 0) ? (long)(temp + 0.5) \r\n                                   : -(long)(Math.abs(temp) + 0.5);\r\n      if (precisionValue == 0) {\r\n\tstringBuffer = new StringBuffer(String.valueOf(0));\r\n      } else {\r\n\tstringBuffer = new StringBuffer(String.valueOf(precisionValue));\r\n      }\r\n      if (afterDecimalPoint == 0) {\r\n\treturn stringBuffer.toString();\r\n      }\r\n      dotPosition = stringBuffer.length() - afterDecimalPoint;\r\n      while (((precisionValue \u003c 0) \u0026\u0026 (dotPosition \u003c 1)) ||\r\n\t     (dotPosition \u003c 0)) {\r\n\tif (precisionValue \u003c 0) {\r\n\t  stringBuffer.insert(1, '0');\r\n\t} else {\r\n\t  stringBuffer.insert(0, '0');\r\n\t}\r\n\tdotPosition++;\r\n      }\r\n      stringBuffer.insert(dotPosition, '.');\r\n      if ((precisionValue \u003c 0) \u0026\u0026 (stringBuffer.charAt(1) == '.')) {\r\n\tstringBuffer.insert(1, '0');\r\n      } else if (stringBuffer.charAt(0) == '.') {\r\n\tstringBuffer.insert(0, '0');\r\n      }\r\n      int currentPos = stringBuffer.length() - 1;\r\n      while ((currentPos \u003e dotPosition) \u0026\u0026\r\n\t     (stringBuffer.charAt(currentPos) == '0')) {\r\n\tstringBuffer.setCharAt(currentPos--, ' ');\r\n      }\r\n      if (stringBuffer.charAt(currentPos) == '.') {\r\n\tstringBuffer.setCharAt(currentPos, ' ');\r\n      }\r\n      \r\n      return stringBuffer.toString().trim();\r\n    }\r\n    return new String(\"\" + value);\r\n  }\r\n\r\n  /**\r\n   * Rounds a double and converts it into a formatted decimal-justified String.\r\n   * Trailing 0's are replaced with spaces.\r\n   *\r\n   * @param value the double value\r\n   * @param width the width of the string\r\n   * @param afterDecimalPoint the number of digits after the decimal point\r\n   * @return the double as a formatted string\r\n   */\r\n  public static /*@pure@*/ String doubleToString(double value, int width,\r\n\t\t\t\t      int afterDecimalPoint) {\r\n    \r\n    String tempString = doubleToString(value, afterDecimalPoint);\r\n    char[] result;\r\n    int dotPosition;\r\n\r\n    if ((afterDecimalPoint \u003e= width) \r\n        || (tempString.indexOf('E') != -1)) { // Protects sci notation\r\n      return tempString;\r\n    }\r\n\r\n    // Initialize result\r\n    result = new char[width];\r\n    for (int i = 0; i \u003c result.length; i++) {\r\n      result[i] = ' ';\r\n    }\r\n\r\n    if (afterDecimalPoint \u003e 0) {\r\n      // Get position of decimal point and insert decimal point\r\n      dotPosition = tempString.indexOf('.');\r\n      if (dotPosition == -1) {\r\n\tdotPosition = tempString.length();\r\n      } else {\r\n\tresult[width - afterDecimalPoint - 1] = '.';\r\n      }\r\n    } else {\r\n      dotPosition = tempString.length();\r\n    }\r\n    \r\n\r\n    int offset = width - afterDecimalPoint - dotPosition;\r\n    if (afterDecimalPoint \u003e 0) {\r\n      offset--;\r\n    }\r\n\r\n    // Not enough room to decimal align within the supplied width\r\n    if (offset \u003c 0) {\r\n      return tempString;\r\n    }\r\n\r\n    // Copy characters before decimal point\r\n    for (int i = 0; i \u003c dotPosition; i++) {\r\n      result[offset + i] = tempString.charAt(i);\r\n    }\r\n\r\n    // Copy characters after decimal point\r\n    for (int i = dotPosition + 1; i \u003c tempString.length(); i++) {\r\n      result[offset + i] = tempString.charAt(i);\r\n    }\r\n\r\n    return new String(result);\r\n  }\r\n\r\n  /**\r\n   * Returns the basic class of an array class (handles multi-dimensional\r\n   * arrays).\r\n   * @param c        the array to inspect\r\n   * @return         the class of the innermost elements\r\n   */\r\n  public static Class getArrayClass(Class c) {\r\n     if (c.getComponentType().isArray())\r\n        return getArrayClass(c.getComponentType());\r\n     else\r\n        return c.getComponentType();\r\n  }\r\n\r\n  /**\r\n   * Returns the dimensions of the given array. Even though the\r\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\r\n   * int[3] or double[2][4].\r\n   *\r\n   * @param array       the array to determine the dimensions for\r\n   * @return            the dimensions of the array\r\n   */\r\n  public static int getArrayDimensions(Class array) {\r\n    if (array.getComponentType().isArray())\r\n      return 1 + getArrayDimensions(array.getComponentType());\r\n    else\r\n      return 1;\r\n  }\r\n\r\n  /**\r\n   * Returns the dimensions of the given array. Even though the\r\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\r\n   * int[3] or double[2][4].\r\n   *\r\n   * @param array       the array to determine the dimensions for\r\n   * @return            the dimensions of the array\r\n   */\r\n  public static int getArrayDimensions(Object array) {\r\n    return getArrayDimensions(array.getClass());\r\n  }\r\n\r\n  /**\r\n   * Returns the given Array in a string representation. Even though the\r\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\r\n   * int[3] or double[2][4].\r\n   * \r\n   * @param array       the array to return in a string representation\r\n   * @return            the array as string\r\n   */\r\n  public static String arrayToString(Object array) {\r\n    String        result;\r\n    int           dimensions;\r\n    int           i;       \r\n\r\n    result     = \"\";\r\n    dimensions = getArrayDimensions(array);\r\n    \r\n    if (dimensions == 0) {\r\n      result = \"null\";\r\n    }\r\n    else if (dimensions == 1) {\r\n      for (i = 0; i \u003c Array.getLength(array); i++) {\r\n        if (i \u003e 0)\r\n          result += \",\";\r\n        if (Array.get(array, i) == null)\r\n          result += \"null\";\r\n        else\r\n          result += Array.get(array, i).toString();\r\n      }\r\n    }\r\n    else {\r\n      for (i = 0; i \u003c Array.getLength(array); i++) {\r\n        if (i \u003e 0)\r\n          result += \",\";\r\n        result += \"[\" + arrayToString(Array.get(array, i)) + \"]\";\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Tests if a is equal to b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n     * @return True if they are equals.\r\n   */\r\n  public static /*@pure@*/ boolean eq(double a, double b){\r\n    \r\n    return (a - b \u003c SMALL) \u0026\u0026 (b - a \u003c SMALL); \r\n  }\r\n\r\n  /**\r\n   * Checks if the given array contains any non-empty options.\r\n   *\r\n   * @param options an array of strings\r\n   * @exception Exception if there are any non-empty options\r\n   */\r\n  public static void checkForRemainingOptions(String [] options) \r\n    throws Exception {\r\n    \r\n    int illegalOptionsFound = 0;\r\n    StringBuffer text = new StringBuffer();\r\n\r\n    if (options == null) {\r\n      return;\r\n    }\r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if (options[i].length() \u003e 0) {\r\n\tillegalOptionsFound++;\r\n\ttext.append(options[i] + ' ');\r\n      }\r\n    }\r\n    if (illegalOptionsFound \u003e 0) {\r\n      throw new Exception(\"Illegal options: \" + text);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Checks if the given array contains the flag \"-Char\". Stops\r\n   * searching at the first marker \"--\". If the flag is found,\r\n   * it is replaced with the empty string.\r\n   *\r\n   * @param flag the character indicating the flag.\r\n   * @param options the array of strings containing all the options.\r\n   * @return true if the flag was found\r\n   * @exception Exception if an illegal option was found\r\n   */\r\n  public static boolean getFlag(char flag, String [] options) \r\n    throws Exception {\r\n       return getFlag(\"\" + flag, options);\r\n  }\r\n  \r\n  /**\r\n   * Checks if the given array contains the flag \"-String\". Stops\r\n   * searching at the first marker \"--\". If the flag is found,\r\n   * it is replaced with the empty string.\r\n   *\r\n   * @param flag the String indicating the flag.\r\n   * @param options the array of strings containing all the options.\r\n   * @return true if the flag was found\r\n   * @exception Exception if an illegal option was found\r\n   */\r\n  public static boolean getFlag(String flag, String [] options) \r\n    throws Exception {\r\n\r\n    if (options == null) {\r\n      return false;\r\n    }\r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if ((options[i].length() \u003e 1) \u0026\u0026 (options[i].charAt(0) == '-')) {\r\n\ttry {\r\n\t  Double dummy = Double.valueOf(options[i]);\r\n\t} catch (NumberFormatException e) {\r\n\t  if (options[i].equals(\"-\" + flag)) {\r\n\t    options[i] = \"\";\r\n\t    return true;\r\n\t  }\r\n\t  if (options[i].charAt(1) == '-') {\r\n\t    return false;\r\n\t  }\r\n\t}\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gets an option indicated by a flag \"-Char\" from the given array\r\n   * of strings. Stops searching at the first marker \"--\". Replaces \r\n   * flag and option with empty strings.\r\n   *\r\n   * @param flag the character indicating the option.\r\n   * @param options the array of strings containing all the options.\r\n   * @return the indicated option or an empty string\r\n   * @exception Exception if the option indicated by the flag can't be found\r\n   */\r\n  public static /*@non_null@*/ String getOption(char flag, String [] options) \r\n    throws Exception {\r\n     return getOption(\"\" + flag, options);\r\n  }\r\n\r\n  /**\r\n   * Gets an option indicated by a flag \"-String\" from the given array\r\n   * of strings. Stops searching at the first marker \"--\". Replaces \r\n   * flag and option with empty strings.\r\n   *\r\n   * @param flag the String indicating the option.\r\n   * @param options the array of strings containing all the options.\r\n   * @return the indicated option or an empty string\r\n   * @exception Exception if the option indicated by the flag can't be found\r\n   */\r\n  public static /*@non_null@*/ String getOption(String flag, String [] options) \r\n    throws Exception {\r\n\r\n    String newString;\r\n\r\n    if (options == null)\r\n      return \"\";\r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if ((options[i].length() \u003e 0) \u0026\u0026 (options[i].charAt(0) == '-')) {\r\n\t\r\n\t// Check if it is a negative number\r\n\ttry {\r\n\t  Double dummy = Double.valueOf(options[i]);\r\n\t} catch (NumberFormatException e) {\r\n\t  if (options[i].equals(\"-\" + flag)) {\r\n\t    if (i + 1 == options.length) {\r\n\t      throw new Exception(\"No value given for -\" + flag + \" option.\");\r\n\t    }\r\n\t    options[i] = \"\";\r\n\t    newString = new String(options[i + 1]);\r\n\t    options[i + 1] = \"\";\r\n\t    return newString;\r\n\t  }\r\n\t  if (options[i].charAt(1) == '-') {\r\n\t    return \"\";\r\n\t  }\r\n\t}\r\n      }\r\n    }\r\n    return \"\";\r\n  }\r\n\r\n  /**\r\n   * Quotes a string if it contains special characters.\r\n   * \r\n   * The following rules are applied:\r\n   *\r\n   * A character is backquoted version of it is one \r\n   * of \u003ctt\u003e\" ' % \\ \\n \\r \\t\u003c/tt\u003e.\r\n   *\r\n   * A string is enclosed within single quotes if a character has been\r\n   * backquoted using the previous rule above or contains \r\n   * \u003ctt\u003e{ }\u003c/tt\u003e or is exactly equal to the strings \r\n   * \u003ctt\u003e, ? space or \"\"\u003c/tt\u003e (empty string).\r\n   *\r\n   * A quoted question mark distinguishes it from the missing value which\r\n   * is represented as an unquoted question mark in arff files.\r\n   *\r\n   * @param string the string to be quoted\r\n   * @return the string (possibly quoted)\r\n   */\r\n  public static /*@pure@*/ String quote(String string) {\r\n      boolean quote = false;\r\n\r\n      // backquote the following characters \r\n      if ((string.indexOf('\\n') != -1) || (string.indexOf('\\r') != -1) || \r\n\t  (string.indexOf('\\'') != -1) || (string.indexOf('\"') != -1) || \r\n\t  (string.indexOf('\\\\') != -1) || \r\n\t  (string.indexOf('\\t') != -1) || (string.indexOf('%') != -1)) {\r\n\t  string = backQuoteChars(string);\r\n\t  quote = true;\r\n      }\r\n\r\n      // Enclose the string in 's if the string contains a recently added\r\n      // backquote or contains one of the following characters.\r\n      if((quote == true) || \r\n\t (string.indexOf('{') != -1) || (string.indexOf('}') != -1) ||\r\n\t (string.indexOf(',') != -1) || (string.equals(\"?\")) ||\r\n\t (string.indexOf(' ') != -1) || (string.equals(\"\"))) {\r\n\t  string = (\"'\".concat(string)).concat(\"'\");\r\n      }\r\n\r\n      return string;\r\n  }\r\n\r\n  /**\r\n   * Converts carriage returns and new lines in a string into \\r and \\n.\r\n   * Backquotes the following characters: ` \" \\ \\t and %\r\n   * @param string the string\r\n   * @return the converted string\r\n   */\r\n  public static /*@pure@*/ String backQuoteChars(String string) {\r\n\r\n    int index;\r\n    StringBuffer newStringBuffer;\r\n\r\n    // replace each of the following characters with the backquoted version\r\n    char   charsFind[] =    {'\\\\',   '\\'',  '\\t',  '\"',    '%'};\r\n    String charsReplace[] = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\\\\"\", \"\\\\%\"};\r\n    for(int i = 0; i \u003c charsFind.length; i++) {\r\n\tif (string.indexOf(charsFind[i]) != -1 ) {\r\n\t    newStringBuffer = new StringBuffer();\r\n\t    while ((index = string.indexOf(charsFind[i])) != -1) {\r\n\t\tif (index \u003e 0) {\r\n\t\t    newStringBuffer.append(string.substring(0, index));\r\n\t\t}\r\n\t\tnewStringBuffer.append(charsReplace[i]);\r\n\t\tif ((index + 1) \u003c string.length()) {\r\n\t\t    string = string.substring(index + 1);\r\n\t\t} else {\r\n\t\t    string = \"\";\r\n\t\t}\r\n\t    }\r\n\t    newStringBuffer.append(string);\r\n\t    string = newStringBuffer.toString();\r\n\t}\r\n    }\r\n\r\n    return Utils.convertNewLines(string);\r\n  }\r\n\r\n  /**\r\n   * Converts carriage returns and new lines in a string into \\r and \\n.\r\n   * @param string the string\r\n   * @return the converted string\r\n   */\r\n  public static /*@pure@*/ String convertNewLines(String string) {\r\n    \r\n    int index;\r\n\r\n    // Replace with \\n\r\n    StringBuffer newStringBuffer = new StringBuffer();\r\n    while ((index = string.indexOf('\\n')) != -1) {\r\n      if (index \u003e 0) {\r\n\tnewStringBuffer.append(string.substring(0, index));\r\n      }\r\n      newStringBuffer.append('\\\\');\r\n      newStringBuffer.append('n');\r\n      if ((index + 1) \u003c string.length()) {\r\n\tstring = string.substring(index + 1);\r\n      } else {\r\n\tstring = \"\";\r\n      }\r\n    }\r\n    newStringBuffer.append(string);\r\n    string = newStringBuffer.toString();\r\n\r\n    // Replace with \\r\r\n    newStringBuffer = new StringBuffer();\r\n    while ((index = string.indexOf('\\r')) != -1) {\r\n      if (index \u003e 0) {\r\n\tnewStringBuffer.append(string.substring(0, index));\r\n      }\r\n      newStringBuffer.append('\\\\');\r\n      newStringBuffer.append('r');\r\n      if ((index + 1) \u003c string.length()){\r\n\tstring = string.substring(index + 1);\r\n      } else {\r\n\tstring = \"\";\r\n      }\r\n    }\r\n    newStringBuffer.append(string);\r\n    return newStringBuffer.toString();\r\n  }\r\n    \r\n\r\n  /**\r\n   * Returns the secondary set of options (if any) contained in\r\n   * the supplied options array. The secondary set is defined to\r\n   * be any options after the first \"--\". These options are removed from\r\n   * the original options array.\r\n   *\r\n   * @param options the input array of options\r\n   * @return the array of secondary options\r\n   */\r\n  public static String [] partitionOptions(String [] options) {\r\n\r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if (options[i].equals(\"--\")) {\r\n\toptions[i++] = \"\";\r\n\tString [] result = new String [options.length - i];\r\n\tfor (int j = i; j \u003c options.length; j++) {\r\n\t  result[j - i] = options[j];\r\n\t  options[j] = \"\";\r\n\t}\r\n\treturn result;\r\n      }\r\n    }\r\n    return new String [0];\r\n  }\r\n    \r\n  /**\r\n   * The inverse operation of backQuoteChars().\r\n   * Converts back-quoted carriage returns and new lines in a string \r\n   * to the corresponding character ('\\r' and '\\n').\r\n   * Also \"un\"-back-quotes the following characters: ` \" \\ \\t and %\r\n   * @param string the string\r\n   * @return the converted string\r\n   */\r\n  public static String unbackQuoteChars(String string) {\r\n\r\n    int index;\r\n    StringBuffer newStringBuffer;\r\n    \r\n    // replace each of the following characters with the backquoted version\r\n    String charsFind[]    = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\\\\"\", \"\\\\%\"};\r\n    char   charsReplace[] = {'\\\\',   '\\'',  '\\t',  '\"',    '%'};\r\n    \r\n    for(int i = 0; i \u003c charsFind.length; i++) {\r\n      if (string.indexOf(charsFind[i]) != -1 ) {\r\n\tnewStringBuffer = new StringBuffer();\r\n\twhile ((index = string.indexOf(charsFind[i])) != -1) {\r\n\t  if (index \u003e 0) {\r\n\t    newStringBuffer.append(string.substring(0, index));\r\n\t  }\r\n\t  newStringBuffer.append(charsReplace[i]);\r\n\t  if ((index + charsFind[i].length()) \u003c string.length()) {\r\n\t    string = string.substring(index + charsFind[i].length());\r\n\t  } else {\r\n\t    string = \"\";\r\n\t  }\r\n\t}\r\n\tnewStringBuffer.append(string);\r\n\tstring = newStringBuffer.toString();\r\n      }\r\n    }\r\n    return Utils.convertNewLines(string);\r\n  }    \r\n  \r\n  /**\r\n   * Split up a string containing options into an array of strings,\r\n   * one for each option.\r\n   *\r\n   * @param quotedOptionString the string containing the options\r\n   * @return the array of options\r\n     * @throws java.lang.Exception\r\n   */\r\n  public static String [] splitOptions(String quotedOptionString) throws Exception{\r\n\r\n    FastVector optionsVec = new FastVector();\r\n    String str = new String(quotedOptionString);\r\n    int i;\r\n    \r\n    while (true){\r\n\r\n      //trimLeft \r\n      i = 0;\r\n      while ((i \u003c str.length()) \u0026\u0026 (Character.isWhitespace(str.charAt(i)))) i++;\r\n      str = str.substring(i);\r\n      \r\n      //stop when str is empty\r\n      if (str.length() == 0) break;\r\n      \r\n      //if str start with a double quote\r\n      if (str.charAt(0) == '\"'){\r\n\t\r\n\t//find the first not anti-slached double quote\r\n\ti = 1;\r\n\twhile(i \u003c str.length()){\r\n\t  if (str.charAt(i) == str.charAt(0)) break;\r\n\t  if (str.charAt(i) == '\\\\'){\r\n\t    i += 1;\r\n\t    if (i \u003e= str.length()) \r\n\t      throw new Exception(\"String should not finish with \\\\\");\r\n\t    if (str.charAt(i) != '\\\\' \u0026\u0026  str.charAt(i) != '\"') \r\n\t      throw new Exception(\"Unknow character \\\\\" + str.charAt(i));\r\n\t  }\r\n\t  i += 1;\r\n\t}\r\n\tif (i \u003e= str.length()) throw new Exception(\"Quote parse error.\");\r\n\t\r\n\t//add the founded string to the option vector (without quotes)\r\n\tString optStr = str.substring(1,i);\r\n\toptStr = unbackQuoteChars(optStr);\r\n\toptionsVec.addElement(optStr);\r\n\tstr = str.substring(i+1);\r\n      } else {\r\n\t//find first whiteSpace\r\n\ti=0;\r\n\twhile((i \u003c str.length()) \u0026\u0026 (!Character.isWhitespace(str.charAt(i)))) i++;\r\n\t\r\n\t//add the founded string to the option vector\r\n\tString optStr = str.substring(0,i);\r\n\toptionsVec.addElement(optStr);\r\n\tstr = str.substring(i);\r\n      }\r\n    }\r\n    \r\n    //convert optionsVec to an array of String\r\n    String [] options = new String[optionsVec.size()];\r\n    for (i = 0; i \u003c optionsVec.size(); i++) {\r\n      options[i] = (String)optionsVec.elementAt(i);\r\n    }\r\n    return options;\r\n  }    \r\n\r\n  /**\r\n   * Joins all the options in an option array into a single string,\r\n   * as might be used on the command line.\r\n   *\r\n   * @param optionArray the array of options\r\n   * @return the string containing all options.\r\n   */\r\n  public static String joinOptions(String [] optionArray) {\r\n\r\n    String optionString = \"\";\r\n    for (int i = 0; i \u003c optionArray.length; i++) {\r\n      if (optionArray[i].equals(\"\")) {\r\n\tcontinue;\r\n      }\r\n      if (optionArray[i].indexOf(' ') != -1) {\r\n\toptionString += '\"' + optionArray[i] + '\"';\r\n      } else {\r\n\toptionString += optionArray[i];\r\n      }\r\n      optionString += \" \";\r\n    }\r\n    return optionString.trim();\r\n  }\r\n  \r\n  /**\r\n   * Creates a new instance of an object given it's class name and\r\n   * (optional) arguments to pass to it's setOptions method. If the\r\n   * object implements OptionHandler and the options parameter is\r\n   * non-null, the object will have it's options set. Example use:\u003cp\u003e\r\n   *\r\n   * \u003ccode\u003e \u003cpre\u003e\r\n   * String classifierName = Utils.getOption('W', options);\r\n   * Classifier c = (Classifier)Utils.forName(Classifier.class,\r\n   *                                          classifierName,\r\n   *                                          options);\r\n   * setClassifier(c);\r\n   * \u003c/pre\u003e\u003c/code\u003e\r\n   *\r\n   * @param classType the class that the instantiated object should\r\n   * be assignable to -- an exception is thrown if this is not the case\r\n   * @param className the fully qualified class name of the object\r\n   * @param options an array of options suitable for passing to setOptions. May\r\n   * be null. Any options accepted by the object will be removed from the\r\n   * array.\r\n   * @return the newly created object, ready for use.\r\n   * @exception Exception if the class name is invalid, or if the\r\n   * class is not assignable to the desired class type, or the options\r\n   * supplied are not acceptable to the object\r\n   */\r\n  public static Object forName(Class classType,\r\n\t\t\t       String className,\r\n\t\t\t       String [] options) throws Exception {\r\n\r\n    Class c = null;\r\n    try {\r\n      c = Class.forName(className);\r\n    } catch (Exception ex) {\r\n      throw new Exception(\"Can't find class called: \" + className);\r\n    }\r\n    if (!classType.isAssignableFrom(c)) {\r\n      throw new Exception(classType.getName() + \" is not assignable from \"\r\n\t\t\t  + className);\r\n    }\r\n    Object o = c.newInstance();\r\n    if ((o instanceof OptionHandler)\r\n\t\u0026\u0026 (options != null)) {\r\n      ((OptionHandler)o).setOptions(options);\r\n      Utils.checkForRemainingOptions(options);\r\n    }\r\n    return o;\r\n  }\r\n\r\n  /**\r\n   * Computes entropy for an array of integers.\r\n   *\r\n   * @param counts array of counts\r\n   * @return - a log2 a - b log2 b - c log2 c + (a+b+c) log2 (a+b+c)\r\n   * when given array [a b c]\r\n   */\r\n  public static /*@pure@*/ double info(int counts[]) {\r\n    \r\n    int total = 0; int c;\r\n    double x = 0;\r\n    for (int j = 0; j \u003c counts.length; j++) {\r\n      x -= xlogx(counts[j]);\r\n      total += counts[j];\r\n    }\r\n    return x + xlogx(total);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is smaller or equal to b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n     * @return  True if a is smaller or equal to b.\r\n   */\r\n  public static /*@pure@*/ boolean smOrEq(double a,double b) {\r\n    \r\n    return (a-b \u003c SMALL);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is greater or equal to b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n     * @return True if a is greater or equal to b.\r\n   */\r\n  public static /*@pure@*/ boolean grOrEq(double a,double b) {\r\n    \r\n    return (b-a \u003c SMALL);\r\n  }\r\n  \r\n  /**\r\n   * Tests if a is smaller than b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n     * @return True if a is smaller than b.\r\n   */\r\n  public static /*@pure@*/ boolean sm(double a,double b) {\r\n    \r\n    return (b-a \u003e SMALL);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is greater than b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double \r\n     * @return  True if a is greater than b.\r\n   */\r\n  public static /*@pure@*/ boolean gr(double a,double b) {\r\n    \r\n    return (a-b \u003e SMALL);\r\n  }\r\n\r\n  /**\r\n   * Returns the kth-smallest value in the array.\r\n   *\r\n   * @param array the array of integers\r\n   * @param k the value of k\r\n   * @return the kth-smallest value\r\n   */\r\n  public static double kthSmallestValue(int[] array, int k) {\r\n\r\n    int [] index = new int[array.length];\r\n    \r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n    }\r\n\r\n    return array[index[select(array, index, 0, array.length - 1, k)]];\r\n  }\r\n\r\n  /**\r\n   * Returns the kth-smallest value in the array\r\n   *\r\n   * @param array the array of double\r\n   * @param k the value of k\r\n   * @return the kth-smallest value\r\n   */\r\n  public static double kthSmallestValue(double[] array, int k) {\r\n\r\n    int [] index = new int[array.length];\r\n    \r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n    }\r\n\r\n    return array[index[select(array, index, 0, array.length - 1, k)]];\r\n  }\r\n\r\n  /**\r\n   * Returns the logarithm of a for base 2.\r\n   *\r\n   * @param a a double\r\n     * @return  the logarithm of a for base 2.\r\n   */\r\n  public static /*@pure@*/ double log2(double a) {\r\n    \r\n    return Math.log(a) / log2;\r\n  }\r\n\r\n  /**\r\n   * Returns index of maximum element in a given\r\n   * array of doubles. First maximum is returned.\r\n   *\r\n   * @param doubles the array of doubles\r\n   * @return the index of the maximum element\r\n   */\r\n  public static /*@pure@*/ int maxIndex(double [] doubles) {\r\n\r\n    double maximum = 0;\r\n    int maxIndex = 0;\r\n\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      if ((i == 0) || (doubles[i] \u003e maximum)) {\r\n\tmaxIndex = i;\r\n\tmaximum = doubles[i];\r\n      }\r\n    }\r\n\r\n    return maxIndex;\r\n  }\r\n\r\n  /**\r\n   * Returns index of maximum element in a given\r\n   * array of integers. First maximum is returned.\r\n   *\r\n   * @param ints the array of integers\r\n   * @return the index of the maximum element\r\n   */\r\n  public static /*@pure@*/ int maxIndex(int [] ints) {\r\n\r\n    int maximum = 0;\r\n    int maxIndex = 0;\r\n\r\n    for (int i = 0; i \u003c ints.length; i++) {\r\n      if ((i == 0) || (ints[i] \u003e maximum)) {\r\n\tmaxIndex = i;\r\n\tmaximum = ints[i];\r\n      }\r\n    }\r\n\r\n    return maxIndex;\r\n  }\r\n\r\n  /**\r\n   * Computes the mean for an array of doubles.\r\n   *\r\n   * @param vector the array\r\n   * @return the mean\r\n   */\r\n  public static /*@pure@*/ double mean(double[] vector) {\r\n  \r\n    double sum = 0;\r\n\r\n    if (vector.length == 0) {\r\n      return 0;\r\n    }\r\n    for (int i = 0; i \u003c vector.length; i++) {\r\n      sum += vector[i];\r\n    }\r\n    return sum / (double) vector.length;\r\n  }\r\n\r\n  /**\r\n   * Returns index of minimum element in a given\r\n   * array of integers. First minimum is returned.\r\n   *\r\n   * @param ints the array of integers\r\n   * @return the index of the minimum element\r\n   */\r\n  public static /*@pure@*/ int minIndex(int [] ints) {\r\n\r\n    int minimum = 0;\r\n    int minIndex = 0;\r\n\r\n    for (int i = 0; i \u003c ints.length; i++) {\r\n      if ((i == 0) || (ints[i] \u003c minimum)) {\r\n\tminIndex = i;\r\n\tminimum = ints[i];\r\n      }\r\n    }\r\n\r\n    return minIndex;\r\n  }\r\n\r\n  /**\r\n   * Returns index of minimum element in a given\r\n   * array of doubles. First minimum is returned.\r\n   *\r\n   * @param doubles the array of doubles\r\n   * @return the index of the minimum element\r\n   */\r\n  public static /*@pure@*/ int minIndex(double [] doubles) {\r\n\r\n    double minimum = 0;\r\n    int minIndex = 0;\r\n\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      if ((i == 0) || (doubles[i] \u003c minimum)) {\r\n\tminIndex = i;\r\n\tminimum = doubles[i];\r\n      }\r\n    }\r\n\r\n    return minIndex;\r\n  }\r\n\r\n  /**\r\n   * Normalizes the doubles in the array by their sum.\r\n   *\r\n   * @param doubles the array of double\r\n   * @exception IllegalArgumentException if sum is Zero or NaN\r\n   */\r\n  public static void normalize(double[] doubles) {\r\n\r\n    double sum = 0;\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      sum += doubles[i];\r\n    }\r\n    normalize(doubles, sum);\r\n  }\r\n\r\n  /**\r\n   * Normalizes the doubles in the array using the given value.\r\n   *\r\n   * @param doubles the array of double\r\n   * @param sum the value by which the doubles are to be normalized\r\n   * @exception IllegalArgumentException if sum is zero or NaN\r\n   */\r\n  public static void normalize(double[] doubles, double sum) {\r\n\r\n    if (Double.isNaN(sum)) {\r\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is NaN.\");\r\n    }\r\n    if (sum == 0) {\r\n      // Maybe this should just be a return.\r\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is zero.\");\r\n    }\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      doubles[i] /= sum;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts an array containing the natural logarithms of\r\n   * probabilities stored in a vector back into probabilities.\r\n   * The probabilities are assumed to sum to one.\r\n   *\r\n   * @param a an array holding the natural logarithms of the probabilities\r\n   * @return the converted array \r\n   */\r\n  public static double[] logs2probs(double[] a) {\r\n\r\n    double max = a[maxIndex(a)];\r\n    double sum = 0.0;\r\n\r\n    double[] result = new double[a.length];\r\n    for(int i = 0; i \u003c a.length; i++) {\r\n      result[i] = Math.exp(a[i] - max);\r\n      sum += result[i];\r\n    }\r\n\r\n    normalize(result, sum);\r\n\r\n    return result;\r\n  } \r\n\r\n  /**\r\n   * Rounds a double to the next nearest integer value. The JDK version\r\n   * of it doesn't work properly.\r\n   *\r\n   * @param value the double value\r\n   * @return the resulting integer value\r\n   */\r\n  public static /*@pure@*/ int round(double value) {\r\n\r\n    int roundedValue = value \u003e 0\r\n      ? (int)(value + 0.5)\r\n      : -(int)(Math.abs(value) + 0.5);\r\n    \r\n    return roundedValue;\r\n  }\r\n\r\n  /**\r\n   * Rounds a double to the next nearest integer value in a probabilistic\r\n   * fashion (e.g. 0.8 has a 20% chance of being rounded down to 0 and a\r\n   * 80% chance of being rounded up to 1). In the limit, the average of\r\n   * the rounded numbers generated by this procedure should converge to\r\n   * the original double.\r\n   *\r\n   * @param value the double value\r\n     * @param rand Random object.\r\n   * @return the resulting integer value\r\n   */\r\n  public static int probRound(double value, Random rand) {\r\n\r\n    if (value \u003e= 0) {\r\n      double lower = Math.floor(value);\r\n      double prob = value - lower;\r\n      if (rand.nextDouble() \u003c prob) {\r\n\treturn (int)lower + 1;\r\n      } else {\r\n\treturn (int)lower;\r\n      }\r\n    } else {\r\n      double lower = Math.floor(Math.abs(value));\r\n      double prob = Math.abs(value) - lower;\r\n      if (rand.nextDouble() \u003c prob) {\r\n\treturn -((int)lower + 1);\r\n      } else {\r\n\treturn -(int)lower;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rounds a double to the given number of decimal places.\r\n   *\r\n   * @param value the double value\r\n   * @param afterDecimalPoint the number of digits after the decimal point\r\n   * @return the double rounded to the given precision\r\n   */\r\n  public static /*@pure@*/ double roundDouble(double value,int afterDecimalPoint) {\r\n\r\n    double mask = Math.pow(10.0, (double)afterDecimalPoint);\r\n\r\n    return (double)(Math.round(value * mask)) / mask;\r\n  }\r\n\r\n  /**\r\n   * Sorts a given array of integers in ascending order and returns an \r\n   * array of integers with the positions of the elements of the original \r\n   * array in the sorted array. The sort is stable. (Equal elements remain\r\n   * in their original order.)\r\n   *\r\n   * @param array this array is not changed by the method!\r\n   * @return an array of integers with the positions in the sorted\r\n   * array.\r\n   */\r\n  public static /*@pure@*/ int[] sort(int [] array) {\r\n\r\n    int [] index = new int[array.length];\r\n    int [] newIndex = new int[array.length];\r\n    int [] helpIndex;\r\n    int numEqual;\r\n    \r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n    }\r\n    quickSort(array, index, 0, array.length - 1);\r\n\r\n    // Make sort stable\r\n    int i = 0;\r\n    while (i \u003c index.length) {\r\n      numEqual = 1;\r\n      for (int j = i + 1; ((j \u003c index.length)\r\n\t\t\t   \u0026\u0026 (array[index[i]] == array[index[j]]));\r\n\t   j++) {\r\n\tnumEqual++;\r\n      }\r\n      if (numEqual \u003e 1) {\r\n\thelpIndex = new int[numEqual];\r\n\tfor (int j = 0; j \u003c numEqual; j++) {\r\n\t  helpIndex[j] = i + j;\r\n\t}\r\n\tquickSort(index, helpIndex, 0, numEqual - 1);\r\n\tfor (int j = 0; j \u003c numEqual; j++) {\r\n\t  newIndex[i + j] = index[helpIndex[j]];\r\n\t}\r\n\ti += numEqual;\r\n      } else {\r\n\tnewIndex[i] = index[i];\r\n\ti++;\r\n      }\r\n    }\r\n    return newIndex;\r\n  }\r\n\r\n  /**\r\n   * Sorts a given array of doubles in ascending order and returns an\r\n   * array of integers with the positions of the elements of the\r\n   * original array in the sorted array. NOTE THESE CHANGES: the sort\r\n   * is no longer stable and it doesn't use safe floating-point\r\n   * comparisons anymore. Occurrences of Double.NaN are treated as \r\n   * Double.MAX_VALUE\r\n   *\r\n   * @param array this array is not changed by the method!\r\n   * @return an array of integers with the positions in the sorted\r\n   * array.  \r\n   */\r\n  public static /*@pure@*/ int[] sort(/*@non_null@*/ double [] array) {\r\n\r\n    int [] index = new int[array.length];\r\n    array = (double [])array.clone();\r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n      if (Double.isNaN(array[i])) {\r\n        array[i] = Double.MAX_VALUE;\r\n      }\r\n    }\r\n    quickSort(array, index, 0, array.length - 1);\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Sorts a given array of doubles in ascending order and returns an \r\n   * array of integers with the positions of the elements of the original \r\n   * array in the sorted array. The sort is stable (Equal elements remain\r\n   * in their original order.) Occurrences of Double.NaN are treated as \r\n   * Double.MAX_VALUE\r\n   *\r\n   * @param array this array is not changed by the method!\r\n   * @return an array of integers with the positions in the sorted\r\n   * array.\r\n   */\r\n  public static /*@pure@*/ int[] stableSort(double [] array){\r\n\r\n    int [] index = new int[array.length];\r\n    int [] newIndex = new int[array.length];\r\n    int [] helpIndex;\r\n    int numEqual;\r\n    \r\n    array = (double [])array.clone();\r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n      if (Double.isNaN(array[i])) {\r\n        array[i] = Double.MAX_VALUE;\r\n      }\r\n    }\r\n    quickSort(array,index,0,array.length-1);\r\n\r\n    // Make sort stable\r\n\r\n    int i = 0;\r\n    while (i \u003c index.length) {\r\n      numEqual = 1;\r\n      for (int j = i+1; ((j \u003c index.length) \u0026\u0026 Utils.eq(array[index[i]],\r\n\t\t\t\t\t\t\tarray[index[j]])); j++)\r\n\tnumEqual++;\r\n      if (numEqual \u003e 1) {\r\n\thelpIndex = new int[numEqual];\r\n\tfor (int j = 0; j \u003c numEqual; j++)\r\n\t  helpIndex[j] = i+j;\r\n\tquickSort(index, helpIndex, 0, numEqual-1);\r\n\tfor (int j = 0; j \u003c numEqual; j++) \r\n\t  newIndex[i+j] = index[helpIndex[j]];\r\n\ti += numEqual;\r\n      } else {\r\n\tnewIndex[i] = index[i];\r\n\ti++;\r\n      }\r\n    }\r\n\r\n    return newIndex;\r\n  }\r\n\r\n  /**\r\n   * Computes the variance for an array of doubles.\r\n   *\r\n   * @param vector the array\r\n   * @return the variance\r\n   */\r\n  public static /*@pure@*/ double variance(double[] vector) {\r\n  \r\n    double sum = 0, sumSquared = 0;\r\n\r\n    if (vector.length \u003c= 1) {\r\n      return 0;\r\n    }\r\n    for (int i = 0; i \u003c vector.length; i++) {\r\n      sum += vector[i];\r\n      sumSquared += (vector[i] * vector[i]);\r\n    }\r\n    double result = (sumSquared - (sum * sum / (double) vector.length)) / \r\n      (double) (vector.length - 1);\r\n\r\n    // We don't like negative variance\r\n    if (result \u003c 0) {\r\n      return 0;\r\n    } else {\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Computes the sum of the elements of an array of doubles.\r\n   *\r\n   * @param doubles the array of double\r\n   * @return the sum of the elements\r\n   */\r\n  public static /*@pure@*/ double sum(double[] doubles) {\r\n\r\n    double sum = 0;\r\n\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      sum += doubles[i];\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * Computes the sum of the elements of an array of integers.\r\n   *\r\n   * @param ints the array of integers\r\n   * @return the sum of the elements\r\n   */\r\n  public static /*@pure@*/ int sum(int[] ints) {\r\n\r\n    int sum = 0;\r\n\r\n    for (int i = 0; i \u003c ints.length; i++) {\r\n      sum += ints[i];\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * Returns c*log2(c) for a given integer value c.\r\n   *\r\n   * @param c an integer value\r\n   * @return c*log2(c) (but is careful to return 0 if c is 0)\r\n   */\r\n  public static /*@pure@*/ double xlogx(int c) {\r\n    \r\n    if (c == 0) {\r\n      return 0.0;\r\n    }\r\n    return c * Utils.log2((double) c);\r\n  }\r\n\r\n  /**\r\n   * Partitions the instances around a pivot. Used by quicksort and\r\n   * kthSmallestValue.\r\n   *\r\n   * @param array the array of doubles to be sorted\r\n   * @param index the index into the array of doubles\r\n   * @param left the first index of the subset \r\n   * @param right the last index of the subset \r\n   *\r\n   * @return the index of the middle element\r\n   */\r\n  private static int partition(double[] array, int[] index, int l, int r) {\r\n    \r\n    double pivot = array[index[(l + r) / 2]];\r\n    int help;\r\n\r\n    while (l \u003c r) {\r\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\r\n        l++;\r\n      }\r\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\r\n        r--;\r\n      }\r\n      if (l \u003c r) {\r\n        help = index[l];\r\n        index[l] = index[r];\r\n        index[r] = help;\r\n        l++;\r\n        r--;\r\n      }\r\n    }\r\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\r\n      r--;\r\n    } \r\n\r\n    return r;\r\n  }\r\n\r\n  /**\r\n   * Partitions the instances around a pivot. Used by quicksort and\r\n   * kthSmallestValue.\r\n   *\r\n   * @param array the array of integers to be sorted\r\n   * @param index the index into the array of integers\r\n   * @param left the first index of the subset \r\n   * @param right the last index of the subset \r\n   *\r\n   * @return the index of the middle element\r\n   */\r\n  private static int partition(int[] array, int[] index, int l, int r) {\r\n    \r\n    double pivot = array[index[(l + r) / 2]];\r\n    int help;\r\n\r\n    while (l \u003c r) {\r\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\r\n        l++;\r\n      }\r\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\r\n        r--;\r\n      }\r\n      if (l \u003c r) {\r\n        help = index[l];\r\n        index[l] = index[r];\r\n        index[r] = help;\r\n        l++;\r\n        r--;\r\n      }\r\n    }\r\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\r\n      r--;\r\n    } \r\n\r\n    return r;\r\n  }\r\n  \r\n  /**\r\n   * Implements quicksort according to Manber's \"Introduction to\r\n   * Algorithms\".\r\n   *\r\n   * @param array the array of doubles to be sorted\r\n   * @param index the index into the array of doubles\r\n   * @param left the first index of the subset to be sorted\r\n   * @param right the last index of the subset to be sorted\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r\n  //@ requires array != index;\r\n  //  assignable index;\r\n  private static void quickSort(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \r\n                                int left, int right) {\r\n\r\n    if (left \u003c right) {\r\n      int middle = partition(array, index, left, right);\r\n      quickSort(array, index, left, middle);\r\n      quickSort(array, index, middle + 1, right);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Implements quicksort according to Manber's \"Introduction to\r\n   * Algorithms\".\r\n   *\r\n   * @param array the array of integers to be sorted\r\n   * @param index the index into the array of integers\r\n   * @param left the first index of the subset to be sorted\r\n   * @param right the last index of the subset to be sorted\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r\n  //@ requires array != index;\r\n  //  assignable index;\r\n  private static void quickSort(/*@non_null@*/ int[] array, /*@non_null@*/  int[] index, \r\n                                int left, int right) {\r\n\r\n    if (left \u003c right) {\r\n      int middle = partition(array, index, left, right);\r\n      quickSort(array, index, left, middle);\r\n      quickSort(array, index, middle + 1, right);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Implements computation of the kth-smallest element according\r\n   * to Manber's \"Introduction to Algorithms\".\r\n   *\r\n   * @param array the array of double\r\n   * @param index the index into the array of doubles\r\n   * @param left the first index of the subset \r\n   * @param right the last index of the subset \r\n   * @param k the value of k\r\n   *\r\n   * @return the index of the kth-smallest element\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  private static int select(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \r\n                            int left, int right, int k) {\r\n    \r\n    if (left == right) {\r\n      return left;\r\n    } else {\r\n      int middle = partition(array, index, left, right);\r\n      if ((middle - left + 1) \u003e= k) {\r\n        return select(array, index, left, middle, k);\r\n      } else {\r\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Implements computation of the kth-smallest element according\r\n   * to Manber's \"Introduction to Algorithms\".\r\n   *\r\n   * @param array the array of integers\r\n   * @param index the index into the array of integers\r\n   * @param left the first index of the subset \r\n   * @param right the last index of the subset \r\n   * @param k the value of k\r\n   *\r\n   * @return the index of the kth-smallest element\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  private static int select(/*@non_null@*/ int[] array, /*@non_null@*/ int[] index, \r\n                            int left, int right, int k) {\r\n    \r\n    if (left == right) {\r\n      return left;\r\n    } else {\r\n      int middle = partition(array, index, left, right);\r\n      if ((middle - left + 1) \u003e= k) {\r\n        return select(array, index, left, middle, k);\r\n      } else {\r\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Main method for testing this class.\r\n   *\r\n   * @param ops some dummy options\r\n   */\r\n  public static void main(String[] ops) {\r\n\r\n    double[] doublesWithNaN = {4.5, 6.7, Double.NaN, 3.4, 4.8, 1.2, 3.4};\r\n    double[] doubles = {4.5, 6.7, 6.7, 3.4, 4.8, 1.2, 3.4, 6.7, 6.7, 3.4};\r\n    int[] ints = {12, 6, 2, 18, 16, 6, 7, 5, 18, 18, 17};\r\n\r\n    try {\r\n\r\n      // Option handling\r\n      System.out.println(\"First option split up:\");\r\n      if (ops.length \u003e 0) {\r\n\tString[] firstOptionSplitUp = Utils.splitOptions(ops[0]);\r\n\tfor (int i = 0; i \u003c firstOptionSplitUp.length; i ++) {\r\n\t  System.out.println(firstOptionSplitUp[i]);\r\n\t}\r\n      }\t\t\t\t\t       \r\n      System.out.println(\"Partitioned options: \");\r\n      String[] partitionedOptions = Utils.partitionOptions(ops);\r\n      for (int i  = 0; i \u003c partitionedOptions.length; i++) {\r\n\tSystem.out.println(partitionedOptions[i]);\r\n      }\r\n      System.out.println(\"Get flag -f: \" + Utils.getFlag('f', ops));\r\n      System.out.println(\"Get option -o: \" + Utils.getOption('o', ops));\r\n      System.out.println(\"Checking for remaining options... \");\r\n      Utils.checkForRemainingOptions(ops);\r\n      \r\n      // Statistics\r\n      System.out.println(\"Original array with NaN (doubles): \");\r\n      for (int i = 0; i \u003c doublesWithNaN.length; i++) {\r\n\tSystem.out.print(doublesWithNaN[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Original array (doubles): \");\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(doubles[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Original array (ints): \");\r\n      for (int i = 0; i \u003c ints.length; i++) {\r\n\tSystem.out.print(ints[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Correlation: \" + Utils.correlation(doubles, doubles, \r\n\t\t\t\t\t\t\t     doubles.length));\r\n      System.out.println(\"Mean: \" + Utils.mean(doubles));\r\n      System.out.println(\"Variance: \" + Utils.variance(doubles));\r\n      System.out.println(\"Sum (doubles): \" + Utils.sum(doubles));\r\n      System.out.println(\"Sum (ints): \" + Utils.sum(ints));\r\n      System.out.println(\"Max index (doubles): \" + Utils.maxIndex(doubles));\r\n      System.out.println(\"Max index (ints): \" + Utils.maxIndex(ints));\r\n      System.out.println(\"Min index (doubles): \" + Utils.minIndex(doubles));\r\n      System.out.println(\"Min index (ints): \" + Utils.minIndex(ints));\r\n      System.out.println(\"Median (doubles): \" + \r\n                         Utils.kthSmallestValue(doubles, doubles.length / 2));\r\n      System.out.println(\"Median (ints): \" + \r\n                         Utils.kthSmallestValue(ints, ints.length / 2));\r\n\r\n      // Sorting and normalizing\r\n      System.out.println(\"Sorted array with NaN (doubles): \");\r\n      int[] sorted = Utils.sort(doublesWithNaN);\r\n      for (int i = 0; i \u003c doublesWithNaN.length; i++) {\r\n\tSystem.out.print(doublesWithNaN[sorted[i]] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Sorted array (doubles): \");\r\n      sorted = Utils.sort(doubles);\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(doubles[sorted[i]] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Sorted array (ints): \");\r\n      sorted = Utils.sort(ints);\r\n      for (int i = 0; i \u003c ints.length; i++) {\r\n\tSystem.out.print(ints[sorted[i]] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Indices from stable sort (doubles): \");\r\n      sorted = Utils.stableSort(doubles);\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(sorted[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Indices from sort (ints): \");\r\n      sorted = Utils.sort(ints);\r\n      for (int i = 0; i \u003c ints.length; i++) {\r\n\tSystem.out.print(sorted[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Normalized array (doubles): \");\r\n      Utils.normalize(doubles);\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(doubles[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Normalized again (doubles): \");\r\n      Utils.normalize(doubles, Utils.sum(doubles));\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(doubles[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      \r\n      // Pretty-printing\r\n      System.out.println(\"-4.58: \" + Utils.doubleToString(-4.57826535, 2));\r\n      System.out.println(\"-6.78: \" + Utils.doubleToString(-6.78214234, 6,2));\r\n      \r\n      // Comparisons\r\n      System.out.println(\"5.70001 == 5.7 ? \" + Utils.eq(5.70001, 5.7));\r\n      System.out.println(\"5.70001 \u003e 5.7 ? \" + Utils.gr(5.70001, 5.7));\r\n      System.out.println(\"5.70001 \u003e= 5.7 ? \" + Utils.grOrEq(5.70001, 5.7));\r\n      System.out.println(\"5.7 \u003c 5.70001 ? \" + Utils.sm(5.7, 5.70001));\r\n      System.out.println(\"5.7 \u003c= 5.70001 ? \" + Utils.smOrEq(5.7, 5.70001));\r\n      \r\n      // Math\r\n      System.out.println(\"Info (ints): \" + Utils.info(ints));\r\n      System.out.println(\"log2(4.6): \" + Utils.log2(4.6));\r\n      System.out.println(\"5 * log(5): \" + Utils.xlogx(5));\r\n      System.out.println(\"5.5 rounded: \" + Utils.round(5.5));\r\n      System.out.println(\"5.55555 rounded to 2 decimal places: \" + \r\n\t\t\t Utils.roundDouble(5.55555, 2));\r\n      \r\n      // Arrays\r\n      System.out.println(\"Array-Dimensions of 'new int[][]': \" + Utils.getArrayDimensions(new int[][]{}));\r\n      System.out.println(\"Array-Dimensions of 'new int[][]{{1,2,3},{4,5,6}}': \" + Utils.getArrayDimensions(new int[][]{{1,2,3},{4,5,6}}));\r\n      String[][][] s = new String[3][4][];\r\n      System.out.println(\"Array-Dimensions of 'new String[3][4][]': \" + Utils.getArrayDimensions(s));\r\n    } catch (Exception e) {\r\n      e.printStackTrace();\r\n    }\r\n  }\r\n}\r\n  \r\n",
        "name": "Utils.java",
        "path": "src/keel/Algorithms/ImbalancedClassification/Resampling/SMOTE_RSB/Rough_Sets/Utils.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/ImbalancedClassification/Resampling/SMOTE_RSB/Rough_Sets/Utils.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 1522,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1523,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1524,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1545,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1546,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1547,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1571,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1599,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "package keel.Algorithms.ImbalancedClassification.Resampling.SMOTE_RSB.Rough_Sets;\r\n\r\n\r\nimport java.io.Serializable;\r\nimport java.util.Enumeration;\r\n\r\n/**\r\n * Class for handling an instance. All values (numeric, nominal, or\r\n * string) are internally stored as floating-point numbers. If an\r\n * attribute is nominal (or a string), the stored value is the index\r\n * of the corresponding nominal (or string) value in the attribute's\r\n * definition. We have chosen this approach in favor of a more elegant\r\n * object-oriented approach because it is much faster. \u003cp\u003e\r\n *\r\n * Typical usage (code from the main() method of this class): \u003cp\u003e\r\n *\r\n * \u003ccode\u003e\r\n * ... \u003cbr\u003e\r\n *      \r\n * // Create empty instance with three attribute values \u003cbr\u003e\r\n * Instance inst = new Instance(3); \u003cbr\u003e\u003cbr\u003e\r\n *     \r\n * // Set instance's values for the attributes \"length\", \"weight\", and \"position\"\u003cbr\u003e\r\n * inst.setValue(length, 5.3); \u003cbr\u003e\r\n * inst.setValue(weight, 300); \u003cbr\u003e\r\n * inst.setValue(position, \"first\"); \u003cbr\u003e\u003cbr\u003e\r\n *   \r\n * // Set instance's dataset to be the dataset \"race\" \u003cbr\u003e\r\n * inst.setDataset(race); \u003cbr\u003e\u003cbr\u003e\r\n *   \r\n * // Print the instance \u003cbr\u003e\r\n * System.out.println(\"The instance: \" + inst); \u003cbr\u003e\r\n *\r\n * ... \u003cbr\u003e\r\n * \u003c/code\u003e\u003cp\u003e\r\n *\r\n * All methods that change an instance are safe, ie. a change of an\r\n * instance does not affect any other instances. All methods that\r\n * change an instance's attribute values clone the attribute value\r\n * vector before it is changed. If your application heavily modifies\r\n * instance values, it may be faster to create a new instance from scratch.\r\n *\r\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\r\n * @version $Revision: 1.1 $ \r\n */\r\npublic class Instance implements Copyable, Serializable {\r\n  \r\n  /** Constant representing a missing value. */\r\n  protected static final double MISSING_VALUE = Double.NaN;\r\n\r\n  /** \r\n   * The dataset the instance has access to.  Null if the instance\r\n   * doesn't have access to any dataset.  Only if an instance has\r\n   * access to a dataset, it knows about the actual attribute types.  \r\n   */\r\n  protected /*@spec_public@*/ Instances m_Dataset;\r\n\r\n  /** The instance's attribute values. */\r\n  protected /*@spec_public non_null@*/ double[] m_AttValues;\r\n\r\n  /** The instance's weight. */\r\n  protected double m_Weight;\r\n\r\n  /**\r\n   * Constructor that copies the attribute values and the weight from\r\n   * the given instance. Reference to the dataset is set to null.\r\n   * (ie. the instance doesn't have access to information about the\r\n   * attribute types)\r\n   *\r\n   * @param instance the instance from which the attribute\r\n   * values and the weight are to be copied \r\n   */\r\n  //@ ensures m_Dataset == null;\r\n  protected Instance(/*@non_null@*/ Instance instance) {\r\n    \r\n    m_AttValues = instance.m_AttValues;\r\n    m_Weight = instance.m_Weight;\r\n    m_Dataset = null;\r\n  }\r\n\r\n  /**\r\n   * Constructor that inititalizes instance variable with given\r\n   * values. Reference to the dataset is set to null. (ie. the instance\r\n   * doesn't have access to information about the attribute types)\r\n   *\r\n   * @param weight the instance's weight\r\n   * @param attValues a vector of attribute values \r\n   */\r\n  //@ ensures m_Dataset == null;\r\n  public Instance(double weight,  /*@non_null@*/ double[]attValues){\r\n    \r\n    m_AttValues = attValues;\r\n    m_Weight = weight;\r\n    m_Dataset = null;\r\n  }\r\n\r\n  /**\r\n   * Constructor of an instance that sets weight to one, all values to\r\n   * be missing, and the reference to the dataset to null. (ie. the instance\r\n   * doesn't have access to information about the attribute types)\r\n   *\r\n   * @param numAttributes the size of the instance \r\n   */\r\n  //@ requires numAttributes \u003e 0;    // Or maybe == 0 is okay too?\r\n  //@ ensures m_Dataset == null;\r\n  public Instance(int numAttributes) {\r\n    \r\n    m_AttValues = new double[numAttributes];\r\n    for (int i = 0; i \u003c m_AttValues.length; i++) {\r\n      m_AttValues[i] = MISSING_VALUE;\r\n    }\r\n    m_Weight = 1;\r\n    m_Dataset = null;\r\n  }\r\n\r\n  /**\r\n   * Returns the attribute with the given index.\r\n   *\r\n   * @param index the attribute's index\r\n   * @return the attribute at the given position\r\n   * @exception UnassignedDatasetException if instance doesn't have access to a\r\n   * dataset\r\n   */ \r\n  //@ requires m_Dataset != null;\r\n  public /*@pure@*/ Attribute attribute(int index) {\r\n   \r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    }\r\n    return m_Dataset.attribute(index);\r\n  }\r\n\r\n  /**\r\n   * Returns the attribute with the given index. Does the same\r\n   * thing as attribute().\r\n   *\r\n   * @param indexOfIndex the index of the attribute's index \r\n   * @return the attribute at the given position\r\n   * @exception UnassignedDatasetException if instance doesn't have access to a\r\n   * dataset\r\n   */ \r\n  //@ requires m_Dataset != null;\r\n  public /*@pure@*/ Attribute attributeSparse(int indexOfIndex) {\r\n   \r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    }\r\n    return m_Dataset.attribute(indexOfIndex);\r\n  }\r\n\r\n  /**\r\n   * Returns class attribute.\r\n   *\r\n   * @return the class attribute\r\n   * @exception UnassignedDatasetException if the class is not set or the\r\n   * instance doesn't have access to a dataset\r\n   */\r\n  //@ requires m_Dataset != null;\r\n  public /*@pure@*/ Attribute classAttribute() {\r\n\r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    }\r\n    return m_Dataset.classAttribute();\r\n  }\r\n\r\n  /**\r\n   * Returns the class attribute's index.\r\n   *\r\n   * @return the class index as an integer \r\n   * @exception UnassignedDatasetException if instance doesn't have access to a dataset \r\n   */\r\n  //@ requires m_Dataset != null;\r\n  //@ ensures  \\result == m_Dataset.classIndex();\r\n  public /*@pure@*/ int classIndex() {\r\n    \r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    }\r\n    return m_Dataset.classIndex();\r\n  }\r\n\r\n  /**\r\n   * Tests if an instance's class is missing.\r\n   *\r\n   * @return true if the instance's class is missing\r\n   * @exception UnassignedClassException if the class is not set or the instance doesn't\r\n   * have access to a dataset\r\n   */\r\n  //@ requires classIndex() \u003e= 0;\r\n  public /*@pure@*/ boolean classIsMissing() {\r\n\r\n    if (classIndex() \u003c 0) {\r\n      throw new UnassignedClassException(\"Class is not set!\");\r\n    }\r\n    return isMissing(classIndex());\r\n  }\r\n\r\n  /**\r\n   * Returns an instance's class value in internal format. (ie. as a\r\n   * floating-point number)\r\n   *\r\n   * @return the corresponding value as a double (If the \r\n   * corresponding attribute is nominal (or a string) then it returns the \r\n   * value's index as a double).\r\n   * @exception UnassignedClassException if the class is not set or the instance doesn't\r\n   * have access to a dataset \r\n   */\r\n  //@ requires classIndex() \u003e= 0;\r\n  public /*@pure@*/ double classValue() {\r\n    \r\n    if (classIndex() \u003c 0) {\r\n      throw new UnassignedClassException(\"Class is not set!\");\r\n    }\r\n    return value(classIndex());\r\n  }\r\n\r\n  /**\r\n   * Produces a shallow copy of this instance. The copy has\r\n   * access to the same dataset. (if you want to make a copy\r\n   * that doesn't have access to the dataset, use \r\n   * \u003ccode\u003enew Instance(instance)\u003c/code\u003e\r\n   *\r\n   * @return the shallow copy\r\n   */\r\n  //@ also ensures \\result != null;\r\n  //@ also ensures \\result instanceof Instance;\r\n  //@ also ensures ((Instance)\\result).m_Dataset == m_Dataset;\r\n  public /*@pure@*/ Object copy() {\r\n\r\n    Instance result = new Instance(this);\r\n    result.m_Dataset = m_Dataset;\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns the dataset this instance has access to. (ie. obtains\r\n   * information about attribute types from) Null if the instance\r\n   * doesn't have access to a dataset.\r\n   *\r\n   * @return the dataset the instance has accesss to\r\n   */\r\n  //@ ensures \\result == m_Dataset;\r\n  public /*@pure@*/ Instances dataset() {\r\n\r\n    return m_Dataset;\r\n  }\r\n\r\n  /**\r\n   * Deletes an attribute at the given position (0 to \r\n   * numAttributes() - 1). Only succeeds if the instance does not\r\n   * have access to any dataset because otherwise inconsistencies\r\n   * could be introduced.\r\n   *\r\n   * @param position the attribute's position\r\n   * @exception RuntimeException if the instance has access to a\r\n   * dataset \r\n   */\r\n  //@ requires m_Dataset != null;\r\n  public void deleteAttributeAt(int position) {\r\n\r\n    if (m_Dataset != null) {\r\n      throw new RuntimeException(\"Instance has access to a dataset!\");\r\n    }\r\n    forceDeleteAttributeAt(position);\r\n  }\r\n\r\n  /**\r\n   * Returns an enumeration of all the attributes.\r\n   *\r\n   * @return enumeration of all the attributes\r\n   * @exception UnassignedDatasetException if the instance doesn't\r\n   * have access to a dataset \r\n   */\r\n  //@ requires m_Dataset != null;\r\n  public /*@pure@*/ Enumeration enumerateAttributes() {\r\n\r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    }\r\n    return m_Dataset.enumerateAttributes();\r\n  }\r\n\r\n  /**\r\n   * Tests if the headers of two instances are equivalent.\r\n   *\r\n   * @param inst another instance\r\n   * @return true if the header of the given instance is \r\n   * equivalent to this instance's header\r\n   * @exception UnassignedDatasetException if instance doesn't have access to any\r\n   * dataset\r\n   */\r\n  //@ requires m_Dataset != null;\r\n  public /*@pure@*/ boolean equalHeaders(Instance inst) {\r\n\r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    }\r\n    return m_Dataset.equalHeaders(inst.m_Dataset);\r\n  }\r\n\r\n  /**\r\n   * Tests whether an instance has a missing value. Skips the class attribute if set.\r\n   * @return true if instance has a missing value.\r\n   * @exception UnassignedDatasetException if instance doesn't have access to any\r\n   * dataset\r\n   */\r\n  //@ requires m_Dataset != null;\r\n  public /*@pure@*/ boolean hasMissingValue() {\r\n    \r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    }\r\n    for (int i = 0; i \u003c numAttributes(); i++) {\r\n      if (i != classIndex()) {\r\n\tif (isMissing(i)) {\r\n\t  return true;\r\n\t}\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  \r\n  /**\r\n   * Inserts an attribute at the given position (0 to \r\n   * numAttributes()). Only succeeds if the instance does not\r\n   * have access to any dataset because otherwise inconsistencies\r\n   * could be introduced.\r\n   *\r\n   * @param position the attribute's position\r\n   * @exception RuntimeException if the instance has accesss to a\r\n   * dataset\r\n   * @exception IllegalArgumentException if the position is out of range\r\n   */\r\n  //@ requires m_Dataset == null;\r\n  //@ requires 0 \u003c= position \u0026\u0026 position \u003c= numAttributes();\r\n  public void insertAttributeAt(int position) {\r\n\r\n    if (m_Dataset != null) {\r\n      throw new RuntimeException(\"Instance has accesss to a dataset!\");\r\n    }\r\n    if ((position \u003c 0) ||\r\n\t(position \u003e numAttributes())) {\r\n      throw new IllegalArgumentException(\"Can't insert attribute: index out \"+\r\n                                         \"of range\");\r\n    }\r\n    forceInsertAttributeAt(position);\r\n  }\r\n\r\n  /**\r\n   * Tests if a specific value is \"missing\".\r\n   *\r\n   * @param attIndex the attribute's index\r\n     * @return True if it is missing.\r\n   */\r\n  public /*@pure@*/ boolean isMissing(int attIndex) {\r\n\r\n    if (Double.isNaN(m_AttValues[attIndex])) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Tests if a specific value is \"missing\". Does\r\n   * the same thing as isMissing() if applied to an Instance.\r\n   *\r\n   * @param indexOfIndex the index of the attribute's index\r\n     * @return  true if it is missing.\r\n   */\r\n  public /*@pure@*/ boolean isMissingSparse(int indexOfIndex) {\r\n\r\n    if (Double.isNaN(m_AttValues[indexOfIndex])) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Tests if a specific value is \"missing\".\r\n   * The given attribute has to belong to a dataset.\r\n   *\r\n   * @param att the attribute\r\n     * @return True if it is missing.\r\n   */\r\n  public /*@pure@*/ boolean isMissing(Attribute att) {\r\n\r\n    return isMissing(att.index());\r\n  }\r\n\r\n  /**\r\n   * Tests if the given value codes \"missing\".\r\n   *\r\n   * @param val the value to be tested\r\n   * @return true if val codes \"missing\"\r\n   */\r\n  public static /*@pure@*/ boolean isMissingValue(double val) {\r\n\r\n    return Double.isNaN(val);\r\n  }\r\n\r\n  /**\r\n   * Merges this instance with the given instance and returns\r\n   * the result. Dataset is set to null.\r\n   *\r\n   * @param inst the instance to be merged with this one\r\n   * @return the merged instances\r\n   */\r\n  public Instance mergeInstance(Instance inst) {\r\n\r\n    int m = 0;\r\n    double [] newVals = new double[numAttributes() + inst.numAttributes()];\r\n    for (int j = 0; j \u003c numAttributes(); j++, m++) {\r\n      newVals[m] = value(j);\r\n    }\r\n    for (int j = 0; j \u003c inst.numAttributes(); j++, m++) {\r\n      newVals[m] = inst.value(j);\r\n    }\r\n    return new Instance(1.0, newVals);\r\n  }\r\n\r\n  /**\r\n   * Returns the double that codes \"missing\".\r\n   *\r\n   * @return the double that codes \"missing\"\r\n   */\r\n  public /*@pure@*/ static double missingValue() {\r\n\r\n    return MISSING_VALUE;\r\n  }\r\n\r\n  /**\r\n   * Returns the number of attributes.\r\n   *\r\n   * @return the number of attributes as an integer\r\n   */\r\n  //@ ensures \\result == m_AttValues.length;\r\n  public /*@pure@*/ int numAttributes() {\r\n\r\n    return m_AttValues.length;\r\n  }\r\n\r\n  /**\r\n   * Returns the number of class labels.\r\n   *\r\n   * @return the number of class labels as an integer if the \r\n   * class attribute is nominal, 1 otherwise.\r\n   * @exception UnassignedDatasetException if instance doesn't have access to any\r\n   * dataset\r\n   */\r\n  //@ requires m_Dataset != null;\r\n  public /*@pure@*/ int numClasses() {\r\n    \r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    }\r\n    return m_Dataset.numClasses();\r\n  }\r\n\r\n  /**\r\n   * Returns the number of values present. Always the same as numAttributes().\r\n   *\r\n   * @return the number of values\r\n   */\r\n  //@ ensures \\result == m_AttValues.length;\r\n  public /*@pure@*/ int numValues() {\r\n\r\n    return m_AttValues.length;\r\n  }\r\n\r\n  /** \r\n   * Replaces all missing values in the instance with the\r\n   * values contained in the given array. A deep copy of\r\n   * the vector of attribute values is performed before the\r\n   * values are replaced.\r\n   *\r\n   * @param array containing the means and modes\r\n   * @exception IllegalArgumentException if numbers of attributes are unequal\r\n   */\r\n  public void replaceMissingValues(double[] array) {\r\n\t \r\n    if ((array == null) || \r\n\t(array.length != m_AttValues.length)) {\r\n      throw new IllegalArgumentException(\"Unequal number of attributes!\");\r\n    }\r\n    freshAttributeVector();\r\n    for (int i = 0; i \u003c m_AttValues.length; i++) {\r\n      if (isMissing(i)) {\r\n\tm_AttValues[i] = array[i];\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the class value of an instance to be \"missing\". A deep copy of\r\n   * the vector of attribute values is performed before the\r\n   * value is set to be missing.\r\n   *\r\n   * @exception UnassignedClassException if the class is not set\r\n   * @exception UnassignedDatasetException if the instance doesn't\r\n   * have access to a dataset\r\n   */\r\n  //@ requires classIndex() \u003e= 0;\r\n  public void setClassMissing() {\r\n\r\n    if (classIndex() \u003c 0) {\r\n      throw new UnassignedClassException(\"Class is not set!\");\r\n    }\r\n    setMissing(classIndex());\r\n  }\r\n\r\n  /**\r\n   * Sets the class value of an instance to the given value (internal\r\n   * floating-point format).  A deep copy of the vector of attribute\r\n   * values is performed before the value is set.\r\n   *\r\n   * @param value the new attribute value (If the corresponding\r\n   * attribute is nominal (or a string) then this is the new value's\r\n   * index as a double).  \r\n   * @exception UnassignedClassException if the class is not set\r\n   */\r\n  //@ requires classIndex() \u003e= 0;\r\n  public void setClassValue(double value) {\r\n\r\n    if (classIndex() \u003c 0) {\r\n      throw new UnassignedClassException(\"Class is not set!\");\r\n    }\r\n    setValue(classIndex(), value);\r\n  }\r\n\r\n  /**\r\n   * Sets the class value of an instance to the given value. A deep\r\n   * copy of the vector of attribute values is performed before the\r\n   * value is set.\r\n   *\r\n   * @param value the new class value (If the class\r\n   * is a string attribute and the value can't be found,\r\n   * the value is added to the attribute).\r\n   * @exception UnassignedClassException if the class is not set\r\n   * @exception UnassignedDatasetException if the dataset is not set\r\n   * @exception IllegalArgumentException if the attribute is not\r\n   * nominal or a string, or the value couldn't be found for a nominal\r\n   * attribute \r\n   */\r\n  //@ requires classIndex() \u003e= 0;\r\n  public final void setClassValue(String value) {\r\n\r\n    if (classIndex() \u003c 0) {\r\n      throw new UnassignedClassException(\"Class is not set!\");\r\n    }\r\n    setValue(classIndex(), value);\r\n  }\r\n\r\n  /**\r\n   * Sets the reference to the dataset. Does not check if the instance\r\n   * is compatible with the dataset. Note: the dataset does not know\r\n   * about this instance. If the structure of the dataset's header\r\n   * gets changed, this instance will not be adjusted automatically.\r\n   *\r\n   * @param instances the reference to the dataset \r\n   */\r\n  public final void setDataset(Instances instances) {\r\n    \r\n    m_Dataset = instances;\r\n  }\r\n\r\n  /**\r\n   * Sets a specific value to be \"missing\". Performs a deep copy\r\n   * of the vector of attribute values before the value is set to\r\n   * be missing.\r\n   *\r\n   * @param attIndex the attribute's index\r\n   */\r\n  public final void setMissing(int attIndex) {\r\n\r\n    setValue(attIndex, MISSING_VALUE);\r\n  }\r\n\r\n  /**\r\n   * Sets a specific value to be \"missing\". Performs a deep copy\r\n   * of the vector of attribute values before the value is set to\r\n   * be missing. The given attribute has to belong to a dataset.\r\n   *\r\n   * @param att the attribute\r\n   */\r\n  public final void setMissing(Attribute att) {\r\n\r\n    setMissing(att.index());\r\n  }\r\n\r\n  /**\r\n   * Sets a specific value in the instance to the given value \r\n   * (internal floating-point format). Performs a deep copy\r\n   * of the vector of attribute values before the value is set.\r\n   *\r\n   * @param attIndex the attribute's index \r\n   * @param value the new attribute value (If the corresponding\r\n   * attribute is nominal (or a string) then this is the new value's\r\n   * index as a double).  \r\n   */\r\n  public void setValue(int attIndex, double value) {\r\n    \r\n    freshAttributeVector();\r\n    m_AttValues[attIndex] = value;\r\n  }\r\n\r\n  /**\r\n   * Sets a specific value in the instance to the given value \r\n   * (internal floating-point format). Performs a deep copy\r\n   * of the vector of attribute values before the value is set.\r\n   * Does exactly the same thing as setValue().\r\n   *\r\n   * @param indexOfIndex the index of the attribute's index \r\n   * @param value the new attribute value (If the corresponding\r\n   * attribute is nominal (or a string) then this is the new value's\r\n   * index as a double).  \r\n   */\r\n  public void setValueSparse(int indexOfIndex, double value) {\r\n    \r\n    freshAttributeVector();\r\n    m_AttValues[indexOfIndex] = value;\r\n  }\r\n\r\n  /**\r\n   * Sets a value of a nominal or string attribute to the given\r\n   * value. Performs a deep copy of the vector of attribute values\r\n   * before the value is set.\r\n   *\r\n   * @param attIndex the attribute's index\r\n   * @param value the new attribute value (If the attribute\r\n   * is a string attribute and the value can't be found,\r\n   * the value is added to the attribute).\r\n   * @exception UnassignedDatasetException if the dataset is not set\r\n   * @exception IllegalArgumentException if the selected\r\n   * attribute is not nominal or a string, or the supplied value couldn't \r\n   * be found for a nominal attribute \r\n   */\r\n  //@ requires m_Dataset != null;\r\n  public final void setValue(int attIndex, String value) {\r\n    \r\n    int valIndex;\r\n\r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    }\r\n    if (!attribute(attIndex).isNominal() \u0026\u0026\r\n\t!attribute(attIndex).isString()) {\r\n      throw new IllegalArgumentException(\"Attribute neither nominal nor string!\");\r\n    }\r\n    valIndex = attribute(attIndex).indexOfValue(value);\r\n    if (valIndex == -1) {\r\n      if (attribute(attIndex).isNominal()) {\r\n\tthrow new IllegalArgumentException(\"Value not defined for given nominal attribute!\");\r\n      } else {\r\n\tattribute(attIndex).forceAddValue(value);\r\n\tvalIndex = attribute(attIndex).indexOfValue(value);\r\n      }\r\n    }\r\n    setValue(attIndex, (double)valIndex); \r\n  }\r\n\r\n  /**\r\n   * Sets a specific value in the instance to the given value\r\n   * (internal floating-point format). Performs a deep copy of the\r\n   * vector of attribute values before the value is set, so if you are\r\n   * planning on calling setValue many times it may be faster to\r\n   * create a new instance using toDoubleArray.  The given attribute\r\n   * has to belong to a dataset.\r\n   *\r\n   * @param att the attribute \r\n   * @param value the new attribute value (If the corresponding\r\n   * attribute is nominal (or a string) then this is the new value's\r\n   * index as a double).  \r\n   */\r\n  public final void setValue(Attribute att, double value) {\r\n\r\n    setValue(att.index(), value);\r\n  }\r\n\r\n  /**\r\n   * Sets a value of an nominal or string attribute to the given\r\n   * value. Performs a deep copy of the vector of attribute values\r\n   * before the value is set, so if you are planning on calling setValue many\r\n   * times it may be faster to create a new instance using toDoubleArray.\r\n   * The given attribute has to belong to a dataset.\r\n   *\r\n   * @param att the attribute\r\n   * @param value the new attribute value (If the attribute\r\n   * is a string attribute and the value can't be found,\r\n   * the value is added to the attribute).\r\n   * @exception IllegalArgumentException if the the attribute is not\r\n   * nominal or a string, or the value couldn't be found for a nominal\r\n   * attribute \r\n   */\r\n  public final void setValue(Attribute att, String value) {\r\n\r\n    if (!att.isNominal() \u0026\u0026\r\n\t!att.isString()) {\r\n      throw new IllegalArgumentException(\"Attribute neither nominal nor string!\");\r\n    }\r\n    int valIndex = att.indexOfValue(value);\r\n    if (valIndex == -1) {\r\n      if (att.isNominal()) {\r\n\tthrow new IllegalArgumentException(\"Value not defined for given nominal attribute!\");\r\n      } else {\r\n\tatt.forceAddValue(value);\r\n\tvalIndex = att.indexOfValue(value);\r\n      }\r\n    }\r\n    setValue(att.index(), (double)valIndex);\r\n  }\r\n\r\n  /**\r\n   * Sets the weight of an instance.\r\n   *\r\n   * @param weight the weight\r\n   */\r\n  public final void setWeight(double weight) {\r\n\r\n    m_Weight = weight;\r\n  }\r\n\r\n  /** \r\n   * Returns the relational value of a relational attribute.\r\n   *\r\n   * @param attIndex the attribute's index\r\n   * @return the corresponding relation as an Instances object\r\n   * @exception IllegalArgumentException if the attribute is not a\r\n   * relation-valued attribute\r\n   * @exception UnassignedDatasetException if the instance doesn't belong\r\n   * to a dataset.\r\n   */\r\n  //@ requires m_Dataset != null;\r\n  public final /*@pure@*/ Instances relationalValue(int attIndex) {\r\n\r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    } \r\n    return relationalValue(m_Dataset.attribute(attIndex));\r\n  }\r\n\r\n\r\n  /** \r\n   * Returns the relational value of a relational attribute.\r\n   *\r\n   * @param att the attribute's index\r\n   * @return the corresponding relation as an Instances object\r\n   * @exception IllegalArgumentException if the attribute is not a\r\n   * relation-valued attribute\r\n   * @exception UnassignedDatasetException if the instance doesn't belong\r\n   * to a dataset.\r\n   */\r\n  public final /*@pure@*/ Instances relationalValue(Attribute att) {\r\n\r\n    int attIndex = att.index();\r\n    if (att.isRelationValued()) {\r\n      return att.relation((int) value(attIndex));\r\n    } else {\r\n      throw new IllegalArgumentException(\"Attribute isn't relation-valued!\");\r\n    }\r\n  }\r\n\r\n  /** \r\n   * Returns the value of a nominal, string, date, or relational attribute\r\n   * for the instance as a string.\r\n   *\r\n   * @param attIndex the attribute's index\r\n   * @return the value as a string\r\n   * @exception IllegalArgumentException if the attribute is not a nominal,\r\n   * string, date, or relation-valued attribute.\r\n   * @exception UnassignedDatasetException if the instance doesn't belong\r\n   * to a dataset.\r\n   */\r\n  //@ requires m_Dataset != null;\r\n  public final /*@pure@*/ String stringValue(int attIndex) {\r\n\r\n    if (m_Dataset == null) {\r\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n    } \r\n    return stringValue(m_Dataset.attribute(attIndex));\r\n  }\r\n\r\n\r\n  /** \r\n   * Returns the value of a nominal, string, date, or relational attribute\r\n   * for the instance as a string.\r\n   *\r\n   * @param att the attribute's index\r\n   * @return the value as a string\r\n   * @exception IllegalArgumentException if the attribute is not a nominal,\r\n   * string, date, or relation-valued attribute.\r\n   * @exception UnassignedDatasetException if the instance doesn't belong\r\n   * to a dataset.\r\n   */\r\n  public final /*@pure@*/ String stringValue(Attribute att) {\r\n\r\n    int attIndex = att.index();\r\n    switch (att.type()) {\r\n    case Attribute.NOMINAL:\r\n    case Attribute.STRING:\r\n      return att.value((int) value(attIndex));\r\n    case Attribute.DATE:\r\n      return att.formatDate(value(attIndex));\r\n    case Attribute.RELATIONAL:\r\n      return att.relation((int) value(attIndex)).stringWithoutHeader();\r\n    default:\r\n      throw new IllegalArgumentException(\"Attribute isn't nominal, string or date!\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the values of each attribute as an array of doubles.\r\n   *\r\n   * @return an array containing all the instance attribute values\r\n   */\r\n  public double[] toDoubleArray() {\r\n\r\n    double[] newValues = new double[m_AttValues.length];\r\n    System.arraycopy(m_AttValues, 0, newValues, 0, \r\n\t\t     m_AttValues.length);\r\n    return newValues;\r\n  }\r\n\r\n  /**\r\n   * Returns the description of one instance. If the instance\r\n   * doesn't have access to a dataset, it returns the internal\r\n   * floating-point values. Quotes string\r\n   * values that contain whitespace characters.\r\n   *\r\n   * @return the instance's description as a string\r\n   */\r\n  public String toString() {\r\n\r\n    StringBuffer text = new StringBuffer();\r\n    \r\n    for (int i = 0; i \u003c m_AttValues.length; i++) {\r\n      if (i \u003e 0) text.append(\",\");\r\n      text.append(toString(i));\r\n    }\r\n\r\n    return text.toString();\r\n  }\r\n\r\n  /**\r\n   * Returns the description of one value of the instance as a \r\n   * string. If the instance doesn't have access to a dataset, it \r\n   * returns the internal floating-point value. Quotes string\r\n   * values that contain whitespace characters, or if they\r\n   * are a question mark.\r\n   *\r\n   * @param attIndex the attribute's index\r\n   * @return the value's description as a string\r\n   */\r\n  public final /*@pure@*/ String toString(int attIndex) {\r\n\r\n   StringBuffer text = new StringBuffer();\r\n   \r\n   if (isMissing(attIndex)) {\r\n     text.append(\"?\");\r\n   } else {\r\n     if (m_Dataset == null) {\r\n       text.append(Utils.doubleToString(m_AttValues[attIndex],6));\r\n     } else {\r\n       switch (m_Dataset.attribute(attIndex).type()) {\r\n       case Attribute.NOMINAL:\r\n       case Attribute.STRING:\r\n       case Attribute.DATE:\r\n       case Attribute.RELATIONAL:\r\n         text.append(Utils.quote(stringValue(attIndex)));\r\n         break;\r\n       case Attribute.REAL:\r\n\t text.append(Utils.doubleToString(value(attIndex),6));\r\n         break;\r\n       default:\r\n         throw new IllegalStateException(\"Unknown attribute type\");\r\n       }\r\n     }\r\n   }\r\n   return text.toString();\r\n  }\r\n\r\n  /**\r\n   * Returns the description of one value of the instance as a \r\n   * string. If the instance doesn't have access to a dataset it \r\n   * returns the internal floating-point value. Quotes string\r\n   * values that contain whitespace characters, or if they\r\n   * are a question mark.\r\n   * The given attribute has to belong to a dataset.\r\n   *\r\n   * @param att the attribute\r\n   * @return the value's description as a string\r\n   */\r\n  public final String toString(Attribute att) {\r\n   \r\n   return toString(att.index());\r\n  }\r\n\r\n  /**\r\n   * Returns an instance's attribute value in internal format.\r\n   *\r\n   * @param attIndex the attribute's index\r\n   * @return the specified value as a double (If the corresponding\r\n   * attribute is nominal (or a string) then it returns the value's index as a \r\n   * double).\r\n   */\r\n  public /*@pure@*/ double value(int attIndex) {\r\n\r\n    return m_AttValues[attIndex];\r\n  }\r\n\r\n  /**\r\n   * Returns an instance's attribute value in internal format.\r\n   * Does exactly the same thing as value() if applied to an Instance.\r\n   *\r\n   * @param indexOfIndex the index of the attribute's index\r\n   * @return the specified value as a double (If the corresponding\r\n   * attribute is nominal (or a string) then it returns the value's index as a \r\n   * double).\r\n   */\r\n  public /*@pure@*/ double valueSparse(int indexOfIndex) {\r\n\r\n    return m_AttValues[indexOfIndex];\r\n  }  \r\n\r\n  /**\r\n   * Returns an instance's attribute value in internal format.\r\n   * The given attribute has to belong to a dataset.\r\n   *\r\n   * @param att the attribute\r\n   * @return the specified value as a double (If the corresponding\r\n   * attribute is nominal (or a string) then it returns the value's index as a\r\n   * double).\r\n   */\r\n  public /*@pure@*/ double value(Attribute att) {\r\n\r\n    return value(att.index());\r\n  }\r\n\r\n  /**\r\n   * Returns the instance's weight.\r\n   *\r\n   * @return the instance's weight as a double\r\n   */\r\n  public final /*@pure@*/ double weight() {\r\n\r\n    return m_Weight;\r\n  }\r\n\r\n  /**\r\n   * Deletes an attribute at the given position (0 to \r\n   * numAttributes() - 1).\r\n   *\r\n   * @param pos the attribute's position\r\n   */\r\n\r\n  void forceDeleteAttributeAt(int position) {\r\n\r\n    double[] newValues = new double[m_AttValues.length - 1];\r\n\r\n    System.arraycopy(m_AttValues, 0, newValues, 0, position);\r\n    if (position \u003c m_AttValues.length - 1) {\r\n      System.arraycopy(m_AttValues, position + 1, \r\n\t\t       newValues, position, \r\n\t\t       m_AttValues.length - (position + 1));\r\n    }\r\n    m_AttValues = newValues;\r\n  }\r\n\r\n  /**\r\n   * Inserts an attribute at the given position\r\n   * (0 to numAttributes()) and sets its value to be missing. \r\n   *\r\n   * @param pos the attribute's position\r\n   */\r\n  void forceInsertAttributeAt(int position)  {\r\n\r\n    double[] newValues = new double[m_AttValues.length + 1];\r\n\r\n    System.arraycopy(m_AttValues, 0, newValues, 0, position);\r\n    newValues[position] = MISSING_VALUE;\r\n    System.arraycopy(m_AttValues, position, newValues, \r\n\t\t     position + 1, m_AttValues.length - position);\r\n    m_AttValues = newValues;\r\n  }\r\n\r\n  /**\r\n   * Private constructor for subclasses. Does nothing.\r\n   */\r\n  protected Instance() {\r\n  }\r\n\r\n  /**\r\n   * Clones the attribute vector of the instance and\r\n   * overwrites it with the clone.\r\n   */\r\n  private void freshAttributeVector() {\r\n\r\n    m_AttValues = toDoubleArray();\r\n  }\r\n\r\n  /**\r\n   * Main method for testing this class.\r\n     * @param options main args. requires options != null\r\n   */\r\n  //@ requires options != null;\r\n  public static void main(String[] options) {\r\n\r\n    try {\r\n\r\n      // Create numeric attributes \"length\" and \"weight\"\r\n      Attribute length = new Attribute(\"length\");\r\n      Attribute weight = new Attribute(\"weight\");\r\n      \r\n      // Create vector to hold nominal values \"first\", \"second\", \"third\" \r\n      FastVector my_nominal_values = new FastVector(3); \r\n      my_nominal_values.addElement(\"first\"); \r\n      my_nominal_values.addElement(\"second\"); \r\n      my_nominal_values.addElement(\"third\"); \r\n      \r\n      // Create nominal attribute \"position\" \r\n      Attribute position = new Attribute(\"position\", my_nominal_values);\r\n      \r\n      // Create vector of the above attributes \r\n      FastVector attributes = new FastVector(3);\r\n      attributes.addElement(length);\r\n      attributes.addElement(weight);\r\n      attributes.addElement(position);\r\n      \r\n      // Create the empty dataset \"race\" with above attributes\r\n      Instances race = new Instances(\"race\", attributes, 0);\r\n      \r\n      // Make position the class attribute\r\n      race.setClassIndex(position.index());\r\n      \r\n      // Create empty instance with three attribute values\r\n      Instance inst = new Instance(3);\r\n      \r\n      // Set instance's values for the attributes \"length\", \"weight\", and \"position\"\r\n      inst.setValue(length, 5.3);\r\n      inst.setValue(weight, 300);\r\n      inst.setValue(position, \"first\");\r\n      \r\n      // Set instance's dataset to be the dataset \"race\"\r\n      inst.setDataset(race);\r\n      \r\n      // Print the instance\r\n      System.out.println(\"The instance: \" + inst);\r\n      \r\n      // Print the first attribute\r\n      System.out.println(\"First attribute: \" + inst.attribute(0));\r\n      \r\n      // Print the class attribute\r\n      System.out.println(\"Class attribute: \" + inst.classAttribute());\r\n      \r\n      // Print the class index\r\n      System.out.println(\"Class index: \" + inst.classIndex());\r\n      \r\n      // Say if class is missing\r\n      System.out.println(\"Class is missing: \" + inst.classIsMissing());\r\n      \r\n      // Print the instance's class value in internal format\r\n      System.out.println(\"Class value (internal format): \" + inst.classValue());\r\n      \r\n      // Print a shallow copy of this instance\r\n      Instance copy = (Instance) inst.copy();\r\n      System.out.println(\"Shallow copy: \" + copy);\r\n      \r\n      // Set dataset for shallow copy\r\n      copy.setDataset(inst.dataset());\r\n      System.out.println(\"Shallow copy with dataset set: \" + copy);\r\n      \r\n      // Unset dataset for copy, delete first attribute, and insert it again\r\n      copy.setDataset(null);\r\n      copy.deleteAttributeAt(0);\r\n      copy.insertAttributeAt(0);\r\n      copy.setDataset(inst.dataset());\r\n      System.out.println(\"Copy with first attribute deleted and inserted: \" + copy); \r\n      \r\n      // Enumerate attributes (leaving out the class attribute)\r\n      System.out.println(\"Enumerating attributes (leaving out class):\");\r\n      Enumeration enu = inst.enumerateAttributes();\r\n      while (enu.hasMoreElements()) {\r\n\tAttribute att = (Attribute) enu.nextElement();\r\n\tSystem.out.println(att);\r\n      }\r\n      \r\n      // Headers are equivalent?\r\n      System.out.println(\"Header of original and copy equivalent: \" +\r\n\t\t\t inst.equalHeaders(copy));\r\n\r\n      // Test for missing values\r\n      System.out.println(\"Length of copy missing: \" + copy.isMissing(length));\r\n      System.out.println(\"Weight of copy missing: \" + copy.isMissing(weight.index()));\r\n      System.out.println(\"Length of copy missing: \" + \r\n\t\t\t Instance.isMissingValue(copy.value(length)));\r\n      System.out.println(\"Missing value coded as: \" + Instance.missingValue());\r\n\r\n      // Prints number of attributes and classes\r\n      System.out.println(\"Number of attributes: \" + copy.numAttributes());\r\n      System.out.println(\"Number of classes: \" + copy.numClasses());\r\n\r\n      // Replace missing values\r\n      double[] meansAndModes = {2, 3, 0};\r\n      copy.replaceMissingValues(meansAndModes);\r\n      System.out.println(\"Copy with missing value replaced: \" + copy);\r\n\r\n      // Setting and getting values and weights\r\n      copy.setClassMissing();\r\n      System.out.println(\"Copy with missing class: \" + copy);\r\n      copy.setClassValue(0);\r\n      System.out.println(\"Copy with class value set to first value: \" + copy);\r\n      copy.setClassValue(\"third\");\r\n      System.out.println(\"Copy with class value set to \\\"third\\\": \" + copy);\r\n      copy.setMissing(1);\r\n      System.out.println(\"Copy with second attribute set to be missing: \" + copy);\r\n      copy.setMissing(length);\r\n      System.out.println(\"Copy with length set to be missing: \" + copy);\r\n      copy.setValue(0, 0);\r\n      System.out.println(\"Copy with first attribute set to 0: \" + copy);\r\n      copy.setValue(weight, 1);\r\n      System.out.println(\"Copy with weight attribute set to 1: \" + copy);\r\n      copy.setValue(position, \"second\");\r\n      System.out.println(\"Copy with position set to \\\"second\\\": \" + copy);\r\n      copy.setValue(2, \"first\");\r\n      System.out.println(\"Copy with last attribute set to \\\"first\\\": \" + copy);\r\n      System.out.println(\"Current weight of instance copy: \" + copy.weight());\r\n      copy.setWeight(2);\r\n      System.out.println(\"Current weight of instance copy (set to 2): \" + copy.weight());\r\n      System.out.println(\"Last value of copy: \" + copy.toString(2));\r\n      System.out.println(\"Value of position for copy: \" + copy.toString(position));\r\n      System.out.println(\"Last value of copy (internal format): \" + copy.value(2));\r\n      System.out.println(\"Value of position for copy (internal format): \" + \r\n\t\t\t copy.value(position));\r\n    } catch (Exception e) {\r\n      e.printStackTrace();\r\n    }\r\n  }\r\n\r\n   \r\n}\r\n",
        "name": "Instance.java",
        "path": "src/keel/Algorithms/ImbalancedClassification/Resampling/SMOTE_RSB/Rough_Sets/Instance.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/ImbalancedClassification/Resampling/SMOTE_RSB/Rough_Sets/Instance.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 72,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Dataset == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 88,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Dataset == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 103,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires numAttributes \u003e 0;    // Or maybe == 0 is okay too?\r"
        },
        {
          "limitHit": false,
          "lineNumber": 104,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Dataset == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 123,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 141,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 157,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 172,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 189,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 208,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 242,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Dataset;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 258,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 274,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 292,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 307,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 335,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 336,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= position \u0026\u0026 position \u003c= numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 437,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_AttValues.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 451,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 465,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_AttValues.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 503,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 522,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 545,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 638,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 733,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 774,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1005,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires options != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 173,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  \\result == m_Dataset.classIndex();\r"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "package keel.Algorithms.ImbalancedClassification.Resampling.SMOTE_RSB.Rough_Sets;\r\n\r\n\r\nimport java.io.Serializable;\r\nimport java.util.Enumeration;\r\n\r\n/**\r\n * Implements a fast vector class without synchronized\r\n * methods. Replaces java.util.Vector. (Synchronized methods tend to\r\n * be slow.)\r\n *\r\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\r\n * @version $Revision: 1.1 $ */\r\npublic class FastVector implements Copyable, Serializable {\r\n\r\n  /**\r\n   * Class for enumerating the vector's elements.\r\n   */\r\n  public class FastVectorEnumeration implements Enumeration {\r\n\r\n    /** The counter. */\r\n    private int m_Counter;\r\n    // These JML commands say how m_Counter implements Enumeration\r\n    //@ in moreElements;\r\n    //@ private represents moreElements = m_Counter \u003c m_Vector.size();\r\n    //@ private invariant 0 \u003c= m_Counter \u0026\u0026 m_Counter \u003c= m_Vector.size();\r\n\r\n    /** The vector. */\r\n    private /*@non_null@*/ FastVector m_Vector;\r\n\r\n    /** Special element. Skipped during enumeration. */\r\n    private int m_SpecialElement;\r\n    //@ private invariant -1 \u003c= m_SpecialElement;\r\n    //@ private invariant m_SpecialElement \u003c m_Vector.size();\r\n    //@ private invariant m_SpecialElement\u003e=0 ==\u003e m_Counter!=m_SpecialElement;\r\n\r\n    /**\r\n     * Constructs an enumeration.\r\n     *\r\n     * @param vector the vector which is to be enumerated\r\n     */\r\n    public FastVectorEnumeration(/*@non_null@*/FastVector vector) {\r\n\r\n      m_Counter = 0;\r\n      m_Vector = vector;\r\n      m_SpecialElement = -1;\r\n    }\r\n\r\n    /**\r\n     * Constructs an enumeration with a special element.\r\n     * The special element is skipped during the enumeration.\r\n     *\r\n     * @param vector the vector which is to be enumerated\r\n     * @param special the index of the special element\r\n     */\r\n    //@ requires 0 \u003c= special \u0026\u0026 special \u003c vector.size();\r\n    public FastVectorEnumeration(/*@non_null@*/FastVector vector, int special){\r\n\r\n      m_Vector = vector;\r\n      m_SpecialElement = special;\r\n      if (special == 0) {\r\n\tm_Counter = 1;\r\n      } else {\r\n\tm_Counter = 0;\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * Tests if there are any more elements to enumerate.\r\n     *\r\n     * @return true if there are some elements left\r\n     */\r\n    public final /*@pure@*/ boolean hasMoreElements() {\r\n\r\n      if (m_Counter \u003c m_Vector.size()) {\r\n\treturn true;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Returns the next element.\r\n     *\r\n     * @return the next element to be enumerated\r\n     */\r\n    //@ also requires hasMoreElements();\r\n    public final Object nextElement() {\r\n  \r\n      Object result = m_Vector.elementAt(m_Counter);\r\n\r\n      m_Counter++;\r\n      if (m_Counter == m_SpecialElement) {\r\n\tm_Counter++;\r\n      }\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /** The array of objects. */\r\n  private /*@spec_public@*/ Object[] m_Objects;\r\n  //@ invariant m_Objects != null;\r\n  //@ invariant m_Objects.length \u003e= 0;\r\n\r\n  /** The current size; */\r\n  private /*@spec_public@*/ int m_Size = 0;\r\n  //@ invariant 0 \u003c= m_Size;\r\n  //@ invariant m_Size \u003c= m_Objects.length;\r\n\r\n  /** The capacity increment */\r\n  private /*@spec_public@*/ int m_CapacityIncrement = 1;\r\n  //@ invariant 1 \u003c= m_CapacityIncrement;\r\n  \r\n  /** The capacity multiplier. */\r\n  private /*@spec_public@*/ int m_CapacityMultiplier = 2;\r\n  //@ invariant 1 \u003c= m_CapacityMultiplier;\r\n\r\n  // Make sure the size will increase...\r\n  //@ invariant 3 \u003c= m_CapacityMultiplier + m_CapacityIncrement;\r\n\r\n  /**\r\n   * Constructs an empty vector with initial\r\n   * capacity zero.\r\n   */\r\n  public FastVector() {\r\n  \r\n    m_Objects = new Object[0];\r\n  }\r\n\r\n  /**\r\n   * Constructs a vector with the given capacity.\r\n   *\r\n   * @param capacity the vector's initial capacity\r\n   */\r\n  //@ requires capacity \u003e= 0;\r\n  public FastVector(int capacity) {\r\n\r\n    m_Objects = new Object[capacity];\r\n  }\r\n\r\n  /**\r\n   * Adds an element to this vector. Increases its\r\n   * capacity if its not large enough.\r\n   *\r\n   * @param element the element to add\r\n   */\r\n  public final void addElement(Object element) {\r\n\r\n    Object[] newObjects;\r\n\r\n    if (m_Size == m_Objects.length) {\r\n      newObjects = new Object[m_CapacityMultiplier *\r\n\t\t\t     (m_Objects.length +\r\n\t\t\t      m_CapacityIncrement)];\r\n      System.arraycopy(m_Objects, 0, newObjects, 0, m_Size);\r\n      m_Objects = newObjects;\r\n    }\r\n    m_Objects[m_Size] = element;\r\n    m_Size++;\r\n  }\r\n\r\n  /**\r\n   * Returns the capacity of the vector.\r\n   *\r\n   * @return the capacity of the vector\r\n   */\r\n  //@ ensures \\result == m_Objects.length;\r\n  public final /*@pure@*/ int capacity() {\r\n  \r\n    return m_Objects.length;\r\n  }\r\n\r\n  /**\r\n   * Produces a shallow copy of this vector.\r\n   *\r\n   * @return the new vector\r\n   */\r\n  public final Object copy() {\r\n\r\n    FastVector copy = new FastVector(m_Objects.length);\r\n\r\n    copy.m_Size = m_Size;\r\n    copy.m_CapacityIncrement = m_CapacityIncrement;\r\n    copy.m_CapacityMultiplier = m_CapacityMultiplier;\r\n    System.arraycopy(m_Objects, 0, copy.m_Objects, 0, m_Size);\r\n    return copy;\r\n  }\r\n\r\n  /**\r\n   * Clones the vector and shallow copies all its elements.\r\n   * The elements have to implement the Copyable interface.\r\n   * \r\n   * @return the new vector\r\n   */\r\n  public final Object copyElements() {\r\n\r\n    FastVector copy = new FastVector(m_Objects.length);\r\n\r\n    copy.m_Size = m_Size;\r\n    copy.m_CapacityIncrement = m_CapacityIncrement;\r\n    copy.m_CapacityMultiplier = m_CapacityMultiplier;\r\n    for (int i = 0; i \u003c m_Size; i++) {\r\n      copy.m_Objects[i] = ((Copyable)m_Objects[i]).copy();\r\n    }\r\n    return copy;\r\n  }\r\n\r\n  /**\r\n   * Returns the element at the given position.\r\n   *\r\n   * @param index the element's index\r\n   * @return the element with the given index\r\n   */\r\n  //@ requires 0 \u003c= index;\r\n  //@ requires index \u003c m_Objects.length;\r\n  public final /*@pure@*/ Object elementAt(int index) {\r\n\r\n    return m_Objects[index];\r\n  }\r\n\r\n  /**\r\n   * Returns an enumeration of this vector.\r\n   *\r\n   * @return an enumeration of this vector\r\n   */\r\n  public final /*@pure@*/ Enumeration elements() {\r\n  \r\n    return new FastVectorEnumeration(this);\r\n  }\r\n\r\n  /**\r\n   * Returns an enumeration of this vector, skipping the\r\n   * element with the given index.\r\n   *\r\n   * @param index the element to skip\r\n   * @return an enumeration of this vector\r\n   */\r\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();\r\n  public final /*@pure@*/ Enumeration elements(int index) {\r\n  \r\n    return new FastVectorEnumeration(this, index);\r\n  }\r\n\r\n    /**\r\n     * Checks if the object given as argument is in the vector.\r\n     * @param o object given.\r\n     * @return True if the object is contained, false otherwise\r\n     */\r\n  public /*@pure@*/ boolean contains(Object o) {\r\n      if(o==null)\r\n\t  return false;\r\n\r\n      for(int i=0; i\u003cm_Objects.length; i++) \r\n\t  if(o.equals(m_Objects[i]))\r\n\t      return true;\r\n      \r\n      return false;\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns the first element of the vector.\r\n   *\r\n   * @return the first element of the vector\r\n   */\r\n  //@ requires m_Size \u003e 0;\r\n  public final /*@pure@*/ Object firstElement() {\r\n\r\n    return m_Objects[0];\r\n  }\r\n\r\n  /**\r\n   * Searches for the first occurence of the given argument, \r\n   * testing for equality using the equals method. \r\n   *\r\n   * @param element the element to be found\r\n   * @return the index of the first occurrence of the argument \r\n   * in this vector; returns -1 if the object is not found\r\n   */\r\n  public final /*@pure@*/ int indexOf(/*@non_null@*/ Object element) {\r\n\r\n    for (int i = 0; i \u003c m_Size; i++) {\r\n      if (element.equals(m_Objects[i])) {\r\n\treturn i;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Inserts an element at the given position.\r\n   *\r\n   * @param element the element to be inserted\r\n   * @param index the element's index\r\n   */\r\n  public final void insertElementAt(Object element, int index) {\r\n\r\n    Object[] newObjects;\r\n\r\n    if (m_Size \u003c m_Objects.length) {\r\n      System.arraycopy(m_Objects, index, m_Objects, index + 1, \r\n                       m_Size - index);\r\n      m_Objects[index] = element;\r\n    } else {\r\n      newObjects = new Object[m_CapacityMultiplier *\r\n\t\t\t     (m_Objects.length +\r\n\t\t\t      m_CapacityIncrement)];\r\n      System.arraycopy(m_Objects, 0, newObjects, 0, index);\r\n      newObjects[index] = element;\r\n      System.arraycopy(m_Objects, index, newObjects, index + 1,\r\n\t\t       m_Size - index);\r\n      m_Objects = newObjects;\r\n    }\r\n    m_Size++;\r\n  }\r\n\r\n  /**\r\n   * Returns the last element of the vector.\r\n   *\r\n   * @return the last element of the vector\r\n   */\r\n  //@ requires m_Size \u003e 0;\r\n  public final /*@pure@*/ Object lastElement() {\r\n\r\n    return m_Objects[m_Size - 1];\r\n  }\r\n\r\n  /**\r\n   * Deletes an element from this vector.\r\n   *\r\n   * @param index the index of the element to be deleted\r\n   */\r\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Size;\r\n  public final void removeElementAt(int index) {\r\n\r\n    System.arraycopy(m_Objects, index + 1, m_Objects, index, \r\n                     m_Size - index - 1);\r\n    m_Size--;\r\n  }\r\n\r\n  /**\r\n   * Removes all components from this vector and sets its \r\n   * size to zero. \r\n   */\r\n  public final void removeAllElements() {\r\n\r\n    m_Objects = new Object[m_Objects.length];\r\n    m_Size = 0;\r\n  }\r\n\r\n  /**\r\n   * Appends all elements of the supplied vector to this vector.\r\n   *\r\n   * @param toAppend the FastVector containing elements to append.\r\n   */\r\n  public final void appendElements(FastVector toAppend) {\r\n\r\n    setCapacity(size() + toAppend.size());\r\n    System.arraycopy(toAppend.m_Objects, 0, m_Objects, size(), toAppend.size());\r\n    m_Size = m_Objects.length;\r\n  }\r\n\r\n  /** \r\n   * Returns all the elements of this vector as an array\r\n   *\r\n   * @return an array containing all the elements of this vector\r\n   */\r\n  public final Object [] toArray() {\r\n\r\n    Object [] newObjects = new Object[size()];\r\n    System.arraycopy(m_Objects, 0, newObjects, 0, size());\r\n    return newObjects;\r\n  }\r\n\r\n  /**\r\n   * Sets the vector's capacity to the given value.\r\n   *\r\n   * @param capacity the new capacity\r\n   */\r\n  public final void setCapacity(int capacity) {\r\n\r\n    Object[] newObjects = new Object[capacity];\r\n   \r\n    System.arraycopy(m_Objects, 0, newObjects, 0, Math.min(capacity, m_Size));\r\n    m_Objects = newObjects;\r\n    if (m_Objects.length \u003c m_Size)\r\n      m_Size = m_Objects.length;\r\n  }\r\n\r\n  /**\r\n   * Sets the element at the given index.\r\n   *\r\n   * @param element the element to be put into the vector\r\n   * @param index the index at which the element is to be placed\r\n   */\r\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();\r\n  public final void setElementAt(Object element, int index) {\r\n\r\n    m_Objects[index] = element;\r\n  }\r\n\r\n  /**\r\n   * Returns the vector's current size.\r\n   *\r\n   * @return the vector's current size\r\n   */\r\n  //@ ensures \\result == m_Size;\r\n  public final /*@pure@*/ int size() {\r\n\r\n    return m_Size;\r\n  }\r\n\r\n  /**\r\n   * Swaps two elements in the vector.\r\n   *\r\n   * @param first index of the first element\r\n   * @param second index of the second element\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c size();\r\n  //@ requires 0 \u003c= second \u0026\u0026 second \u003c size();\r\n  public final void swap(int first, int second) {\r\n\r\n    Object help = m_Objects[first];\r\n\r\n    m_Objects[first] = m_Objects[second];\r\n    m_Objects[second] = help;\r\n  }\r\n\r\n  /**\r\n   * Sets the vector's capacity to its size.\r\n   */\r\n  public final void trimToSize() {\r\n\r\n    Object[] newObjects = new Object[m_Size];\r\n    \r\n    System.arraycopy(m_Objects, 0, newObjects, 0, m_Size);\r\n    m_Objects = newObjects;\r\n  }\r\n}\r\n\r\n",
        "name": "FastVector.java",
        "path": "src/keel/Algorithms/ImbalancedClassification/Resampling/SMOTE_RSB/Rough_Sets/FastVector.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/ImbalancedClassification/Resampling/SMOTE_RSB/Rough_Sets/FastVector.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 55,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= special \u0026\u0026 special \u003c vector.size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 134,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires capacity \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 166,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Objects.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 213,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 214,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003c m_Objects.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 237,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 265,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Size \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 321,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Size \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 332,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Size;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 395,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 406,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Size;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 418,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 419,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= second \u0026\u0026 second \u003c size();\r"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "package keel.Algorithms.ImbalancedClassification.Resampling.SMOTE_RSB.Rough_Sets;\r\n\r\n\r\nimport java.util.Enumeration;\r\n\r\n/** \r\n * Interface to something that understands options.\r\n *\r\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\r\n * @author Len Trigg (trigg@cs.waikato.ac.nz)\r\n * @version $Revision: 1.1 $\r\n */\r\npublic interface OptionHandler {\r\n\r\n  /**\r\n   * Returns an enumeration of all the available options..\r\n   *\r\n   * @return an enumeration of all available options.\r\n   */\r\n  Enumeration listOptions();\r\n\r\n  /**\r\n   * Sets the OptionHandler's options using the given list. All options\r\n   * will be set (or reset) during this call (i.e. incremental setting\r\n   * of options is not possible).\r\n   *\r\n   * @param options the list of options as an array of strings\r\n   * @exception Exception if an option is not supported\r\n   */\r\n  //@ requires options != null;\r\n  //@ requires \\nonnullelements(options);\r\n  void setOptions(String[] options) throws Exception;\r\n\r\n  /**\r\n   * Gets the current option settings for the OptionHandler.\r\n   *\r\n   * @return the list of current option settings as an array of strings\r\n   */\r\n  //@ ensures \\result != null;\r\n  //@ ensures \\nonnullelements(\\result);\r\n  /*@pure@*/ String[] getOptions();\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
        "name": "OptionHandler.java",
        "path": "src/keel/Algorithms/ImbalancedClassification/Resampling/SMOTE_RSB/Rough_Sets/OptionHandler.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/ImbalancedClassification/Resampling/SMOTE_RSB/Rough_Sets/OptionHandler.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 29,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires options != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 30,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires \\nonnullelements(options);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 39,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\nonnullelements(\\result);\r"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "/***********************************************************************\r\n\r\n\tThis file is part of KEEL-software, the Data Mining tool for regression, \r\n\tclassification, clustering, pattern mining and so on.\r\n\r\n\tCopyright (C) 2004-2010\r\n\t\r\n\tF. Herrera (herrera@decsai.ugr.es)\r\n    L. Sánchez (luciano@uniovi.es)\r\n    J. Alcalá-Fdez (jalcala@decsai.ugr.es)\r\n    S. García (sglopez@ujaen.es)\r\n    A. Fernández (alberto.fernandez@ujaen.es)\r\n    J. Luengo (julianlm@decsai.ugr.es)\r\n\r\n\tThis program is free software: you can redistribute it and/or modify\r\n\tit under the terms of the GNU General Public License as published by\r\n\tthe Free Software Foundation, either version 3 of the License, or\r\n\t(at your option) any later version.\r\n\r\n\tThis program is distributed in the hope that it will be useful,\r\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\tGNU General Public License for more details.\r\n\r\n\tYou should have received a copy of the GNU General Public License\r\n\talong with this program.  If not, see http://www.gnu.org/licenses/\r\n  \r\n**********************************************************************/\r\n\r\n/*\r\n *    This program is free software; you can redistribute it and/or modify\r\n *    it under the terms of the GNU General Public License as published by\r\n *    the Free Software Foundation; either version 2 of the License, or\r\n *    (at your option) any later version.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU General Public License\r\n *    along with this program; if not, write to the Free Software\r\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\r\n */\r\n\r\n/*\r\n *    Instance.java\r\n *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand\r\n *\r\n */\r\n\r\npackage keel.Algorithms.SVM.SMO.core;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.Enumeration;\r\n\r\nimport keel.Dataset.Attribute;\r\nimport keel.Dataset.Attributes;\r\n\r\n/**\r\n * Class for handling an instance. All values (numeric, date, nominal, string\r\n * or relational) are internally stored as floating-point numbers. If an\r\n * attribute is nominal (or a string or relational), the stored value is the\r\n * index of the corresponding nominal (or string or relational) value in the\r\n * attribute's definition. We have chosen this approach in favor of a more\r\n * elegant object-oriented approach because it is much faster. \u003cp\u003e\r\n *\r\n * Typical usage (code from the main() method of this class): \u003cp\u003e\r\n *\r\n * \u003ccode\u003e\r\n * ... \u003cbr\u003e\r\n *      \r\n * // Create empty instance with three attribute values \u003cbr\u003e\r\n * Instance inst = new Instance(3); \u003cbr\u003e\u003cbr\u003e\r\n *     \r\n * // Set instance's values for the attributes \"length\", \"weight\", and \"position\"\u003cbr\u003e\r\n * inst.setValue(length, 5.3); \u003cbr\u003e\r\n * inst.setValue(weight, 300); \u003cbr\u003e\r\n * inst.setValue(position, \"first\"); \u003cbr\u003e\u003cbr\u003e\r\n *   \r\n * // Set instance's dataset to be the dataset \"race\" \u003cbr\u003e\r\n * inst.setDataset(race); \u003cbr\u003e\u003cbr\u003e\r\n *   \r\n * // Print the instance \u003cbr\u003e\r\n * System.out.println(\"The instance: \" + inst); \u003cbr\u003e\r\n *\r\n * ... \u003cbr\u003e\r\n * \u003c/code\u003e\u003cp\u003e\r\n *\r\n * All methods that change an instance are safe, ie. a change of an\r\n * instance does not affect any other instances. All methods that\r\n * change an instance's attribute values clone the attribute value\r\n * vector before it is changed. If your application heavily modifies\r\n * instance values, it may be faster to create a new instance from scratch.\r\n *\r\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\r\n * @version $Revision: 1.1 $ \r\n */\r\npublic class Instance\r\nimplements Serializable {\r\n\r\n\t/** for serialization */\r\n\tstatic final long serialVersionUID = 1482635194499365122L;\r\n\r\n\t/** Constant representing a missing value. */\r\n\tprotected static final double MISSING_VALUE = Double.NaN;\r\n\r\n\t/** \r\n\t * The dataset the instance has access to.  Null if the instance\r\n\t * doesn't have access to any dataset.  Only if an instance has\r\n\t * access to a dataset, it knows about the actual attribute types.  \r\n\t */\r\n\tprotected /*@spec_public@*/ Instances m_Dataset;\r\n\r\n\t/** The instance's attribute values. */\r\n\tprotected /*@spec_public non_null@*/ double[] m_AttValues;\r\n\r\n\t/** The instance's weight. */\r\n\tprotected double m_Weight;\r\n\r\n\t/**\r\n\t * Constructor that copies the attribute values and the weight from\r\n\t * the given instance. Reference to the dataset is set to null.\r\n\t * (ie. the instance doesn't have access to information about the\r\n\t * attribute types)\r\n\t *\r\n\t * @param instance the instance from which the attribute\r\n\t * values and the weight are to be copied \r\n\t */\r\n\t//@ ensures m_Dataset == null;\r\n\tpublic Instance(/*@non_null@*/ Instance instance) {\r\n\r\n\t\tm_AttValues = instance.m_AttValues;\r\n\t\tm_Weight = instance.m_Weight;\r\n\t\tm_Dataset = null;\r\n\t}\r\n\r\n\t/**\r\n\t * Constructor that inititalizes instance variable with given\r\n\t * values. Reference to the dataset is set to null. (ie. the instance\r\n\t * doesn't have access to information about the attribute types)\r\n\t *\r\n\t * @param weight the instance's weight\r\n\t * @param attValues a vector of attribute values \r\n\t */\r\n\t//@ ensures m_Dataset == null;\r\n\tpublic Instance(double weight,  /*@non_null@*/ double[]attValues){\r\n\r\n\t\tm_AttValues = attValues;\r\n\t\tm_Weight = weight;\r\n\t\tm_Dataset = null;\r\n\t}\r\n\r\n\t/**\r\n\t * Constructor of an instance that sets weight to one, all values to\r\n\t * be missing, and the reference to the dataset to null. (ie. the instance\r\n\t * doesn't have access to information about the attribute types)\r\n\t *\r\n\t * @param numAttributes the size of the instance \r\n\t */\r\n\t//@ requires numAttributes \u003e 0;    // Or maybe == 0 is okay too?\r\n\t//@ ensures m_Dataset == null;\r\n\tpublic Instance(int numAttributes) {\r\n\r\n\t\tm_AttValues = new double[numAttributes];\r\n\t\tfor (int i = 0; i \u003c m_AttValues.length; i++) {\r\n\t\t\tm_AttValues[i] = MISSING_VALUE;\r\n\t\t}\r\n\t\tm_Weight = 1;\r\n\t\tm_Dataset = null;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the attribute with the given index.\r\n\t *\r\n\t * @param index the attribute's index\r\n\t * @return the attribute at the given position\r\n\t * @throws UnassignedDatasetException if instance doesn't have access to a\r\n\t * dataset\r\n\t */ \r\n\t//@ requires m_Dataset != null;\r\n\tpublic /*@pure@*/ Attribute attribute(int index) {\r\n\r\n\t\tif (m_Dataset == null) {\r\n\t\t\tthrow new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n\t\t}\r\n\t\treturn Attributes.getAttribute(index);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the attribute with the given index. Does the same\r\n\t * thing as attribute().\r\n\t *\r\n\t * @param indexOfIndex the index of the attribute's index \r\n\t * @return the attribute at the given position\r\n\t * @throws UnassignedDatasetException if instance doesn't have access to a\r\n\t * dataset\r\n\t */ \r\n\t//@ requires m_Dataset != null;\r\n\tpublic /*@pure@*/ Attribute attributeSparse(int indexOfIndex) {\r\n\r\n\t\tif (m_Dataset == null) {\r\n\t\t\tthrow new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n\t\t}\r\n\t\treturn m_Dataset.attribute(indexOfIndex);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns class attribute.\r\n\t *\r\n\t * @return the class attribute\r\n\t * @throws UnassignedDatasetException if the class is not set or the\r\n\t * instance doesn't have access to a dataset\r\n\t */\r\n\t//@ requires m_Dataset != null;\r\n\tpublic /*@pure@*/ Attribute classAttribute() {\r\n\r\n\t\tif (m_Dataset == null) {\r\n\t\t\tthrow new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n\t\t}\r\n\t\treturn m_Dataset.classAttribute();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the class attribute's index.\r\n\t *\r\n\t * @return the class index as an integer \r\n\t * @throws UnassignedDatasetException if instance doesn't have access to a dataset \r\n\t */\r\n\t//@ requires m_Dataset != null;\r\n\t//@ ensures  \\result == m_Dataset.classIndex();\r\n\tpublic /*@pure@*/ int classIndex() {\r\n\r\n\t\tif (m_Dataset == null) {\r\n\t\t\tthrow new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n\t\t}\r\n\t\treturn m_Dataset.classIndex();\r\n\t}\r\n\r\n\t/**\r\n\t * Tests if an instance's class is missing.\r\n\t *\r\n\t * @return true if the instance's class is missing\r\n\t * @throws UnassignedClassException if the class is not set or the instance doesn't\r\n\t * have access to a dataset\r\n\t */\r\n\t//@ requires classIndex() \u003e= 0;\r\n\tpublic /*@pure@*/ boolean classIsMissing() {\r\n\r\n\t\tif (classIndex() \u003c 0) {\r\n\t\t\tthrow new UnassignedClassException(\"Class is not set!\");\r\n\t\t}\r\n\t\treturn isMissing(classIndex());\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an instance's class value in internal format. (ie. as a\r\n\t * floating-point number)\r\n\t *\r\n\t * @return the corresponding value as a double (If the \r\n\t * corresponding attribute is nominal (or a string) then it returns the \r\n\t * value's index as a double).\r\n\t * @throws UnassignedClassException if the class is not set or the instance doesn't\r\n\t * have access to a dataset \r\n\t */\r\n\t//@ requires classIndex() \u003e= 0;\r\n\tpublic /*@pure@*/ double classValue() {\r\n\r\n\t\tif (classIndex() \u003c 0) {\r\n\t\t\tthrow new UnassignedClassException(\"Class is not set!\");\r\n\t\t}\r\n\t\treturn value(classIndex());\r\n\t}\r\n\r\n\t/**\r\n\t * Produces a shallow copy of this instance. The copy has\r\n\t * access to the same dataset. (if you want to make a copy\r\n\t * that doesn't have access to the dataset, use \r\n\t * \u003ccode\u003enew Instance(instance)\u003c/code\u003e\r\n\t *\r\n\t * @return the shallow copy\r\n\t */\r\n\t//@ also ensures \\result != null;\r\n\t//@ also ensures \\result instanceof Instance;\r\n\t//@ also ensures ((Instance)\\result).m_Dataset == m_Dataset;\r\n\tpublic /*@pure@*/ Object copy() {\r\n\r\n\t\tInstance result = new Instance(this);\r\n\t\tresult.m_Dataset = m_Dataset;\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the dataset this instance has access to. (ie. obtains\r\n\t * information about attribute types from) Null if the instance\r\n\t * doesn't have access to a dataset.\r\n\t *\r\n\t * @return the dataset the instance has accesss to\r\n\t */\r\n\t//@ ensures \\result == m_Dataset;\r\n\tpublic /*@pure@*/ Instances dataset() {\r\n\r\n\t\treturn m_Dataset;\r\n\t}\r\n\r\n\t/**\r\n\t * Deletes an attribute at the given position (0 to \r\n\t * numAttributes() - 1). Only succeeds if the instance does not\r\n\t * have access to any dataset because otherwise inconsistencies\r\n\t * could be introduced.\r\n\t *\r\n\t * @param position the attribute's position\r\n\t * @throws RuntimeException if the instance has access to a\r\n\t * dataset \r\n\t */\r\n\t//@ requires m_Dataset != null;\r\n\tpublic void deleteAttributeAt(int position) {\r\n\r\n\t\tif (m_Dataset != null) {\r\n\t\t\tthrow new RuntimeException(\"Instance has access to a dataset!\");\r\n\t\t}\r\n\t\tforceDeleteAttributeAt(position);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an enumeration of all the attributes.\r\n\t *\r\n\t * @return enumeration of all the attributes\r\n\t * @throws UnassignedDatasetException if the instance doesn't\r\n\t * have access to a dataset \r\n\t */\r\n\t//@ requires m_Dataset != null;\r\n\tpublic /*@pure@*/ Enumeration enumerateAttributes() {\r\n\r\n\t\tif (m_Dataset == null) {\r\n\t\t\tthrow new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n\t\t}\r\n\t\treturn m_Dataset.enumerateAttributes();\r\n\t}\r\n\r\n\t/**\r\n\t * Tests if the headers of two instances are equivalent.\r\n\t *\r\n\t * @param inst another instance\r\n\t * @return true if the header of the given instance is \r\n\t * equivalent to this instance's header\r\n\t * @throws UnassignedDatasetException if instance doesn't have access to any\r\n\t * dataset\r\n\t */\r\n\t//@ requires m_Dataset != null;\r\n\tpublic /*@pure@*/ boolean equalHeaders(Instance inst) {\r\n\r\n\t\tif (m_Dataset == null) {\r\n\t\t\tthrow new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n\t\t}\r\n\t\treturn m_Dataset.equalHeaders(inst.m_Dataset);\r\n\t}\r\n\r\n\t/**\r\n\t * Tests whether an instance has a missing value. Skips the class attribute if set.\r\n\t * @return true if instance has a missing value.\r\n\t * @throws UnassignedDatasetException if instance doesn't have access to any\r\n\t * dataset\r\n\t */\r\n\t//@ requires m_Dataset != null;\r\n\tpublic /*@pure@*/ boolean hasMissingValue() {\r\n\r\n\t\tif (m_Dataset == null) {\r\n\t\t\tthrow new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n\t\t}\r\n\t\tfor (int i = 0; i \u003c numAttributes(); i++) {\r\n\t\t\tif (i != classIndex()) {\r\n\t\t\t\tif (isMissing(i)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the index of the attribute stored at the given position.\r\n\t * Just returns the given value.\r\n\t *\r\n\t * @param position the position \r\n\t * @return the index of the attribute stored at the given position\r\n\t */\r\n\tpublic /*@pure@*/ int index(int position) {\r\n\r\n\t\treturn position;\r\n\t}\r\n\r\n\t/**\r\n\t * Inserts an attribute at the given position (0 to \r\n\t * numAttributes()). Only succeeds if the instance does not\r\n\t * have access to any dataset because otherwise inconsistencies\r\n\t * could be introduced.\r\n\t *\r\n\t * @param position the attribute's position\r\n\t * @throws RuntimeException if the instance has accesss to a\r\n\t * dataset\r\n\t * @throws IllegalArgumentException if the position is out of range\r\n\t */\r\n\t//@ requires m_Dataset == null;\r\n\t//@ requires 0 \u003c= position \u0026\u0026 position \u003c= numAttributes();\r\n\tpublic void insertAttributeAt(int position) {\r\n\r\n\t\tif (m_Dataset != null) {\r\n\t\t\tthrow new RuntimeException(\"Instance has accesss to a dataset!\");\r\n\t\t}\r\n\t\tif ((position \u003c 0) ||\r\n\t\t\t\t(position \u003e numAttributes())) {\r\n\t\t\tthrow new IllegalArgumentException(\"Can't insert attribute: index out \"+\r\n\t\t\t\"of range\");\r\n\t\t}\r\n\t\tforceInsertAttributeAt(position);\r\n\t}\r\n\r\n\t/**\r\n\t * Tests if a specific value is \"missing\".\r\n\t *\r\n\t * @param attIndex the attribute's index\r\n\t * @return true if the value is \"missing\"\r\n\t */\r\n\tpublic /*@pure@*/ boolean isMissing(int attIndex) {\r\n\r\n\t\tif (Double.isNaN(m_AttValues[attIndex])) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Tests if a specific value is \"missing\". Does\r\n\t * the same thing as isMissing() if applied to an Instance.\r\n\t *\r\n\t * @param indexOfIndex the index of the attribute's index \r\n\t * @return true if the value is \"missing\"\r\n\t */\r\n\tpublic /*@pure@*/ boolean isMissingSparse(int indexOfIndex) {\r\n\r\n\t\tif (Double.isNaN(m_AttValues[indexOfIndex])) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Tests if a specific value is \"missing\".\r\n\t * The given attribute has to belong to a dataset.\r\n\t *\r\n\t * @param att the attribute\r\n\t * @return true if the value is \"missing\"\r\n\t */\r\n\tpublic /*@pure@*/ boolean isMissing(Attribute att) {\r\n\t\tint index;\r\n\t\tindex = -1;\r\n\t\tfor(int i=0;i\u003cAttributes.getNumAttributes() \u0026\u0026 index ==-1;i++)\r\n\t\t\tif(att == Attributes.getAttribute(index))\r\n\t\t\t\tindex = i;\r\n\t\treturn isMissing(index);\r\n\t}\r\n\r\n\t/**\r\n\t * Tests if the given value codes \"missing\".\r\n\t *\r\n\t * @param val the value to be tested\r\n\t * @return true if val codes \"missing\"\r\n\t */\r\n\tpublic static /*@pure@*/ boolean isMissingValue(double val) {\r\n\r\n\t\treturn Double.isNaN(val);\r\n\t}\r\n\r\n\t/**\r\n\t * Merges this instance with the given instance and returns\r\n\t * the result. Dataset is set to null.\r\n\t *\r\n\t * @param inst the instance to be merged with this one\r\n\t * @return the merged instances\r\n\t */\r\n\tpublic Instance mergeInstance(Instance inst) {\r\n\r\n\t\tint m = 0;\r\n\t\tdouble [] newVals = new double[numAttributes() + inst.numAttributes()];\r\n\t\tfor (int j = 0; j \u003c numAttributes(); j++, m++) {\r\n\t\t\tnewVals[m] = value(j);\r\n\t\t}\r\n\t\tfor (int j = 0; j \u003c inst.numAttributes(); j++, m++) {\r\n\t\t\tnewVals[m] = inst.value(j);\r\n\t\t}\r\n\t\treturn new Instance(1.0, newVals);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the double that codes \"missing\".\r\n\t *\r\n\t * @return the double that codes \"missing\"\r\n\t */\r\n\tpublic /*@pure@*/ static double missingValue() {\r\n\r\n\t\treturn MISSING_VALUE;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the number of attributes.\r\n\t *\r\n\t * @return the number of attributes as an integer\r\n\t */\r\n\t//@ ensures \\result == m_AttValues.length;\r\n\tpublic /*@pure@*/ int numAttributes() {\r\n\r\n\t\treturn m_AttValues.length;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the number of class labels.\r\n\t *\r\n\t * @return the number of class labels as an integer if the \r\n\t * class attribute is nominal, 1 otherwise.\r\n\t * @throws UnassignedDatasetException if instance doesn't have access to any\r\n\t * dataset\r\n\t */\r\n\t//@ requires m_Dataset != null;\r\n\tpublic /*@pure@*/ int numClasses() {\r\n\r\n\t\tif (m_Dataset == null) {\r\n\t\t\tthrow new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n\t\t}\r\n\t\treturn m_Dataset.numClasses();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the number of values present. Always the same as numAttributes().\r\n\t *\r\n\t * @return the number of values\r\n\t */\r\n\t//@ ensures \\result == m_AttValues.length;\r\n\tpublic /*@pure@*/ int numValues() {\r\n\r\n\t\treturn m_AttValues.length;\r\n\t}\r\n\r\n\t/** \r\n\t * Replaces all missing values in the instance with the\r\n\t * values contained in the given array. A deep copy of\r\n\t * the vector of attribute values is performed before the\r\n\t * values are replaced.\r\n\t *\r\n\t * @param array containing the means and modes\r\n\t * @throws IllegalArgumentException if numbers of attributes are unequal\r\n\t */\r\n\tpublic void replaceMissingValues(double[] array) {\r\n\r\n\t\tif ((array == null) || \r\n\t\t\t\t(array.length != m_AttValues.length)) {\r\n\t\t\tthrow new IllegalArgumentException(\"Unequal number of attributes!\");\r\n\t\t}\r\n\t\tfreshAttributeVector();\r\n\t\tfor (int i = 0; i \u003c m_AttValues.length; i++) {\r\n\t\t\tif (isMissing(i)) {\r\n\t\t\t\tm_AttValues[i] = array[i];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the class value of an instance to be \"missing\". A deep copy of\r\n\t * the vector of attribute values is performed before the\r\n\t * value is set to be missing.\r\n\t *\r\n\t * @throws UnassignedClassException if the class is not set\r\n\t * @throws UnassignedDatasetException if the instance doesn't\r\n\t * have access to a dataset\r\n\t */\r\n\t//@ requires classIndex() \u003e= 0;\r\n\tpublic void setClassMissing() {\r\n\r\n\t\tif (classIndex() \u003c 0) {\r\n\t\t\tthrow new UnassignedClassException(\"Class is not set!\");\r\n\t\t}\r\n\t\tsetMissing(classIndex());\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the class value of an instance to the given value (internal\r\n\t * floating-point format).  A deep copy of the vector of attribute\r\n\t * values is performed before the value is set.\r\n\t *\r\n\t * @param value the new attribute value (If the corresponding\r\n\t * attribute is nominal (or a string) then this is the new value's\r\n\t * index as a double).  \r\n\t * @throws UnassignedClassException if the class is not set or if the instance doesn't\r\n\t * have access to a dataset \r\n\t */\r\n\t//@ requires classIndex() \u003e= 0;\r\n\tpublic void setClassValue(double value) {\r\n\r\n\t\tif (classIndex() \u003c 0) {\r\n\t\t\tthrow new UnassignedClassException(\"Class is not set!\");\r\n\t\t}\r\n\t\tsetValue(classIndex(), value);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the class value of an instance to the given value. A deep\r\n\t * copy of the vector of attribute values is performed before the\r\n\t * value is set.\r\n\t *\r\n\t * @param value the new class value (If the class\r\n\t * is a string attribute and the value can't be found,\r\n\t * the value is added to the attribute).\r\n\t * @throws UnassignedClassException if the class is not set\r\n\t * @throws UnassignedDatasetException if the dataset is not set\r\n\t * @throws IllegalArgumentException if the attribute is not\r\n\t * nominal or a string, or the value couldn't be found for a nominal\r\n\t * attribute \r\n\t */\r\n\t//@ requires classIndex() \u003e= 0;\r\n\tpublic final void setClassValue(String value) {\r\n\r\n\t\tif (classIndex() \u003c 0) {\r\n\t\t\tthrow new UnassignedClassException(\"Class is not set!\");\r\n\t\t}\r\n\t\tsetValue(classIndex(), value);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the reference to the dataset. Does not check if the instance\r\n\t * is compatible with the dataset. Note: the dataset does not know\r\n\t * about this instance. If the structure of the dataset's header\r\n\t * gets changed, this instance will not be adjusted automatically.\r\n\t *\r\n\t * @param instances the reference to the dataset \r\n\t */\r\n\tpublic final void setDataset(Instances instances) {\r\n\r\n\t\tm_Dataset = instances;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a specific value to be \"missing\". Performs a deep copy\r\n\t * of the vector of attribute values before the value is set to\r\n\t * be missing.\r\n\t *\r\n\t * @param attIndex the attribute's index\r\n\t */\r\n\tpublic final void setMissing(int attIndex) {\r\n\r\n\t\tsetValue(attIndex, MISSING_VALUE);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a specific value to be \"missing\". Performs a deep copy\r\n\t * of the vector of attribute values before the value is set to\r\n\t * be missing. The given attribute has to belong to a dataset.\r\n\t *\r\n\t * @param att the attribute\r\n\t */\r\n\tpublic final void setMissing(Attribute att) {\r\n\t\tint index;\r\n\t\tindex = -1;\r\n\t\tfor(int i=0;i\u003cAttributes.getNumAttributes() \u0026\u0026 index ==-1;i++)\r\n\t\t\tif(att == Attributes.getAttribute(index))\r\n\t\t\t\tindex = i;\r\n\t\tsetMissing(index);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a specific value in the instance to the given value \r\n\t * (internal floating-point format). Performs a deep copy\r\n\t * of the vector of attribute values before the value is set.\r\n\t *\r\n\t * @param attIndex the attribute's index \r\n\t * @param value the new attribute value (If the corresponding\r\n\t * attribute is nominal (or a string) then this is the new value's\r\n\t * index as a double).  \r\n\t */\r\n\tpublic void setValue(int attIndex, double value) {\r\n\r\n\t\tfreshAttributeVector();\r\n\t\tm_AttValues[attIndex] = value;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a specific value in the instance to the given value \r\n\t * (internal floating-point format). Performs a deep copy\r\n\t * of the vector of attribute values before the value is set.\r\n\t * Does exactly the same thing as setValue().\r\n\t *\r\n\t * @param indexOfIndex the index of the attribute's index \r\n\t * @param value the new attribute value (If the corresponding\r\n\t * attribute is nominal (or a string) then this is the new value's\r\n\t * index as a double).  \r\n\t */\r\n\tpublic void setValueSparse(int indexOfIndex, double value) {\r\n\r\n\t\tfreshAttributeVector();\r\n\t\tm_AttValues[indexOfIndex] = value;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a value of a nominal or string attribute to the given\r\n\t * value. Performs a deep copy of the vector of attribute values\r\n\t * before the value is set.\r\n\t *\r\n\t * @param attIndex the attribute's index\r\n\t * @param value the new attribute value (If the attribute\r\n\t * is a string attribute and the value can't be found,\r\n\t * the value is added to the attribute).\r\n\t * @throws UnassignedDatasetException if the dataset is not set\r\n\t * @throws IllegalArgumentException if the selected\r\n\t * attribute is not nominal or a string, or the supplied value couldn't \r\n\t * be found for a nominal attribute \r\n\t */\r\n\t//@ requires m_Dataset != null;\r\n\tpublic final void setValue(int attIndex, String value) {\r\n\t\tAttribute a = Attributes.getAttribute(attIndex);\r\n\t\tint valIndex;\r\n\r\n\t\tif (m_Dataset == null) {\r\n\t\t\tthrow new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n\t\t}\r\n\t\tif (!(a.getType()==Attribute.NOMINAL)) {\r\n\t\t\tthrow new IllegalArgumentException(\"Attribute neither nominal nor string!\");\r\n\t\t}\r\n//\t\tvalIndex = attribute(attIndex).indexOfValue(value);\r\n//\t\tif (valIndex == -1) {\r\n//\t\t\tif (a.getType()==Attribute.NOMINAL) {\r\n//\t\t\t\tthrow new IllegalArgumentException(\"Value not defined for given nominal attribute!\");\r\n//\t\t\t} else {\r\n//\t\t\t\tattribute(attIndex).forceAddValue(value);\r\n//\t\t\t\tvalIndex = attribute(attIndex).indexOfValue(value);\r\n//\t\t\t}\r\n//\t\t}\r\n\t\tvalIndex = -1;\r\n\t\tfor(int i=0;i\u003ca.getNumNominalValues();i++)\r\n\t\t\tif(a.getNominalValue(i).compareTo(value)==0)\r\n\t\t\t\tvalIndex = i;\r\n\t\tsetValue(attIndex, (double)valIndex); \r\n\t}\r\n\r\n\t/**\r\n\t * Sets a specific value in the instance to the given value\r\n\t * (internal floating-point format). Performs a deep copy of the\r\n\t * vector of attribute values before the value is set, so if you are\r\n\t * planning on calling setValue many times it may be faster to\r\n\t * create a new instance using toDoubleArray.  The given attribute\r\n\t * has to belong to a dataset.\r\n\t *\r\n\t * @param att the attribute \r\n\t * @param value the new attribute value (If the corresponding\r\n\t * attribute is nominal (or a string) then this is the new value's\r\n\t * index as a double).  \r\n\t */\r\n\tpublic final void setValue(Attribute att, double value) {\r\n\t\tint index;\r\n\t\tindex = -1;\r\n\t\tfor(int i=0;i\u003cAttributes.getNumAttributes() \u0026\u0026 index ==-1;i++)\r\n\t\t\tif(att == Attributes.getAttribute(index))\r\n\t\t\t\tindex = i;\r\n\t\tsetValue(index, value);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a value of an nominal or string attribute to the given\r\n\t * value. Performs a deep copy of the vector of attribute values\r\n\t * before the value is set, so if you are planning on calling setValue many\r\n\t * times it may be faster to create a new instance using toDoubleArray.\r\n\t * The given attribute has to belong to a dataset.\r\n\t *\r\n\t * @param att the attribute\r\n\t * @param value the new attribute value (If the attribute\r\n\t * is a string attribute and the value can't be found,\r\n\t * the value is added to the attribute).\r\n\t * @throws IllegalArgumentException if the the attribute is not\r\n\t * nominal or a string, or the value couldn't be found for a nominal\r\n\t * attribute \r\n\t */\r\n\tpublic final void setValue(Attribute att, String value) {\r\n\t\tint index,valIndex;\r\n\t\tindex = -1;\r\n\t\tfor(int i=0;i\u003cAttributes.getNumAttributes() \u0026\u0026 index ==-1;i++)\r\n\t\t\tif(att == Attributes.getAttribute(index))\r\n\t\t\t\tindex = i;\r\n\t\t\r\n\t\tvalIndex = -1;\r\n\t\tfor(int i=0;i\u003catt.getNumNominalValues();i++){\r\n\t\t\tif(att.getNominalValue(i).compareTo(value)==0)\r\n\t\t\t\tvalIndex = i;\r\n\t\t}\r\n\t\tsetValue(index, (double)valIndex);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the weight of an instance.\r\n\t *\r\n\t * @param weight the weight\r\n\t */\r\n\tpublic final void setWeight(double weight) {\r\n\r\n\t\tm_Weight = weight;\r\n\t}\r\n\r\n\t/** \r\n\t * Returns the relational value of a relational attribute.\r\n\t *\r\n\t * @param attIndex the attribute's index\r\n\t * @return the corresponding relation as an Instances object\r\n\t * @throws IllegalArgumentException if the attribute is not a\r\n\t * relation-valued attribute\r\n\t * @throws UnassignedDatasetException if the instance doesn't belong\r\n\t * to a dataset.\r\n\t */\r\n\t//@ requires m_Dataset != null;\r\n//\tpublic final /*@pure@*/ Instances relationalValue(int attIndex) {\r\n//\r\n//\t\tif (m_Dataset == null) {\r\n//\t\t\tthrow new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n//\t\t} \r\n//\t\treturn relationalValue(m_Dataset.attribute(attIndex));\r\n//\t}\r\n\r\n\r\n\t/** \r\n\t * Returns the relational value of a relational attribute.\r\n\t *\r\n\t * @param att the attribute\r\n\t * @return the corresponding relation as an Instances object\r\n\t * @throws IllegalArgumentException if the attribute is not a\r\n\t * relation-valued attribute\r\n\t * @throws UnassignedDatasetException if the instance doesn't belong\r\n\t * to a dataset.\r\n\t */\r\n//\tpublic final /*@pure@*/ Instances relationalValue(Attribute att) {\r\n//\r\n//\t\tint attIndex = att.index();\r\n//\t\tif (att.isRelationValued()) {\r\n//\t\t\treturn att.relation((int) value(attIndex));\r\n//\t\t} else {\r\n//\t\t\tthrow new IllegalArgumentException(\"Attribute isn't relation-valued!\");\r\n//\t\t}\r\n//\t}\r\n\r\n\t/** \r\n\t * Returns the value of a nominal, string, date, or relational attribute\r\n\t * for the instance as a string.\r\n\t *\r\n\t * @param attIndex the attribute's index\r\n\t * @return the value as a string\r\n\t * @throws IllegalArgumentException if the attribute is not a nominal,\r\n\t * string, date, or relation-valued attribute.\r\n\t * @throws UnassignedDatasetException if the instance doesn't belong\r\n\t * to a dataset.\r\n\t */\r\n\t//@ requires m_Dataset != null;\r\n\tpublic final /*@pure@*/ String stringValue(int attIndex) {\r\n\r\n\t\tif (m_Dataset == null) {\r\n\t\t\tthrow new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\r\n\t\t} \r\n\t\treturn stringValue(m_Dataset.attribute(attIndex));\r\n\t}\r\n\r\n\r\n\t/** \r\n\t * Returns the value of a nominal, string, date, or relational attribute\r\n\t * for the instance as a string.\r\n\t *\r\n\t * @param att the attribute\r\n\t * @return the value as a string\r\n\t * @throws IllegalArgumentException if the attribute is not a nominal,\r\n\t * string, date, or relation-valued attribute.\r\n\t * @throws UnassignedDatasetException if the instance doesn't belong\r\n\t * to a dataset.\r\n\t */\r\n\tpublic final /*@pure@*/ String stringValue(Attribute att) {\r\n\t\tint index;\r\n\t\tAttribute a;\r\n\t\tindex = -1;\r\n\t\tif(m_Dataset!=null){\r\n\t\t\tfor(int i=0;i\u003cm_Dataset.numAttributes() \u0026\u0026 index ==-1;i++){\r\n\t\t\t\ta = m_Dataset.attribute(i);\r\n\t\t\t\tif(att == a)\r\n\t\t\t\t\tindex = i;\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tfor(int i=0;i\u003cAttributes.getNumAttributes() \u0026\u0026 index ==-1;i++)\r\n\t\t\t\tif(att == Attributes.getAttribute(index))\r\n\t\t\t\t\tindex = i;\r\n\t\t}\r\n\t\tint attIndex = index;\r\n\t\tswitch (att.getType()) {\r\n\t\tcase Attribute.NOMINAL:\r\n\t\t\treturn att.getNominalValue((int) value(attIndex));\r\n\t\tdefault:\r\n\t\t\tthrow new IllegalArgumentException(\"Attribute isn't nominal, string or date!\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the values of each attribute as an array of doubles.\r\n\t *\r\n\t * @return an array containing all the instance attribute values\r\n\t */\r\n\tpublic double[] toDoubleArray() {\r\n\r\n\t\tdouble[] newValues = new double[m_AttValues.length];\r\n\t\tSystem.arraycopy(m_AttValues, 0, newValues, 0, \r\n\t\t\t\tm_AttValues.length);\r\n\t\treturn newValues;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the description of one instance. If the instance\r\n\t * doesn't have access to a dataset, it returns the internal\r\n\t * floating-point values. Quotes string\r\n\t * values that contain whitespace characters.\r\n\t *\r\n\t * @return the instance's description as a string\r\n\t */\r\n\tpublic String toString() {\r\n\r\n\t\tStringBuffer text = new StringBuffer();\r\n\r\n\t\tfor (int i = 0; i \u003c m_AttValues.length; i++) {\r\n\t\t\tif (i \u003e 0) text.append(\",\");\r\n\t\t\ttext.append(toString(i));\r\n\t\t}\r\n\r\n\t\treturn text.toString();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the description of one value of the instance as a \r\n\t * string. If the instance doesn't have access to a dataset, it \r\n\t * returns the internal floating-point value. Quotes string\r\n\t * values that contain whitespace characters, or if they\r\n\t * are a question mark.\r\n\t *\r\n\t * @param attIndex the attribute's index\r\n\t * @return the value's description as a string\r\n\t */\r\n\tpublic final /*@pure@*/ String toString(int attIndex) {\r\n\r\n\t\tStringBuffer text = new StringBuffer();\r\n\r\n\t\tif (isMissing(attIndex)) {\r\n\t\t\ttext.append(\"?\");\r\n\t\t} else {\r\n\t\t\tif (m_Dataset == null) {\r\n\t\t\t\ttext.append(Utils.doubleToString(m_AttValues[attIndex],6));\r\n\t\t\t} else {\r\n\t\t\t\tswitch (m_Dataset.attribute(attIndex).getType()) {\r\n\t\t\t\tcase Attribute.NOMINAL:\r\n\t\t\t\t\ttext.append(Utils.quote(stringValue(attIndex)));\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase Attribute.INTEGER:\r\n\t\t\t\tcase Attribute.REAL:\r\n\t\t\t\t\ttext.append(Utils.doubleToString(value(attIndex),6));\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new IllegalStateException(\"Unknown attribute type\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn text.toString();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the description of one value of the instance as a \r\n\t * string. If the instance doesn't have access to a dataset it \r\n\t * returns the internal floating-point value. Quotes string\r\n\t * values that contain whitespace characters, or if they\r\n\t * are a question mark.\r\n\t * The given attribute has to belong to a dataset.\r\n\t *\r\n\t * @param att the attribute\r\n\t * @return the value's description as a string\r\n\t */\r\n//\tpublic final String toString(Attribute att) {\r\n//\r\n//\t\treturn toString(att.index());\r\n//\t}\r\n\r\n\t/**\r\n\t * Returns an instance's attribute value in internal format.\r\n\t *\r\n\t * @param attIndex the attribute's index\r\n\t * @return the specified value as a double (If the corresponding\r\n\t * attribute is nominal (or a string) then it returns the value's index as a \r\n\t * double).\r\n\t */\r\n\tpublic /*@pure@*/ double value(int attIndex) {\r\n\r\n\t\treturn m_AttValues[attIndex];\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an instance's attribute value in internal format.\r\n\t * Does exactly the same thing as value() if applied to an Instance.\r\n\t *\r\n\t * @param indexOfIndex the index of the attribute's index\r\n\t * @return the specified value as a double (If the corresponding\r\n\t * attribute is nominal (or a string) then it returns the value's index as a \r\n\t * double).\r\n\t */\r\n\tpublic /*@pure@*/ double valueSparse(int indexOfIndex) {\r\n\r\n\t\treturn m_AttValues[indexOfIndex];\r\n\t}  \r\n\r\n\t/**\r\n\t * Returns an instance's attribute value in internal format.\r\n\t * The given attribute has to belong to a dataset.\r\n\t *\r\n\t * @param att the attribute\r\n\t * @return the specified value as a double (If the corresponding\r\n\t * attribute is nominal (or a string) then it returns the value's index as a\r\n\t * double).\r\n\t */\r\n\tpublic /*@pure@*/ double value(Attribute att) {\r\n\t\tint index;\r\n\t\tindex = -1;\r\n\t\tfor(int i=0;i\u003cAttributes.getNumAttributes() \u0026\u0026 index ==-1;i++)\r\n\t\t\tif(att == Attributes.getAttribute(index))\r\n\t\t\t\tindex = i;\r\n\t\treturn value(index);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the instance's weight.\r\n\t *\r\n\t * @return the instance's weight as a double\r\n\t */\r\n\tpublic final /*@pure@*/ double weight() {\r\n\r\n\t\treturn m_Weight;\r\n\t}\r\n\r\n\t/**\r\n\t * Deletes an attribute at the given position (0 to \r\n\t * numAttributes() - 1).\r\n\t *\r\n\t * @param position the attribute's position\r\n\t */\r\n\tvoid forceDeleteAttributeAt(int position) {\r\n\r\n\t\tdouble[] newValues = new double[m_AttValues.length - 1];\r\n\r\n\t\tSystem.arraycopy(m_AttValues, 0, newValues, 0, position);\r\n\t\tif (position \u003c m_AttValues.length - 1) {\r\n\t\t\tSystem.arraycopy(m_AttValues, position + 1, \r\n\t\t\t\t\tnewValues, position, \r\n\t\t\t\t\tm_AttValues.length - (position + 1));\r\n\t\t}\r\n\t\tm_AttValues = newValues;\r\n\t}\r\n\r\n\t/**\r\n\t * Inserts an attribute at the given position\r\n\t * (0 to numAttributes()) and sets its value to be missing. \r\n\t *\r\n\t * @param position the attribute's position\r\n\t */\r\n\tvoid forceInsertAttributeAt(int position)  {\r\n\r\n\t\tdouble[] newValues = new double[m_AttValues.length + 1];\r\n\r\n\t\tSystem.arraycopy(m_AttValues, 0, newValues, 0, position);\r\n\t\tnewValues[position] = MISSING_VALUE;\r\n\t\tSystem.arraycopy(m_AttValues, position, newValues, \r\n\t\t\t\tposition + 1, m_AttValues.length - position);\r\n\t\tm_AttValues = newValues;\r\n\t}\r\n\r\n\t/**\r\n\t * Private constructor for subclasses. Does nothing.\r\n\t */\r\n\tprotected Instance() {\r\n\t}\r\n\r\n\t/**\r\n\t * Clones the attribute vector of the instance and\r\n\t * overwrites it with the clone.\r\n\t */\r\n\tprivate void freshAttributeVector() {\r\n\r\n\t\tm_AttValues = toDoubleArray();\r\n\t}\r\n\r\n\t/**\r\n\t * Main method for testing this class.\r\n\t * \r\n\t * @param options the commandline options - ignored\r\n\t */\r\n\t//@ requires options != null;\r\n//\tpublic static void main(String[] options) {\r\n//\r\n//\t\ttry {\r\n//\r\n//\t\t\t// Create numeric attributes \"length\" and \"weight\"\r\n//\t\t\tAttribute length = new Attribute(\"length\");\r\n//\t\t\tAttribute weight = new Attribute(\"weight\");\r\n//\r\n//\t\t\t// Create vector to hold nominal values \"first\", \"second\", \"third\" \r\n//\t\t\tFastVector my_nominal_values = new FastVector(3); \r\n//\t\t\tmy_nominal_values.addElement(\"first\"); \r\n//\t\t\tmy_nominal_values.addElement(\"second\"); \r\n//\t\t\tmy_nominal_values.addElement(\"third\"); \r\n//\r\n//\t\t\t// Create nominal attribute \"position\" \r\n//\t\t\tAttribute position = new Attribute(\"position\", my_nominal_values);\r\n//\r\n//\t\t\t// Create vector of the above attributes \r\n//\t\t\tFastVector attributes = new FastVector(3);\r\n//\t\t\tattributes.addElement(length);\r\n//\t\t\tattributes.addElement(weight);\r\n//\t\t\tattributes.addElement(position);\r\n//\r\n//\t\t\t// Create the empty dataset \"race\" with above attributes\r\n//\t\t\tInstances race = new Instances(\"race\", attributes, 0);\r\n//\r\n//\t\t\t// Make position the class attribute\r\n//\t\t\trace.setClassIndex(position.index());\r\n//\r\n//\t\t\t// Create empty instance with three attribute values\r\n//\t\t\tInstance inst = new Instance(3);\r\n//\r\n//\t\t\t// Set instance's values for the attributes \"length\", \"weight\", and \"position\"\r\n//\t\t\tinst.setValue(length, 5.3);\r\n//\t\t\tinst.setValue(weight, 300);\r\n//\t\t\tinst.setValue(position, \"first\");\r\n//\r\n//\t\t\t// Set instance's dataset to be the dataset \"race\"\r\n//\t\t\tinst.setDataset(race);\r\n//\r\n//\t\t\t// Print the instance\r\n//\t\t\tSystem.out.println(\"The instance: \" + inst);\r\n//\r\n//\t\t\t// Print the first attribute\r\n//\t\t\tSystem.out.println(\"First attribute: \" + inst.attribute(0));\r\n//\r\n//\t\t\t// Print the class attribute\r\n//\t\t\tSystem.out.println(\"Class attribute: \" + inst.classAttribute());\r\n//\r\n//\t\t\t// Print the class index\r\n//\t\t\tSystem.out.println(\"Class index: \" + inst.classIndex());\r\n//\r\n//\t\t\t// Say if class is missing\r\n//\t\t\tSystem.out.println(\"Class is missing: \" + inst.classIsMissing());\r\n//\r\n//\t\t\t// Print the instance's class value in internal format\r\n//\t\t\tSystem.out.println(\"Class value (internal format): \" + inst.classValue());\r\n//\r\n//\t\t\t// Print a shallow copy of this instance\r\n//\t\t\tInstance copy = (Instance) inst.copy();\r\n//\t\t\tSystem.out.println(\"Shallow copy: \" + copy);\r\n//\r\n//\t\t\t// Set dataset for shallow copy\r\n//\t\t\tcopy.setDataset(inst.dataset());\r\n//\t\t\tSystem.out.println(\"Shallow copy with dataset set: \" + copy);\r\n//\r\n//\t\t\t// Unset dataset for copy, delete first attribute, and insert it again\r\n//\t\t\tcopy.setDataset(null);\r\n//\t\t\tcopy.deleteAttributeAt(0);\r\n//\t\t\tcopy.insertAttributeAt(0);\r\n//\t\t\tcopy.setDataset(inst.dataset());\r\n//\t\t\tSystem.out.println(\"Copy with first attribute deleted and inserted: \" + copy); \r\n//\r\n//\t\t\t// Enumerate attributes (leaving out the class attribute)\r\n//\t\t\tSystem.out.println(\"Enumerating attributes (leaving out class):\");\r\n//\t\t\tEnumeration enu = inst.enumerateAttributes();\r\n//\t\t\twhile (enu.hasMoreElements()) {\r\n//\t\t\t\tAttribute att = (Attribute) enu.nextElement();\r\n//\t\t\t\tSystem.out.println(att);\r\n//\t\t\t}\r\n//\r\n//\t\t\t// Headers are equivalent?\r\n//\t\t\tSystem.out.println(\"Header of original and copy equivalent: \" +\r\n//\t\t\t\t\tinst.equalHeaders(copy));\r\n//\r\n//\t\t\t// Test for missing values\r\n//\t\t\tSystem.out.println(\"Length of copy missing: \" + copy.isMissing(length));\r\n//\t\t\tSystem.out.println(\"Weight of copy missing: \" + copy.isMissing(weight.index()));\r\n//\t\t\tSystem.out.println(\"Length of copy missing: \" + \r\n//\t\t\t\t\tInstance.isMissingValue(copy.value(length)));\r\n//\t\t\tSystem.out.println(\"Missing value coded as: \" + Instance.missingValue());\r\n//\r\n//\t\t\t// Prints number of attributes and classes\r\n//\t\t\tSystem.out.println(\"Number of attributes: \" + copy.numAttributes());\r\n//\t\t\tSystem.out.println(\"Number of classes: \" + copy.numClasses());\r\n//\r\n//\t\t\t// Replace missing values\r\n//\t\t\tdouble[] meansAndModes = {2, 3, 0};\r\n//\t\t\tcopy.replaceMissingValues(meansAndModes);\r\n//\t\t\tSystem.out.println(\"Copy with missing value replaced: \" + copy);\r\n//\r\n//\t\t\t// Setting and getting values and weights\r\n//\t\t\tcopy.setClassMissing();\r\n//\t\t\tSystem.out.println(\"Copy with missing class: \" + copy);\r\n//\t\t\tcopy.setClassValue(0);\r\n//\t\t\tSystem.out.println(\"Copy with class value set to first value: \" + copy);\r\n//\t\t\tcopy.setClassValue(\"third\");\r\n//\t\t\tSystem.out.println(\"Copy with class value set to \\\"third\\\": \" + copy);\r\n//\t\t\tcopy.setMissing(1);\r\n//\t\t\tSystem.out.println(\"Copy with second attribute set to be missing: \" + copy);\r\n//\t\t\tcopy.setMissing(length);\r\n//\t\t\tSystem.out.println(\"Copy with length set to be missing: \" + copy);\r\n//\t\t\tcopy.setValue(0, 0);\r\n//\t\t\tSystem.out.println(\"Copy with first attribute set to 0: \" + copy);\r\n//\t\t\tcopy.setValue(weight, 1);\r\n//\t\t\tSystem.out.println(\"Copy with weight attribute set to 1: \" + copy);\r\n//\t\t\tcopy.setValue(position, \"second\");\r\n//\t\t\tSystem.out.println(\"Copy with position set to \\\"second\\\": \" + copy);\r\n//\t\t\tcopy.setValue(2, \"first\");\r\n//\t\t\tSystem.out.println(\"Copy with last attribute set to \\\"first\\\": \" + copy);\r\n//\t\t\tSystem.out.println(\"Current weight of instance copy: \" + copy.weight());\r\n//\t\t\tcopy.setWeight(2);\r\n//\t\t\tSystem.out.println(\"Current weight of instance copy (set to 2): \" + copy.weight());\r\n//\t\t\tSystem.out.println(\"Last value of copy: \" + copy.toString(2));\r\n//\t\t\tSystem.out.println(\"Value of position for copy: \" + copy.toString(position));\r\n//\t\t\tSystem.out.println(\"Last value of copy (internal format): \" + copy.value(2));\r\n//\t\t\tSystem.out.println(\"Value of position for copy (internal format): \" + \r\n//\t\t\t\t\tcopy.value(position));\r\n//\t\t} catch (Exception e) {\r\n//\t\t\te.printStackTrace();\r\n//\t\t}\r\n//\t}\r\n}\r\n\r\n\t\r\n",
        "name": "Instance.java",
        "path": "src/keel/Algorithms/SVM/SMO/core/Instance.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/SVM/SMO/core/Instance.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 129,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures m_Dataset == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 145,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures m_Dataset == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 160,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires numAttributes \u003e 0;    // Or maybe == 0 is okay too?\r"
        },
        {
          "limitHit": false,
          "lineNumber": 161,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures m_Dataset == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 180,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 198,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 214,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 229,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 246,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires classIndex() \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 265,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires classIndex() \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 299,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result == m_Dataset;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 315,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 331,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 349,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 364,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 403,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires m_Dataset == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 404,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= position \u0026\u0026 position \u003c= numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 509,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result == m_AttValues.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 523,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 537,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result == m_AttValues.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 575,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires classIndex() \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 595,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires classIndex() \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 618,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires classIndex() \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 715,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 814,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 855,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires m_Dataset != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1096,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires options != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 230,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures  \\result == m_Dataset.classIndex();\r"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "5f404a9470f17528445baabe3a5d9f5202adee7a"
        },
        "content": "/***********************************************************************\r\n\r\n\tThis file is part of KEEL-software, the Data Mining tool for regression, \r\n\tclassification, clustering, pattern mining and so on.\r\n\r\n\tCopyright (C) 2004-2010\r\n\t\r\n\tF. Herrera (herrera@decsai.ugr.es)\r\n    L. Sánchez (luciano@uniovi.es)\r\n    J. Alcalá-Fdez (jalcala@decsai.ugr.es)\r\n    S. García (sglopez@ujaen.es)\r\n    A. Fernández (alberto.fernandez@ujaen.es)\r\n    J. Luengo (julianlm@decsai.ugr.es)\r\n\r\n\tThis program is free software: you can redistribute it and/or modify\r\n\tit under the terms of the GNU General Public License as published by\r\n\tthe Free Software Foundation, either version 3 of the License, or\r\n\t(at your option) any later version.\r\n\r\n\tThis program is distributed in the hope that it will be useful,\r\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\tGNU General Public License for more details.\r\n\r\n\tYou should have received a copy of the GNU General Public License\r\n\talong with this program.  If not, see http://www.gnu.org/licenses/\r\n  \r\n**********************************************************************/\r\n\r\n/*\r\n *    This program is free software; you can redistribute it and/or modify\r\n *    it under the terms of the GNU General Public License as published by\r\n *    the Free Software Foundation; either version 2 of the License, or\r\n *    (at your option) any later version.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU General Public License\r\n *    along with this program; if not, write to the Free Software\r\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\r\n */\r\n\r\n/*\r\n *    Instances.java\r\n *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand\r\n *\r\n */\r\n\r\npackage keel.Algorithms.SVM.SMO.core;\r\n\r\nimport keel.Dataset.*;\r\n\r\nimport org.core.Randomize;\r\n\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\nimport java.io.Reader;\r\nimport java.io.Serializable;\r\nimport java.util.Enumeration;\r\nimport java.util.Random;\r\nimport java.util.Vector;\r\n\r\n/**\r\n * Class for handling an ordered set of weighted instances. \u003cp\u003e\r\n *\r\n * Typical usage: \u003cp\u003e\r\n * \u003cpre\u003e\r\n * import keel.Algorithms.SVM.SMO.core.converters.ConverterUtils.DataSource;\r\n * ...\r\n * \r\n * // Read all the instances in the file (ARFF, CSV, XRFF, ...)\r\n * DataSource source = new DataSource(filename);\r\n * Instances instances = source.getDataSet();\r\n *\r\n * // Make the last attribute be the class\r\n * instances.setClassIndex(instances.numAttributes() - 1);\r\n * \r\n * // Print header and instances.\r\n * System.out.println(\"\\nDataset:\\n\");\r\n * System.out.println(instances);\r\n * \r\n * ...\r\n * \u003c/pre\u003e\u003cp\u003e\r\n *\r\n * All methods that change a set of instances are safe, ie. a change\r\n * of a set of instances does not affect any other sets of\r\n * instances. All methods that change a datasets's attribute\r\n * information clone the dataset before it is changed.\r\n *\r\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\r\n * @author Len Trigg (trigg@cs.waikato.ac.nz)\r\n * @author FracPete (fracpete at waikato dot ac dot nz)\r\n * @version $Revision: 1.1 $ \r\n */\r\n//Modified to work with KEEL attributes, instead of Weka ones (Julian)\r\npublic class Instances \r\nimplements Serializable {\r\n\r\n\t/** for serialization */\r\n\tstatic final long serialVersionUID = -19412345060742748L;\r\n\r\n\t/** The filename extension that should be used for arff files */\r\n\tpublic final static String FILE_EXTENSION = \".arff\";\r\n\r\n\t/** The filename extension that should be used for bin. serialized instances files */\r\n\tpublic final static String SERIALIZED_OBJ_FILE_EXTENSION = \".bsi\";\r\n\r\n\t/** The keyword used to denote the start of an arff header */\r\n\tpublic final static String ARFF_RELATION = \"@relation\";\r\n\r\n\t/** The keyword used to denote the start of the arff data section */\r\n\tpublic final static String ARFF_DATA = \"@data\";\r\n\r\n\t/** The dataset's name. */\r\n\tprotected /*@spec_public non_null@*/ String m_RelationName;         \r\n\r\n\t/** The attribute information. */\r\n\tprotected /*@spec_public non_null@*/ FastVector m_Attributes;\r\n\t/*  public invariant (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c m_Attributes.size(); \r\n                    m_Attributes.elementAt(i) != null);\r\n\t */\r\n\r\n\t/** The instances. */\r\n\tprotected /*@spec_public non_null@*/ FastVector m_Instances;\r\n\r\n\t/** The class attribute's index */\r\n\tprotected int m_ClassIndex;\r\n\t//@ protected invariant classIndex() == m_ClassIndex;\r\n\r\n\t/** The lines read so far in case of incremental loading. Since the \r\n\t * StreamTokenizer will be re-initialized with every instance that is read,\r\n\t * we have to keep track of the number of lines read so far. \r\n\t * @see #readInstance(Reader) */\r\n\tprotected int m_Lines = 0;\r\n\r\n\t/**\r\n\t * Reads an ARFF file from a reader, and assigns a weight of\r\n\t * one to each instance. Lets the index of the class \r\n\t * attribute be undefined (negative).\r\n\t *\r\n\t * @param reader the reader\r\n\t * @throws IOException if the ARFF file is not read \r\n\t * successfully\r\n\t */\r\n//\tpublic Instances(/*@non_null@*/Reader reader) throws IOException {\r\n//\tArffReader arff = new ArffReader(reader);\r\n//\tInstances dataset = arff.getData();\r\n//\tinitialize(dataset, dataset.numInstances());\r\n//\tdataset.copyInstances(0, this, dataset.numInstances());\r\n//\tcompactify();\r\n//\t}\r\n\r\n\t/**\r\n\t * Reads the header of an ARFF file from a reader and \r\n\t * reserves space for the given number of instances. Lets\r\n\t * the class index be undefined (negative).\r\n\t *\r\n\t * @param reader the reader\r\n\t * @param capacity the capacity\r\n\t * @throws IllegalArgumentException if the header is not read successfully\r\n\t * or the capacity is negative.\r\n\t * @throws IOException if there is a problem with the reader.\r\n\t * @deprecated instead of using this method in conjunction with the\r\n\t * \u003ccode\u003ereadInstance(Reader)\u003c/code\u003e method, one should use the \r\n\t * \u003ccode\u003eArffLoader\u003c/code\u003e or \u003ccode\u003eDataSource\u003c/code\u003e class instead.\r\n\t * @see weka.core.converters.ArffLoader\r\n\t * @see weka.core.converters.ConverterUtils.DataSource\r\n\t */\r\n\t//@ requires capacity \u003e= 0;\r\n\t//@ ensures classIndex() == -1;\r\n//\t@Deprecated public Instances(/*@non_null@*/Reader reader, int capacity)\r\n//\tthrows IOException {\r\n\r\n//\tArffReader arff = new ArffReader(reader, 0);\r\n//\tInstances header = arff.getStructure();\r\n//\tinitialize(header, capacity);\r\n//\tm_Lines = arff.getLineNo();\r\n//\t}\r\n\r\n\t/**\r\n\t * Constructor copying all instances and references to\r\n\t * the header information from the given set of instances.\r\n\t *\r\n\t * @param dataset the set to be copied\r\n\t */\r\n\tpublic Instances(/*@non_null@*/Instances dataset) {\r\n\r\n\t\tthis(dataset, dataset.numInstances());\r\n\r\n\t\tdataset.copyInstances(0, this, dataset.numInstances());\r\n\t}\r\n\r\n\t/**\r\n\t * Constructor creating an empty set of instances. Copies references\r\n\t * to the header information from the given set of instances. Sets\r\n\t * the capacity of the set of instances to 0 if its negative.\r\n\t *\r\n\t * @param dataset the instances from which the header \r\n\t * information is to be taken\r\n\t * @param capacity the capacity of the new dataset \r\n\t */\r\n\tpublic Instances(/*@non_null@*/Instances dataset, int capacity) {\r\n\t\tinitialize(dataset, capacity);\r\n\t}\r\n\r\n\t/**\r\n\t * initializes with the header information of the given dataset and sets\r\n\t * the capacity of the set of instances.\r\n\t * \r\n\t * @param dataset the dataset to use as template\r\n\t * @param capacity the number of rows to reserve\r\n\t */\r\n\tprotected void initialize(Instances dataset, int capacity) {\r\n\t\tif (capacity \u003c 0)\r\n\t\t\tcapacity = 0;\r\n\r\n\t\t// Strings only have to be \"shallow\" copied because\r\n\t\t// they can't be modified.\r\n\t\tm_ClassIndex   = dataset.m_ClassIndex;\r\n\t\tm_RelationName = dataset.m_RelationName;\r\n\t\tm_Attributes   = dataset.m_Attributes;\r\n\t\tm_Instances    = new FastVector(capacity);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a new set of instances by copying a \r\n\t * subset of another set.\r\n\t *\r\n\t * @param source the set of instances from which a subset \r\n\t * is to be created\r\n\t * @param first the index of the first instance to be copied\r\n\t * @param toCopy the number of instances to be copied\r\n\t * @throws IllegalArgumentException if first and toCopy are out of range\r\n\t */\r\n\t//@ requires 0 \u003c= first;\r\n\t//@ requires 0 \u003c= toCopy;\r\n\t//@ requires first + toCopy \u003c= source.numInstances();\r\n\tpublic Instances(/*@non_null@*/Instances source, int first, int toCopy) {\r\n\r\n\t\tthis(source, toCopy);\r\n\r\n\t\tif ((first \u003c 0) || ((first + toCopy) \u003e source.numInstances())) {\r\n\t\t\tthrow new IllegalArgumentException(\"Parameters first and/or toCopy out \"+\r\n\t\t\t\"of range\");\r\n\t\t}\r\n\t\tsource.copyInstances(first, this, toCopy);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an empty set of instances. Uses the given\r\n\t * attribute information. Sets the capacity of the set of \r\n\t * instances to 0 if its negative. Given attribute information\r\n\t * must not be changed after this constructor has been used.\r\n\t *\r\n\t * @param name the name of the relation\r\n\t * @param attInfo the attribute information\r\n\t * @param capacity the capacity of the set\r\n\t */\r\n\tpublic Instances(/*@non_null@*/String name, \r\n\t\t\t/*@non_null@*/FastVector attInfo, int capacity) {\r\n\r\n\t\tm_RelationName = name;\r\n\t\tm_ClassIndex = -1;\r\n\t\tm_Attributes = attInfo;\r\n//\t\tfor (int i = 0; i \u003c numAttributes(); i++) {\r\n//\t\tattribute(i).setIndex(i);\r\n//\t\t}\r\n\t\tm_Instances = new FastVector(capacity);\r\n\t}\r\n\r\n\t/**\r\n\t * Create a copy of the structure, but \"cleanse\" string types (i.e.\r\n\t * doesn't contain references to the strings seen in the past).\r\n\t * Also cleanses all relational attributes.\r\n\t *\r\n\t * @return a copy of the instance structure.\r\n\t */\r\n//\tpublic Instances stringFreeStructure() {\r\n\r\n//\tFastVector atts = (FastVector)m_Attributes.copy();\r\n//\tfor (int i = 0 ; i \u003c atts.size(); i++) {\r\n//\tAttribute att = (Attribute)atts.elementAt(i);\r\n//\tif (att.type() == Attribute.STRING) {\r\n//\tatts.setElementAt(new Attribute(att.name(), (FastVector)null), i);\r\n//\t} else if (att.type() == Attribute.RELATIONAL) {\r\n//\tatts.setElementAt(new Attribute(att.name(), new Instances(att.relation(), 0)), i);\r\n//\t}\r\n//\t}\r\n//\tInstances result = new Instances(relationName(), atts, 0);\r\n//\tresult.m_ClassIndex = m_ClassIndex;\r\n//\treturn result;\r\n//\t}\r\n\r\n\t/**\r\n\t * Adds one instance to the end of the set. \r\n\t * Shallow copies instance before it is added. Increases the\r\n\t * size of the dataset if it is not large enough. Does not\r\n\t * check if the instance is compatible with the dataset.\r\n\t * Note: String or relational values are not transferred.\r\n\t *\r\n\t * @param instance the instance to be added\r\n\t */\r\n\tpublic void add(/*@non_null@*/ Instance instance) {\r\n\r\n\t\tInstance newInstance = (Instance)instance.copy();\r\n\r\n\t\tnewInstance.setDataset(this);\r\n\t\tm_Instances.addElement(newInstance);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an attribute.\r\n\t *\r\n\t * @param index the attribute's index (index starts with 0)\r\n\t * @return the attribute at the given position\r\n\t */\r\n\t//@ requires 0 \u003c= index;\r\n\t//@ requires index \u003c m_Attributes.size();\r\n\t//@ ensures \\result != null;\r\n\tpublic /*@pure@*/ Attribute attribute(int index) {\r\n\r\n\t\treturn (Attribute) m_Attributes.elementAt(index);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an attribute given its name. If there is more than\r\n\t * one attribute with the same name, it returns the first one.\r\n\t * Returns null if the attribute can't be found.\r\n\t *\r\n\t * @param name the attribute's name\r\n\t * @return the attribute with the given name, null if the\r\n\t * attribute can't be found\r\n\t */ \r\n\tpublic /*@pure@*/ Attribute attribute(String name) {\r\n\r\n\t\tfor (int i = 0; i \u003c numAttributes(); i++) {\r\n\t\t\tif (attribute(i).getName().equals(name)) {\r\n\t\t\t\treturn attribute(i);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks for attributes of the given type in the dataset\r\n\t *\r\n\t * @param attType  the attribute type to look for\r\n\t * @return         true if attributes of the given type are present\r\n\t */\r\n\tpublic boolean checkForAttributeType(int attType) {\r\n\r\n\t\tint i = 0;\r\n\r\n\t\twhile (i \u003c m_Attributes.size()) {\r\n\t\t\tif (attribute(i++).getType() == attType) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks for string attributes in the dataset\r\n\t *\r\n\t * @return true if string attributes are present, false otherwise\r\n\t */\r\n\tpublic /*@pure@*/ boolean checkForStringAttributes() {\r\n\t\treturn checkForAttributeType(Attribute.NOMINAL);\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the given instance is compatible\r\n\t * with this dataset. Only looks at the size of\r\n\t * the instance and the ranges of the values for \r\n\t * nominal and string attributes.\r\n\t *\r\n\t * @param instance the instance to check\r\n\t * @return true if the instance is compatible with the dataset \r\n\t */\r\n\tpublic /*@pure@*/ boolean checkInstance(Instance instance) {\r\n\r\n\t\tif (instance.numAttributes() != numAttributes()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tfor (int i = 0; i \u003c numAttributes(); i++) {\r\n\t\t\tif (instance.isMissing(i)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t} else if (attribute(i).getType()==Attribute.NOMINAL) {\r\n\t\t\t\tif (!(Utils.eq(instance.value(i),\r\n\t\t\t\t\t\t(double)(int)instance.value(i)))) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t} else if (Utils.sm(instance.value(i), 0) ||\r\n\t\t\t\t\t\tUtils.gr(instance.value(i),\r\n\t\t\t\t\t\t\t\tattribute(i).getNumNominalValues())) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the class attribute.\r\n\t *\r\n\t * @return the class attribute\r\n\t * @throws UnassignedClassException if the class is not set\r\n\t */\r\n\t//@ requires classIndex() \u003e= 0;\r\n\tpublic /*@pure@*/ Attribute classAttribute() {\r\n\r\n\t\tif (m_ClassIndex \u003c 0) {\r\n\t\t\tthrow new UnassignedClassException(\"Class index is negative (not set)!\");\r\n\t\t}\r\n\t\treturn attribute(m_ClassIndex);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the class attribute's index. Returns negative number\r\n\t * if it's undefined.\r\n\t *\r\n\t * @return the class index as an integer\r\n\t */\r\n\t// ensures \\result == m_ClassIndex;\r\n\tpublic /*@pure@*/ int classIndex() {\r\n\r\n\t\treturn m_ClassIndex;\r\n\t}\r\n\r\n\t/**\r\n\t * Compactifies the set of instances. Decreases the capacity of\r\n\t * the set so that it matches the number of instances in the set.\r\n\t */\r\n\tpublic void compactify() {\r\n\r\n\t\tm_Instances.trimToSize();\r\n\t}\r\n\r\n\t/**\r\n\t * Removes all instances from the set.\r\n\t */\r\n\tpublic void delete() {\r\n\r\n\t\tm_Instances = new FastVector();\r\n\t}\r\n\r\n\t/**\r\n\t * Removes an instance at the given position from the set.\r\n\t *\r\n\t * @param index the instance's position (index starts with 0)\r\n\t */\r\n\t//@ requires 0 \u003c= index \u0026\u0026 index \u003c numInstances();\r\n\tpublic void delete(int index) {\r\n\r\n\t\tm_Instances.removeElementAt(index);\r\n\t}\r\n\r\n\t/**\r\n\t * Deletes an attribute at the given position \r\n\t * (0 to numAttributes() - 1). A deep copy of the attribute\r\n\t * information is performed before the attribute is deleted.\r\n\t *\r\n\t * @param position the attribute's position (position starts with 0)\r\n\t * @throws IllegalArgumentException if the given index is out of range \r\n\t *            or the class attribute is being deleted\r\n\t */\r\n\t//@ requires 0 \u003c= position \u0026\u0026 position \u003c numAttributes();\r\n\t//@ requires position != classIndex();\r\n\tpublic void deleteAttributeAt(int position) {\r\n\r\n\t\tif ((position \u003c 0) || (position \u003e= m_Attributes.size())) {\r\n\t\t\tthrow new IllegalArgumentException(\"Index out of range\");\r\n\t\t}\r\n\t\tif (position == m_ClassIndex) {\r\n\t\t\tthrow new IllegalArgumentException(\"Can't delete class attribute\");\r\n\t\t}\r\n\t\tfreshAttributeInfo();\r\n\t\tif (m_ClassIndex \u003e position) {\r\n\t\t\tm_ClassIndex--;\r\n\t\t}\r\n\t\tm_Attributes.removeElementAt(position);\r\n\t\tfor (int i = position; i \u003c m_Attributes.size(); i++) {\r\n\t\t\tAttribute current = (Attribute)m_Attributes.elementAt(i);\r\n//\t\t\tcurrent.setIndex(current.index() - 1);\r\n\t\t}\r\n\t\tfor (int i = 0; i \u003c numInstances(); i++) {\r\n\t\t\tinstance(i).forceDeleteAttributeAt(position); \r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Deletes all attributes of the given type in the dataset. A deep copy of \r\n\t * the attribute information is performed before an attribute is deleted.\r\n\t *\r\n\t * @param attType the attribute type to delete\r\n\t * @throws IllegalArgumentException if attribute couldn't be \r\n\t * successfully deleted (probably because it is the class attribute).\r\n\t */\r\n\tpublic void deleteAttributeType(int attType) {\r\n\t\tint i = 0;\r\n\t\twhile (i \u003c m_Attributes.size()) {\r\n\t\t\tif (attribute(i).getType() == attType) {\r\n\t\t\t\tdeleteAttributeAt(i);\r\n\t\t\t} else {\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Deletes all string attributes in the dataset. A deep copy of the attribute\r\n\t * information is performed before an attribute is deleted.\r\n\t *\r\n\t * @throws IllegalArgumentException if string attribute couldn't be \r\n\t * successfully deleted (probably because it is the class attribute).\r\n\t * @see #deleteAttributeType(int)\r\n\t */\r\n\tpublic void deleteStringAttributes() {\r\n\t\tdeleteAttributeType(Attribute.NOMINAL);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes all instances with missing values for a particular\r\n\t * attribute from the dataset.\r\n\t *\r\n\t * @param attIndex the attribute's index (index starts with 0)\r\n\t */\r\n\t//@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\r\n\tpublic void deleteWithMissing(int attIndex) {\r\n\r\n\t\tFastVector newInstances = new FastVector(numInstances());\r\n\r\n\t\tfor (int i = 0; i \u003c numInstances(); i++) {\r\n\t\t\tif (!instance(i).isMissing(attIndex)) {\r\n\t\t\t\tnewInstances.addElement(instance(i));\r\n\t\t\t}\r\n\t\t}\r\n\t\tm_Instances = newInstances;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes all instances with missing values for a particular\r\n\t * attribute from the dataset.\r\n\t *\r\n\t * @param att the attribute\r\n\t */\r\n\tpublic void deleteWithMissing(/*@non_null@*/ Attribute att) {\r\n\t\t\r\n\t\tdeleteWithMissing(indexOf(att));\r\n\t}\r\n\r\n\t/**\r\n\t * Removes all instances with a missing class value\r\n\t * from the dataset.\r\n\t *\r\n\t * @throws UnassignedClassException if class is not set\r\n\t */\r\n\tpublic void deleteWithMissingClass() {\r\n\r\n\t\tif (m_ClassIndex \u003c 0) {\r\n\t\t\tthrow new UnassignedClassException(\"Class index is negative (not set)!\");\r\n\t\t}\r\n\t\tdeleteWithMissing(m_ClassIndex);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an enumeration of all the attributes.\r\n\t *\r\n\t * @return enumeration of all the attributes.\r\n\t */\r\n\tpublic /*@non_null pure@*/ Enumeration enumerateAttributes() {\r\n\r\n\t\treturn m_Attributes.elements(m_ClassIndex);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an enumeration of all instances in the dataset.\r\n\t *\r\n\t * @return enumeration of all instances in the dataset\r\n\t */\r\n\tpublic /*@non_null pure@*/ Enumeration enumerateInstances() {\r\n\r\n\t\treturn m_Instances.elements();\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if two headers are equivalent.\r\n\t *\r\n\t * @param dataset another dataset\r\n\t * @return true if the header of the given dataset is equivalent \r\n\t * to this header\r\n\t */\r\n\tpublic /*@pure@*/ boolean equalHeaders(Instances dataset){\r\n\r\n\t\t// Check class and all attributes\r\n\t\tif (m_ClassIndex != dataset.m_ClassIndex) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (m_Attributes.size() != dataset.m_Attributes.size()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tfor (int i = 0; i \u003c m_Attributes.size(); i++) {\r\n\t\t\tif (!(attribute(i).equals(dataset.attribute(i)))) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the first instance in the set.\r\n\t *\r\n\t * @return the first instance in the set\r\n\t */\r\n\t//@ requires numInstances() \u003e 0;\r\n\tpublic /*@non_null pure@*/ Instance firstInstance() {\r\n\r\n\t\treturn (Instance)m_Instances.firstElement();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a random number generator. The initial seed of the random\r\n\t * number generator depends on the given seed and the hash code of\r\n\t * a string representation of a instances chosen based on the given\r\n\t * seed. \r\n\t *\r\n\t * @param seed the given seed\r\n\t * @return the random number generator\r\n\t */\r\n\tpublic Random getRandomNumberGenerator(long seed) {\r\n\r\n\t\tRandom r = new Random(seed);\r\n\t\tr.setSeed(instance(r.nextInt(numInstances())).toString().hashCode() + seed);\r\n\t\treturn r;\r\n\t}\r\n\r\n\t/**\r\n\t * Inserts an attribute at the given position (0 to \r\n\t * numAttributes()) and sets all values to be missing.\r\n\t * Shallow copies the attribute before it is inserted, and performs\r\n\t * a deep copy of the existing attribute information.\r\n\t *\r\n\t * @param att the attribute to be inserted\r\n\t * @param position the attribute's position (position starts with 0)\r\n\t * @throws IllegalArgumentException if the given index is out of range\r\n\t */\r\n\t//@ requires 0 \u003c= position;\r\n\t//@ requires position \u003c= numAttributes();\r\n\tpublic void insertAttributeAt(/*@non_null@*/ Attribute att, int position) {\r\n\r\n\t\tif ((position \u003c 0) ||\r\n\t\t\t\t(position \u003e m_Attributes.size())) {\r\n\t\t\tthrow new IllegalArgumentException(\"Index out of range\");\r\n\t\t}\r\n\t\tfreshAttributeInfo();\r\n//\t\tatt.setIndex(position);\r\n\t\tm_Attributes.insertElementAt(att, position);\r\n\t\tfor (int i = position + 1; i \u003c m_Attributes.size(); i++) {\r\n\t\t\tAttribute current = (Attribute)m_Attributes.elementAt(i);\r\n//\t\t\tcurrent.setIndex(indexOf(current) + 1);\r\n\t\t}\r\n\t\tfor (int i = 0; i \u003c numInstances(); i++) {\r\n\t\t\tinstance(i).forceInsertAttributeAt(position);\r\n\t\t}\r\n\t\tif (m_ClassIndex \u003e= position) {\r\n\t\t\tm_ClassIndex++;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the instance at the given position.\r\n\t *\r\n\t * @param index the instance's index (index starts with 0)\r\n\t * @return the instance at the given position\r\n\t */\r\n\t//@ requires 0 \u003c= index;\r\n\t//@ requires index \u003c numInstances();\r\n\tpublic /*@non_null pure@*/ Instance instance(int index) {\r\n\r\n\t\treturn (Instance)m_Instances.elementAt(index);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the kth-smallest attribute value of a numeric attribute.\r\n\t * Note that calling this method will change the order of the data!\r\n\t *\r\n\t * @param att the Attribute object\r\n\t * @param k the value of k\r\n\t * @return the kth-smallest value\r\n\t */\r\n\tpublic double kthSmallestValue(Attribute att, int k) {\r\n\r\n\t\treturn kthSmallestValue(indexOf(att), k);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the kth-smallest attribute value of a numeric attribute.\r\n\t * Note that calling this method will change the order of the data!\r\n\t * The number of non-missing values in the data must be as least\r\n\t * as last as k for this to work.\r\n\t *\r\n\t * @param attIndex the attribute's index\r\n\t * @param k the value of k\r\n\t * @return the kth-smallest value\r\n\t */\r\n\tpublic double kthSmallestValue(int attIndex, int k) {\r\n\r\n\t\tif (attribute(attIndex).getType()==Attribute.NOMINAL) {\r\n\t\t\tthrow new IllegalArgumentException(\"Instances: attribute must be numeric to compute kth-smallest value.\");\r\n\t\t}\r\n\r\n\t\tint i,j;\r\n\r\n\t\t// move all instances with missing values to end\r\n\t\tj = numInstances() - 1;\r\n\t\ti = 0;\r\n\t\twhile (i \u003c= j) {\r\n\t\t\tif (instance(j).isMissing(attIndex)) {\r\n\t\t\t\tj--;\r\n\t\t\t} else {\r\n\t\t\t\tif (instance(i).isMissing(attIndex)) {\r\n\t\t\t\t\tswap(i,j);\r\n\t\t\t\t\tj--;\r\n\t\t\t\t}\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ((k \u003c 0) || (k \u003e j)) {\r\n\t\t\tthrow new IllegalArgumentException(\"Instances: value for k for computing kth-smallest value too large.\");\r\n\t\t}\r\n\r\n\t\treturn instance(select(attIndex, 0, j, k)).value(attIndex);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the last instance in the set.\r\n\t *\r\n\t * @return the last instance in the set\r\n\t */\r\n\t//@ requires numInstances() \u003e 0;\r\n\tpublic /*@non_null pure@*/ Instance lastInstance() {\r\n\r\n\t\treturn (Instance)m_Instances.lastElement();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the mean (mode) for a numeric (nominal) attribute as\r\n\t * a floating-point value. Returns 0 if the attribute is neither nominal nor \r\n\t * numeric. If all values are missing it returns zero.\r\n\t *\r\n\t * @param attIndex the attribute's index (index starts with 0)\r\n\t * @return the mean or the mode\r\n\t */\r\n\tpublic /*@pure@*/ double meanOrMode(int attIndex) {\r\n\r\n\t\tdouble result, found;\r\n\t\tint [] counts;\r\n\r\n\t\tif (!(attribute(attIndex).getType()==Attribute.NOMINAL)) {\r\n\t\t\tresult = found = 0;\r\n\t\t\tfor (int j = 0; j \u003c numInstances(); j++) {\r\n\t\t\t\tif (!instance(j).isMissing(attIndex)) {\r\n\t\t\t\t\tfound += instance(j).weight();\r\n\t\t\t\t\tresult += instance(j).weight()*instance(j).value(attIndex);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (found \u003c= 0) {\r\n\t\t\t\treturn 0;\r\n\t\t\t} else {\r\n\t\t\t\treturn result / found;\r\n\t\t\t}\r\n\t\t} else if (attribute(attIndex).getType()==Attribute.NOMINAL) {\r\n\t\t\tcounts = new int[attribute(attIndex).getNumNominalValues()];\r\n\t\t\tfor (int j = 0; j \u003c numInstances(); j++) {\r\n\t\t\t\tif (!instance(j).isMissing(attIndex)) {\r\n\t\t\t\t\tcounts[(int) instance(j).value(attIndex)] += instance(j).weight();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn (double)Utils.maxIndex(counts);\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the mean (mode) for a numeric (nominal) attribute as a\r\n\t * floating-point value.  Returns 0 if the attribute is neither\r\n\t * nominal nor numeric.  If all values are missing it returns zero.\r\n\t *\r\n\t * @param att the attribute\r\n\t * @return the mean or the mode \r\n\t */\r\n\tpublic /*@pure@*/ double meanOrMode(Attribute att) {\r\n\r\n\t\treturn meanOrMode(indexOf(att));\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the number of attributes.\r\n\t *\r\n\t * @return the number of attributes as an integer\r\n\t */\r\n\t//@ ensures \\result == m_Attributes.size();\r\n\tpublic /*@pure@*/ int numAttributes() {\r\n\r\n\t\treturn m_Attributes.size();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the number of class labels.\r\n\t *\r\n\t * @return the number of class labels as an integer if the class \r\n\t * attribute is nominal, 1 otherwise.\r\n\t * @throws UnassignedClassException if the class is not set\r\n\t */\r\n\t//@ requires classIndex() \u003e= 0;\r\n\tpublic /*@pure@*/ int numClasses() {\r\n\r\n\t\tif (m_ClassIndex \u003c 0) {\r\n\t\t\tthrow new UnassignedClassException(\"Class index is negative (not set)!\");\r\n\t\t}\r\n\t\tif (!(classAttribute().getType()==Attribute.NOMINAL)) {\r\n\t\t\treturn 1;\r\n\t\t} else {\r\n\t\t\treturn classAttribute().getNumNominalValues();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the number of distinct values of a given attribute.\r\n\t * Returns the number of instances if the attribute is a\r\n\t * string attribute. The value 'missing' is not counted.\r\n\t *\r\n\t * @param attIndex the attribute (index starts with 0)\r\n\t * @return the number of distinct values of a given attribute\r\n\t */\r\n\t//@ requires 0 \u003c= attIndex;\r\n\t//@ requires attIndex \u003c numAttributes();\r\n\tpublic /*@pure@*/ int numDistinctValues(int attIndex) {\r\n\r\n\t\tif (!(attribute(attIndex).getType()==Attribute.NOMINAL)) {\r\n\t\t\tdouble [] attVals = attributeToDoubleArray(attIndex);\r\n\t\t\tint [] sorted = Utils.sort(attVals);\r\n\t\t\tdouble prev = 0;\r\n\t\t\tint counter = 0;\r\n\t\t\tfor (int i = 0; i \u003c sorted.length; i++) {\r\n\t\t\t\tInstance current = instance(sorted[i]);\r\n\t\t\t\tif (current.isMissing(attIndex)) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif ((i == 0) || \r\n\t\t\t\t\t\t(current.value(attIndex) \u003e prev)) {\r\n\t\t\t\t\tprev = current.value(attIndex);\r\n\t\t\t\t\tcounter++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn counter;\r\n\t\t} else {\r\n\t\t\treturn attribute(attIndex).getNumNominalValues();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the number of distinct values of a given attribute.\r\n\t * Returns the number of instances if the attribute is a\r\n\t * string attribute. The value 'missing' is not counted.\r\n\t *\r\n\t * @param att the attribute\r\n\t * @return the number of distinct values of a given attribute\r\n\t */\r\n\tpublic /*@pure@*/ int numDistinctValues(/*@non_null@*/Attribute att) {\r\n\r\n\t\treturn numDistinctValues(indexOf(att));\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the number of instances in the dataset.\r\n\t *\r\n\t * @return the number of instances in the dataset as an integer\r\n\t */\r\n\t//@ ensures \\result == m_Instances.size();\r\n\tpublic /*@pure@*/ int numInstances() {\r\n\r\n\t\treturn m_Instances.size();\r\n\t}\r\n\r\n\t/**\r\n\t * Shuffles the instances in the set so that they are ordered \r\n\t * randomly.\r\n\t *\r\n\t * @param random a random number generator\r\n\t */\r\n\tpublic void randomize(Random random) {\r\n\r\n\t\tfor (int j = numInstances() - 1; j \u003e 0; j--)\r\n\t\t\tswap(j, random.nextInt(j+1));\r\n\t}\r\n\t\r\n\t/**\r\n\t * Shuffles the instances in the set so that they are ordered \r\n\t * randomly.\r\n\t * It uses the Randomize method of KEEL\r\n\t */\r\n\tpublic void randomize() {\r\n\r\n\t\tfor (int j = numInstances() - 1; j \u003e 0; j--)\r\n\t\t\tswap(j, Randomize.Randint(0, j+1));\r\n\t}\r\n\r\n\t/**\r\n\t * Reads a single instance from the reader and appends it\r\n\t * to the dataset.  Automatically expands the dataset if it\r\n\t * is not large enough to hold the instance. This method does\r\n\t * not check for carriage return at the end of the line.\r\n\t *\r\n\t * @param reader the reader \r\n\t * @return false if end of file has been reached\r\n\t * @throws IOException if the information is not read \r\n\t * successfully\r\n\t * @deprecated instead of using this method in conjunction with the\r\n\t * \u003ccode\u003ereadInstance(Reader)\u003c/code\u003e method, one should use the \r\n\t * \u003ccode\u003eArffLoader\u003c/code\u003e or \u003ccode\u003eDataSource\u003c/code\u003e class instead.\r\n\t * @see weka.core.converters.ArffLoader\r\n\t * @see weka.core.converters.ConverterUtils.DataSource\r\n\t */ \r\n//\t@Deprecated public boolean readInstance(Reader reader) throws IOException {\r\n//\r\n//\t\tArffReader arff = new ArffReader(reader, this, m_Lines, 1);\r\n//\t\tInstance inst = arff.readInstance(arff.getData(), false);\r\n//\t\tm_Lines = arff.getLineNo();\r\n//\t\tif (inst != null) {\r\n//\t\t\tadd(inst);\r\n//\t\t\treturn true;\r\n//\t\t}\r\n//\t\telse {\r\n//\t\t\treturn false;\r\n//\t\t}\r\n//\t}    \r\n\r\n\t/**\r\n\t * Returns the relation's name.\r\n\t *\r\n\t * @return the relation's name as a string\r\n\t */\r\n\t//@ ensures \\result == m_RelationName;\r\n\tpublic /*@pure@*/ String relationName() {\r\n\r\n\t\treturn m_RelationName;\r\n\t}\r\n\r\n\t/**\r\n\t * Renames an attribute. This change only affects this\r\n\t * dataset.\r\n\t *\r\n\t * @param att the attribute's index (index starts with 0)\r\n\t * @param name the new name\r\n\t */\r\n//\tpublic void renameAttribute(int att, String name) {\r\n//\r\n//\t\tAttribute newAtt = attribute(att).copy(name);\r\n//\t\tFastVector newVec = new FastVector(numAttributes());\r\n//\r\n//\t\tfor (int i = 0; i \u003c numAttributes(); i++) {\r\n//\t\t\tif (i == att) {\r\n//\t\t\t\tnewVec.addElement(newAtt);\r\n//\t\t\t} else {\r\n//\t\t\t\tnewVec.addElement(attribute(i));\r\n//\t\t\t}\r\n//\t\t}\r\n//\t\tm_Attributes = newVec;\r\n//\t}\r\n\r\n\t/**\r\n\t * Renames an attribute. This change only affects this\r\n\t * dataset.\r\n\t *\r\n\t * @param att the attribute\r\n\t * @param name the new name\r\n\t */\r\n//\tpublic void renameAttribute(Attribute att, String name) {\r\n//\r\n//\t\trenameAttribute(indexOf(att), name);\r\n//\t}\r\n\r\n\t/**\r\n\t * Renames the value of a nominal (or string) attribute value. This\r\n\t * change only affects this dataset.\r\n\t *\r\n\t * @param att the attribute's index (index starts with 0)\r\n\t * @param val the value's index (index starts with 0)\r\n\t * @param name the new name \r\n\t */\r\n//\tpublic void renameAttributeValue(int att, int val, String name) {\r\n//\r\n//\t\tAttribute newAtt = (Attribute)attribute(att).copy();\r\n//\t\tFastVector newVec = new FastVector(numAttributes());\r\n//\r\n////\t\tnewAtt.setValue(val, name);\r\n//\t\tfor (int i = 0; i \u003c numAttributes(); i++) {\r\n//\t\t\tif (i == att) {\r\n//\t\t\t\tnewVec.addElement(newAtt);\r\n//\t\t\t} else {\r\n//\t\t\t\tnewVec.addElement(attribute(i));\r\n//\t\t\t}\r\n//\t\t}\r\n//\t\tm_Attributes = newVec;\r\n//\t}\r\n\r\n\t/**\r\n\t * Renames the value of a nominal (or string) attribute value. This\r\n\t * change only affects this dataset.\r\n\t *\r\n\t * @param att the attribute\r\n\t * @param val the value\r\n\t * @param name the new name\r\n\t */\r\n//\tpublic void renameAttributeValue(Attribute att, String val, \r\n//\t\t\tString name) {\r\n//\r\n//\t\tint v = indexOfValue(att,val);\r\n////\t\tint v = att.indexOfValue(val);\r\n//\t\tif (v == -1) throw new IllegalArgumentException(val + \" not found\");\r\n//\t\trenameAttributeValue(indexOf(att), v, name);\r\n//\t}\r\n\r\n\t/**\r\n\t * Creates a new dataset of the same size using random sampling\r\n\t * with replacement.\r\n\t *\r\n\t * @param random a random number generator\r\n\t * @return the new dataset\r\n\t */\r\n\tpublic Instances resample(Random random) {\r\n\r\n\t\tInstances newData = new Instances(this, numInstances());\r\n\t\twhile (newData.numInstances() \u003c numInstances()) {\r\n\t\t\tnewData.add(instance(random.nextInt(numInstances())));\r\n\t\t}\r\n\t\treturn newData;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a new dataset of the same size using random sampling\r\n\t * with replacement according to the current instance weights. The\r\n\t * weights of the instances in the new dataset are set to one.\r\n\t *\r\n\t * @param random a random number generator\r\n\t * @return the new dataset\r\n\t */\r\n\tpublic Instances resampleWithWeights(Random random) {\r\n\r\n\t\tdouble [] weights = new double[numInstances()];\r\n\t\tfor (int i = 0; i \u003c weights.length; i++) {\r\n\t\t\tweights[i] = instance(i).weight();\r\n\t\t}\r\n\t\treturn resampleWithWeights(random, weights);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Creates a new dataset of the same size using random sampling\r\n\t * with replacement according to the given weight vector. The\r\n\t * weights of the instances in the new dataset are set to one.\r\n\t * The length of the weight vector has to be the same as the\r\n\t * number of instances in the dataset, and all weights have to\r\n\t * be positive.\r\n\t *\r\n\t * @param random a random number generator\r\n\t * @param weights the weight vector\r\n\t * @return the new dataset\r\n\t * @throws IllegalArgumentException if the weights array is of the wrong\r\n\t * length or contains negative weights.\r\n\t */\r\n\tpublic Instances resampleWithWeights(Random random, \r\n\t\t\tdouble[] weights) {\r\n\r\n\t\tif (weights.length != numInstances()) {\r\n\t\t\tthrow new IllegalArgumentException(\"weights.length != numInstances.\");\r\n\t\t}\r\n\t\tInstances newData = new Instances(this, numInstances());\r\n\t\tif (numInstances() == 0) {\r\n\t\t\treturn newData;\r\n\t\t}\r\n\t\tdouble[] probabilities = new double[numInstances()];\r\n\t\tdouble sumProbs = 0, sumOfWeights = Utils.sum(weights);\r\n\t\tfor (int i = 0; i \u003c numInstances(); i++) {\r\n\t\t\tsumProbs += random.nextDouble();\r\n\t\t\tprobabilities[i] = sumProbs;\r\n\t\t}\r\n\t\tUtils.normalize(probabilities, sumProbs / sumOfWeights);\r\n\r\n\t\t// Make sure that rounding errors don't mess things up\r\n\t\tprobabilities[numInstances() - 1] = sumOfWeights;\r\n\t\tint k = 0; int l = 0;\r\n\t\tsumProbs = 0;\r\n\t\twhile ((k \u003c numInstances() \u0026\u0026 (l \u003c numInstances()))) {\r\n\t\t\tif (weights[l] \u003c 0) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"Weights have to be positive.\");\r\n\t\t\t}\r\n\t\t\tsumProbs += weights[l];\r\n\t\t\twhile ((k \u003c numInstances()) \u0026\u0026\r\n\t\t\t\t\t(probabilities[k] \u003c= sumProbs)) { \r\n\t\t\t\tnewData.add(instance(l));\r\n\t\t\t\tnewData.instance(k).setWeight(1);\r\n\t\t\t\tk++;\r\n\t\t\t}\r\n\t\t\tl++;\r\n\t\t}\r\n\t\treturn newData;\r\n\t}\r\n\r\n\t/** \r\n\t * Sets the class attribute.\r\n\t *\r\n\t * @param att attribute to be the class\r\n\t */\r\n\tpublic void setClass(Attribute att) {\r\n\r\n\t\tm_ClassIndex = indexOf(att);\r\n\t}\r\n\r\n\t/** \r\n\t * Sets the class index of the set.\r\n\t * If the class index is negative there is assumed to be no class.\r\n\t * (ie. it is undefined)\r\n\t *\r\n\t * @param classIndex the new class index (index starts with 0)\r\n\t * @throws IllegalArgumentException if the class index is too big or \u003c 0\r\n\t */\r\n\tpublic void setClassIndex(int classIndex) {\r\n\r\n\t\tif (classIndex \u003e= numAttributes()) {\r\n\t\t\tthrow new IllegalArgumentException(\"Invalid class index: \" + classIndex);\r\n\t\t}\r\n\t\tm_ClassIndex = classIndex;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the relation's name.\r\n\t *\r\n\t * @param newName the new relation name.\r\n\t */\r\n\tpublic void setRelationName(/*@non_null@*/String newName) {\r\n\r\n\t\tm_RelationName = newName;\r\n\t}\r\n\r\n\t/**\r\n\t * Sorts the instances based on an attribute. For numeric attributes, \r\n\t * instances are sorted in ascending order. For nominal attributes, \r\n\t * instances are sorted based on the attribute label ordering \r\n\t * specified in the header. Instances with missing values for the \r\n\t * attribute are placed at the end of the dataset.\r\n\t *\r\n\t * @param attIndex the attribute's index (index starts with 0)\r\n\t */\r\n\tpublic void sort(int attIndex) {\r\n\r\n\t\tint i,j;\r\n\r\n\t\t// move all instances with missing values to end\r\n\t\tj = numInstances() - 1;\r\n\t\ti = 0;\r\n\t\twhile (i \u003c= j) {\r\n\t\t\tif (instance(j).isMissing(attIndex)) {\r\n\t\t\t\tj--;\r\n\t\t\t} else {\r\n\t\t\t\tif (instance(i).isMissing(attIndex)) {\r\n\t\t\t\t\tswap(i,j);\r\n\t\t\t\t\tj--;\r\n\t\t\t\t}\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tquickSort(attIndex, 0, j);\r\n\t}\r\n\r\n\t/**\r\n\t * Sorts the instances based on an attribute. For numeric attributes, \r\n\t * instances are sorted into ascending order. For nominal attributes, \r\n\t * instances are sorted based on the attribute label ordering \r\n\t * specified in the header. Instances with missing values for the \r\n\t * attribute are placed at the end of the dataset.\r\n\t *\r\n\t * @param att the attribute\r\n\t */\r\n\tpublic void sort(Attribute att) {\r\n\r\n\t\tsort(indexOf(att));\r\n\t}\r\n\r\n\t/**\r\n\t * Stratifies a set of instances according to its class values \r\n\t * if the class attribute is nominal (so that afterwards a \r\n\t * stratified cross-validation can be performed).\r\n\t *\r\n\t * @param numFolds the number of folds in the cross-validation\r\n\t * @throws UnassignedClassException if the class is not set\r\n\t */\r\n\tpublic void stratify(int numFolds) {\r\n\r\n\t\tif (numFolds \u003c= 0) {\r\n\t\t\tthrow new IllegalArgumentException(\"Number of folds must be greater than 1\");\r\n\t\t}\r\n\t\tif (m_ClassIndex \u003c 0) {\r\n\t\t\tthrow new UnassignedClassException(\"Class index is negative (not set)!\");\r\n\t\t}\r\n\t\tif (classAttribute().getType()==Attribute.NOMINAL) {\r\n\r\n\t\t\t// sort by class\r\n\t\t\tint index = 1;\r\n\t\t\twhile (index \u003c numInstances()) {\r\n\t\t\t\tInstance instance1 = instance(index - 1);\r\n\t\t\t\tfor (int j = index; j \u003c numInstances(); j++) {\r\n\t\t\t\t\tInstance instance2 = instance(j);\r\n\t\t\t\t\tif ((instance1.classValue() == instance2.classValue()) ||\r\n\t\t\t\t\t\t\t(instance1.classIsMissing() \u0026\u0026 \r\n\t\t\t\t\t\t\t\t\tinstance2.classIsMissing())) {\r\n\t\t\t\t\t\tswap(index,j);\r\n\t\t\t\t\t\tindex++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tindex++;\r\n\t\t\t}\r\n\t\t\tstratStep(numFolds);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Computes the sum of all the instances' weights.\r\n\t *\r\n\t * @return the sum of all the instances' weights as a double\r\n\t */\r\n\tpublic /*@pure@*/ double sumOfWeights() {\r\n\r\n\t\tdouble sum = 0;\r\n\r\n\t\tfor (int i = 0; i \u003c numInstances(); i++) {\r\n\t\t\tsum += instance(i).weight();\r\n\t\t}\r\n\t\treturn sum;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates the test set for one fold of a cross-validation on \r\n\t * the dataset.\r\n\t *\r\n\t * @param numFolds the number of folds in the cross-validation. Must\r\n\t * be greater than 1.\r\n\t * @param numFold 0 for the first fold, 1 for the second, ...\r\n\t * @return the test set as a set of weighted instances\r\n\t * @throws IllegalArgumentException if the number of folds is less than 2\r\n\t * or greater than the number of instances.\r\n\t */\r\n\t//@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\r\n\t//@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\r\n\tpublic Instances testCV(int numFolds, int numFold) {\r\n\r\n\t\tint numInstForFold, first, offset;\r\n\t\tInstances test;\r\n\r\n\t\tif (numFolds \u003c 2) {\r\n\t\t\tthrow new IllegalArgumentException(\"Number of folds must be at least 2!\");\r\n\t\t}\r\n\t\tif (numFolds \u003e numInstances()) {\r\n\t\t\tthrow new IllegalArgumentException(\"Can't have more folds than instances!\");\r\n\t\t}\r\n\t\tnumInstForFold = numInstances() / numFolds;\r\n\t\tif (numFold \u003c numInstances() % numFolds){\r\n\t\t\tnumInstForFold++;\r\n\t\t\toffset = numFold;\r\n\t\t}else\r\n\t\t\toffset = numInstances() % numFolds;\r\n\t\ttest = new Instances(this, numInstForFold);\r\n\t\tfirst = numFold * (numInstances() / numFolds) + offset;\r\n\t\tcopyInstances(first, test, numInstForFold);\r\n\t\treturn test;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the dataset as a string in ARFF format. Strings\r\n\t * are quoted if they contain whitespace characters, or if they\r\n\t * are a question mark.\r\n\t *\r\n\t * @return the dataset in ARFF format as a string\r\n\t */\r\n\tpublic String toString() {\r\n\r\n\t\tStringBuffer text = new StringBuffer();\r\n\r\n\t\ttext.append(ARFF_RELATION).append(\" \").\r\n\t\tappend(Utils.quote(m_RelationName)).append(\"\\n\\n\");\r\n\t\tfor (int i = 0; i \u003c numAttributes(); i++) {\r\n\t\t\ttext.append(attribute(i)).append(\"\\n\");\r\n\t\t}\r\n\t\ttext.append(\"\\n\").append(ARFF_DATA).append(\"\\n\");\r\n\r\n\t\ttext.append(stringWithoutHeader());\r\n\t\treturn text.toString();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the instances in the dataset as a string in ARFF format. Strings\r\n\t * are quoted if they contain whitespace characters, or if they\r\n\t * are a question mark.\r\n\t *\r\n\t * @return the dataset in ARFF format as a string\r\n\t */\r\n\tprotected String stringWithoutHeader() {\r\n\r\n\t\tStringBuffer text = new StringBuffer();\r\n\r\n\t\tfor (int i = 0; i \u003c numInstances(); i++) {\r\n\t\t\ttext.append(instance(i));\r\n\t\t\tif (i \u003c numInstances() - 1) {\r\n\t\t\t\ttext.append('\\n');\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn text.toString();\r\n\t}\r\n\r\n\t/**\r\n\t * Creates the training set for one fold of a cross-validation \r\n\t * on the dataset. \r\n\t *\r\n\t * @param numFolds the number of folds in the cross-validation. Must\r\n\t * be greater than 1.\r\n\t * @param numFold 0 for the first fold, 1 for the second, ...\r\n\t * @return the training set \r\n\t * @throws IllegalArgumentException if the number of folds is less than 2\r\n\t * or greater than the number of instances.\r\n\t */\r\n\t//@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\r\n\t//@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\r\n\tpublic Instances trainCV(int numFolds, int numFold) {\r\n\r\n\t\tint numInstForFold, first, offset;\r\n\t\tInstances train;\r\n\r\n\t\tif (numFolds \u003c 2) {\r\n\t\t\tthrow new IllegalArgumentException(\"Number of folds must be at least 2!\");\r\n\t\t}\r\n\t\tif (numFolds \u003e numInstances()) {\r\n\t\t\tthrow new IllegalArgumentException(\"Can't have more folds than instances!\");\r\n\t\t}\r\n\t\tnumInstForFold = numInstances() / numFolds;\r\n\t\tif (numFold \u003c numInstances() % numFolds) {\r\n\t\t\tnumInstForFold++;\r\n\t\t\toffset = numFold;\r\n\t\t}else\r\n\t\t\toffset = numInstances() % numFolds;\r\n\t\ttrain = new Instances(this, numInstances() - numInstForFold);\r\n\t\tfirst = numFold * (numInstances() / numFolds) + offset;\r\n\t\tcopyInstances(0, train, first);\r\n\t\tcopyInstances(first + numInstForFold, train,\r\n\t\t\t\tnumInstances() - first - numInstForFold);\r\n\r\n\t\treturn train;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates the training set for one fold of a cross-validation \r\n\t * on the dataset. The data is subsequently randomized based\r\n\t * on the given random number generator.\r\n\t *\r\n\t * @param numFolds the number of folds in the cross-validation. Must\r\n\t * be greater than 1.\r\n\t * @param numFold 0 for the first fold, 1 for the second, ...\r\n\t * @param random the random number generator\r\n\t * @return the training set \r\n\t * @throws IllegalArgumentException if the number of folds is less than 2\r\n\t * or greater than the number of instances.\r\n\t */\r\n\t//@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\r\n\t//@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\r\n\tpublic Instances trainCV(int numFolds, int numFold, Random random) {\r\n\r\n\t\tInstances train = trainCV(numFolds, numFold);\r\n\t\ttrain.randomize(random);\r\n\t\treturn train;\r\n\t}\r\n\r\n\t/**\r\n\t * Computes the variance for a numeric attribute.\r\n\t *\r\n\t * @param attIndex the numeric attribute (index starts with 0)\r\n\t * @return the variance if the attribute is numeric\r\n\t * @throws IllegalArgumentException if the attribute is not numeric\r\n\t */\r\n\tpublic /*@pure@*/ double variance(int attIndex) {\r\n\r\n\t\tdouble sum = 0, sumSquared = 0, sumOfWeights = 0;\r\n\r\n\t\tif (attribute(attIndex).getType()==Attribute.NOMINAL) {\r\n\t\t\tthrow new IllegalArgumentException(\"Can't compute variance because attribute is \" +\r\n\t\t\t\"not numeric!\");\r\n\t\t}\r\n\t\tfor (int i = 0; i \u003c numInstances(); i++) {\r\n\t\t\tif (!instance(i).isMissing(attIndex)) {\r\n\t\t\t\tsum += instance(i).weight() * \r\n\t\t\t\tinstance(i).value(attIndex);\r\n\t\t\t\tsumSquared += instance(i).weight() * \r\n\t\t\t\tinstance(i).value(attIndex) *\r\n\t\t\t\tinstance(i).value(attIndex);\r\n\t\t\t\tsumOfWeights += instance(i).weight();\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (sumOfWeights \u003c= 1) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tdouble result = (sumSquared - (sum * sum / sumOfWeights)) / \r\n\t\t(sumOfWeights - 1);\r\n\r\n\t\t// We don't like negative variance\r\n\t\tif (result \u003c 0) {\r\n\t\t\treturn 0;\r\n\t\t} else {\r\n\t\t\treturn result;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Computes the variance for a numeric attribute.\r\n\t *\r\n\t * @param att the numeric attribute\r\n\t * @return the variance if the attribute is numeric\r\n\t * @throws IllegalArgumentException if the attribute is not numeric\r\n\t */\r\n\tpublic /*@pure@*/ double variance(Attribute att) {\r\n\r\n\t\treturn variance(indexOf(att));\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates summary statistics on the values that appear in this\r\n\t * set of instances for a specified attribute.\r\n\t *\r\n\t * @param index the index of the attribute to summarize (index starts with 0)\r\n\t * @return an AttributeStats object with it's fields calculated.\r\n\t */\r\n\t//@ requires 0 \u003c= index \u0026\u0026 index \u003c numAttributes();\r\n//\tpublic AttributeStats attributeStats(int index) {\r\n//\r\n//\t\tAttributeStats result = new AttributeStats();\r\n//\t\tif (attribute(index).isNominal()) {\r\n//\t\t\tresult.nominalCounts = new int [attribute(index).numValues()];\r\n//\t\t}\r\n//\t\tif (attribute(index).isNumeric()) {\r\n//\t\t\tresult.numericStats = new weka.experiment.Stats();\r\n//\t\t}\r\n//\t\tresult.totalCount = numInstances();\r\n//\r\n//\t\tdouble [] attVals = attributeToDoubleArray(index);\r\n//\t\tint [] sorted = Utils.sort(attVals);\r\n//\t\tint currentCount = 0;\r\n//\t\tdouble prev = Instance.missingValue();\r\n//\t\tfor (int j = 0; j \u003c numInstances(); j++) {\r\n//\t\t\tInstance current = instance(sorted[j]);\r\n//\t\t\tif (current.isMissing(index)) {\r\n//\t\t\t\tresult.missingCount = numInstances() - j;\r\n//\t\t\t\tbreak;\r\n//\t\t\t}\r\n//\t\t\tif (current.value(index) == prev) {\r\n//\t\t\t\tcurrentCount++;\r\n//\t\t\t} else {\r\n//\t\t\t\tresult.addDistinct(prev, currentCount);\r\n//\t\t\t\tcurrentCount = 1;\r\n//\t\t\t\tprev = current.value(index);\r\n//\t\t\t}\r\n//\t\t}\r\n//\t\tresult.addDistinct(prev, currentCount);\r\n//\t\tresult.distinctCount--; // So we don't count \"missing\" as a value \r\n//\t\treturn result;\r\n//\t}\r\n\r\n\t/**\r\n\t * Gets the value of all instances in this dataset for a particular\r\n\t * attribute. Useful in conjunction with Utils.sort to allow iterating\r\n\t * through the dataset in sorted order for some attribute.\r\n\t *\r\n\t * @param index the index of the attribute.\r\n\t * @return an array containing the value of the desired attribute for\r\n\t * each instance in the dataset. \r\n\t */\r\n\t//@ requires 0 \u003c= index \u0026\u0026 index \u003c numAttributes();\r\n\tpublic /*@pure@*/ double [] attributeToDoubleArray(int index) {\r\n\r\n\t\tdouble [] result = new double[numInstances()];\r\n\t\tfor (int i = 0; i \u003c result.length; i++) {\r\n\t\t\tresult[i] = instance(i).value(index);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Generates a string summarizing the set of instances. Gives a breakdown\r\n\t * for each attribute indicating the number of missing/discrete/unique\r\n\t * values and other information.\r\n\t *\r\n\t * @return a string summarizing the dataset\r\n\t */\r\n//\tpublic String toSummaryString() {\r\n//\r\n//\t\tStringBuffer result = new StringBuffer();\r\n//\t\tresult.append(\"Relation Name:  \").append(relationName()).append('\\n');\r\n//\t\tresult.append(\"Num Instances:  \").append(numInstances()).append('\\n');\r\n//\t\tresult.append(\"Num Attributes: \").append(numAttributes()).append('\\n');\r\n//\t\tresult.append('\\n');\r\n//\r\n//\t\tresult.append(Utils.padLeft(\"\", 5)).append(Utils.padRight(\"Name\", 25));\r\n//\t\tresult.append(Utils.padLeft(\"Type\", 5)).append(Utils.padLeft(\"Nom\", 5));\r\n//\t\tresult.append(Utils.padLeft(\"Int\", 5)).append(Utils.padLeft(\"Real\", 5));\r\n//\t\tresult.append(Utils.padLeft(\"Missing\", 12));\r\n//\t\tresult.append(Utils.padLeft(\"Unique\", 12));\r\n//\t\tresult.append(Utils.padLeft(\"Dist\", 6)).append('\\n');\r\n//\t\tfor (int i = 0; i \u003c numAttributes(); i++) {\r\n//\t\t\tAttribute a = attribute(i);\r\n//\t\t\tAttributeStats as = attributeStats(i);\r\n//\t\t\tresult.append(Utils.padLeft(\"\" + (i + 1), 4)).append(' ');\r\n//\t\t\tresult.append(Utils.padRight(a.name(), 25)).append(' ');\r\n//\t\t\tlong percent;\r\n//\t\t\tswitch (a.type()) {\r\n//\t\t\tcase Attribute.NOMINAL:\r\n//\t\t\t\tresult.append(Utils.padLeft(\"Nom\", 4)).append(' ');\r\n//\t\t\t\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\r\n//\t\t\t\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\r\n//\t\t\t\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\r\n//\t\t\t\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\r\n//\t\t\t\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\r\n//\t\t\t\tbreak;\r\n//\t\t\tcase Attribute.NUMERIC:\r\n//\t\t\t\tresult.append(Utils.padLeft(\"Num\", 4)).append(' ');\r\n//\t\t\t\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\r\n//\t\t\t\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\r\n//\t\t\t\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\r\n//\t\t\t\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\r\n//\t\t\t\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\r\n//\t\t\t\tbreak;\r\n//\t\t\tcase Attribute.DATE:\r\n//\t\t\t\tresult.append(Utils.padLeft(\"Dat\", 4)).append(' ');\r\n//\t\t\t\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\r\n//\t\t\t\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\r\n//\t\t\t\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\r\n//\t\t\t\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\r\n//\t\t\t\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\r\n//\t\t\t\tbreak;\r\n//\t\t\tcase Attribute.STRING:\r\n//\t\t\t\tresult.append(Utils.padLeft(\"Str\", 4)).append(' ');\r\n//\t\t\t\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\r\n//\t\t\t\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\r\n//\t\t\t\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\r\n//\t\t\t\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\r\n//\t\t\t\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\r\n//\t\t\t\tbreak;\r\n//\t\t\tcase Attribute.RELATIONAL:\r\n//\t\t\t\tresult.append(Utils.padLeft(\"Rel\", 4)).append(' ');\r\n//\t\t\t\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\r\n//\t\t\t\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\r\n//\t\t\t\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\r\n//\t\t\t\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\r\n//\t\t\t\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\r\n//\t\t\t\tbreak;\r\n//\t\t\tdefault:\r\n//\t\t\t\tresult.append(Utils.padLeft(\"???\", 4)).append(' ');\r\n//\t\t\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\r\n//\t\t\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\r\n//\t\t\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\r\n//\t\t\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\r\n//\t\t\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\r\n//\t\t\tbreak;\r\n//\t\t\t}\r\n//\t\t\tresult.append(Utils.padLeft(\"\" + as.missingCount, 5)).append(\" /\");\r\n//\t\t\tpercent = Math.round(100.0 * as.missingCount / as.totalCount);\r\n//\t\t\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\r\n//\t\t\tresult.append(Utils.padLeft(\"\" + as.uniqueCount, 5)).append(\" /\");\r\n//\t\t\tpercent = Math.round(100.0 * as.uniqueCount / as.totalCount);\r\n//\t\t\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\r\n//\t\t\tresult.append(Utils.padLeft(\"\" + as.distinctCount, 5)).append(' ');\r\n//\t\t\tresult.append('\\n');\r\n//\t\t}\r\n//\t\treturn result.toString();\r\n//\t}\r\n\r\n\t/**\r\n\t * Copies instances from one set to the end of another \r\n\t * one.\r\n\t *\r\n\t * @param from the position of the first instance to be copied\r\n\t * @param dest the destination for the instances\r\n\t * @param num the number of instances to be copied\r\n\t */\r\n\t//@ requires 0 \u003c= from \u0026\u0026 from \u003c= numInstances() - num;\r\n\t//@ requires 0 \u003c= num;\r\n\tprotected void copyInstances(int from, /*@non_null@*/ Instances dest, int num) {\r\n\r\n\t\tfor (int i = 0; i \u003c num; i++) {\r\n\t\t\tdest.add(instance(from + i));\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces the attribute information by a clone of\r\n\t * itself.\r\n\t */\r\n\tprotected void freshAttributeInfo() {\r\n\r\n\t\tm_Attributes = (FastVector) m_Attributes.copyElements();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns string including all instances, their weights and\r\n\t * their indices in the original dataset.\r\n\t *\r\n\t * @return description of instance and its weight as a string\r\n\t */\r\n\tprotected /*@pure@*/ String instancesAndWeights(){\r\n\r\n\t\tStringBuffer text = new StringBuffer();\r\n\r\n\t\tfor (int i = 0; i \u003c numInstances(); i++) {\r\n\t\t\ttext.append(instance(i) + \" \" + instance(i).weight());\r\n\t\t\tif (i \u003c numInstances() - 1) {\r\n\t\t\t\ttext.append(\"\\n\");\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn text.toString();\r\n\t}\r\n\r\n\t/**\r\n\t * Partitions the instances around a pivot. Used by quicksort and\r\n\t * kthSmallestValue.\r\n\t *\r\n\t * @param attIndex the attribute's index (index starts with 0)\r\n\t * @param l the first index of the subset (index starts with 0)\r\n\t * @param r the last index of the subset (index starts with 0)\r\n\t *\r\n\t * @return the index of the middle element\r\n\t */\r\n\t//@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\r\n\t//@ requires 0 \u003c= left \u0026\u0026 left \u003c= right \u0026\u0026 right \u003c numInstances();\r\n\tprotected int partition(int attIndex, int l, int r) {\r\n\r\n\t\tdouble pivot = instance((l + r) / 2).value(attIndex);\r\n\r\n\t\twhile (l \u003c r) {\r\n\t\t\twhile ((instance(l).value(attIndex) \u003c pivot) \u0026\u0026 (l \u003c r)) {\r\n\t\t\t\tl++;\r\n\t\t\t}\r\n\t\t\twhile ((instance(r).value(attIndex) \u003e pivot) \u0026\u0026 (l \u003c r)) {\r\n\t\t\t\tr--;\r\n\t\t\t}\r\n\t\t\tif (l \u003c r) {\r\n\t\t\t\tswap(l, r);\r\n\t\t\t\tl++;\r\n\t\t\t\tr--;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ((l == r) \u0026\u0026 (instance(r).value(attIndex) \u003e pivot)) {\r\n\t\t\tr--;\r\n\t\t} \r\n\r\n\t\treturn r;\r\n\t}\r\n\r\n\t/**\r\n\t * Implements quicksort according to Manber's \"Introduction to\r\n\t * Algorithms\".\r\n\t *\r\n\t * @param attIndex the attribute's index (index starts with 0)\r\n\t * @param left the first index of the subset to be sorted (index starts with 0)\r\n\t * @param right the last index of the subset to be sorted (index starts with 0)\r\n\t */\r\n\t//@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\r\n\t//@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c numInstances();\r\n\tprotected void quickSort(int attIndex, int left, int right) {\r\n\r\n\t\tif (left \u003c right) {\r\n\t\t\tint middle = partition(attIndex, left, right);\r\n\t\t\tquickSort(attIndex, left, middle);\r\n\t\t\tquickSort(attIndex, middle + 1, right);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Implements computation of the kth-smallest element according\r\n\t * to Manber's \"Introduction to Algorithms\".\r\n\t *\r\n\t * @param attIndex the attribute's index (index starts with 0)\r\n\t * @param left the first index of the subset (index starts with 0)\r\n\t * @param right the last index of the subset (index starts with 0)\r\n\t * @param k the value of k\r\n\t *\r\n\t * @return the index of the kth-smallest element\r\n\t */\r\n\t//@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\r\n\t//@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c numInstances();\r\n\tprotected int select(int attIndex, int left, int right, int k) {\r\n\r\n\t\tif (left == right) {\r\n\t\t\treturn left;\r\n\t\t} else {\r\n\t\t\tint middle = partition(attIndex, left, right);\r\n\t\t\tif ((middle - left + 1) \u003e= k) {\r\n\t\t\t\treturn select(attIndex, left, middle, k);\r\n\t\t\t} else {\r\n\t\t\t\treturn select(attIndex, middle + 1, right, k - (middle - left + 1));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Help function needed for stratification of set.\r\n\t *\r\n\t * @param numFolds the number of folds for the stratification\r\n\t */\r\n\tprotected void stratStep (int numFolds){\r\n\r\n\t\tFastVector newVec = new FastVector(m_Instances.capacity());\r\n\t\tint start = 0, j;\r\n\r\n\t\t// create stratified batch\r\n\t\twhile (newVec.size() \u003c numInstances()) {\r\n\t\t\tj = start;\r\n\t\t\twhile (j \u003c numInstances()) {\r\n\t\t\t\tnewVec.addElement(instance(j));\r\n\t\t\t\tj = j + numFolds;\r\n\t\t\t}\r\n\t\t\tstart++;\r\n\t\t}\r\n\t\tm_Instances = newVec;\r\n\t}\r\n\r\n\t/**\r\n\t * Swaps two instances in the set.\r\n\t *\r\n\t * @param i the first instance's index (index starts with 0)\r\n\t * @param j the second instance's index (index starts with 0)\r\n\t */\r\n\t//@ requires 0 \u003c= i \u0026\u0026 i \u003c numInstances();\r\n\t//@ requires 0 \u003c= j \u0026\u0026 j \u003c numInstances();\r\n\tpublic void swap(int i, int j){\r\n\r\n\t\tm_Instances.swap(i, j);\r\n\t}\r\n\r\n\t/**\r\n\t * Merges two sets of Instances together. The resulting set will have\r\n\t * all the attributes of the first set plus all the attributes of the \r\n\t * second set. The number of instances in both sets must be the same.\r\n\t *\r\n\t * @param first the first set of Instances\r\n\t * @param second the second set of Instances\r\n\t * @return the merged set of Instances\r\n\t * @throws IllegalArgumentException if the datasets are not the same size\r\n\t */\r\n\tpublic static Instances mergeInstances(Instances first, Instances second) {\r\n\r\n\t\tif (first.numInstances() != second.numInstances()) {\r\n\t\t\tthrow new IllegalArgumentException(\"Instance sets must be of the same size\");\r\n\t\t}\r\n\r\n\t\t// Create the vector of merged attributes\r\n\t\tFastVector newAttributes = new FastVector();\r\n\t\tfor (int i = 0; i \u003c first.numAttributes(); i++) {\r\n\t\t\tnewAttributes.addElement(first.attribute(i));\r\n\t\t}\r\n\t\tfor (int i = 0; i \u003c second.numAttributes(); i++) {\r\n\t\t\tnewAttributes.addElement(second.attribute(i));\r\n\t\t}\r\n\r\n\t\t// Create the set of Instances\r\n\t\tInstances merged = new Instances(first.relationName() + '_'\r\n\t\t\t\t+ second.relationName(), \r\n\t\t\t\tnewAttributes, \r\n\t\t\t\tfirst.numInstances());\r\n\t\t// Merge each instance\r\n\t\tfor (int i = 0; i \u003c first.numInstances(); i++) {\r\n\t\t\tmerged.add(first.instance(i).mergeInstance(second.instance(i)));\r\n\t\t}\r\n\t\treturn merged;\r\n\t}\r\n\r\n\t/**\r\n\t * Method for testing this class.\r\n\t *\r\n\t * @param argv should contain one element: the name of an ARFF file\r\n\t */\r\n\t//@ requires argv != null;\r\n\t//@ requires argv.length == 1;\r\n\t//@ requires argv[0] != null;\r\n//\tpublic static void test(String [] argv) {\r\n//\r\n//\t\tInstances instances, secondInstances, train, test, empty;\r\n//\t\tRandom random = new Random(2);\r\n//\t\tReader reader;\r\n//\t\tint start, num;\r\n//\t\tFastVector testAtts, testVals;\r\n//\t\tint i,j;\r\n//\r\n//\t\ttry{\r\n//\t\t\tif (argv.length \u003e 1) {\r\n//\t\t\t\tthrow (new Exception(\"Usage: Instances [\u003cfilename\u003e]\"));\r\n//\t\t\t}\r\n//\r\n//\t\t\t// Creating set of instances from scratch\r\n//\t\t\ttestVals = new FastVector(2);\r\n//\t\t\ttestVals.addElement(\"first_value\");\r\n//\t\t\ttestVals.addElement(\"second_value\");\r\n//\t\t\ttestAtts = new FastVector(2);\r\n//\t\t\ttestAtts.addElement(new Attribute(\"nominal_attribute\", testVals));\r\n//\t\t\ttestAtts.addElement(new Attribute(\"numeric_attribute\"));\r\n//\t\t\tinstances = new Instances(\"test_set\", testAtts, 10);\r\n//\t\t\tinstances.add(new Instance(instances.numAttributes()));\r\n//\t\t\tinstances.add(new Instance(instances.numAttributes()));\r\n//\t\t\tinstances.add(new Instance(instances.numAttributes()));\r\n//\t\t\tinstances.setClassIndex(0);\r\n//\t\t\tSystem.out.println(\"\\nSet of instances created from scratch:\\n\");\r\n//\t\t\tSystem.out.println(instances);\r\n//\r\n//\t\t\tif (argv.length == 1) {\r\n//\t\t\t\tString filename = argv[0];\r\n//\t\t\t\treader = new FileReader(filename);\r\n//\r\n//\t\t\t\t// Read first five instances and print them\r\n//\t\t\t\tSystem.out.println(\"\\nFirst five instances from file:\\n\");\r\n//\t\t\t\tinstances = new Instances(reader, 1);\r\n//\t\t\t\tinstances.setClassIndex(instances.numAttributes() - 1);\r\n//\t\t\t\ti = 0;\r\n//\t\t\t\twhile ((i \u003c 5) \u0026\u0026 (instances.readInstance(reader))) {\r\n//\t\t\t\t\ti++;\r\n//\t\t\t\t}\r\n//\t\t\t\tSystem.out.println(instances);\r\n//\r\n//\t\t\t\t// Read all the instances in the file\r\n//\t\t\t\treader = new FileReader(filename);\r\n//\t\t\t\tinstances = new Instances(reader);\r\n//\r\n//\t\t\t\t// Make the last attribute be the class \r\n//\t\t\t\tinstances.setClassIndex(instances.numAttributes() - 1);\r\n//\r\n//\t\t\t\t// Print header and instances.\r\n//\t\t\t\tSystem.out.println(\"\\nDataset:\\n\");\r\n//\t\t\t\tSystem.out.println(instances);\r\n//\t\t\t\tSystem.out.println(\"\\nClass index: \"+instances.classIndex());\r\n//\t\t\t}\r\n//\r\n//\t\t\t// Test basic methods based on class index.\r\n//\t\t\tSystem.out.println(\"\\nClass name: \"+instances.classAttribute().name());\r\n//\t\t\tSystem.out.println(\"\\nClass index: \"+instances.classIndex());\r\n//\t\t\tSystem.out.println(\"\\nClass is nominal: \" +\r\n//\t\t\t\t\tinstances.classAttribute().isNominal());\r\n//\t\t\tSystem.out.println(\"\\nClass is numeric: \" +\r\n//\t\t\t\t\tinstances.classAttribute().isNumeric());\r\n//\t\t\tSystem.out.println(\"\\nClasses:\\n\");\r\n//\t\t\tfor (i = 0; i \u003c instances.numClasses(); i++) {\r\n//\t\t\t\tSystem.out.println(instances.classAttribute().value(i));\r\n//\t\t\t}\r\n//\t\t\tSystem.out.println(\"\\nClass values and labels of instances:\\n\");\r\n//\t\t\tfor (i = 0; i \u003c instances.numInstances(); i++) {\r\n//\t\t\t\tInstance inst = instances.instance(i);\r\n//\t\t\t\tSystem.out.print(inst.classValue() + \"\\t\");\r\n//\t\t\t\tSystem.out.print(inst.toString(inst.classIndex()));\r\n//\t\t\t\tif (instances.instance(i).classIsMissing()) {\r\n//\t\t\t\t\tSystem.out.println(\"\\tis missing\");\r\n//\t\t\t\t} else {\r\n//\t\t\t\t\tSystem.out.println();\r\n//\t\t\t\t}\r\n//\t\t\t}\r\n//\r\n//\t\t\t// Create random weights.\r\n//\t\t\tSystem.out.println(\"\\nCreating random weights for instances.\");\r\n//\t\t\tfor (i = 0; i \u003c instances.numInstances(); i++) {\r\n//\t\t\t\tinstances.instance(i).setWeight(random.nextDouble()); \r\n//\t\t\t}\r\n//\r\n//\t\t\t// Print all instances and their weights (and the sum of weights).\r\n//\t\t\tSystem.out.println(\"\\nInstances and their weights:\\n\");\r\n//\t\t\tSystem.out.println(instances.instancesAndWeights());\r\n//\t\t\tSystem.out.print(\"\\nSum of weights: \");\r\n//\t\t\tSystem.out.println(instances.sumOfWeights());\r\n//\r\n//\t\t\t// Insert an attribute\r\n//\t\t\tsecondInstances = new Instances(instances);\r\n//\t\t\tAttribute testAtt = new Attribute(\"Inserted\");\r\n//\t\t\tsecondInstances.insertAttributeAt(testAtt, 0);\r\n//\t\t\tSystem.out.println(\"\\nSet with inserted attribute:\\n\");\r\n//\t\t\tSystem.out.println(secondInstances);\r\n//\t\t\tSystem.out.println(\"\\nClass name: \"\r\n//\t\t\t\t\t+ secondInstances.classAttribute().name());\r\n//\r\n//\t\t\t// Delete the attribute\r\n//\t\t\tsecondInstances.deleteAttributeAt(0);\r\n//\t\t\tSystem.out.println(\"\\nSet with attribute deleted:\\n\");\r\n//\t\t\tSystem.out.println(secondInstances);\r\n//\t\t\tSystem.out.println(\"\\nClass name: \"\r\n//\t\t\t\t\t+ secondInstances.classAttribute().name());\r\n//\r\n//\t\t\t// Test if headers are equal\r\n//\t\t\tSystem.out.println(\"\\nHeaders equal: \"+\r\n//\t\t\t\t\tinstances.equalHeaders(secondInstances) + \"\\n\");\r\n//\r\n//\t\t\t// Print data in internal format.\r\n//\t\t\tSystem.out.println(\"\\nData (internal values):\\n\");\r\n//\t\t\tfor (i = 0; i \u003c instances.numInstances(); i++) {\r\n//\t\t\t\tfor (j = 0; j \u003c instances.numAttributes(); j++) {\r\n//\t\t\t\t\tif (instances.instance(i).isMissing(j)) {\r\n//\t\t\t\t\t\tSystem.out.print(\"? \");\r\n//\t\t\t\t\t} else {\r\n//\t\t\t\t\t\tSystem.out.print(instances.instance(i).value(j) + \" \");\r\n//\t\t\t\t\t}\r\n//\t\t\t\t}\r\n//\t\t\t\tSystem.out.println();\r\n//\t\t\t}\r\n//\r\n//\t\t\t// Just print header\r\n//\t\t\tSystem.out.println(\"\\nEmpty dataset:\\n\");\r\n//\t\t\tempty = new Instances(instances, 0);\r\n//\t\t\tSystem.out.println(empty);\r\n//\t\t\tSystem.out.println(\"\\nClass name: \"+empty.classAttribute().name());\r\n//\r\n//\t\t\t// Create copy and rename an attribute and a value (if possible)\r\n//\t\t\tif (empty.classAttribute().isNominal()) {\r\n//\t\t\t\tInstances copy = new Instances(empty, 0);\r\n//\t\t\t\tcopy.renameAttribute(copy.classAttribute(), \"new_name\");\r\n//\t\t\t\tcopy.renameAttributeValue(copy.classAttribute(), \r\n//\t\t\t\t\t\tcopy.classAttribute().value(0), \r\n//\t\t\t\t\"new_val_name\");\r\n//\t\t\t\tSystem.out.println(\"\\nDataset with names changed:\\n\" + copy);\r\n//\t\t\t\tSystem.out.println(\"\\nOriginal dataset:\\n\" + empty);\r\n//\t\t\t}\r\n//\r\n//\t\t\t// Create and prints subset of instances.\r\n//\t\t\tstart = instances.numInstances() / 4;\r\n//\t\t\tnum = instances.numInstances() / 2;\r\n//\t\t\tSystem.out.print(\"\\nSubset of dataset: \");\r\n//\t\t\tSystem.out.println(num + \" instances from \" + (start + 1) \r\n//\t\t\t\t\t+ \". instance\");\r\n//\t\t\tsecondInstances = new Instances(instances, start, num);\r\n//\t\t\tSystem.out.println(\"\\nClass name: \"\r\n//\t\t\t\t\t+ secondInstances.classAttribute().name());\r\n//\r\n//\t\t\t// Print all instances and their weights (and the sum of weights).\r\n//\t\t\tSystem.out.println(\"\\nInstances and their weights:\\n\");\r\n//\t\t\tSystem.out.println(secondInstances.instancesAndWeights());\r\n//\t\t\tSystem.out.print(\"\\nSum of weights: \");\r\n//\t\t\tSystem.out.println(secondInstances.sumOfWeights());\r\n//\r\n//\t\t\t// Create and print training and test sets for 3-fold\r\n//\t\t\t// cross-validation.\r\n//\t\t\tSystem.out.println(\"\\nTrain and test folds for 3-fold CV:\");\r\n//\t\t\tif (instances.classAttribute().isNominal()) {\r\n//\t\t\t\tinstances.stratify(3);\r\n//\t\t\t}\r\n//\t\t\tfor (j = 0; j \u003c 3; j++) {\r\n//\t\t\t\ttrain = instances.trainCV(3,j, new Random(1));\r\n//\t\t\t\ttest = instances.testCV(3,j);\r\n//\r\n//\t\t\t\t// Print all instances and their weights (and the sum of weights).\r\n//\t\t\t\tSystem.out.println(\"\\nTrain: \");\r\n//\t\t\t\tSystem.out.println(\"\\nInstances and their weights:\\n\");\r\n//\t\t\t\tSystem.out.println(train.instancesAndWeights());\r\n//\t\t\t\tSystem.out.print(\"\\nSum of weights: \");\r\n//\t\t\t\tSystem.out.println(train.sumOfWeights());\r\n//\t\t\t\tSystem.out.println(\"\\nClass name: \"+train.classAttribute().name());\r\n//\t\t\t\tSystem.out.println(\"\\nTest: \");\r\n//\t\t\t\tSystem.out.println(\"\\nInstances and their weights:\\n\");\r\n//\t\t\t\tSystem.out.println(test.instancesAndWeights());\r\n//\t\t\t\tSystem.out.print(\"\\nSum of weights: \");\r\n//\t\t\t\tSystem.out.println(test.sumOfWeights());\r\n//\t\t\t\tSystem.out.println(\"\\nClass name: \"+test.classAttribute().name());\r\n//\t\t\t}\r\n//\r\n//\t\t\t// Randomize instances and print them.\r\n//\t\t\tSystem.out.println(\"\\nRandomized dataset:\");\r\n//\t\t\tinstances.randomize(random);\r\n//\r\n//\t\t\t// Print all instances and their weights (and the sum of weights).\r\n//\t\t\tSystem.out.println(\"\\nInstances and their weights:\\n\");\r\n//\t\t\tSystem.out.println(instances.instancesAndWeights());\r\n//\t\t\tSystem.out.print(\"\\nSum of weights: \");\r\n//\t\t\tSystem.out.println(instances.sumOfWeights());\r\n//\r\n//\t\t\t// Sort instances according to first attribute and\r\n//\t\t\t// print them.\r\n//\t\t\tSystem.out.print(\"\\nInstances sorted according to first attribute:\\n \");\r\n//\t\t\tinstances.sort(0);\r\n//\r\n//\t\t\t// Print all instances and their weights (and the sum of weights).\r\n//\t\t\tSystem.out.println(\"\\nInstances and their weights:\\n\");\r\n//\t\t\tSystem.out.println(instances.instancesAndWeights());\r\n//\t\t\tSystem.out.print(\"\\nSum of weights: \");\r\n//\t\t\tSystem.out.println(instances.sumOfWeights());\r\n//\t\t} catch (Exception e) {\r\n//\t\t\te.printStackTrace(); \r\n//\t\t}\r\n//\t}\r\n\r\n\t/**\r\n\t * Main method for this class. The following calls are possible:\r\n\t * \u003cul\u003e\r\n\t *   \u003cli\u003e\r\n\t *     \u003ccode\u003eweka.core.Instances\u003c/code\u003e help\u003cbr/\u003e\r\n\t *     prints a short list of possible commands.\r\n\t *   \u003c/li\u003e\r\n\t *   \u003cli\u003e\r\n\t *     \u003ccode\u003eweka.core.Instances\u003c/code\u003e \u0026lt;filename\u0026gt;\u003cbr/\u003e\r\n\t *     prints a summary of a set of instances.\r\n\t *   \u003c/li\u003e\r\n\t *   \u003cli\u003e\r\n\t *     \u003ccode\u003eweka.core.Instances\u003c/code\u003e merge \u0026lt;filename1\u0026gt; \u0026lt;filename2\u0026gt;\u003cbr/\u003e\r\n\t *     merges the two datasets (must have same number of instances) and\r\n\t *     outputs the results on stdout.\r\n\t *   \u003c/li\u003e\r\n\t *   \u003cli\u003e\r\n\t *     \u003ccode\u003eweka.core.Instances\u003c/code\u003e append \u0026lt;filename1\u0026gt; \u0026lt;filename2\u0026gt;\u003cbr/\u003e\r\n\t *     appends the second dataset to the first one (must have same headers) and\r\n\t *     outputs the results on stdout.\r\n\t *   \u003c/li\u003e\r\n\t *   \u003cli\u003e\r\n\t *     \u003ccode\u003eweka.core.Instances\u003c/code\u003e randomize \u0026lt;seed\u0026gt; \u0026lt;filename\u0026gt;\u003cbr/\u003e\r\n\t *     randomizes the dataset with the given seed and outputs the result on stdout.\r\n\t *   \u003c/li\u003e\r\n\t * \u003c/ul\u003e\r\n\t *\r\n\t * @param args \tthe commandline parameters\r\n\t */\r\n//\tpublic static void main(String[] args) {\r\n//\r\n//\t\ttry {\r\n//\t\t\tInstances i;\r\n//\t\t\t// read from stdin and print statistics\r\n//\t\t\tif (args.length == 0) {\r\n//\t\t\t\tDataSource source = new DataSource(System.in);\r\n//\t\t\t\ti = source.getDataSet();\r\n//\t\t\t\tSystem.out.println(i.toSummaryString());\r\n//\t\t\t}\r\n//\t\t\t// read file and print statistics\r\n//\t\t\telse if ((args.length == 1) \u0026\u0026 (!args[0].equals(\"-h\")) \u0026\u0026 (!args[0].equals(\"help\"))) {\r\n//\t\t\t\tDataSource source = new DataSource(args[0]);\r\n//\t\t\t\ti = source.getDataSet();\r\n//\t\t\t\tSystem.out.println(i.toSummaryString());\r\n//\t\t\t}\r\n//\t\t\t// read two files, merge them and print result to stdout\r\n//\t\t\telse if ((args.length == 3) \u0026\u0026 (args[0].toLowerCase().equals(\"merge\"))) {\r\n//\t\t\t\tDataSource source1 = new DataSource(args[1]);\r\n//\t\t\t\tDataSource source2 = new DataSource(args[2]);\r\n//\t\t\t\ti = Instances.mergeInstances(source1.getDataSet(), source2.getDataSet());\r\n//\t\t\t\tSystem.out.println(i);\r\n//\t\t\t}\r\n//\t\t\t// read two files, append them and print result to stdout\r\n//\t\t\telse if ((args.length == 3) \u0026\u0026 (args[0].toLowerCase().equals(\"append\"))) {\r\n//\t\t\t\tDataSource source1 = new DataSource(args[1]);\r\n//\t\t\t\tDataSource source2 = new DataSource(args[2]);\r\n//\t\t\t\tif (!source1.getStructure().equalHeaders(source2.getStructure()))\r\n//\t\t\t\t\tthrow new Exception(\"The two datasets have different headers!\");\r\n//\t\t\t\tInstances structure = source1.getStructure();\r\n//\t\t\t\tSystem.out.println(source1.getStructure());\r\n//\t\t\t\twhile (source1.hasMoreElements(structure))\r\n//\t\t\t\t\tSystem.out.println(source1.nextElement(structure));\r\n//\t\t\t\tstructure = source2.getStructure();\r\n//\t\t\t\twhile (source2.hasMoreElements(structure))\r\n//\t\t\t\t\tSystem.out.println(source2.nextElement(structure));\r\n//\t\t\t}\r\n//\t\t\t// read file and seed value, randomize data and print result to stdout\r\n//\t\t\telse if ((args.length == 3) \u0026\u0026 (args[0].toLowerCase().equals(\"randomize\"))) {\r\n//\t\t\t\tDataSource source = new DataSource(args[2]);\r\n//\t\t\t\ti = source.getDataSet();\r\n//\t\t\t\ti.randomize(new Random(Integer.parseInt(args[1])));\r\n//\t\t\t\tSystem.out.println(i);\r\n//\t\t\t}\r\n//\t\t\t// wrong parameters\r\n//\t\t\telse {\r\n//\t\t\t\tSystem.err.println(\r\n//\t\t\t\t\t\t\"\\nUsage:\\n\"\r\n//\t\t\t\t\t\t+ \"\\tweka.core.Instances help\\n\"\r\n//\t\t\t\t\t\t+ \"\\tweka.core.Instances \u003cfilename\u003e\\n\"\r\n//\t\t\t\t\t\t+ \"\\tweka.core.Instances merge \u003cfilename1\u003e \u003cfilename2\u003e\\n\"\r\n//\t\t\t\t\t\t+ \"\\tweka.core.Instances append \u003cfilename1\u003e \u003cfilename2\u003e\\n\"\r\n//\t\t\t\t\t\t+ \"\\tweka.core.Instances randomize \u003cseed\u003e \u003cfilename\u003e\\n\"\r\n//\t\t\t\t);\r\n//\t\t\t\tSystem.exit(1);\r\n//\t\t\t}\r\n//\t\t}\r\n//\t\tcatch (Exception ex) {\r\n//\t\t\tex.printStackTrace();\r\n//\t\t\tSystem.err.println(ex.getMessage());\r\n//\t\t}\r\n//\t}\r\n\t\r\n            /**\r\n     * Returns the index of the attribute given.\r\n     * @param att attribute given.\r\n     * @return the index of the attribute given.\r\n     */\r\n\tprotected int indexOf(Attribute att){\r\n\t\tint index = -1;\r\n\t\tfor(int i=0;i\u003cAttributes.getNumAttributes() \u0026\u0026 index==-1;i++){\r\n\t\t\tif(Attributes.getAttribute(i)==att)\r\n\t\t\t\tindex = i;\r\n\t\t}\r\n\t\treturn index;\r\n\t}\r\n\t\r\n    /**\r\n     * Returns the index of the value given of the attribute given.\r\n     * @param att attribute given.\r\n     * @param value value given.\r\n     * @return the index of the value given of the attribute given.\r\n     */\r\n    protected int indexOfValue(Attribute att,String value){\r\n\t\tVector vals = att.getNominalValuesList();\r\n\t\tString s;\r\n\t\tint index = -1;\r\n\t\tfor(int i=0;i\u003cvals.size() \u0026\u0026 index == -1;i++){\r\n\t\t\ts = (String)vals.get(i);\r\n\t\t\tif(value.compareTo(s)==0)\r\n\t\t\t\tindex = i;\r\n\t\t}\r\n\t\t\r\n\t\treturn index;\r\n\t}\r\n}\r\n\r\n",
        "name": "Instances.java",
        "path": "src/keel/Algorithms/SVM/SMO/core/Instances.java",
        "url": "/github.com/SCI2SUGR/KEEL/-/blob/src/keel/Algorithms/SVM/SMO/core/Instances.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 171,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires capacity \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 172,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures classIndex() == -1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 237,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= first;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 238,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= toCopy;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 239,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires first + toCopy \u003c= source.numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 319,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 320,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires index \u003c m_Attributes.size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 321,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 410,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires classIndex() \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 453,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= index \u0026\u0026 index \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 468,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= position \u0026\u0026 position \u003c numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 469,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires position != classIndex();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 529,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 616,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires numInstances() \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 648,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= position;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 649,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires position \u003c= numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 677,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 678,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires index \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 742,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires numInstances() \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 805,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result == m_Attributes.size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 818,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires classIndex() \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 839,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= attIndex;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 840,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires attIndex \u003c numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 883,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result == m_Instances.size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 947,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result == m_RelationName;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1257,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1258,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1335,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1336,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1376,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1377,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1443,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= index \u0026\u0026 index \u003c numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1487,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= index \u0026\u0026 index \u003c numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1594,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= from \u0026\u0026 from \u003c= numInstances() - num;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1595,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= num;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1641,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1642,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= left \u0026\u0026 left \u003c= right \u0026\u0026 right \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1675,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1676,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1697,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1698,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1741,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= i \u0026\u0026 i \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1742,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= j \u0026\u0026 j \u003c numInstances();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1790,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires argv != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1791,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires argv.length == 1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1792,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires argv[0] != null;\r"
        }
      ],
      "repository": {
        "name": "github.com/SCI2SUGR/KEEL",
        "url": "/github.com/SCI2SUGR/KEEL"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 425,
  "ElapsedMilliseconds": 93,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
