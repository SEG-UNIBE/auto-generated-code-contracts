{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/lip6/ITSTools lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib;\r\n\r\nimport java.math.BigDecimal;\r\nimport java.math.BigInteger;\r\nimport java.util.List;\r\n\r\nimport org.smtlib.ICommand.IScript;\r\nimport org.smtlib.IPos.IPosable;\r\n\r\n/** This interface represents the functionality for any class implementing an SMT-LIB term or formula */\r\npublic interface IExpr extends IAccept, IPosable {\r\n\t\r\n\t/** Helpful method that indicates the class of expression, used in human-readable messages. */\r\n\t//@ pure\r\n\tString kind();\r\n\r\n\t/** The interface defining the factory type for producing objects of various subtypes of IExpr;\r\n\t * the IPos argument is an optional argument giving information about the textual position of an expression. */\r\n\tstatic public interface IFactory {\r\n\t\t/** Creates a INumeral object; the argument must be a string of digits. */\r\n\t\tINumeral numeral(String v);\r\n\t\t/** Creates a INumeral object; the argument must be non-negative */\r\n\t\t//@ requires v \u003e= 0;\r\n\t\tINumeral numeral(long v);\r\n\t\t/** Creates a IDecimal object; the argument must be a string of digits with just one decimal point */\r\n\t\tIDecimal decimal(String v);\r\n\t\t/** The argument is a pure character string, with no Java or SMTLIB escapes or enclosing quotes */\r\n\t\tIStringLiteral unquotedString(String v);\r\n\t\t/** The argument is SMTLIB escaped, with enclosing quotes */\r\n\t\tIStringLiteral quotedString(String v);\r\n\t\t/** Creates a IKeyword object from a canonical string representation */\r\n\t\tIKeyword keyword(String v);\r\n\t\t/** Creates a IBinaryLiteral from a string of 0 and 1 digits */\r\n\t\tIBinaryLiteral binary(String v);\r\n\t\t/** Creates a IHexLiteral object from a string of hex digits (either case) */\r\n\t\tIHexLiteral hex(String v);\r\n\t\t/** Creates a ISymbol object from a canonical String representation of the symbol */\r\n\t\tISymbol symbol(String v);\r\n\t\t/** Creates an attribute with just a keyword and no attribute value */\r\n\t\tIAttribute\u003c?\u003e attribute(IKeyword k);\r\n\t\t/** Creates an attribute with a keyword and a value */\r\n\t\t\u003cT extends IAttributeValue\u003e IAttribute\u003cT\u003e attribute(IKeyword k, T value);\r\n\t\t/** Creates an attributed expression (an expression with a positive number of attributes) */\r\n\t\t//@ requires attributes.size() \u003e 0;\r\n\t\tIAttributedExpr attributedExpr(IExpr e, List\u003cIAttribute\u003c?\u003e\u003e attributes);\r\n\t\t/** Creates an attributed expression with just one attribute. */\r\n\t\t\u003cT extends IAttributeValue\u003e IAttributedExpr attributedExpr(IExpr e, IKeyword key, /*@Nullable*/T value);\r\n\t\t/** Creates a function expression (perhaps with an empty argument list) */\r\n        IFcnExpr fcn(IQualifiedIdentifier id, List\u003cIExpr\u003e args);\r\n\t\t/** Creates a function expression (perhaps with an empty argument list) */\r\n        IFcnExpr fcn(IQualifiedIdentifier id, IExpr... args);\r\n        /** A special function expression, using \"special_relations_decl\" in Z3 */ \r\n\t\tIExpr fcn(IFcnExpr fcn, IExpr... args);\r\n        /** Creates a parameterized identifier from a symbol and a non-empty list of numerals */\r\n        //@ requires num.size() \u003e 0;\r\n\t\tIParameterizedIdentifier id(ISymbol symbol, List\u003cINumeral\u003e num);\r\n\t\t/** Creates a 'as' identifier from an identifier and a sort qualifier */\r\n\t\tIAsIdentifier id(IIdentifier identifier, ISort qualifier);\r\n\t\t/** Creates a Let expression */\r\n\t\t//@ requires bindings.size() \u003e 0;\r\n\t\tILet let(List\u003cIBinding\u003e bindings, IExpr e);\r\n\t\t/** Creates a binding for a Let expression */\r\n\t\tIBinding binding(ISymbol symbol, IExpr expr);\r\n\t\t/** Creates a parameter declaration */\r\n\t\tIDeclaration declaration(ISymbol symbol, ISort sort);\r\n\t\t/** Creates a Forall expression */\r\n\t\t//@ requires params.size() \u003e 0;\r\n\t\tIForall forall(List\u003cIDeclaration\u003e params, IExpr e);\r\n\t\t/** Creates a Exists expression */\r\n\t\t//@ requires params.size() \u003e 0;\r\n\t\tIExists exists(List\u003cIDeclaration\u003e params, IExpr e);\r\n\r\n\t\t/** Creates a command script from a file of commands or a list of commands */\r\n\t\tIScript script(/*@Nullable*/IStringLiteral filename, /*@Nullable*/List\u003cICommand\u003e commands);\r\n\r\n\t\t/** Creates an error expression */\r\n\t\tIError error(String text);\r\n\r\n\t}\r\n\t\r\n\t/** This interface represents all literal (explicit constant) expressions. */\r\n\tstatic public interface ILiteral extends IExpr, IAttributeValue {\r\n\t}\r\n\t\r\n\t/** This interface represents non-negative integers of arbitrary size. */\r\n\tstatic public interface INumeral extends ILiteral {\r\n\t\t//@ ensures compareTo(BigInteger.ZERO) \u003e= 0;\r\n\t\t/*@ pure */\r\n\t\tBigInteger value();\r\n\t\t\r\n\t\t//@ ensures value().compareTo(BigInteger.valueOf(Integer.INT_MAX)) \u003c= 0 ==\u003e value().intValue() == \\result;\r\n\t\t//@ ensures \\result \u003e= 0;\r\n\t\t/*@ pure */\r\n\t\tint intValue();\r\n\t\t\r\n\t}\r\n\t\r\n\t/** This interface represents non-negative decimal numbers of arbitrary size\r\n\t * (i.e. an arbitrary non-negative integer divided by an arbitrary non-negative power of ten).\r\n\t */\r\n\tstatic public interface IDecimal extends ILiteral {\r\n\t\t//@ pure\r\n\t\tBigDecimal value();\r\n\t}\r\n\t\r\n\t/** This interface represents SMT-LIB ids; equal ids have equal (using .equals) values\r\n\t * of value().\r\n\t */\r\n\tstatic public interface ISymbol extends IAttributeValue, IIdentifier {\r\n\t\t/** A String giving the canonical value of symbol. */\r\n\t\t//@ pure\r\n\t\tString value();\r\n\r\n\t\t/** A printable String giving the original text of this symbol. */\r\n\t\t//@ pure\r\n\t\t@Override\r\n\t\tString toString();\r\n\t}\r\n\t\r\n\t/** This interface represents SMT-LIB attribute and infoflag names. */\r\n\tstatic public interface IKeyword extends IAccept, IPosable{\r\n\t\t/** A canonical representation of keyword key */\r\n\t\t//@ pure\r\n\t\tString value();\r\n\t\t\r\n\t\t/** The original textual representation of the keyword */\r\n\t\t//@ pure\r\n\t\t@Override\r\n\t\tString toString();\r\n\t\t\r\n\t\t/** Helpful method that indicates the class of expression, used in human-readable messages. */\r\n\t\t//@ pure\r\n\t\tString kind();\r\n\t\t\r\n\t\t@Override\r\n\t\tboolean equals(Object o);\r\n\t}\r\n\t\r\n\t/** This interface represents SMT-LIB binary literals */\r\n\tstatic public interface IBinaryLiteral extends ILiteral {\r\n\t\t/** Returns a canonical value of the binary literal: 0 and 1 digits from MSB to LSB */\r\n\t\tString value();\r\n\t\t\r\n\t\t/** The binary value as an unsigned integer */\r\n\t\tBigInteger intValue();\r\n\t\t\r\n\t\t/** Number of binary bits */\r\n\t\tint length();\r\n\t}\r\n\t\r\n\t/** This interface represents SMT-LIB hex literals */\r\n\tstatic public interface IHexLiteral extends ILiteral {\r\n\t\t/** Returns a canonical value of the hex literal; lower-case hex digits from most-significant to least-significant */\r\n\t\tString value(); \r\n\t\t\r\n\t\t/** The hex value as an unsigned integer */\r\n\t\tBigInteger intValue();\r\n\t\t\r\n\t\t/** Number of hex digits */\r\n\t\tint length();\r\n\t}\r\n\t\r\n\t// FIXME - document toString for all interfaces\r\n\t// FIXME - review headSymbol, head\r\n\t// FIXME - review IParameter, ILetParameter\r\n\t\r\n\t/** This interface represents SMT-LIB string literals */\r\n\tstatic public interface IStringLiteral extends ILiteral {\r\n\t\t/** Returns the value without enclosing quotes and without any escape sequences; there may be explicit new line (and other white space characters) */\r\n\t\t//@ pure\r\n\t\tString value();\r\n\r\n\t\t/** Returns a value with enclosing quotes and appropriate SMT-LIB escape sequences so that the String value\r\n\t\t * can be represented with SMT-LIB printable characters; the result may have explicit newline characters. */\r\n\t\t//@ pure\r\n\t\t@Override\r\n\t\tString toString();\r\n\t}\r\n\t\r\n\t/** This interface represents SMT-LIB expressions that are a function identifier applied to one or more arguments. */\r\n\tstatic public interface IFcnExpr extends IExpr {\r\n\t\t/** The function identifier */\r\n\t\t//@ pure\r\n\t\tIQualifiedIdentifier head();\r\n\t\t\r\n\t\t/** The arguments of the function */\r\n\t\t//@ ensures \\result.size() \u003e 0;\r\n\t\t//@ pure\r\n\t\tList\u003cIExpr\u003e args();\r\n\t}\r\n\r\n\t/** This interface represents SMT-LIB identifiers for function ids (either ids or parameterized ids\r\n\t * or as-type identifiers) */\r\n\tstatic public interface IQualifiedIdentifier extends IExpr {\r\n\t\t/** The head symbol of the identifier */\r\n\t\tISymbol headSymbol();\r\n\t}\r\n\t\r\n\t/** This interface represents SMT-LIB identifiers (either ids or parameterized ids) */\r\n\tstatic public interface IIdentifier extends IQualifiedIdentifier {\r\n\t\t/** The head symbol of the identifier */\r\n\t\t@Override\r\n\t\tISymbol headSymbol();\r\n\r\n\t}\r\n\t\r\n\t/** This interface represents SMT-LIB identifiers that are sort qualifiers on function ids */\r\n\tstatic public interface IAsIdentifier extends IQualifiedIdentifier {\r\n\t\t/** The head of the identifier */\r\n\t\tIIdentifier head();\r\n\t\t\r\n\t\t/** The head symbol of the identifier */\r\n\t\t@Override\r\n\t\tISymbol headSymbol();\r\n\r\n\t\t/** The Sort qualifier */\r\n\t\tISort qualifier();\r\n\t}\r\n\t\r\n\t/** This interface represents SMT-LIB parameterized identifiers */\r\n\tstatic public interface IParameterizedIdentifier extends IIdentifier {\r\n\t\t\r\n\t\t// TODO - document\r\n\t\tIIdentifier head();\r\n\t\t\r\n\t\t/** The head symbol of the identifier */\r\n\t\t@Override\r\n\t\tISymbol headSymbol();\r\n\t\t\r\n\t\t/** The non-negative integer parameters of the identifier */\r\n\t\t//@ ensures \\result.size() \u003e 0;\r\n\t\tList\u003cINumeral\u003e numerals();\r\n\t}\r\n\t\r\n\t/** This interface represents an SMT-LIB expression with attributes. */\r\n\tstatic public interface IAttributedExpr extends IExpr {\r\n\t\t//@ pure\r\n\t\tIExpr expr();\r\n\t\t\r\n\t\t//@ ensures \\result.size() \u003e 0;\r\n\t\t//@ pure\r\n\t\tList\u003cIAttribute\u003c?\u003e\u003e attributes();\r\n\t}\r\n\t\r\n\t/** This interface represents the general class of attribute values; \r\n\t * that is, it is the super-interface of any class that may be an attribute value;\r\n\t * in the abstract syntax it has no particular structure, though it does include\r\n\t * true, false, string literals, numerals, and various pre-defined constants.\r\n\t */\r\n\tstatic public interface IAttributeValue extends IResponse, IPos.IPosable {\r\n\t}\r\n\t\r\n\t/** This interface represents an SMT-LIB attribute-value pair */\r\n\tstatic public interface IAttribute\u003cTT extends IAttributeValue\u003e extends IAccept, IPosable, IResponse {\r\n\t\t//@ pure\r\n\t\tIKeyword keyword();\r\n\t\t\r\n\t\t//@ pure\r\n\t\t/*@Nullable*/ TT attrValue();\r\n\t}\r\n\t\r\n\t/** This interface represents a declaration of a parameter and its sort */\r\n\tstatic public interface IDeclaration extends IAccept, IPosable {\r\n\t\tISymbol parameter();\r\n\t\tISort sort();\r\n\t}\r\n\t\r\n\t/** This interface represents a binding of a parameter and an expression */\r\n\tstatic public interface IBinding extends IAccept, IPosable {\r\n\t\tISymbol parameter();\r\n\t\tIExpr expr();\r\n\t}\r\n\t\r\n\t/** This interface represents an SMT-LIB let-expression */\r\n\tstatic public interface ILet extends IExpr {\r\n\t\t//@ ensures \\result.size() \u003e 0;\r\n\t\tList\u003cIBinding\u003e bindings();\r\n\t\tIExpr expr();\r\n\t}\r\n\r\n\t/** This interface represents an SMT-LIB quantified forall expression */\r\n\tstatic public interface IForall extends IExpr {\r\n\t\t//@ ensures \\result.size() \u003e 0;\r\n\t\tList\u003cIDeclaration\u003e parameters();\r\n\t\tIExpr expr();\r\n\t}\r\n\t\r\n\t/** This interface represents an SMT-LIB quantified exists expression */\r\n\tstatic public interface IExists extends IExpr {\r\n\t\t//@ ensures \\result.size() \u003e 0;\r\n\t\tList\u003cIDeclaration\u003e parameters();\r\n\t\tIExpr expr();\r\n\t}\r\n\t\r\n\t/** This interface represents an error, e.g. a parsing error that is part of a larger\r\n\t * expression.  Using an error expression as a sub-expression allows further error\r\n\t * checking to be performed.\r\n\t */\r\n\tstatic public interface IError extends IExpr {\r\n\t\t/** Returns an informational message about the error */\r\n\t\tString value();\r\n\t}\r\n\r\n}\r\n",
        "name": "IExpr.java",
        "path": "smt/lip6.smtlib.SMT/src/org/smtlib/IExpr.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.SMT/src/org/smtlib/IExpr.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 59,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires num.size() \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires v \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 48,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires attributes.size() \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 64,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires bindings.size() \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 71,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires params.size() \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 74,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires params.size() \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 91,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures compareTo(BigInteger.ZERO) \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 95,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures value().compareTo(BigInteger.valueOf(Integer.INT_MAX)) \u003c= 0 ==\u003e value().intValue() == \\result;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 96,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 191,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result.size() \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 235,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result.size() \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 244,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result.size() \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 280,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result.size() \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 287,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result.size() \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 294,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result.size() \u003e 0;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT plugin project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.plugin;\r\n\r\n// FIXME - still needs review\r\n// FIXME - need to be sure that the showMessage... methods are called in the UI context when they need to be\r\n\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.Reader;\r\nimport java.io.StringBufferInputStream;\r\nimport java.util.Date;\r\nimport java.util.Iterator;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\n\r\nimport org.eclipse.core.resources.IContainer;\r\nimport org.eclipse.core.resources.IFile;\r\nimport org.eclipse.core.resources.IResource;\r\nimport org.eclipse.core.resources.IStorage;\r\nimport org.eclipse.core.runtime.CoreException;\r\nimport org.eclipse.core.runtime.IAdaptable;\r\nimport org.eclipse.core.runtime.IPath;\r\nimport org.eclipse.core.runtime.IProgressMonitor;\r\nimport org.eclipse.core.runtime.IStatus;\r\nimport org.eclipse.core.runtime.Status;\r\nimport org.eclipse.core.runtime.jobs.Job;\r\nimport org.eclipse.jface.dialogs.Dialog;\r\nimport org.eclipse.jface.dialogs.MessageDialog;\r\nimport org.eclipse.jface.resource.ImageDescriptor;\r\nimport org.eclipse.jface.text.IDocument;\r\nimport org.eclipse.jface.text.ITextSelection;\r\nimport org.eclipse.jface.viewers.ISelection;\r\nimport org.eclipse.jface.viewers.IStructuredSelection;\r\nimport org.eclipse.swt.SWT;\r\nimport org.eclipse.swt.widgets.Display;\r\nimport org.eclipse.swt.widgets.Shell;\r\nimport org.eclipse.ui.IEditorInput;\r\nimport org.eclipse.ui.IEditorPart;\r\nimport org.eclipse.ui.IPersistableElement;\r\nimport org.eclipse.ui.IStorageEditorInput;\r\nimport org.eclipse.ui.IWorkbenchPage;\r\nimport org.eclipse.ui.IWorkbenchWindow;\r\nimport org.eclipse.ui.IWorkingSet;\r\nimport org.eclipse.ui.PlatformUI;\r\nimport org.eclipse.ui.texteditor.IDocumentProvider;\r\nimport org.eclipse.ui.texteditor.ITextEditor;\r\nimport org.smtlib.IResponse;\r\nimport org.smtlib.SMT;\r\n\r\n/** This class holds utility values and methods to support the Eclipse plugin.\r\n * \r\n * @author David Cok\r\n *\r\n */\r\npublic class Utils {\r\n\t\r\n\tfinal static String windowHeader = \"SMT Plugin\";\r\n\r\n    /** This class is used to wrap arbitrary exceptions coming from the plug-in */\r\n    public static class PluginException extends RuntimeException {\r\n        /** Default serial version Symbol */\r\n        private static final long serialVersionUID = 1L;\r\n\r\n        /** Used to signal some unexpected error situation during plug-in processing. */\r\n        public PluginException(String error) {\r\n            super(error);\r\n        }\r\n        /** Used to signal some unexpected error situation during plug-in processing. */\r\n        public PluginException(String error, /*@NonNull*/ java.lang.Exception e) {\r\n            super(error,e);\r\n        }\r\n    }\r\n\r\n    /** The Symbol of the marker, which must match that in the plugin file. */\r\n    final public static  String SMT_MARKER_ID = Activator.PLUGIN_ID + \".SMTProblem\";\r\n\r\n    \r\n    /** Run a specific solver on the given text, belonging to the given file (unsaved edits), in a computational job. \r\n     * If solver is null, then use the default from the options.  Call the method from the UI thread.\r\n     */\r\n    public void runSolver(String solver, IFile file, String text) {\r\n    \tif (solver == null) solver = Preferences.poptions.defaultSolver.getStringValue();\r\n    \tString exec = \"\";\r\n    \t// FIXME - there is a lot of code in common with the previous method\r\n    \tif (!solver.equals(org.smtlib.Utils.TEST_SOLVER)) try {// FIXME - make \"test\" a symbolic constant\r\n    \t\texec = Preferences.getExec(solver);\r\n    \t\tif (exec == null) {\r\n    \t\t\tActivator.log.errorlog(\"SMT: INTERNAL ERROR: Could not find an executable option for \" + solver,null);\r\n    \t\t\treturn;\r\n    \t\t}\r\n    \t\tFile execFile = new File(exec);\r\n    \t\tif (!execFile.exists()) {\r\n    \t\t\tActivator.utils.showMessageInUI(null,windowHeader,\"The executable path for this solver does not appear to exist: \" + solver + \" \\\"\" + exec + \"\\\"\");\r\n    \t\t\treturn;\r\n    \t\t}\r\n    \t\tif (!execFile.canExecute()) {\r\n    \t\t\tActivator.utils.showMessageInUI(null,windowHeader,\"The executable path for this solver does not appear to be executable: \" + solver + \" \" + exec);\r\n    \t\t\treturn;\r\n    \t\t}\r\n    \t} catch (java.lang.Exception e) {\r\n\t\t\tActivator.log.errorlog(\"SMT: Could not find the executable for the solver \" + solver,e);\r\n\t\t\treturn;\r\n    \t}\r\n    \tif (Activator.verbose) Activator.log.logln(\"ISolver = \" + solver);\r\n    \ttry {\r\n\t\t\tSMT smt = new SMT();\r\n\t\t\tsmt.smtConfig = Activator.smtConfiguration.clone();\r\n\t\t\tsmt.smtConfig.files = null;\r\n\t\t\tString[] cmd = text == null ? new String[]{ \"-s\", solver, \"--exec\", exec, file.getLocation().toString() }\r\n\t\t\t\t\t\t\t\t\t\t: new String[]{ \"-s\", solver, \"--exec\", exec, \"--text\", text, file.getLocation().toString() };\r\n\t\t\tdeleteMarkers(file,null);\r\n\t\t\tboolean batch = false;\r\n\t\t\tif (batch) { // FIXME - get rid of launchJob now?\r\n\t\t\t\tlaunchJob(file.getLocation().toString(),smt,cmd,null);\r\n\t\t\t} else {\r\n\t\t\t\tinteractiveJob(file.getLocation().toString(),smt,cmd,null);\r\n\t\t\t}\r\n    \t} catch (java.lang.Exception e) {\r\n    \t\tActivator.log.errorlog(\"SMT - Internal exception\",e);\r\n    \t}\r\n    }\r\n    \r\n    SMT saved_smt = null;\r\n    \r\n    /** Executes the given command (cmd) by the smt instance as a computational (non-UI) Job\r\n     *\r\n     * @param name name of the Job\r\n     * @param smt the SMT instance in which to execute the commands\r\n     * @param cmd the command to execute\r\n     * @param shell the shell in which to display any UI messages\r\n     */\r\n    public void launchJob(String name, final SMT smt, final String[] cmd, /*@Nullable*/ final Shell shell) {\r\n    \tJob j = new Job(\"SMT Solver: \" + name) {\r\n    \t\t@Override\r\n    \t\tpublic IStatus run(IProgressMonitor monitor) {\r\n    \t\t\tboolean c = false;\r\n    \t\t\ttry {\r\n    \t\t\t\tsmt.smtConfig.log.numErrors = 0;\r\n    \t\t\t\tint exitCode = smt.exec(cmd);\r\n    \t\t\t\tString timestring = \"[\" + new Date().toString() + \"] \";\r\n    \t\t\t\tActivator.log.logln(timestring + \"Completed \" + cmd[1]\r\n    \t\t\t\t\t\t+ (exitCode == 0 ? \"\" : \" (exitcode=\" + exitCode +\")\")\r\n    \t\t\t\t\t\t+ (smt.smtConfig.log.numErrors == 0? \"\" : (\" : \" + smt.smtConfig.log.numErrors + \" errors\")) \r\n    \t\t\t\t\t\t+ (smt.checkSatStatus == null ? \"(no result)\" : (\" \" + smt.smtConfig.defaultPrinter.toString(smt.checkSatStatus)))\r\n    \t\t\t\t\t\t);\r\n    \t\t\t} catch (PluginException e) {\r\n    \t\t\t\tshowMessageInUI(shell,\"SMT PluginException\",e.getClass() + \" - \" + e.getMessage());\r\n    \t\t\t\tc = true;\r\n    \t\t\t}\r\n    \t\t\treturn c ? Status.CANCEL_STATUS : Status.OK_STATUS;\r\n    \t\t}\r\n    \t};\r\n    \tj.setUser(true); // true = initiated by an end-user\r\n    \tj.schedule();\r\n    }\r\n\r\n    /** Executes the given command within the given SMT object,\r\n     *  reporting results on the console and to the given shell;\r\n     *  'name' is an informational name giving the file being working on;\r\n     *  this method must be called in a computational thread.\r\n     */\r\n    public void interactiveJob(String name, SMT smt, String[] cmd, /*@Nullable*/ final Shell shell) {\r\n    \t\t\ttry {\r\n    \t\t\t\tsmt.smtConfig.log.numErrors = 0;\r\n    \t\t\t\tint exitCode = smt.exec(cmd);\r\n    \t\t\t\tString timestring = \"[\" + new Date().toString() + \"] \";\r\n    \t\t\t\tActivator.log.logln(timestring + \"Completed \" + cmd[1] + \" on \" + name + \" :\"\r\n    \t\t\t\t\t\t+ (exitCode == 0 ? \"\" : \" (exitcode=\" + exitCode +\")\")\r\n    \t\t\t\t\t\t+ (smt.smtConfig.log.numErrors == 0? \"\" : (\" : \" + smt.smtConfig.log.numErrors + \" errors\")) \r\n    \t\t\t\t\t\t+ (smt.checkSatStatus == null ? \"(no result)\" : (\" \" + smt.smtConfig.defaultPrinter.toString(smt.checkSatStatus)))\r\n    \t\t\t\t\t\t);\r\n    \t\t\t} catch (PluginException e) {\r\n    \t\t\t\tshowMessageInUI(shell,\"SMT PluginException\",e.getClass() + \" - \" + e.getMessage());\r\n    \t\t\t}\r\n\t\t\t\tsaved_smt = smt;\r\n    }\r\n\r\n    /** This runs a type-check only on the given text, in the UI thread. */\r\n    public void runCheck(IFile file, String text) {\r\n    \tif (text.length() \u003e 1000000) return; // FIXME - disable for large text\r\n    \ttry {\r\n\t\t\tSMT smt = new SMT();\r\n\t\t\t// FIXME - would rather not clone the configuration and allocate\r\n\t\t\t// a new log and ProblemListener on each edit, but we might want\r\n\t\t\t// to have any configuration parameters in force as they change\r\n\t\t\tsmt.smtConfig = Activator.smtConfiguration.clone();\r\n\t\t\tsmt.smtConfig.log = new org.smtlib.Log(smt.smtConfig);\r\n\t\t\tsmt.smtConfig.log.clearListeners(); // This removes the standard listener that would otherwise send log information to the console\r\n\t\t    smt.smtConfig.log.addListener(new ProblemListener());\r\n\r\n\t\t\tsmt.smtConfig.files = null;\r\n    \t\tString[] cmd = new String[]{ \"-s\", org.smtlib.Utils.TEST_SOLVER, \"--text\", text, file.getFullPath().toString() };\r\n    \t\tdeleteMarkers(file,null);\r\n    \t\tsmt.exec(cmd);\r\n    \t\t//launchJob(\"interactive\",smt,cmd,null);\r\n    \t} catch (java.lang.Exception e) {\r\n    \t\tActivator.log.errorlog(\"SMT - Internal exception\",e);\r\n    \t}\r\n    }\r\n\r\n\r\n    /** Returns the ITextSelection corresponding to a selection, if there is one (null otherwise). */\r\n    /*@Nullable*/\r\n    static public ITextSelection getSelectedText(ISelection selection) {\r\n        if (!selection.isEmpty() \u0026\u0026 selection instanceof ITextSelection) {\r\n            return (ITextSelection)selection;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    \r\n\r\n    /**\r\n     * This method interprets the selection returning a List of IResources, and\r\n     * ignoring things it does not know how to handle.  The selection is ignored\r\n     * if it is not an IStructuredSelection (e.g. ITextSelections are ignored).\r\n     * If the selection is empty and 'window'\r\n     * is non-null, then the routine attempts to find a resource that corresponds\r\n     * to the currently active editor.  The method expects to be called in the UI thread,\r\n     * \u003cUL\u003e\r\n     * \u003cLI\u003eIResource - added directly to list, whether a file or a container\r\n     * \u003cLI\u003eworking set - adds the elements of the working set if they can be\r\n     *          converted (through IAdaptor) to an IResource\r\n     * \u003cLI\u003eIJavaElement - adds the IResource that contains the element\r\n     * \u003cLI\u003eotherwise - ignored\r\n     * \u003c/UL\u003e\r\n     * \r\n     * @param selection  The selection to inspect\r\n     * @param window  The window in which a selected editor exists\r\n     * @param shell the shell to use in displaying information dialogs\r\n     * @return A List of IResources found in the selection\r\n     */\r\n    public List\u003cIResource\u003e getSelectedResources(ISelection selection, \r\n            /*@Nullable*/ IWorkbenchWindow window, /*@Nullable*/ Shell shell) {\r\n        List\u003cIResource\u003e list = new LinkedList\u003cIResource\u003e();\r\n        if (!selection.isEmpty() \u0026\u0026 selection instanceof IStructuredSelection) {\r\n            IStructuredSelection structuredSelection = (IStructuredSelection) selection;\r\n            for (Iterator\u003c?\u003e iter = structuredSelection.iterator(); iter.hasNext(); ) {\r\n                Object element = iter.next();\r\n                if (element instanceof IResource) {\r\n                    list.add((IResource)element);\r\n                } else if (element instanceof IWorkingSet) {\r\n                    for (IAdaptable a: ((IWorkingSet)element).getElements()) {\r\n                        IResource r = (IResource) a.getAdapter(IResource.class);\r\n                        if (r != null) list.add(r);\r\n                    }\r\n                    continue;\r\n                } else if (element instanceof IAdaptable) {\r\n                    IResource r = (IResource) ((IAdaptable)element).getAdapter(IResource.class);\r\n                    if (r != null) list.add(r);\r\n                }\t\r\n            }\r\n        } else {\r\n            // We had nothing selected\r\n            // Look for the active editor instead\r\n            try {\r\n                IEditorPart p = window.getActivePage().getActiveEditor();\r\n                IEditorInput e = p==null? null : p.getEditorInput();\r\n                IResource o = e==null ? null : (IFile)e.getAdapter(IFile.class);\r\n                if (o != null) {\r\n                    list.add(o);  // This is an IFile\r\n                } \r\n            } catch (PluginException ee) {\r\n            \t// These methods expect to be called in the UI thread.\r\n                Activator.log.errorlog(\"PluginException when finding selected targets: \" + ee,ee);\r\n                showMessage(shell,\"JML Plugin PluginException\",\"PluginException occurred when finding selected targets: \" + ee);\r\n            }\r\n        }\r\n        return list;\r\n    }\r\n\r\n    /** Creates a list of all the selected files, or files that are in selected containers. */\r\n    public List\u003cIFile\u003e getSelectedFiles(ISelection selection, \r\n            /*@Nullable*/ IWorkbenchWindow window, /*@Nullable*/ Shell shell) throws CoreException {\r\n        List\u003cIFile\u003e list = new LinkedList\u003cIFile\u003e();\r\n        if (!selection.isEmpty() \u0026\u0026 selection instanceof IStructuredSelection) {\r\n            IStructuredSelection structuredSelection = (IStructuredSelection) selection;\r\n            for (Iterator\u003c?\u003e iter = structuredSelection.iterator(); iter.hasNext(); ) {\r\n                Object element = iter.next();\r\n                if (element instanceof IResource) {\r\n                \taddFiles((IResource)element,list);\r\n                } else if (element instanceof IWorkingSet) {\r\n                    for (IAdaptable a: ((IWorkingSet)element).getElements()) {\r\n                        IResource r = (IResource) a.getAdapter(IResource.class);\r\n                        if (r != null) addFiles(r,list);\r\n                    }\r\n                } else if (element instanceof IAdaptable) {\r\n                    IResource r = (IResource) ((IAdaptable)element).getAdapter(IResource.class);\r\n                    if (r != null) addFiles(r,list);\r\n                }\r\n            }\r\n        }\r\n        return list;\r\n    }\r\n    \r\n    // TODO - duplicated with Preferences.solverNames, and should be made configurable\r\n\tfinal String[] solverList = new String[]{ \"simplify\", \"yices\", \"cvc\", \"z3_2_11\", \"z3_4_3\"};\r\n    \r\n\t/** Interprets the input string (the action id, as in action.getId()) to\r\n\t * determine which solvers to run, returning their names in a list.\r\n\t */\r\n    public List\u003cString\u003e getSolvers(String id) {\r\n    \tList\u003cString\u003e solvers = new LinkedList\u003cString\u003e();\r\n\t\tint i = id.lastIndexOf('.');\r\n\t\tString name = id.substring(i+1);\r\n    \tif (\"All\".equals(name)) {\r\n    \t\tfor (String s: solverList) solvers.add(s);\r\n    \t} else if (\"default\".equals(name)) {\r\n        \tname = Preferences.poptions.defaultSolver.getStringValue();\r\n        \tsolvers.add(name);\r\n    \t} else {\r\n    \t\tsolvers.add(name);\r\n    \t}\r\n    \treturn solvers;\r\n    }\r\n    \r\n    public void runJobs(final List\u003cString\u003e solvers, final List\u003cIFile\u003e files) {\r\n\t\tJob j = new Job(\"SMT Solving\") {\r\n\t\t\t@Override\r\n\t\t\tpublic IStatus run(IProgressMonitor monitor) {\r\n\t\t\t\tIStatus status = Status.OK_STATUS;\r\n\t\t\t\tif (monitor != null) {\r\n\t\t\t\t\tmonitor.beginTask(\"SMT solving\", solvers.size() * (files.isEmpty() ? 1 : files.size()));\r\n\t\t\t\t}\r\n        \t\tfor (IFile file: files) {\r\n        \t\t\tfor (String solver: solvers) {\r\n        \t\t\t\ttry {\r\n        \t\t\t\t\tif (monitor != null) monitor.subTask(solver + \" on \" + file.getName().substring(file.getName().lastIndexOf('/')+1));\r\n        \t\t\t\t\trunSolver(solver,file,text);\r\n        \t\t\t\t} catch (Exception e) {\r\n        \t\t\t\t\tActivator.log.errorlog(\"Exception while executing \" + solver + \" on \" + file.getName() + \": \" + e,e);\r\n        \t\t\t\t}\r\n        \t\t\t\tif (monitor != null) {\r\n        \t\t\t\t\tmonitor.worked(1);\r\n        \t\t\t\t\tif (monitor.isCanceled()) {\r\n        \t\t\t\t\t\tstatus = Status.CANCEL_STATUS;\r\n        \t\t\t\t\t\tbreak;\r\n        \t\t\t\t\t}\r\n        \t\t\t\t}\r\n        \t\t\t}\r\n        \t\t}\r\n\t\t\t\tif (monitor != null) {\r\n\t\t\t\t\tmonitor.done();\r\n\t\t\t\t}\r\n\t\t\t\treturn status;\r\n\t\t\t}\r\n\t\t};\r\n\t\tj.setUser(true); // true = initiated by an end-user\r\n\t\tj.schedule();\r\n    }\r\n    \r\n    /** Finds the selected editor; if it is a TextEditor, then if the editor is\r\n     * dirty, runs the solver on the text; if the editor is not dirty, runs the\r\n     * solver on the file. Returns true if successfully found file or text on which\r\n     * to run; returns false otherwise.\r\n     * \r\n     * This must be called in the UI thread; executes the check in a computational Job.\r\n     * */\r\n    public boolean runSolverOnSelectedEditor(String solver, List\u003cIFile\u003e files) throws CoreException {\r\n\t\tfor (IFile r: files) runSolver(solver,r,text);\r\n        return true;\r\n    }\r\n    \r\n    String text;\r\n    \r\n    // FIXME - document\r\n    public List\u003cIFile\u003e resources(ISelection selection, \r\n            /*@Nullable*/ IWorkbenchWindow window, /*@Nullable*/ Shell shell) throws CoreException {\r\n    \tIFile file = null;\r\n\t\tList\u003cIFile\u003e list = new LinkedList\u003cIFile\u003e();\r\n\t\ttext = null;\r\n    \ttry {\r\n    \t\tIWorkbenchPage page = window == null ? null : window.getActivePage();\r\n    \t\tIEditorPart p = page == null ? null : window.getActivePage().getActiveEditor();\r\n    \t\tIEditorInput e = p==null? null : p.getEditorInput();\r\n    \t\tfile = e==null ? null : (IFile)e.getAdapter(IFile.class);\r\n    \t\tif (file == null) return null;\r\n\t\t\tif (p instanceof ITextEditor) {\r\n\t\t\t\tlist.add(file);\r\n\t\t\t\tif (p.isDirty()) {\r\n\t\t\t\t\tIDocumentProvider doc = ((ITextEditor)p).getDocumentProvider();\r\n\t\t\t\t\tif (doc == null) return null;\r\n\t\t\t\t\tIDocument d = doc.getDocument(e);\r\n\t\t\t\t\tif (d == null) return null;\r\n\t\t\t\t\ttext = d.get();\r\n\t\t\t\t}\r\n\t\t\t}\r\n    \t} catch (PluginException ee) {\r\n    \t\t// These calls expect to be in the UI thread\r\n    \t\tActivator.log.errorlog(\"PluginException when finding selected targets: \" + ee,ee);\r\n    \t\tshowMessage(shell,\"JML Plugin PluginException\",\"PluginException occurred when finding selected targets: \" + ee);\r\n    \t}\r\n    \treturn list;\r\n    }\r\n    \r\n    /** This adds files in the given resource to the list; if the resource is a container, it \r\n     * adds the files that are in the container.\r\n     */\r\n    private void addFiles(IResource resource, List\u003cIFile\u003e list) throws CoreException {\r\n    \tif (resource instanceof IFile) {\r\n    \t\tif (resource.getName().toString().endsWith(org.smtlib.Utils.SUFFIX)) {\r\n        \t\t//Activator.log.log(\"ADDING \" + resource.getLocation().toString());\r\n    \t\t\tlist.add((IFile)resource);\r\n    \t\t}\r\n    \t\treturn;\r\n    \t} else if (resource instanceof IContainer) {\r\n    \t\tfor (IResource r: ((IContainer)resource).members()) {\r\n    \t\t\taddFiles(r,list);\r\n    \t\t}\r\n    \t}\r\n    }\r\n\r\n\r\n    // FIXME - should resource things be happening in another thread?\r\n    /** Deletes all JML markers from the items selected, right within the UI thread,\r\n     * without a progress dialog.  The resources for which markers are deleted are\r\n     * those returned by Utils.getSelectedResources.   This should be called from\r\n     * the UI thread.\r\n     * @param selection the IStructuredSelection whose markers are to be deleted\r\n     * @param window the current workbench window, or null (used in getSelectedResources)\r\n     * @param shell the current Shell, or null for the default shell (for message dialogs)\r\n     */\r\n    public void deleteMarkersInSelection(ISelection selection, IWorkbenchWindow window, Shell shell) {\r\n        List\u003cIResource\u003e list = getSelectedResources(selection,window,shell);\r\n        //list.add(ResourcesPlugin.getWorkspace().getRoot()); // FIXME - temporarily here to clear out unrooted markers\r\n        if (list.isEmpty()) {\r\n            showMessage(shell,windowHeader,\"Nothing appropriate to delete markers of\");\r\n            return;\r\n        }\r\n        deleteMarkers(list,shell);\r\n    }\r\n\r\n\r\n    /** This class is an implementation of the interfaces needed to provide input\r\n     * to and launch editors in the workspace.\r\n     * @author David R. Cok\r\n     */\r\n    public static class StringStorage implements IStorage, IStorageEditorInput {\r\n        /** The initial content of the editor */\r\n        private String content;\r\n        /** The name of storage unit (e.g. the file name) */\r\n        private String name;\r\n        \r\n        /** A constructor for a new storage unit */\r\n        //@ assignable this.*;\r\n        public StringStorage(String content, String name) { \r\n            this.content = content; \r\n            this.name = name; \r\n        }\r\n        \r\n        /** Interface method that returns the contents of the storage unit */\r\n        //JAVA16 @Override\r\n        public InputStream getContents() throws CoreException {\r\n            return new StringBufferInputStream(content);\r\n        }\r\n\r\n        /** Returns the path to the underlying resource\r\n         * @return null (not needed for readonly Strings)\r\n         */\r\n        //JAVA16 @Override\r\n        public IPath getFullPath() {\r\n            return null;\r\n        }\r\n\r\n        /** Returns the name of the storage object \r\n         * @return the name of the storage unit\r\n         */\r\n        //JAVA16 @Override\r\n        public String getName() { return name; }\r\n\r\n        /** Returns whether the storage object is read only\r\n         * @return always true\r\n         */\r\n        //JAVA16 @Override\r\n        public boolean isReadOnly() { return true; }\r\n\r\n        /** Returns the object adapted to the given class.  It appears we can\r\n         * ignore this and always return null.\r\n         * @return null\r\n         */\r\n        //JAVA16 @Override\r\n        public /*@Nullable*/ Object getAdapter(Class arg0) { return null; }\r\n\r\n        /** Returns self\r\n         * @return this object\r\n         */\r\n        //@ ensures \\return == this;\r\n        //JAVA16 @Override\r\n        public IStorage getStorage() throws CoreException {\r\n            return (IStorage)this;\r\n        }\r\n        \r\n        /** Returns whether the underlying storage object exists\r\n         * @return always true\r\n         */\r\n        //JAVA16 @Override\r\n        public boolean exists() {\r\n            return true;\r\n        }\r\n        \r\n        /** Returns an ImageDescriptor, here ignored\r\n         * @return always null\r\n         */\r\n        //JAVA16 @Override\r\n        public /*@Nullable*/ ImageDescriptor getImageDescriptor() {\r\n            return null;\r\n        }\r\n        \r\n        /** Returns a corresponding Persistable object, here ignored\r\n         * @return always null\r\n         */\r\n        //JAVA16 @Override\r\n        public /*@Nullable*/ IPersistableElement getPersistable() {\r\n            return null;\r\n        }\r\n        \r\n        /** Return the text desired in a tool tip, here the name of the\r\n         * storage unit\r\n         */\r\n        //@NonNull\r\n        //JAVA16 @Override\r\n        public String getToolTipText() {\r\n            return name;\r\n        }\r\n\r\n    }\r\n\r\n    /** Launches a read-only text editor with the given content and name\r\n     * @param content the content of the editor\r\n     * @param name the name (as in the title) of the editor\r\n     */\r\n    public void launchEditor(String content,String name) {\r\n        try {\r\n            IEditorInput editorInput = new StringStorage(content,name);\r\n            IWorkbenchWindow window = PlatformUI.getWorkbench().getActiveWorkbenchWindow();\r\n            if (window == null) {\r\n                showMessageInUI(null,\"SMT PluginException\",\"No window found for editor named \" + name);\r\n            \treturn;\r\n            }\r\n            IWorkbenchPage page = window.getActivePage();\r\n            if (page == null) {\r\n                showMessageInUI(null,\"SMT PluginException\",\"No active page found for editor named \" + name);\r\n            \treturn;\r\n            }\r\n\r\n            //            IEditorPart[] parts = page.getEditors();\r\n            //            for (IEditorPart e: parts) Log.log(\"EDITOR \" + e.getEditorSite().getId());\r\n            page.openEditor(editorInput, \"org.eclipse.ui.DefaultTextEditor\");\r\n        } catch (java.lang.Exception e) {\r\n            showMessageInUI(null,\"SMT PluginException\",e.getMessage());\r\n\t\t}\r\n    }\r\n\r\n    /** Deletes the SMT_MARKER_ID markers in any of the objects in the List that are \r\n     * IResource objects; if the object is a container, markers are deleted for\r\n     * any resources in the container; other kinds of objects are ignored.\r\n     * Expects to be called from the UI thread.\r\n     * @param \u003cT\u003e just the type of the list\r\n     * @param list a list of objects whose markers are to be deleted\r\n     * @param shell the current shell for dialogs (or null for default)\r\n     */\r\n    public \u003cT extends IResource\u003e void deleteMarkers(List\u003cT\u003e list, /*@Nullable*/ Shell shell) {\r\n    \tStringBuilder sb = new StringBuilder();\r\n        for (T t: list) {\r\n            IResource resource = (IResource)t;\r\n            String s = deleteMarkers(resource,shell);\r\n            if (s != null) { sb.append(s); sb.append(\"\\n\"); }\r\n        }\r\n        String ss = sb.toString();\r\n        if (!ss.isEmpty()) Activator.utils.showMessage(shell,windowHeader,ss);\r\n    }\r\n    \r\n    /** Deletes any SMT_MARKER_ID markers on the given resource, returns an error message, if any (else null);\r\n     * expects to be called from the UI thread. */\r\n    public /*@Nullable*/ String deleteMarkers(IResource resource, /*@Nullable*/ Shell shell) {\r\n\t\ttry {\r\n\t\t\ttry {\r\n\t\t\t\tif (Activator.verbose) Activator.log.logln(\"Deleting markers in \" + resource.getName());\r\n\t\t\t\tresource.deleteMarkers(SMT_MARKER_ID, false,\r\n\t\t\t\t\t\tIResource.DEPTH_INFINITE);\r\n\t\t\t} catch (CoreException e) {\r\n\t\t\t\tString msg = \"Failed to delete markers on \"\r\n\t\t\t\t\t\t+ resource.getProject();\r\n\t\t\t\tActivator.log.errorlog(msg, e);\r\n\t\t\t}\r\n\t\t} catch (PluginException e) {\r\n\t\t\tActivator.log.errorlog(\"PluginException while deleting markers: \" + e, e);\r\n\t\t\treturn \"PluginException while deleting markers \"\r\n\t\t\t\t\t\t\t+ (resource != null ? \"on \" + resource.getName()\r\n\t\t\t\t\t\t\t\t\t: \"\");\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n \r\n    /**\r\n     * Displays a message in a dialog in the UI thread - this may\r\n     * be called from other threads.\r\n     * @param sh  The shell to use to display the dialog, or \r\n     *      a top-level shell if the parameter is null\r\n     * @param title  The title of the dialog window\r\n     * @param msg  The message to display in the dialog\r\n     */\r\n    public void showMessageInUI(/*@Nullable*/ Shell sh, \r\n            final String title, final String msg) {\r\n        final Shell shell = sh;\r\n        Display d = shell == null ? Display.getDefault() : shell.getDisplay();\r\n        d.asyncExec(new Runnable() {\r\n            public void run() {\r\n                MessageDialog.openInformation(\r\n                        shell,\r\n                        title,\r\n                        msg);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Displays a message in a non-modal dialog in the UI thread - this may\r\n     * be called from other threads.\r\n     * @param sh  The shell to use to display the dialog, or \r\n     *      a top-level shell if the parameter is null\r\n     * @param title  The title of the dialog window\r\n     * @param msg  The message to display in the dialog\r\n     */\r\n    public void showMessageInUINM(/*@Nullable*/ Shell sh, \r\n            final String title, final String msg) {\r\n        final Shell shell = sh;\r\n        Display d = shell == null ? Display.getDefault() : shell.getDisplay();\r\n        d.asyncExec(new Runnable() {\r\n            public void run() {\r\n                Dialog d = new NonModalDialog(\r\n                        shell,\r\n                        title,\r\n                        msg);\r\n                d.open();\r\n            }\r\n        });\r\n    }\r\n\r\n    // FIXME this does not seem to be working\r\n    static public class NonModalDialog extends MessageDialog {\r\n        final static String[] buttons = { \"OK\" };\r\n        public NonModalDialog(Shell shell, String title, String message) {\r\n            super(new Shell(),title,null,message,INFORMATION,buttons,0);\r\n            setShellStyle(getShellStyle()|SWT.MODELESS);\r\n            setBlockOnOpen(false);\r\n        }\r\n    }\r\n    \r\n\r\n    /**\r\n     * Displays a message in a information dialog; must be called from the UI thread.\r\n     * @param shell  Either the parent shell\r\n     * @param title  A title for the dialog window\r\n     * @param msg   The message to display in the dialog window\r\n     */\r\n    //@ requires msg != null;\r\n    public void showMessage(/*@Nullable*/Shell shell, /*@Nullable*/String title, String msg) {\r\n        MessageDialog.openInformation(\r\n                shell,\r\n                title,\r\n                msg);\r\n    }\r\n    \r\n    /** Shows an error dialog box for an exception; must be called from the UI thread */\r\n    public void topLevelException(/*@Nullable*/Shell shell, String title, java.lang.Exception e) {\r\n        //e.printStackTrace(sw); // TODO\r\n        showMessage(shell,\"SMT Top-level PluginException: \" + title,\r\n                e.toString());\r\n    }\r\n    \r\n    /** Shows the logic or theory file of the selected text; error dialogs if can't find an appropriate file to show. */\r\n    public void viewLogic(Shell shell, ISelection selection) {\r\n    \tString name = \"\";\r\n    \tString path = \"\";\r\n\t\tReader r = null;\r\n\t\tInputStream stream = null;\r\n    \ttry {\r\n    \t\tITextSelection tsel = Utils.getSelectedText(selection);\r\n    \t\tif (tsel == null) {\r\n    \t\t\tActivator.utils.showMessage(shell,windowHeader,\"Select the name of a logic or theory to show\");\r\n    \t\t\treturn;\r\n    \t\t}\r\n    \t\tname = tsel.getText();\r\n    \t\tif (name == null || name.length() == 0) {\r\n    \t\t\tActivator.utils.showMessage(shell,windowHeader,\"Select the name of a logic or theory to show\");\r\n    \t\t\treturn;\r\n    \t\t}\r\n    \t\tString dir = Preferences.poptions.logics.getValue();\r\n    \t\tif (dir != null) dir = dir.trim();\r\n    \t\t\r\n\t\t\tif (dir == null || dir.isEmpty()) {\r\n\t    \t\ttry {\r\n\t    \t\t\tstream = SMT.logicFinder.find(null,name,null);\r\n\t    \t\t\tif (stream == null) {\r\n\t    \t\t\t\treturn;\r\n\t    \t\t\t}\r\n\t\t    \t\tr = new InputStreamReader(stream);\r\n\t    \t\t} catch (IOException e) {\r\n\t\t\t\t\tshowMessage(shell,\"SMT View Logic\",\"Could not read the definition file for \" + name\r\n\t\t\t\t\t\t\t+ \"\\n\" + e.getMessage());\r\n\t\t\t\t\treturn;\r\n\t    \t\t} catch (org.smtlib.Utils.SMTLIBException e) {\r\n\t\t\t\t\tshowMessage(shell,\"SMT View Logic\",\"Could not read the definition file for \" + name\r\n\t\t\t\t\t\t\t+ \"\\n\" + e.errorResponse);\r\n\t\t\t\t\treturn;\r\n\t    \t\t}\r\n\t\t\t} else {\r\n\t\t\t\tString fname = dir + File.separator + name + org.smtlib.Utils.SUFFIX;\r\n\t\t\t\tif (Activator.verbose) Activator.log.logln(\"Trying to read logic file \" + fname);\r\n\t\t\t\tFile f = new File(fname);\r\n\t\t\t\tif (f.isFile()) r = new FileReader(f);\r\n\t\t\t}\r\n\t\t\tif (r == null) {\r\n\t\t\t\tshowMessage(shell,\"SMT View Logic\",\"Could not find a definition file for \" + name\r\n\t\t\t\t\t\t+ \"\\nTry setting the directory for logic definitions in the SMT preferences\");\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n    \t\tchar[] buf = new char[10000];\r\n    \t\tint p = 0;\r\n    \t\tint n = 0;\r\n    \t\ttry {\r\n    \t\t\twhile (p \u003c buf.length) {\r\n    \t\t\t\tn = r.read(buf,p,buf.length-p);\r\n    \t\t\t\tif (n == -1) break; \r\n    \t\t\t\tp += n;\r\n    \t\t\t}\r\n    \t\t\tActivator.utils.launchEditor(new String(buf,0,p),name);\r\n    \t\t} catch (IOException e) {\r\n    \t\t\tActivator.utils.showMessage(shell,windowHeader,\"Failed to read logic file for \" + name);\r\n    \t\t\tActivator.log.errorlog(\"Failed to read logic file for \" + name,e);\r\n    \t\t}\r\n    \t} catch (FileNotFoundException e) {\r\n    \t\tActivator.utils.showMessage(shell,windowHeader,\"Could not find logic or theory named \" + name + \"\\n(\" + path + \")\");\r\n\r\n    \t} catch (PluginException e) {\r\n    \t\tActivator.utils.topLevelException(shell,windowHeader,e);\r\n    \t} finally {\r\n    \t\ttry {\r\n    \t\t\tif (r != null) r.close();\r\n    \t\t\tif (stream != null) stream.close();\r\n    \t\t} catch (IOException e) {\r\n    \t\t\tActivator.log.errorlog(\"Failed to close reader for the logic file\",e);\r\n    \t\t}\r\n    \t}\r\n    }\r\n    \r\n    /** Performs a get-value command on the selected text. */\r\n    public void getValue(Shell shell, ISelection selection) {\r\n    \tString text = \"\";\r\n    \ttry {\r\n    \t\tITextSelection tsel = Utils.getSelectedText(selection);\r\n    \t\tif (tsel == null) {\r\n    \t\t\tActivator.utils.showMessage(shell,windowHeader,\"Select an expression whose value is wanted\");\r\n    \t\t\treturn;\r\n    \t\t}\r\n    \t\ttext = tsel.getText();\r\n    \t\tif (text == null || text.length() == 0) {\r\n    \t\t\tActivator.utils.showMessage(shell,windowHeader,\"Select an expression whose value is wanted\");\r\n    \t\t\treturn;\r\n    \t\t}\r\n    \t\tif (saved_smt == null) {\r\n    \t\t\tActivator.utils.showMessage(shell,windowHeader,\"There is no current model\");\r\n    \t\t\treturn;\r\n    \t\t}\r\n    \t\t\r\n    \t\tint e = saved_smt.execCommand(\"(get-value (\" + text + \"))\");\r\n    \t\tif (e != 0) {\r\n    \t\t\tActivator.utils.showMessage(shell,windowHeader,\"The selected text is not a valid expression:\\n\" + text);\r\n    \t\t} else {\r\n    \t\t\tIResponse response = saved_smt.lastResponse;\r\n    \t\t\tActivator.utils.showMessage(shell,windowHeader,\"Value: \" + saved_smt.smtConfig.defaultPrinter.toString(response));\r\n    \t\t}\r\n    \t} catch (PluginException e) {\r\n    \t\tActivator.utils.topLevelException(shell,windowHeader,e);\r\n    \t}\r\n    }\r\n\r\n}\r\n",
        "name": "Utils.java",
        "path": "smt/lip6.smtlib.plugin.SMTPlugin/src/org/smtlib/plugin/Utils.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.plugin.SMTPlugin/src/org/smtlib/plugin/Utils.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 494,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures \\return == this;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 664,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires msg != null;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT plugin project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.plugin;\r\n\r\nimport org.eclipse.jface.resource.JFaceResources;\r\nimport org.eclipse.swt.SWT;\r\nimport org.eclipse.swt.events.ModifyListener;\r\nimport org.eclipse.swt.events.MouseAdapter;\r\nimport org.eclipse.swt.events.MouseEvent;\r\nimport org.eclipse.swt.graphics.Font;\r\nimport org.eclipse.swt.layout.GridData;\r\nimport org.eclipse.swt.layout.GridLayout;\r\nimport org.eclipse.swt.widgets.Button;\r\nimport org.eclipse.swt.widgets.Composite;\r\nimport org.eclipse.swt.widgets.DirectoryDialog;\r\nimport org.eclipse.swt.widgets.FileDialog;\r\nimport org.eclipse.swt.widgets.Label;\r\nimport org.eclipse.swt.widgets.Shell;\r\nimport org.eclipse.swt.widgets.Text;\r\n\r\n/**\r\n * This class just holds a bunch of related classes which are\r\n * custom widgets for building dialogs.\r\n * \r\n * @author David Cok\r\n *\r\n */\r\npublic class Widgets {\r\n\r\n\r\n  /** \r\n   * A composite that lays its children out in a number of\r\n   * columns.\r\n   * \r\n   * @author David Cok\r\n   *\r\n   */\r\n  public static class HComposite extends Composite {\r\n    /**\r\n     * Constructs the composite as a member of the given\r\n     * parent and with the given number of columns.\r\n     * \r\n     * @param parent  The container into which to place this new widget\r\n     * @param cols    The number of columns of this widget\r\n     */\r\n    //@ requires cols \u003e 0;\r\n    public HComposite(/*@ non_null */ Composite parent,int cols) {\r\n      super(parent, SWT.NONE);\r\n      GridLayout layout = new GridLayout();\r\n      layout.numColumns = cols;\r\n      setLayout(layout);\r\n      GridData data = new GridData();\r\n      data.verticalAlignment = GridData.FILL;\r\n      data.horizontalAlignment = GridData.FILL;\r\n      setLayoutData(data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * A custom widget that lays out its children in one vertical\r\n   * column.\r\n   */\r\n  public static class VComposite extends Composite {\r\n    /**\r\n     * Constructs the composite as a member of the given\r\n     * parent.\r\n     * \r\n     * @param parent  The container into which to place this new widget\r\n     */\r\n    public VComposite(/*@ non_null */ Composite parent) {\r\n      super(parent, SWT.NONE);\r\n      GridLayout layout = new GridLayout();\r\n      layout.numColumns = 1;\r\n      setLayout(layout);\r\n      GridData data = new GridData();\r\n      data.verticalAlignment = GridData.FILL;\r\n      data.horizontalAlignment = GridData.FILL;\r\n      setLayoutData(data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * A custom widget that is a separator followed by a label,\r\n   * typically used as a title to a set of widgets below it.\r\n   * \r\n   * @author David Cok\r\n   */\r\n  public static class LabeledSeparator extends Composite {\r\n    /**\r\n     * @param parent  The container this widget is made part of\r\n     * @param label\t  The text to be used as the label in the widget\r\n     */\r\n    public LabeledSeparator(/*@ non_null */ Composite parent, \r\n            /*@ non_null */ String label) {\r\n      super(parent, SWT.NONE);\r\n      GridLayout layout = new GridLayout();\r\n      layout.numColumns = 2;\r\n      setLayout(layout);\r\n      GridData data = new GridData();\r\n      data.verticalAlignment = GridData.FILL;\r\n      data.horizontalAlignment = GridData.FILL;\r\n      setLayoutData(data);\r\n      new Label(this,SWT.SEPARATOR|SWT.HORIZONTAL);\r\n      new Label(this,SWT.NONE).setText(label);\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * A custom widget that is used to provide a way for the user\r\n   * to specify a file; it combines a label, a Browse button,\r\n   * and a text field.  The Browse button pops up a file browser;\r\n   * that lets the user browse for a file; the path of the selected\r\n   * file is then put into the text field.  Or the user can type into\r\n   * the text field directly.\r\n   * \r\n   * @author David Cok\r\n   */\r\n  public static class FileTextField extends VComposite {\r\n    /** The text field that shows the file path */\r\n    private Text text;\r\n    /** A String used for spaces */\r\n    final private static String tenspaces = \"          \";\r\n    // The length of this string defines the minimum size of the text field.\r\n    // FIXME - there must be a better way to set the size,\r\n    // and a better way to make a long string\r\n    /** A String used for spaces that helps set the size of the text widget */\r\n    final private static String spaces = tenspaces + tenspaces + tenspaces\r\n    + tenspaces + tenspaces + tenspaces + tenspaces + tenspaces + tenspaces;\r\n\r\n\r\n    /**\r\n     * Constructs the composite widget as a member of the given\r\n     * parent and with the given parameters.\r\n     * @param parent\tThe container this new widget is made part of\r\n     * @param label\t\tThe label to be used for this widget (e.g. the purpose of the directory being identified)\r\n     * @param initialValue  The initial value for the text field (a directory path)\r\n     * @param toolTipText   The explantory text used as a tooltip\r\n     * @param length    The size of the visible part of the field, in characters\r\n     *\t\t */\r\n    public FileTextField(/*@ non_null */ Composite parent,\r\n            /*@ non_null */ String label, \r\n            /*@ non_null */ String initialValue,\r\n            /*@ non_null */ String toolTipText,\r\n            int length) {\r\n      super(parent);\r\n      final Shell shell = parent.getShell();\r\n\r\n      // This is a composite widget with internals\r\n      // arranged as follows:\r\n      //   *********************************************\r\n      //   *   label     *  Browse button              *\r\n      //   *********************************************\r\n      //   *        Text field                         *\r\n      //   *********************************************\r\n\r\n      Composite hc = new HComposite(this,2);\r\n\r\n      new Label(hc,SWT.NONE).setText(label);\r\n\r\n      text = new Text(this,SWT.SINGLE);\r\n      String s = initialValue;\r\n      int n = spaces.length();\r\n      if (length \u003c n) n = length;\r\n      if (s.length() \u003c n) s += spaces.substring(0,n-s.length());\r\n      text.setText(s);\r\n      text.setToolTipText(toolTipText);\r\n      // Make the text fixed width and bold\r\n      Font f = JFaceResources.getFontRegistry().getBold(JFaceResources.TEXT_FONT);\r\n      text.setFont(f);\r\n      final Text t = text;\r\n\r\n      Button browse = new Button(hc, SWT.PUSH);\r\n      browse.setText(\"Browse\");\r\n      browse.setToolTipText(toolTipText);\r\n      browse.addMouseListener(new MouseAdapter() {\r\n    \t@Override\r\n        public void mouseUp(MouseEvent e) {\r\n          // TODO: Would be nice to start the directory browser\r\n          // in the location that is currently set in the text\r\n          // field, but there does not seem to be away to do that\r\n          FileDialog dd = new FileDialog(shell,SWT.OPEN);\r\n          String result = dd.open();\r\n          if (result != null) t.setText(result);\r\n        }\r\n      });\r\n    }\r\n\r\n    /** Returns the current value of the specified file path.\r\n     *\r\n     * @return the current value of the specified file path\r\n     */\r\n    //@ modifies \\nothing;\r\n    //@ ensures \\result != null;\r\n    public String value() {\r\n      return text.getText();\r\n    }\r\n\r\n    /**\r\n     * Sets the current value in the text field.\r\n     * \r\n     * @param v The text to display\r\n     */\r\n    public void setText(String v) {\r\n      text.setText(v);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * A custom widget that is used to provide a way for the user\r\n   * to specify a directory; it combines a label, a Browse button,\r\n   * and a text field.  The Browse button pops up a file system browser;\r\n   * that lets the user browse for a directory; the path of the selected\r\n   * directory is then put into the text field.  Or the user can type into\r\n   * the text field directly.\r\n   * \r\n   * @author David Cok\r\n   */\r\n  public static class DirTextField extends VComposite {\r\n    /** The text field that shows the directory path */\r\n    private Text text;\r\n    /** A String used for spaces */\r\n    final private static String tenspaces = \"          \";\r\n    // The length of this string defines the minimum size of the text field.\r\n    // FIXME - there must be a better way to set the size,\r\n    // and a better way to make a long string\r\n    /** A String used for spaces that helps set the size of the text widget */\r\n    final private static String spaces = tenspaces + tenspaces + tenspaces\r\n    + tenspaces + tenspaces + tenspaces + tenspaces + tenspaces + tenspaces;\r\n\r\n\r\n    /**\r\n     * Constructs the composite widget as a member of the given\r\n     * parent and with the given parameters.\r\n     * @param parent    The container this new widget is made part of\r\n     * @param label     The label to be used for this widget (e.g. the purpose of the directory being identified)\r\n     * @param initialValue  The initial value for the text field (a directory path)\r\n     * @param toolTipText   The explanatory text used as a tooltip\r\n     * @param length    The size of the visible part of the field, in characters\r\n     *       */\r\n    public DirTextField(/*@ non_null */ Composite parent,\r\n            /*@ non_null */ String label, \r\n            /*@ non_null */ String initialValue,\r\n            /*@ non_null */ String toolTipText,\r\n            int length) {\r\n      super(parent);\r\n      final Shell shell = parent.getShell();\r\n\r\n      // This is a composite widget with internals\r\n      // arranged as follows:\r\n      //   *********************************************\r\n      //   *   label     *  Browse button              *\r\n      //   *********************************************\r\n      //   *        Text field                         *\r\n      //   *********************************************\r\n\r\n      Composite hc = new HComposite(this,2);\r\n\r\n      new Label(hc,SWT.NONE).setText(label);\r\n\r\n      text = new Text(this,SWT.SINGLE);\r\n      String s = initialValue;\r\n      int n = spaces.length();\r\n      if (length \u003c n) n = length;\r\n      if (s.length() \u003c n) s += spaces.substring(0,n-s.length());\r\n      text.setText(s);\r\n      text.setToolTipText(toolTipText);\r\n      // Make the text fixed width and bold\r\n      Font f = JFaceResources.getFontRegistry().getBold(JFaceResources.TEXT_FONT);\r\n      text.setFont(f);\r\n      final Text t = text;\r\n\r\n      Button browse = new Button(hc, SWT.PUSH);\r\n      browse.setText(\"Browse\");\r\n      browse.setToolTipText(toolTipText);\r\n      browse.addMouseListener(new MouseAdapter() {\r\n    \t@Override\r\n        public void mouseUp(MouseEvent e) {\r\n          // TODO: Would be nice to start the directory browser\r\n          // in the location that is currently set in the text\r\n          // field, but there does not seem to be away to do that\r\n          DirectoryDialog dd = new DirectoryDialog(shell,SWT.OPEN);\r\n          String result = dd.open();\r\n          if (result != null) t.setText(result);\r\n        }\r\n      });\r\n    }\r\n    \r\n    public void addModifyListener(ModifyListener listener) {\r\n    \ttext.addModifyListener(listener);\r\n    }\r\n\r\n    /** Returns the current value of the specified directory path.\r\n     *\r\n     * @return the current value of the specified directory path\r\n     */\r\n    //@ modifies \\nothing;\r\n    //@ ensures \\result != null;\r\n    public String value() {\r\n      return text.getText();\r\n    }\r\n\r\n    /**\r\n     * Sets the current value in the text field.\r\n     * \r\n     * @param v The text to display\r\n     */\r\n    public void setText(String v) {\r\n      text.setText(v);\r\n    }\r\n  }\r\n  \r\n}\r\n",
        "name": "Widgets.java",
        "path": "smt/lip6.smtlib.plugin.SMTPlugin/src/org/smtlib/plugin/Widgets.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.plugin.SMTPlugin/src/org/smtlib/plugin/Widgets.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 48,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires cols \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 196,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 300,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result != null;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT plugin project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.plugin;\r\n\r\nimport java.util.List;\r\n\r\nimport org.eclipse.core.resources.IFile;\r\nimport org.eclipse.jface.action.IAction;\r\nimport org.eclipse.jface.viewers.ISelection;\r\nimport org.eclipse.swt.widgets.Shell;\r\nimport org.eclipse.ui.IWorkbenchWindow;\r\nimport org.eclipse.ui.IWorkbenchWindowActionDelegate;\r\n\r\n/**\r\n * This class holds the implementations of the utils in response to\r\n * menu items in the menubar and toolbar\r\n */\r\nabstract public class MenuActions implements IWorkbenchWindowActionDelegate {\r\n\r\n    // IWorkbenchWindowActionDelegate is the interface for actions that\r\n    // are contributed as menubar or toolbar items\r\n\r\n    /** Caches the value of the window, when informed of it. */\r\n    /*@Nullable*/ protected IWorkbenchWindow window;\r\n\r\n    /** Caches the value of the shell in which the window exists. */\r\n    /*@Nullable*/ protected Shell shell = null;\r\n\r\n    /** The current selection. */\r\n    /*@Nullable*/ protected ISelection selection;\r\n\r\n    /* (non-Javadoc)\r\n     * @see org.eclipse.ui.IActionDelegate#selectionChanged(org.eclipse.jface.action.IAction, org.eclipse.jface.viewers.ISelection)\r\n     */\r\n    //@ ensures this.selection != null;\r\n    //JAVA16 @Override\r\n    public final void selectionChanged(final IAction action, final ISelection selection) {\r\n        this.selection = selection;\r\n    }\r\n\r\n    /**\r\n     * We can use this method to dispose of any system\r\n     * resources we previously allocated.\r\n     * @see IWorkbenchWindowActionDelegate#dispose\r\n     */\r\n    //JAVA16 @Override\r\n    public void dispose() {\r\n    }\r\n\r\n    /**\r\n     * We will cache window object in order to\r\n     * be able to provide a parent shell for the message dialog.\r\n     * @param window The parent window\r\n     * @see IWorkbenchWindowActionDelegate#init\r\n     */\r\n    //JAVA16 @Override\r\n    public void init(IWorkbenchWindow window) {\r\n        this.window = window;\r\n        this.shell = window.getShell();\r\n    }\r\n\r\n    /** Called by the system in response to a menu selection (or other command).\r\n     * This should be overridden for individual menu items.\r\n     */\r\n    //JAVA16 @Override\r\n    abstract public void run(final IAction action);\r\n\r\n    /**\r\n     * This class implements the action for checking\r\n     * JML in the selected objects (which may be working sets, folders,\r\n     * or java files).  Applying the operation\r\n     * to a container applies it to all its contents recursively.\r\n     * The checks are done in a non-UI thread.\r\n     * \r\n     * @author David R. Cok\r\n     */\r\n    public static class RunSolver extends MenuActions {\r\n\r\n    \t@Override\r\n    \tpublic final void run(final IAction action) {\r\n    \t\ttry {\r\n    \t\t\tfinal List\u003cString\u003e solvers = Activator.utils.getSolvers(action.getId());\r\n    \t\t\tList\u003cIFile\u003e files = Activator.utils.getSelectedFiles(selection,window,shell);\r\n    \t\t\tActivator.utils.text = null; // TODO - setting 'text' through side-effects is a bad design\r\n        \t\tif (files.isEmpty()) files = Activator.utils.resources(selection,window,shell); // sets Activator.utils.text also\r\n        \t\tif (files.isEmpty()) {\r\n        \t\t\tActivator.utils.showMessageInUI(shell,\"SMT Run Solver\",\r\n        \t\t\t\t\t\"Failed to find a resource on which to run a solver (select one or more files or an editor)\");\r\n        \t\t\treturn;\r\n        \t\t}\r\n    \t\t\tActivator.utils.runJobs(solvers,files);\r\n    \t\t} catch (Exception e) {\r\n    \t\t\tActivator.utils.topLevelException(shell,\"MenuActions.RunSolver\",e);\r\n    \t\t}\r\n\r\n    \t}\r\n    }\r\n\r\n    /**\r\n     * This class implements the action that clears\r\n     * SMT markers.  It is performed entirely in the UI thread, with no\r\n     * progress reporting.  Its ought to be fast.\r\n     * \r\n     * @author David R. Cok\r\n     */\r\n    public static class DeleteMarkers extends MenuActions {\r\n        @Override\r\n        public final void run(final IAction action) {\r\n            try {\r\n                Activator.utils.deleteMarkersInSelection(selection,window,shell);\r\n            } catch (Exception e) {\r\n                Activator.utils.topLevelException(shell,\"MenuActions.DeleteMarkers\",e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Shows the content of the SMT logic or theory whose name is selected */\r\n    public static class ViewLogic extends MenuActions {\r\n        @Override\r\n        public final void run(final IAction action) {\r\n        \tActivator.utils.viewLogic(shell,selection);\r\n        }\r\n    }\r\n\r\n    /** Does a get-value command on the selected text */\r\n    public static class GetValue extends MenuActions {\r\n        @Override\r\n        public final void run(final IAction action) {\r\n        \tActivator.utils.getValue(shell,selection);\r\n        }\r\n    }\r\n\r\n}\r\n",
        "name": "MenuActions.java",
        "path": "smt/lip6.smtlib.plugin.SMTPlugin/src/org/smtlib/plugin/MenuActions.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.plugin.SMTPlugin/src/org/smtlib/plugin/MenuActions.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 37,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures this.selection != null;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT plugin project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.plugin;\r\n\r\n// FIXME : Needs a color selection widget\r\n\r\nimport org.eclipse.swt.SWT;\r\nimport org.eclipse.swt.events.ModifyListener;\r\nimport org.eclipse.swt.widgets.Button;\r\nimport org.eclipse.swt.widgets.Text;\r\nimport org.eclipse.swt.widgets.Combo;\r\nimport org.eclipse.swt.widgets.Composite;\r\n\r\n/**\r\n * This class is a base class for the controls that are used in\r\n * the property page; each control is connected to an Option object.\r\n * \r\n * @author David Cok\r\n *\r\n */\r\nabstract public class PreferenceWidget {\r\n\t\r\n\t/** The option object represented by this PreferenceWidget */\r\n\t/*@Nullable*/ AbstractPreference option;\r\n\t\r\n\t\r\n\t/**\r\n\t * Base class constructor, taking some common arguments.\r\n\t * \r\n\t * @param option The option that this widget represents.\r\n\t */\r\n\tpublic PreferenceWidget(/*@Nullable*/ AbstractPreference option) {\r\n\t\tthis.option = option;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Creates and adds the widget to the given control\r\n\t * @param parent The composite to add the widget to.\r\n\t */\r\n\tabstract public void addWidget(Composite parent);\r\n\t\r\n\t/**\r\n\t * Sets the UI widget to the built-in default value\r\n\t *\r\n\t */\r\n\tabstract public void setDefault();\r\n\t\r\n\t/**\r\n\t * Sets the value of the associated option based on the\r\n\t * current UI setting.\r\n\t * \r\n\t */\r\n\tabstract public void setOptionValue();\r\n\r\n\t\r\n\t/**\r\n\t * A UI widget that offers a selection from a fixed \r\n\t * set of strings,\r\n\t * corresponding to a ChoiceOption.\r\n\t *  \r\n\t * @author David Cok\r\n\t *\r\n\t */\r\n\tpublic static class ChoiceWidget extends PreferenceWidget {\r\n\t\t\r\n\t\t/** The widget used to get input from the user. */\r\n\t\t/*@Nullable*/ protected Combo widget = null;\r\n\t\t\r\n\t\t/**\r\n\t\t * A constructor that creates a Combo widget, initializing\r\n\t\t * it from the associated property.\r\n\t\t * \r\n\t\t * @param option The option with which the widget is associated\r\n\t\t */\r\n\t\t//@ pure\r\n\t\tpublic ChoiceWidget(AbstractPreference.ChoiceOption option) {\r\n\t\t\tsuper(option);\r\n\t\t}\r\n        \r\n\t\t/**\r\n\t\t * Creates the corresponding widget and adds it to the given\r\n\t\t * Composite widget; the UI widgets are recreated for each\r\n\t\t * instance of a property page.\r\n\t\t * @param parent The Composite that holds all of the option widgets\r\n\t\t */\r\n\t\t//@ ensures widget != null;\r\n\t\t@Override\r\n\t\tpublic void addWidget(Composite parent) {\r\n\t\t\tAbstractPreference.ChoiceOption opt = (AbstractPreference.ChoiceOption)option;\r\n\t\t\tComposite composite = new Widgets.HComposite(parent,2);\r\n\t\t\twidget = new Combo(composite, SWT.READ_ONLY);\r\n\t\t\twidget.setItems(opt.choices());\r\n\t\t\twidget.select(opt.getIndexValue());\r\n\t\t\twidget.setVisibleItemCount(opt.choices().length);\r\n\t\t\twidget.setToolTipText(opt.tooltip());\r\n\t\t\torg.eclipse.swt.widgets.Label label2 = new org.eclipse.swt.widgets.Label(composite,SWT.NONE);\r\n\t\t\tlabel2.setText(opt.label());\r\n\t\t\tlabel2.setToolTipText(opt.tooltip());\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns the current setting of the widget; this method\r\n\t\t * may be called only when there is a current Properties Page.\r\n\t\t * @return The current setting of the widget\r\n\t\t */\r\n\t\t//@ requires widget != null;\r\n\t\t//@ ensures \\result != null;\r\n\t\t//@ pure\r\n\t\tpublic String value() { return widget.getText(); }\r\n\t\t\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets the UI widget to the option's default value\r\n\t\t *\r\n\t\t */\r\n\t\t@Override\r\n\t\tpublic void setDefault() {\r\n\t\t\twidget.select(((AbstractPreference.ChoiceOption)option).getDefaultIndex());\r\n\t\t}\t\t\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets the option value to be consistent with the\r\n\t\t * current setting of the UI's widget.\r\n\t\t */\r\n\t\t@Override\r\n\t\tpublic void setOptionValue() { ((AbstractPreference.ChoiceOption)option).setValue(value()); } \r\n\t\t\r\n\t\t/** Resets the list of choice items */\r\n\t\tpublic void setChoices(String[] choices) { widget.setItems(choices); }\r\n\t}\r\n\t\r\n\t// FIXME - improve the handling of lengths of file/directory/string fields\r\n\t\r\n\t/**\r\n\t * This class implements an PreferenceWidget for a text field\r\n\t * property that holds a file name, using the FileTextField widget, which \r\n\t * incorporates a Browse button.\r\n\t * \r\n\t * @author David Cok\r\n\t *\r\n\t */\r\n\tpublic static class FileWidget extends PreferenceWidget {\r\n\t\t\r\n\t\t/** The UI widget representing a file browser. */\r\n\t\t/*@Nullable*/ protected Widgets.FileTextField widget = null;\r\n\r\n\t\t/**\r\n\t\t * Creates a FileWidget (the underlying widget is not\r\n\t\t * created until createContents is called).\r\n\t\t * @param option The option on which this widget is based\r\n\t\t */\r\n\t\t//@ reqiures option != null;\r\n\t\t//@ ensures widget == null;\r\n\t\t//@ ensures this.option == option;\r\n\t\t//@ pure\r\n\t\tpublic FileWidget(AbstractPreference.StringOption option) {\r\n\t\t\tsuper(option);\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t/**\r\n\t\t * Creates the corresponding widget and adds it to the given\r\n\t\t * Composite widget; the UI widgets are recreated for each\r\n\t\t * instance of a property page.\r\n\t\t * @param parent The Composite that holds all of the option widgets\r\n\t\t */\r\n\t\t//@ ensures widget != null;\r\n\t\t@Override\r\n\t\tpublic void addWidget(Composite parent) {\r\n\t\t\tString fn = ((AbstractPreference.StringOption)option).getValue();\r\n\t\t\twidget = new Widgets.FileTextField(parent,option.label(),fn,option.tooltip(),50);\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns the current setting of the widget; this method\r\n\t\t * may be called only when there is a current Properties Page.\r\n\t\t * @return The current setting of the widget\r\n\t\t */\r\n\t\t//@ requires widget != null;\r\n\t\tpublic String value() { return widget.value().trim(); }\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets the UI widget to the built-in default value\r\n\t\t *\r\n\t\t */\r\n\t\t//@ requires widget != null;\r\n\t\t//@ requires option != null;\r\n\t\t@Override\r\n\t\tpublic void setDefault() {\r\n\t\t\twidget.setText(((AbstractPreference.StringOption)option).getDefault());\r\n\t\t}\r\n\t\t\t\t\r\n\t\t/**\r\n\t\t * Sets the option value to be consistent with the\r\n\t\t * current setting of the UI's widget.\r\n\t\t */\r\n\t\t//@ requires widget != null;\r\n\t\t//@ requires option != null;\r\n\t\t@Override\r\n\t\tpublic void setOptionValue() { ((AbstractPreference.StringOption)option).setValue(value()); } \r\n\t}\r\n\t\r\n\t/**\r\n\t * This class implements an PreferenceWidget for a text field\r\n\t * property that holds a directory name, using the DirTextField widget, which \r\n\t * incorporates a Browse button.\r\n\t * \r\n\t * @author David Cok\r\n\t *\r\n\t */\r\n\tpublic static class DirectoryWidget extends PreferenceWidget {\r\n\t\t\r\n\t\t/** The UI widget representing a file browser. */\r\n\t\t/*@Nullable*/ protected Widgets.DirTextField widget = null;\r\n\r\n\t\t/**\r\n\t\t * Creates a FileWidget (the underlying widget is not\r\n\t\t * created until createContents is called).\r\n\t\t * @param option The option on which this widget is based\r\n\t\t */\r\n\t\t//@ reqiures option != null;\r\n\t\t//@ ensures widget == null;\r\n\t\t//@ ensures this.option == option;\r\n\t\t//@ pure\r\n\t\tpublic DirectoryWidget(AbstractPreference.StringOption option) {\r\n\t\t\tsuper(option);\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t/**\r\n\t\t * Creates the corresponding widget and adds it to the given\r\n\t\t * Composite widget; the UI widgets are recreated for each\r\n\t\t * instance of a property page.\r\n\t\t * @param parent The Composite that holds all of the option widgets\r\n\t\t */\r\n\t\t//@ ensures widget != null;\r\n\t\t@Override\r\n\t\tpublic void addWidget(Composite parent) {\r\n\t\t\tString fn = ((AbstractPreference.StringOption)option).getValue();\r\n\t\t\twidget = new Widgets.DirTextField(parent,option.label(),fn,option.tooltip(),80);\r\n\t\t}\r\n\t\t\r\n\t\tpublic void addModifyListener(ModifyListener listener) {\r\n\t\t\twidget.addModifyListener(listener);\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns the current setting of the widget; this method\r\n\t\t * may be called only when there is a current Properties Page.\r\n\t\t * @return The current setting of the widget\r\n\t\t */\r\n\t\t//@ requires widget != null;\r\n\t\tpublic String value() { return widget.value().trim(); }\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets the UI widget to the built-in default value\r\n\t\t *\r\n\t\t */\r\n\t\t//@ requires widget != null;\r\n\t\t//@ requires option != null;\r\n\t\t@Override\r\n\t\tpublic void setDefault() {\r\n\t\t\twidget.setText(((AbstractPreference.StringOption)option).getDefault());\r\n\t\t}\r\n\t\t\t\t\r\n\t\t/**\r\n\t\t * Sets the option value to be consistent with the\r\n\t\t * current setting of the UI's widget.\r\n\t\t */\r\n\t\t//@ requires widget != null;\r\n\t\t//@ requires option != null;\r\n\t\t@Override\r\n\t\tpublic void setOptionValue() { ((AbstractPreference.StringOption)option).setValue(value()); } \r\n\t}\r\n\t\r\n\t/**\r\n\t * This class implements a PropertyWidget for a boolean-valued\r\n\t * property, associating it with a check-box Button in the UI.\r\n\t * \r\n\t * @author David Cok\r\n\t *\r\n\t */\r\n\tpublic static class BooleanWidget extends PreferenceWidget {\r\n\t\t\r\n\t\t/** The UI widget representing a boolean choice. */\r\n\t\t/*@Nullable*/ protected Button widget = null;\r\n\t\t\r\n\t\t/**\r\n\t\t * Creates a checkbox widget on the given parent Composite widget;\r\n\t\t * initializes the widget with the value of the given option\r\n\t\t * @param option The option on which this widget is based\r\n\t\t */\r\n\t\t//@ requires option != null;\r\n\t\t//@ ensures this.option == option;\r\n\t\t//@ pure\r\n\t\tpublic BooleanWidget(AbstractPreference.BooleanOption option) {\r\n\t\t\tsuper(option);\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * Creates the corresponding widget and adds it to the given\r\n\t\t * Composite widget; the UI widgets are recreated for each\r\n\t\t * instance of a property page.\r\n\t\t * @param parent The Composite that holds all of the option widgets\r\n\t\t */\r\n\t\t//@ requires option != null;\r\n\t\t//@ ensures widget != null;\r\n\t\t@Override\r\n\t\tpublic void addWidget(Composite parent) {\r\n\t\t\twidget = new Button(parent,SWT.CHECK);\r\n\t\t\twidget.setText(option.label());\r\n\t\t\twidget.setToolTipText(option.tooltip());\r\n\t\t\twidget.setSelection(((AbstractPreference.BooleanOption)option).getValue());\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns the current setting of the widget; this method\r\n\t\t * may be called only when there is a current Properties Page.\r\n\t\t * @return The current setting of the widget\r\n\t\t */\r\n\t\t//@ requires widget != null;\r\n\t\tpublic boolean value() { return widget.getSelection(); }\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets the UI widget to the built-in default value\r\n\t\t *\r\n\t\t */\r\n\t\t//@ requires widget != null;\r\n\t\t//@ requires option != null;\r\n\t\t@Override\r\n\t\tpublic void setDefault() {\r\n\t\t\twidget.setSelection(((AbstractPreference.BooleanOption)option).getDefault());\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets the workspace property value to be consistent with the\r\n\t\t * current setting of the UI's widget.\r\n\t\t */\r\n\t\t//@ requires widget != null;\r\n\t\t//@ requires option != null;\r\n\t\t@Override\r\n\t\tpublic void setOptionValue() { ((AbstractPreference.BooleanOption)option).setValue(value()); } \r\n\t}\r\n\r\n    /**\r\n     * This class implements a PropertyWidget for a boolean-valued\r\n     * property, associating it with a check-box Button in the UI.\r\n     * \r\n     * @author David Cok\r\n     *\r\n     */\r\n    public static class IntWidget extends PreferenceWidget {\r\n    \t\r\n    \t// FIXME - change this to be an int field with arrow keys?  Use FieldEditors?\r\n        \r\n        /** The UI widget representing a choice. */\r\n    \t/*@Nullable*/ protected Combo widget = null;\r\n        \r\n        /** The strings giving the specific choices displayed. */\r\n        protected String[] choices;\r\n        \r\n        /**\r\n         * Creates a checkbox widget on the given parent Composite widget;\r\n         * initializes the widget with the value of the given option\r\n         * @param option The option on which this widget is based\r\n         * @param choices the specific alternates displayed as choices\r\n         */\r\n        //@ requires option != null;\r\n        //@ ensures this.option == option;\r\n        //@ pure\r\n        public IntWidget(AbstractPreference.IntOption option, String[] choices) {\r\n            super(option);\r\n            this.choices = choices;\r\n        }\r\n        \r\n        /**\r\n         * Creates the corresponding widget and adds it to the given\r\n         * Composite widget; the UI widgets are recreated for each\r\n         * instance of a property page.\r\n         * @param parent The Composite that holds all of the option widgets\r\n         */\r\n        //@ requires option != null;\r\n        //@ ensures widget != null;\r\n\t\t@Override\r\n        public void addWidget(Composite parent) {\r\n            AbstractPreference.IntOption opt = (AbstractPreference.IntOption)option;\r\n            Composite composite = new Widgets.HComposite(parent,2);\r\n            org.eclipse.swt.widgets.Label label2 = new org.eclipse.swt.widgets.Label(composite,SWT.NONE);\r\n            label2.setText(opt.label());\r\n            label2.setToolTipText(opt.tooltip());\r\n            widget = new Combo(composite, SWT.READ_ONLY);\r\n            widget.setItems(choices);\r\n            widget.select(opt.getValue());\r\n            widget.setVisibleItemCount(choices.length);\r\n            widget.setToolTipText(opt.tooltip());\r\n\r\n//            widget = new Button(parent,SWT.CHECK);\r\n//            widget.setText(option.label());\r\n//            widget.setToolTipText(option.tooltip());\r\n//            widget.setSelection(((AbstractPreference.BooleanOption)option).getValue());\r\n        }\r\n        \r\n        /**\r\n         * Returns the current setting of the widget; this method\r\n         * may be called only when there is a current Properties Page.\r\n         * @return The current setting of the widget\r\n         */\r\n        //@ requires widget != null;\r\n        public int value() { return widget.getSelectionIndex(); }\r\n        \r\n        /**\r\n         * Sets the UI widget to the built-in default value\r\n         *\r\n         */\r\n        //@ requires widget != null;\r\n        //@ requires option != null;\r\n\t\t@Override\r\n        public void setDefault() {\r\n            widget.select(((AbstractPreference.IntOption)option).getDefault());\r\n        }\r\n        \r\n        /**\r\n         * Sets the workspace property value to be consistent with the\r\n         * current setting of the UI's widget.\r\n         */\r\n        //@ requires widget != null;\r\n        //@ requires option != null;\r\n\t\t@Override\r\n        public void setOptionValue() { ((AbstractPreference.IntOption)option).setValue(value()); } \r\n    }\r\n    \r\n\r\n    /**\r\n     * This class implements a PropertyWidget for a String-valued\r\n     * property, associating it with an editable text box in the UI.\r\n     * \r\n     * @author David Cok\r\n     *\r\n     */\r\n    public static class StringWidget extends PreferenceWidget {\r\n        \r\n        /** The UI widget representing a String value. */\r\n    \t/*@Nullable*/ protected Text widget = null;\r\n        \r\n        /**\r\n         * Creates a checkbox widget on the given parent Composite widget;\r\n         * initializes the widget with the value of the given option\r\n         * @param option The option on which this widget is based\r\n         */\r\n        //@ requires option != null;\r\n        //@ ensures this.option == option;\r\n        //@ pure\r\n        public StringWidget(AbstractPreference.StringOption option) {\r\n            super(option);\r\n        }\r\n        \r\n        /**\r\n         * Creates the corresponding widget and adds it to the given\r\n         * Composite widget; the UI widgets are recreated for each\r\n         * instance of a property page.\r\n         * @param parent The Composite that holds all of the option widgets\r\n         */\r\n        //@ requires option != null;\r\n        //@ ensures widget != null;\r\n\t\t@Override\r\n        public void addWidget(Composite parent) {\r\n          Composite composite = new Widgets.HComposite(parent,2);\r\n          org.eclipse.swt.widgets.Label label2 = new org.eclipse.swt.widgets.Label(composite,SWT.NONE);\r\n          label2.setText(option.label());\r\n          label2.setToolTipText(option.tooltip());\r\n          widget = new Text(composite, SWT.SINGLE);\r\n          widget.setText(((AbstractPreference.StringOption)option).getValue());\r\n          widget.setToolTipText(option.tooltip());\r\n        }\r\n\r\n        /**\r\n         * Returns the current setting of the widget; this method\r\n         * may be called only when there is a current Properties Page.\r\n         * @return The current setting of the widget\r\n         */\r\n        //@ requires widget != null;\r\n        public String value() { return widget.getText(); }\r\n        \r\n        /**\r\n         * Sets the UI widget to the built-in default value\r\n         *\r\n         */\r\n        //@ requires widget != null;\r\n        //@ requires option != null;\r\n\t\t@Override\r\n        public void setDefault() {\r\n            widget.setText(((AbstractPreference.StringOption)option).getDefault());\r\n        }\r\n        \r\n        /**\r\n         * Sets the workspace property value to be consistent with the\r\n         * current setting of the UI's widget.\r\n         */\r\n        //@ requires widget != null;\r\n        //@ requires option != null;\r\n\t\t@Override\r\n        public void setOptionValue() {\r\n          ((AbstractPreference.StringOption)option).setValue(value()); \r\n        } \r\n    }\r\n\t/**\r\n\t * This class implements an PreferenceWidget that is a Label, so\r\n\t * that it can sit in lists of PreferenceWidgets.  However, it does\r\n\t * not have an option associated with it.\r\n\t * \r\n\t * @author David Cok\r\n\t *\r\n\t */\r\n\tpublic static class Label extends PreferenceWidget {\r\n\t\t\r\n\t\t/** The UI widget that is a label. */\r\n\t\t/*@Nullable*/ protected Widgets.LabeledSeparator widget = null;\r\n\t\t\r\n\t\t/** The label value */\r\n\t\tprotected String label;\r\n\t\r\n\t\t/** \r\n\t\t * Creates a Label widget on the given parent Composite widget.\r\n\t\t * @param label The label text for the widget\r\n\t\t */\r\n\t\t//@ requires label != null;\r\n\t\t//@ ensures this.label == label;\r\n\t\t//@ pure\r\n\t\tpublic Label(String label) {\r\n\t\t\tsuper(null);\r\n\t\t\tthis.label = label;\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * Creates the corresponding widget and adds it to the given\r\n\t\t * Composite widget; the UI widgets are recreated for each\r\n\t\t * instance of a property page.\r\n\t\t * @param parent The Composite that holds all of the option widgets\r\n\t\t */\r\n\t\t//@ ensures widget != null;\r\n\t\t@Override\r\n\t\tpublic void addWidget(Composite parent) {\r\n\t\t\twidget = new Widgets.LabeledSeparator(parent,label);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Does nothing.\r\n\t\t */\r\n\t\t@Override\r\n\t\tpublic void setDefault() { } \r\n\t\t\r\n\t\t/**\r\n\t\t * Does nothing.\r\n\t\t */\r\n\t\t@Override\r\n\t\tpublic void setOptionValue() { } \r\n\t}\r\n\r\n}\r\n",
        "name": "PreferenceWidget.java",
        "path": "smt/lip6.smtlib.plugin.SMTPlugin/src/org/smtlib/plugin/PreferenceWidget.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.plugin.SMTPlugin/src/org/smtlib/plugin/PreferenceWidget.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 370,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 371,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures this.option == option;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 384,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 385,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 410,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 417,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 418,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 428,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 429,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 452,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 453,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures this.option == option;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 465,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 466,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 483,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 490,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 491,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 501,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 502,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 88,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 109,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 155,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures widget == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 156,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures this.option == option;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 169,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 181,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 188,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 189,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 199,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 200,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 224,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures widget == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 225,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures this.option == option;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 238,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 254,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 261,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 262,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 272,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 273,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 295,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 296,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures this.option == option;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 308,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 309,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 323,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 330,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 331,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 341,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 342,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 528,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires label != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 529,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures this.label == label;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 542,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures widget != null;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT plugin project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.plugin;\r\n\r\nimport java.util.Collection;\r\nimport java.util.LinkedList;\r\n\r\nimport org.eclipse.jface.preference.IPreferenceStore;\r\n\r\n/**\r\n * This is a base class for persistent options.  The options are\r\n * stored as workspace preferences.\r\n * \r\n * @author David R. Cok\r\n */\r\npublic class AbstractPreference {\r\n\r\n    /** A reference to the plugin's preference store */\r\n    public IPreferenceStore preferenceStore() { \r\n    \treturn Activator.getDefault().getPreferenceStore(); \r\n    }\r\n\r\n    /** The name used as the key into the \r\n     * persistent store for the value of the option.\r\n     */\r\n    //@ non_null\r\n    protected String key;\r\n\r\n    /** The label to use for the widget */\r\n    //@ non_null\r\n    protected String label;\r\n\r\n    /** The tooltip help for the widget */\r\n    //@ non_null\r\n    protected String tooltip;\r\n\r\n    /**\r\n     * The protected constructor used by derived classes\r\n     * @param key  The name used as a preference key\r\n     * @param label  A short description suitable as a label\r\n     * @param tooltip  A longer description suitable as help\r\n     */\r\n    protected AbstractPreference(String key, String label, String tooltip) {\r\n        this.key = key;\r\n        this.label = label;\r\n        this.tooltip = tooltip;\r\n    }\r\n\r\n    /** An interface for the listeners that are fired when options change.*/\r\n    static public interface Listener {\r\n        /** The method executed when the listener is notified. */\r\n        public void run();\r\n    }\r\n\r\n    /** The listeners that will be notified when options change (through the workspace preferences dialog). */\r\n    static private Collection\u003cListener\u003e listeners = new LinkedList\u003cListener\u003e();\r\n\r\n    /** Adds a listener to the collection of listeners.\r\n     * \r\n     * @param l Listener to be added\r\n     */\r\n    static synchronized public void addListener(Listener l) {\r\n        listeners.add(l);\r\n    }\r\n\r\n    /** Adds a listener to the collection of listeners.\r\n     * \r\n     * @param l Listener to be removed\r\n     */\r\n    static synchronized public void removeListener(Listener l) {\r\n        listeners.remove(l);\r\n    }\r\n\r\n    /** Executes all listeners */\r\n    static synchronized public void notifyListeners() {\r\n        for (Listener i: listeners) {\r\n            i.run();\r\n        }\r\n    }\r\n    \r\n    /** Returns the key string\r\n     * @return the key\r\n     */\r\n    public String key() { return key; }\r\n\r\n    /** Returns the label string (short description) for this option\r\n     * \r\n     * @return the label string\r\n     */\r\n    public String label() { return label; }\r\n\r\n    /** Returns the help string for this option\r\n     * \r\n     * @return the help string\r\n     */\r\n    public String tooltip() { return tooltip; }\r\n\r\n    /** Sets the option to its default value */\r\n    public void setToDefault() {\r\n        preferenceStore().setToDefault(key);\r\n    }\r\n\r\n    /** An option that has a boolean value */\r\n    static public class BooleanOption extends AbstractPreference {\r\n\r\n        /**\r\n         * Creating a boolean option object\r\n         * @param key  The name used as a preference key\r\n         * @param def  The default value used if no value is previously stored\r\n         * @param label A short description usable as a label\r\n         * @param tooltip A long description usable as help\r\n         */\r\n        public BooleanOption(String key, boolean def,\r\n                String label, String tooltip) {\r\n            super(key,label,tooltip);\r\n            preferenceStore().setDefault(key,def);\r\n        }\r\n\r\n        /**\r\n         * Returns the current value of the option \r\n         * @return The current value of the option\r\n         */\r\n        public boolean getValue() { return preferenceStore().getBoolean(key); }\r\n\r\n        /**\r\n         * Sets the workspace property value to the given value.\r\n         * \r\n         * @param b The value to set\r\n         */\r\n        public void setValue(boolean b) { preferenceStore().setValue(key,b); } \r\n\r\n        /** Returns the default value of the preference\r\n         * @return the default value of the preference\r\n         */\r\n        public boolean getDefault() {\r\n            return preferenceStore().getDefaultBoolean(key);\r\n        }\r\n\r\n    }\r\n\r\n    /** An option that has a int value */\r\n    static public class IntOption extends AbstractPreference {\r\n\r\n        /**\r\n         * Creating a int option object\r\n         * @param key  The name used as a preference key\r\n         * @param def  The default value used if no value is previously stored\r\n         * @param label A short description usable as a label\r\n         * @param tooltip A long description usable as help\r\n         */\r\n        public IntOption(String key, int def,\r\n                String label, String tooltip) {\r\n            super(key,label,tooltip);\r\n            preferenceStore().setDefault(key,def);\r\n        }\r\n\r\n        /**\r\n         * Returns the current value of the option \r\n         * @return The current value of the option\r\n         */\r\n        public int getValue() { return preferenceStore().getInt(key); }\r\n\r\n        /**\r\n         * Sets the workspace property value to the given value.\r\n         * \r\n         * @param i The value to set\r\n         */\r\n        public void setValue(int i) { preferenceStore().setValue(key,i); } \r\n\r\n        /** Returns the default value of the preference\r\n         * @return the default value of the preference\r\n         */\r\n        public int getDefault() {\r\n            return preferenceStore().getDefaultInt(key);\r\n        }\r\n\r\n    }\r\n\r\n    /** An option that has a String value */\r\n    static public class StringOption extends AbstractPreference {\r\n\r\n        /**\r\n         * Creating a String option object\r\n         * @param key  The qualified name used as a property key\r\n         * @param def  The default value used if no value is previously stored\r\n         * @param label A short description usable as a label\r\n         * @param tooltip A long description usable as help\r\n         */\r\n        public StringOption(String key, String def,\r\n                String label, String tooltip) {\r\n            super(key,label,tooltip);\r\n            if (def != null) preferenceStore().setDefault(key,def);\r\n        }\r\n\r\n        /** Returns the default value of the preference\r\n         * @return the default value of the preference\r\n         */\r\n        public String getDefault() {\r\n            return preferenceStore().getDefaultString(key);\r\n        }\r\n\r\n        /**\r\n         * Returns the current value of the option \r\n         * @return The current value of the option\r\n         */\r\n        public String getValue() { return preferenceStore().getString(key); }\r\n\r\n        /**\r\n         * Sets the option value to the given value.\r\n         * \r\n         * @param v The value to set\r\n         */\r\n        public void setValue(String v) { preferenceStore().setValue(key,v); } \r\n    }\r\n\r\n    /** An option that has one of a set of Strings as its value */\r\n    static public class ChoiceOption extends AbstractPreference {\r\n\r\n        /** The choices */\r\n        protected String[] choices;\r\n\r\n        /**\r\n         * Creating a String option object\r\n         * @param key  The name used as a preference key\r\n         * @param def  The default value used if no value is previously stored (an index into the array of choices)\r\n         * @param choices The choices (as Strings) to be chosen among\r\n         * @param label A short description usable as a label\r\n         * @param tooltip A long description usable as help\r\n         */\r\n        public ChoiceOption(String key, String[] choices,\r\n                int def,\r\n                String label, String tooltip) {\r\n            super(key,label,tooltip);\r\n            preferenceStore().setDefault(key,choices[def]);\r\n            this.choices = choices;\r\n        }\r\n\r\n        /** Returns the array of choices; this array should not be modified.\r\n         * \r\n         * @return the array of choices\r\n         */\r\n        public String[] choices() { return choices; }\r\n\r\n        /** Returns the default value of the preference\r\n         * @return the default value of the preference\r\n         */\r\n        public String getDefault() {\r\n            return preferenceStore().getDefaultString(key);\r\n        }\r\n\r\n        /** Returns the default value of the preference\r\n         * @return the default value of the preference\r\n         */\r\n        public int getDefaultIndex() {\r\n            return lookup(preferenceStore().getDefaultString(key));\r\n        }\r\n\r\n        /**\r\n         * Returns the current value of the option \r\n         * @return The current value of the option\r\n         */\r\n        public int getIndexValue() { \r\n            String r = preferenceStore().getString(key);\r\n            return lookup(r);\r\n        }\r\n\r\n        /**\r\n         * Returns the current value of the option \r\n         * @return The current value of the option\r\n         */\r\n        public String getStringValue() { \r\n            return preferenceStore().getString(key);\r\n        }\r\n\r\n        /**\r\n         * Sets the option value to the given value.\r\n         * \r\n         * @param v The String value to set\r\n         */\r\n        public void setValue(String v) { preferenceStore().setValue(key,v); }\r\n\r\n        /**\r\n         * Sets the option value to the given value.\r\n         * \r\n         * @param i The index value to set\r\n         */\r\n        //@ requires 0\u003c=i \u0026\u0026 i\u003cchoices.length;\r\n        public void setValue(int i) { preferenceStore().setValue(key,choices[i]); } \r\n\r\n        /**\r\n         * Returns the index in the choices array corresponding\r\n         * to the argument; returns -1 if not found.\r\n         * @param s The String to be sought in the choices array\r\n         * @return The index of the argument in the array\r\n         */\r\n        //@ requires s != null;\r\n        //@ ensures \\result != -1 ==\u003e choices[\\result].equals(s);\r\n        //@ ensures \\result == -1 ==\u003e (\\forall int i; 0\u003c=i \u0026\u0026 i\u003cchoices.length; !choices[i].equals(s));\r\n        private int lookup(String s) {\r\n            for (int i=0; i\u003cchoices.length; ++i) {\r\n                if (s.equals(choices[i])) return i;\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n}\r\n",
        "name": "AbstractPreference.java",
        "path": "smt/lip6.smtlib.plugin.SMTPlugin/src/org/smtlib/plugin/AbstractPreference.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.plugin.SMTPlugin/src/org/smtlib/plugin/AbstractPreference.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 289,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires 0\u003c=i \u0026\u0026 i\u003cchoices.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 298,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires s != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 299,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures \\result != -1 ==\u003e choices[\\result].equals(s);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 300,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures \\result == -1 ==\u003e (\\forall int i; 0\u003c=i \u0026\u0026 i\u003cchoices.length; !choices[i].equals(s));\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib;\r\n\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\nimport org.smtlib.IExpr.IIdentifier;\r\nimport org.smtlib.IExpr.INumeral;\r\nimport org.smtlib.IExpr.ISymbol;\r\nimport org.smtlib.IPos.IPosable;\r\nimport org.smtlib.IVisitor.VisitorException;\r\n\r\n/** The interface for an SMT-LIB concept of a Sort. Two kinds of things are modeled here.\r\n * \u003cP\u003e\r\n * First, a definition of a Sort, modeled by ISort.IDefinition. There are these kinds of \r\n * definitions:\r\n * \u003cUL\u003e\r\n * \u003cLI\u003e an ISort.IFamily, which defines a new sort symbol of a given arity\r\n * \u003cLI\u003e an ISort.IAbbreviation, which defines a (possibly parameterized) abbreviation for a sort expression.\r\n * \u003cLI\u003e an ISort.IParameter, which defines a sort name used as a parameter in an abbreviation definition\r\n * \u003cLI\u003e The ISort.ErrorDefinition class, which is used as a definition place holder for ill-formed definitions, to avoid excessive redundant errors\r\n * \u003c/UL\u003e\r\n * Second, Sort expressions themselves, modeled by ISort:\r\n * \u003cUL\u003e\r\n * \u003cLI\u003eA ISort.IApplication, which is the application of an IDefinition to the appropriate number\r\n * (possibly 0) of Sort expressions\r\n * \u003cLI\u003eA ISort.IParameter, which is a simple symbol designating the parameter of a parameterized abbreviation\r\n * \u003cLI\u003eA ISort.IFcnSort, an expression designating a function sort; this is not expressible in SMT-LIBv2, but is \r\n * useful internally within jSMTLIB.\r\n * \u003c/UL\u003e\r\n */\r\npublic interface ISort extends IAccept, IPosable {\r\n\r\n\t/** Structural equality after expansion of abbreviations, but without any substitution of free parameters. */\r\n\t//@ pure\r\n\t@Override\r\n\tboolean equals(Object o);\r\n\r\n\t/** Structural equality after expansion of abbreviations (as looked up in the symbol table)\r\n\t * and substitution of free parameters according to the respective maps. \r\n\t */\r\n\t//@ pure\r\n\tboolean equals(Map\u003cIParameter,ISort\u003e leftmap, ISort s, Map\u003cIParameter,ISort\u003e rightmap, SymbolTable symTable);\r\n\r\n\t/** Returns true if the receiver designates the Bool pre-defined Sort. */\r\n\t//@ pure\r\n\tboolean isBool();\r\n\t\r\n\t/** Expands all abbreviations */\r\n\t//@ pure\r\n\tISort expand();\r\n\t\r\n\t/** Returns a new sort with any parameters substituted */\r\n\t//@ pure\r\n\tISort substitute(java.util.Map\u003cIParameter,ISort\u003e map);\r\n\r\n\t/** Compares sort expressions without abbreviation expansion or parameter substitution */\r\n\t//@ pure\r\n\tboolean equalsNoExpand(ISort sort);\r\n\t\r\n\t/** A super-interface for definitions of new sort ids.\r\n\t */\r\n\tstatic public interface IDefinition extends IAccept {\r\n\t\t/** The identifier for the sort symbol */\r\n\t\t//@ pure\r\n\t\tIIdentifier identifier();\r\n\t\t\r\n\t\t/** A new sort expression that results from applying the sort symbol to a list of sort expressions */\r\n\t\t//@ requires sorts.size() == intArity();\r\n\t\t//@ pure\r\n\t\tISort eval(List\u003cISort\u003e sorts);\r\n\t\t\r\n\t\t/** The arity of the symbol*/\r\n\t\t//@ ensures \\result \u003e= 0;\r\n\t\t//@ pure\r\n\t\tint intArity();\r\n\t}\r\n\t\r\n\t/** This class is an instance of a sort definition that represents an erroneous definition\r\n\t * of a Sort; by defining an actual IDefinition, excessive propagation of errors is avoided.\r\n\t */ // TODO - check if the above statement is actually valid and that having this class makes a difference\r\n\tstatic public class ErrorDefinition implements IDefinition {\r\n\t\tpublic IIdentifier id;\r\n\t\tpublic String error;\r\n\t\tpublic IPos pos;\r\n\t\t\r\n\t\tpublic ErrorDefinition(IIdentifier id, String error, IPos pos) {\r\n\t\t\tthis.id = id;\r\n\t\t\tthis.error = error;\r\n\t\t\tthis.pos = pos;\r\n\t\t}\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic \u003cT\u003e T accept(IVisitor\u003cT\u003e v) throws VisitorException {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic IIdentifier identifier() {\r\n\t\t\treturn id;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic ISort eval(List\u003cISort\u003e sorts) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic int intArity() {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t/** This interface represents a new Sort symbol designating either\r\n\t * a new Sort (if the arity is 0) or a new parameterized Sort family\r\n\t * (if the arity is greater than 0); each new symbol has a (new) name\r\n\t * and a non-negative arity.\r\n\t */\r\n\tstatic public interface IFamily extends IDefinition {\r\n\t\t/** The unique identifier for this sort symbol */\r\n\t\t@Override\r\n\t\tIIdentifier identifier();\r\n\t\t\r\n\t\t/** The arity of the sort symbol */\r\n\t\t//@ ensures \\result.intValue() \u003e= 0;\r\n\t\tINumeral arity();\r\n\t}\r\n\t\r\n\t/** This interface represents a new Sort symbol designating an\r\n\t * abbreviation for a (possibly parameterized) sort expression.\r\n\t */\r\n\tstatic public interface IAbbreviation extends IDefinition {\r\n\t\t/** The identifier of the abbreviation */\r\n\t\t@Override\r\n\t\tIIdentifier identifier();\r\n\r\n\t\t/** The list of parameters of the abbreviation (possibly empty, but not null) */\r\n\t\tList\u003cIParameter\u003e parameters();\r\n\r\n\t\t/** The sort expression that the abbreviation represents, presumably using the given parameters */\r\n\t\tISort sortExpression();\r\n\t}\r\n\t\r\n\t/** The interface for a Sort expression that consists of either\r\n\t * an arity 0 sort symbol or a positive-arity symbol with the \r\n\t * appropriate number of arguments.\r\n\t */\r\n\tstatic public interface IApplication extends ISort {\r\n\t\t/** The head identifier of the sort expression */\r\n\t\tIIdentifier family();\r\n\t\t\r\n\t\t/** Returns the ith parameter */\r\n\t\t//@ requires i \u003e= 0 \u0026\u0026 i \u003c parameters().size();\r\n\t\tISort param(int i);\r\n\t\t\r\n\t\t/** Returns the list of parameters */\r\n\t\tList\u003cISort\u003e parameters();\r\n\t\t\r\n\t\t/** The definition of the family identifier, valid after the sort expression has been type-checked. */\r\n\t\tIDefinition definition();\r\n\r\n\t\t/** Sets and returns the value of definition() for this object to the value that is the argument */\r\n\t\t//@ ensures \\result == definition;\r\n\t\tIDefinition definition(IDefinition definition);\r\n\t\t\r\n\t\t/** Expands any head abbreviations, if any; requires definition() to be defined */\r\n\t\t@Override\r\n\t\tISort expand();\r\n\r\n\t\t@Override\r\n\t\tboolean equals(/*@Nullable*/Object o);\r\n\t\t\r\n\t\t@Override\r\n\t\tboolean equals(Map\u003cIParameter,ISort\u003e leftmap, ISort s, Map\u003cIParameter,ISort\u003e rightmap, SymbolTable symTable);\r\n\r\n\t\t@Override\r\n\t\tboolean equalsNoExpand(ISort sort);\r\n\r\n\t}\r\n\r\n\t/** The interface for a sort parameter, as used in sort abbreviations\r\n\t * (including in the defining expression).\r\n\t */\r\n\tstatic public interface IParameter extends ISort, IDefinition {\r\n\t\t/** The symbol that names the parameter */\r\n\t\tISymbol symbol();\r\n\t\t\r\n\t\t@Override\r\n\t\tboolean equals(/*@Nullable*/Object o);\r\n\t\t\r\n\t\t@Override\r\n\t\tboolean equals(Map\u003cIParameter,ISort\u003e leftmap, ISort s, Map\u003cIParameter,ISort\u003e rightmap, SymbolTable symTable);\r\n\t\t\r\n\t\t@Override\r\n\t\tboolean equalsNoExpand(ISort sort);\r\n\r\n\t}\r\n\t\r\n\t/** An interface to represent the Sort of a function; this is\r\n\t * not something that can be written as a sort expression in SMT-LIB,\r\n\t * but it is convenient to be able to represent the sorts of function\r\n\t * ids uniformly with the sorts of other ids.  // FIXME - perhaps we can get around this - IFcnSort\r\n\t */\r\n\tstatic public interface IFcnSort extends ISort {\r\n\t\tISort resultSort();\r\n\t\tISort[] argSorts();\r\n\t}\r\n\t\r\n\t/** The interface for a Sort-creating factory */\r\n\tstatic public interface IFactory {\r\n\t\t/** Creates a sort family with the given identifier and arity */\r\n\t\tIFamily createSortFamily(IIdentifier identifier, INumeral arity);\r\n\t\t\r\n\t\t/** Creates a parameter for a parameterized sort abbreviation */\r\n\t\tIParameter createSortParameter(ISymbol symbol);\r\n\t\t\r\n\t\t/** Creates a sort expression, applying a family to a list of sort arguments;\r\n\t\t * the arity of the identifier in the applicable symbol table must match the number of sort arguments\r\n\t\t */\r\n\t\tIApplication createSortExpression(IIdentifier sortFamily, ISort... exprs);\r\n\r\n\t\t/** Creates a sort expression, applying a family to a list of sort arguments;\r\n\t\t * the arity of the identifier in the applicable symbol table must match the number of sort arguments\r\n\t\t */\r\n\t\tIApplication createSortExpression(IIdentifier sortFamily, List\u003cISort\u003e exprs);\r\n\t\t\r\n\t\t/** Creates a new sort abbreviation */\r\n\t\tIAbbreviation createSortAbbreviation(IIdentifier identifier, List\u003cIParameter\u003e params, ISort sortExpr);\r\n\t\t\r\n\t\t/** Creates a function sort */\r\n\t\tIFcnSort createFcnSort(ISort[] args, ISort result);\r\n\t\t\r\n\t\t/** Returns the Bool Sort */\r\n\t\tIApplication Bool();\r\n\t}\r\n}\r\n",
        "name": "ISort.java",
        "path": "smt/lip6.smtlib.SMT/src/org/smtlib/ISort.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.SMT/src/org/smtlib/ISort.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 72,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires sorts.size() == intArity();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 77,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 129,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result.intValue() \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 157,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires i \u003e= 0 \u0026\u0026 i \u003c parameters().size();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 167,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result == definition;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib;\r\n\r\nimport java.util.Map;\r\n\r\nimport org.smtlib.IExpr.IAttribute;\r\nimport org.smtlib.IExpr.IAttributeValue;\r\nimport org.smtlib.IExpr.IKeyword;\r\nimport org.smtlib.IExpr.ISymbol;\r\n\r\n/** This interface represents a definition of an SMT_LIB logic */\r\npublic interface ILogic extends IAccept, ILanguage {\r\n\t/** The name of the logic */\r\n\tISymbol logicName();\r\n\t\r\n\t/** The attributes of the logic */\r\n\t//@ ensures \\result.size() \u003e 0;\r\n\tMap\u003cIKeyword,IAttribute\u003c?\u003e\u003e attributes();\r\n\t\r\n\t/** The value of an attribute; returns null if the attribute does not exist for this logic. */\r\n\t/*@Nullable*/IAttributeValue value(IKeyword keyword);\r\n}\r\n",
        "name": "ILogic.java",
        "path": "smt/lip6.smtlib.SMT/src/org/smtlib/ILogic.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.SMT/src/org/smtlib/ILogic.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result.size() \u003e 0;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib;\r\n\r\nimport org.smtlib.ICommand.Ideclare_fun;\r\nimport org.smtlib.ICommand.Ideclare_sort;\r\nimport org.smtlib.ICommand.Idefine_fun;\r\nimport org.smtlib.ICommand.Idefine_sort;\r\nimport org.smtlib.IExpr.IAttributeValue;\r\nimport org.smtlib.IExpr.IKeyword;\r\n\r\n\r\n/** This is the interface to be implemented by any solver adapter;\r\n * there is an abstract method for each SMT-LIB command */\r\npublic interface ISolver {\r\n\r\n\t/** Returns the configuration object with which the solver is initialized */\r\n\tSMT.Configuration smt();\r\n\t\r\n\t/** Current check-sat status; returns sat, unsat, unknown, error, or null */ // TODO - be more specific\r\n\t/*@Nullable*/ IResponse checkSatStatus();\r\n\t\r\n\t/** Starts the solver; this is not an SMT-LIB command, but it is convenient in some implementations\r\n\t * to separate the starting and initialization from the construction of the solver instance.\r\n\t * @return success or error\r\n\t */\r\n\tIResponse start();\r\n\t\r\n\t/** Terminate the solver; no further commands are permitted.\r\n\t * @return success or error\r\n\t */\r\n\tIResponse exit();\r\n\t\r\n\t/** Sets the logic the solver should use; the position argument is\r\n\t * just used for position information in error messages.\r\n\t * @return success or error\r\n\t */\r\n\tIResponse set_logic(String logicName, /*@Nullable*/ IPos pos);\r\n\t\r\n\t/** Adds the given number of empty stack frames to the solver state.\r\n\t * @param number non-negative number of stack frames to push\r\n\t * @return success or error\r\n\t */\r\n\t//@ requires number \u003e= 0;\r\n\tIResponse push(int number);\r\n\t\r\n\t/** Pops the given number of stack frames from the solver state.\r\n\t * @param number non-negative number of stack frames to pop\r\n\t * @return success or error\r\n\t */\r\n\t//@ requires number \u003e= 0;\r\n\tIResponse pop(int number);\r\n\t\r\n\t/** Asserts the given expression into the solver state (in the top stack frame);\r\n\t * the expression is expected to be already checked that it is a valid, well-formed and well-sorted\r\n\t * expression in the current logic; returns success or error */\r\n\tIResponse assertExpr(IExpr expr); // Not named assert because that is a Java reserved word, though\r\n\t\t\t\t\t\t\t\t\t\t// the SMT-LIB command is 'assert'\r\n\t\r\n\t/** Checks whether the current state is satisfiable in the current logic.\r\n\t * @return sat, unsat, unknown or error\r\n\t */\r\n\tIResponse check_sat();\r\n\t\r\n\t/** Defines a new uninterpreted constant or function; returns success or error*/\r\n\tIResponse declare_fun(Ideclare_fun cmd);\r\n\t\r\n\t/** Declares a new basic sort; returns success or error */\r\n\tIResponse declare_sort(Ideclare_sort cmd);\r\n\r\n\t/** Defines a new constant or function; returns success or error */\r\n\tIResponse define_fun(Idefine_fun cmd);\r\n\t\r\n\t/** Defines a new sort abbreviation; returns success or error */\r\n\tIResponse define_sort(Idefine_sort cmd);\r\n\t\r\n\t/** Sets an SMT-LIB option\r\n\t * @param option the option whose value is to be set\r\n\t * @param value the value to which to set it\r\n\t * @return SUCCESS or an error or unsupported\r\n\t */\r\n\tIResponse set_option(IKeyword option, IAttributeValue value);\r\n\r\n\t/** Sets an SMT-LIB info value\r\n\t * @param key the info item whose value is to be set\r\n\t * @param value the value to which to set it\r\n\t * @return SUCCESS or an error or unsupported\r\n\t */\r\n\tIResponse set_info(IKeyword key, IAttributeValue value);\r\n\t\r\n\t/** Returns a list of all the formulae that have been asserted in the current state.\r\n\t * If the solver prints the list of assertions itself, then this method simply returns success.\r\n\t * May only be used in interactive mode.  If interactive mode is not implemented,\r\n\t * this command may return unsupported.\r\n\t * @return success or a list of formulae (as Strings or terms?) // TODO is this what we want?\r\n\t */\r\n\tIResponse get_assertions();\r\n\t\r\n\t/** Returns a proof that the current state is unsatisfiable. If the solver prints the proof itself,\r\n\t * then it returns simply success. // TODO check is this what we want\r\n\t * May only be issued if the :produce-proofs option is enabled.\r\n\t * Supporting proof production is optional.\r\n\t * @return error or success or unsupported (if proof production is not supported) or a proof\r\n\t */\r\n\tIResponse get_proof();\r\n\t\r\n\t/** Returns a list of the names of formulae in the unsat core of the current (unsatisfiable) state.\r\n\t * May only be issued if :produce-unsat-core is enabled.\r\n\t * @return unsupported or error or a list of names (as ids)\r\n\t */\r\n\tIResponse get_unsat_core();\r\n\t\r\n\t/** Returns a list of values for the given expressions.\r\n\t * May only be used if :produce-models is enabled.\r\n\t * @param terms expressions whose value in the current (Satisfiable) state is to be determined\r\n\t * @return error or list of values (which may include IError instances)\r\n\t */\r\n\tIResponse get_value(IExpr... terms);\r\n\r\n\t/** Retrieves values for all named formulae in the current (satisfiable) state.\r\n\t * May only be used if :produce-assignments is enabled.\r\n\t * @return error or a list of name-value pairs\r\n\t */\r\n\tIResponse get_assignment();\r\n\r\n\t/** Gets the value of an SMT-LIB option\r\n\t * \r\n\t * @param option the option whose value is desired\r\n\t * @return TODO\r\n\t */\r\n\tIResponse get_option(IKeyword option);\r\n\r\n\t/** Gets the value of an SMT-LIB information topic\r\n\t * \r\n\t * @param option the info option whose value is desired\r\n\t * @return TODO\r\n\t */\r\n\tIResponse get_info(IKeyword option);\r\n\r\n\tIResponse get_model();\r\n\t\r\n\tdefault IResponse maximize(IExpr expr) { return smt().responseFactory.error(\"Maximize : Unimplemented for this solver.\"); }\r\n\tdefault IResponse minimize(IExpr expr) { return smt().responseFactory.error(\"Minimize : Unimplemented for this solver.\"); }\r\n\t\r\n}\r\n",
        "name": "ISolver.java",
        "path": "smt/lip6.smtlib.SMT/src/org/smtlib/ISolver.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.SMT/src/org/smtlib/ISolver.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 46,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires number \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 53,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires number \u003e= 0;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "package org.smtlib;\r\n\r\n/** This interface represents sources of characters.  The source need not be fully available at\r\n * any given time, but it does need to be able to supply characters at a given position on demand\r\n * and to determine line numbers from the beginning of the source.\r\n */\r\npublic interface ISource {\r\n\t// NOTE - the methods are not necessarily pure, since the internals may change.  However, the\r\n\t// implicit character content should not change.\r\n\t\r\n\t/** The internal character stream as a CharSequence.  We would like to avoid the constraint of\r\n\t * having to have this kind of internal representation, but the parser uses Pattern and Matcher,\r\n\t * which require a CharSequence.  The CharSequence might not contain all the characters that might\r\n\t * ever be read, but will contain characters as they are read.\r\n\t */\r\n\tCharSequence chars();\r\n\t\r\n\t/** Closes any open resources - the source is not usable after this call. */\r\n\tvoid close();\r\n\t\r\n\t/** User-specified identification of the location of the source; the user is responsible to use\r\n\t * the result in the way in which the source object was created.\r\n\t * @return the location object of the source\r\n\t */\r\n\t/*@Nullable*/ Object location();\r\n\t\r\n\t/** Returns the character at the given character position within the source. Character positions \r\n\t * begin at 0.*/\r\n\t//@ requires pos \u003e= 0;\r\n\tchar charAt(int pos);\r\n\t\r\n\t/** Returns the character position of the beginning of the line containing the given position. \r\n\t * Character positions begin at 0.*/\r\n\t//@ requires pos \u003e= 0;\r\n\t//@ ensures 0 \u003c= \\result \u0026\u0026 \\result \u003c= pos;\r\n\tint lineBeginning(int pos);\r\n\t\r\n\t/** Returns the text of the line containing the given position, at least through the given position,\r\n\t * and always ending with a (perhaps added) line termination sequence. Character positions begin at 0.\r\n\t * @param pos a character position\r\n\t * @return the line of text containing that character position\r\n\t */\r\n\t//@ requires pos \u003e= 0;\r\n\tString textLine(int pos);\r\n\t\r\n\t/** Returns the number (beginning with 1) of the line containing the given character position (which begins at 0). */\r\n\t//@ requires pos \u003e= 0;\r\n\t//@ ensures \\result \u003e 0;\r\n\tint lineNumber(int pos);\r\n}",
        "name": "ISource.java",
        "path": "smt/lip6.smtlib.SMT/src/org/smtlib/ISource.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.SMT/src/org/smtlib/ISource.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires pos \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 33,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires pos \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 34,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures 0 \u003c= \\result \u0026\u0026 \\result \u003c= pos;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 42,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires pos \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 46,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires pos \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 47,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result \u003e 0;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib;\r\n\r\nimport java.util.Map;\r\n\r\nimport org.smtlib.IExpr.IAttributeValue;\r\nimport org.smtlib.IExpr.ISymbol;\r\nimport org.smtlib.IExpr.IKeyword;\r\n\r\n/** This interface represents a definition of an SMT-LIB theory */\r\npublic interface ITheory extends IAccept {\r\n\t/** The name of the theory */\r\n\tISymbol theoryName();\r\n\t\r\n\t/** The attributes (keyword-value pairs) of the theory. */\r\n\t//@ ensures \\result.size() \u003e 0;\r\n\tMap\u003cIKeyword,IExpr.IAttribute\u003c?\u003e\u003e attributes();\r\n\t\r\n\t/** The value of an attribute; returns null if the attribute does not exist for this theory */\r\n\t/*@Nullable*/IAttributeValue value(IKeyword keyword);\r\n\t\r\n\t// TODO - do we export the pre-defined symbols?\r\n}\r\n",
        "name": "ITheory.java",
        "path": "smt/lip6.smtlib.SMT/src/org/smtlib/ITheory.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.SMT/src/org/smtlib/ITheory.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 19,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result.size() \u003e 0;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib;\r\n\r\nimport java.util.List;\r\n\r\nimport org.smtlib.IExpr.IAttributeValue;\r\nimport org.smtlib.IExpr.IDeclaration;\r\nimport org.smtlib.IExpr.IIdentifier;\r\nimport org.smtlib.IExpr.IKeyword;\r\nimport org.smtlib.IExpr.INumeral;\r\nimport org.smtlib.IExpr.IStringLiteral;\r\nimport org.smtlib.IExpr.ISymbol;\r\nimport org.smtlib.ISort.IParameter;\r\n\r\n\r\n/** This interface is the generic interface to command classes, providing functionality\r\n * to type-check the command and to execute it.\r\n * @author David R. Cok\r\n */\r\npublic interface ICommand extends IAccept {\r\n\t\r\n\t/** This interface defines classes that implement techniques for mapping a command name to a class\r\n\t * that implements that command.\r\n\t */\r\n\tpublic static interface IFinder {\r\n\t\t/** This method finds a class that implements the ICommand interface for the given class name */\r\n\t\tClass\u003c? extends ICommand\u003e findCommand(String name);\r\n\t}\r\n\t\r\n\t/** Executes the command on the given solver; presumes that the command type-checked\r\n\t * successfully.\r\n\t * @param solver the instance of the solver to use (note that solvers have state)\r\n\t * @return the result of the command\r\n\t */\r\n\tIResponse execute(ISolver solver);\r\n\t\r\n\t/** This is the interface to be used by a concrete ICommand factory. */\r\n\tstatic public interface IFactory {\r\n\t\t/** Creates a script object containing the given filename or the given set of commands */\r\n\t\tIScript script(/*@Nullable*/IStringLiteral filename, /*@Nullable*/List\u003cICommand\u003e commands);\r\n\t\t\r\n\t\t/** Creates an assert command object, asserting the given expression */\r\n\t\tIassert assertCommand(IExpr expr);\r\n\t\t\r\n\t\t/** Creates a check-sat command object */\r\n\t\tIcheck_sat check_sat();\r\n\t\t\r\n\t\t/** Creates a declare-fun command object */\r\n\t\tIdeclare_fun declare_fun(IIdentifier id, List\u003cISort\u003e argSorts, ISort resultSort);\r\n\t\t\r\n\t\t/** Creates a declare-sort command object. */\r\n\t\tIdeclare_sort declare_sort(ISymbol sym, INumeral arity);\r\n\t\t\r\n\t\t/** Creates a define-fun command object */\r\n\t\tIdefine_fun define_fun(IIdentifier id, List\u003cIDeclaration\u003e declarations, ISort resultSort, IExpr expression);\r\n\t\t\r\n\t\t/** Creates a define-sort command object. */\r\n\t\tIdefine_sort define_sort(IIdentifier id, List\u003cIParameter\u003e parameters, ISort.IApplication expression);\r\n\t\t\r\n\t\t/** Creates an exit command object. */\r\n\t\tIexit exit();\r\n\t\t\r\n\t\t/** Creates a get-assertions command object. */\r\n\t\tIget_assertions get_assertions();\r\n\t\t\r\n\t\t/** Creates a get-assignment command object. */\r\n\t\tIget_assignment get_assignment();\r\n\t\t\r\n\t\t/** Creates a get-info command object. */\r\n\t\tIget_info get_info(IKeyword infoflag);\r\n\t\t\r\n\t\t/** Creates a get-option command object */\r\n\t\tIget_option get_option(IKeyword option);\r\n\t\t\r\n\t\t/** Creates a get-proof command object. */\r\n\t\tIget_proof get_proof();\r\n\t\t\r\n\t\t/** Creates a get-unsat-core command object. */\r\n\t\tIget_unsat_core get_unsat_core();\r\n\t\t\r\n\t\t/** Creates a get-value command object. */\r\n\t\tIget_value get_value(List\u003cIExpr\u003e exprs);\r\n\t\t\r\n\t\t/** Creates a push command object. */\r\n\t\tIpush push(INumeral number);\r\n\t\t\r\n\t\t/** Creates a pop command object. */\r\n\t\tIpop pop(INumeral number);\r\n\t\t\r\n\t\t/** Creates a set-logic command object */\r\n\t\tIset_logic set_logic(ISymbol logic);\r\n\t\t\r\n\t\t/** Creates a set-info command object. */\r\n\t\tIset_info set_info(IKeyword infoflag, IAttributeValue value);\r\n\t\t\r\n\t\t/** Creates a set-option command object. */\r\n\t\tIset_option set_option(IKeyword option, IAttributeValue value);\r\n\t}\r\n\t\r\n\t/** Interface to be implemented by all objects representing SMT-LIB scripts. A script may consist of a file or an explicit list of commands. */\r\n\t\r\n\tstatic public interface IScript extends IAccept {\r\n\t\t/*@Nullable*/ IStringLiteral filename();\r\n\t\t/*@Nullable*/ List\u003cICommand\u003e commands();\r\n\t\tIResponse execute(ISolver solver);\r\n\t}\r\n\t\r\n\t/** Interface to be implemented by all objects representing SMT-LIB assert commands. */\r\n\tstatic public interface Iassert extends ICommand {\r\n\t\tIExpr expr();\r\n\t}\r\n\t\r\n\t/** Interface to be implemented by all objects representing SMT-LIB check-sat commands. */\r\n\tstatic public interface Icheck_sat extends ICommand {\r\n\t}\r\n\t\r\n\t/** Interface to be implemented by all objects representing SMT-LIB declare-fun commands. */\r\n\tstatic public interface Ideclare_fun extends ICommand {\r\n\t\tISymbol symbol();\r\n\t\tList\u003cISort\u003e argSorts();\r\n\t\tISort resultSort();\r\n\t}\r\n\t\r\n\t/** Interface to be implemented by all objects representing SMT-LIB declare-sort commands. */\r\n\tstatic public interface Ideclare_sort extends ICommand {\r\n\t\tISymbol sortSymbol();\r\n\t\tINumeral arity();\r\n\t}\r\n\t\r\n\t/** Interface to be implemented by all objects representing SMT-LIB define-fun commands. */\r\n\tstatic public interface Idefine_fun extends ICommand {\r\n\t\tISymbol symbol();\r\n\t\tList\u003cIDeclaration\u003e parameters();\r\n\t\tISort resultSort();\r\n\t\tIExpr expression();\r\n\t}\r\n\t\r\n\t/** Interface to be implemented by all objects representing SMT-LIB define-sort commands. */\r\n\tstatic public interface Idefine_sort extends ICommand {\r\n\t\tISymbol sortSymbol();\r\n\t\tList\u003cIParameter\u003e parameters();\r\n\t\tISort expression();\r\n\t}\r\n\t\r\n\t/** Interface to be implemented by all objects representing SMT-LIB exit commands. */\r\n\tstatic public interface Iexit extends ICommand {\r\n\t}\r\n\t\r\n\t/** Interface to be implemented by all objects representing SMT-LIB get-assertions commands. */\r\n\tstatic public interface Iget_assertions extends ICommand {\r\n\t}\r\n\t\r\n\t/** Interface to be implemented by all objects representing SMT-LIB get-assignment commands. */\r\n\tstatic public interface Iget_assignment extends ICommand {\r\n\t}\r\n\t\r\n\t/** Interface to be implemented by all objects representing SMT-LIB get-info commands. */\r\n\tstatic public interface Iget_info extends ICommand {\r\n\t\tIKeyword infoflag();\r\n\t}\r\n\t\r\n\t/** Interface to be implemented by all objects representing SMT-LIB get-option commands. */\r\n\tstatic public interface Iget_option extends ICommand {\r\n\t\tIKeyword option();\r\n\t}\r\n\t\r\n\t/** Interface to be implemented by all objects representing SMT-LIB get-proof commands. */\r\n\tstatic public interface Iget_proof extends ICommand {\r\n\t}\r\n\t\r\n\t/** Interface to be implemented by all objects representing SMT-LIB get-unsat-core commands. */\r\n\tstatic public interface Iget_unsat_core extends ICommand {\r\n\t}\r\n\r\n\t/** Interface to be implemented by all objects representing SMT-LIB get-value commands. */\r\n\tstatic public interface Iget_value extends ICommand {\r\n\t\t//@ ensures exprs().size \u003e 0;\r\n\t\tList\u003cIExpr\u003e exprs();\r\n\t}\r\n\t\r\n\t/** Interface to be implemented by all objects representing SMT-LIB pop commands. */\r\n\tstatic public interface Ipop extends ICommand {\r\n\t\t//@ ensures \\result.intValue() \u003e= 0;\r\n\t\tINumeral number();\r\n\t}\r\n\t\r\n\t/** Interface to be implemented by all objects representing SMT-LIB push commands. */\r\n\tstatic public interface Ipush extends ICommand {\r\n\t\t//@ ensures \\result.intValue() \u003e= 0;\r\n\t\tINumeral number();\r\n\t}\r\n\t\r\n\t/** Interface to be implemented by all objects representing SMT-LIB set-logic commands. */\r\n\tstatic public interface Iset_logic extends ICommand {\r\n\t\tISymbol logic();\r\n\t}\r\n\t\r\n\t/** Interface to be implemented by all objects representing SMT-LIB set-info commands. */\r\n\tstatic public interface Iset_info extends ICommand {\r\n\t\tIKeyword infoflag();\r\n\t\tIAttributeValue value();\r\n\t}\r\n\t\r\n\t/** Interface to be implemented by all objects representing SMT-LIB set-option commands. */\r\n\tstatic public interface Iset_option extends ICommand {\r\n\t\tIKeyword option();\r\n\t\t/*@Nullable*/IAttributeValue value();\r\n\t}\r\n}\r\n",
        "name": "ICommand.java",
        "path": "smt/lip6.smtlib.SMT/src/org/smtlib/ICommand.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.SMT/src/org/smtlib/ICommand.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 180,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures exprs().size \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 186,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result.intValue() \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 192,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result.intValue() \u003e= 0;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.impl;\r\n\r\nimport java.io.*;\r\n\r\nimport org.smtlib.*;\r\n\r\n/** Represents a range of characters in a source - used to indicate the location of errors */\r\npublic class Pos implements IPos {\r\n\r\n\t/** The starting character, beginning from 0 */\r\n\tint charStart;\r\n\t/** One past the last character of the range, beginning from 0 */\r\n\tint charEnd;\r\n\t\r\n\t/** The source of text */\r\n\t/*@Nullable*/ISource source;\r\n\t\r\n\t/** Constructor for a Pos object\r\n\t * @param cs the start position of the character range, 0-based\r\n\t * @param ce one past the end position of the character range, 0- based\r\n\t * @param s the source of text to which the character positions refer\r\n\t */\r\n\tpublic Pos(int cs, int ce, /*@Nullable*/ISource s) {\r\n\t\tthis.charStart = cs;\r\n\t\tthis.charEnd = ce;\r\n\t\tthis.source = s;\r\n\t}\r\n\t\r\n\t/** The starting character, beginning from 0 */\r\n\t@Override\r\n\tpublic int charStart() { return charStart; }\r\n\t/** One past the last character of the range, beginning from 0 */\r\n\t@Override\r\n\tpublic int charEnd() { return charEnd; }\r\n\t/** The source of text */\r\n\t@Override\r\n\tpublic /*@Nullable*/ISource source() { return source; }\r\n\r\n\t/** An implementation of IPosable, holding an instance of Pos,\r\n\t *  that can be used as a base class if necessary */\r\n\tpublic static class Posable implements IPosable {\r\n\t\tprotected /*@Nullable*/ IPos pos;\r\n\t\t@Override\r\n\t\tpublic IPos pos() { return pos; }\r\n\t\t@Override\r\n\t\tpublic void setPos(IPos pos) { this.pos = pos; }\r\n\t}\r\n\t\r\n\t/** An implementation of the ISource interface */\r\n\tpublic static class Source implements ISource {\r\n\t\tprivate Reader rdr = null;\r\n\t\t\r\n\t\t/** The sequence of characters */\r\n\t\tprivate CharSequence chars;\r\n\t\t/** The sequence of characters */\r\n\t\t@Override\r\n\t\tpublic CharSequence chars() { return chars; }\r\n\t\t\r\n\t\t/** The identifier for the location */\r\n\t\tprivate /*@Nullable*/ Object location;\r\n\t\t/** The identifier for the location */\r\n\t\t@Override\r\n\t\tpublic /*@Nullable*/ Object location() { return location; }\r\n\r\n\t\t/** Creates a Source from a character sequence\r\n\t\t * @param cs the sequence to use as a source of characters\r\n\t\t * @param location a designator of the location of the source, used for identification only\r\n\t\t */\r\n\t\tpublic Source(CharSequence cs, /*@Nullable*/ Object location) {\r\n\t\t\tthis.chars = cs;\r\n\t\t\tthis.location = location;\r\n\t\t}\r\n\r\n\t\t/** Creates a Source from a File; for these objects, the location is the file path (a String)\r\n\t\t * @param smtConfig the SMT Configuration object\r\n\t\t * @param f the File object from which to read characters\r\n\t\t * @throws java.io.FileNotFoundException if a problem occurred opening or reading the file\r\n\t\t */\r\n\t\tpublic Source(SMT.Configuration smtConfig, java.io.File f) throws java.io.FileNotFoundException {\r\n\t\t\trdr = new FileReader(f);\r\n\t\t\t// The numbers in the next call are not magic - they just double the buffer by a factor of 2 if it is not large enough\r\n\t\t\tCharSequenceReader csr = new CharSequenceReader(rdr,smtConfig.initialInputBufferSize,0,2);\r\n\t\t\tcsr.prompter = new SMT.Prompter(smtConfig);\r\n\t\t\tchars = csr;\r\n\t\t\tthis.location = f.getPath();\r\n\t\t}\r\n\t\t\r\n\t\t/** Creates a Source from a File\r\n\t\t * @param smtConfig the SMT Configuration object\r\n\t\t * @param f the InputStream object from which to read characters\r\n\t\t * @param location object describing the location of the source\r\n\t\t */\r\n\t\tpublic Source(SMT.Configuration smtConfig, InputStream f, Object location) {\r\n\t\t\trdr = new InputStreamReader(f);\r\n\t\t\t// The numbers in the next call are not magic - they just double the buffer by a factor of 2 if it is not large enough\r\n\t\t\tCharSequenceReader csr = new CharSequenceReader(rdr,smtConfig.initialInputBufferSize,0,2);\r\n\t\t\tcsr.prompter = new SMT.Prompter(smtConfig);\r\n\t\t\tchars = csr;\r\n\t\t\tthis.location = location;\r\n\t\t}\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic void close() {\r\n\t\t\ttry {\r\n\t\t\t\trdr.close();\r\n\t\t\t} catch (IOException e) {}\r\n\t\t}\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic char charAt(int pos) {\r\n\t\t\treturn this.chars.charAt(pos);\r\n\t\t}\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic int lineBeginning(int pos) {\r\n\t\t\tint p = pos;\r\n\t\t\tif (p \u003e= chars().length()) p = chars().length()-1; // If the length is indeterminate, length() should be INT_MAX\r\n\t\t\tif (p \u003e 0 \u0026\u0026 charAt(p) == '\\n' \u0026\u0026 charAt(p-1) == '\\r') --p;\r\n\t\t\tchar c;\r\n\t\t\twhile (p \u003e= 0 \u0026\u0026 (c=charAt(p)) != '\\n' \u0026\u0026 c != '\\r') --p;\r\n\t\t\treturn p+1;\r\n\t\t}\r\n\t\t\r\n\t\tprivate final static String eol = System.getProperty(\"line.separator\");\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic String textLine(int pos) {\r\n\t\t\tint b = lineBeginning(pos);\r\n\t\t\tint e = nextLineTermination(pos);\r\n\t\t\tString s = chars.subSequence(b,e+1).toString();\r\n\t\t\tchar c = s.length() == 0 ? ' ' : s.charAt(s.length()-1);\r\n\t\t\tif (c != '\\n' \u0026\u0026 c != '\\r') s = s + eol;\r\n\t\t\treturn s;\r\n\t\t}\r\n\r\n\t\t/** The (last character of) the next line termination sequence after the given character position */\r\n\t\t//@ requires pos \u003e= 0;\r\n\t\t//@ ensures \\result \u003e= pos;\r\n\t\tprotected int nextLineTermination(int pos) {\r\n\t\t\tchar c;\r\n\t\t\tif (pos \u003e= chars().length()) return chars().length()-1; // If the length is indeterminate, length() should be INT_MAX\r\n\t\t\twhile ((c=charAt(pos)) != '\\n' \u0026\u0026 c != '\\r' \u0026\u0026 c != CharSequenceInfinite.endChar) ++pos;\r\n\t\t\tif (c == '\\r' \u0026\u0026 charAt(pos+1) == '\\n') ++pos;\r\n\t\t\telse if (c == CharSequenceInfinite.endChar) --pos;\r\n\t\t\treturn pos;\r\n\t\t}\r\n\t\t\r\n\t\t// Note: this counts lines from the beginning of the character sequence, calling charAt at each\r\n\t\t// character position; this is not very efficient; the presumption is that this method is called\r\n\t\t// just for the occasional error message.\r\n\t\t@Override\r\n\t\tpublic int lineNumber(int pos) {\r\n\t\t\tint line = 1;\r\n\t\t\tchar c;\r\n\t\t\tfor (int i=0; i\u003cpos; i++) {\r\n\t\t\t\tc = charAt(i);\r\n\t\t\t\tif (c == '\\n') line++;\r\n\t\t\t\telse if (c == '\\r') {\r\n\t\t\t\t\tline++;\r\n\t\t\t\t\tif (charAt(i+1) == '\\n') i++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn line;\r\n\t\t}\r\n\t}\r\n}\r\n",
        "name": "Pos.java",
        "path": "smt/lip6.smtlib.SMT/src/org/smtlib/impl/Pos.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.SMT/src/org/smtlib/impl/Pos.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 141,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires pos \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 142,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result \u003e= pos;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib;\r\n\r\nimport java.util.List;\r\n\r\nimport org.smtlib.IExpr.IAttribute;\r\nimport org.smtlib.IExpr.IAttributeValue;\r\nimport org.smtlib.IExpr.ISymbol;\r\nimport org.smtlib.IPos.IPosable;\r\nimport org.smtlib.sexpr.ISexpr.ISeq;\r\n\r\n/** This interface represents responses that can be received from SMT-LIB commands. */\r\npublic interface IResponse extends IAccept {\r\n\t\r\n\t/** Returns true if the response is a SUCCESS response */\r\n\tboolean isOK();\r\n\t\r\n\t/** Returns true if the response is an error response */\r\n\t//@ ensures \\result \u003c==\u003e (this instanceof IResponse.IError);\r\n\tboolean isError();\r\n\t\r\n\t/** The interface for error responses */\r\n\tpublic static interface IError extends IResponse, IPosable {\r\n\t\t/** Returns the error message held by this response */\r\n\t\tString errorMsg();\r\n\t\t\r\n\t\t/** Returns the textual location for the response, if available and applicable, otherwise null. */\r\n\t\t/*@Nullable*/ IPos pos();\r\n\t}\r\n\t\r\n\t/** An interface for simple pairs of objects */\r\n\tpublic static interface IPair\u003cT1,T2\u003e {\r\n\t\tT1 first();\r\n\t\tT2 second();\r\n\t}\r\n\r\n\t\r\n\t/** The interface representing the factory for IResponse instances */ // TODO _ more restrictive return types?\r\n\tpublic static interface IFactory {\r\n\t\tIError error(String msg);\r\n\t\tIError error(String msg, /*@Nullable*//*@ReadOnly*/ IPos pos);\r\n\t\tIResponse empty();\r\n\t\tIResponse success();\r\n\t\tIResponse unsupported();\r\n\t\tIResponse unknown();\r\n\t\tIResponse sat();\r\n\t\tIResponse unsat();\r\n\t\tIResponse immediate_exit();\r\n\t\tIResponse continued_execution();\r\n\t\tIResponse memout();\r\n\t\tIResponse incomplete();\r\n\t\t/** Returns a constant response with the given canonical name */\r\n\t\tIResponse constant(String id); // FIXME - use abstract keyword?\r\n\t\t/** The argument has no SMT-LIB escapes and no enclosing quotes */\r\n\t\tIResponse stringLiteral(String value);\r\n\t\tIResponse numericLiteral(int value);\r\n\t\tIResponse get_option_response(IAttributeValue v);\r\n\t\tIResponse.IAttributeList get_info_response(IAttribute\u003c?\u003e attr);\r\n\t\tIResponse.IAttributeList get_info_response(List\u003cIAttribute\u003c?\u003e\u003e attrList);\r\n\t\tIResponse.IProofResponse get_proof_response();\r\n\t\tIResponse.IValueResponse get_value_response(List\u003cIPair\u003cIExpr,IExpr\u003e\u003e values);\r\n\t\t\u003cT1,T2\u003e IPair\u003cT1,T2\u003e pair(T1 first, T2 second);\r\n\t\tIResponse.IAssignmentResponse get_assignment_response(List\u003cIPair\u003cIExpr.ISymbol,Boolean\u003e\u003e assignments);\r\n\t\tIResponse.IUnsatCoreResponse get_unsat_core_response(List\u003cISymbol\u003e names);\r\n\t\tIResponse.IAssertionsResponse get_assertions_response(List\u003cIExpr\u003e exprs);\r\n\t}\r\n\t\r\n\tstatic public interface IAttributeList extends IResponse {\r\n\t\tpublic List\u003cIAttribute\u003c? extends IAttributeValue\u003e\u003e attributes();\r\n\t}\r\n\r\n\tstatic public interface IAssignmentResponse extends IResponse {\r\n\t\tpublic List\u003cIPair\u003cIExpr.ISymbol,Boolean\u003e\u003e assignments();\r\n\t}\r\n\r\n\tstatic public interface IValueResponse extends IResponse {\r\n\t\tpublic List\u003cIPair\u003cIExpr,IExpr\u003e\u003e values();\r\n\t}\r\n\r\n\tstatic public interface IUnsatCoreResponse extends IResponse {\r\n\t\tpublic List\u003cIExpr.ISymbol\u003e names();\r\n\t}\r\n\r\n\tstatic public interface IAssertionsResponse extends IResponse {\r\n\t\tpublic List\u003cIExpr\u003e assertions();\r\n\t}\r\n\r\n\tstatic public interface IProofResponse extends IResponse {\r\n\t\tpublic Object proof();\r\n\t}\r\n}\r\n",
        "name": "IResponse.java",
        "path": "smt/lip6.smtlib.SMT/src/org/smtlib/IResponse.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.SMT/src/org/smtlib/IResponse.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 22,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result \u003c==\u003e (this instanceof IResponse.IError);\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "package org.smtlib.impl;\r\n\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\nimport java.util.Iterator;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.logging.Logger;\r\n\r\nimport org.smtlib.*;\r\nimport org.smtlib.ICommand.IScript;\r\nimport org.smtlib.IExpr.IStringLiteral;\r\nimport org.smtlib.IParser.ParserException;\r\n\r\n/** This class implements the IScript interface, representing SMT-LIB command scripts */\r\npublic class Script implements IScript {\r\n\t// This class can hold either a filename from which to read commands\r\n\t// or a sequence of commands held directly; it should not have both\r\n\t\r\n\t//@ invariant (filename() == null) != (commands() != null);\r\n\t\r\n\t/** The filename of the script file */\r\n\t//@ spec_public\r\n\tprotected /*@Nullable*/ IStringLiteral filename;\r\n\t\r\n\t/** The filename of the script file */\r\n\t//@ ensures \\result == filename;\r\n\t@Override\r\n\tpublic /*@Nullable*/IStringLiteral filename() {\r\n\t\treturn filename;\r\n\t}\r\n\t\r\n\t/** The list of commands */\r\n\t//@ spec_public\r\n\tprotected /*@Nullable*/List\u003cICommand\u003e commands;\r\n\t\r\n\t/** Returns a reference to the internal list */\r\n\t//@ ensures \\result == commands;\r\n\t@Override\r\n\tpublic /*@Nullable*/List\u003cICommand\u003e commands() {\r\n\t\treturn commands;\r\n\t}\r\n\r\n\t/** Constructs a script with no commands */\r\n\tpublic Script() {\r\n\t\tfilename = null;\r\n\t\tcommands = new LinkedList\u003cICommand\u003e();\r\n\t}\r\n\t\r\n\t/** Constructs the script with the given list of commands, hijacking the list itself */\r\n\t//@ requires (filename != null) != (list != null);\r\n\tpublic Script(/*@Nullable*/IStringLiteral filename, /*@Nullable*/List\u003cICommand\u003e list) {\r\n\t\tthis.filename = filename;\r\n\t\tthis.commands = list;\r\n\t}\r\n\t\r\n\t/** Adds a command to the end of the script */\r\n\t//@ requires commands() != null;\r\n\tpublic void add(ICommand command) {\r\n\t\tif (commands == null) commands = new LinkedList\u003cICommand\u003e();  // FIXME - test without this line\r\n\t\tcommands.add(command);\r\n\t}\r\n\t\r\n\tpublic String kind() { return \"script\"; }  // FIXME - should override?\r\n\r\n\t/** Executes the current list */\r\n\t// FIXME _ should we have an incremental read and execute option?\r\n\t@Override\r\n\tpublic IResponse execute(ISolver solver) {\r\n\t\tSMT.Configuration smtConfig = solver.smt();\r\n\t\t/*@Mutable*/FileReader fileReader = null;\r\n\t\tList\u003cICommand\u003e commands = this.commands;\r\n\t\tif (filename != null) {\r\n\t\t\tString filename = this.filename.value();\r\n\t\t\ttry {\r\n\t\t\t\tfileReader = new FileReader(new File(filename));\r\n\t\t\t\tISource source = smtConfig.smtFactory.createSource(new CharSequenceReader(fileReader),filename);\r\n\t\t\t\tIParser p = smtConfig.smtFactory.createParser(smtConfig,source);\r\n\t\t\t\tIScript script = p.parseScript();\r\n\t\t\t\tif (script == null) return smtConfig.responseFactory.error(\"Failed to parse the command script: \" + filename,this.filename.pos());\r\n\t\t\t\tcommands = script.commands();\r\n\t\t\t} catch (FileNotFoundException e) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(e.toString(),this.filename.pos());\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(e.toString(),this.filename.pos());\r\n\t\t\t} catch (ParserException e) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(e.toString(),e.pos());\r\n\t\t\t} finally {\r\n\t\t\t\tif (fileReader != null) {\r\n\t\t\t\t\ttry { \r\n\t\t\t\t\t\tfileReader.close(); \r\n\t\t\t\t\t} catch (IOException e) { \r\n\t\t\t\t\t\treturn smtConfig.responseFactory.error(\"Failed to close input file: \" + e,this.filename.pos());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (commands == null) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"INTERNAL ERROR: Unexpected null command list in a script\");\r\n\t\t}\r\n\t\tIterator\u003cICommand\u003e iter = commands.iterator();\r\n\t\tIResponse response = smtConfig.responseFactory.success();\r\n\t\tICommand s;\r\n\t\twhile (iter.hasNext() \u0026\u0026 !response.isError()) {\r\n\t\t\ts = iter.next();\r\n\t\t\t// TODO: should we typecheck the entire script before executing it?\r\n\t\t\tresponse = s.execute(solver);\r\n\t\t\t// TODO: If we include this output, we need a way to control it via the API so OpenJML can control it\r\n\t\t\tif (! response.isOK()) {\r\n\t\t\t\tLogger.getLogger(\"org.jsmtlib\").warning(\"Script execution failed on command \"+ s.toString() + \" with error \"+ response.toString());\r\n\t\t\t}\r\n\t\t\t//if (!r.isOK()) smtConfig.log.logDiag(smtConfig.defaultPrinter.toString(r));\r\n\t\t}\r\n\t\treturn response;\r\n\t}\r\n\t\r\n\t/** The accept method for visitor classes; the type parameter is the return type of the accept and visit methods */\r\n\t@Override\r\n\tpublic \u003c/*@Nullable*/T\u003e /*@Nullable*/T accept(IVisitor\u003c/*@Nullable*/T\u003e v) throws IVisitor.VisitorException {\r\n\t\treturn v.visit(this);\r\n\t}\r\n}",
        "name": "Script.java",
        "path": "smt/lip6.smtlib.SMT/src/org/smtlib/impl/Script.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.SMT/src/org/smtlib/impl/Script.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result == filename;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 39,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result == commands;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 52,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires (filename != null) != (list != null);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 59,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires commands() != null;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.sexpr;\r\n\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Method;\r\nimport java.util.*;\r\nimport java.util.regex.Matcher;\r\n\r\nimport org.smtlib.*;\r\nimport org.smtlib.ICommand.IScript;\r\nimport org.smtlib.IExpr.IAsIdentifier;\r\nimport org.smtlib.IExpr.IAttribute;\r\nimport org.smtlib.IExpr.IAttributeValue;\r\nimport org.smtlib.IExpr.IBinaryLiteral;\r\nimport org.smtlib.IExpr.IBinding;\r\nimport org.smtlib.IExpr.IDecimal;\r\nimport org.smtlib.IExpr.IDeclaration;\r\nimport org.smtlib.IExpr.IHexLiteral;\r\nimport org.smtlib.IExpr.IIdentifier;\r\nimport org.smtlib.IExpr.IKeyword;\r\nimport org.smtlib.IExpr.ILiteral;\r\nimport org.smtlib.IExpr.INumeral;\r\nimport org.smtlib.IExpr.IQualifiedIdentifier;\r\nimport org.smtlib.IExpr.IStringLiteral;\r\nimport org.smtlib.IExpr.ISymbol;\r\nimport org.smtlib.impl.*;\r\nimport org.smtlib.impl.SMTExpr.Keyword;\r\nimport org.smtlib.impl.SMTExpr.Numeral;\r\nimport org.smtlib.impl.SMTExpr.StringLiteral;\r\nimport org.smtlib.impl.SMTExpr.Symbol;\r\n\r\n//import checkers.nullness.quals.Nullable;\r\n/** Parses the standard SMT-LIB concrete syntax to produce ASTs of objects that\r\n * are instances of the org.smtlib.* interfaces.\r\n */\r\npublic class Parser extends Lexer implements IParser {\r\n\t/** A handle to the parent SMTConfig object, in order to see command-line options\r\n\t * etc. that are fields of smtConfig */\r\n\tfinal private SMT.Configuration smtConfig;\r\n\t\r\n\t/** Returns a handle to the parent SMTConfig object, in order to see command-line options\r\n\t * etc. that are fields of smtConfig */\r\n\tpublic SMT.Configuration smt() { return smtConfig; }\r\n\t\r\n\t/** The most recent error, or null */\r\n\tpublic /*@ Nullable */ IResponse.IError lastError = null;\r\n\t\r\n\tpublic /*@ Nullable */ IResponse.IError lastError() { return lastError; }\r\n\t\r\n\t/** The (common) factory used to generate objects */\r\n\tfinal protected IExpr.IFactory factory;\r\n\t\r\n\t/** Returns an IPos object for the given character start and end \r\n\t * positions and including a reference to the parser's source object. \r\n\t * @param start the start character position (counting from 0)\r\n\t * @param end the end character position (one past the last actual character to be included)\r\n\t * @return the IPos object representing the character range within the parser's current source\r\n\t */\r\n\tpublic /*@Nullable*//*@ReadOnly*/ IPos pos(/*@Nullable*//*@ReadOnly*/IPos start, /*@Nullable*//*@ReadOnly*/IPos end) { \r\n\t\tif (start == null || end == null) return null;\r\n\t\treturn pos(start.charStart(),end.charEnd()); \r\n\t}\r\n\t\r\n\t/** Returns an IPos object for the given character start and end \r\n\t * positions and including a reference to the parser's source object. \r\n\t * @param start the start character position (counting from 0)\r\n\t * @param end the end character position (one past the last actual character to be included)\r\n\t * @return the IPos object representing the character range within the parser's current source\r\n\t */\r\n\tpublic /*@Nullable*/ IPos pos(int start, int end) { \r\n\t\treturn new Pos(start,end,source()); \r\n\t} // Use factory instead of new Pos?\r\n\t\r\n\t/** Creates a Parser using an SMT configuration object and a source for\r\n\t * characters; ordinarily use a factory to obtain a parser.\r\n\t */\r\n\tpublic Parser(SMT.Configuration smtConfig, ISource src) {\r\n\t\tsuper(smtConfig, src);\r\n\t\tthis.smtConfig = smtConfig;\r\n\t\tthis.factory = smtConfig.exprFactory;\r\n\t}\r\n\t\t\r\n\r\n\t// See the documentation in the interface\r\n\t@Override\r\n\tpublic /*@Nullable*/ICommand.IScript parseScript() {\r\n\t\t// NOTE: interactive is set false here because it is only ever used for parsing exec scripts\r\n\t\t// if it is used to parse top-level scripts, we have to pass in the appropriate value\r\n\t\tboolean interactive = smtConfig.interactive;\r\n\t\tIScript scr;\r\n\t\ttry {\r\n\t\t\tStringLiteral filename;\r\n\t\t\tif (!isLP()) {\r\n\t\t\t\tfilename = parseStringLiteral();\r\n\t\t\t\tif (filename == null) return null;\r\n\t\t\t\t//scr = smtConfig.commandFactory.script(filename,null);\r\n\t\t\t\tscr = new Script(filename,null); // FIXME - use a factory, set position\r\n\t\t\t\t//scr = setPos(smtConfig.commandFactory.script(filename,null),filename.pos());// FIXME - set pos\r\n\t\t\t} else {\r\n\t\t\t\t// This loop skips over invalid commands, producing error messages (parseCommand\r\n\t\t\t\t// returns null); the resulting script is valid, but misses the invalid entries\r\n\t\t\t\tsmtConfig.interactive = false;\r\n\t\t\t\tICommand s;\r\n\t\t\t\tList\u003cICommand\u003e res = new LinkedList\u003cICommand\u003e();\r\n\t\t\t\tparseLP();\r\n\t\t\t\tboolean anyError = false;\r\n\t\t\t\twhile (!isRP()) {\r\n\t\t\t\t\ts = parseCommand();\r\n\t\t\t\t\tif (s != null) res.add(s);\r\n\t\t\t\t\telse anyError = true;\r\n\t\t\t\t}\r\n\t\t\t\tILexToken rp = parseRP();\r\n\t\t\t\tif (rp == null || anyError) return null;\r\n\t\t\t\tscr = new Script(null,res); // FIXME - use a factory, set position\r\n\t\t\t\t// FIXME set pos pos(lp.pos(),rp.pos(),source);\r\n\t\t\t}\r\n\t\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Completed input\");\r\n\t\t} catch (ParserException e) {\r\n\t\t\tsmtConfig.log.logError(smt().responseFactory.error(\r\n\t\t\t\t\t\"A failure occurred while parsing a command: \" + e,\r\n\t\t\t\t\te.pos()));\r\n\t\t\treturn null;\r\n\t\t} finally {\r\n\t\t\tsmtConfig.interactive = interactive;\r\n\t\t}\r\n\t\treturn scr;\r\n\t}\r\n\t\r\n\t/** This field is used to communicate the beginning LP while parsing commands */\r\n\tpublic /*@Nullable*/ ILexToken savedlp;\r\n\t\r\n\t/** This field is used only to communicate the position of the name of a command to the command creator\r\n\t * (instead of using method arguments).\r\n\t */\r\n\tpublic /*@ReadOnly*/ ISymbol commandName;\r\n\t\r\n\t/** Parses the next text in the source as a SMT-LIB command; if an error occurs, the error is logged\r\n\t * and the method skips through a matching number of right parentheses\r\n\t *  @return returns the parsed command, or EOD.eod if the end of input has been reached, \r\n\t *  or null if no valid command could be parsed\r\n\t */\r\n\t//@ nullable\r\n\t/*@Nullable*/\r\n\t/*@Mutable*/\r\n\tpublic Command parseCommand() {\r\n\t\tboolean savedTopLevel = smtConfig.topLevel;\r\n\t\tCommand command = null;\r\n\t\ttry {\r\n\t\t\twhile (true) { // The while loop is just so that AbortParseException can cause a retry\r\n\t\t\t\ttry {\r\n\t\t\t\t\tILexToken rp = null;\r\n\t\t\t\t\tsavedlp = parseLP();\r\n\t\t\t\t\tif (savedlp == null) {\r\n\t\t\t\t\t\t// We have not consumed a token - if we don't we may get into\r\n\t\t\t\t\t\t// an infinite loop; if we skipThruRP, we may consume the\r\n\t\t\t\t\t\t// whole file - so we skip to an LP\r\n\t\t\t\t\t\tdo { getToken(); } while (!isLP() \u0026\u0026 !isEOD());\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsmtConfig.topLevel = false;\r\n\t\t\t\t\tSymbol sym = parseSymbolOrReservedWord(\"Expected a symbol here, not a #\");\r\n\t\t\t\t\tif (sym == null) {\r\n\t\t\t\t\t\tskipThruRP();\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcommandName = sym;\r\n\t\t\t\t\tString name = sym.value();\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\t// To create a command, we invoke the 'parse' method (that has a Parser argument)\r\n\t\t\t\t\t\t// in the class corresponding to the given command name.\r\n\t\t\t\t\t\t// The parse method is supposed to consume its argument from the parser source;\r\n\t\t\t\t\t\t// the method does not parse the final right-parenthesis or check that there is no\r\n\t\t\t\t\t\t// extraneous material beyond the last argument parsed - those checks are done here\r\n\t\t\t\t\t\t// for all commands. We also set the IPos value for the command here.\r\n\t\t\t\t\t\t// If an error occurs in parsing the command, an error message should be logged and\r\n\t\t\t\t\t\t// null returned (if null is returned, an error message is expected to have been logged).\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// This call translates a name to the class that implements the command with that name.\r\n\t\t\t\t\t\t// The user can change the lookup behavior by assigning a new command finder object in\r\n\t\t\t\t\t\t// the configuration\r\n\t\t\t\t\t\tClass\u003c? extends ICommand\u003e clazz = smt().commandFinder.findCommand(name);\r\n\t\t\t\t\t\tif (clazz == null) {\r\n\t\t\t\t\t\t\tlastError = error(\"Unknown command: \" + name,sym.pos());\r\n\t\t\t\t\t\t\tcommand = null;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Call the static parser method of the command class; that will create an\r\n\t\t\t\t\t\t\t// instance of the appropriate command, initialized according to the parsed data.\r\n\t\t\t\t\t\t\t// If the parse fails, null is returned and an error will have been logged.\r\n\t\t\t\t\t\t\tMethod m = clazz.getMethod(\"parse\",Parser.class);\r\n\t\t\t\t\t\t\tcommand = (Command)m.invoke(null,this);\r\n\t\t\t\t\t\t\trp = null;\r\n\t\t\t\t\t\t\tif (command != null) {\r\n\t\t\t\t\t\t\t\tif (!isRP()) {\r\n\t\t\t\t\t\t\t\t\tlastError = error(\"Too many arguments or extraneous material after the command or missing right parenthesis\",\r\n\t\t\t\t\t\t\t\t\t\t\t//pos(currentPos()-1,currentPos()));\r\n\t\t\t\t\t\t\t\t\t\t\tpeekToken().pos());\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\trp = parseRP();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} catch (InvocationTargetException ex) {\r\n\t\t\t\t\t\tif (ex.getTargetException() instanceof StackOverflowError) {\r\n\t\t\t\t\t\t\tlastError = error(\"Stack overflow occurred while parsing input\", sym.pos());\r\n\t\t\t\t\t\t\tthrow new ParserException(null,null);\r\n\t\t\t\t\t\t} else if (ex.getTargetException() instanceof OutOfMemoryError) {\r\n\t\t\t\t\t\t\tlastError = error(\"Out of memory error occurred while parsing input\", sym.pos());\r\n\t\t\t\t\t\t\tthrow new ParserException(null,null);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tlastError = error(ex.getTargetException().toString(),sym.pos());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (command == null) {\r\n\t\t\t\t\t\tskipThruRP();\r\n\t\t\t\t\t} else if (rp == null) {\r\n\t\t\t\t\t\tskipThruRP();\r\n\t\t\t\t\t\tcommand = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (command != null) {\r\n\t\t\t\t\t\tsetPos(command,pos(savedlp.pos(),rp.pos()));\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (AbortParseException e) {\r\n\t\t\t\t\tsmtConfig.log.logOut(\"Input aborted\\n\");\r\n\t\t\t\t\tsmtConfig.topLevel = true;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} catch (ParserException e) {\r\n\t\t\t\t\tMatcher m = skipThroughEndOfLine.matcher(csr);\r\n\t\t\t\t\tm.region(matcher.regionStart(),matcher.regionEnd());\r\n\t\t\t\t\tif (e.getMessage() != null) lastError = smtConfig.log.logError(smtConfig.responseFactory.error(e.getMessage(),e.pos()));\r\n\t\t\t\t\tif (m.lookingAt()) {\r\n\t\t\t\t\t\t//smtConfig.log.logOut(\"SKIPPED \" + m.start() + \" \" + m.end());\r\n\t\t\t\t\t\tmatcher.region(m.end(),matcher.regionEnd());\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t//smtConfig.log.logOut(\"NOTHING TO SKIP\");\r\n\t\t\t\t\t} // If the match fails, there was nothing left before the end of the line\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tIPos pos = new Pos(0,0,null);\r\n\t\t\tlastError = smtConfig.responseFactory.error(\"Error while parsing command: \" + e,pos);\r\n\t\t\te.printStackTrace(System.out); // FIXME - should write to the log output\r\n\t\t\tsmtConfig.log.logError(lastError);\r\n\t\t} finally {\r\n\t\t\tsmtConfig.topLevel = savedTopLevel;\r\n\t\t}\r\n\t\treturn command;\r\n\t}\r\n\t\r\n\t/** A helper check, called by command-specific parse methods in which the commands have no arguments */\r\n\t//@ requires savedlp != null \u0026\u0026 commandName != null;\r\n\tpublic boolean checkNoArg() {\r\n\t\ttry {\r\n\t\t\tif (!isRP()) {\r\n\t\t\t\tif (isEOD()) {\r\n\t\t\t\t\tsmtConfig.log.logError(smtConfig.responseFactory.error(\r\n\t\t\t\t\t\t\t\"The input ends with an unmatched left parenthesis\",\r\n\t\t\t\t\t\t\tpos(savedlp.pos(),savedlp.pos())));\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tsmtConfig.log.logError(smtConfig.responseFactory.error(\r\n\t\t\t\t\t\t\"A \" + commandName + \" command takes no arguments\",\r\n\t\t\t\t\t\tpeekToken().pos())); \r\n\t\t\t\treturn false;\r\n\t\t\t} else {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t} catch (ParserException e) {\r\n\t\t\tsmtConfig.log.logError(smt().responseFactory.error(\r\n\t\t\t\t\t\"A failure occurred while parsing a command: \" + e,\r\n\t\t\t\t\te.pos()));\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t/** Parses an Sexpr\r\n\t * @return an Sexpr or null if no more input\r\n\t * @throws ParserException if a parsing problem occurred, such as an invalid token or mismatched parentheses\r\n\t */\r\n\t// FIXME - should this log errors and return null instead of throwing an exception?\r\n\t/*@Nullable*/\r\n\tpublic ISexpr parseSexpr() throws ParserException {\r\n\t\tif (isEOD()) return null;\r\n\t\tILexToken t = getToken();\r\n\t\tif (t.toString() == IPLexToken.RP) {\r\n\t\t\tthrow new ParserException(\"Unexpected right parenthesis\",t.pos());\r\n\t\t}\r\n\t\tif (t.toString() == IPLexToken.LP) {\r\n\t\t\tboolean saved = smtConfig.topLevel;\r\n\t\t\tsmtConfig.topLevel = false;\r\n\t\t\tSexpr res = parseSeq(t);\r\n\t\t\tsmtConfig.topLevel = saved; // FIXME - use a try-finally block?\r\n\t\t\treturn res;\r\n\t\t} \r\n\t\tif (!(t instanceof ISexpr)) {\r\n\t\t\tthrow new ParserException(\"Token is not an S-expression token: \" + t.getClass(),t.pos());\r\n\t\t}\r\n\t\treturn (ISexpr)t;\r\n\t}\r\n\t\r\n\t/** Parses and adds Sexpr to a list until parseSexpr returns null (indicating\r\n\t * a RightParen has been seen or end of input or an error)\r\n\t * @return a SExpr.Seq containing the sequence of SExpr seen\r\n\t * @throws ParserException FIXME - no more of these?\r\n\t */\r\n\tpublic Sexpr.Seq parseSeq(ILexToken lp) throws ParserException {\r\n\t\tSexpr.Seq seq = new Sexpr.Seq(); // FIXME - use factory\r\n\t\t\r\n\t\twhile (true) {\r\n\t\t\tILexToken token = getToken();\r\n\t\t\tif (token.toString() == IPLexToken.RP) {\r\n\t\t\t\tseq.setPos(pos(lp.pos(),token.pos()));\r\n\t\t\t\treturn seq;\r\n\t\t\t} else if (token.toString() == IPLexToken.EMPTY) {\r\n\t\t\t\tthrow new IParser.ParserException(\"Unbalanced parentheses at end of input\",pos(lp.pos(),lp.pos()));\r\n\t\t\t} else if (token.toString() == IPLexToken.LP) {\r\n\t\t\t\tISexpr sexpr = parseSeq(token);\r\n\t\t\t\tseq.sexprs().add(sexpr);\r\n\t\t\t} else if (token instanceof ISexpr) {\r\n\t\t\t\tseq.sexprs().add((ISexpr)token);\r\n\t\t\t} else {\r\n\t\t\t\t// FIXME - invalid token\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/** Parses a qualified identifier (either a symbol, a parameterized identifier, or an as identifier)\r\n\t * from the token stream, returning null (with logged error messages) if there is not one.\r\n\t */\r\n\t@Override\r\n\tpublic /*@Nullable*/IQualifiedIdentifier parseQualifiedIdentifier() throws ParserException {\r\n\t\tif (!isLP()) {\r\n\t\t\treturn parseSymbol();\r\n\t\t} else {\r\n\t\t\tILexToken lp = parseLP(); // will succeed since isLP() was true\r\n\t\t\tISymbol head = parseSymbolOrReservedWord(\"Expected a symbol here, not a #\");\r\n\t\t\tif (head == null) { \r\n\t\t\t\t \r\n\t\t\t} else if (head.toString().equals(\"as\")) {\r\n\t\t\t\treturn parseAsIdentifierRest(lp);\r\n\t\t\t} else if (head.toString().equals(\"_\")) {\r\n\t\t\t\treturn parseIdentifierRest(lp);\r\n\t\t\t} else {\r\n\t\t\t\terror(\"Invalid beginning of an identifer: expected either 'as' or '_' here\",head.pos());\r\n\t\t\t}\r\n\t\t\tskipThruRP();\r\n\t\t\treturn null; // Unsuccessful parsing\r\n\t\t}\r\n\t}\r\n\t\r\n//\tprivate \u003cT extends IPos.IPosable\u003e T setPos(T p, IPos pos) { p.setPos(pos); return p; }\r\n\t\r\n\t/** Parses an 'as' identifier, presuming the left-paren and the 'as' are already parsed,\r\n\t * from the token stream, returning null (with logged error messages) if there is not one.\r\n\t */\r\n\tprivate /*@Nullable*/ IAsIdentifier parseAsIdentifierRest(ILexToken lp) throws ParserException {\r\n\t\tIIdentifier name = parseIdentifier();\r\n\t\tif (name == null) return null;\r\n\t\tISort sort = parseSort(null);\r\n\t\tif (sort == null) { skipThruRP(); return null; }\r\n\t\tILexToken rp = parseRP();\r\n\t\tif (rp == null) { skipThruRP(); return null; }\r\n\t\tIPos pos = pos(lp.pos(),rp.pos());\r\n\t\treturn setPos(smtConfig.exprFactory.id(name,sort),pos);\r\n\t}\r\n\t\r\n\t/** Parses an identifier (either symbol or parameterized identifier) from the token\r\n\t * stream, returning null with logged error messages if there is not one.\r\n\t */\r\n\tpublic /*@Nullable*/IIdentifier parseIdentifier() throws ParserException {\r\n\t\tif (!isLP()) {\r\n\t\t\treturn parseSymbol();\r\n\t\t} else {\r\n\t\t\tILexToken lp = parseLP();\r\n\t\t\tISymbol head = parseSymbolOrReservedWord(\"Expected a symbol here, not a #\");\r\n\t\t\tif (head == null) { \r\n\t\t\t\t// continue \r\n\t\t\t} else if (head.toString().equals(\"_\")) {\r\n\t\t\t\treturn parseIdentifierRest(lp);\r\n\t\t\t} else {\r\n\t\t\t\terror(\"Invalid beginning of an identifer: expected a '_' here\",head.pos());\r\n\t\t\t}\r\n\t\t\tskipThruRP();\r\n\t\t\treturn null; // Unsuccessful parsing\r\n\t\t}\r\n\t}\r\n\t\r\n\t/** Parses a parameterized identifier from the token stream, presuming the left\r\n\t * parenthesis and the underscore character are already read, return null with \r\n\t * logged error messages if there is not one.\r\n\t * @param lp the token for the left parenthesis that starts the identifier\r\n\t * @return the token or null\r\n\t * @throws ParserException if unrecoverable error occurs\r\n\t */\r\n\tprivate IIdentifier parseIdentifierRest(ILexToken lp) throws ParserException {\r\n\t\tISymbol name = parseSymbol();\r\n\t\tif (name == null) { skipThruRP();  return null; }\r\n\t\tList\u003cINumeral\u003e numerals = new LinkedList\u003cINumeral\u003e();\r\n\t\tdo {\r\n\t\t\tif (isEOD()) { \r\n\t\t\t\terror(\"Unexpected end of data while parsing a parameterized identifier\",pos(lp.pos().charStart(),currentPos()));\r\n\t\t\t\treturn null; \r\n\t\t\t}\r\n\t\t\tINumeral num = parseNumeral();\r\n\t\t\tif (num == null)  { skipThruRP();  return null; }\r\n\t\t\tnumerals.add(num);\r\n\t\t} while (!isRP());\r\n\t\tILexToken rp = parseRP();\r\n\t\tif (rp == null)  { skipThruRP();  return null; }\r\n\t\tIPos pos = pos(lp.pos(),rp.pos());\r\n\t\treturn setPos(smtConfig.exprFactory.id(name,numerals),pos);\r\n\t}\r\n\t\r\n\t/** Parses an expression, returning null with error messages if there is not a valid\r\n\t * expression in the token stream.\r\n\t */\r\n\t@Override\r\n\tpublic /*@Nullable*/IExpr parseExpr() throws ParserException {\r\n\t\t// Here we suffer a bit for using a hand-written top-down parser.\r\n\t\t// An IExpr can be\r\n\t\t//\t\tliteral\r\n\t\t//\t\tsymbol\r\n\t\t//\t\t( _ symbol numeral+ )\r\n\t\t//\t\t( as identifier sort )\r\n\t\t//\t\t( ! ...\r\n\t\t//\t\t( forall ...\r\n\t\t//\t\t( exists ...\r\n\t\t//\t\t( let ...\r\n\t\t//\t\t( symbol ...\r\n\t\t//\t\t( ( _ symbol ...\r\n\t\t//\t\t( ( as ...\r\n\t\tif (!isLP()) {\r\n\t\t\tILexToken token = getToken();\r\n\t\t\tif (token instanceof SMTExpr.Error) return null;\r\n\t\t\tif (token instanceof IExpr) return (IExpr)token; // FIXME - do we need to check that this is just a literal or symbol\r\n\t\t\tif (!(token instanceof SMTExpr.Error)) error(\"Expected an expression here\",token.pos());\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tILexToken lp = getToken();\r\n\t\tIQualifiedIdentifier head;\r\n\t\tif (!isLP()) {\r\n\t\t\thead = parseSymbolOrReservedWord(\"Expected an identifier or reserved word here, not a #\");\r\n\t\t} else {\r\n\t\t\thead = parseQualifiedIdentifier();\r\n\t\t}\r\n\t\tif (head == null) { skipThruRP(); return null; }\r\n\t\tif (head instanceof ISymbol) { // in particular we want reserved words here\r\n\t\t\tString s = ((ISymbol)head).value();\r\n\t\t\tif (Utils.FORALL.equals(s)) {\r\n\t\t\t\tList\u003cIDeclaration\u003e decls = parseDeclarations();\r\n\t\t\t\tIExpr expr = decls == null ? null : parseExpr();\r\n\t\t\t\tILexToken rp = expr == null ? null : parseRP();\r\n\t\t\t\tif (rp == null) { skipThruRP(); return null ; }\r\n\t\t\t\treturn setPos(smtConfig.exprFactory.forall(decls, expr), pos(lp.pos(), rp.pos()));\r\n\t\t\t} else if (Utils.EXISTS.equals(s)) {\r\n\t\t\t\tList\u003cIDeclaration\u003e decls = parseDeclarations();\r\n\t\t\t\tIExpr expr = decls == null ? null : parseExpr();\r\n\t\t\t\tILexToken rp = expr == null ? null : parseRP();\r\n\t\t\t\tif (rp == null) { skipThruRP(); return null ; }\r\n\t\t\t\treturn setPos(smtConfig.exprFactory.exists(decls, expr), pos(lp.pos(), rp.pos()));\r\n\t\t\t} else if (Utils.LET.equals(s)) {\r\n\t\t\t\tList\u003cIBinding\u003e decls = parseBindings();\r\n\t\t\t\tIExpr expr = decls == null ? null : parseExpr();\r\n\t\t\t\tILexToken rp = expr == null ? null : parseRP();\r\n\t\t\t\tif (rp == null) { skipThruRP(); return null ; }\r\n\t\t\t\treturn setPos(smtConfig.exprFactory.let(decls, expr), pos(lp.pos(), rp.pos()));\r\n\t\t\t} else if (Utils.AS.equals(s)) {\r\n\t\t\t\treturn parseAsIdentifierRest(lp);\r\n\t\t\t} else if (Utils.UNDERSCORE.equals(s)) {\r\n\t\t\t\treturn parseIdentifierRest(lp);\r\n\t\t\t} else if (Utils.NAMED_EXPR.equals(s)) {\r\n\t\t\t\tIExpr expr = parseExpr();\r\n\t\t\t\tif (expr instanceof IExpr.IError) expr = null;\r\n\t\t\t\tList\u003cIAttribute\u003c?\u003e\u003e list = parseAttributeSequence();\r\n\t\t\t\tif (list == null) { skipThruRP(); return null; }\r\n\t\t\t\tILexToken rp = parseRP();\r\n\t\t\t\tif (rp == null) { skipThruRP(); return null; }\r\n\t\t\t\treturn setPos(smtConfig.exprFactory.attributedExpr(expr,list),pos(lp.pos(), rp.pos()));\r\n\t\t\t}\r\n\t\t}\r\n\t\tList\u003cIExpr\u003e list = new LinkedList\u003cIExpr\u003e();\r\n\t\tboolean anyErrors = false;\r\n\t\twhile (!isRP()) {\r\n\t\t\tif (isEOD()) {\r\n\t\t\t\terror(\"Unexpected end of data while parsing a sequence of expressions\",pos(lp.pos().charStart(),currentPos()));\r\n\t\t\t\treturn null; \r\n\t\t\t}\r\n\t\t\tIExpr e = parseExpr();\r\n\t\t\tif (e != null) list.add(e);\r\n\t\t\telse anyErrors = true;\r\n\t\t}\r\n\t\tif (anyErrors) { skipThruRP(); return null; }\r\n\t\tILexToken rp = parseRP();\r\n\t\tif (rp == null) { skipThruRP(); return null; }\r\n\t\tif (list.size() == 0) {\r\n\t\t\terror(\"A function expression must have at least one argument\",pos(lp.pos(),rp.pos()));\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\treturn setPos(smtConfig.exprFactory.fcn(head,list), pos(lp.pos(), rp.pos()));\r\n\t}\r\n\t\r\n\t/** Parses a parenthesized sequence of IDeclaration items, returning null with error messages if an error occurs */\r\n\tpublic /*@Nullable*/List\u003cIDeclaration\u003e parseDeclarations() throws ParserException {\r\n\t\tILexToken lp = parseLP();\r\n\t\tif (lp == null) return null;\r\n\t\tSet\u003cISymbol\u003e names = new HashSet\u003cISymbol\u003e();\r\n\t\tList\u003cIDeclaration\u003e decls = new LinkedList\u003cIDeclaration\u003e();\r\n\t\twhile (!isRP()) {\r\n\t\t\tif (isEOD()) {\r\n\t\t\t\terror(\"Unexpected end of data while parsing a sequence of declarations\",pos(lp.pos().charStart(),currentPos()));\r\n\t\t\t\treturn null; \r\n\t\t\t}\r\n\t\t\tIDeclaration decl = parseDeclaration();\r\n\t\t\tif (decl == null) { skipThruRP(); return null; }\r\n\t\t\tdecls.add(decl);\r\n\t\t\tif (!names.add(decl.parameter())) {\r\n\t\t\t\terror(\"Parameter list has a duplicate name: \" + smtConfig.defaultPrinter.toString(decl.parameter()),decl.parameter().pos());\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tILexToken rp = parseRP();\r\n\t\tif (rp == null) { skipThruRP(); return null; }\r\n\t\treturn decls;\r\n\t}\r\n\r\n\t/** Parses a parenthesized sequence of let-bindings, returning null with error messages if an error occurs */\r\n\tpublic /*@Nullable*/List\u003cIBinding\u003e parseBindings() throws ParserException {\r\n\t\tILexToken lp = parseLP();\r\n\t\tif (lp == null) return null;\r\n\t\tList\u003cIBinding\u003e decls = new LinkedList\u003cIBinding\u003e();\r\n\t\tSet\u003cISymbol\u003e names = new HashSet\u003cISymbol\u003e();\r\n\t\twhile (!isRP()) {\r\n\t\t\tif (isEOD()) {\r\n\t\t\t\terror(\"Unexpected end of data while parsing a sequence of parameter bindings\",pos(lp.pos().charStart(),currentPos()));\r\n\t\t\t\treturn null; \r\n\t\t\t}\r\n\t\t\tIBinding decl = parseBinding();\r\n\t\t\tif (decl == null) { skipThruRP(); return null; }\r\n\t\t\tdecls.add(decl);\r\n\t\t\tif (!names.add(decl.parameter())) {\r\n\t\t\t\terror(\"Parameter list has a duplicate name: \" + smtConfig.defaultPrinter.toString(decl.parameter()),decl.parameter().pos());\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tILexToken rp = parseRP();\r\n\t\tif (rp == null) { skipThruRP(); return null; }\r\n\t\treturn decls;\r\n\t}\r\n\r\n\t/** Parses a declaration \"(id sort)\", returning null with error messages if an error occurs */\r\n\t@Override\r\n\tpublic /*@Nullable*/IDeclaration parseDeclaration() throws ParserException {\r\n\t\tILexToken lp = parseLP();\r\n\t\tISymbol sym = lp == null ?  null : parseSymbol();\r\n\t\tISort sort = sym == null ? null : parseSort(null);\r\n\t\tILexToken rp = sort == null ? null : parseRP();\r\n\t\tif (rp == null) return null;\r\n\t\t//ISymbol.IParameter p = new Symbol.Parameter(sym); // FIXME - use a factory\r\n\t\treturn setPos(smtConfig.exprFactory.declaration(sym,sort), pos(lp.pos(), rp.pos()));\r\n\t}\r\n\r\n\t/** Parses a binding \"(id expression)\", returning null with error messages if an error occurs */\r\n\t@Override\r\n\tpublic /*@Nullable*/IBinding parseBinding() throws ParserException {\r\n\t\tILexToken lp = parseLP();\r\n\t\tISymbol sym = lp == null ?  null : parseSymbol();\r\n\t\tIExpr expr = sym == null ? null : parseExpr();\r\n\t\tILexToken rp = expr == null ? null : parseRP();\r\n\t\tif (rp == null) return null;\r\n\t\t//ISymbol.ILetParameter p = new Symbol.LetParameter(sym); // FIXME - use a factory\r\n\t\treturn setPos(smtConfig.exprFactory.binding(sym,expr), pos(lp.pos(), rp.pos()));\r\n\t}\r\n\r\n\t/** Parses a symbol, returning null with messages and not advancing the parser if an error occurs */\r\n\t@Override\r\n\tpublic /*@Nullable*/Symbol parseSymbol() throws ParserException {\r\n\t\treturn parseSymbol(\"Expected a symbol here, not a #\");\r\n\t}\r\n\r\n\t/** Parses a symbol (but not a reserved word unless the configuration field 'relax' is true), \r\n\t * returning null with messages if an error occurs; the parser is advanced only if an actual symbol is parsed.  The error message\r\n\t * is given by the argument; it may contain a '#' character that will be replaced by the\r\n\t * kind() of the token actually observed; if the argument is null, no error message is\r\n\t * emitted. */\r\n\tpublic /*@Nullable*/Symbol parseSymbol(/*@Nullable*/String msg) throws ParserException {\r\n\t\tILexToken token = peekToken();\r\n\t\tif (token instanceof Symbol) {\r\n\t\t\tif (smtConfig.relax) {\r\n\t\t\t\tif (smtConfig.reservedWordsNotCommands.contains(token.toString())) {\r\n\t\t\t\t\terror(\"A reserved word may not be used as a symbol here: \" + token.toString(),token.pos());\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (smtConfig.reservedWords.contains(token.toString())) {\r\n\t\t\t\t\terror(\"A reserved word may not be used as a symbol here: \" + token.toString(),token.pos());\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ttoken = getToken();\r\n\t\t\treturn (Symbol)token;\r\n\t\t}\r\n\t\tif (!(token instanceof SMTExpr.Error) \u0026\u0026 msg != null) error(msg.replace(\"#\",token.kind()),token.pos());\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** Parses a symbol or a reserved word, returning null with messages if an error occurs.  The error message\r\n\t * is given by the argument; it may contain a '#' character that will be replaced by the\r\n\t * kind() of the token actually observed. */\r\n\tpublic /*@Nullable*/Symbol parseSymbolOrReservedWord(String msg) throws ParserException {\r\n\t\tILexToken token = getToken();\r\n\t\tif (token instanceof Symbol) return (Symbol)token;\r\n\t\tif (!(token instanceof SMTExpr.Error)) error(msg.replace(\"#\",token.kind()),token.pos());\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** Parses a literal, returning null with error messages if an error occurs. */\r\n\t@Override\r\n\tpublic /*@Nullable*/ILiteral parseLiteral() throws ParserException {\r\n\t\tILexToken token = getToken();\r\n\t\tif (token instanceof ILiteral) return (ILiteral)token;\r\n\t\tif (!(token instanceof SMTExpr.Error)) error(\"Expected a literal here, instead of a \" + token.kind(),token.pos());\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** Parses a numeral, returning null with error messages if an error occurs; if\r\n\t * the next token is not a numeral, the token is not consumed, */\r\n\t@Override\r\n\tpublic /*@Nullable*/INumeral parseNumeral() throws ParserException {\r\n\t\tILexToken token = getToken(INumeral.class);\r\n\t\tif (token instanceof INumeral) return (INumeral)token;\r\n\t\tif (!(token instanceof SMTExpr.Error)) error(\"Expected a numeral here, instead of a \" + token.kind(),token.pos());\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** Parses a numeral, returning null with the given message if an error occurs; if\r\n\t * the next token is not a numeral, the token is not consumed, */\r\n\tpublic /*@Nullable*/Numeral parseNumeral(String msg) throws ParserException {\r\n\t\tILexToken token = getToken(INumeral.class);\r\n\t\tif (token instanceof Numeral) return (Numeral)token;\r\n\t\tif (!(token instanceof SMTExpr.Error)) error(msg,token);\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** Parses a decimal, returning null with the given message if an error occurs; if\r\n\t * the next token is not a decimal, the token is not consumed, */\r\n\t@Override\r\n\tpublic IDecimal parseDecimal() throws ParserException {\r\n\t\tILexToken token = getToken(IDecimal.class);\r\n\t\tif (token instanceof IDecimal) return (IDecimal)token;\r\n\t\tif (!(token instanceof SMTExpr.Error)) error(\"Expected a decimal here, instead of a \" + token.kind(),token.pos());\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** Parses a binary literal, returning null with the given message if an error occurs; if\r\n\t * the next token is not a binary literal, the token is not consumed, */\r\n\t@Override\r\n\tpublic IBinaryLiteral parseBinary() throws ParserException {\r\n\t\tILexToken token = getToken(IBinaryLiteral.class);\r\n\t\tif (token instanceof IBinaryLiteral) return (IBinaryLiteral)token;\r\n\t\tif (!(token instanceof SMTExpr.Error)) error(\"Expected a binary literal here, instead of a \" + token.kind(),token.pos());\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** Parses a hex literal, returning null with the given message if an error occurs; if\r\n\t * the next token is not a hex literal, the token is not consumed, */\r\n\t@Override\r\n\tpublic IHexLiteral parseHex() throws ParserException {\r\n\t\tILexToken token = getToken(IHexLiteral.class);\r\n\t\tif (token instanceof IHexLiteral) return (IHexLiteral)token;\r\n\t\tif (!(token instanceof SMTExpr.Error)) error(\"Expected a hex literal here, instead of a \" + token.kind(),token.pos());\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\t/** Parses a string literal, returning null with an error message if an error occurs; if\r\n\t * the next token is not a string literal, the token is not consumed, */\r\n\t@Override\r\n\tpublic /*@Nullable*/StringLiteral parseStringLiteral() throws ParserException {\r\n\t\tILexToken token = getToken(IStringLiteral.class);\r\n\t\tif (token instanceof StringLiteral) return (StringLiteral)token;\r\n\t\tif (!(token instanceof SMTExpr.Error)) error(\"Expected a string literal here, instead of a \" + token.kind(),token.pos());\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** Parses a keyword, returning null with an error message if an error occurs; if\r\n\t * the next token is not a keyword, the token is not consumed. */\r\n\t@Override\r\n\tpublic /*@Nullable*/Keyword parseKeyword() throws ParserException {\r\n\t\tILexToken token = getToken(Keyword.class);\r\n\t\tif (token instanceof Keyword) return (Keyword)token;\r\n\t\tif (!(token instanceof SMTExpr.Error)) error(\"Expected a keyword (beginning with a colon) here, instead of a \" + token.kind(),token.pos());\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/** Parses a keyword, returning null with messages if an error occurs.  The error message\r\n\t * is given by the argument; it may contain a '#' character that will be replaced by the\r\n\t * kind() of the token actually observed; if\r\n\t * the next token is not a keyword, the token is not consumed. */\r\n\tpublic /*@Nullable*/Keyword parseKeyword(String msg) throws ParserException {\r\n\t\tILexToken token = getToken(Keyword.class);\r\n\t\tif (token instanceof Keyword) return (Keyword)token;\r\n\t\tif (!(token instanceof SMTExpr.Error)) error(msg.replace(\"#\",token.kind()),token.pos());\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\t/** Parses a sort, returning null with error messages if a valid sort is not in the \r\n\t * next parser tokens.\r\n\t */\r\n\t// Can be:\r\n\t//\t\tid\r\n\t//\t\t( id sort+ )\r\n\t// so \r\n\t//\t\tsymbol\r\n\t//\t\t( _ symbol numeral+ )\r\n\t//\t\t( symbol sort+ )\r\n\t//\t\t( ( _ symbol numeral+ ) sort+ )\r\n\t@Override\r\n\tpublic /*@Nullable*/Sort parseSort(List\u003cISort.IParameter\u003e parameters) throws ParserException {\r\n\t\tif (!isLP()) {\r\n\t\t\tSymbol sym = parseSymbol();\r\n\t\t\tif (sym == null) { getToken(); return null; } // Make sure to make some forward progress\r\n\t\t\tif (parameters != null) {\r\n\t\t\t\tfor (ISort.IParameter p: parameters) {\r\n\t\t\t\t\tif (p.identifier().equals(sym)) return (Sort)p;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn setPos(new Sort.Application(sym),sym.pos());\r\n\t\t} else {\r\n\t\t\tILexToken lp = parseLP();\r\n\t\t\t\r\n\t\t\tif (!isLP()) {\r\n\t\t\t\tISymbol head = parseSymbolOrReservedWord(\"Expected a symbol or _ here, not a #\");\r\n\t\t\t\tif (head == null) { \r\n\t\t\t\t\treturn null; \r\n\t\t\t\t} else if (head.toString().equals(\"_\")) {\r\n\t\t\t\t\tIIdentifier id = parseIdentifierRest(lp);\r\n\t\t\t\t\tif (id == null) { return null; }\r\n\t\t\t\t\treturn setPos(new Sort.Application(id),id.pos());\r\n\t\t\t\t}\r\n\t\t\t\t// else some other symbol\r\n\r\n\t\t\t\tList\u003cISort\u003e list = parseSortList(parameters);\r\n\t\t\t\tif (list == null) { skipThruRP(); return null; }\r\n\t\t\t\tILexToken rp = parseRP();\r\n\t\t\t\tif (rp == null) { skipThruRP(); return null; }\r\n\t\t\t\treturn setPos(new Sort.Application(head,list),pos(lp.pos(),rp.pos()));\r\n\t\t\t} else {\r\n\t\t\t\tIIdentifier id = parseIdentifier();\r\n\t\t\t\tif (id == null) { skipThruRP(); return null; }\r\n\t\t\t\tList\u003cISort\u003e list = parseSortList(parameters);\r\n\t\t\t\tif (list == null) { skipThruRP(); return null; }\r\n\t\t\t\tILexToken rp = parseRP();\r\n\t\t\t\tif (rp == null) { skipThruRP(); return null; }\r\n\t\t\t\treturn setPos(new Sort.Application(id,list),pos(lp.pos(),rp.pos()));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/** Parses sequence of sorts up to a right-parenthesis, returning null with error messages\r\n\t * if an error occurs.\r\n\t */\r\n\tpublic /*@Nullable*/List\u003cISort\u003e parseSortList(List\u003cISort.IParameter\u003e parameters) throws ParserException {\r\n\t\tList\u003cISort\u003e list = new LinkedList\u003cISort\u003e();\r\n\t\twhile (!isRP()) {\r\n\t\t\tif (isEOD()) {\r\n\t\t\t\terror(\"Unexpected end of data while parsing a sort\",pos(currentPos()-1,currentPos()));\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\tISort s = parseSort(parameters);\r\n\t\t\tif (s != null) list.add(s);\r\n\t\t\telse { skipThruRP(); return null; }\r\n\t\t}\r\n\t\treturn list;\r\n\t}\r\n\r\n\t/** Parse an attribute (keyword with optional value), returning null with error messages\r\n\t * if an error occurs.\r\n\t */\r\n\t@Override\r\n\tpublic /*@Nullable*/IExpr.IAttributeValue parseAttributeValue() throws ParserException {\r\n\t\tif (!isLP()) {\r\n\t\t\tif (isRP()) {\r\n\t\t\t\tsmtConfig.log.logError(smtConfig.responseFactory.error(\"Expected an attribute value here, instead of a )\",\r\n\t\t\t\t\t\tpos(currentPos()-1,currentPos())));\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\tILexToken t = getToken();\r\n\t\t\tif (t.isError()) {\r\n\t\t\t\t// Already have an error message\r\n\t\t\t\t//smtConfig.log.logError(smtConfig.responseFactory.error(\"Expected an attribute value here, instead of a \" + t.kind(),t.pos()));\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\tif (t instanceof IKeyword) {\r\n\t\t\t\tsmtConfig.log.logError(smtConfig.responseFactory.error(\"Expected an attribute value here, instead of a \" + t.kind(),t.pos()));\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\tif (t instanceof IAttributeValue) {\r\n\t\t\t\tIAttributeValue v = (IAttributeValue)t;\r\n\t\t\t\treturn v;\r\n\t\t\t} else {\r\n\t\t\t\tsmtConfig.log.logError(smtConfig.responseFactory.error(\"Expected an attribute value here, instead of a \" + t.kind(),t.pos()));\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tISexpr value = parseSexpr();\r\n\t\t\tif (value == null) return null;\r\n\t\t\treturn value;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/** Parse an attribute (keyword with optional value), returning null with error messages\r\n\t * if an error occurs.\r\n\t */\r\n\t@Override\r\n\tpublic /*@Nullable*/IExpr.IAttribute\u003c?\u003e parseAttribute() throws ParserException {\r\n\t\tKeyword keyword = parseKeyword();\r\n\t\tif (keyword == null) return null;\r\n\t\tif (isRP() || isEOD()) {\r\n\t\t\treturn setPos(smtConfig.exprFactory.attribute(keyword),keyword.pos());\r\n\t\t}\r\n\t\tILexToken n = peekToken();\r\n\t\tif (n instanceof IKeyword) {\r\n\t\t\treturn setPos(smtConfig.exprFactory.attribute(keyword),keyword.pos());\r\n\t\t} else {\r\n\t\t\tif (!isLP()) {\r\n\t\t\t\tILexToken t = getToken();\r\n\t\t\t\tif (t instanceof IAttributeValue) {\r\n\t\t\t\t\tIAttributeValue v = (IAttributeValue)t;\r\n\t\t\t\t\treturn setPos(smtConfig.exprFactory.attribute(keyword,v),pos(keyword.pos(),v.pos()));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsmtConfig.log.logError(smtConfig.responseFactory.error(\"The value for the keyword \" + \r\n\t\t\t\t\t\t\tsmtConfig.defaultPrinter.toString(keyword) + \" is not a legal attribute value\"));\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tISexpr value = parseSexpr();\r\n\t\t\t\tif (value == null) return null;\r\n\t\t\t\treturn setPos(smtConfig.exprFactory.attribute(keyword,value),pos(keyword.pos(),value.pos()));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/** Parse a sequence of attributes (keyword with optional value) terminated by a right parenthesis, returning null with error messages\r\n\t * if an error occurs.\r\n\t */\r\n\tpublic /*@Nullable*/List\u003cIExpr.IAttribute\u003c?\u003e\u003e parseAttributeSequence() throws ParserException {\r\n\t\tList\u003cIExpr.IAttribute\u003c?\u003e\u003e list = new LinkedList\u003cIExpr.IAttribute\u003c?\u003e\u003e();\r\n\t\twhile (!isRP()) {\r\n\t\t\tif (isEOD()) {\r\n\t\t\t\tsmtConfig.responseFactory.error(\"Unexpected end of data while parsing attributes\",\r\n\t\t\t\t\t\tpos(currentPos()-1,currentPos()));\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\tIExpr.IAttribute\u003c?\u003e attr = parseAttribute();\r\n\t\t\tif (attr == null) return null;\r\n\t\t\tlist.add(attr);\r\n\t\t}\r\n\t\treturn list;\r\n\t}\r\n\t\r\n\t/** Parses a logic definition (including beginning and ending parentheses, returning null\r\n\t * with error messages if it fails; only part of the checking of the contents is\r\n\t * performed in this call (the rest is done in loadLogic).\r\n\t */\r\n\t@Override\r\n\tpublic /*@Nullable*/ ILogic parseLogic() throws ParserException {\r\n\t\tILexToken lp = parseLP();\r\n\t\tif (lp == null) return null;\r\n\t\tISymbol sym = parseSymbol();\r\n\t\tif (sym == null || !Utils.LOGIC.equals(sym.value())) {\r\n\t\t\terror(\"Faulty logic definition: should have the keyword '\" + Utils.LOGIC + \"' as the first token\",\r\n\t\t\t\t\tsym == null ? pos(lp.pos(),lp.pos()) : sym.pos());\r\n\t\t\tskipThruRP(); \r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tISymbol name = parseSymbol();\r\n\t\tif (name == null) { skipThruRP(); return null; }\r\n\t\tList\u003cIAttribute\u003c?\u003e\u003e attributes = parseAttributeSequence();\r\n\t\tif (attributes == null) { skipThruRP(); return null; }\r\n\t\tILexToken rp = parseRP();\r\n\t\tif (rp != null) {\r\n\t\t\tif (!isEOD()) error(\"Expected the end of file after the right parenthesis\",\r\n\t\t\t\t\tpos(lp.pos().charStart(),currentPos()));\r\n\t\t}\r\n\t\tString clazzName = \"org.smtlib.logic.\" + name;\r\n\t\ttry {\r\n\t\t\tClass\u003c? extends ILogic\u003e clazz = (Class\u003c? extends ILogic\u003e)Class.forName(clazzName);\r\n\t\t\tConstructor\u003c? extends ILogic\u003e con = clazz.getConstructor(ISymbol.class,Collection.class);\r\n\t\t\treturn con.newInstance(name,attributes);\r\n\t\t} catch (ClassNotFoundException e) {\r\n\t\t\t// OK - no extension class - no language restrictions\r\n\t\t} catch (NoSuchMethodException e) {\r\n\t\t\t// error - the class must have the right constructor\r\n\t\t\terror(\"The constructor for the class \" + clazzName + \" does not have a constructor with the correct argument types\",\r\n\t\t\t\t\tpos(lp.pos().charStart(),currentPos()));\r\n\t\t} catch (IllegalAccessException e) {\r\n\t\t\t// error - could not create a new instance\r\n\t\t\terror(\"An exception occured when instantiating class \" + clazzName + \": \" + e,\r\n\t\t\t\t\tpos(lp.pos().charStart(),currentPos()));\r\n\t\t} catch (InstantiationException e) {\r\n\t\t\t// error - could not create a new instance\r\n\t\t\terror(\"An exception occured when instantiating class \" + clazzName + \": \" + e,\r\n\t\t\t\t\tpos(lp.pos().charStart(),currentPos()));\r\n\t\t} catch (InvocationTargetException e) {\r\n\t\t\t// error - could not create a new instance\r\n\t\t\terror(\"An exception occured when instantiating class \" + clazzName + \": \" + e,\r\n\t\t\t\t\tpos(lp.pos().charStart(),currentPos()));\r\n\t\t}\r\n\t\treturn new SMTExpr.Logic(name,attributes);\r\n\t}\r\n\t\r\n\t/** Parses a theory definition (including beginning and ending parentheses, returning null\r\n\t * with error messages if it fails; only part of the checking of the contents is\r\n\t * performed in this call (the rest is done in loadTheory).\r\n\t */\r\n\t@Override\r\n\tpublic /*@Nullable*/ ITheory parseTheory() throws ParserException {\r\n\t\tILexToken lp = parseLP();\r\n\t\tif (lp == null) return null;\r\n\t\tISymbol sym = parseSymbol();\r\n\t\tif (sym == null || !Utils.THEORY.equals(sym.value())) {\r\n\t\t\terror(\"Faulty theory definition: should have the keyword '\" + Utils.THEORY + \"' as the first token\",\r\n\t\t\t\t\tsym == null ? pos(lp.pos(),lp.pos()) : sym.pos());\r\n\t\t\tskipThruRP(); \r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tISymbol name = parseSymbol();\r\n\t\tif (name == null) { skipThruRP(); return null; }\r\n\t\tList\u003cIAttribute\u003c?\u003e\u003e attributes = parseAttributeSequence();\r\n\t\tif (attributes == null) { skipThruRP(); return null; }\r\n\t\tILexToken rp = parseRP();\r\n\t\tif (rp != null) {\r\n\t\t\tif (!isEOD()) error(\"Expected the end of file after the right parenthesis\",\r\n\t\t\t\t\tpos(lp.pos().charStart(),currentPos()));\r\n\t\t}\r\n\t\treturn new SMTExpr.Theory(name,attributes);\r\n\t}\r\n\t\r\n\t//@Override // FIXME - put this in the interface\r\n\tpublic /*@Nullable*/ IResponse parseResponse(String response) throws ParserException {\r\n\t\tIResponse.IFactory f = smtConfig.responseFactory;\r\n\t\tresponse = response.trim();\r\n\t\tif (\"\".equals(response)) return f.empty();\r\n\t\tif (\"success\".equals(response)) return f.success();\r\n\t\tif (\"sat\".equals(response)) return f.sat();\r\n\t\tif (\"unsat\".equals(response)) return f.unsat();\r\n\t\tif (\"unknown\".equals(response)) return f.unknown();\r\n\t\tif (\"unsupported\".equals(response)) return f.unsupported();\r\n\t\tif (\"true\".equals(response)) return smtConfig.exprFactory.symbol(\"true\");\r\n\t\tif (\"false\".equals(response)) return smtConfig.exprFactory.symbol(\"false\");\r\n\t\t// FIXME - more - iterate over a list?\r\n\t\t\r\n\t\tISexpr sexpr = parseSexpr();\r\n\t\tif (sexpr instanceof ISexpr.ISeq) {\r\n\t\t\tList\u003cISexpr\u003e list = ((ISexpr.ISeq)sexpr).sexprs();\r\n\t\t\tif (list.get(0).toString().equals(\"error\") \u0026\u0026 list.get(1) instanceof IStringLiteral) {\r\n\t\t\t\treturn f.error(((IStringLiteral)list.get(1)).value());\r\n\t\t\t}\r\n\t\t\tif (list.get(0) instanceof IKeyword) {\r\n\t            IAttribute\u003c?\u003e attr = smtConfig.exprFactory.attribute((IKeyword)list.get(0),list.get(1));\r\n\t            return f.get_info_response(attr);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn sexpr;\r\n\t\t//return f.error(\"Could not translate response: \" + response);\r\n\t}\r\n\t\r\n\t/** Parses a left parenthesis, returning null and emitting an error message\r\n\t *  if there isn't one (and the next token is not consumed)\r\n\t */\r\n\tpublic /*@Nullable*/ILexToken parseLP() throws ParserException {\r\n\t\tILexToken token = peekToken();\r\n\t\tif (token.kind() == LexToken.LP) return getToken();\r\n\t\tif (!(token instanceof SMTExpr.Error)) error(\"Expected a left parenthesis here, instead of a \" + token.kind(),token.pos());\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\t/** Parses a right parenthesis, returning null and emitting an error message\r\n\t *  if there isn't one (and the next token is not consumed)\r\n\t */\r\n\tpublic /*@Nullable*/ILexToken parseRP() throws ParserException {\r\n\t\tILexToken token = peekToken();\r\n\t\tif (token.kind() == LexToken.RP) return getToken();\r\n\t\tif (!(token instanceof SMTExpr.Error)) error(\"Expected a right parenthesis here, instead of a \" + token.kind(),token.pos());\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\t/** Parses a right parenthesis, returning null and emitting an error message\r\n\t *  if there isn't one (and the next token is not consumed); the error message\r\n\t *  is the argument, with any '# character replaced by the kind() of the actual next\r\n\t *  token.\r\n\t */\r\n\tpublic /*@Nullable*/ILexToken parseRP(String msg) throws ParserException {\r\n\t\tILexToken token = peekToken();\r\n\t\tif (token.kind() == LexToken.RP) return getToken();\r\n\t\tif (!(token instanceof SMTExpr.Error)) error(msg,token);\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\t/** Emits an error message consisting of the given message string and position. */\r\n\tpublic IResponse.IError error(String msg, /*@Nullable*//*@ReadOnly*/IPos pos) {\r\n\t\treturn smtConfig.log.logError(smtConfig.responseFactory.error(msg,pos));\r\n\t}\r\n\t\r\n\t/** Emits an error message consisting of the given message string with any '#' \r\n\t * character in the string replaced by the kind() of the second argument; the position\r\n\t * of the error is the position of the given token. */\r\n\tpublic void error(String msg, ILexToken token) {\r\n\t\tif (token.kind().equals(\"error\")) return; // FIXME better comparison? document? no string constant?\r\n\t\tString description = token.kind();\r\n\t\tif (description == LexToken.LP) description = \"sequence\";\r\n\t\tsmtConfig.log.logError(smtConfig.responseFactory.error(msg.replace(\"#\",description),token.pos()));\r\n\t}\r\n\r\n\t\r\n\t\r\n}\r\n",
        "name": "Parser.java",
        "path": "smt/lip6.smtlib.SMT/src/org/smtlib/sexpr/Parser.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.SMT/src/org/smtlib/sexpr/Parser.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 255,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires savedlp != null \u0026\u0026 commandName != null;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.command;\r\n\r\nimport java.io.IOException;\r\n\r\nimport org.smtlib.ICommand.Ipop;\r\nimport org.smtlib.IExpr.INumeral;\r\nimport org.smtlib.IParser.ParserException;\r\nimport org.smtlib.IResponse;\r\nimport org.smtlib.ISolver;\r\nimport org.smtlib.IVisitor;\r\nimport org.smtlib.impl.Command;\r\nimport org.smtlib.sexpr.Parser;\r\nimport org.smtlib.sexpr.Printer;\r\n\r\n/** Implements the pop command */\r\npublic class C_pop extends Command implements Ipop {\r\n\t/** The command name */\r\n\tpublic static final String commandName = \"pop\";\r\n\t/** The command name */\r\n\t@Override\r\n\tpublic String commandName() { return commandName; }\r\n\t\r\n\t/** The (non-negative) number of stack frames to pop */\r\n\t//@ protected invariant n.value().compareTo(BigInteger.ZERO) \u003e 0;\r\n\tprotected INumeral numeral;\r\n\t\r\n\t/** The int value giving the number of stack frames to pop (set by check()), if the value is in the range of an int type */\r\n\t//@ protected invariant numeral.value().compareTo(BigInteger.MAX_INT) \u003c= 0 ==\u003e numeral.intValue() == number;\r\n\tprotected int number;\r\n\t\r\n\t/** The number of assertion set stack items to pop */\r\n\t@Override\r\n\tpublic INumeral number() { \r\n\t\treturn numeral;\r\n\t}\r\n\t/** Constructs a command instance */\r\n\t//@ requires n.value().compareTo(BigInteger.ZERO) \u003e 0;\r\n\tpublic C_pop(INumeral n) {\r\n\t\tnumeral = n;\r\n\t\tnumber = n.intValue(); \r\n\t}\r\n\t\r\n\t/** Parses the arguments of the command, producing a new command instance */\r\n\tstatic public /*@Nullable*/ C_pop parse(Parser p) throws ParserException {\r\n\t\tINumeral num = p.parseNumeral();\r\n\t\tif (num == null) return null;\r\n\t\treturn new C_pop(num);\r\n\t}\r\n\r\n\t/** Writes the command in the syntax of the given printer */\r\n\tpublic void write(Printer p) throws IOException, IVisitor.VisitorException {\r\n\t\tp.writer().append(\"(\" + commandName + \" \");\r\n\t\tnumeral.accept(p);\r\n\t\tp.writer().append(\")\");\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic IResponse execute(ISolver solver) {\r\n\t\treturn solver.pop(number);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic \u003cT\u003e T accept(IVisitor\u003cT\u003e v) throws IVisitor.VisitorException {\r\n\t\treturn v.visit(this);\r\n\t}\r\n}\r\n",
        "name": "C_pop.java",
        "path": "smt/lip6.smtlib.SMT/src/org/smtlib/command/C_pop.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.SMT/src/org/smtlib/command/C_pop.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 41,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires n.value().compareTo(BigInteger.ZERO) \u003e 0;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.command;\r\n\r\nimport java.io.IOException;\r\n\r\nimport org.smtlib.ICommand.Ipush;\r\nimport org.smtlib.IExpr.INumeral;\r\nimport org.smtlib.IParser.ParserException;\r\nimport org.smtlib.IResponse;\r\nimport org.smtlib.ISolver;\r\nimport org.smtlib.IVisitor;\r\nimport org.smtlib.impl.Command;\r\nimport org.smtlib.sexpr.Parser;\r\nimport org.smtlib.sexpr.Printer;\r\n\r\n/** Implements the push command */\r\npublic class C_push extends Command implements Ipush {\r\n\t/** The command name */\r\n\tpublic static final String commandName = \"push\";\r\n\t/** The command name */\r\n\t@Override\r\n\tpublic String commandName() { return commandName; }\r\n\t\r\n\t/** The (non-negative) number of stack frames to push */\r\n\t//@ protected invariant n.value().compareTo(BigInteger.ZERO) \u003e 0;\r\n\tprotected INumeral numeral;\r\n\t\r\n\t/** The int value giving the number of stack frames to push (set by check()), if the value is in the range of an int type */\r\n\t//@ protected invariant numeral.value().compareTo(BigInteger.MAX_INT) \u003c= 0 ==\u003e numeral.intValue() == number;\r\n\tprotected int number;\r\n\t\r\n\t/** The number of assertion set stack items to pop */\r\n\t@Override\r\n\tpublic INumeral number() { \r\n\t\treturn numeral;\r\n\t}\r\n\t/** Constructs a command instance */\r\n\t//@ requires n.value().compareTo(BigInteger.ZERO) \u003e 0;\r\n\tpublic C_push(INumeral n) {\r\n\t\tnumeral = n;\r\n\t\tnumber = n.intValue(); \r\n\t}\r\n\t\r\n\t/** Parses the arguments of the command, producing a new command instance */\r\n\tstatic public /*@Nullable*/ C_push parse(Parser p) throws ParserException {\r\n\t\tINumeral num = p.parseNumeral();\r\n\t\tif (num == null) return null;\r\n\t\treturn new C_push(num);\r\n\t}\r\n\r\n\t/** Writes the command in the syntax of the given printer */\r\n\tpublic void write(Printer p) throws IOException, IVisitor.VisitorException {\r\n\t\tp.writer().append(\"(\" + commandName + \" \");\r\n\t\tnumeral.accept(p);\r\n\t\tp.writer().append(\")\");\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic IResponse execute(ISolver solver) {\r\n\t\treturn solver.push(number);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic \u003cT\u003e T accept(IVisitor\u003cT\u003e v) throws IVisitor.VisitorException {\r\n\t\treturn v.visit(this);\r\n\t}\r\n}\r\n",
        "name": "C_push.java",
        "path": "smt/lip6.smtlib.SMT/src/org/smtlib/command/C_push.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.SMT/src/org/smtlib/command/C_push.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 41,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires n.value().compareTo(BigInteger.ZERO) \u003e 0;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.solvers;\r\n\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.PrintStream;\r\nimport java.math.BigDecimal;\r\nimport java.math.BigInteger;\r\nimport java.util.*;\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\nimport org.smtlib.*;\r\nimport org.smtlib.ICommand.*;\r\nimport org.smtlib.impl.Pos;\r\nimport org.smtlib.impl.SMTExpr.ParameterizedIdentifier;\r\nimport org.smtlib.sexpr.ISexpr;\r\nimport org.smtlib.sexpr.Sexpr;\r\nimport org.smtlib.ICommand.Idefine_fun;\r\nimport org.smtlib.IExpr.IAttribute;\r\nimport org.smtlib.IExpr.IAttributeValue;\r\nimport org.smtlib.IExpr.IAttributedExpr;\r\nimport org.smtlib.IExpr.IBinaryLiteral;\r\nimport org.smtlib.IExpr.IBinding;\r\nimport org.smtlib.IExpr.IDecimal;\r\nimport org.smtlib.IExpr.IDeclaration;\r\nimport org.smtlib.IExpr.IError;\r\nimport org.smtlib.IExpr.IExists;\r\nimport org.smtlib.IExpr.IFcnExpr;\r\nimport org.smtlib.IExpr.IForall;\r\nimport org.smtlib.IExpr.IHexLiteral;\r\nimport org.smtlib.IExpr.IIdentifier;\r\nimport org.smtlib.IExpr.IKeyword;\r\nimport org.smtlib.IExpr.ILet;\r\nimport org.smtlib.IExpr.INumeral;\r\nimport org.smtlib.IExpr.IParameterizedIdentifier;\r\nimport org.smtlib.IExpr.IStringLiteral;\r\nimport org.smtlib.IExpr.ISymbol;\r\nimport org.smtlib.ISort.IApplication;\r\nimport org.smtlib.IVisitor.VisitorException;\r\n\r\n/** This class implements the adapter of SMTv2 to old CVC commands. */ \r\npublic class Solver_cvc extends Solver_test implements ISolver {\r\n\t/** Holds the options for the command-line that invokes the solver;\r\n\t * cmds[0] is filled in with the local file-system path to the executable\r\n\t */\r\n\tString cmds[] = new String[]{ \"\", \"+int\" }; \r\n\t\r\n\t//private IResponse status;\r\n\r\n\t/** The external process driver, initialized in start() */\r\n\tprivate SolverProcess solverProcess;\r\n\t\r\n\tfinal private String errorIndication = \"rror\";\r\n\t\r\n\t/** Creates a solver object (which is not yet started)*/\r\n\tpublic Solver_cvc(SMT.Configuration smtConfig, String executable) {\r\n\t\tsuper(smtConfig,\"\");\r\n\t\tcmds[0] = executable;\r\n\t\tsolverProcess = new SolverProcess(cmds,\"CVC\u003e \",smtConfig);\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic IResponse start() {\r\n\t\tsuper.start();\r\n\t\ttry {\r\n\t\t\tsolverProcess.start(true);\r\n//\t\t\tString response = solverProcess.sendAndListen(\"DATATYPE T$$PBOOL = _$TRUE | _$FALSE END;\\n\");\r\n//\t\t\tif (response.contains(errorIndication)) {\r\n//\t\t\t\treturn smtConfig.responseFactory.error(response);\r\n//\t\t\t}\r\n\t\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Started cvc \" );\r\n\t\t\treturn smtConfig.responseFactory.success();\r\n\t\t} catch (Exception e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to start process \" + cmds[0] + \" : \" + e.getMessage());\r\n\t\t}\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic IResponse exit() {\r\n\t\tsuper.exit();\r\n\t\tsolverProcess.exit();\r\n\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Ended CVC \");\r\n\t\treturn smtConfig.responseFactory.success();\r\n\t}\r\n\r\n\r\n\r\n\t@Override\r\n\tpublic IResponse assertExpr(IExpr sexpr) {\r\n\t\ttry {\r\n\t\t\tIResponse status = super.assertExpr(sexpr);\r\n\t\t\tif (!status.isOK()) return status;\r\n\t\t\tString translated = translate(sexpr);\r\n\t\t\tString response = solverProcess.sendAndListen(\"ASSERT \" + translated + \" ;\\n\");\r\n\t\t\tif (response.contains(errorIndication)) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(response);\r\n\t\t\t}\r\n\t\t\treturn status;\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to assert expression: \" + e + \" \" + sexpr, sexpr.pos());\r\n\t\t} catch (VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(e.getMessage(),e.pos());\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse check_sat() { // FIXME - do we need to do a PUSH before a check-sat and then a POP after the last get-value?\r\n\t\tIResponse res;\r\n\t\tIResponse status = super.check_sat();\r\n\t\tif (status.isError()) return status;\r\n\t\ttry {\r\n\t\t\tString s = solverProcess.sendAndListen(\"CHECKSAT;\\r\\n\");\r\n\t\t\t//System.out.println(\"HEARD: \" + s);\r\n\t\t\tif (s.contains(errorIndication)) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(s);\r\n\t\t\t}\r\n\t\t\tif (s.contains(\"Unsatisfiable.\")) res = smtConfig.responseFactory.unsat();\r\n\t\t\telse if (s.contains(\"Satisfiable.\")) res = smtConfig.responseFactory.sat();\r\n\t\t\telse res = smtConfig.responseFactory.unknown();\r\n\t\t\tcheckSatStatus = res;\r\n\t\t} catch (IOException e) {\r\n\t\t\tres = smtConfig.responseFactory.error(\"Failed to check-sat\",null);\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n//\t@Override\r\n//\tpublic CommandResult defineFun(SExpr sexpr) {\r\n//\t\t// TODO Auto-generated method stub\r\n//\t\treturn null;\r\n//\t}\r\n//\r\n\t@Override\r\n\tpublic IResponse pop(int number) {\r\n\t\ttry {\r\n\t\t\tIResponse status = super.pop(number);\r\n\t\t\tif (!status.isOK()) return status;\r\n\t\t\tif (number == 0) return smtConfig.responseFactory.success();\r\n\t\t\twhile (number-- \u003e 0) {\r\n\t\t\t\tString response = solverProcess.sendAndListen(\"POP;\\n\");\r\n\t\t\t\tif (response.contains(errorIndication)) {\r\n\t\t\t\t\treturn smtConfig.responseFactory.error(response);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn status;\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to execute pop: \" + e);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse push(int number) {\r\n\t\ttry {\r\n\t\t\tIResponse status = super.push(number);\r\n\t\t\tif (!status.isOK()) return status;\r\n\t\t\tif (number == 0) return smtConfig.responseFactory.success();\r\n\t\t\twhile (number-- \u003e 0) {\r\n\t\t\t\tString response = solverProcess.sendAndListen(\"PUSH;\\n\");\r\n\t\t\t\tif (response.contains(errorIndication)) {\r\n\t\t\t\t\treturn smtConfig.responseFactory.error(response);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn smtConfig.responseFactory.success();\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to execute push: \" + e);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse set_logic(String logicName, /*@Nullable*/ IPos pos) {\r\n\t\treturn super.set_logic(logicName,pos);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse set_option(IKeyword key, IAttributeValue value) {\r\n\t\tString option = key.value();\r\n\t\tif (Utils.PRINT_SUCCESS.equals(option)) {\r\n\t\t\tif (!(Utils.TRUE.equals(value) || Utils.FALSE.equals(value))) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be 'true' or 'false'\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (logicSet \u0026\u0026 Utils.INTERACTIVE_MODE.equals(option)) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be set before the set-logic command\");\r\n\t\t}\r\n\t\tif (Utils.PRODUCE_ASSIGNMENTS.equals(option) || \r\n\t\t\t\t//Utils.PRODUCE_MODELS.equals(option) || \r\n\t\t\t\tUtils.PRODUCE_PROOFS.equals(option) ||\r\n\t\t\t\tUtils.PRODUCE_UNSAT_CORES.equals(option)) {\r\n\t\t\tif (logicSet) return smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be set before the set-logic command\");\r\n\t\t\treturn smtConfig.responseFactory.unsupported();\r\n\t\t}\r\n\t\tif (Utils.VERBOSITY.equals(option)) {\r\n\t\t\tIAttributeValue v = options.get(option);\r\n\t\t\tsmtConfig.verbose = (v instanceof INumeral) ? ((INumeral)v).intValue() : 0;\r\n\t\t} else if (Utils.DIAGNOSTIC_OUTPUT_CHANNEL.equals(option)) {\r\n\t\t\t// Actually, v should never be anything but IStringLiteral - that should\r\n\t\t\t// be checked during parsing\r\n\t\t\tString name = (value instanceof IStringLiteral)? ((IStringLiteral)value).value() : \"stderr\";\r\n\t\t\tif (name.equals(\"stdout\")) {\r\n\t\t\t\tsmtConfig.log.diag = System.out;\r\n\t\t\t} else if (name.equals(\"stderr\")) {\r\n\t\t\t\tsmtConfig.log.diag = System.err;\r\n\t\t\t} else {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tFileOutputStream f = new FileOutputStream(name,true); // append\r\n\t\t\t\t\tsmtConfig.log.diag = new PrintStream(f);\r\n\t\t\t\t} catch (java.io.IOException e) {\r\n\t\t\t\t\treturn smtConfig.responseFactory.error(\"Failed to open or write to the diagnostic output \" + e.getMessage(),value.pos());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (Utils.REGULAR_OUTPUT_CHANNEL.equals(option)) {\r\n\t\t\t// Actually, v should never be anything but IStringLiteral - that should\r\n\t\t\t// be checked during parsing\r\n\t\t\tString name = (value instanceof IStringLiteral)?((IStringLiteral)value).value() : \"stdout\";\r\n\t\t\tif (name.equals(\"stdout\")) {\r\n\t\t\t\tsmtConfig.log.out = System.out;\r\n\t\t\t} else if (name.equals(\"stderr\")) {\r\n\t\t\t\tsmtConfig.log.out = System.err;\r\n\t\t\t} else {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tFileOutputStream f = new FileOutputStream(name,true); // append\r\n\t\t\t\t\tsmtConfig.log.out = new PrintStream(f);\r\n\t\t\t\t} catch (java.io.IOException e) {\r\n\t\t\t\t\treturn smtConfig.responseFactory.error(\"Failed to open or write to the regular output \" + e.getMessage(),value.pos());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\toptions.put(option,value);\r\n\t\tif (key.toString().equals(\":print-success\")) {\r\n\t\t\tsmtConfig.nosuccess = value.toString().equals(\"false\");\r\n\t\t}\r\n\t\treturn smtConfig.responseFactory.success();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse get_option(IKeyword key) {\r\n\t\tString option = key.value();\r\n\t\tIAttributeValue value = options.get(option);\r\n\t\tif (value == null) return smtConfig.responseFactory.unsupported();\r\n\t\treturn value;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse get_info(IKeyword key) {\r\n\t\tString option = key.value();\r\n\t\tIAttributeValue lit;\r\n\t\tif (\":error-behavior\".equals(option)) {\r\n\t\t\tlit = smtConfig.exprFactory.symbol(Utils.CONTINUED_EXECUTION); // FIXME\r\n\t\t} else if (\":status\".equals(option)) {\r\n\t\t\treturn checkSatStatus==null ? smtConfig.responseFactory.unsupported() : checkSatStatus; \r\n\t\t} else if (\":all-statistics\".equals(option)) {\r\n\t\t\treturn smtConfig.responseFactory.unsupported(); // FIXME\r\n\t\t} else if (\":reason-unknown\".equals(option)) {\r\n\t\t\treturn smtConfig.responseFactory.unsupported(); // FIXME\r\n\t\t} else if (\":authors\".equals(option)) {\r\n\t\t\tlit = smtConfig.exprFactory.unquotedString(\"Clark Barrett, Cesare Tinelli, and others\");\r\n\t\t} else if (\":version\".equals(option)) {\r\n\t\t\tlit = smtConfig.exprFactory.unquotedString(\"2.2\");\r\n\t\t} else if (\":name\".equals(option)) {\r\n\t\t\tlit = smtConfig.exprFactory.unquotedString(\"CVC3\");\r\n\t\t} else {\r\n\t\t\treturn smtConfig.responseFactory.unsupported();\r\n\t\t}\r\n\t\tIAttribute\u003c?\u003e attr = smtConfig.exprFactory.attribute(key,lit);\r\n\t\treturn smtConfig.responseFactory.get_info_response(attr);\r\n\t}\r\n\t\r\n\t\r\n\t@Override\r\n\tpublic IResponse declare_fun(Ideclare_fun cmd){\r\n\t\ttry {\r\n\t\t\tIResponse status = super.declare_fun(cmd);\r\n\t\t\tif (!status.isOK()) return status;\r\n\t\t\tString encodedName = translate(cmd.symbol());\r\n\t\t\tString msg = encodedName + \":\";\r\n\t\t\tif (cmd.argSorts().size() == 0) {\r\n\t\t\t\tmsg = msg + translate(cmd.resultSort());\r\n\t\t\t} else if (cmd.argSorts().size() == 1) {\r\n\t\t\t\tmsg = msg + translate(cmd.argSorts().get(0));\r\n\t\t\t\tmsg = msg + \"-\u003e\";\r\n\t\t\t\tmsg = msg + translate(cmd.resultSort());\r\n\t\t\t} else {\r\n\t\t\t\tIterator\u003cISort\u003e iter = cmd.argSorts().iterator();\r\n\t\t\t\tmsg = msg + \"(\" + translate(iter.next());\r\n\t\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\t\tmsg = msg + \",\" + translate(iter.next());\r\n\t\t\t\t}\r\n\t\t\t\tmsg = msg + \")-\u003e\";\r\n\t\t\t\tmsg = msg + translate(cmd.resultSort());\r\n\t\t\t}\r\n\t\t\tmsg = msg + \";\\n\";\r\n\t\t\tString response = solverProcess.sendAndListen(msg);\r\n\t\t\tif (response.contains(errorIndication)) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(response);\r\n\t\t\t}\r\n\t\t\treturn smtConfig.responseFactory.success();\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to execute set_logic: \" + e);\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to execute set_logic: \" + e, e.pos());\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic String encodeSort(IIdentifier id) throws VisitorException {\r\n\t\tif (id instanceof ISymbol) {\r\n\t\t\tString nm = org.smtlib.sexpr.Printer.write(id);\r\n\t\t\tif (\"Bool\".equals(nm)) return \"BOOLEAN\";\r\n\t\t\tif (\"Int\".equals(nm)) return \"INT\";\r\n\t\t\tif (\"Real\".equals(nm)) return \"REAL\";\r\n\t\t\tif (\"Array\".equals(nm)) {\r\n\t\t\t\tif (!symTable.arrayTheorySet) {\r\n\t\t\t\t\tthrow new VisitorException(\"Array logic not enabled\",id.pos());\r\n\t\t\t\t}\r\n\t\t\t\treturn \"ARRAY\";\r\n\t\t\t}\r\n\t\t\treturn \"T$\" + nm;\r\n\t\t} else if (id instanceof IParameterizedIdentifier){\r\n\t\t\tIParameterizedIdentifier pid = (IParameterizedIdentifier)id;\r\n\t\t\tISymbol head = pid.headSymbol();\r\n\t\t\tString nm = org.smtlib.sexpr.Printer.write(head);\r\n\t\t\tif (\"BitVec\".equals(nm)) {\r\n\t\t\t\treturn \"BITVECTOR(\" + pid.numerals().get(0) + \")\";\r\n\t\t\t}\r\n\t\t\tnm = \"T$\" + nm;\r\n\t\t\tfor (INumeral n: pid.numerals()) {\r\n\t\t\t\tnm = nm + \"$_\" + org.smtlib.sexpr.Printer.write(n);\r\n\t\t\t}\r\n\t\t\treturn nm;\r\n\t\t} else {\r\n\t\t\tthrow new VisitorException(\"Unexpected kind of identifier: \" + id.getClass(),id.pos());\r\n\t\t}\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic IResponse declare_sort(Ideclare_sort cmd) {\r\n\t\tIResponse res = super.declare_sort(cmd);\r\n\t\tif (!res.isOK()) return res;\r\n\t\ttry {\r\n\t\t\tif (cmd.arity().value().intValue() == 0) {\r\n\t\t\t\tString msg = encodeSort(cmd.sortSymbol()) + \": TYPE;\\n\";\r\n\t\t\t\tString response = solverProcess.sendAndListen(msg);\r\n\t\t\t\tif (response.contains(errorIndication)) {\r\n\t\t\t\t\treturn smtConfig.responseFactory.error(response);\r\n\t\t\t\t}\r\n\t\t\t\treturn res;\r\n\t\t\t} else {\r\n\t\t\t\treturn smtConfig.responseFactory.error(\"CVC adapter does not implement parameterized user-defined sorts\",cmd instanceof IPos.IPosable ? ((IPos.IPosable)cmd).pos() : null);\r\n\t\t\t}\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to execute declare_sort: \" + e);\r\n\t\t} catch (VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to execute declare_sort: \" + e, e.pos());\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse define_fun(Idefine_fun cmd) {\r\n\t\tIResponse res = super.define_fun(cmd);\r\n\t\tif (!res.isOK()) return res;\r\n\t\ttry {\r\n\t\t\tif (cmd.parameters().size() == 0) {\r\n\t\t\t\tString name = encode(cmd.symbol());\r\n\t\t\t\tString resultSort = translate(cmd.resultSort());\r\n\t\t\t\tString def = cmd.expression() == null ? null : translate(cmd.expression());\r\n\t\t\t\tdef = name + \": \" + resultSort + \r\n\t\t\t\t\t( def == null ? \"\" : (\" = \" + def )) + \r\n\t\t\t\t\t\";\\n\";\r\n\t\t\t\tString response = solverProcess.sendAndListen(def);\r\n\t\t\t\tif (response.contains(errorIndication)) {\r\n\t\t\t\t\treturn smtConfig.responseFactory.error(response);\r\n\t\t\t\t}\r\n\t\t\t\treturn res;\r\n\t\t\t} else {\r\n\t\t\t\tString name = encode(cmd.symbol());\r\n\t\t\t\tStringBuilder def = new StringBuilder();\r\n\t\t\t\tdef.append(name);\r\n\t\t\t\tdef.append(\" : \");\r\n\t\t\t\tif (cmd.parameters().size() == 1) {\r\n\t\t\t\t\tdef.append(translate(cmd.parameters().get(0).sort()));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdef.append(\"(\");\r\n\t\t\t\t\tIterator\u003cIDeclaration\u003e iter = cmd.parameters().iterator();\r\n\t\t\t\t\tdef.append(translate(iter.next().sort()));\r\n\t\t\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\t\t\tdef.append(\",\");\r\n\t\t\t\t\t\tdef.append(translate(iter.next().sort()));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tdef.append(\")-\u003e\");\r\n\t\t\t\tdef.append(translate(cmd.resultSort()));\r\n\t\t\t\tdef.append(\" = LAMBDA(\");\r\n\t\t\t\tIterator\u003cIDeclaration\u003e iter = cmd.parameters().iterator();\r\n\t\t\t\tIDeclaration d = iter.next();\r\n\t\t\t\tif (cmd.parameters().size() == 1) {\r\n\t\t\t\t\tdef.append(translate(d.parameter()));\r\n\t\t\t\t\tdef.append(\":\");\r\n\t\t\t\t\tdef.append(translate(d.sort()));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdef.append(translate(d.parameter()));\r\n\t\t\t\t\tdef.append(\":\");\r\n\t\t\t\t\tdef.append(translate(d.sort()));\r\n\t\t\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\t\t\tdef.append(\",\");\r\n\t\t\t\t\t\td = iter.next();\r\n\t\t\t\t\t\tdef.append(translate(d.parameter()));\r\n\t\t\t\t\t\tdef.append(\":\");\r\n\t\t\t\t\t\tdef.append(translate(d.sort()));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tdef.append(\"): \");\r\n\t\t\t\tdef.append(translate(cmd.expression()));\r\n\t\t\t\tdef.append(\";\\n\");\r\n\t\t\t\tString response = solverProcess.sendAndListen(def.toString());\r\n\t\t\t\tif (response.contains(errorIndication)) {\r\n\t\t\t\t\treturn smtConfig.responseFactory.error(response);\r\n\t\t\t\t}\r\n\t\t\t\treturn res;\r\n\t\t\t}\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to execute define_fun: \" + e);\r\n\t\t} catch (VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to execute define_fun: \" + e, e.pos());\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse define_sort(Idefine_sort cmd) {\r\n\t\tIResponse res = super.define_sort(cmd);\r\n\t\tif (!res.isOK()) return res;\r\n\t\ttry {\r\n\t\t\tif (cmd.parameters().size() == 0) {\r\n\t\t\t\tString def = translate(cmd.expression());\r\n\t\t\t\tString head = encodeSort(cmd.sortSymbol());\r\n\t\t\t\tdef = head + \": TYPE = \" + def + \";\\n\";\r\n\t\t\t\tString response = solverProcess.sendAndListen(def);\r\n\t\t\t\tif (response.contains(errorIndication)) {\r\n\t\t\t\t\treturn smtConfig.responseFactory.error(response);\r\n\t\t\t\t}\r\n\t\t\t\treturn res;\r\n\t\t\t} else {\r\n\t\t\t\treturn smtConfig.responseFactory.error(\"Parameterized sort definitions not implemented\"); // FIXME\r\n\t\t\t}\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to execute define_sort: \" + e);\r\n\t\t} catch (VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to execute define_sort: \" + e, e.pos());\r\n\t\t}\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic IResponse get_value(IExpr... terms) {\r\n\t\tTypeChecker tc = new TypeChecker(symTable);\r\n\t\ttry {\r\n\t\t\tfor (IExpr term: terms) {\r\n\t\t\t\tterm.accept(tc);\r\n\t\t\t}\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\ttc.result.add(smtConfig.responseFactory.error(e.getMessage()));\r\n\t\t} finally {\r\n\t\t\tif (!tc.result.isEmpty()) return tc.result.get(0); // FIXME - report all errors?\r\n\t\t}\r\n\t\t// FIXME - do we really want to call get-option here? it involves going to the solver?\r\n\t\tif (!Utils.TRUE.equals(get_option(smtConfig.exprFactory.keyword(Utils.PRODUCE_MODELS)))) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The get-value command is only valid if :produce-models has been enabled\");\r\n\t\t}\r\n\t\tif (!smtConfig.responseFactory.sat().equals(checkSatStatus) \u0026\u0026 !smtConfig.responseFactory.unknown().equals(checkSatStatus)) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"A get-value command is valid only after check-sat has returned sat or unknown\");\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tString response = solverProcess.sendAndListen(\"COUNTERMODEL;\\n\");\r\n\t\t\tList\u003cISexpr\u003e valueslist = new LinkedList\u003cISexpr\u003e();\r\n\t\t\torg.smtlib.sexpr.Lexer lexer = new org.smtlib.sexpr.Lexer(smtConfig,null);\r\n\t\t\tfor (IExpr e: terms) {\r\n\t\t\t\tList\u003cISexpr\u003e values = new LinkedList\u003cISexpr\u003e();\r\n\t\t\t\tvalues.add(new Sexpr.Expr(e));\r\n\t\t\t\tresponse = solverProcess.sendAndListen(\"TRANSFORM \" + translate(e) + \";\\n\");\r\n\t\t\t\tif (response.endsWith(\"CVC\u003e \")) response = response.substring(0,response.length()-5).trim();\r\n\t\t\t\tif (response.startsWith(\"0bin\")) response = \"#b\" + response.substring(4);\r\n\t\t\t\telse if (response.equals(\"TRUE\")) response = \"true\";\r\n\t\t\t\telse if (response.equals(\"FALSE\")) response = \"false\";\r\n\t\t\t\telse if (response.contains(\"(\")) {\r\n\t\t\t\t\tISexpr s = (ISexpr)lexer.getToken(\"\\\"\" + response + \"\\\"\");\r\n\t\t\t\t\tvalues.add(s);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tISexpr s = ((ISexpr)lexer.getToken(response));\r\n\t\t\t\tif (s != null) values.add(s);\r\n\t\t\t\telse {\r\n\t\t\t\t\t\ts = (ISexpr)lexer.getToken(\"?\");\r\n\t\t\t\t\t\tvalues.add(s);\r\n\t\t\t\t}\r\n\t\t\t\tvalueslist.add(new Sexpr.Seq(values));\r\n\t\t\t}\r\n\t\t\treturn new Sexpr.Seq(valueslist);\r\n//\t\ttry {\r\n//\t\t\tString response = solverProcess.sendAndListen(\"COUNTERMODEL;\\n\");\r\n//\t\t\tPattern p = Pattern.compile(\"ASSERT (\\\\(([a-zA-X_]+) = ([0-9a-zA-Z-_\\\\.\\\\(\\\\)]+)|(NOT )?([a-zA-X_]+))\\\\;\");\r\n//\t\t\tPattern pvalue = Pattern.compile(\"([0-9]+)|(true)|(false)|0bin([01]+)\");\r\n//\t\t\tMatcher m = p.matcher(response);\r\n//\t\t\tMap\u003cString,String\u003e map = new HashMap\u003cString,String\u003e();\r\n//\t\t\twhile (m.find()) {\r\n//\t\t\t\tString name = m.group(2);\r\n//\t\t\t\tif (name != null) {\r\n//\t\t\t\t\tString value = m.group(3);\r\n//\t\t\t\t\tif (value.startsWith(\"0bin\")) {\r\n//\t\t\t\t\t\tvalue = \"#b\" + value.substring(4,value.length()-1);\r\n//\t\t\t\t\t} else {\r\n//\t\t\t\t\t\tvalue = value.substring(0,value.length()-1);\t\t\t\t\t\t\r\n//\t\t\t\t\t}\r\n//\t\t\t\t\tmap.put(name,value);\r\n//\t\t\t\t} else {\r\n//\t\t\t\t\tname = m.group(5);\r\n//\t\t\t\t\tmap.put(name,m.group(4)==null?\"true\":\"false\");\r\n//\t\t\t\t}\r\n//\t\t\t}\r\n//\t\t\tList\u003cISexpr\u003e values = new LinkedList\u003cISexpr\u003e();\r\n//\t\t\torg.smtlib.sexpr.Lexer lexer = new org.smtlib.sexpr.Lexer(smtConfig,null);\r\n//\t\t\tfor (IExpr e: terms) {\r\n//\t\t\t\tString v = map.get(e.toString());\r\n//\t\t\t\tif (v == null) {\r\n//\t\t\t\t\tISexpr s = (ISexpr)lexer.getToken(\"?\");\r\n//\t\t\t\t\tvalues.add(s);\r\n//\t\t\t\t\tcontinue; // FIXME - should have an error\r\n//\t\t\t\t}\r\n//\t\t\t\tISexpr s = ((ISexpr)lexer.getToken(v));\r\n//\t\t\t\tif (s != null) values.add(s);\r\n//\t\t\t\telse {\r\n//\t\t\t\t\t\ts = (ISexpr)lexer.getToken(\"\\\"\" + v + \"\\\"\");\r\n//\t\t\t\t\t\tvalues.add(s);\r\n//\t\t\t\t}\r\n//\t\t\t}\r\n//\t\t\treturn new Sexpr.Seq(values);\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to CVC solver: \" + e);\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to CVC solver: \" + e);\r\n\t\t} catch (IParser.ParserException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to CVC solver: \" + e);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\tpublic String translate(IExpr expr) throws IVisitor.VisitorException {\r\n\t\treturn expr.accept(new Translator(typemap,smtConfig));\r\n\t}\r\n\t\r\n\tpublic String translate(ISort expr) throws IVisitor.VisitorException {\r\n\t\treturn expr.accept(new Translator(typemap,smtConfig));\r\n\t}\r\n\t\r\n\t/* CVC does distinguish formulas and terms, but allows\r\n\t * BOOLEAN terms\r\n\t */\r\n\t\r\n\tstatic Map\u003cString,String\u003e fcnNames = new HashMap\u003cString,String\u003e();\r\n\tstatic Set\u003cString\u003e logicNames = new HashSet\u003cString\u003e();\r\n\tstatic {\r\n\t\t/* SMTLIB\t\t\tCVC\r\n\t\t * (or p q r ...)\t(p OR q OR r ...)\r\n\t\t * (and p q r ...)\t(p AND q AND r ...)\r\n\t\t * (not p)\t\t\t(NOT p)\r\n\t\t * (=\u003e p q r ...)\t(p =\u003e (q =\u003e r)) \r\n\t\t * (xor p q r ...)\t((p XOR q) XOR r)\r\n\t\t * (= p q r ...)\t((p \u003c=\u003e q) AND ( q \u003c=\u003e r) ... )   - formulas\r\n\t\t * (= p q r ...)\t((p = q) AND (q == r) ... )   - terms\r\n\t\t * (distinct p q r)\t(NOT (p == q))   - formulas (error if more than 2 arguments) \r\n\t\t * (distinct p q r)\t(DISTINCT p q r ... )   - terms  \r\n\t\t * true\t\t\t\tTRUE\r\n\t\t * false\t\t\tFALSE\r\n\t\t * (ite b p q)\t\t(IF b THEN p ELSE q ENDIF)\r\n\t\t * \r\n\t\t */\r\n\t\t\r\n\t\tfcnNames.put(\"or\",\"|\");\t\t\t\t// infix for cvc (left-assoc)\r\n\t\tfcnNames.put(\"and\",\"\u0026\");\t\t\t\t// infix for cvc (left-assoc)\r\n\t\tfcnNames.put(\"not\",\"~\");\t\t\t\t// prefix\r\n\t\tfcnNames.put(\"=\u003e\",\"=\u003e\");\t\t\t\t// infix for cvc (right-assoc)\r\n\t\tfcnNames.put(\"xor\",\"XOR\");\t\t\t\t// infix for cvc (left-assoc)\r\n\t\tfcnNames.put(\"=\",\"=\"); // \u003c=\u003e for formula \t// infix for cvc (chainable)\r\n\t\tfcnNames.put(\"distinct\",\"DISTINCT\"); // XOR for formula// \u003e2 arguments OK for cvc (pairwise)\r\n\t\tfcnNames.put(\"true\",\"TRUE\");\r\n\t\tfcnNames.put(\"false\",\"FALSE\");\r\n\t\tfcnNames.put(\"ite\",\"IF\");\t\t\t// special in cvc  IF ... THEN ... ELSE ... FI\r\n\t\tfcnNames.put(\"+\",\"+\");\t\t\t\t// infix for cvc (left-assoc)\r\n\t\tfcnNames.put(\"-\",\"-\");\t\t\t\t// infix for cvc (left-assoc)\r\n\t\tfcnNames.put(\"*\",\"*\");\t\t\t\t// infix for cvc (left-assoc)\r\n\t\tfcnNames.put(\"\u003e\",\"\u003e\");\t\t\t\t// infix for cvc (left-assoc)\t\t\r\n\t\tfcnNames.put(\"\u003e=\",\"\u003e=\");\t\t\t// infix for cvc (chainable)\r\n\t\tfcnNames.put(\"\u003c\",\"\u003c\");\t\t\t\t// infix for cvc (chainable)\r\n\t\tfcnNames.put(\"\u003c=\",\"\u003c=\");\t\t\t// infix for cvc (chainable)\r\n\t\t\r\n\t\tfcnNames.put(\"forall\",\"FORALL\");\r\n\t\tfcnNames.put(\"exists\",\"EXISTS\");\r\n\t\tfcnNames.put(\"let\",\"LET\");\r\n\t\t\r\n\t\tfcnNames.put(\"bvadd\",\"BVPLUS\"); // needs a first argument of the number of bits\r\n\t\tfcnNames.put(\"bvsub\",\"BVSUB\"); // needs a first argument of the number of bits\r\n\t\tfcnNames.put(\"bvmul\",\"BVMULT\"); // needs a first argument of the number of bits\r\n\t\tfcnNames.put(\"bvneg\",\"BVUMINUS\");\r\n\t\tfcnNames.put(\"bvnand\",\"BVNAND\");\r\n\t\tfcnNames.put(\"bvnor\",\"BVNOR\");\r\n\t\tfcnNames.put(\"bvxor\",\"BVXOR\");\r\n\t\tfcnNames.put(\"bvxnor\",\"BVXNOR\");\r\n\t\tfcnNames.put(\"bvnot\",\"~\");\r\n\t\tfcnNames.put(\"bvand\",\"\u0026\"); // infix\r\n\t\tfcnNames.put(\"bvor\",\"|\"); // infix\r\n\t\tfcnNames.put(\"bvudiv\",\"\u0026\"); // FIXME\r\n\t\tfcnNames.put(\"bvurem\",\"\u0026\"); // FIXME\r\n\t\tfcnNames.put(\"bvshl\",\"\u003c\u003c\"); // infix// FIXME\r\n\t\tfcnNames.put(\"bvlshr\",\"\u003e\u003e\"); // infix// FIXME\r\n\t\tfcnNames.put(\"concat\",\"@\"); // infix\r\n\t\tfcnNames.put(\"bvult\",\"BVLT\");\r\n\t\tfcnNames.put(\"bvule\",\"BVLE\");\r\n\t\tfcnNames.put(\"bvugt\",\"BVGT\");\r\n\t\tfcnNames.put(\"bvuge\",\"BVGE\");\r\n\t\tfcnNames.put(\"extract\",\"extract\");\r\n\t\t\r\n\t\tlogicNames.add(\"or\");\r\n\t\tlogicNames.add(\"and\");\r\n\t\tlogicNames.add(\"not\");\r\n\t\tlogicNames.add(\"=\u003e\");\r\n\t}\r\n\t\r\n\t\r\n\tpublic class Translator extends IVisitor.NullVisitor\u003cString\u003e {\r\n\t\tboolean isFormula = true;\r\n\t\tfinal private Map\u003cIExpr,ISort\u003e typemap;\r\n\t\tfinal private SMT.Configuration smtConfig;\r\n\t\t\r\n\t\tpublic Translator(Map\u003cIExpr,ISort\u003e typemap, SMT.Configuration smtConfig) {\r\n\t\t\tthis.typemap = typemap;\r\n\t\t\tthis.smtConfig = smtConfig;\r\n\t\t}\r\n\t\t\r\n\t\tpublic /*@Nullable*/ IPos pos(Object e) {\r\n\t\t\treturn e instanceof IPos.IPosable ? ((IPos.IPosable)e).pos() : null;\r\n\t\t}\r\n\t\t\r\n\t\tpublic String encode(IAttributeValue id) throws VisitorException {\r\n\t\t\tif (id instanceof ISymbol) {\r\n\t\t\t\treturn org.smtlib.sexpr.Printer.write(id);\r\n\t\t\t} else if (id instanceof IParameterizedIdentifier){\r\n\t\t\t\tIParameterizedIdentifier pid = (IParameterizedIdentifier)id;\r\n\t\t\t\tISymbol head = pid.headSymbol();\r\n\t\t\t\tString nm = org.smtlib.sexpr.Printer.write(head);\r\n\t\t\t\tfor (INumeral n: pid.numerals()) {\r\n\t\t\t\t\tnm = nm + \"$_\" + org.smtlib.sexpr.Printer.write(n);\r\n\t\t\t\t}\r\n\t\t\t\treturn nm;\r\n\t\t\t} else {\r\n\t\t\t\tthrow new VisitorException(\"Unexpected kind of identifier: \" + id.getClass(),id.pos());\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tpublic String encodeSort(IIdentifier id) throws VisitorException {\r\n\t\t\treturn Solver_cvc.this.encodeSort(id);\r\n\t\t}\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic String visit(IAttributedExpr e) throws IVisitor.VisitorException {\r\n\t\t\tIExpr expr = e.expr();\r\n\t\t\tIAttribute\u003c?\u003e attr = e.attributes().get(0);\r\n\t\t\tif (attr.keyword().toString().equals(\":named\")) {\r\n\t\t\t\tString name = encode(attr.attrValue());\r\n\t\t\t\tString ex = expr.accept(this);\r\n\t\t\t\tString def = name + \" : \" + \"BOOLEAN\" + \" = \" + ex + \";\\n\";\r\n\t\t\t\ttry {\r\n\t\t\t\t\tString response = solverProcess.sendAndListen(def);\r\n\t\t\t\t\tif (response.contains(errorIndication)) {\r\n\t\t\t\t\t\tthrow new VisitorException(response,e.pos());\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (IOException exc) {\r\n\t\t\t\t\tthrow new VisitorException(\"Failed to define attributed expression: \" + exc, e.pos());\r\n\t\t\t\t}\r\n\t\t\t\treturn ex;\r\n\t\t\t} else {\r\n\t\t\t\tthrow new VisitorException(\"Unexpected kind of keyword: \" + smtConfig.defaultPrinter.toString(attr.keyword()),attr.pos());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IDecimal e) throws IVisitor.VisitorException {\r\n\t\t\t// CVC has rationals for decimal numbers\r\n\t\t\tBigDecimal v = e.value();\r\n\t\t\tint scale = v.scale();\r\n\t\t\tif (scale \u003e= 0) {\r\n\t\t\t\tBigDecimal num = v.scaleByPowerOfTen(scale);\r\n\t\t\t\tBigDecimal den = BigDecimal.ONE.scaleByPowerOfTen(scale);\r\n\t\t\t\treturn \"(\" + num.toBigInteger() + \"/\" + den.toBigInteger() + \")\";\r\n\t\t\t} else {\r\n\t\t\t\tBigDecimal num = v.scaleByPowerOfTen(-scale);\r\n\t\t\t\treturn \"(\" + num.toBigInteger() + \")\";\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IStringLiteral e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new VisitorException(\"The CVC solver cannot handle string literals\", pos(e));\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(INumeral e) throws IVisitor.VisitorException {\r\n\t\t\treturn org.smtlib.sexpr.Printer.write(e);\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IBinaryLiteral e) throws IVisitor.VisitorException {\r\n\t\t\t// CVC prefix is 0bin - LSB is on right, MSB on left\r\n\t\t\treturn \"0bin\" + e.value();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IHexLiteral e) throws IVisitor.VisitorException {\r\n\t\t\t// CVC prefix is 0hex - LSB is on right, MSB on left\r\n\t\t\treturn \"0hex\" + e.value();\r\n\t\t}\r\n\t\t\r\n\t\t//@ requires iter.hasNext();\r\n\t\tprivate \u003cT extends IExpr\u003e String rightassoc(String fcnname, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\r\n\t\t\tT n = iter.next();\r\n\t\t\tif (!iter.hasNext()) {\r\n\t\t\t\treturn n.accept(this);\r\n\t\t\t} else {\r\n\t\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\t\tsb.append(\"(\");\r\n\t\t\t\tsb.append(n.accept(this));\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(fcnname);\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(rightassoc(fcnname,iter));\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t\treturn sb.toString();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//@ requires iter.hasNext();\r\n\t\t//@ requires length \u003e 0;\r\n\t\tprivate \u003cT extends IExpr\u003e String remove_leftassoc(String fcnname, int length, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\r\n\t\t\tif (length == 1) {\r\n\t\t\t\treturn iter.next().accept(this);\r\n\t\t\t} else {\r\n\t\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\t\tsb.append(\"(\");\r\n\t\t\t\tsb.append(remove_leftassoc(fcnname,length-1,iter));\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(fcnname);\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t\treturn sb.toString();\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t//@ requires iter.hasNext();\r\n\t\t//@ requires length \u003e 0;\r\n\t\tprivate \u003cT extends IAccept\u003e String remove_chainable(String newName, int length, Iterator\u003cIExpr\u003e iter ) throws IVisitor.VisitorException {\r\n\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\tif (length == 2) {\r\n\t\t\t\tsb.append(\"(\");\r\n\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(newName);\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t} else {\r\n\t\t\t\tboolean first = true;\r\n\t\t\t\tIExpr left = iter.next();\r\n\t\t\t\tsb.append(\"(\");\r\n\t\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\t\tif (first) first = false; else sb.append(\" AND \");\r\n\t\t\t\t\tsb.append(\"(\");\r\n\t\t\t\t\tsb.append(left.accept(this));\r\n\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\tsb.append(newName);\r\n\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\tsb.append((left = iter.next()).accept(this));\r\n\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t}\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t}\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\r\n\t\tSet\u003cString\u003e infix = new HashSet\u003cString\u003e();\r\n\t\t{\r\n\t\t\tinfix.addAll(Arrays.asList(new String[]{\"OR\",\"AND\",\"+\",\"*\",\"XOR\",\"-\",\"/\"}));\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IFcnExpr e) throws IVisitor.VisitorException {\r\n\t\t\tboolean resultIsFormula = this.isFormula;\r\n\t\t\tIterator\u003cIExpr\u003e iter = e.args().iterator();\r\n\t\t\tif (!iter.hasNext()) throw new VisitorException(\"Did not expect an empty argument list\", e.pos());\r\n\t\t\tString oldName = e.head().headSymbol().toString();\r\n\t\t\tString newName = e.head().headSymbol().accept(this);\r\n\t\t\tint length = e.args().size();\r\n\t\t\t// FIXME - should we be doing these comparisons with strings?\r\n\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\ttry {\r\n\t\t\t\t// Determine if the arguments are formulas or terms\r\n\t\t\t\tif (resultIsFormula) {\r\n\t\t\t\t\tif (newName != null \u0026\u0026 logicNames.contains(oldName)) {\r\n\t\t\t\t\t\t// Propositional boolean item\r\n\t\t\t\t\t\tthis.isFormula = true;\r\n\t\t\t\t\t\tif (oldName.equals(\"or\")) newName = \"OR\";\r\n\t\t\t\t\t\tif (oldName.equals(\"and\")) newName = \"AND\";\r\n\t\t\t\t\t\tif (oldName.equals(\"not\")) newName = \"NOT\";\r\n\t\t\t\t\t\tif (oldName.equals(\"=\u003e\")) newName = \"=\u003e\";\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tIExpr arg = e.args().get(e.args().size() \u003c= 1 ? 0 : 1); // Use argument 1 for ite's sake\r\n\t\t\t\t\t\tISort sort = typemap.get(arg);\r\n\t\t\t\t\t\tif (sort == null) {\r\n\t\t\t\t\t\t\tthrow new VisitorException(\"INTERNAL ERROR: Encountered an un-sorted expression node: \" + smtConfig.defaultPrinter.toString(arg),arg.pos());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (sort.isBool()) {\r\n\t\t\t\t\t\t\t// Some functions can take both bool and non-bool arguments:\r\n\t\t\t\t\t\t\t//   = /= DISTINCT ite\r\n\t\t\t\t\t\t\tthis.isFormula = resultIsFormula;\r\n\t\t\t\t\t\t\tif (\"=\".equals(newName)) newName = \"\u003c=\u003e\";\r\n\t\t\t\t\t\t\telse if (\"DISTINCT\".equals(newName)) {\r\n\t\t\t\t\t\t\t\tif (e.args().size() \u003e 2) {\r\n\t\t\t\t\t\t\t\t\treturn \"FALSE\";\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tString a1 = iter.next().accept(this);\r\n\t\t\t\t\t\t\t\t\tString a2 = iter.next().accept(this);\r\n\t\t\t\t\t\t\t\t\treturn \"((\" + a1 + \")XOR(\" + a2 + \"))\"; \r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} // FIXME - what about ite?\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Arguments must be terms\r\n\t\t\t\t\t\t\tthis.isFormula = false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.isFormula = false;\r\n\t\t\t\t} // FIXME - implies, equality, non-equality, \r\n\r\n\t\t\t\tif (infix.contains(newName) \u0026\u0026 length \u003e= 2) {\r\n\t\t\t\t\t// infix\r\n\t\t\t\t\tsb.append(\"(\");\r\n\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\t\tsb.append(newName);\r\n\t\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t} else if (newName.equals(\"=\u003e\")) {\r\n\t\t\t\t\tsb.append(rightassoc(newName,iter));\r\n\t\t\t\t} else if (oldName.equals(\"=\")) {\r\n\t\t\t\t\tboolean argsAreBool = typemap.get(e.args().get(0)).isBool();\r\n\t\t\t\t\tboolean needsAnd = length \u003e 2;\r\n\t\t\t\t\tif (needsAnd) sb.append(\"(\");\r\n\t\t\t\t\tString right = iter.next().accept(this);\r\n\t\t\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\t\t\tString left = right;\r\n\t\t\t\t\t\tright = iter.next().accept(this);\r\n\t\t\t\t\t\tif (resultIsFormula) {\r\n\t\t\t\t\t\t\tsb.append(\"((\");\r\n\t\t\t\t\t\t\tsb.append(left);\r\n\t\t\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t\t\t\tsb.append(newName);\r\n\t\t\t\t\t\t\tsb.append(\"(\");\r\n\t\t\t\t\t\t\tsb.append(right);\r\n\t\t\t\t\t\t\tsb.append(\"))\");\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthrow new VisitorException(\"CVC does not permit = in terms\",e.pos());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (needsAnd) {\r\n\t\t\t\t\t\t\tif (!iter.hasNext()) sb.append(\")\");\r\n\t\t\t\t\t\t\telse sb.append(\" AND \");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (newName.equals(\"~\") || newName.equals(\"NOT\")) {\r\n\t\t\t\t\tsb.append(\"(\");\r\n\t\t\t\t\tsb.append(newName);\r\n\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\tsb.append(\" )\");\r\n\t\t\t\t} else if (newName.equals(\"DISTINCT\")) {\r\n\t\t\t\t\tif (isFormula) {\r\n\t\t\t\t\t\tif (length == 2) {\r\n\t\t\t\t\t\t\tsb.append(\"( \");\r\n\t\t\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\t\t\tsb.append(\" XOR \");\r\n\t\t\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\t\t\tsb.append(\" )\");\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tsb.append(\"( \");\r\n\t\t\t\t\t\t\tboolean first = true;\r\n\t\t\t\t\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\t\t\t\t\tIExpr left = iter.next();\r\n\t\t\t\t\t\t\t\tIterator\u003cIExpr\u003e iter2 = e.args().iterator();\r\n\t\t\t\t\t\t\t\tIExpr right;\r\n\t\t\t\t\t\t\t\twhile ((right = iter2.next()) != left) {\r\n\t\t\t\t\t\t\t\t\tif (first) first = false; else sb.append(\" AND \");\r\n\t\t\t\t\t\t\t\t\tsb.append(\"( \");\r\n\t\t\t\t\t\t\t\t\tsb.append(left.accept(this));\r\n\t\t\t\t\t\t\t\t\tsb.append(\" XOR \");\r\n\t\t\t\t\t\t\t\t\tsb.append(right.accept(this));\r\n\t\t\t\t\t\t\t\t\tsb.append(\" )\");\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tsb.append(\" )\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tsb.append(\"DISTINCT(\");\r\n\t\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\t\t\t\tsb.append(\",\");\r\n\t\t\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (symTable.arrayTheorySet \u0026\u0026 oldName.equals(\"select\")) {\r\n\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\tsb.append(\"[\");\r\n\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\tsb.append(\"]\");\r\n\t\t\t\t} else if (symTable.arrayTheorySet \u0026\u0026 oldName.equals(\"store\")) {\r\n\t\t\t\t\tsb.append(\"(\");\r\n\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\tsb.append(\" WITH [\");\r\n\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\tsb.append(\"] := \");\r\n\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t} else if (oldName.equals(\"ite\")) {\r\n\t\t\t\t\tif (!resultIsFormula) {\r\n\t\t\t\t\t\tthrow new VisitorException(\"CVC only allows ite constructs at the formula level\",e.pos());\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// FIXME - formula only\r\n\t\t\t\t\tsb.append(\"(IF \");\r\n\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\tsb.append(\" THEN \");\r\n\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\tsb.append(\" ELSE \");\r\n\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\tsb.append(\" ENDIF)\");\r\n\t\t\t\t} else if (oldName.equals(\"\u003e\") || oldName.equals(\"\u003c\") || oldName.equals(\"\u003e=\") || oldName.equals(\"\u003c=\")) {\r\n\t\t\t\t\tsb.append(remove_chainable(newName,length,iter));\r\n\t\t\t\t} else if (length == 1 \u0026\u0026 newName.equals(\"-\")) {\r\n\t\t\t\t\tsb.append(\"(\");\r\n\t\t\t\t\tsb.append(oldName);\r\n\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t} else if (symTable.bitVectorTheorySet \u0026\u0026 oldName.equals(\"extract\")) {\r\n\t\t\t\t\tIParameterizedIdentifier pid = (IParameterizedIdentifier)e.head();\r\n\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\tsb.append(\"[\");\r\n\t\t\t\t\tsb.append(org.smtlib.sexpr.Printer.write(pid.numerals().get(0)));\r\n\t\t\t\t\tsb.append(\":\");\r\n\t\t\t\t\tsb.append(org.smtlib.sexpr.Printer.write(pid.numerals().get(1)));\r\n\t\t\t\t\tsb.append(\"]\");\r\n\t\t\t\t} else if (symTable.bitVectorTheorySet \u0026\u0026 (oldName.equals(\"bvudiv\") || oldName.equals(\"bvurem\") || oldName.equals(\"bvshl\") || oldName.equals(\"bvlshr\")\r\n\t\t\t\t\t\t|| oldName.equals(\"bvsge\") || oldName.equals(\"bvsgt\") || oldName.equals(\"bvsle\") || oldName.equals(\"bvslt\") \r\n\t\t\t\t\t\t|| oldName.equals(\"bvashr\") \r\n\t\t\t\t\t\t|| oldName.equals(\"bvsmod\") || oldName.equals(\"bvsrem\") || oldName.equals(\"bvsdiv\") \r\n\t\t\t\t\t\t|| oldName.equals(\"bvcomp\") \r\n\t\t\t\t\t\t)) {\r\n\t\t\t\t\tthrow new VisitorException(\"SMT BitVector function \" + oldName + \" is not implemented in cvc\",e.pos());\r\n\t\t\t\t} else if (symTable.bitVectorTheorySet \u0026\u0026 (\"@\".equals(newName) || (oldName.startsWith(\"bv\") \u0026\u0026 newName != null \u0026\u0026 newName.charAt(0) != 'B'))) {\r\n\t\t\t\t\t// infix\r\n\t\t\t\t\tsb.append(\"((\");\r\n\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t\tsb.append(newName);\r\n\t\t\t\t\tsb.append(\"(\");\r\n\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\tsb.append(\"))\");\r\n\t\t\t\t} else if (symTable.bitVectorTheorySet \u0026\u0026 (newName.equals(\"BVPLUS\") || newName.equals(\"BVSUB\") || newName.equals(\"BVMULT\"))) {\r\n\t\t\t\t\tISort sort = typemap.get(e);\r\n\t\t\t\t\tint k = 1;\r\n\t\t\t\t\tif (sort instanceof IApplication) {\r\n\t\t\t\t\t\tIIdentifier id = ((IApplication)sort).family();\r\n\t\t\t\t\t\tif (id instanceof IParameterizedIdentifier) {\r\n\t\t\t\t\t\t\tk = ((IParameterizedIdentifier)id).numerals().get(0).intValue();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsb.append(newName);\r\n\t\t\t\t\tsb.append(\"(\");\r\n\t\t\t\t\tsb.append(k);\r\n\t\t\t\t\tsb.append(\",\");\r\n\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\tsb.append(\",\");\r\n\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t} else if (symTable.bitVectorTheorySet \u0026\u0026 newName.equals(\"sign_extend\")) {\r\n\t\t\t\t\tISort sort = typemap.get(e);\r\n\t\t\t\t\tint k = 1;\r\n\t\t\t\t\tif (sort instanceof IApplication) {\r\n\t\t\t\t\t\tIIdentifier id = ((IApplication)sort).family();\r\n\t\t\t\t\t\tif (id instanceof IParameterizedIdentifier) {\r\n\t\t\t\t\t\t\tk = ((IParameterizedIdentifier)id).numerals().get(0).intValue();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n//\t\t\t\t\tList\u003cINumeral\u003e numerals = ((IParameterizedIdentifier)e.head()).numerals();\r\n//\t\t\t\t\tint arg = numerals.get(0).intValue();\r\n\t\t\t\t\tsb.append(\"SX\");\r\n\t\t\t\t\tsb.append(\"(\");\r\n\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\tsb.append(\",\");\r\n\t\t\t\t\tsb.append(k);\r\n\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t} else if (symTable.bitVectorTheorySet \u0026\u0026 newName.equals(\"rotate_left\")) {\r\n\t\t\t\t\tISort sort = typemap.get(e);\r\n\t\t\t\t\tint k = 1;\r\n\t\t\t\t\tif (sort instanceof IApplication) {\r\n\t\t\t\t\t\tIIdentifier id = ((IApplication)sort).family();\r\n\t\t\t\t\t\tif (id instanceof IParameterizedIdentifier) {\r\n\t\t\t\t\t\t\tk = ((IParameterizedIdentifier)id).numerals().get(0).intValue();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tList\u003cINumeral\u003e numerals = ((IParameterizedIdentifier)e.head()).numerals();\r\n\t\t\t\t\tint arg = numerals.get(0).intValue();\r\n\t\t\t\t\tString expr = (iter.next().accept(this));\r\n\r\n\t\t\t\t\tsb.append(\"(\");\r\n\t\t\t\t\tsb.append(expr);\r\n\t\t\t\t\tsb.append(\"[\");\r\n\t\t\t\t\tsb.append(k-1);\r\n\t\t\t\t\tsb.append(\":\");\r\n\t\t\t\t\tsb.append(k-arg);\r\n\t\t\t\t\tsb.append(\"]@\");\r\n\t\t\t\t\tsb.append(expr);\r\n\t\t\t\t\tsb.append(\"[\");\r\n\t\t\t\t\tsb.append(k-arg-1);\r\n\t\t\t\t\tsb.append(\":0])\");\r\n\t\t\t\t} else if (symTable.bitVectorTheorySet \u0026\u0026 newName.equals(\"rotate_right\")) {\r\n\t\t\t\t\tISort sort = typemap.get(e);\r\n\t\t\t\t\tint k = 1;\r\n\t\t\t\t\tif (sort instanceof IApplication) {\r\n\t\t\t\t\t\tIIdentifier id = ((IApplication)sort).family();\r\n\t\t\t\t\t\tif (id instanceof IParameterizedIdentifier) {\r\n\t\t\t\t\t\t\tk = ((IParameterizedIdentifier)id).numerals().get(0).intValue();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tList\u003cINumeral\u003e numerals = ((IParameterizedIdentifier)e.head()).numerals();\r\n\t\t\t\t\tint arg = numerals.get(0).intValue();\r\n\t\t\t\t\tString expr = (iter.next().accept(this));\r\n\r\n\t\t\t\t\tsb.append(\"(\");\r\n\t\t\t\t\tsb.append(expr);\r\n\t\t\t\t\tsb.append(\"[\");\r\n\t\t\t\t\tsb.append(k-1);\r\n\t\t\t\t\tsb.append(\":\");\r\n\t\t\t\t\tsb.append(arg);\r\n\t\t\t\t\tsb.append(\"]@\");\r\n\t\t\t\t\tsb.append(expr);\r\n\t\t\t\t\tsb.append(\"[\");\r\n\t\t\t\t\tsb.append(arg-1);\r\n\t\t\t\t\tsb.append(\":0])\");\r\n\t\t\t\t} else if (symTable.bitVectorTheorySet \u0026\u0026 newName.equals(\"zero_extend\")) {\r\n\t\t\t\t\tISort sort = typemap.get(e);\r\n\t\t\t\t\tint k = 1;\r\n\t\t\t\t\tif (sort instanceof IApplication) {\r\n\t\t\t\t\t\tIIdentifier id = ((IApplication)sort).family();\r\n\t\t\t\t\t\tif (id instanceof IParameterizedIdentifier) {\r\n\t\t\t\t\t\t\tk = ((IParameterizedIdentifier)id).numerals().get(0).intValue();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tList\u003cINumeral\u003e numerals = ((IParameterizedIdentifier)e.head()).numerals();\r\n\t\t\t\t\tint arg = numerals.get(0).intValue();\r\n\t\t\t\t\tString expr = (iter.next().accept(this));\r\n\t\t\t\t\t\r\n\t\t\t\t\tString addedzeros = \"\";\r\n\t\t\t\t\twhile (addedzeros.length() \u003c arg) {\r\n\t\t\t\t\t\taddedzeros = addedzeros + zeros.substring(zeros.length() - (arg-addedzeros.length()) );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsb.append(\"(0bin\");\r\n\t\t\t\t\tsb.append(addedzeros);\r\n\t\t\t\t\tsb.append(\"@\");\r\n\t\t\t\t\tsb.append(expr);\r\n\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t} else if (symTable.bitVectorTheorySet \u0026\u0026 newName.equals(\"repeat\")) {\r\n\t\t\t\t\tList\u003cINumeral\u003e numerals = ((IParameterizedIdentifier)e.head()).numerals();\r\n\t\t\t\t\tint arg = numerals.get(0).intValue();\r\n\t\t\t\t\tString expr = (iter.next().accept(this));\r\n\t\t\t\t\tsb.append(\"((\");\r\n\t\t\t\t\tsb.append(expr);\r\n\t\t\t\t\tfor (int i=1; i\u003carg; i++) {\r\n\t\t\t\t\t\tsb.append(\")@(\");\r\n\t\t\t\t\t\tsb.append(expr);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsb.append(\"))\");\r\n\t\t\t\t} else if (e.head() instanceof ParameterizedIdentifier) {\r\n\t\t\t\t\tthrow new VisitorException(\"Unknown parameterized function symbol: \" + oldName, e.pos());\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// usual functional notation\r\n\t\t\t\t\tsb.append(newName == null ? oldName : newName);\r\n\t\t\t\t\tif (!iter.hasNext()) {\r\n\t\t\t\t\t\tsb.append(\"()\"); // FIXME - should this have no parens at all?\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tsb.append(\"(\");\r\n\t\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\t\t\t\tsb.append(\",\");\r\n\t\t\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} finally {\r\n\t\t\t\tisFormula = resultIsFormula;\r\n\t\t\t}\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(ISymbol e) throws IVisitor.VisitorException {\r\n\t\t\t// FIXME - need to check what characters are allowed in a CVC name\r\n\t\t\tString oldName = e.value();\r\n\t\t\tif (!isFormula) {\r\n\t\t\t\tif (\"true\".equals(oldName)) return \"$_TRUE\";\r\n\t\t\t\tif (\"false\".equals(oldName)) return \"$_FALSE\";\r\n\t\t\t}\r\n\t\t\tString newName = fcnNames.get(oldName);\r\n\t\t\tif (newName != null) {\r\n\t\t\t\t// There is a direct translation of a pre-defined SMT-LIB name\r\n\t\t\t\t// into a simplify equivalent - use it.\r\n\t\t\t} else {\r\n\t\t\t\t// Use the ? character as an escape\r\n\t\t\t\tnewName = oldName;\r\n\t\t\t}\r\n\t\t\treturn newName;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IKeyword e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new VisitorException(\"Did not expect a Keyword in an expression to be translated\",pos(e));\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IError e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new VisitorException(\"Did not expect a Error token in an expression to be translated\",pos(e));\r\n\t\t}\r\n\t\t\r\n\t\tprivate final static String zeros = \"00000000000000000000000000000000000000000000000000\";\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IParameterizedIdentifier e) throws IVisitor.VisitorException {\r\n\t\t\tString s = e.headSymbol().toString();\r\n\t\t\tif (s.matches(\"bv[0-9]+\")) {\r\n\t\t\t\tint length = e.numerals().get(0).intValue();\r\n\t\t\t\tBigInteger value = new BigInteger(s.substring(2));\r\n\t\t\t\tString bits = value.toString(2);\r\n\t\t\t\twhile (bits.length() \u003c length) {\r\n\t\t\t\t\tint n = zeros.length() - (length - bits.length());\r\n\t\t\t\t\tif (n \u003c 0) n = 0;\r\n\t\t\t\t\tbits = zeros.substring(n) + bits;\r\n\t\t\t\t}\r\n\t\t\t\treturn \"0bin\" + bits;\r\n\t\t\t}\r\n\t\t\t// FIXME - use default printer properly to print Symbol\r\n\t\t\tthrow new IVisitor.VisitorException(\"Unsupported parameterized function symbol: \" + e.headSymbol().toString(),e.pos());\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IForall e) throws IVisitor.VisitorException {\r\n\t\t\t// FIXME - I think CVC only allows this in formulas\r\n\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\tsb.append(\"(FORALL (\");\r\n\t\t\tboolean first = true;\r\n\t\t\tfor (IDeclaration d: e.parameters()) {\r\n\t\t\t\tif (first) first = false; else sb.append(\", \");\r\n\t\t\t\tsb.append(d.parameter().accept(this));\r\n\t\t\t\tsb.append(\":\");\r\n\t\t\t\tsb.append(d.sort().accept(this));\r\n\t\t\t}\r\n\t\t\tsb.append(\"): \");\r\n\t\t\tsb.append(e.expr().accept(this));\r\n\t\t\tsb.append(\")\");\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IExists e) throws IVisitor.VisitorException {\r\n\t\t\t// FIXME - I think CVC only allows this in formulas\r\n\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\tsb.append(\"(EXISTS (\");\r\n\t\t\tboolean first = true;\r\n\t\t\tfor (IDeclaration d: e.parameters()) {\r\n\t\t\t\tif (first) first = false; else sb.append(\", \");\r\n\t\t\t\tsb.append(d.parameter().accept(this));\r\n\t\t\t\tsb.append(\":\");\r\n\t\t\t\tsb.append(d.sort().accept(this));\r\n\t\t\t}\r\n\t\t\tsb.append(\"): \");\r\n\t\t\tsb.append(e.expr().accept(this));\r\n\t\t\tsb.append(\")\");\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(ILet e) throws IVisitor.VisitorException {\r\n\t\t\t// FIXME - only in formulas?\r\n\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\tsb.append(\"(LET \");\r\n\t\t\tboolean first = true;\r\n\t\t\tfor (IBinding d: e.bindings()) {\r\n\t\t\t\tif (first) first = false; else sb.append(\", \");\r\n\t\t\t\tsb.append(d.parameter().accept(this));\r\n\t\t\t\tsb.append(\" = \");\r\n\t\t\t\tsb.append(d.expr().accept(this));\r\n\t\t\t}\r\n\t\t\tsb.append(\" IN \");\r\n\t\t\tsb.append(e.expr().accept(this));\r\n\t\t\tsb.append(\")\");\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\r\n\t\tpublic String visit(ISort.IFamily s) throws IVisitor.VisitorException {\r\n\t\t\treturn s.identifier().accept(this);\r\n\t\t}\r\n\t\t\r\n\t\tpublic String visit(ISort.IAbbreviation s) throws IVisitor.VisitorException {\r\n\t\t\tthrow new UnsupportedOperationException(\"CVC visit-ISort.IAbbreviation\");\r\n\t\t}\r\n\t\t\r\n\t\tpublic String visit(ISort.IApplication s) throws IVisitor.VisitorException {\r\n\t\t\tif (s.isBool()) return \"BOOLEAN\";\r\n\t\t\tif (s.parameters().size() == 0) {\r\n\t\t\t\tString sort = encodeSort(s.family());\r\n\t\t\t\tif (\"Int\".equals(sort)) return \"INT\";\r\n\t\t\t\tif (\"Real\".equals(sort)) return \"REAL\";\r\n\t\t\t\treturn sort; // FIXME - Array, BitVector\r\n\t\t\t} else if (s.parameters().size() == 2) {\r\n\t\t\t\tString sort = encodeSort(s.family());\r\n\t\t\t\tif (\"ARRAY\".equals(sort)) {\r\n\t\t\t\t\tList\u003cISort\u003e args = s.parameters();\r\n\t\t\t\t\treturn \"(ARRAY \" + args.get(0).accept(this) + \" OF \" + args.get(1).accept(this) +\")\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn \"UNKNOWN\";\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\treturn \"UNKNOWN\"; // FIXME\r\n\t\t\t\t//throw new UnsupportedOperationException(\"CVC visit-ISort.IExpression\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tpublic String visit(ISort.IFcnSort s) {\r\n\t\t\tthrow new UnsupportedOperationException(\"CVC visit-ISort.IFcnSort\");\r\n\t\t}\r\n\t\tpublic String visit(ISort.IParameter s) {\r\n\t\t\tthrow new UnsupportedOperationException(\"CVC visit-ISort.IParameter\");\r\n\t\t}\r\n\t}\r\n}\r\n",
        "name": "Solver_cvc.java",
        "path": "smt/lip6.smtlib.SMT/src/org/smtlib/solvers/Solver_cvc.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.SMT/src/org/smtlib/solvers/Solver_cvc.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 724,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 742,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 743,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires length \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 760,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 761,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires length \u003e 0;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.InputStreamReader;\r\nimport java.io.PrintStream;\r\nimport java.io.Reader;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\n\r\n\r\n/** This class implements a CharSequence that obtains its characters from a ServerSocket.  The characters \r\n * read are held in an internal char array, whose size grows as needed; it starts as initialSize and\r\n * is expanded to currentSize*sizeMultiple + sizeIncrease whenever needed.\r\n * \u003cP\u003e\r\n * The CharSequenceReader is an unconventional CharSequence in that its length() is not known; \r\n * whether this will cause problems\r\n * in some uses of the CharSequenceReader is unknown.  The user should not use the value of length()\r\n * directly; it seems to work in the ways it is called from Pattern.matcher.\r\n * @author David R. Cok\r\n *\r\n */\r\npublic class CharSequenceSocket extends CharSequenceInfinite {\r\n\r\n\t/** The socket from which characters are read */\r\n\tprotected ServerSocket serverSocket;\r\n\r\n\t/** The configuration for this instance of SMT */\r\n\tprotected SMT.Configuration smtConfig;\r\n\t\r\n\t/** Constructor for a new instance\r\n\t * \r\n\t * @param serverSocket the ServerSocket that supplies characters on demand\r\n\t * @param initialSize the beginning size of the internal char array\r\n\t * @param sizeIncrease the amount to add to the current size of the internal char array when the array needs expanding\r\n\t * @param sizeMultiple the factor by which to multiply the current size of the internal char array when it needs expanding\r\n\t */\r\n\t//@ requires initialSize \u003e 0 \u0026\u0026 sizeIncrease \u003e= 0 \u0026\u0026 sizeMultiple \u003e= 1;\r\n\t//@ requires !(sizeIncrease == 0 \u0026\u0026 sizeMultiple == 1)\r\n\tpublic CharSequenceSocket(SMT.Configuration smtConfig, ServerSocket serverSocket, int initialSize, int sizeIncrease, double sizeMultiple) {\r\n\t\tsuper(initialSize, sizeIncrease, sizeMultiple);\r\n\t\tthis.serverSocket = serverSocket;\r\n\t\tthis.smtConfig = smtConfig;\r\n\t}\r\n\r\n\t/** Internal state - if true then we need to create a new connection before reading characters */\r\n\tprivate boolean needsNewConnection = true;\r\n\t\r\n\t/** Internal state - the client socket on which we are reading */\r\n\tprivate /*@Nullable*/ Socket clientSocket = null;\r\n\t\r\n\t/** Internal state - the current Reader for fetching characters */\r\n\tprivate /*@Nullable*/ Reader rdr = null;\r\n\t\r\n\t//@ requires !needsNewConnection =\u003e rdr != null;\r\n\t@Override\r\n\tprotected boolean readChars() throws java.io.IOException {\r\n\t\twhile (true) {\r\n\t\t\tif (needsNewConnection) {\r\n\t\t\t\tif (rdr != null) rdr.close();\r\n\t\t\t\tif (clientSocket != null) clientSocket.close();\r\n\r\n\t\t\t\t// Wait for a client to initiate a call\r\n\t\t\t\tclientSocket = serverSocket.accept();\r\n\r\n\t\t\t\t// Create the input and output streams\r\n\t\t\t\t// FIXME - use a listener?\r\n\t\t\t\t// FIXME - are there any other exceptions?  what if the connection is unexpectedly broken\r\n\t\t\t\tsmtConfig.log.out = new PrintStream(clientSocket.getOutputStream(),true);\r\n\t\t\t\trdr = new BufferedReader(\r\n\t\t\t\t\t\tnew InputStreamReader(\r\n\t\t\t\t\t\t\t\tclientSocket.getInputStream()));\r\n\t\t\t\tneedsNewConnection = false;\r\n\t\t\t}\r\n\t\t\t/*@SuppressWarnings(\"nullness\")*/\r\n\t\t\t/*@NonNull*/ Reader nnrdr = rdr;\r\n\t\t\tint nread = 0;\r\n\t\t\tdo {\r\n\t\t\t\tnread = nnrdr.read(buf,amountRead,buf.length-amountRead);\r\n\t\t\t\tif (nread == -1) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"SOCKET READ \" + nread + \":\" + new String(buf,amountRead,nread));\r\n\t\t\t\tamountRead += nread;\r\n\t\t\t} while (amountRead \u003c buf.length \u0026\u0026 nnrdr.ready());\r\n\r\n\t\t\tif (nread == -1) {\r\n\t\t\t\tneedsNewConnection = true;\r\n\t\t\t\t// end of file so no characters read - go read some more\r\n\t\t\t} else if (buf[amountRead-1] == 0) {\r\n\t\t\t\tamountRead--;\r\n\t\t\t\tneedsNewConnection = true;\r\n\t\t\t\tif (nread \u003e 1) return true;\r\n\t\t\t\t// read only the 0 so no characters read - go read some more\r\n\t\t\t} else {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n}\r\n",
        "name": "CharSequenceSocket.java",
        "path": "smt/lip6.smtlib.SMT/src/org/smtlib/CharSequenceSocket.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.SMT/src/org/smtlib/CharSequenceSocket.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 41,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires initialSize \u003e 0 \u0026\u0026 sizeIncrease \u003e= 0 \u0026\u0026 sizeMultiple \u003e= 1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 42,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires !(sizeIncrease == 0 \u0026\u0026 sizeMultiple == 1)\r"
        },
        {
          "limitHit": false,
          "lineNumber": 58,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires !needsNewConnection =\u003e rdr != null;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib;\r\n\r\nimport java.io.Reader;\r\n\r\n/** This class implements a CharSequence that obtains its characters from a Reader.  The characters \r\n * read are held in an internal char array, whose size grows as needed; it starts as initialSize and\r\n * is expanded to currentSize*sizeMultiple + sizeIncrease whenever needed.\r\n * \r\n * The CharSequenceReader is an unconventional CharSequence in that its length() is not known; \r\n * whether this will cause problems\r\n * in some uses of the CharSequenceReader is unknown.  The user should not use the value of length()\r\n * directly; it seems to work in the ways it is called from Pattern.matcher.\r\n * @author David R. Cok\r\n *\r\n */\r\npublic class CharSequenceReader extends CharSequenceInfinite implements CharSequence {\r\n\r\n\t/** Constructor for a new instance\r\n\t * \r\n\t * @param rdr the Reader that supplies characters on demand\r\n\t * @param initialSize the beginning size of the internal char array\r\n\t * @param sizeIncrease the amount to add to the current size of the internal char array when the array needs expanding\r\n\t * @param sizeMultiple the factor by which to multiply the current size of the internal char array when it needs expanding\r\n\t */\r\n\t//@ requires initialSize \u003e 0 \u0026\u0026 sizeIncrease \u003e= 0 \u0026\u0026 sizeMultiple \u003e= 1;\r\n\t//@ requires !(sizeIncrease == 0 \u0026\u0026 sizeMultiple == 1)\r\n\tpublic CharSequenceReader(/*@NonNull*/Reader rdr, int initialSize, int sizeIncrease, double sizeMultiple) {\r\n\t\tsuper(initialSize, sizeIncrease, sizeMultiple);\r\n\t\tthis.rdr = rdr;\r\n\t}\r\n\t\r\n\t/** Constructor for a new instance\r\n\t * \r\n\t * @param rdr the Reader that supplies characters on demand\r\n\t */\r\n\tpublic CharSequenceReader(/*@NonNull*/Reader rdr) {\r\n\t\tthis(rdr, 100000, 100, 2);\r\n\t}\r\n\t\r\n\t/** The Reader that supplies characters for the CharSequence */\r\n\tprotected /*@NonNull*/ Reader rdr;\r\n\t\r\n\t@Override\r\n\tprotected boolean readChars() throws java.io.IOException {\r\n\t\tint nread;\r\n\t\t// It appears that rdr.ready() can be false when a file has been completely\r\n\t\t// read and the next read will return -1 - there does not appear to be a way\r\n\t\t// to determine that the reader is at the end of file without issuing the\r\n\t\t// final read (which might block if we are interactive)\r\n\t\tif (!rdr.ready() \u0026\u0026 prompter != null) {\r\n\t\t\tprompter.prompt();\r\n\t\t}\r\n\t\tdo {\r\n\t\t\tnread = rdr.read(buf,amountRead,buf.length-amountRead);\r\n\t\t\tif (nread == -1) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tamountRead += nread;\r\n\t\t} while (amountRead \u003c buf.length \u0026\u0026 rdr.ready());\r\n\t\treturn true;\r\n\t}\r\n}\r\n",
        "name": "CharSequenceReader.java",
        "path": "smt/lip6.smtlib.SMT/src/org/smtlib/CharSequenceReader.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.SMT/src/org/smtlib/CharSequenceReader.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 29,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires initialSize \u003e 0 \u0026\u0026 sizeIncrease \u003e= 0 \u0026\u0026 sizeMultiple \u003e= 1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 30,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires !(sizeIncrease == 0 \u0026\u0026 sizeMultiple == 1)\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.solvers;\r\n\r\nimport java.io.FileOutputStream;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\nimport java.io.PrintStream;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\nimport org.smtlib.*;\r\nimport org.smtlib.ICommand.Ideclare_fun;\r\nimport org.smtlib.ICommand.Ideclare_sort;\r\nimport org.smtlib.ICommand.Idefine_fun;\r\nimport org.smtlib.ICommand.Idefine_sort;\r\nimport org.smtlib.IExpr.IAsIdentifier;\r\nimport org.smtlib.IExpr.IAttribute;\r\nimport org.smtlib.IExpr.IAttributeValue;\r\nimport org.smtlib.IExpr.IAttributedExpr;\r\nimport org.smtlib.IExpr.IBinaryLiteral;\r\nimport org.smtlib.IExpr.IBinding;\r\nimport org.smtlib.IExpr.IDecimal;\r\nimport org.smtlib.IExpr.IDeclaration;\r\nimport org.smtlib.IExpr.IError;\r\nimport org.smtlib.IExpr.IExists;\r\nimport org.smtlib.IExpr.IFcnExpr;\r\nimport org.smtlib.IExpr.IForall;\r\nimport org.smtlib.IExpr.IHexLiteral;\r\nimport org.smtlib.IExpr.IKeyword;\r\nimport org.smtlib.IExpr.ILet;\r\nimport org.smtlib.IExpr.INumeral;\r\nimport org.smtlib.IExpr.IParameterizedIdentifier;\r\nimport org.smtlib.IExpr.IQualifiedIdentifier;\r\nimport org.smtlib.IExpr.IStringLiteral;\r\nimport org.smtlib.IExpr.ISymbol;\r\nimport org.smtlib.IVisitor.VisitorException;\r\nimport org.smtlib.impl.Response;\r\nimport org.smtlib.impl.SMTExpr.ParameterizedIdentifier;\r\n\r\n// FIXME - in some commands, like assert, push, pop, the effect in solver_test happens even if the effect in the \r\n// solver itself causes an error, putting the two out of synch; also, push and pop can happen partially\r\n/** This class is the adapter for the Yices SMT solver */\r\npublic class Solver_yices extends Solver_test implements ISolver {\r\n\t/** This holds the command-line arguments used to launch the solver;\r\n\t * the path to the executable is inserted in cmds[0]. */\r\n\tString cmds[] = new String[]{\"\",\"-i\"};\r\n\t\r\n\t/** Holds the driver for external processes */\r\n\tprivate SolverProcess solverProcess;\r\n\t\r\n\t/** The string that indicates an Error in the solver reply */\r\n\tstatic public final String errorIndication = \"Error\";\r\n\r\n\t/** Records the values of options */\r\n\tprotected Map\u003cString,IAttributeValue\u003e options = new HashMap\u003cString,IAttributeValue\u003e();\r\n\t{ \r\n\t\toptions.putAll(Utils.defaults);\r\n\t}\r\n\t\r\n\t/** Creates but does not start a solver instance */\r\n\tpublic Solver_yices(SMT.Configuration smtConfig, String executable) {\r\n\t\tsuper(smtConfig,\"\");\r\n\t\tcmds[0] = executable;\r\n\t\tsolverProcess = new SolverProcess(cmds,\"yices \u003e \",smtConfig);\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic IResponse start() {\r\n\t\tsuper.start();\r\n\t\ttry {\r\n\t\t\tsolverProcess.start(true);\r\n\t\t\tsolverProcess.sendAndListen(\"(define mod :: (-\u003e int int int))\\n\");\r\n\t\t\tsolverProcess.sendAndListen(\"(define div :: (-\u003e int int int))\\n\");\r\n\t\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Started yices \" + (solverProcess!=null));\r\n\t\t\treturn smtConfig.responseFactory.success();\r\n\t\t} catch (Exception e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to start process \" + cmds[0] + \" : \" + e.getMessage());\r\n\t\t}\r\n\t}\r\n\t\r\n\tprotected /*@Nullable*/ IResponse send(IPos pos, String... solverCmds) {\r\n\t\ttry {\r\n\t\t\tfor (String s: solverCmds) solverProcess.sendNoListen(s);\r\n\t\t\tString response = solverProcess.sendAndListen(\"\\n\");\r\n\t\t\tif (response.contains(errorIndication)) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(response,pos);\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(e.getMessage(),pos);\r\n\t\t}\r\n\t}\r\n\r\n\t// FIXME - are we capturing errors from the solver?\r\n\t\r\n\t@Override\r\n\tpublic IResponse exit() {\r\n\t\tIResponse r = send(null,\"(exit)\");\r\n\t\tif (r != null) return r;\r\n\t\tsolverProcess.exit();\r\n\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Ended yices \");\r\n\t\treturn smtConfig.responseFactory.success();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse assertExpr(IExpr sexpr) {\r\n\t\ttry {\r\n\t\t\tIResponse status = super.assertExpr(sexpr);\r\n\t\t\tif (!status.isOK()) return status;\r\n\r\n\t\t\tIResponse response = send(sexpr.pos(),\"(assert+ \",translate(sexpr),\" )\");\r\n\t\t\tif (response != null) return response;\r\n\t\t\treturn status;\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Yices assert command failed: \" + e.getMessage());\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse check_sat() {\r\n\t\tIResponse res = super.check_sat();\r\n\t\tif (res.isError()) return res;\r\n\r\n\t\ttry {\r\n\t\t\tString s = solverProcess.sendAndListen(\"(check)\\r\\n\");\r\n\t\t\tif (s.contains(errorIndication)) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(s);\r\n\t\t\t}\r\n\t\t\t//System.out.println(\"HEARD: \" + s);\r\n\t\t\tif (s.contains(\"unsat\")) res = smtConfig.responseFactory.unsat();\r\n\t\t\telse if (s.contains(\"sat\")) res = smtConfig.responseFactory.sat();\r\n\t\t\telse res = smtConfig.responseFactory.unknown();\r\n\t\t\tcheckSatStatus = res;\r\n\t\t} catch (IOException e) {\r\n\t\t\tres = smtConfig.responseFactory.error(\"Failed to check-sat\");\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse pop(int number) {\r\n\t\tIResponse status = super.pop(number);\r\n\t\tif (status.isError()) return status;\r\n\t\twhile (number-- \u003e 0) {\r\n\t\t\tIResponse response = send(null,\"(pop)\");\r\n\t\t\tif (response != null) return response;\r\n\t\t}\r\n\t\treturn smtConfig.responseFactory.success();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse push(int number) {\r\n\t\tIResponse status = super.push(number);\r\n\t\tif (status.isError()) return status;\r\n\t\twhile (number-- \u003e 0) {\r\n\t\t\tIResponse response = send(null,\"(push)\");\r\n\t\t\tif (response != null) return response;\r\n\t\t}\r\n\t\treturn smtConfig.responseFactory.success();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse set_logic(String logicName, /*@Nullable*/ IPos pos) {\r\n\t\tboolean lSet = logicSet;\r\n\t\tIResponse status = super.set_logic(logicName,pos);\r\n\t\tif (!status.isOK()) return status;\r\n\r\n\t\t// FIXME - discrimninate among logics\r\n\r\n\t\tif (lSet) {\r\n\t\t\tif (!smtConfig.relax) return smtConfig.responseFactory.error(\"Logic is already set\");\r\n\t\t\tIResponse response = send(pos,\"(reset)\");\r\n\t\t\tif (response != null) return response;\r\n\t\t}\r\n\t\treturn status;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse set_option(IKeyword key, IAttributeValue value) {\r\n\t\tString option = key.value();\r\n\t\tif (Utils.PRINT_SUCCESS.equals(option)) {\r\n\t\t\tif (!(Utils.TRUE.equals(value) || Utils.FALSE.equals(value))) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be 'true' or 'false'\");\r\n\t\t\t}\r\n\t\t\t((Response.Factory)smtConfig.responseFactory).printSuccess = !Utils.FALSE.equals(value);\r\n\t\t}\r\n\t\tif (logicSet \u0026\u0026 Utils.INTERACTIVE_MODE.equals(option)) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be set before the set-logic command\");\r\n\t\t}\r\n\t\tif (Utils.PRODUCE_ASSIGNMENTS.equals(option) || \r\n\t\t\t\tUtils.PRODUCE_MODELS.equals(option) || \r\n\t\t\t\tUtils.PRODUCE_PROOFS.equals(option) ||\r\n\t\t\t\tUtils.PRODUCE_UNSAT_CORES.equals(option)) {\r\n\t\t\tif (logicSet) return smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be set before the set-logic command\");\r\n\t\t\treturn smtConfig.responseFactory.unsupported();\r\n\t\t}\r\n\t\tif (Utils.VERBOSITY.equals(option)) {\r\n\t\t\tIAttributeValue v = options.get(option);\r\n\t\t\tsmtConfig.verbose = (v instanceof INumeral) ? ((INumeral)v).intValue() : 0;\r\n\t\t} else if (Utils.DIAGNOSTIC_OUTPUT_CHANNEL.equals(option)) {\r\n\t\t\t// Actually, v should never be anything but IStringLiteral - that should\r\n\t\t\t// be checked during parsing\r\n\t\t\tString name = (value instanceof IStringLiteral)? ((IStringLiteral)value).value() : \"stderr\";\r\n\t\t\tif (name.equals(\"stdout\")) {\r\n\t\t\t\tsmtConfig.log.diag = System.out;\r\n\t\t\t} else if (name.equals(\"stderr\")) {\r\n\t\t\t\tsmtConfig.log.diag = System.err;\r\n\t\t\t} else {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tFileOutputStream f = new FileOutputStream(name,true); // append\r\n\t\t\t\t\tsmtConfig.log.diag = new PrintStream(f);\r\n\t\t\t\t} catch (java.io.IOException e) {\r\n\t\t\t\t\treturn smtConfig.responseFactory.error(\"Failed to open or write to the diagnostic output \" + e.getMessage(),value.pos());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (Utils.REGULAR_OUTPUT_CHANNEL.equals(option)) {\r\n\t\t\t// Actually, v should never be anything but IStringLiteral - that should\r\n\t\t\t// be checked during parsing\r\n\t\t\tString name = (value instanceof IStringLiteral)?((IStringLiteral)value).value() : \"stdout\";\r\n\t\t\tif (name.equals(\"stdout\")) {\r\n\t\t\t\tsmtConfig.log.out = System.out;\r\n\t\t\t} else if (name.equals(\"stderr\")) {\r\n\t\t\t\tsmtConfig.log.out = System.err;\r\n\t\t\t} else {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tFileOutputStream f = new FileOutputStream(name,true); // append\r\n\t\t\t\t\tsmtConfig.log.out = new PrintStream(f);\r\n\t\t\t\t} catch (java.io.IOException e) {\r\n\t\t\t\t\treturn smtConfig.responseFactory.error(\"Failed to open or write to the regular output \" + e.getMessage(),value.pos());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\toptions.put(option,value);\r\n\t\treturn smtConfig.responseFactory.success();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse get_option(IKeyword key) {\r\n\t\tString option = key.value();\r\n\t\tIAttributeValue value = options.get(option);\r\n\t\tif (value == null) return smtConfig.responseFactory.unsupported();\r\n\t\treturn value;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse get_info(IKeyword key) {\r\n\t\tString option = key.value();\r\n\t\tIAttributeValue lit;\r\n\t\tif (\":error-behavior\".equals(option)) {\r\n\t\t\tlit = smtConfig.exprFactory.symbol(Utils.CONTINUED_EXECUTION); // FIXME\r\n\t\t} else if (\":status\".equals(option)) {\r\n\t\t\treturn checkSatStatus==null ? smtConfig.responseFactory.unsupported() : checkSatStatus; \r\n\t\t} else if (\":all-statistics\".equals(option)) {\r\n\t\t\treturn smtConfig.responseFactory.unsupported(); // FIXME\r\n\t\t} else if (\":reason-unknown\".equals(option)) {\r\n\t\t\treturn smtConfig.responseFactory.unsupported(); // FIXME\r\n\t\t} else if (\":authors\".equals(option)) {\r\n\t\t\tlit = smtConfig.exprFactory.unquotedString(\"SRI\");\r\n\t\t} else if (\":version\".equals(option)) {\r\n\t\t\tlit = smtConfig.exprFactory.unquotedString(\"1.0.28\");\r\n\t\t} else if (\":name\".equals(option)) {\r\n\t\t\tlit = smtConfig.exprFactory.unquotedString(\"yices\");\r\n\t\t} else {\r\n\t\t\treturn smtConfig.responseFactory.unsupported();\r\n\t\t}\r\n\t\tIAttribute\u003c?\u003e attr = smtConfig.exprFactory.attribute(key,lit);\r\n\t\treturn smtConfig.responseFactory.get_info_response(attr);\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic IResponse declare_fun(Ideclare_fun cmd) {\r\n\t\ttry {\r\n\t\t\tIResponse status = super.declare_fun(cmd);\r\n\t\t\tif (!status.isOK()) return status;\r\n\r\n\t\t\tString name = translate(cmd.symbol());\r\n\t\t\tString yicescmd;\r\n\t\t\tif (cmd.argSorts().size() == 0) {\r\n\t\t\t\tyicescmd = \"(define \" + name + \"::\" + translate(cmd.resultSort()) + \")\";\r\n\t\t\t} else {\r\n\t\t\t\tyicescmd = \"(define \" + name + \"::(-\u003e\";\r\n\t\t\t\tfor (ISort s: cmd.argSorts()) {\r\n\t\t\t\t\tyicescmd = yicescmd + \" \" + translate(s);\r\n\t\t\t\t}\r\n\t\t\t\tyicescmd = yicescmd + \" \" + translate(cmd.resultSort()) + \"))\";\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tIResponse response = send(null,yicescmd);\r\n\t\t\tif (response != null) return response;\r\n\t\t\treturn status;\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"declare-fun command failed: \" + e.getMessage());\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse define_fun(Idefine_fun cmd) {\r\n\t\ttry {\r\n\t\t\tIResponse status = super.define_fun(cmd);\r\n\t\t\tif (!status.isOK()) return status;\r\n\t\t\t\r\n\t\t\tString name = translate(cmd.symbol());\r\n\t\t\tStringBuilder yicescmd = new StringBuilder();;\r\n\t\t\tif (cmd.parameters().size() == 0) {\r\n\t\t\t\tyicescmd.append(\"(define \" + name + \"::\" + translate(cmd.resultSort()) + \" \" \r\n\t\t\t\t\t\t\t\t+ translate(cmd.expression()));\r\n\t\t\t} else {\r\n\t\t\t\tyicescmd.append(\"(define \" + name + \"::(-\u003e\");\r\n\t\t\t\tfor (IDeclaration d: cmd.parameters()) {\r\n\t\t\t\t\tyicescmd.append(\" \" + translate(d.sort()));\r\n\t\t\t\t}\r\n\t\t\t\tyicescmd.append(\" \" + translate(cmd.resultSort()) + \") \");\r\n\t\t\t\tyicescmd.append(\"(lambda (\");\r\n\t\t\t\tfor (IDeclaration d: cmd.parameters()) {\r\n\t\t\t\t\tyicescmd.append(translate(d.parameter()));\r\n\t\t\t\t\tyicescmd.append(\"::\");\r\n\t\t\t\t\tyicescmd.append(translate(d.sort()));\r\n\t\t\t\t\tyicescmd.append(\" \");\r\n\t\t\t\t}\r\n\t\t\t\tyicescmd.append(\") \");\r\n\t\t\t\tyicescmd.append(translate(cmd.expression()));\r\n\t\t\t\tyicescmd.append(\")\");\r\n\t\t\t}\r\n\t\t\tyicescmd.append(\")\");\r\n\t\t\tIResponse response = send(null,yicescmd.toString());\r\n\t\t\tif (response != null) return response;\r\n\t\t\treturn status;\r\n\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"assert command failed: \" + e.getMessage());\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse declare_sort(Ideclare_sort cmd) {\r\n\t\ttry {\r\n\t\t\tIResponse status = super.declare_sort(cmd);\r\n\t\t\tif (!status.isOK()) return status;\r\n\t\t\t\r\n\t\t\tif (cmd.arity().intValue() == 0) {\r\n\t\t\t\tIResponse response = send(cmd.sortSymbol().pos(),\"(define-type \" + translate(cmd.sortSymbol()) + \")\");\r\n\t\t\t\tif (response != null) return response;\r\n\t\t\t} else {\r\n\t\t\t\tthrow new IVisitor.VisitorException(\"Yices does not support defining parameterized types\",null);\r\n\t\t\t}\r\n\t\t\treturn status;\r\n\t\t\t\r\n\t\t\t// FIXME - Yices does not seem to allow creating arbitrary new types\r\n\t\t\t// Besides Yices uses structural equivalence.\r\n\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Yices declare-sort command failed: \" + e.getMessage(),e.pos());\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse define_sort(Idefine_sort cmd) {\r\n\t\ttry {\r\n\t\t\tIResponse status = super.define_sort(cmd);\r\n\t\t\tif (!status.isOK()) return status;\r\n\r\n\t\t\tif (cmd.parameters().size() == 0) {\r\n\t\t\t\tString msg = \"(define-type \" + translate(cmd.sortSymbol()) + \" \";\r\n\t\t\t\tmsg = msg + translate(cmd.expression()) + \")\";\r\n\t\t\t\tIResponse response = send(cmd.sortSymbol().pos(),msg);\r\n\t\t\t\tif (response != null) return response;\r\n\t\t\t} else {\r\n\t\t\t\tthrow new IVisitor.VisitorException(\"Yices does not support defining parameterized types\",null);\r\n\t\t\t}\r\n\t\t\treturn status;\r\n\r\n\t\t\t// FIXME - Yices does not seem to allow creating arbitrary new types\r\n\t\t\t\t// Besides Yices uses structural equivalence.\r\n\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Yices define-sort command failed: \" + e.getMessage(),e.pos());\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t@Override \r\n\tpublic IResponse get_proof() {\r\n\t\tIResponse status = super.get_proof();\r\n\t\tif (status.isError()) return status;\r\n\t\ttry {\r\n\t\t\tString response = solverProcess.sendAndListen(\"(get-proof)\\n\");\r\n\t\t\tif (response.contains(errorIndication)) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(response);\r\n\t\t\t}\r\n\t\t\treturn smtConfig.responseFactory.unsupported(); // FIXME - need to return the proof\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override \r\n\tpublic IResponse get_unsat_core() {\r\n\t\tIResponse status = super.get_unsat_core();\r\n\t\tif (status.isError()) return status;\r\n\t\ttry {\r\n\t\t\tString response = solverProcess.sendAndListen(\"(get-unsat-core)\\n\");\r\n\t\t\tif (response.contains(errorIndication)) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(response);\r\n\t\t\t}\r\n\t\t\treturn smtConfig.responseFactory.unsupported(); // FIXME - need to return the unsat core\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override \r\n\tpublic IResponse get_assignment() {\r\n\t\tIResponse status = super.get_assignment();\r\n\t\tif (status.isError()) return status;\r\n\t\ttry {\r\n\t\t\tString response = solverProcess.sendAndListen(\"(get-assignment)\\n\");\r\n\t\t\tif (response.contains(errorIndication)) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(response);\r\n\t\t\t}\r\n\t\t\treturn smtConfig.responseFactory.unsupported(); // FIXME - need to return the assignment\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override \r\n\tpublic IResponse get_value(IExpr... terms) {\r\n\t\tIResponse status = super.get_value(terms);\r\n\t\tif (status.isError()) return status;\r\n\t\ttry {\r\n\t\t\tsolverProcess.sendNoListen(\"(get-value\");\r\n\t\t\tfor (IExpr e: terms) {\r\n\t\t\t\tsolverProcess.sendNoListen(\" \",translate(e));\r\n\t\t\t}\r\n\t\t\tString response = solverProcess.sendAndListen(\"\\n\");\r\n\t\t\tif (response.contains(errorIndication)) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(response);\r\n\t\t\t}\r\n\t\t\treturn smtConfig.responseFactory.unsupported(); // FIXME - need to return the results\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Yices solver: \" + e);\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error translating for Yices: \" + e.getMessage());\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic /*@Nullable*/ String translate(IExpr expr) throws IVisitor.VisitorException {\r\n\t\treturn expr.accept(new Translator());\r\n\t}\r\n\t\r\n\tpublic /*@Nullable*/ String translate(ISort expr) throws IVisitor.VisitorException {\r\n\t\treturn expr.accept(new Translator());\r\n\t}\r\n\t\r\n\t/* Yices does not distinguish formulas and terms, so the mapping\r\n\t * from SMT-LIB is simpler.\r\n\t */\r\n\t\r\n\tstatic Map\u003cString,String\u003e fcnNames = new HashMap\u003cString,String\u003e();\r\n\tstatic Set\u003cString\u003e logicNames = new HashSet\u003cString\u003e();\r\n\tstatic {\r\n\t\t/* SMTLIB\t\t\tYICES\r\n\t\t * (or p q r ...)\t(or p q r ...)\r\n\t\t * (and p q r ...)\t(and p q r ...)\r\n\t\t * (not p)\t\t\t(not p)\r\n\t\t * (=\u003e p q r ...)\t(=\u003e p (=\u003e q r...))\r\n\t\t * (xor p q r ...)\t(/= (/= p q)) r )) ...\r\n\t\t * (= p q r ...)\t(and (= p q) (= q r) ... ) \r\n\t\t * (distinct p q r)\t conjunction of /= \r\n\t\t * true\t\t\t\ttrue\r\n\t\t * false\t\t\tfalse\r\n\t\t * (ite b p q)\t\t(if b p q)\r\n\t\t * (forall ...\t\t(forall (a::Bool b::Int) expr)\r\n\t\t * (exists ...\t\t(exists (a::Bool b::Int) expr)\r\n\t\t * (let ...\t\t\t(let ((aux::int (f (f x)))) (g aux aux))\r\n\t\t * \r\n\t\t * \u003c \u003c= \u003e \u003e=\t\t\u003c \u003c= \u003e \u003e=  : no chaining allowed\r\n\t\t *\r\n\t\t * TERMS\r\n\t\t * + - *\t\t\t+ - * : left associative\r\n\t\t * \t    \t\t\tselect store  - for arrays\r\n\t\t * \r\n\t\t * \r\n\t\t * Yices has / mod div\r\n\t\t */\r\n\t\t\r\n\t}\r\n\t\r\n\r\n\t/* Yices ids:\r\n\t * \t\tFIXME - not  defined what Yices ids can be made of\r\n\t */\r\n\t\r\n\tstatic Map\u003cString,String\u003e bvfcns = new HashMap\u003cString,String\u003e();\r\n\tstatic {\r\n\t\tbvfcns.put(\"bvadd\",\"bv-add\");\r\n\t\tbvfcns.put(\"bvand\",\"bv-and\");\r\n\t\tbvfcns.put(\"bvor\",\"bv-or\");\r\n\t\tbvfcns.put(\"bvmul\",\"bv-mul\");\r\n\t\tbvfcns.put(\"bvshl\",\"bv-shift-left0\"); // second argument is an integer\r\n\t\tbvfcns.put(\"bvlshr\",\"bv-shift-right0\"); // second argument is an integer\r\n\t\tbvfcns.put(\"bvneg\",\"bv-neg\");\r\n\t\tbvfcns.put(\"bvnot\",\"bv-not\");\r\n\t\tbvfcns.put(\"bvudiv\",\"\");\r\n\t\tbvfcns.put(\"bvurem\",\"\");\r\n\t\tbvfcns.put(\"concat\",\"bv-concat\");\r\n\t\tbvfcns.put(\"extract\",\"bv-extract\");\r\n\t\tbvfcns.put(\"bvult\",\"bv-lt\");\r\n\t\tbvfcns.put(\"bvnand\",\"\");\r\n\t\tbvfcns.put(\"bvnor\",\"\");\r\n\t\tbvfcns.put(\"bvxor\",\"\");\r\n\t\tbvfcns.put(\"bvxnor\",\"\");\r\n\t\tbvfcns.put(\"bvcomp\",\"\");\r\n\t\tbvfcns.put(\"bvsub\",\"\");\r\n\t\tbvfcns.put(\"bvsdiv\",\"\");\r\n\t\tbvfcns.put(\"bvsrem\",\"\");\r\n\t\tbvfcns.put(\"bvsmod\",\"\");\r\n\t\tbvfcns.put(\"bvashr\",\"\");\r\n\t\tbvfcns.put(\"bvule\",\"\");\r\n\t\tbvfcns.put(\"bvugt\",\"\");\r\n\t\tbvfcns.put(\"bvuge\",\"\");\r\n\t\tbvfcns.put(\"bvslt\",\"\");\r\n\t\tbvfcns.put(\"bvsle\",\"\");\r\n\t\tbvfcns.put(\"bvsgt\",\"\");\r\n\t\tbvfcns.put(\"bvsge\",\"\");\r\n\t}\r\n\r\n\t\r\n\tpublic class Translator extends IVisitor.NullVisitor\u003cString\u003e {\r\n\t\t\r\n\t\tpublic Translator() {}\r\n\t\t\r\n\t\tprotected String encode(IAttributeValue sym) {\r\n\t\t\treturn org.smtlib.sexpr.Printer.write(sym); // FIXME - is this OK?\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IDecimal e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new VisitorException(\"The yices solver cannot handle decimal literals\",e.pos());\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IStringLiteral e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new VisitorException(\"The yices solver cannot handle string literals\",e.pos());\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(INumeral e) throws IVisitor.VisitorException {\r\n\t\t\treturn e.value().toString();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IBinaryLiteral e) throws IVisitor.VisitorException {\r\n\t\t\treturn \"0b\" + e.value();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IHexLiteral e) throws IVisitor.VisitorException {\r\n\t\t\t// Convert to binary literal\r\n\t\t\tfinal String[] bits = { \"0000\", \"1000\", \"0100\", \"1100\", \"0010\", \"1010\", \"0110\", \"1110\", \"0001\", \"1001\", \"0101\", \"1101\", \"0011\", \"1011\", \"0111\", \"1111\" };\r\n\t\t\tStringBuilder s = new StringBuilder();\r\n\t\t\tfor (int i = 0; i \u003c e.value().length(); i++) {\r\n\t\t\t\tchar c = e.value().charAt(i);\r\n\t\t\t\tint k = c \u003c= '9' ? (c-'0') : c \u003c= 'Z' ? (c - 'A' + 10) : (c - 'a' + 10);\r\n\t\t\t\ts.append(bits[k]);\r\n\t\t\t}\r\n\t\t\treturn s.toString();\r\n\t\t}\r\n\t\t\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IFcnExpr e) throws IVisitor.VisitorException {\r\n\t\t\tIterator\u003cIExpr\u003e iter = e.args().iterator();\r\n\t\t\tif (!iter.hasNext()) throw new VisitorException(\"Did not expect an empty argument list\",e.pos());\r\n\t\t\tIQualifiedIdentifier fcn = e.head();\r\n\t\t\tString fcnname = fcn.headSymbol().accept(this);\r\n\t\t\t// FIXME - should we be doing these comparisons with strings?\r\n\t\t\tif (fcn instanceof ParameterizedIdentifier \u0026\u0026 fcn.headSymbol().toString().equals(fcnname)) {\r\n\t\t\t\tthrow new VisitorException(\"Unknown parameterized function symbol: \" + fcnname, e.pos());\r\n\t\t\t}\r\n\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\tint length  = e.args().size();\r\n\t\t\tif (fcnname.equals(\"or\") || fcnname.equals(\"and\")) {\r\n\t\t\t\t// operators that are still multi-arity\r\n\t\t\t\tsb.append(\"( \");\r\n\t\t\t\tsb.append(fcnname);\r\n\t\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t}\r\n\t\t\t\tsb.append(\" )\");\r\n\t\t\t\treturn sb.toString();\r\n\t\t\t} else if (fcnname.equals(\"=\") || fcnname.equals(\"\u003c\") || fcnname.equals(\"\u003e\") || fcnname.equals(\"\u003c=\") || fcnname.equals(\"\u003e=\")) {\r\n\t\t\t\t// chainable\r\n\t\t\t\treturn remove_chainable(fcnname,iter);\r\n\t\t\t} else if (fcnname.equals(\"xor\")) {\r\n\t\t\t\tfcnname = \"/=\";\r\n\t\t\t\t// left-associative operators that need grouping\r\n\t\t\t\treturn remove_leftassoc(fcnname,length,iter);\r\n\t\t\t} else if (fcnname.equals(\"=\u003e\")) {\r\n\t\t\t\t// right-associative operators that need grouping\r\n\t\t\t\tif (!iter.hasNext()) {\r\n\t\t\t\t\tthrow new VisitorException(\"=\u003e operation without arguments\",e.pos());\r\n\t\t\t\t}\r\n\t\t\t\treturn remove_rightassoc(fcnname,iter);\r\n\t\t\t} else if (fcnname.equals(\"distinct\")) {\r\n\t\t\t\tif (length == 2) {\r\n\t\t\t\t\tsb.append(\"(/=\");\r\n\t\t\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tint j = 0;\r\n\t\t\t\t\tsb.append(\"(and\");\r\n\t\t\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\t\t\tIExpr n = iter.next();\r\n\t\t\t\t\t\tfor (int k = 0; k\u003cj; k++) {\r\n\t\t\t\t\t\t\tsb.append(\" (/= \");\r\n\t\t\t\t\t\t\tsb.append(n.accept(this));\r\n\t\t\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\t\t\tsb.append(e.args().get(k).accept(this));\r\n\t\t\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t++j;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t}\r\n\t\t\t\treturn sb.toString();\r\n\t\t\t} else if (length == 1 \u0026\u0026 fcnname.equals(\"-\")) {\r\n\t\t\t\t// In yices there is no negation: (- x) is just x\r\n\t\t\t\t// We express negation with (- 0 x)\r\n\t\t\t\tsb.append(\"(- 0 \");\r\n\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\tsb.append(\" )\");\r\n\t\t\t\treturn sb.toString();\r\n\t\t\t} else if (length == 2 \u0026\u0026 symTable.arrayTheorySet \u0026\u0026 fcnname.equals(\"select\")) {\r\n\t\t\t\tsb.append(\"(\");\r\n\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t\treturn sb.toString();\r\n\t\t\t} else if (length == 3 \u0026\u0026 symTable.arrayTheorySet \u0026\u0026 fcnname.equals(\"store\")) {\r\n\t\t\t\tsb.append(\"(update \");\r\n\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\tsb.append(\" (\");\r\n\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\tsb.append(\") \");\r\n\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t\treturn sb.toString();\r\n\t\t\t} else {\r\n\t\t\t\tif (symTable.bitVectorTheorySet) {\r\n\t\t\t\t\t// Predefined: bvadd, bvmul, bvneg, bvnot, bvshl, bvlshr, concat, extract, bvult, bvudiv, bvurem, bvand, bvor\r\n\t\t\t\t\tString newname = bvfcns.get(fcnname);\r\n\t\t\t\t\tif (newname == null) {\r\n\t\t\t\t\t\t// continue\r\n\t\t\t\t\t} else if (newname.isEmpty()) {\r\n\t\t\t\t\t\tthrow new VisitorException(\"The BitVector function \" + fcnname + \" is not implemented in yices\",e.pos());\r\n\t\t\t\t\t} else if (fcnname.equals(\"extract\")) {\r\n\t\t\t\t\t\tsb.append(\"(bv-extract \");\r\n\t\t\t\t\t\tIParameterizedIdentifier pid = (IParameterizedIdentifier)fcn;\r\n\t\t\t\t\t\tsb.append(pid.numerals().get(1).intValue());\r\n\t\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\t\tsb.append(pid.numerals().get(0).intValue());\r\n\t\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t\t\treturn sb.toString();\r\n\t\t\t\t\t} else if (fcnname.equals(\"bvshl\") || fcnname.equals(\"bvlshr\")) {\r\n\t\t\t\t\t\tthrow new VisitorException(\"The BitVector function \" + fcnname + \" is not implementetd in yices\",e.pos());\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfcnname = newname;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// no associativity \r\n\t\t\t\tsb.append(\"( \");\r\n\t\t\t\tsb.append(fcnname);\r\n\t\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t}\r\n\t\t\t\tsb.append(\" )\");\r\n\t\t\t\treturn sb.toString();\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t\r\n\t\t//@ requires iter.hasNext();\r\n\t\tprivate \u003cT extends IExpr\u003e String remove_rightassoc(String fcnname, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\r\n\t\t\tT n = iter.next();\r\n\t\t\tif (!iter.hasNext()) {\r\n\t\t\t\treturn n.accept(this);\r\n\t\t\t} else {\r\n\t\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\t\tsb.append(\"(\");\r\n\t\t\t\tsb.append(fcnname);\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(n.accept(this));\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(remove_rightassoc(fcnname,iter));\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t\treturn sb.toString();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//@ requires iter.hasNext();\r\n\t\t//@ requires length \u003e 0;\r\n\t\tprivate \u003cT extends IExpr\u003e String remove_leftassoc(String fcnname, int length, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\r\n\t\t\tif (length == 1) {\r\n\t\t\t\treturn iter.next().accept(this);\r\n\t\t\t} else {\r\n\t\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\t\tsb.append(\"(\");\r\n\t\t\t\tsb.append(fcnname);\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(remove_leftassoc(fcnname,length-1,iter));\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t\treturn sb.toString();\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t//@ requires iter.hasNext();\r\n\t\t//@ requires length \u003e 0;\r\n\t\tprivate \u003cT extends IAccept\u003e String remove_chainable(String fcnname, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\r\n\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\tsb.append(\"(and \");\r\n\t\t\tT left = iter.next();\r\n\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\tsb.append(\"(\");\r\n\t\t\t\tsb.append(fcnname);\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(left.accept(this));\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append((left=iter.next()).accept(this));\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t}\r\n\t\t\tsb.append(\")\");\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(ISymbol e) throws IVisitor.VisitorException {\r\n\t\t\treturn e.value(); // FIXME - translate\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IKeyword e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new VisitorException(\"Did not expect a Keyword in an expression to be translated\",e.pos());\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IError e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new VisitorException(\"Did not expect a Error token in an expression to be translated\", e.pos());\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IParameterizedIdentifier e) throws IVisitor.VisitorException {\r\n\t\t\t// FIXME - use default printer properly to print Symbol\r\n\t\t\tthrow new IVisitor.VisitorException(\"Unsupported parameterized function symbol: \" + e.headSymbol().toString(),e.pos());\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IAsIdentifier e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new UnsupportedOperationException(\"visit-IAsIdentifier\");\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IForall e) throws IVisitor.VisitorException {\r\n\t\t\tStringBuffer sb = new StringBuffer();\r\n\t\t\tsb.append(\"(forall (\");\r\n\t\t\tfor (IDeclaration d: e.parameters()) {\r\n\t\t\t\tsb.append(d.parameter().accept(this));\r\n\t\t\t\tsb.append(\"::\");\r\n\t\t\t\tsb.append(d.sort().accept(this));\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t}\r\n\t\t\tsb.append(\") \");\r\n\t\t\tsb.append(e.expr().accept(this));\r\n\t\t\tsb.append(\")\");\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IExists e) throws IVisitor.VisitorException {\r\n\t\t\tStringBuffer sb = new StringBuffer();\r\n\t\t\tsb.append(\"(exists (\");\r\n\t\t\tfor (IDeclaration d: e.parameters()) {\r\n\t\t\t\tsb.append(d.parameter().accept(this));\r\n\t\t\t\tsb.append(\"::\");\r\n\t\t\t\tsb.append(d.sort().accept(this));\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t}\r\n\t\t\tsb.append(\") \");\r\n\t\t\tsb.append(e.expr().accept(this));\r\n\t\t\tsb.append(\")\");\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(ILet e) throws IVisitor.VisitorException {\r\n\t\t\tStringBuffer sb = new StringBuffer();\r\n\t\t\tsb.append(\"(let (\");\r\n\t\t\tfor (IBinding d: e.bindings()) {\r\n\t\t\t\tsb.append(\"(\");\r\n\t\t\t\tsb.append(d.parameter().accept(this));\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(d.expr().accept(this));\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t}\r\n\t\t\tsb.append(\") \");\r\n\t\t\tsb.append(e.expr().accept(this));\r\n\t\t\tsb.append(\")\");\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IAttribute\u003c?\u003e e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new UnsupportedOperationException(\"visit-IAttribute\");\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IAttributedExpr e) throws IVisitor.VisitorException {\r\n\t\t\tIExpr expr = e.expr();\r\n\t\t\tIAttribute\u003c?\u003e attr = e.attributes().get(0);\r\n\t\t\tif (attr.keyword().toString().equals(\":named\")) {\r\n\t\t\t\tString name = encode(attr.attrValue());\r\n\t\t\t\tString ex = expr.accept(this);\r\n\t\t\t\tString sort = typemap.get(expr).accept(this);\r\n\t\t\t\tString def = \"(define \" + name + \"::\" + sort + \" \" + ex + \")\";\r\n\t\t\t\tIResponse response = send(e.pos(),def);\r\n\t\t\t\tif (response != null) {\r\n\t\t\t\t\tthrow new VisitorException(\"Failed to define attributed expression: \" + response, e.pos()); // FIXME - error message format?\r\n\t\t\t\t}\r\n\t\t\t\treturn ex;\r\n\t\t\t} else {\r\n\t\t\t\tthrow new VisitorException(\"Unexpected kind of keyword: \" + smtConfig.defaultPrinter.toString(attr.keyword()),attr.pos());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IDeclaration e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new UnsupportedOperationException(\"visit-IDeclaration\");\r\n\t\t}\r\n\r\n\t\tpublic String visit(ISort.IFamily s) throws IVisitor.VisitorException {\r\n\t\t\treturn s.identifier().accept(this);\r\n\t\t}\r\n\t\t\r\n\t\tpublic String visit(ISort.IAbbreviation s) throws IVisitor.VisitorException {\r\n\t\t\tthrow new UnsupportedOperationException(\"visit-ISort.IAbbreviation\");\r\n\t\t}\r\n\t\t\r\n\t\tpublic String visit(ISort.IApplication s) throws IVisitor.VisitorException {\r\n\t\t\tif (s.isBool()) return \"bool\";\r\n\t\t\tString sort = s.family().headSymbol().accept(this);\r\n\t\t\tif (s.parameters().size() == 0) {\r\n\t\t\t\tif (\"Int\".equals(sort)) return \"int\";\r\n\t\t\t\tif (\"Real\".equals(sort)) return \"real\";\r\n\t\t\t\tif (symTable.bitVectorTheorySet \u0026\u0026 \"BitVec\".equals(sort)) {\r\n\t\t\t\t\tString sbv = \"(bitvector \";\r\n\t\t\t\t\tint k = ((IParameterizedIdentifier)s.family()).numerals().get(0).intValue();\r\n\t\t\t\t\tsbv = sbv + k + \")\";\r\n\t\t\t\t\treturn sbv;\r\n\t\t\t\t}\r\n\t\t\t\treturn sort;\r\n\t\t\t} else {\r\n\t\t\t\tif (symTable.arrayTheorySet \u0026\u0026 \"Array\".equals(sort)) {\r\n\t\t\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\t\t\tsb.append(\"(-\u003e \");\r\n\t\t\t\t\tsb.append(s.parameters().get(0).accept(this));\r\n\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\tsb.append(s.parameters().get(1).accept(this));\r\n\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t\treturn sb.toString();\r\n\t\t\t\t}\r\n\t\t\t\tthrow new VisitorException(\"Yices does not support user-defined parameterized sorts: \" + s, s.pos());\r\n\t\t\t}\r\n\t\t}\r\n\t\tpublic String visit(ISort.IFcnSort s) {\r\n\t\t\tthrow new UnsupportedOperationException(\"visit-ISort.IFcnSort\");\r\n\t\t}\r\n\t\tpublic String visit(ISort.IParameter s) {\r\n\t\t\tthrow new UnsupportedOperationException(\"visit-ISort.IParameter\");\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t}\r\n}\r\n",
        "name": "Solver_yices.java",
        "path": "smt/lip6.smtlib.SMT/src/org/smtlib/solvers/Solver_yices.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.SMT/src/org/smtlib/solvers/Solver_yices.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 699,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 717,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 718,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires length \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 735,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 736,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires length \u003e 0;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib;\r\n\r\nimport java.io.IOException;\r\nimport java.nio.CharBuffer;\r\n\r\n/** This class implements a CharSequence that obtains its characters from a source of characters\r\n * of unknown length; it also provides some functionality to retain the characters and compute line numbers.  \r\n * \u003cP\u003e\r\n * The characters \r\n * read are held in an internal char array, whose size grows as needed; it starts as initialSize and\r\n * is expanded to currentSize*sizeMultiple + sizeIncrease whenever needed.\r\n * \u003cP\u003e\r\n * The CharSequenceReader is an unconventional CharSequence in that its length() is not known; \r\n * whether this will cause problems\r\n * in some uses of the CharSequenceReader is unknown.  The user should not use the value of length()\r\n * directly; it seems to work in the ways it is called from Pattern.matcher.\r\n * @author David R. Cok\r\n *\r\n */\r\npublic abstract class CharSequenceInfinite implements CharSequence {\r\n\r\n\t/** This interface is used to create prompters.  A CharSequenceInfinite object needs on occasion to\r\n\t * obtain new input, which it does by calling readChars().  readChars() invokes the prompter to \r\n\t * communicate to the source of input that more data is needed.  As an example, if the input comes from\r\n\t * interactive input, the prompter may print out prompt characters.\r\n\t */\r\n\tpublic static interface IPrompter {\r\n\t\t/** Implement this call-back to do whatever user actions are needed to\r\n\t\t * cause more input to be available.\r\n\t\t */\r\n\t\tvoid prompt();\r\n\t}\r\n\t\r\n\t/** The prompter object */\r\n\tpublic /*@Nullable*/ IPrompter prompter = null;\r\n\t\r\n\t/** Constructor for a new instance\r\n\t * \r\n\t * @param initialSize the beginning size of the internal char array\r\n\t * @param sizeIncrease the amount to add to the current size of the internal char array when the array needs expanding\r\n\t * @param sizeMultiple the factor by which to multiply the current size of the internal char array when it needs expanding\r\n\t */\r\n\t//@ requires initialSize \u003e 0 \u0026\u0026 sizeIncrease \u003e= 0 \u0026\u0026 sizeMultiple \u003e= 1;\r\n\t//@ requires !(sizeIncrease == 0 \u0026\u0026 sizeMultiple == 1)\r\n\tpublic CharSequenceInfinite(int initialSize, int sizeIncrease, double sizeMultiple) {\r\n\t\tthis.sizeIncrease = sizeIncrease;\r\n\t\tthis.sizeMultiple = sizeMultiple;\r\n\t\tbuf = new char[initialSize];\r\n\t\tthis.amountRead = 0;\r\n\t\tthis.length = Integer.MAX_VALUE;\r\n\t}\r\n\r\n\t/** The amount by which to increase the internal char array when needed */\r\n\t//@ invariant sizeIncrease \u003e= 0;\r\n\tprotected int sizeIncrease;\r\n\r\n\t/** The factor by which to increase the size of the internal char array when needed */\r\n\t//@ invariant sizeMultiple \u003e= 1 \u0026\u0026 (sizeIncrease==0 ==\u003e sizeMultiple \u003e 1);\r\n\tprotected double sizeMultiple;\r\n\r\n\t/** The internal char array that holds characters as they are read */\r\n\tprotected char /*@NonNull*/[] buf;\r\n\r\n\t/** The number of characters read so far (and in the char array) */\r\n\t//@ invariant amountRead \u003e= 0 \u0026\u0026 amountRead \u003c= buf.length;\r\n\tprotected int amountRead;\r\n\r\n\t/** The implicit length of the CharSequence; note that this length may change as characters are read */\r\n\t//@ invariant length \u003e= 0 \u0026\u0026 length \u003e= amountRead;\r\n\tprotected int length;\r\n\r\n\t/** The character to use to mark the end of input */\r\n\tfinal public static char endChar = (char)25;\r\n\r\n\t//@ constraint (\\forall int i; 0 \u003c= i \u003c \\old(amountRead); \\old(buf[i]) == buf[i]);\r\n\t//@ constraint amountRead \u003e= \\old(amountRead);\r\n\t\r\n\t/** Returns the char at the given index; this may block while input is read if the char has\r\n\t * not been read before.  An IOException that occurs while reading input is converted to an\r\n\t * undeclared RuntimeException. \r\n\t */\r\n\t//@ requires index \u003e= 0;\r\n\t//@ assigns buf, buf[amountRead..], amountRead, length;\r\n\t//@ ensures index \u003c amountRead;\r\n\t@Override\r\n\tpublic char charAt(int index) {\r\n\t\tif (index \u003e= amountRead) {\r\n\t\t\tif (index \u003e= buf.length) {\r\n\t\t\t\t// We need +1 because one needs a buffer of at least size 2 to include index=1\r\n\t\t\t\t// We add an additional +1 so that there is room to hold an End-of-input character if necessary\r\n\t\t\t\texpandBuffer(index+2);\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\twhile (amountRead \u003c= index) {\r\n\t\t\t\t\tif (!readChars()){\r\n\t\t\t\t\t\t//SMT.out.println(\"END OF INPUT READ\");\r\n\t\t\t\t\t\tbuf[amountRead++] = endChar;\r\n\t\t\t\t\t\tlength = amountRead;\r\n\t\t\t\t\t\treturn endChar;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\t// Note: we catch IOException and turn it into a RuntimeException\r\n\t\t\t\t// (so it does not have to be declared) because the inherited \r\n\t\t\t\t// signature for charAt(int) does not declare any thrown exceptions\r\n\t\t\t\tthrow new RuntimeException(e);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn buf[index];\r\n\t}\r\n\t\r\n\t/** Reads more characters into the buffer; may block until some are read;\r\n\t * returns false if end of input has been reached,\r\n\t * in which case no additional chars should have been read.  Does not expand the\r\n\t * buffer, so the buffer must have extra space in it when readChars() is called.\r\n\t * @return true if characters were read, false if no chars were read and end of input was reached\r\n\t */\r\n\t//@ requires buf.length \u003e amountRead;\r\n\t//@ modifies buf,buf[amountRead..],amountRead;\r\n\t//@ ensures \\result =\u003e amountRead \u003e \\old(amountRead);\r\n\t//@ ensures !\\result ==\u003e amountRead == \\old(amountRead);\r\n\t//@ ensures buf[0..\\old(amountRead)-1] == \\old(buf[0..amountRead-1]);\r\n\tabstract protected boolean readChars() throws java.io.IOException ;\r\n\t\r\n\t/** This expands the buffer to be at least as large as the argument; the buffer is expanded\r\n\t * even if it is already of adequate size.\r\n\t * \r\n\t * @param newSize minimum size of the expanded buffer\r\n\t */\r\n\t//@ requires newSize \u003e 0;\r\n\t//@ modifies buf;\r\n\t//@ ensures buf.length \u003e= newSize \u0026\u0026 buf.length \u003e \\old(buf.length);\r\n\t//@ ensures (\\forall int i; 0\u003c=i \u0026\u0026 i\u003camountRead; buf[i] == \\old(buf[i]));\r\n\tprivate void expandBuffer(int newSize) {\r\n\t\tint newlength = buf.length;\r\n\t\tdo {\r\n\t\t\tint k = (int) Math.ceil(newlength*sizeMultiple+sizeIncrease);\r\n\t\t\tnewlength = (k \u003c= newlength) ? newlength+100 : k; // check for both bad parameters and for integer overflow\r\n\t\t} while (newSize \u003e newlength);\r\n\t\tchar[] nbuf = new char[newlength];\r\n\t\tSystem.arraycopy(buf,0,nbuf,0,amountRead);\r\n\t\tbuf = nbuf;\r\n\t}\r\n\r\n\t/** Returns the length of the CharSequence; for this implementation, the return value is at\r\n\t * least as great as the unknown length of the CharSequence.  The value is correct once the\r\n\t * end of input has been reached.\r\n\t * @return the length of the CharSequence\r\n\t */\r\n\t@Override\r\n\tpublic int length() {\r\n\t\treturn this.length;\r\n\t}\r\n\r\n\t/** Returns a subsequence of this CharSequence, of length end-start.\r\n\t * CAUTION: This method can wrap a portion of the internal char array, but then\r\n\t * the char array can be expanded, allocating a new char array - so just don't rely on\r\n\t * changes to the sub-sequence to be reflected in the parent array.\r\n\t * @param start the starting index of the subsequence\r\n\t * @param end one past the last character included in the subsequence\r\n\t * \r\n\t */\r\n\t@Override\r\n\tpublic CharSequence subSequence(int start, int end) {\r\n\t\tcharAt(end-1); // Just to be sure it has been read\r\n\t\treturn CharBuffer.wrap(buf,start,end-start);\r\n\t}\r\n\t\r\n}\r\n",
        "name": "CharSequenceInfinite.java",
        "path": "smt/lip6.smtlib.SMT/src/org/smtlib/CharSequenceInfinite.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.SMT/src/org/smtlib/CharSequenceInfinite.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 47,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires initialSize \u003e 0 \u0026\u0026 sizeIncrease \u003e= 0 \u0026\u0026 sizeMultiple \u003e= 1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 48,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires !(sizeIncrease == 0 \u0026\u0026 sizeMultiple == 1)\r"
        },
        {
          "limitHit": false,
          "lineNumber": 86,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires index \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 88,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures index \u003c amountRead;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 122,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires buf.length \u003e amountRead;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 124,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result =\u003e amountRead \u003e \\old(amountRead);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 125,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures !\\result ==\u003e amountRead == \\old(amountRead);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 126,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures buf[0..\\old(amountRead)-1] == \\old(buf[0..amountRead-1]);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 134,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires newSize \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 136,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures buf.length \u003e= newSize \u0026\u0026 buf.length \u003e \\old(buf.length);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 137,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures (\\forall int i; 0\u003c=i \u0026\u0026 i\u003camountRead; buf[i] == \\old(buf[i]));\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.solvers;\r\n\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.PrintStream;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\nimport org.smtlib.*;\r\nimport org.smtlib.ICommand.Ideclare_fun;\r\nimport org.smtlib.ICommand.Ideclare_sort;\r\nimport org.smtlib.ICommand.Idefine_fun;\r\nimport org.smtlib.ICommand.Idefine_sort;\r\nimport org.smtlib.IExpr.IAsIdentifier;\r\nimport org.smtlib.IExpr.IAttribute;\r\nimport org.smtlib.IExpr.IAttributeValue;\r\nimport org.smtlib.IExpr.IAttributedExpr;\r\nimport org.smtlib.IExpr.IBinaryLiteral;\r\nimport org.smtlib.IExpr.IBinding;\r\nimport org.smtlib.IExpr.IDecimal;\r\nimport org.smtlib.IExpr.IDeclaration;\r\nimport org.smtlib.IExpr.IError;\r\nimport org.smtlib.IExpr.IExists;\r\nimport org.smtlib.IExpr.IFcnExpr;\r\nimport org.smtlib.IExpr.IForall;\r\nimport org.smtlib.IExpr.IHexLiteral;\r\nimport org.smtlib.IExpr.IKeyword;\r\nimport org.smtlib.IExpr.ILet;\r\nimport org.smtlib.IExpr.INumeral;\r\nimport org.smtlib.IExpr.IParameterizedIdentifier;\r\nimport org.smtlib.IExpr.IQualifiedIdentifier;\r\nimport org.smtlib.IExpr.IStringLiteral;\r\nimport org.smtlib.IExpr.ISymbol;\r\nimport org.smtlib.IParser.ParserException;\r\nimport org.smtlib.IResponse.IPair;\r\nimport org.smtlib.impl.Pos;\r\nimport org.smtlib.impl.Response;\r\nimport org.smtlib.impl.SMTExpr.ParameterizedIdentifier;\r\nimport org.smtlib.sexpr.ISexpr;\r\n\r\n// FIXME - in some commands, like assert, push, pop, the effect in solver_test happens even if the effect in the \r\n// solver itself causes an error, putting the two out of synch; also, push and pop can happen partially\r\n/** This class is the adapter for the Yices SMT solver */\r\npublic class Solver_yices2 extends Solver_test implements ISolver {\r\n\t/** This holds the command-line arguments used to launch the solver;\r\n\t * the path to the executable is inserted in cmds[0]. */\r\n\tString cmds[] = new String[]{\"\",\"--mode=interactive\"};\r\n\t\r\n\t/** Holds the driver for external processes */\r\n\tprivate SolverProcess solverProcess;\r\n\t\r\n\t/** The string that indicates an Error in the solver reply */\r\n\tstatic public final String errorIndication = \"Error\";\r\n\r\n\t/** Records the values of options */\r\n\t{ \r\n\t\toptions.putAll(Utils.defaults);\r\n\t}\r\n\t\r\n\t/** Creates but does not start a solver instance */\r\n\tpublic Solver_yices2(SMT.Configuration smtConfig, String executable) {\r\n\t\tsuper(smtConfig,\"\");\r\n\t\tcmds[0] = executable;\r\n\t\tsolverProcess = new SolverProcess(cmds,\"yices\u003e \",smtConfig) {\r\n\t\t\t@Override\r\n\t\t\tpublic String listen() throws IOException {\r\n\t\t\t\t// FIXME - need to put the two reads in parallel, otherwise one might block on a full buffer, preventing the other from completing\r\n\t\t\t\tString err = listenThru(errors,endMarker);\r\n\t\t\t\tString out = listenThru(fromProcess,null);\r\n\t\t\t\tif (err.endsWith(endMarker)) err = err.substring(0,err.length()-endMarker.length());\r\n\t\t\t\tif (log != null) {\r\n\t\t\t\t\tif (!out.isEmpty()) { log.write(\";;OUT: \"); log.write(out); log.write(eol); } // input usually ends with a prompt and no line terminator\r\n\t\t\t\t\tif (!err.isEmpty()) { log.write(\";;ERR: \"); log.write(err); } // input usually ends with a line terminator, we think\r\n\t\t\t\t}\r\n\t\t\t\treturn err.isEmpty() ? out : err;\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic IResponse start() {\r\n\t\tsuper.start();\r\n\t\ttry {\r\n\t\t\tsolverProcess.start(true);\r\n\t\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Started yices2 \" + (solverProcess!=null));\r\n//\t\t\tsolverProcess.sendAndListen(\"(define mod :: (-\u003e int int int))\\n\");\r\n//\t\t\tsolverProcess.sendAndListen(\"(define div :: (-\u003e int int int))\\n\");\r\n\t\t\t\r\n\t\t\treturn smtConfig.responseFactory.success();\r\n\t\t} catch (Exception e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to start process \" + cmds[0] + \" : \" + e.getMessage());\r\n\t\t}\r\n\t}\r\n\t\r\n\tprotected /*@Nullable*/ IResponse send(IPos pos, String... solverCmds) {\r\n\t\ttry {\r\n\t\t\tfor (String s: solverCmds) solverProcess.sendNoListen(s);\r\n\t\t\tString response = solverProcess.sendAndListen(\"\\n\");\r\n\t\t\tif (response.contains(errorIndication) || response.contains(\"does not support quantifiers\")) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(response,pos);\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(e.getMessage(),pos);\r\n\t\t}\r\n\t}\r\n\r\n\t// FIXME - are we capturing errors from the solver?\r\n\t\r\n\t@Override\r\n\tpublic IResponse exit() {\r\n\t\tIResponse r = send(null,\"(exit)\");\r\n\t\tif (r != null) return r;\r\n\t\tsolverProcess.exit();\r\n\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Ended yices2 \");\r\n\t\treturn smtConfig.responseFactory.success();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse assertExpr(IExpr sexpr) {\r\n\t\ttry {\r\n//\t\t\tIResponse status = super.assertExpr(sexpr);\r\n//\t\t\tif (!status.isOK()) return status;\r\n\r\n\t\t\tIResponse response = send(sexpr.pos(),\"(assert \",translate(sexpr),\" )\");\r\n\t\t\tif (response != null) return response;\r\n\t\t\treturn smtConfig.responseFactory.success();\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Yices assert command failed: \" + e.getMessage());\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse check_sat() {\r\n//\t\tIResponse res = super.check_sat();\r\n//\t\tif (res.isError()) return res;\r\n\t\tIResponse res = smtConfig.responseFactory.success();\r\n\t\ttry {\r\n\t\t\tif (smtConfig.timeout\u003e0) {\r\n\t\t\t\tString sq = solverProcess.sendAndListen(\"(set-timeout \"+(int)smtConfig.timeout+\")\\r\\n\");\r\n\t\t\t\tif (sq.contains(errorIndication)) {\r\n\t\t\t\t\treturn smtConfig.responseFactory.error(sq);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tString s = solverProcess.sendAndListen(\"(check)\\r\\n\");\r\n\t\t\tif (s.contains(errorIndication)) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(s);\r\n\t\t\t}\r\n\t\t\t//System.out.println(\"HEARD: \" + s);\r\n\t\t\tif (s.contains(\"unsat\")) res = smtConfig.responseFactory.unsat();\r\n\t\t\telse if (s.contains(\"sat\")) res = smtConfig.responseFactory.sat();\r\n\t\t\telse res = smtConfig.responseFactory.unknown();\r\n\t\t\tcheckSatStatus = res;\r\n\t\t} catch (IOException e) {\r\n\t\t\tres = smtConfig.responseFactory.error(\"Failed to check-sat\");\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse pop(int number) {\r\n//\t\tIResponse status = super.pop(number);\r\n//\t\tif (status.isError()) return status;\r\n\t\twhile (number-- \u003e 0) {\r\n\t\t\tIResponse response = send(null,\"(pop)\");\r\n\t\t\tif (response != null) return response;\r\n\t\t}\r\n\t\treturn smtConfig.responseFactory.success();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse push(int number) {\r\n//\t\tIResponse status = super.push(number);\r\n//\t\tif (status.isError()) return status;\r\n\t\twhile (number-- \u003e 0) {\r\n\t\t\tIResponse response = send(null,\"(push)\");\r\n\t\t\tif (response != null) return response;\r\n\t\t}\r\n\t\treturn smtConfig.responseFactory.success();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse set_logic(String logicName, /*@Nullable*/ IPos pos) {\r\n\t\tboolean lSet = logicSet;\r\n//\t\tIResponse status = super.set_logic(logicName,pos);\r\n//\t\tif (!status.isOK()) return status;\r\n\r\n\t\t// FIXME - discrimninate among logics\r\n\t\tsymTable.arrayTheorySet = true;\r\n\t\tif (lSet) {\r\n\t\t\tif (!smtConfig.relax) return smtConfig.responseFactory.error(\"Logic is already set\");\r\n\t\t\tIResponse response = send(pos,\"(reset)\");\r\n\t\t\tif (response != null) return response;\r\n\t\t}\r\n\t\treturn smtConfig.responseFactory.success();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse set_option(IKeyword key, IAttributeValue value) {\r\n\t\tString option = key.value();\r\n\t\tif (Utils.PRINT_SUCCESS.equals(option)) {\r\n\t\t\tif (!(Utils.TRUE.equals(value) || Utils.FALSE.equals(value))) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be 'true' or 'false'\");\r\n\t\t\t}\r\n\t\t\t// FIXME - improve the following line\r\n\t\t\t((Response.Factory)smtConfig.responseFactory).printSuccess = !Utils.FALSE.equals(value);\r\n\t\t}\r\n\t\tif (Utils.INTERACTIVE_MODE.equals(option) || \r\n\t\t\t\tUtils.PRODUCE_MODELS.equals(option) ||\r\n\t\t\t\tUtils.PRODUCE_UNSAT_CORES.equals(option)) {\r\n\t\t\tif (logicSet) return smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be set before the set-logic command\");\r\n\t\t} else if (Utils.PRODUCE_ASSIGNMENTS.equals(option) || \r\n\t\t\t\tUtils.PRODUCE_PROOFS.equals(option)) {\r\n\t\t\tif (logicSet) return smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be set before the set-logic command\");\r\n\t\t\treturn smtConfig.responseFactory.unsupported();\r\n\t\t}\r\n\t\tif (Utils.VERBOSITY.equals(option)) {\r\n\t\t\tIAttributeValue v = options.get(option);\r\n\t\t\tsmtConfig.verbose = (v instanceof INumeral) ? ((INumeral)v).intValue() : 0;\r\n\t\t} else if (Utils.DIAGNOSTIC_OUTPUT_CHANNEL.equals(option)) {\r\n\t\t\t// Actually, v should never be anything but IStringLiteral - that should\r\n\t\t\t// be checked during parsing\r\n\t\t\tString name = (value instanceof IStringLiteral)? ((IStringLiteral)value).value() : \"stderr\";\r\n\t\t\tif (name.equals(\"stdout\")) {\r\n\t\t\t\tsmtConfig.log.diag = System.out;\r\n\t\t\t} else if (name.equals(\"stderr\")) {\r\n\t\t\t\tsmtConfig.log.diag = System.err;\r\n\t\t\t} else {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tFileOutputStream f = new FileOutputStream(name,true); // append\r\n\t\t\t\t\tsmtConfig.log.diag = new PrintStream(f);\r\n\t\t\t\t} catch (java.io.IOException e) {\r\n\t\t\t\t\treturn smtConfig.responseFactory.error(\"Failed to open or write to the diagnostic output \" + e.getMessage(),value.pos());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (Utils.REGULAR_OUTPUT_CHANNEL.equals(option)) {\r\n\t\t\t// Actually, v should never be anything but IStringLiteral - that should\r\n\t\t\t// be checked during parsing\r\n\t\t\tString name = (value instanceof IStringLiteral)?((IStringLiteral)value).value() : \"stdout\";\r\n\t\t\tif (name.equals(\"stdout\")) {\r\n\t\t\t\tsmtConfig.log.out = System.out;\r\n\t\t\t} else if (name.equals(\"stderr\")) {\r\n\t\t\t\tsmtConfig.log.out = System.err;\r\n\t\t\t} else {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tFileOutputStream f = new FileOutputStream(name,true); // append\r\n\t\t\t\t\tsmtConfig.log.out = new PrintStream(f);\r\n\t\t\t\t} catch (java.io.IOException e) {\r\n\t\t\t\t\treturn smtConfig.responseFactory.error(\"Failed to open or write to the regular output \" + e.getMessage(),value.pos());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\toptions.put(option,value);\r\n\t\treturn smtConfig.responseFactory.success();\r\n\t}\r\n\r\n//\t@Override\r\n//\tpublic IResponse get_option(IKeyword key) {\r\n//\t\tString option = key.value();\r\n//\t\tIAttributeValue value = options.get(option);\r\n//\t\tif (value == null) return smtConfig.responseFactory.unsupported();\r\n//\t\treturn value;\r\n//\t}\r\n\r\n\t@Override\r\n\tpublic IResponse get_info(IKeyword key) {\r\n\t\tString option = key.value();\r\n\t\tIAttributeValue lit;\r\n\t\tif (\":error-behavior\".equals(option)) {\r\n\t\t\tlit = smtConfig.exprFactory.symbol(Utils.CONTINUED_EXECUTION); // FIXME\r\n\t\t} else if (\":status\".equals(option)) {\r\n\t\t\treturn checkSatStatus==null ? smtConfig.responseFactory.unsupported() : checkSatStatus; \r\n\t\t} else if (\":all-statistics\".equals(option)) {\r\n\t\t\treturn smtConfig.responseFactory.unsupported(); // FIXME\r\n\t\t} else if (\":reason-unknown\".equals(option)) {\r\n\t\t\treturn smtConfig.responseFactory.unsupported(); // FIXME\r\n\t\t} else if (\":authors\".equals(option)) {\r\n\t\t\tlit = smtConfig.exprFactory.unquotedString(\"SRI\");\r\n\t\t} else if (\":version\".equals(option)) {\r\n\t\t\tlit = smtConfig.exprFactory.unquotedString(\"2.1\");\r\n\t\t} else if (\":name\".equals(option)) {\r\n\t\t\tlit = smtConfig.exprFactory.unquotedString(\"yices2\");\r\n\t\t} else {\r\n\t\t\treturn smtConfig.responseFactory.unsupported();\r\n\t\t}\r\n\t\tIAttribute\u003c?\u003e attr = smtConfig.exprFactory.attribute(key,lit);\r\n\t\treturn smtConfig.responseFactory.get_info_response(attr);\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic IResponse declare_fun(Ideclare_fun cmd) {\r\n\t\ttry {\r\n//\t\t\tIResponse status = super.declare_fun(cmd);\r\n//\t\t\tif (!status.isOK()) return status;\r\n\r\n\t\t\tString name = translate(cmd.symbol());\r\n\t\t\tString yicescmd;\r\n\t\t\tif (cmd.argSorts().size() == 0) {\r\n\t\t\t\tyicescmd = \"(define \" + name + \"::\" + translate(cmd.resultSort()) + \")\";\r\n\t\t\t} else {\r\n\t\t\t\tyicescmd = \"(define \" + name + \"::(-\u003e\";\r\n\t\t\t\tfor (ISort s: cmd.argSorts()) {\r\n\t\t\t\t\tyicescmd = yicescmd + \" \" + translate(s);\r\n\t\t\t\t}\r\n\t\t\t\tyicescmd = yicescmd + \" \" + translate(cmd.resultSort()) + \"))\";\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tIResponse response = send(null,yicescmd);\r\n\t\t\tif (response != null) return response;\r\n\t\t\treturn smtConfig.responseFactory.success();\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"declare-fun command failed: \" + e.getMessage());\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse define_fun(Idefine_fun cmd) {\r\n\t\ttry {\r\n//\t\t\tIResponse status = super.define_fun(cmd);\r\n//\t\t\tif (!status.isOK()) return status;\r\n\t\t\t\r\n\t\t\tString name = translate(cmd.symbol());\r\n\t\t\tStringBuilder yicescmd = new StringBuilder();;\r\n\t\t\tif (cmd.parameters().size() == 0) {\r\n\t\t\t\tyicescmd.append(\"(define \" + name + \"::\" + translate(cmd.resultSort()) + \" \" \r\n\t\t\t\t\t\t\t\t+ translate(cmd.expression()));\r\n\t\t\t} else {\r\n\t\t\t\tyicescmd.append(\"(define \" + name + \"::(-\u003e\");\r\n\t\t\t\tfor (IDeclaration d: cmd.parameters()) {\r\n\t\t\t\t\tyicescmd.append(\" \" + translate(d.sort()));\r\n\t\t\t\t}\r\n\t\t\t\tyicescmd.append(\" \" + translate(cmd.resultSort()) + \") \");\r\n\t\t\t\tyicescmd.append(\"(lambda (\");\r\n\t\t\t\tfor (IDeclaration d: cmd.parameters()) {\r\n\t\t\t\t\tyicescmd.append(translate(d.parameter()));\r\n\t\t\t\t\tyicescmd.append(\"::\");\r\n\t\t\t\t\tyicescmd.append(translate(d.sort()));\r\n\t\t\t\t\tyicescmd.append(\" \");\r\n\t\t\t\t}\r\n\t\t\t\tyicescmd.append(\") \");\r\n\t\t\t\tyicescmd.append(translate(cmd.expression()));\r\n\t\t\t\tyicescmd.append(\")\");\r\n\t\t\t}\r\n\t\t\tyicescmd.append(\")\");\r\n\t\t\tIResponse response = send(null,yicescmd.toString());\r\n\t\t\tif (response != null) return response;\r\n\t\t\treturn smtConfig.responseFactory.success();\r\n\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"assert command failed: \" + e.getMessage());\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse declare_sort(Ideclare_sort cmd) {\r\n\t\ttry {\r\n//\t\t\tIResponse status = super.declare_sort(cmd);\r\n//\t\t\tif (!status.isOK()) return status;\r\n\t\t\t\r\n\t\t\tif (cmd.arity().intValue() == 0) {\r\n\t\t\t\tIResponse response = send(cmd.sortSymbol().pos(),\"(define-type \" + translate(cmd.sortSymbol()) + \")\");\r\n\t\t\t\tif (response != null) return response;\r\n\t\t\t} else {\r\n\t\t\t\tthrow new IVisitor.VisitorException(\"Yices2 does not support defining parameterized types\",null);\r\n\t\t\t}\r\n\t\t\treturn smtConfig.responseFactory.success();\r\n\t\t\t\r\n\t\t\t// FIXME - Yices does not seem to allow creating arbitrary new types\r\n\t\t\t// Besides Yices uses structural equivalence.\r\n\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Yices2 declare-sort command failed: \" + e.getMessage(),e.pos());\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse define_sort(Idefine_sort cmd) {\r\n\t\ttry {\r\n//\t\t\tIResponse status = super.define_sort(cmd);\r\n//\t\t\tif (!status.isOK()) return status;\r\n\r\n\t\t\tif (cmd.parameters().size() == 0) {\r\n\t\t\t\tString msg = \"(define-type \" + translate(cmd.sortSymbol()) + \" \";\r\n\t\t\t\tmsg = msg + translate(cmd.expression()) + \")\";\r\n\t\t\t\tIResponse response = send(cmd.sortSymbol().pos(),msg);\r\n\t\t\t\tif (response != null) return response;\r\n\t\t\t} else {\r\n\t\t\t\tthrow new IVisitor.VisitorException(\"Yices2 does not support defining parameterized types\",null);\r\n\t\t\t}\r\n\t\t\treturn smtConfig.responseFactory.success();\r\n\r\n\t\t\t// FIXME - Yices does not seem to allow creating arbitrary new types\r\n\t\t\t\t// Besides Yices uses structural equivalence.\r\n\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Yices2 define-sort command failed: \" + e.getMessage(),e.pos());\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t@Override \r\n\tpublic IResponse get_proof() {\r\n\t\tIResponse status = super.get_proof();\r\n\t\tif (status.isError()) return status;\r\n\t\ttry {\r\n\t\t\tString response = solverProcess.sendAndListen(\"(get-proof)\\n\");\r\n\t\t\tif (response.contains(errorIndication)) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(response);\r\n\t\t\t}\r\n\t\t\treturn smtConfig.responseFactory.unsupported(); // FIXME - need to return the proof\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Yices2 solver: \" + e);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override \r\n\tpublic IResponse get_unsat_core() {\r\n\t\tIResponse status = super.get_unsat_core();\r\n\t\tif (status.isError()) return status;\r\n\t\ttry {\r\n\t\t\tString response = solverProcess.sendAndListen(\"(get-unsat-core)\\n\");\r\n\t\t\tif (response.contains(errorIndication)) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(response);\r\n\t\t\t}\r\n\t\t\treturn smtConfig.responseFactory.unsupported(); // FIXME - need to return the unsat core\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Yices2 solver: \" + e);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override \r\n\tpublic IResponse get_assignment() {\r\n//\t\tIResponse status = super.get_assignment();\r\n//\t\tif (status.isError()) return status;\r\n\t\ttry {\r\n\t\t\tString response = solverProcess.sendAndListen(\"(get-assignment)\\n\");\r\n\t\t\tif (response.contains(errorIndication)) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(response);\r\n\t\t\t}\r\n\t\t\treturn smtConfig.responseFactory.unsupported(); // FIXME - need to return the assignment\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Yices2 solver: \" + e);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override \r\n\tpublic IResponse get_value(IExpr... terms) {\r\n//\t\tIResponse status = super.get_value(terms);\r\n//\t\tif (status.isError()) return status;\r\n\t\ttry {\r\n\t\t\t// FIMXE - only one term at a time\r\n\t\t\tIResponse.IFactory factory = smtConfig.responseFactory;\r\n\t\t\tString response = null;\r\n\t\t\tList\u003cIPair\u003cIExpr,IExpr\u003e\u003e list = new LinkedList\u003cIPair\u003cIExpr,IExpr\u003e\u003e();\r\n\t\t\tfor (IExpr e: terms) {\r\n\t\t\t\tString s = \"(eval \" + translate(e) + \")\\n\";\r\n\t\t\t\tresponse = solverProcess.sendAndListen(s);\r\n\t\t\t\tif (response.contains(errorIndication)) {\r\n\t\t\t\t\treturn smtConfig.responseFactory.error(response);\r\n\t\t\t\t}\r\n\t\t\t\tIExpr r = parseYicesResponse(response);\r\n\t\t\t\tif (r == null) return factory.error(\"Don't know how to parse \" + response);\r\n\r\n\t\t\t\tIPair\u003cIExpr,IExpr\u003e  p = factory.pair(e,r);\r\n\t\t\t\tlist.add(p);\r\n\t\t\t}\r\n\t\t\treturn factory.get_value_response(list);\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Yices2 solver: \" + e);\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error translating for Yices2: \" + e.getMessage());\r\n\t\t}\r\n\t}\r\n\t\r\n\tprotected IExpr parseYicesResponse(String response) {\r\n//\t\ttry {\r\n\t\t\tresponse = response.trim();\r\n\t\t\tIResponse.IFactory factory = smtConfig.responseFactory;\r\n\t\t\tIExpr.IFactory f = smtConfig.exprFactory;\r\n\t\t\tif (\"true\".equals(response) || \"false\".equals(response)) {\r\n\t\t\t\treturn f.symbol(response);\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\tInteger i = Integer.valueOf(response);\r\n\t\t\t\treturn f.numeral(i);\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\t// continue\r\n\t\t\t}\r\n\t\t\tif (response.contains(\"stdin\")) return null;\r\n\t\t\tif (response.charAt(0) != '(' \u0026\u0026 !response.contains(\" \")) return f.symbol(response);\r\n\t\t\t\r\n//\t\t\tPattern oldbv = Pattern.compile(\"bv([0-9]+)\\\\[([0-9]+)\\\\]\");\r\n//\t\t\tMatcher mm = oldbv.matcher(response);\r\n//\t\t\twhile (mm.find()) {\r\n//\t\t\t\tlong val = Long.parseLong(mm.group(1));\r\n//\t\t\t\tint base = Integer.parseInt(mm.group(2));\r\n//\t\t\t\tString bits = \"\";\r\n//\t\t\t\tfor (int i=0; i\u003cbase; i++) { bits = ((val\u00261)==0 ? \"0\" : \"1\") + bits; val = val \u003e\u003e\u003e 1; }\r\n//\t\t\t\tresponse = response.substring(0,mm.start()) + \"#b\" + bits + response.substring(mm.end(),response.length());\r\n//\t\t\t\tmm = oldbv.matcher(response);\r\n//\t\t\t}\r\n//\t\t\tif (response.contains(\"error\")) {\r\n//\t\t\t\t// is this right for Yices2?\r\n//\t\t\t\t// FIXME - (1) the {Print} also needs {Space}; (2) err_getValueTypes.tst returns a non-error s-expr and then an error s-expr - this fails for that case\r\n//\t\t\t\t//Pattern p = Pattern.compile(\"\\\\p{Space}*\\\\(\\\\p{Blank}*error\\\\p{Blank}+\\\"(([\\\\p{Space}\\\\p{Print}^[\\\\\\\"\\\\\\\\]]|\\\\\\\\\\\")*)\\\"\\\\p{Blank}*\\\\)\\\\p{Space}*\");\r\n//\t\t\t\tPattern p = Pattern.compile(\"\\\\p{Space}*\\\\(\\\\p{Blank}*error\\\\p{Blank}+\\\"(([\\\\p{Print}\\\\p{Space}\u0026\u0026[^\\\"\\\\\\\\]]|\\\\\\\\\\\")*)\\\"\\\\p{Blank}*\\\\)\");\r\n//\t\t\t\tMatcher m = p.matcher(response);\r\n//\t\t\t\tString concat = \"\";\r\n//\t\t\t\twhile (m.lookingAt()) {\r\n//\t\t\t\t\tif (!concat.isEmpty()) concat = concat + \"; \";\r\n//\t\t\t\t\tString matched = m.group(1);\r\n//\t\t\t\t\tconcat = concat + matched;\r\n//\t\t\t\t\tm.region(m.end(0),m.regionEnd());\r\n//\t\t\t\t}\r\n//\t\t\t\tif (!concat.isEmpty()) response = concat;\r\n//\t\t\t\treturn smtConfig.responseFactory.error(response);\r\n//\t\t\t}\r\n//\t\t\torg.smtlib.sexpr.Parser responseParser = new org.smtlib.sexpr.Parser(smt(),new Pos.Source(response,null));\r\n//\t\t\treturn responseParser.parseResponse(response);\r\n\t\t\treturn null;\r\n//\t\t} catch (ParserException e) {\r\n//\t\t\treturn smtConfig.responseFactory.error(\"ParserException while parsing response: \" + response + \" \" + e);\r\n//\t\t}\r\n\t}\r\n\r\n\r\n\t\r\n\tpublic /*@Nullable*/ String translate(IExpr expr) throws IVisitor.VisitorException {\r\n\t\treturn expr.accept(new Translator());\r\n\t}\r\n\t\r\n\tpublic /*@Nullable*/ String translate(ISort expr) throws IVisitor.VisitorException {\r\n\t\treturn expr.accept(new Translator());\r\n\t}\r\n\t\r\n\t/* Yices does not distinguish formulas and terms, so the mapping\r\n\t * from SMT-LIB is simpler.\r\n\t */\r\n\t\r\n\tstatic Map\u003cString,String\u003e fcnNames = new HashMap\u003cString,String\u003e();\r\n\tstatic Set\u003cString\u003e logicNames = new HashSet\u003cString\u003e();\r\n\tstatic {\r\n\t\t/* SMTLIB\t\t\tYICES\r\n\t\t * (or p q r ...)\t(or p q r ...)\r\n\t\t * (and p q r ...)\t(and p q r ...)\r\n\t\t * (not p)\t\t\t(not p)\r\n\t\t * (=\u003e p q r ...)\t(=\u003e p (=\u003e q r...))\r\n\t\t * (xor p q r ...)\t(/= (/= p q)) r )) ...\r\n\t\t * (= p q r ...)\t(and (= p q) (= q r) ... ) \r\n\t\t * (distinct p q r)\t conjunction of /= \r\n\t\t * true\t\t\t\ttrue\r\n\t\t * false\t\t\tfalse\r\n\t\t * (ite b p q)\t\t(if b p q)\r\n\t\t * (forall ...\t\t(forall (a::Bool b::Int) expr)\r\n\t\t * (exists ...\t\t(exists (a::Bool b::Int) expr)\r\n\t\t * (let ...\t\t\t(let ((aux::int (f (f x)))) (g aux aux))\r\n\t\t * \r\n\t\t * \u003c \u003c= \u003e \u003e=\t\t\u003c \u003c= \u003e \u003e=  : no chaining allowed\r\n\t\t *\r\n\t\t * TERMS\r\n\t\t * + - *\t\t\t+ - * : left associative\r\n\t\t * \t    \t\t\tselect store  - for arrays\r\n\t\t * \r\n\t\t * \r\n\t\t * Yices has / mod div\r\n\t\t */\r\n\t\t\r\n\t}\r\n\t\r\n\r\n\t/* Yices ids:\r\n\t * \t\tFIXME - not  defined what Yices ids can be made of\r\n\t */\r\n\t\r\n\tstatic Map\u003cString,String\u003e bvfcns = new HashMap\u003cString,String\u003e();\r\n\tstatic {\r\n\t\tbvfcns.put(\"bvadd\",\"bv-add\");\r\n\t\tbvfcns.put(\"bvand\",\"bv-and\");\r\n\t\tbvfcns.put(\"bvor\",\"bv-or\");\r\n\t\tbvfcns.put(\"bvmul\",\"bv-mul\");\r\n\t\tbvfcns.put(\"bvshl\",\"bv-shift-left0\"); // second argument is an integer\r\n\t\tbvfcns.put(\"bvlshr\",\"bv-shift-right0\"); // second argument is an integer\r\n\t\tbvfcns.put(\"bvneg\",\"bv-neg\");\r\n\t\tbvfcns.put(\"bvnot\",\"bv-not\");\r\n\t\tbvfcns.put(\"bvudiv\",\"\");\r\n\t\tbvfcns.put(\"bvurem\",\"\");\r\n\t\tbvfcns.put(\"concat\",\"bv-concat\");\r\n\t\tbvfcns.put(\"extract\",\"bv-extract\");\r\n\t\tbvfcns.put(\"bvult\",\"bv-lt\");\r\n\t\tbvfcns.put(\"bvnand\",\"\");\r\n\t\tbvfcns.put(\"bvnor\",\"\");\r\n\t\tbvfcns.put(\"bvxor\",\"\");\r\n\t\tbvfcns.put(\"bvxnor\",\"\");\r\n\t\tbvfcns.put(\"bvcomp\",\"\");\r\n\t\tbvfcns.put(\"bvsub\",\"\");\r\n\t\tbvfcns.put(\"bvsdiv\",\"\");\r\n\t\tbvfcns.put(\"bvsrem\",\"\");\r\n\t\tbvfcns.put(\"bvsmod\",\"\");\r\n\t\tbvfcns.put(\"bvashr\",\"\");\r\n\t\tbvfcns.put(\"bvule\",\"\");\r\n\t\tbvfcns.put(\"bvugt\",\"\");\r\n\t\tbvfcns.put(\"bvuge\",\"\");\r\n\t\tbvfcns.put(\"bvslt\",\"\");\r\n\t\tbvfcns.put(\"bvsle\",\"\");\r\n\t\tbvfcns.put(\"bvsgt\",\"\");\r\n\t\tbvfcns.put(\"bvsge\",\"\");\r\n\t}\r\n\r\n\t\r\n\tpublic class Translator extends IVisitor.NullVisitor\u003cString\u003e {\r\n\t\t\r\n\t\tpublic Translator() {}\r\n\t\t\r\n\t\tprotected String encode(IAttributeValue sym) {\r\n\t\t\treturn org.smtlib.sexpr.Printer.write(sym); // FIXME - is this OK?\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IDecimal e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new VisitorException(\"The yices2 solver cannot handle decimal literals\",e.pos());\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IStringLiteral e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new VisitorException(\"The yices2 solver cannot handle string literals\",e.pos());\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(INumeral e) throws IVisitor.VisitorException {\r\n\t\t\treturn e.value().toString();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IBinaryLiteral e) throws IVisitor.VisitorException {\r\n\t\t\treturn \"0b\" + e.value();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IHexLiteral e) throws IVisitor.VisitorException {\r\n\t\t\t// Convert to binary literal\r\n\t\t\tfinal String[] bits = { \"0000\", \"1000\", \"0100\", \"1100\", \"0010\", \"1010\", \"0110\", \"1110\", \"0001\", \"1001\", \"0101\", \"1101\", \"0011\", \"1011\", \"0111\", \"1111\" };\r\n\t\t\tStringBuilder s = new StringBuilder();\r\n\t\t\tfor (int i = 0; i \u003c e.value().length(); i++) {\r\n\t\t\t\tchar c = e.value().charAt(i);\r\n\t\t\t\tint k = c \u003c= '9' ? (c-'0') : c \u003c= 'Z' ? (c - 'A' + 10) : (c - 'a' + 10);\r\n\t\t\t\ts.append(bits[k]);\r\n\t\t\t}\r\n\t\t\treturn s.toString();\r\n\t\t}\r\n\t\t\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IFcnExpr e) throws IVisitor.VisitorException {\r\n\t\t\tIterator\u003cIExpr\u003e iter = e.args().iterator();\r\n\t\t\tif (!iter.hasNext()) throw new VisitorException(\"Did not expect an empty argument list\",e.pos());\r\n\t\t\tIQualifiedIdentifier fcn = e.head();\r\n\t\t\tString fcnname = fcn.headSymbol().accept(this);\r\n\t\t\t// FIXME - should we be doing these comparisons with strings?\r\n\t\t\tif (fcn instanceof ParameterizedIdentifier \u0026\u0026 fcn.headSymbol().toString().equals(fcnname)) {\r\n\t\t\t\tthrow new VisitorException(\"Unknown parameterized function symbol: \" + fcnname, e.pos());\r\n\t\t\t}\r\n\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\tint length  = e.args().size();\r\n\t\t\tif (fcnname.equals(\"or\") || fcnname.equals(\"and\")) {\r\n\t\t\t\t// operators that are still multi-arity\r\n\t\t\t\tsb.append(\"( \");\r\n\t\t\t\tsb.append(fcnname);\r\n\t\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t}\r\n\t\t\t\tsb.append(\" )\");\r\n\t\t\t\treturn sb.toString();\r\n\t\t\t} else if (fcnname.equals(\"=\") || fcnname.equals(\"\u003c\") || fcnname.equals(\"\u003e\") || fcnname.equals(\"\u003c=\") || fcnname.equals(\"\u003e=\")) {\r\n\t\t\t\t// chainable\r\n\t\t\t\treturn remove_chainable(fcnname,iter);\r\n\t\t\t} else if (fcnname.equals(\"xor\")) {\r\n\t\t\t\tfcnname = \"/=\";\r\n\t\t\t\t// left-associative operators that need grouping\r\n\t\t\t\treturn remove_leftassoc(fcnname,length,iter);\r\n\t\t\t} else if (fcnname.equals(\"=\u003e\")) {\r\n\t\t\t\t// right-associative operators that need grouping\r\n\t\t\t\tif (!iter.hasNext()) {\r\n\t\t\t\t\tthrow new VisitorException(\"=\u003e operation without arguments\",e.pos());\r\n\t\t\t\t}\r\n\t\t\t\treturn remove_rightassoc(fcnname,iter);\r\n\t\t\t} else if (fcnname.equals(\"distinct\")) {\r\n\t\t\t\tif (length == 2) {\r\n\t\t\t\t\tsb.append(\"(/=\");\r\n\t\t\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tint j = 0;\r\n\t\t\t\t\tsb.append(\"(and\");\r\n\t\t\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\t\t\tIExpr n = iter.next();\r\n\t\t\t\t\t\tfor (int k = 0; k\u003cj; k++) {\r\n\t\t\t\t\t\t\tsb.append(\" (/= \");\r\n\t\t\t\t\t\t\tsb.append(n.accept(this));\r\n\t\t\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\t\t\tsb.append(e.args().get(k).accept(this));\r\n\t\t\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t++j;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t}\r\n\t\t\t\treturn sb.toString();\r\n\t\t\t} else if (length == 1 \u0026\u0026 fcnname.equals(\"-\")) {\r\n\t\t\t\t// In yices there is no negation: (- x) is just x\r\n\t\t\t\t// We express negation with (- 0 x)\r\n\t\t\t\tsb.append(\"(- 0 \");\r\n\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\tsb.append(\" )\");\r\n\t\t\t\treturn sb.toString();\r\n\t\t\t} else if (length == 2 \u0026\u0026 symTable.arrayTheorySet \u0026\u0026 fcnname.equals(\"select\")) {\r\n\t\t\t\tsb.append(\"(\");\r\n\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t\treturn sb.toString();\r\n\t\t\t} else if (length == 3 \u0026\u0026 symTable.arrayTheorySet \u0026\u0026 fcnname.equals(\"store\")) {\r\n\t\t\t\tsb.append(\"(update \");\r\n\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\tsb.append(\" (\");\r\n\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\tsb.append(\") \");\r\n\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t\treturn sb.toString();\r\n\t\t\t} else {\r\n\t\t\t\tif (symTable.bitVectorTheorySet) {\r\n\t\t\t\t\t// Predefined: bvadd, bvmul, bvneg, bvnot, bvshl, bvlshr, concat, extract, bvult, bvudiv, bvurem, bvand, bvor\r\n\t\t\t\t\tString newname = bvfcns.get(fcnname);\r\n\t\t\t\t\tif (newname == null) {\r\n\t\t\t\t\t\t// continue\r\n\t\t\t\t\t} else if (newname.isEmpty()) {\r\n\t\t\t\t\t\tthrow new VisitorException(\"The BitVector function \" + fcnname + \" is not implemented in yices\",e.pos());\r\n\t\t\t\t\t} else if (fcnname.equals(\"extract\")) {\r\n\t\t\t\t\t\tsb.append(\"(bv-extract \");\r\n\t\t\t\t\t\tIParameterizedIdentifier pid = (IParameterizedIdentifier)fcn;\r\n\t\t\t\t\t\tsb.append(pid.numerals().get(1).intValue());\r\n\t\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\t\tsb.append(pid.numerals().get(0).intValue());\r\n\t\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t\t\treturn sb.toString();\r\n\t\t\t\t\t} else if (fcnname.equals(\"bvshl\") || fcnname.equals(\"bvlshr\")) {\r\n\t\t\t\t\t\tthrow new VisitorException(\"The BitVector function \" + fcnname + \" is not implementetd in yices\",e.pos());\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfcnname = newname;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// no associativity \r\n\t\t\t\tsb.append(\"( \");\r\n\t\t\t\tsb.append(fcnname);\r\n\t\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t}\r\n\t\t\t\tsb.append(\" )\");\r\n\t\t\t\treturn sb.toString();\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t\r\n\t\t//@ requires iter.hasNext();\r\n\t\tprivate \u003cT extends IExpr\u003e String remove_rightassoc(String fcnname, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\r\n\t\t\tT n = iter.next();\r\n\t\t\tif (!iter.hasNext()) {\r\n\t\t\t\treturn n.accept(this);\r\n\t\t\t} else {\r\n\t\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\t\tsb.append(\"(\");\r\n\t\t\t\tsb.append(fcnname);\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(n.accept(this));\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(remove_rightassoc(fcnname,iter));\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t\treturn sb.toString();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//@ requires iter.hasNext();\r\n\t\t//@ requires length \u003e 0;\r\n\t\tprivate \u003cT extends IExpr\u003e String remove_leftassoc(String fcnname, int length, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\r\n\t\t\tif (length == 1) {\r\n\t\t\t\treturn iter.next().accept(this);\r\n\t\t\t} else {\r\n\t\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\t\tsb.append(\"(\");\r\n\t\t\t\tsb.append(fcnname);\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(remove_leftassoc(fcnname,length-1,iter));\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t\treturn sb.toString();\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t//@ requires iter.hasNext();\r\n\t\t//@ requires length \u003e 0;\r\n\t\tprivate \u003cT extends IAccept\u003e String remove_chainable(String fcnname, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\r\n\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\tsb.append(\"(and \");\r\n\t\t\tT left = iter.next();\r\n\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\tsb.append(\"(\");\r\n\t\t\t\tsb.append(fcnname);\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(left.accept(this));\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append((left=iter.next()).accept(this));\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t}\r\n\t\t\tsb.append(\")\");\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(ISymbol e) throws IVisitor.VisitorException {\r\n\t\t\treturn e.value(); // FIXME - translate\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IKeyword e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new VisitorException(\"Did not expect a Keyword in an expression to be translated\",e.pos());\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IError e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new VisitorException(\"Did not expect a Error token in an expression to be translated\", e.pos());\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IParameterizedIdentifier e) throws IVisitor.VisitorException {\r\n\t\t\t// FIXME - use default printer properly to print Symbol\r\n\t\t\tthrow new IVisitor.VisitorException(\"Unsupported parameterized function symbol: \" + e.headSymbol().toString(),e.pos());\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IAsIdentifier e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new UnsupportedOperationException(\"visit-IAsIdentifier\");\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IForall e) throws IVisitor.VisitorException {\r\n\t\t\tStringBuffer sb = new StringBuffer();\r\n\t\t\tboolean allBool = true;\r\n\t\t\tlong bits = 1; // FIXME - no more than 63 quantifiers\r\n\t\t\tfor (IDeclaration p: e.parameters()) {\r\n\t\t\t\tif (!p.sort().isBool()) allBool = false;\r\n\t\t\t\tbits = bits \u003c\u003c 1;\r\n\t\t\t}\r\n\t\t\tif (allBool) {\r\n\t\t\t\tsb.append(\"(and \");\r\n\t\t\t\twhile (--bits \u003e= 0) {\r\n\t\t\t\t\tsb.append(\"(let (\");\r\n\t\t\t\t\tlong k = bits;\r\n\t\t\t\t\tfor (IDeclaration p: e.parameters()) {\r\n\t\t\t\t\t\tsb.append(\"(\");\r\n\t\t\t\t\t\tsb.append(p.parameter().accept(this));\r\n\t\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\t\tsb.append((k\u00261) == 1 ? \"true\" : \"false\");\r\n\t\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t\t\tk = k \u003e\u003e\u003e 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t    sb.append(\") \");\r\n\t\t\t\t    sb.append(e.expr().accept(this));\r\n\t\t\t\t    sb.append(\") \");\r\n\t\t\t\t}\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t} else {\r\n\t\t\t\tsb.append(\"(forall (\");\r\n\t\t\t\tfor (IDeclaration d: e.parameters()) {\r\n\t\t\t\t\tsb.append(d.parameter().accept(this));\r\n\t\t\t\t\tsb.append(\"::\");\r\n\t\t\t\t\tsb.append(d.sort().accept(this));\r\n\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t}\r\n\t\t\t\tsb.append(\") \");\r\n\t\t\t\tsb.append(e.expr().accept(this));\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t}\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IExists e) throws IVisitor.VisitorException {\r\n\t\t\tStringBuffer sb = new StringBuffer();\r\n\t\t\tboolean allBool = true;\r\n\t\t\tlong bits = 1; // FIXME - no more than 63 quantifiers\r\n\t\t\tfor (IDeclaration p: e.parameters()) {\r\n\t\t\t\tif (!p.sort().isBool()) allBool = false;\r\n\t\t\t\tbits = bits \u003c\u003c 1;\r\n\t\t\t}\r\n\t\t\tif (allBool) {\r\n\t\t\t\tsb.append(\"(or \");\r\n\t\t\t\twhile (--bits \u003e= 0) {\r\n\t\t\t\t\tsb.append(\"(let (\");\r\n\t\t\t\t\tlong k = bits;\r\n\t\t\t\t\tfor (IDeclaration p: e.parameters()) {\r\n\t\t\t\t\t\tsb.append(\"(\");\r\n\t\t\t\t\t\tsb.append(p.parameter().accept(this));\r\n\t\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\t\tsb.append((k\u00261) == 1 ? \"true\" : \"false\");\r\n\t\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t\t\tk = k \u003e\u003e\u003e 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t    sb.append(\") \");\r\n\t\t\t\t    sb.append(e.expr().accept(this));\r\n\t\t\t\t    sb.append(\") \");\r\n\t\t\t\t}\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t} else {\r\n\t\t\t\tsb.append(\"(exists (\");\r\n\t\t\t\tfor (IDeclaration d: e.parameters()) {\r\n\t\t\t\t\tsb.append(d.parameter().accept(this));\r\n\t\t\t\t\tsb.append(\"::\");\r\n\t\t\t\t\tsb.append(d.sort().accept(this));\r\n\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t}\r\n\t\t\t\tsb.append(\") \");\r\n\t\t\t\tsb.append(e.expr().accept(this));\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t}\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(ILet e) throws IVisitor.VisitorException {\r\n\t\t\tStringBuffer sb = new StringBuffer();\r\n\t\t\tsb.append(\"(let (\");\r\n\t\t\tfor (IBinding d: e.bindings()) {\r\n\t\t\t\tsb.append(\"(\");\r\n\t\t\t\tsb.append(d.parameter().accept(this));\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(d.expr().accept(this));\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t}\r\n\t\t\tsb.append(\") \");\r\n\t\t\tsb.append(e.expr().accept(this));\r\n\t\t\tsb.append(\")\");\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IAttribute\u003c?\u003e e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new UnsupportedOperationException(\"visit-IAttribute\");\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IAttributedExpr e) throws IVisitor.VisitorException {\r\n\t\t\tIExpr expr = e.expr();\r\n\t\t\tIAttribute\u003c?\u003e attr = e.attributes().get(0);\r\n\t\t\tif (attr.keyword().toString().equals(\":named\")) {\r\n\t\t\t\tString name = encode(attr.attrValue());\r\n\t\t\t\tString ex = expr.accept(this);\r\n\t\t\t\tString sort = typemap.get(expr).accept(this);\r\n\t\t\t\tString def = \"(define \" + name + \"::\" + sort + \" \" + ex + \")\";\r\n\t\t\t\tIResponse response = send(e.pos(),def);\r\n\t\t\t\tif (response != null) {\r\n\t\t\t\t\tthrow new VisitorException(\"Failed to define attributed expression: \" + response, e.pos()); // FIXME - error message format?\r\n\t\t\t\t}\r\n\t\t\t\treturn ex;\r\n\t\t\t} else {\r\n\t\t\t\tthrow new VisitorException(\"Unexpected kind of keyword: \" + smtConfig.defaultPrinter.toString(attr.keyword()),attr.pos());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IDeclaration e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new UnsupportedOperationException(\"visit-IDeclaration\");\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(ISort.IFamily s) throws IVisitor.VisitorException {\r\n\t\t\treturn s.identifier().accept(this);\r\n\t\t}\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic String visit(ISort.IAbbreviation s) throws IVisitor.VisitorException {\r\n\t\t\tthrow new UnsupportedOperationException(\"visit-ISort.IAbbreviation\");\r\n\t\t}\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic String visit(ISort.IApplication s) throws IVisitor.VisitorException {\r\n\t\t\tif (s.isBool()) return \"bool\";\r\n\t\t\tString sort = s.family().headSymbol().accept(this);\r\n\t\t\tif (s.parameters().size() == 0) {\r\n\t\t\t\tif (\"Int\".equals(sort)) return \"int\";\r\n\t\t\t\tif (\"Real\".equals(sort)) return \"real\";\r\n\t\t\t\tif (symTable.bitVectorTheorySet \u0026\u0026 \"BitVec\".equals(sort)) {\r\n\t\t\t\t\tString sbv = \"(bitvector \";\r\n\t\t\t\t\tint k = ((IParameterizedIdentifier)s.family()).numerals().get(0).intValue();\r\n\t\t\t\t\tsbv = sbv + k + \")\";\r\n\t\t\t\t\treturn sbv;\r\n\t\t\t\t}\r\n\t\t\t\treturn sort;\r\n\t\t\t} else {\r\n\t\t\t\tif (\"Array\".equals(sort)) {\r\n\t\t\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\t\t\tsb.append(\"(-\u003e \");\r\n\t\t\t\t\tsb.append(s.parameters().get(0).accept(this));\r\n\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\tsb.append(s.parameters().get(1).accept(this));\r\n\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t\treturn sb.toString();\r\n\t\t\t\t}\r\n\t\t\t\tthrow new VisitorException(\"Yices does not support user-defined parameterized sorts: \" + s, s.pos());\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic String visit(ISort.IFcnSort s) {\r\n\t\t\tthrow new UnsupportedOperationException(\"visit-ISort.IFcnSort\");\r\n\t\t}\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic String visit(ISort.IParameter s) {\r\n\t\t\tthrow new UnsupportedOperationException(\"visit-ISort.IParameter\");\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t}\r\n}\r\n",
        "name": "Solver_yices2.java",
        "path": "smt/lip6.smtlib.SMT/src/org/smtlib/solvers/Solver_yices2.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.SMT/src/org/smtlib/solvers/Solver_yices2.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 786,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 804,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 805,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires length \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 822,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 823,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires length \u003e 0;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.solvers;\r\n\r\n// Items not implemented:\r\n//   attributed expressions\r\n//   get-values get-assignment get-proof get-unsat-core\r\n//   some error detection and handling\r\n\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.PrintStream;\r\nimport java.io.StringWriter;\r\nimport java.io.Writer;\r\nimport java.util.Arrays;\r\nimport java.util.HashMap;\r\nimport java.util.Iterator;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\nimport org.smtlib.*;\r\nimport org.smtlib.ICommand.Ideclare_fun;\r\nimport org.smtlib.ICommand.Ideclare_sort;\r\nimport org.smtlib.ICommand.Idefine_fun;\r\nimport org.smtlib.ICommand.Idefine_sort;\r\nimport org.smtlib.IExpr.IAttribute;\r\nimport org.smtlib.IExpr.IAttributeValue;\r\nimport org.smtlib.IExpr.IFcnExpr;\r\nimport org.smtlib.IExpr.IIdentifier;\r\nimport org.smtlib.IExpr.IKeyword;\r\nimport org.smtlib.IExpr.INumeral;\r\nimport org.smtlib.IExpr.IQualifiedIdentifier;\r\nimport org.smtlib.IExpr.IStringLiteral;\r\nimport org.smtlib.IParser.ParserException;\r\nimport org.smtlib.IVisitor.VisitorException;\r\nimport org.smtlib.impl.Pos;\r\nimport org.smtlib.sexpr.Printer;\r\n\r\n/** This class is an adapter that takes the SMT-LIB ASTs and translates them into Z3 commands */\r\npublic class Solver_z3_4_3 extends AbstractSolver implements ISolver {\r\n\t\r\n\tprotected String NAME_VALUE = \"z3-4.3\";\r\n\tprotected String AUTHORS_VALUE = \"Leonardo de Moura and Nikolaj Bjorner\";\r\n\tprotected String VERSION_VALUE = \"4.3\";\r\n\t\r\n\tprotected int linesOffset = 0;\r\n\t/** A reference to the SMT configuration */\r\n\tprotected SMT.Configuration smtConfig;\r\n\r\n\t/** A reference to the SMT configuration */\r\n\tpublic SMT.Configuration smt() { return smtConfig; }\r\n\t\r\n\t/** The command-line arguments for launching the Z3 solver */\r\n\tprotected String cmds[];\r\n\tprotected String cmds_win[] = new String[]{ \"\", \"/smt2\",\"/in\",\"SMTLIB2_COMPLIANT=true\"}; \r\n\tprotected String cmds_mac[] = new String[]{ \"\", \"-smt2\",\"-in\",\"SMTLIB2_COMPLIANT=true\"}; \r\n\tprotected String cmds_unix[] = new String[]{ \"\", \"-smt2\",\"-in\"}; \r\n\r\n\t/** The object that interacts with external processes */\r\n\tprotected SolverProcess solverProcess;\r\n\t\r\n\t/** The parser that parses responses from the solver */\r\n\tprotected org.smtlib.sexpr.Parser responseParser;\r\n\t\r\n\t/** Set to true once a set-logic command has been executed */\r\n\tprivate boolean logicSet = false;\r\n\t\r\n\t/** The checkSatStatus returned by check-sat, if sufficiently recent, otherwise null */\r\n\tprotected /*@Nullable*/ IResponse checkSatStatus = null;\r\n\t\r\n\t@Override\r\n\tpublic /*@Nullable*/IResponse checkSatStatus() { return checkSatStatus; }\r\n\r\n\t/** The number of pushes less the number of pops so far */\r\n\tprivate int pushesDepth = 0;\r\n\t\r\n\t/** Map that keeps current values of options */\r\n\tprotected Map\u003cString,IAttributeValue\u003e options = new HashMap\u003cString,IAttributeValue\u003e();\r\n\t{ \r\n\t\toptions.putAll(Utils.defaults);\r\n\t}\r\n\t\r\n\t/** Creates an instance of the Z3 solver */\r\n\tpublic Solver_z3_4_3(SMT.Configuration smtConfig, /*@NonNull*/ String executable) {\r\n\t\tthis.smtConfig = smtConfig;\r\n\t\tif (isWindows) {\r\n\t\t\tcmds = cmds_win;\r\n\t\t} else if (isMac) {\r\n\t\t\tcmds = cmds_mac;\r\n\t\t} else {\r\n\t\t\tcmds = cmds_unix;\r\n\t\t}\r\n\t\tcmds[0] = executable;\r\n\t\tdouble timeout = smtConfig.timeout;\r\n\t\tif (timeout \u003e 0) {\r\n\t\t\tList\u003cString\u003e args = new java.util.ArrayList\u003cString\u003e(cmds.length+1);\r\n\t\t\targs.addAll(Arrays.asList(cmds));\t\t\t\r\n\t\t\tif (isWindows) args.add(\"/t:\" + Integer.toString((int)timeout));\r\n\t\t\telse           args.add(\"-t:\" + Integer.toString((int)timeout));\t\t\t\t\t\t\r\n\t\t\tcmds = args.toArray(new String[args.size()]);\r\n\t\t}\r\n\t\tdouble timeoutT = smtConfig.timeoutTotal;\r\n\t\tif (timeoutT \u003e 0) {\r\n\t\t\tList\u003cString\u003e args = new java.util.ArrayList\u003cString\u003e(cmds.length+1);\r\n\t\t\targs.addAll(Arrays.asList(cmds));\t\t\t\r\n\t\t\tif (isWindows) args.add(\"/T:\" + Integer.toString((int)timeoutT));\r\n\t\t\telse           args.add(\"-T:\" + Integer.toString((int)timeoutT));\t\t\t\t\t\t\r\n\t\t\tcmds = args.toArray(new String[args.size()]);\r\n\t\t}\r\n\t\tsolverProcess = new SolverProcess(cmds,\"\\n\",smtConfig);\r\n\t\tresponseParser = new org.smtlib.sexpr.Parser(smt(),new Pos.Source(\"\",null));\r\n\t}\r\n\r\n\tpublic IResponse sendCommand(ICommand cmd) {\r\n\t\tString translatedCmd = null;\r\n\t\ttry {\r\n\t\t\ttranslatedCmd = translate(cmd);\r\n\t\t\treturn parseResponse(solverProcess.sendAndListen(translatedCmd,\"\\n\"));\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to solver: \" + translatedCmd + \" \" + e);\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to solver: \" + translatedCmd + \" \" + e);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic IResponse sendCommand(String cmd) {\r\n\t\ttry {\r\n\t\t\tString r = solverProcess.sendAndListen(cmd);\r\n\t\t\treturn parseResponse(r);\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to solver: \" + cmd + \" \" + e);\r\n\t\t}\r\n\t}\r\n\t\r\n\r\n\t@Override\r\n\tpublic IResponse start() {\r\n\t\ttry {\r\n\t\t\tsolverProcess.start(false);\r\n\t\t\t// FIXME - enable the following lines when the Z3 solver supports them\r\n//\t\t\tif (smtConfig.solverVerbosity \u003e 0) solverProcess.sendNoListen(\"(set-option :verbosity \",Integer.toString(smtConfig.solverVerbosity),\")\");\r\n//\t\t\tif (!smtConfig.batch) solverProcess.sendNoListen(\"(set-option :interactive-mode true)\"); // FIXME - not sure we can do this - we'll lose the feedback\r\n\t\t\t// Can't turn off printing success, or we get no feedback\r\n\t\t\tString res = solverProcess.sendAndListen(\"(set-option :print-success true)\\n\"); // Z3 4.3.0 needs this because it mistakenly has the default for :print-success as false\r\n\t\t\tlinesOffset ++; \r\n\t\t\t//if (smtConfig.nosuccess) solverProcess.sendAndListen(\"(set-option :print-success false)\");\r\n\t\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Started Z3-4.3 \");\r\n\t\t\treturn smtConfig.responseFactory.success();\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to start process \" + cmds[0] + \" : with command line \" + Arrays.toString(cmds) +\" Failed with error :  \"+ e.getMessage());\r\n\t\t}\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic IResponse exit() {\r\n\t\ttry {\r\n\t\t\tsolverProcess.sendAndListen(\"(exit)\\n\");\r\n\t\t\tsolverProcess.exit();\r\n\t\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Ended Z3 \");\r\n\t\t\treturn successOrEmpty(smtConfig);\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\r\n\t\t}\r\n\t}\r\n\r\n\t/** Translates an S-expression into Z3 syntax */\r\n\tprotected String translate(IAccept sexpr) throws IVisitor.VisitorException {\r\n\t\t// The z3 solver uses the standard S-expression concrete syntax, but not quite\r\n\t\t// so we have to use our own translator\r\n\t\tStringWriter sw = new StringWriter();\r\n\t\tsexpr.accept(new Translator(sw));\r\n\t\treturn sw.toString();\r\n\t}\r\n\t\r\n\t/** Translates an S-expression into standard SMT syntax */\r\n\tprotected String translateSMT(IAccept sexpr) throws IVisitor.VisitorException {\r\n\t\t// The z3 solver uses the standard S-expression concrete syntax, but not quite\r\n\t\tStringWriter sw = new StringWriter();\r\n\t\torg.smtlib.sexpr.Printer.write(sw,sexpr);\r\n\t\treturn sw.toString();\r\n\t}\r\n\t\r\n\tprotected IResponse parseResponse(String response) {\r\n\t\ttry {\r\n\t\t\tif (response.startsWith(\"stderr\")) response = response.replace(\"stderr\", \"\\\"stderr\\\"\");\r\n\t\t\telse if (response.startsWith(\"stdout\")) response = response.replace(\"stdout\", \"\\\"stdout\\\"\");\r\n\t\t\tPattern oldbv = Pattern.compile(\"bv([0-9]+)\\\\[([0-9]+)\\\\]\");\r\n\t\t\tMatcher mm = oldbv.matcher(response);\r\n\t\t\twhile (mm.find()) {\r\n\t\t\t\tlong val = Long.parseLong(mm.group(1));\r\n\t\t\t\tint base = Integer.parseInt(mm.group(2));\r\n\t\t\t\tString bits = \"\";\r\n\t\t\t\tfor (int i=0; i\u003cbase; i++) { bits = ((val\u00261)==0 ? \"0\" : \"1\") + bits; val = val \u003e\u003e\u003e 1; }\r\n\t\t\t\tresponse = response.substring(0,mm.start()) + \"#b\" + bits + response.substring(mm.end(),response.length());\r\n\t\t\t\tmm = oldbv.matcher(response);\r\n\t\t\t}\r\n\t\t\tif (isMac \u0026\u0026 response.startsWith(\"success\")) return smtConfig.responseFactory.success(); // IFXME - this is just to avoid a problem with the Mac Z3 implementation\r\n\t\t\tif (response.contains(\"error\")  \u0026\u0026 !response.contains(\":error\")) {\r\n\t\t\t\t// Z3 returns an s-expr (always?)\r\n\t\t\t\t// FIXME - (1) the {Print} also needs {Space}; (2) err_getValueTypes.tst returns a non-error s-expr and then an error s-expr - this fails for that case\r\n\t\t\t\t//Pattern p = Pattern.compile(\"\\\\p{Space}*\\\\(\\\\p{Blank}*error\\\\p{Blank}+\\\"(([\\\\p{Space}\\\\p{Print}^[\\\\\\\"\\\\\\\\]]|\\\\\\\\\\\")*)\\\"\\\\p{Blank}*\\\\)\\\\p{Space}*\");\r\n\t\t\t\tPattern p = Pattern.compile(\"\\\\p{Space}*\\\\(\\\\p{Blank}*error\\\\p{Blank}+\\\"(([\\\\p{Print}\\\\p{Space}\u0026\u0026[^\\\"\\\\\\\\]]|\\\\\\\\\\\")*)\\\"\\\\p{Blank}*\\\\)\");\r\n\t\t\t\tMatcher m = p.matcher(response);\r\n\t\t\t\tString concat = \"\";\r\n\t\t\t\twhile (m.lookingAt()) {\r\n\t\t\t\t\tif (!concat.isEmpty()) concat = concat + \"; \";\r\n\t\t\t\t\tString matched = m.group(1);\r\n\t\t\t\t\tString prefix = \"line \";\r\n\t\t\t\t\tint offset = prefix.length();\r\n\t\t\t\t\tif (matched.startsWith(prefix)) {\r\n\t\t\t\t\t\tint k = matched.indexOf(' ',offset);\r\n\t\t\t\t\t\tString number = matched.substring(offset, k);\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tint n = Integer.parseInt(number);\r\n\t\t\t\t\t\t\tmatched = prefix + (n-linesOffset) + matched.substring(k);\r\n\t\t\t\t\t\t} catch (NumberFormatException e) {\r\n\t\t\t\t\t\t\t// Just continue\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconcat = concat + matched;\r\n\t\t\t\t\tm.region(m.end(0),m.regionEnd());\r\n\t\t\t\t}\r\n\t\t\t\tif (!concat.isEmpty()) response = concat;\r\n\t\t\t\treturn smtConfig.responseFactory.error(response);\r\n\t\t\t}\r\n\t\t\tresponseParser = new org.smtlib.sexpr.Parser(smt(),new Pos.Source(response,null));\r\n\t\t\treturn responseParser.parseResponse(response);\r\n\t\t} catch (ParserException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"ParserException while parsing response: \" + response + \" \" + e);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse assertExpr(IExpr sexpr) {\r\n\t\tIResponse response;\r\n\t\tif (pushesDepth \u003c= 0) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"All assertion sets have been popped from the stack\");\r\n\t\t}\r\n\t\tif (!logicSet) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before an assert command is issued\");\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tString s = solverProcess.sendAndListen(\"(assert \",translate(sexpr),\")\\n\");\r\n\t\t\tresponse = parseResponse(s);\r\n\t\t\tcheckSatStatus = null;\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to assert expression: \" + e + \" \" + sexpr);\r\n\t\t} catch (Exception e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to assert expression: \" + e + \" \" + sexpr);\r\n\t\t}\r\n\t\treturn response;\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic IResponse get_assertions() {\r\n\t\tif (!logicSet) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a get-assertions command is issued\");\r\n\t\t}\r\n\t\t// FIXME - do we really want to call get-option here? it involves going to the solver?\r\n\t\tif (!smtConfig.relax \u0026\u0026 !Utils.TRUE.equals(get_option(smtConfig.exprFactory.keyword(Utils.INTERACTIVE_MODE)))) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The get-assertions command is only valid if :interactive-mode has been enabled\");\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\tString s;\r\n\t\t\tint parens = 0;\r\n\t\t\tdo {\r\n\t\t\t\ts = solverProcess.sendAndListen(\"(get-assertions)\\n\");\r\n\t\t\t\tint p = -1;\r\n\t\t\t\twhile (( p = s.indexOf('(',p+1)) != -1) parens++;\r\n\t\t\t\tp = -1;\r\n\t\t\t\twhile (( p = s.indexOf(')',p+1)) != -1) parens--;\r\n\t\t\t\tsb.append(s.replace('\\n',' ').replace(\"\\r\",\"\"));\r\n\t\t\t} while (parens \u003e 0);\r\n\t\t\ts = sb.toString();\r\n\t\t\torg.smtlib.sexpr.Parser p = new org.smtlib.sexpr.Parser(smtConfig,new org.smtlib.impl.Pos.Source(s,null));\r\n\t\t\tList\u003cIExpr\u003e exprs = new LinkedList\u003cIExpr\u003e();\r\n\t\t\ttry {\r\n\t\t\t\tif (p.isLP()) {\r\n\t\t\t\t\tp.parseLP();\r\n\t\t\t\t\twhile (!p.isRP() \u0026\u0026 !p.isEOD()) {\r\n\t\t\t\t\t\tIExpr e = p.parseExpr();\r\n\t\t\t\t\t\texprs.add(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (p.isRP()) {\r\n\t\t\t\t\t\tp.parseRP();\r\n\t\t\t\t\t\tif (p.isEOD()) return smtConfig.responseFactory.get_assertions_response(exprs); \r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} catch (Exception e ) {\r\n\t\t\t\t// continue - fall through\r\n\t\t\t}\r\n\t\t\treturn smtConfig.responseFactory.error(\"Unexpected output from the Z3 solver: \" + s);\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"IOException while reading Z3 reponse\");\r\n\t\t}\r\n\t}\r\n\t\r\n\r\n\r\n\t@Override\r\n\tpublic IResponse check_sat() {\r\n\t\tIResponse res;\r\n\t\ttry {\r\n\t\t\tif (!logicSet) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a check-sat command is issued\");\r\n\t\t\t}\r\n\t\t\tString s = solverProcess.sendAndListen(\"(check-sat)\\n\");\r\n\t\t\t//smtConfig.log.logDiag(\"HEARD: \" + s);  // FIXME - detect errors - parseResponse?\r\n\t\t\t\r\n\t\t\tif (solverProcess.isRunning(false)) {\r\n\t\t\t\tif (s.contains(\"unsat\")) res = smtConfig.responseFactory.unsat();\r\n\t\t\t\telse if (s.contains(\"sat\")) res = smtConfig.responseFactory.sat();\r\n\t\t\t\telse res = smtConfig.responseFactory.unknown();\r\n\t\t\t} else {\r\n\t\t\t\tres = smtConfig.responseFactory.error(\"Solver has unexpectedly terminated\");\r\n\t\t\t}\r\n\r\n\t\t\tcheckSatStatus = res;\r\n\t\t} catch (IOException e) {\r\n\t\t\tres = smtConfig.responseFactory.error(\"Failed to check-sat\");\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse pop(int number) {\r\n\t\tif (!logicSet) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a pop command is issued\");\r\n\t\t}\r\n\t\tif (number \u003c 0) throw new SMT.InternalException(\"Internal bug: A pop command called with a negative argument: \" + number);\r\n\t\tif (number \u003e pushesDepth) return smtConfig.responseFactory.error(\"The argument to a pop command is too large: \" + number + \" vs. a maximum of \" + (pushesDepth));\r\n\t\tif (number == 0) return  successOrEmpty(smtConfig);\r\n\t\ttry {\r\n\t\t\tcheckSatStatus = null;\r\n\t\t\tpushesDepth -= number;\r\n\t\t\treturn parseResponse(solverProcess.sendAndListen(\"(pop \",new Integer(number).toString(),\")\\n\"));\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse push(int number) {\r\n\t\tif (!logicSet) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a push command is issued\");\r\n\t\t}\r\n\t\tif (number \u003c 0) throw new SMT.InternalException(\"Internal bug: A push command called with a negative argument: \" + number);\r\n\t\tcheckSatStatus = null;\r\n\t\tif (number == 0) return smtConfig.responseFactory.success();\r\n\t\ttry {\r\n\t\t\tpushesDepth += number;\r\n\t\t\tIResponse r = parseResponse(solverProcess.sendAndListen(\"(push \",new Integer(number).toString(),\")\\n\"));\r\n\t\t\t// FIXME - actually only see this problem on Linux\r\n\t\t\t// if (r.isError() \u0026\u0026 !isWindows) return successOrEmpty(smtConfig);\r\n\t\t\treturn r;\r\n\t\t} catch (Exception e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse set_logic(String logicName, /*@Nullable*/ IPos pos) {\r\n\t\tif (logicName != null) {\r\n\t\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"#set-logic \" + logicName);\r\n\t\t\tif (logicSet) {\r\n\t\t\t\tif (!smtConfig.relax) return smtConfig.responseFactory.error(\"Logic is already set\");\r\n\t\t\t\tpop(pushesDepth);\r\n\t\t\t}\r\n\t\t\tpushesDepth++;\r\n\t\t\tlogicSet = true;\r\n\t\t\ttry {\r\n\t\t\t\treturn parseResponse(solverProcess.sendAndListen(\"(set-logic \",logicName,\")\\n\"));\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e,pos);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tlogicSet = true;\r\n\t\t\tpushesDepth++;\r\n\t\t\treturn smtConfig.responseFactory.success();\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse set_option(IKeyword key, IAttributeValue value) {\r\n\t\tString option = key.value();\r\n\t\tif (Utils.PRINT_SUCCESS.equals(option)) {\r\n\t\t\tif (!(Utils.TRUE.equals(value) || Utils.FALSE.equals(value))) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be 'true' or 'false'\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (logicSet \u0026\u0026 Utils.INTERACTIVE_MODE.equals(option)) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be set before the set-logic command\");\r\n\t\t}\r\n\t\tif (Utils.PRODUCE_ASSIGNMENTS.equals(option) || \r\n\t\t\t\tUtils.PRODUCE_PROOFS.equals(option) ||\r\n\t\t\t\tUtils.PRODUCE_UNSAT_CORES.equals(option)) {\r\n\t\t\tif (logicSet) return smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be set before the set-logic command\");\r\n\t\t\treturn smtConfig.responseFactory.unsupported();\r\n\t\t}\r\n\t\tif (Utils.PRODUCE_MODELS.equals(option)) {\r\n\t\t\tif (logicSet) return smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be set before the set-logic command\");\r\n\t\t}\r\n\t\tif (Utils.VERBOSITY.equals(option)) {\r\n\t\t\tIAttributeValue v = options.get(option);\r\n\t\t\tsmtConfig.verbose = (v instanceof INumeral) ? ((INumeral)v).intValue() : 0;\r\n\t\t} else if (Utils.DIAGNOSTIC_OUTPUT_CHANNEL.equals(option)) {\r\n\t\t\t// Actually, v should never be anything but IStringLiteral - that should\r\n\t\t\t// be checked during parsing\r\n\t\t\tString name = (value instanceof IStringLiteral)? ((IStringLiteral)value).value() : \"stderr\";\r\n\t\t\tif (name.equals(\"stdout\")) {\r\n\t\t\t\tsmtConfig.log.diag = System.out;\r\n\t\t\t} else if (name.equals(\"stderr\")) {\r\n\t\t\t\tsmtConfig.log.diag = System.err;\r\n\t\t\t} else {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tFileOutputStream f = new FileOutputStream(name,true); // true -\u003e append\r\n\t\t\t\t\tsmtConfig.log.diag = new PrintStream(f);\r\n\t\t\t\t} catch (java.io.IOException e) {\r\n\t\t\t\t\treturn smtConfig.responseFactory.error(\"Failed to open or write to the diagnostic output \" + e.getMessage(),value.pos());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (Utils.REGULAR_OUTPUT_CHANNEL.equals(option)) {\r\n\t\t\t// Actually, v should never be anything but IStringLiteral - that should\r\n\t\t\t// be checked during parsing\r\n\t\t\tString name = (value instanceof IStringLiteral)?((IStringLiteral)value).value() : \"stdout\";\r\n\t\t\tif (name.equals(\"stdout\")) {\r\n\t\t\t\tsmtConfig.log.out = System.out;\r\n\t\t\t} else if (name.equals(\"stderr\")) {\r\n\t\t\t\tsmtConfig.log.out = System.err;\r\n\t\t\t} else {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tFileOutputStream f = new FileOutputStream(name,true); // append\r\n\t\t\t\t\tsmtConfig.log.out = new PrintStream(f);\r\n\t\t\t\t} catch (java.io.IOException e) {\r\n\t\t\t\t\treturn smtConfig.responseFactory.error(\"Failed to open or write to the regular output \" + e.getMessage(),value.pos());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Save the options on our side as well\r\n\t\toptions.put(option,value);\r\n\t\tIResponse r = checkPrintSuccess(smtConfig,key,value);\r\n\t\tif (r != null) return r;\r\n\r\n\t\ttry {\r\n\t\t\tsolverProcess.sendAndListen(\"(set-option \",option,\" \",value.toString(),\")\\n\");// FIXME - detect errors\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\r\n\t\t}\r\n\t\t\r\n\t\treturn successOrEmpty(smtConfig);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse get_option(IKeyword key) { // FIXME - use the solver?\r\n\t\tString option = key.value();\r\n\t\tIAttributeValue value = options.get(option);\r\n\t\tif (value == null) return smtConfig.responseFactory.unsupported();\r\n\t\treturn value;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse get_info(IKeyword key) {\r\n\t\treturn sendCommand(\"(get-info \" + key + \")\\n\");\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic IResponse set_info(IKeyword key, IAttributeValue value) {\r\n\t\tif (Utils.infoKeywords.contains(key)) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Setting the value of a pre-defined keyword is not permitted: \"+ \r\n\t\t\t\t\tsmtConfig.defaultPrinter.toString(key),key.pos());\r\n\t\t}\r\n\t\treturn sendCommand(new org.smtlib.command.C_set_info(key,value));\r\n\t}\r\n\r\n\r\n\t@Override\r\n\tpublic IResponse declare_fun(Ideclare_fun cmd) {\r\n\t\tif (!logicSet) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a declare-fun command is issued\");\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tcheckSatStatus = null;\r\n\t\t\treturn parseResponse(solverProcess.sendAndListen(translate(cmd),\"\\n\"));\r\n\t\t\t\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse define_fun(Idefine_fun cmd) {\r\n\t\tif (!logicSet) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a define-fun command is issued\");\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tcheckSatStatus = null;\r\n\t\t\treturn parseResponse(solverProcess.sendAndListen(translate(cmd),\"\\n\"));\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse declare_sort(Ideclare_sort cmd) {\r\n\t\tif (!logicSet) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a declare-sort command is issued\");\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tcheckSatStatus = null;\r\n\t\t\treturn parseResponse(solverProcess.sendAndListen(translate(cmd),\"\\n\"));\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse define_sort(Idefine_sort cmd) {\r\n\t\tif (!logicSet) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a define-sort command is issued\");\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tcheckSatStatus = null;\r\n\t\t\treturn parseResponse(solverProcess.sendAndListen(translate(cmd),\"\\n\"));\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\r\n\t\t}\r\n\t}\r\n\t\r\n\t@Override \r\n\tpublic IResponse get_proof() {\r\n\t\tif (!Utils.TRUE.equals(get_option(smtConfig.exprFactory.keyword(Utils.PRODUCE_PROOFS)))) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The get-proof command is only valid if :produce-proofs has been enabled\");\r\n\t\t}\r\n\t\tif (checkSatStatus != smtConfig.responseFactory.unsat()) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The get-proof command is only valid immediately after check-sat returned unsat\");\r\n\t\t}\r\n\t\ttry {\r\n\t\t\treturn parseResponse(solverProcess.sendAndListen(\"(get-proof)\\n\"));\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override \r\n\tpublic IResponse get_unsat_core() {\r\n\t\tif (!Utils.TRUE.equals(get_option(smtConfig.exprFactory.keyword(Utils.PRODUCE_UNSAT_CORES)))) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The get-unsat-core command is only valid if :produce-unsat-cores has been enabled\");\r\n\t\t}\r\n\t\tif (checkSatStatus != smtConfig.responseFactory.unsat()) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The get-unsat-core command is only valid immediately after check-sat returned unsat\");\r\n\t\t}\r\n\t\ttry {\r\n\t\t\treturn parseResponse(solverProcess.sendAndListen(\"(get-unsat-core)\\n\"));\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override \r\n\tpublic IResponse get_assignment() {\r\n\t\t// FIXME - do we really want to call get-option here? it involves going to the solver?\r\n\t\tif (!Utils.TRUE.equals(get_option(smtConfig.exprFactory.keyword(Utils.PRODUCE_ASSIGNMENTS)))) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The get-assignment command is only valid if :produce-assignments has been enabled\");\r\n\t\t}\r\n\t\tif (checkSatStatus != smtConfig.responseFactory.sat() \u0026\u0026 checkSatStatus != smtConfig.responseFactory.unknown()) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The get-assignment command is only valid immediately after check-sat returned sat or unknown\");\r\n\t\t}\r\n\t\ttry {\r\n\t\t\treturn parseResponse(solverProcess.sendAndListen(\"(get-assignment)\\n\"));\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override \r\n\tpublic IResponse get_value(IExpr... terms) {\r\n\t\t// FIXME - do we really want to call get-option here? it involves going to the solver?\r\n\t\tif (!Utils.TRUE.equals(get_option(smtConfig.exprFactory.keyword(Utils.PRODUCE_MODELS)))) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The get-value command is only valid if :produce-models has been enabled\");\r\n\t\t}\r\n\t\tif (!smtConfig.responseFactory.sat().equals(checkSatStatus) \u0026\u0026 !smtConfig.responseFactory.unknown().equals(checkSatStatus)) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"A get-value command is valid only after check-sat has returned sat or unknown\");\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tsolverProcess.sendNoListen(\"(get-value (\");\r\n\t\t\tfor (IExpr e: terms) {\r\n\t\t\t\tsolverProcess.sendNoListen(\" \",translate(e));\r\n\t\t\t}\r\n\t\t\tString r = solverProcess.sendAndListen(\"))\\n\");\r\n\t\t\tIResponse response = parseResponse(r);\r\n//\t\t\tif (response instanceof ISeq) {\r\n//\t\t\t\tList\u003cISexpr\u003e valueslist = new LinkedList\u003cISexpr\u003e();\r\n//\t\t\t\tIterator\u003cISexpr\u003e iter = ((ISeq)response).sexprs().iterator();\r\n//\t\t\t\tfor (IExpr e: terms) {\r\n//\t\t\t\t\tif (!iter.hasNext()) break;\r\n//\t\t\t\t\tList\u003cISexpr\u003e values = new LinkedList\u003cISexpr\u003e();\r\n//\t\t\t\t\tvalues.add(new Sexpr.Expr(e));\r\n//\t\t\t\t\tvalues.add(iter.next());\r\n//\t\t\t\t\tvalueslist.add(new Sexpr.Seq(values));\r\n//\t\t\t\t}\t\r\n//\t\t\t\treturn new Sexpr.Seq(valueslist);\r\n//\t\t\t}\r\n\t\t\treturn response;\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\t@Override \r\n\tpublic IResponse get_model() {\r\n\t\t// FIXME - do we really want to call get-option here? it involves going to the solver?\r\n\t\tif (!Utils.TRUE.equals(get_option(smtConfig.exprFactory.keyword(Utils.PRODUCE_MODELS)))) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The get-value command is only valid if :produce-models has been enabled\");\r\n\t\t}\r\n\t\tif (!smtConfig.responseFactory.sat().equals(checkSatStatus) \u0026\u0026 !smtConfig.responseFactory.unknown().equals(checkSatStatus)) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"A get-value command is valid only after check-sat has returned sat or unknown\");\r\n\t\t}\r\n\t\ttry {\r\n//\t\t\tsolverProcess.sendNoListen(\"(get-model)\");\t\t\t\r\n\t\t\tsolverProcess.setEndMarker(\"\\n)\\n\");\r\n\t\t\tString r = solverProcess.sendAndListen(\"(get-model)\\n\");\r\n\t\t\tsolverProcess.setEndMarker(\"\\n\");\r\n\t\t\t\r\n\t\t\tIResponse response = parseResponse(r);\r\n\t\t\treturn response;\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\r\n\t\t}\r\n\t}\r\n\t\r\n\t@Override \r\n\tpublic IResponse minimize(IExpr e) {\r\n\t\ttry {\r\n\t\t\tString r = solverProcess.sendAndListen(\"(minimize (\"+translate(e)+\"))\\n\");\r\n\t\t\tIResponse response = parseResponse(r);\r\n\t\t\treturn response;\r\n\t\t} catch (IOException | VisitorException ex) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + ex);\r\n\t\t}\r\n\t}\r\n\t\r\n\t@Override \r\n\tpublic IResponse maximize(IExpr e) {\r\n\t\ttry {\r\n\t\t\tString r = solverProcess.sendAndListen(\"(maximize \"+translate(e)+\")\\n\");\r\n\t\t\tIResponse response = parseResponse(r);\r\n\t\t\treturn response;\r\n\t\t} catch (IOException | VisitorException ex) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + ex);\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic class Translator extends Printer { //extends IVisitor.NullVisitor\u003cString\u003e {\r\n\t\t\r\n\t\tpublic Translator(Writer w) { super(w); }\r\n\r\n//\t\t@Override\r\n//\t\tpublic String visit(IDecimal e) throws IVisitor.VisitorException {\r\n//\t\t\treturn translateSMT(e);\r\n//\t\t}\r\n//\r\n//\t\t@Override\r\n//\t\tpublic String visit(IStringLiteral e) throws IVisitor.VisitorException {\r\n//\t\t\tthrow new VisitorException(\"The Z3 solver cannot handle string literals\",e.pos());\r\n//\t\t}\r\n//\r\n//\t\t@Override\r\n//\t\tpublic String visit(INumeral e) throws IVisitor.VisitorException {\r\n//\t\t\treturn e.value().toString();\r\n//\t\t}\r\n//\r\n//\t\t@Override\r\n//\t\tpublic String visit(IBinaryLiteral e) throws IVisitor.VisitorException {\r\n//\t\t\treturn \"#b\" + e.value();\r\n//\t\t}\r\n//\r\n//\t\t@Override\r\n//\t\tpublic String visit(IHexLiteral e) throws IVisitor.VisitorException {\r\n//\t\t\treturn \"#x\" + e.value();\r\n//\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic Void visit(IFcnExpr e) throws IVisitor.VisitorException {\r\n\t\t\t// Only - for \u003e=2 args is not correctly done, but we can't delegate to translateSMT because it might be a sub-expression.\r\n\t\t\tIterator\u003cIExpr\u003e iter = e.args().iterator();\r\n\t\t\tif (!iter.hasNext()) throw new VisitorException(\"Did not expect an empty argument list\",e.pos());\r\n\t\t\tIQualifiedIdentifier fcn = e.head();\r\n\t\t\tint length = e.args().size();\r\n\t\t\tif (length \u003e 2 \u0026\u0026 (fcn instanceof IIdentifier) \u0026\u0026 fcn.toString().equals(\"-\")) {\r\n\t\t\t\tleftassoc(fcn.toString(),length,iter);\r\n\t\t\t} else {\r\n\t\t\t\tsuper.visit(e);\r\n\t\t\t}\r\n\t\t\treturn null;\r\n//\t\t\tString fcnname = fcn.accept(this);\r\n//\t\t\tStringBuilder sb = new StringBuilder();\r\n//\t\t\tint length = e.args().size();\r\n//\t\t\tif (length \u003e 2 \u0026\u0026 (fcnname.equals(\"=\") || fcnname.equals(\"\u003c\") || fcnname.equals(\"\u003e\") || fcnname.equals(\"\u003c=\") || fcnname.equals(\"\u003e=\"))) {\r\n//\t\t\t\t// chainable\r\n//\t\t\t\treturn chainable(fcnname,iter);\r\n//\t\t\t} else if (fcnname.equals(\"xor\")) {\r\n//\t\t\t\t// left-associative operators that need grouping\r\n//\t\t\t\treturn leftassoc(fcnname,length,iter);\r\n//\t\t\t} else if (length \u003e 1 \u0026\u0026 fcnname.equals(\"-\")) {\r\n//\t\t\t\t// left-associative operators that need grouping\r\n//\t\t\t\treturn leftassoc(fcnname,length,iter);\r\n//\t\t\t} else if (fcnname.equals(\"=\u003e\")) {\r\n//\t\t\t\t// right-associative operators that need grouping\r\n//\t\t\t\tif (!iter.hasNext()) {\r\n//\t\t\t\t\tthrow new VisitorException(\"=\u003e operation without arguments\",e.pos());\r\n//\t\t\t\t}\r\n//\t\t\t\treturn rightassoc(fcnname,iter);\r\n//\t\t\t} else {\r\n//\t\t\t\t// no associativity \r\n//\t\t\t\tsb.append(\"(\");\r\n//\t\t\t\tsb.append(fcnname);\r\n//\t\t\t\twhile (iter.hasNext()) {\r\n//\t\t\t\t\tsb.append(\" \");\r\n//\t\t\t\t\tsb.append(iter.next().accept(this));\r\n//\t\t\t\t}\r\n//\t\t\t\tsb.append(\")\");\r\n//\t\t\t\treturn sb.toString();\r\n//\t\t\t}\r\n\t\t}\r\n\r\n\t\t//@ requires iter.hasNext();\r\n\t\t//@ requires length \u003e 0;\r\n\t\tprotected \u003cT extends IExpr\u003e void leftassoc(String fcnname, int length, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\r\n\t\t\tif (length == 1) {\r\n\t\t\t\titer.next().accept(this);\r\n\t\t\t} else {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tw.append(\"(\");\r\n\t\t\t\t\tw.append(fcnname);\r\n\t\t\t\t\tw.append(\" \");\r\n\t\t\t\t\tleftassoc(fcnname,length-1,iter);\r\n\t\t\t\t\tw.append(\" \");\r\n\t\t\t\t\titer.next().accept(this);\r\n\t\t\t\t\tw.append(\")\");\r\n\t\t\t\t} catch (IOException ex) {\r\n\t\t\t\t\tthrow new IVisitor.VisitorException(ex,null); // FIXME - null ?\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//@ requires iter.hasNext();\r\n\t\tprotected \u003cT extends IExpr\u003e void rightassoc(String fcnname, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\r\n\t\t\tT n = iter.next();\r\n\t\t\tif (!iter.hasNext()) {\r\n\t\t\t\tn.accept(this);\r\n\t\t\t} else {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tw.append(\"(\");\r\n\t\t\t\t\tw.append(fcnname);\r\n\t\t\t\t\tw.append(\" \");\r\n\t\t\t\t\tn.accept(this);\r\n\t\t\t\t\tw.append(\" \");\r\n\t\t\t\t\trightassoc(fcnname,iter);\r\n\t\t\t\t\tw.append(\")\");\r\n\t\t\t\t} catch (IOException ex) {\r\n\t\t\t\t\tthrow new IVisitor.VisitorException(ex,null); // FIXME - null ?\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t\r\n\t\t//@ requires iter.hasNext();\r\n\t\t//@ requires length \u003e 0;\r\n\t\tprotected \u003cT extends IAccept\u003e void chainable(String fcnname, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\r\n\t\t\ttry {\r\n\t\t\t\tw.append(\"(and \");\r\n\t\t\t\tT left = iter.next();\r\n\t\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\t\tw.append(\"(\");\r\n\t\t\t\t\tw.append(fcnname);\r\n\t\t\t\t\tw.append(\" \");\r\n\t\t\t\t\tleft.accept(this);\r\n\t\t\t\t\tw.append(\" \");\r\n\t\t\t\t\t(left=iter.next()).accept(this);\r\n\t\t\t\t\tw.append(\")\");\r\n\t\t\t\t}\r\n\t\t\t\tw.append(\")\");\r\n\t\t\t} catch (IOException ex) {\r\n\t\t\t\tthrow new IVisitor.VisitorException(ex,null); // FIXME - null ?\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n//\t\t@Override\r\n//\t\tpublic String visit(ISymbol e) throws IVisitor.VisitorException {\r\n//\t\t\treturn translateSMT(e);\r\n//\t\t}\r\n//\r\n//\t\t@Override\r\n//\t\tpublic String visit(IKeyword e) throws IVisitor.VisitorException {\r\n//\t\t\tthrow new VisitorException(\"Did not expect a Keyword in an expression to be translated\",e.pos());\r\n//\t\t}\r\n//\r\n//\t\t@Override\r\n//\t\tpublic String visit(IError e) throws IVisitor.VisitorException {\r\n//\t\t\tthrow new VisitorException(\"Did not expect a Error token in an expression to be translated\", e.pos());\r\n//\t\t}\r\n//\r\n//\t\tprivate final String zeros = \"00000000000000000000000000000000000000000000000000\";\r\n//\t\t@Override\r\n//\t\tpublic String visit(IParameterizedIdentifier e) throws IVisitor.VisitorException {\r\n//\t\t\treturn translateSMT(e);\r\n//\t\t}\r\n//\r\n//\t\t@Override\r\n//\t\tpublic String visit(IAsIdentifier e) throws IVisitor.VisitorException {\r\n//\t\t\treturn translateSMT(e);\r\n//\t\t}\r\n//\r\n//\t\t@Override\r\n//\t\tpublic String visit(IForall e) throws IVisitor.VisitorException {\r\n//\t\t\treturn translateSMT(e);\r\n//\t\t}\r\n//\r\n//\t\t@Override\r\n//\t\tpublic String visit(IExists e) throws IVisitor.VisitorException {\r\n//\t\t\treturn translateSMT(e);\r\n//\t\t}\r\n//\r\n//\t\t@Override\r\n//\t\tpublic String visit(ILet e) throws IVisitor.VisitorException {\r\n//\t\t\treturn translateSMT(e);\r\n//\t\t}\r\n//\r\n//\t\t@Override\r\n//\t\tpublic String visit(IAttribute\u003c?\u003e e) throws IVisitor.VisitorException {\r\n//\t\t\tthrow new UnsupportedOperationException(\"visit-IAttribute\");\r\n//\t\t}\r\n//\r\n//\t\t@Override\r\n//\t\tpublic String visit(IAttributedExpr e) throws IVisitor.VisitorException {\r\n//\t\t\treturn translateSMT(e);\r\n//\t\t}\r\n//\r\n//\t\t@Override\r\n//\t\tpublic String visit(IDeclaration e) throws IVisitor.VisitorException {\r\n//\t\t\tthrow new UnsupportedOperationException(\"visit-IDeclaration\");\r\n//\t\t}\r\n//\r\n//\t\t@Override\r\n//\t\tpublic String visit(ISort.IFamily s) throws IVisitor.VisitorException {\r\n//\t\t\treturn s.identifier().accept(this);\r\n//\t\t}\r\n//\t\t\r\n//\t\t@Override\r\n//\t\tpublic String visit(ISort.IAbbreviation s) throws IVisitor.VisitorException {\r\n//\t\t\tthrow new UnsupportedOperationException(\"visit-ISort.IAbbreviation\");\r\n//\t\t}\r\n//\t\t\r\n//\t\t@Override\r\n//\t\tpublic String visit(ISort.IApplication s) throws IVisitor.VisitorException {\r\n//\t\t\treturn translateSMT(s);\r\n//\t\t}\r\n//\t\t\r\n//\t\t@Override\r\n//\t\tpublic String visit(ISort.IFcnSort s) throws IVisitor.VisitorException {\r\n//\t\t\tthrow new UnsupportedOperationException(\"visit-ISort.IFcnSort\");\r\n//\t\t}\r\n//\t\t\r\n//\t\t@Override\r\n//\t\tpublic String visit(ISort.IParameter s) throws IVisitor.VisitorException {\r\n//\t\t\tthrow new UnsupportedOperationException(\"visit-ISort.IParameter\");\r\n//\t\t}\r\n//\t\t\r\n//\t\t@Override\r\n//\t\tpublic String visit(ICommand command) throws IVisitor.VisitorException {\r\n//\t\t\tif (command instanceof ICommand.Iassert) {\r\n//\t\t\t\treturn \"(assert \" + ((ICommand.Iassert)command).expr().accept(this) + \")\";\r\n//\t\t\t} else {\r\n//\t\t\t\treturn translateSMT(command);\r\n//\t\t\t}\r\n//\t\t}\r\n\t}\r\n}\r\n",
        "name": "Solver_z3_4_3.java",
        "path": "smt/lip6.smtlib.SMT/src/org/smtlib/solvers/Solver_z3_4_3.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.SMT/src/org/smtlib/solvers/Solver_z3_4_3.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 744,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 745,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires length \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 764,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 785,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 786,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires length \u003e 0;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.solvers;\r\n\r\nimport java.io.IOException;\r\nimport java.util.Arrays;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\nimport org.smtlib.ICommand.IScript;\r\nimport org.smtlib.ICommand.Ideclare_fun;\r\nimport org.smtlib.*;\r\nimport org.smtlib.ICommand.Idefine_fun;\r\nimport org.smtlib.IExpr.IAsIdentifier;\r\nimport org.smtlib.IExpr.IAttribute;\r\nimport org.smtlib.IExpr.IAttributeValue;\r\nimport org.smtlib.IExpr.IAttributedExpr;\r\nimport org.smtlib.IResponse.IAssertionsResponse;\r\nimport org.smtlib.IResponse.IAssignmentResponse;\r\nimport org.smtlib.IResponse.IAttributeList;\r\nimport org.smtlib.IResponse.IProofResponse;\r\nimport org.smtlib.IResponse.IUnsatCoreResponse;\r\nimport org.smtlib.IResponse.IValueResponse;\r\nimport org.smtlib.ISort.IAbbreviation;\r\nimport org.smtlib.ISort.IApplication;\r\nimport org.smtlib.ISort.IFamily;\r\nimport org.smtlib.ISort.IFcnSort;\r\nimport org.smtlib.ISort.IParameter;\r\nimport org.smtlib.IExpr.*;\r\nimport org.smtlib.IVisitor.VisitorException;\r\n\r\n// Note - simplify appears to have problems if the set of assertions pushed\r\n// via BG_PUSH are not consistent.  At least, it does not produce counterexample\r\n// information in that case.\r\n\r\n/** The adapter that drives the Simplify solver.\r\n * \u003cP\u003e\r\n * Note on implementation.  Simplify allows only either pushing an assertion to\r\n * the background or checking that it is valid.  Assertions that are pushed (via BG_PUSH)\r\n * appear to be filtered out of counterexamples.  Thus for now we will only use\r\n * BG_PUSH for background theory axioms; for the rest we will accumulate all assertions\r\n * into one giant AND (in the conjunction field) and then assert them all at once to Simplify\r\n * when check-sat is called.  The usual push and pop will not be sent to Simplify - rather\r\n * we save the state of 'conjunction' ourselves.  This implements the letter if not the\r\n * spirit of push and pop, and it may have performance implications.  If it does, we'll\r\n * optimize the implementation then. */\r\npublic class Solver_simplify extends Solver_test implements ISolver {\r\n\t\r\n\t/** Just to hold the command line to launch Simplify */\r\n\tString cmds[] = new String[1]; \r\n\t\r\n\t/** The external process driver, initialized in start() */\r\n\tprotected SolverProcess solverProcess;\r\n\t\r\n\t/** Accumulates the translated expressions from various asserts, in order\r\n\t * to send them all at once with a check-sat command.\r\n\t */\r\n\tprivate String conjunction = \"\";\r\n\r\n\t/** The stack on which to save instances of 'conjunction' */\r\n\tprivate List\u003cString\u003e pushesStack = new LinkedList\u003cString\u003e();\r\n\t{\r\n\t\tpushesStack.add(\"\");\r\n\t}\r\n\t\r\n\t/** Constructor with standard signature for invocation through reflection */\r\n\tpublic Solver_simplify(SMT.Configuration smtConfig, String executable) {\r\n\t\tsuper(smtConfig,\"\");\r\n\t\tcmds[0] = executable;\r\n\t\tsolverProcess = new SolverProcess(cmds,\"\u003e\\t\",smtConfig);\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic IResponse start() {\r\n\t\tsuper.start();\r\n\t\tsolverProcess.start(true);\r\n\t\ttry {\r\n\t\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Started simplify\");\r\n\t\t\tsolverProcess.sendAndListen(\"(BG_PUSH (FORALL (B X Y) (IMPLIES (EQ B |@true|) (EQ (\" + ite_term + \" B X Y) X))))\\n\");\r\n\t\t\tsolverProcess.sendAndListen(\"(BG_PUSH (FORALL (B X Y) (IMPLIES (NEQ B |@true|) (EQ (\" + ite_term + \" B X Y) Y))))\\n\");\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to assert background formulae at start\");\r\n\t\t}\r\n\t\treturn smtConfig.responseFactory.success();\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic IResponse exit() {\r\n\t\tsolverProcess.exit();\r\n\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Ended simplify \");\r\n\t\t//process = null;\r\n\t\treturn super.exit();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse assertExpr(IExpr sexpr) {\r\n\t\tIResponse res = super.assertExpr(sexpr);\r\n\t\tif (!res.isOK()) return res;\r\n\t\ttry {\r\n\t\t\tString translatedSexpr = translate(sexpr);\r\n\t\t\tif (translatedSexpr == null) {\r\n\t\t\t\treturn smtConfig.responseFactory.error(\"Failure in translating expression: \" + smtConfig.defaultPrinter.toString(sexpr), sexpr.pos());\r\n\t\t\t}\r\n\t\t\tconjunction = conjunction + \" \\n\" + translatedSexpr;\r\n\t\t\t//String s = solverProcess.sendAndListen(\"(BG_PUSH \",translatedSexpr,\" )\\r\\n\");\r\n\t\t\t//System.out.println(\"HEARD: \" + s);\r\n\t\t} catch (VisitorException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(e.getMessage(),e.pos);\r\n\t\t}\r\n\t\treturn smtConfig.responseFactory.success();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse get_assertions() {\r\n\t\treturn super.get_assertions();\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic IResponse check_sat() {\r\n\t\tIResponse res = super.check_sat();\r\n\t\tif (res.isError()) return res;\r\n\t\ttry {\r\n//\t\t\tString s = solverProcess.sendAndListen(\"(BG_PUSH (EQ 0 0))\\r\\n\");\r\n//\t\t\ts = solverProcess.sendAndListen(\"(EQ 0 1)\\r\\n\");\r\n//\t\t\tif (s.contains(\"Valid.\")) res = smtConfig.responseFactory.unsat();\r\n//\t\t\telse if (s.contains(\"Invalid.\")) res = smtConfig.responseFactory.sat();\r\n//\t\t\telse res = smtConfig.responseFactory.unknown();\r\n\t\t\t\r\n\t\t\tString msg = \"(NOT (AND TRUE \" + conjunction + \"\\n))\\n\";\r\n\t\t\tString s = solverProcess.sendAndListen(msg);\r\n\t\t\t// FIXME - what about errors in SImplify\r\n\t\t\t//smtConfig.log.logOut(\"HEARD: \" + s);\r\n\t\t\tif (s.contains(\"Valid.\")) res = smtConfig.responseFactory.unsat();\r\n\t\t\telse if (s.contains(\"Invalid.\")) res = smtConfig.responseFactory.sat();\r\n\t\t\telse res = smtConfig.responseFactory.unknown();\r\n\t\t\tcheckSatStatus = res;\r\n//\t\t\ts = solverProcess.sendAndListen(\"(BG_POP)\\r\\n\");\r\n\t\t\t\r\n\t\t} catch (IOException e) {\r\n\t\t\tres = smtConfig.responseFactory.error(\"Failed to check-sat\");\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse declare_fun(Ideclare_fun cmd) {\r\n\t\tIResponse res = super.declare_fun(cmd);\r\n\t\tif (res.isError()) return res;\r\n\t\ttry {\r\n\t\t\tif (cmd.resultSort().isBool() \u0026\u0026 cmd.argSorts().size() \u003e 0) {\r\n\t\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\t\tsb.append(\"(DEFPRED (\");\r\n\t\t\t\tsb.append(translate(cmd.symbol()));\r\n\t\t\t\tint n = cmd.argSorts().size();\r\n\t\t\t\tfor (int i = 0; i\u003cn; i++) {\r\n\t\t\t\t\tsb.append(\" X\");  // FIXME - fix this\r\n\t\t\t\t\tsb.append(i);\r\n\t\t\t\t}\r\n\t\t\t\tsb.append(\"))\\n\");\r\n\t\t\t\tString s = solverProcess.sendAndListen(sb.toString());\r\n\t\t\t\t// FIXME - check for error in s -- System.out.println(\"HEARD \" + s);\r\n\t\t\t\tres = smtConfig.responseFactory.success();\r\n\t\t\t} else {\r\n\t\t\t\tres = smtConfig.responseFactory.success();\r\n\t\t\t}\r\n\t\t} catch (IOException e) {\r\n\t\t\tres = smtConfig.responseFactory.error(\"Failed to declare-fun: \" + e.getMessage(),null); // FIXME - position?\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\tres = smtConfig.responseFactory.error(\"Failed to declare-fun: \" + e.getMessage(),null);\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse define_fun(Idefine_fun cmd) {\r\n\t\tIResponse res = super.define_fun(cmd);\r\n\t\tif (res.isError()) return res;\r\n\t\ttry {\r\n\t\t\tif (cmd.resultSort().isBool() \u0026\u0026 cmd.parameters().size() \u003e 0) {\r\n\t\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\t\tsb.append(\"(DEFPRED (\");\r\n\t\t\t\tsb.append(translate(cmd.symbol()));\r\n\t\t\t\tint n = cmd.parameters().size();\r\n\t\t\t\tfor (int i = 0; i\u003cn; i++) {\r\n\t\t\t\t\tsb.append(\" X\");\r\n\t\t\t\t\tsb.append(i);\r\n\t\t\t\t}\r\n\t\t\t\tsb.append(\"))\\n\");\r\n\t\t\t\tString s = solverProcess.sendAndListen(sb.toString());\r\n\t\t\t\t// FIXME - check for error in s -- System.out.println(\"HEARD \" + s);\r\n\t\t\t\tres = smtConfig.responseFactory.success();\r\n\t\t\t} else {\r\n\t\t\t\tres = smtConfig.responseFactory.success();\r\n\t\t\t}\r\n\t\t\tIExpr.IFactory f = smtConfig.exprFactory;\r\n\t\t\tassertExpr(f.fcn(f.symbol(\"=\"),cmd.symbol(),cmd.expression()));\r\n\t\t\t\t\t\r\n\t\t} catch (IOException e) {\r\n\t\t\tres = smtConfig.responseFactory.error(\"Failed to declare-fun: \" + e.getMessage(),null); // FIXME - position?\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\tres = smtConfig.responseFactory.error(\"Failed to declare-fun: \" + e.getMessage(),null);\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t//@ requires number \u003e= 0;\r\n\t@Override\r\n\tpublic IResponse pop(int number) {\r\n\t\tIResponse status = super.pop(number);\r\n\t\tif (!status.isOK()) return status;\r\n\t\ttry {\r\n\t\t\twhile (--number \u003e= 0) { \r\n\t\t\t\tconjunction = pushesStack.remove(0);\r\n\t\t\t\tString s = solverProcess.sendAndListen(\"(BG_POP)\");\r\n\t\t\t\t// FIXME - check for error in s -- System.out.println(\"HEARD \" + s);\r\n\t\t\t}\r\n\t\t\treturn smtConfig.responseFactory.success();\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to push\");\r\n\t\t}\r\n\t}\r\n\r\n\t//@ requires number \u003e= 0;\r\n\t@Override\r\n\tpublic IResponse push(int number) {\r\n\t\tIResponse status = super.push(number);\r\n\t\tif (!status.isOK()) return status;\r\n\t\ttry {\r\n\t\t\twhile (--number \u003e= 0) { \r\n\t\t\t\tpushesStack.add(0,conjunction);\r\n\t\t\t\tString s = solverProcess.sendAndListen(\"(BG_PUSH (EQ 0 0))\");\r\n\t\t\t\t// FIXME - check for error in s -- System.out.println(\"HEARD \" + s);\r\n\t\t\t}\r\n\t\t\treturn smtConfig.responseFactory.success();\r\n\t\t} catch (IOException e) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to push\");\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse set_logic(String logicName, /*@Nullable*/ IPos pos) {\r\n\t\t// FIXME - discrimninate among logics\r\n\t\tboolean lSet = logicSet;\r\n\t\tIResponse status = super.set_logic(logicName,pos);\r\n\t\tif (!status.isOK()) return status;\r\n\t\tif (logicName.contains(\"BV\")) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The simplify solver does not yet support the bit-vector theory\",pos);\r\n\t\t}\r\n\t\tif (lSet) {\r\n\t\t\tpushesStack.clear();\r\n\t\t\tpush(1);\r\n\t\t}\r\n\t\treturn smtConfig.responseFactory.success();\r\n\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse set_option(IKeyword option, IAttributeValue value) {\r\n\t\tif (option.value().equals(\":produce-assignments\")) return smtConfig.responseFactory.unsupported();\r\n\t\tif (option.value().equals(\":produce-models\")) return smtConfig.responseFactory.unsupported();\r\n\t\tif (option.value().equals(\":produce-proofs\")) return smtConfig.responseFactory.unsupported();\r\n\t\tif (option.value().equals(\":produce-unsat-cores\")) return smtConfig.responseFactory.unsupported();\r\n\t\treturn super.set_option(option,value);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse set_info(IKeyword option, IAttributeValue value) {\r\n\t\treturn super.set_info(option,value);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse get_option(IKeyword key) {\r\n\t\tString option = key.value();\r\n\t\tIAttributeValue value = options.get(option);\r\n\t\tif (value == null) return smtConfig.responseFactory.unsupported();\r\n\t\treturn value;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IResponse get_info(IKeyword key) {\r\n\t\tsuper.get_info(key);\r\n\t\tIKeyword option = key;\r\n\t\tIAttributeValue lit;\r\n\t\tif (Utils.ERROR_BEHAVIOR.equals(option)) {\r\n\t\t\tlit = smtConfig.exprFactory.symbol(Utils.CONTINUED_EXECUTION);\r\n\t\t} else if (Utils.AUTHORS.equals(option)) {\r\n\t\t\tlit = smtConfig.exprFactory.unquotedString(\"David Detlefs and Greg Nelson and James B. Saxe\");\r\n\t\t} else if (Utils.VERSION.equals(option)) {\r\n\t\t\tlit = smtConfig.exprFactory.unquotedString(\"1.5.4\");\r\n\t\t} else if (Utils.NAME.equals(option)) {\r\n\t\t\tlit = smtConfig.exprFactory.unquotedString(\"simplify\");\r\n\t\t} else if (Utils.REASON_UNKNOWN.equals(option)) {\r\n\t\t\treturn smtConfig.responseFactory.unsupported();\r\n\t\t} else if (Utils.ALL_STATISTICS.equals(option)) {\r\n\t\t\treturn smtConfig.responseFactory.unsupported();\r\n\t\t} else {\r\n\t\t\treturn smtConfig.responseFactory.unsupported();\r\n\t\t}\r\n\t\tIAttribute\u003c?\u003e attr = smtConfig.exprFactory.attribute(key,lit);\r\n\t\treturn smtConfig.responseFactory.get_info_response(attr);\r\n\t}\r\n\r\n// Pure overrides are redundant\r\n//\t@Override\r\n//\tpublic IResponse declare_sort(Ideclare_sort cmd) {\r\n//\t\treturn super.declare_sort(cmd);\r\n//\t}\r\n//\r\n//\t@Override\r\n//\tpublic IResponse define_fun(Idefine_fun cmd){\r\n//\t\treturn super.define_fun(cmd);\r\n//\t}\r\n//\r\n//\t@Override\r\n//\tpublic IResponse define_sort(Idefine_sort cmd){\r\n//\t\treturn super.define_sort(cmd);\r\n//\t}\r\n\t\r\n\t// These are all currently unsupported\r\n//\t@Override\r\n//\tpublic IResponse get_proof() {\r\n//\t\treturn smtConfig.responseFactory.error(\"The get-proof command is not implemented for simplify\"); // FIXME - get-proof for simplify\r\n//\t}\r\n//\t\r\n//\t@Override\r\n//\tpublic IResponse get_value(IExpr ... terms) {\r\n//\t\treturn smtConfig.responseFactory.error(\"The get-value command is not implemented for simplify\"); // FIXME - get-value for simplify\r\n//\t}\r\n//\t\r\n//\t@Override\r\n//\tpublic IResponse get_assignment() {\r\n//\t\treturn smtConfig.responseFactory.error(\"The get-assignment command is not implemented for simplify\"); // FIXME - get-assignment for simplify\r\n//\t}\r\n//\t\r\n//\t@Override\r\n//\tpublic IResponse get_unsat_core() {\r\n//\t\treturn smtConfig.responseFactory.error(\"The get-proof command is not implemented for simplify\"); // FIXME - get-proof for simplify\r\n//\t}\r\n\r\n\t@Override\r\n\tpublic IResponse get_value(IExpr... terms) {\r\n\t\tTypeChecker tc = new TypeChecker(symTable);\r\n\t\ttry {\r\n\t\t\tfor (IExpr term: terms) {\r\n\t\t\t\tterm.accept(tc);\r\n\t\t\t}\r\n\t\t} catch (IVisitor.VisitorException e) {\r\n\t\t\ttc.result.add(smtConfig.responseFactory.error(e.getMessage()));\r\n\t\t} finally {\r\n\t\t\tif (!tc.result.isEmpty()) return tc.result.get(0); // FIXME - report all errors?\r\n\t\t}\r\n\t\t// FIXME - do we really want to call get-option here? it involves going to the solver?\r\n\t\tif (!Utils.TRUE.equals(get_option(smtConfig.exprFactory.keyword(Utils.PRODUCE_MODELS)))) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"The get-value command is only valid if :produce-models has been enabled\");\r\n\t\t}\r\n\t\tif (!smtConfig.responseFactory.sat().equals(checkSatStatus) \u0026\u0026 !smtConfig.responseFactory.unknown().equals(checkSatStatus)) {\r\n\t\t\treturn smtConfig.responseFactory.error(\"A get-value command is valid only after check-sat has returned sat or unknown\");\r\n\t\t}\r\n\t\treturn smtConfig.responseFactory.unsupported();\r\n\t}\r\n\r\n\r\n\r\n\t\r\n\tpublic /*@Nullable*/String translate(IExpr expr) throws IVisitor.VisitorException {\r\n\t\tTranslator t = new Translator(typemap,smtConfig);\r\n\t\tString r = expr.accept(t);\r\n\t\tif (t.conjuncts.isEmpty()) return r;\r\n\t\tString and = \"(AND \";\r\n\t\tfor (String c: t.conjuncts) {\r\n\t\t\tand = and + c + \" \";\r\n\t\t}\r\n\t\tand = and + r + \" )\";\r\n\t\treturn and;\r\n\t}\r\n\t/* Translating simplify:\r\n\t *  Simplify has no type definitions\r\n\t *  It does not require declaring symbols before use - it presumes\r\n\t *  a symbol is a term or a predicate constant or a function when it\r\n\t *  first sees one.  \r\n\t *  New predicates are defined with DEFPRED\r\n\t *  It has a strict distinction between terms and formulas, so\r\n\t *  \t- there are different symbols for equality (EQ and IFF)\r\n\t *  \t- there are different symbols for inequality (NEQ and (IFF p (NOT q)))\r\n\t *  \t- DISTINCT operates only on terms (and the result is a formula)\r\n\t *  \r\n\t *  \r\n\t *  QUESTIONS: what about overloaded functions\r\n\t */\r\n\t/*    SMTLIB\t\t\tSIMPLIFY\r\n\t * FORMULAE:\r\n\t * (or p q r ...)\t(OR p q r ...)\r\n\t * (and p q r ...)\t(AND p q r ...)\r\n\t * (not p)\t\t\t(NOT p)\r\n\t * (=\u003e p q r ...)\t(IMPLIES p (IMPLIES q r...))\r\n\t * (xor p q r ...)\t(NOT ( IFF ( NOT (IFF p q)) r )) ...\r\n\t * (= p q r ...)\t(IFF (IFF p q) r)  -- formulas\r\n\t * (= p q r ...)\t(AND (EQ p q ) ( EQ q r) ...)  -- terms\r\n\t * (distinct p q r)\t-- does not make sense for more than 2 arguments if the arguments are boolean \r\n\t * (distinct x y z)\t(DISTINCT x y z)  -- x,y,z are terms, result is a formula\r\n\t * true\t\t\t\tTRUE - when used as a formula\r\n\t * false\t\t\tFALSE - when used as a formula\r\n\t * (ite b p q)\t\t_ITEB for formula arguments; _ITET for term arguments\r\n\t * \r\n\t * \u003c \u003c= \u003e \u003e=\t\t\u003c \u003c= \u003e \u003e= - arguments are terms, result is a formula\r\n\t *\r\n\t * TERMS\r\n\t * + - *\t\t\t+ - *\r\n\t * \t    \t\t\tselect store  - for arrays\r\n\t * \r\n\t * In simplify EQ NEQ \u003c \u003c= \u003e \u003e= DISTINCT take terms as arguments, produce formulas\r\n\t * how to handle boolean terms???\r\n\t */\r\n\r\n\t/* Simplify ids:\r\n\t * \t\ta) sequence of alpha, digits, underscore, beginning with alpha\r\n\t * \t\tb) sequence of ! # $ % \u0026 ∗  + − . / : \u003c = \u003e ? @ [ ] ^ _ { } ∼\r\n\t *               excludes | ( ) ` \\ ; \" ' , \r\n\t * \t\tc) printable characters and space except \\ |, surrounded by |\r\n\t *           - also allows undocumented 'escape sequences'\r\n\t *  To translate from SMT-LIB use form (c), but have to remove\r\n\t *  explicit tabs, newlines, crs; also any \\-escape sequences\r\n\t */\r\n\t\r\n\r\n\t/** Name of an if-then-else construct on term arguments */ \r\n\tstatic private String ite_term = \"_ITE\";\r\n\t\r\n\tstatic Map\u003cString,String\u003e fcnNames = new HashMap\u003cString,String\u003e();\r\n\tstatic Set\u003cString\u003e logicNames = new HashSet\u003cString\u003e();\r\n\tstatic Set\u003cString\u003e reservedWords  = new HashSet\u003cString\u003e();\r\n\tstatic Set\u003cString\u003e nonchainables  = new HashSet\u003cString\u003e();\r\n\tstatic {\r\n\t\t// FIXME - this builds in the theories - we should abstract both the naming and the mappings for arbitrary arguments\r\n\t\t// Translations of SMT-LIB standard concrete names to Simplify names\r\n\t\t// Anything not here is considered to be uninterpreted and the\r\n\t\t// SMT-LIB name will be encoded into a unique Simplify name\r\n\t\tfcnNames.put(\"or\",\"OR\");  // \u003e2 arguments OK for simplify (left-assoc)\r\n\t\tfcnNames.put(\"not\",\"NOT\");\r\n\t\tfcnNames.put(\"and\",\"AND\");  // \u003e2 arguments OK for simplify (left-assoc)\r\n\t\tfcnNames.put(\"=\",\"EQ\");\t\t  // \u003e2 arguments NOT OK for simplify (chainable)\r\n\t\tfcnNames.put(\"=\u003e\",\"IMPLIES\"); // \u003e2 arguments NOT OK for simplify (right-assoc)\r\n\t\tfcnNames.put(\"distinct\",\"DISTINCT\"); // \u003e2 arguments OK for simplify (pairwise)\r\n\t\tfcnNames.put(\"xor\",\"NEQ\");\t\t\t// \u003e2 arguments NOT OK for simplify (left-assoc)\r\n\t\tfcnNames.put(\"+\",\"+\");\t\t\t\t// \u003e2 arguments  OK for simplify (left-assoc)\r\n\t\tfcnNames.put(\"-\",\"-\");\t\t\t\t// \u003e2 arguments NOT OK for simplify (left-assoc)\r\n\t\tfcnNames.put(\"*\",\"*\");\t\t\t\t// \u003e2 arguments  OK for simplify (left-assoc)\r\n\t\tfcnNames.put(\"\u003e\",\"\u003e\");\t\t\t\t// \u003e2 arguments NOT OK for simplify\t(left-assoc)\t\t\r\n\t\tfcnNames.put(\"\u003e=\",\"\u003e=\");\t\t\t// \u003e2 arguments NOT OK for simplify (chainable)\r\n\t\tfcnNames.put(\"\u003c\",\"\u003c\");\t\t\t\t// \u003e2 arguments NOT OK for simplify (chainable)\r\n\t\tfcnNames.put(\"\u003c=\",\"\u003c=\");\t\t\t// \u003e2 arguments NOT OK for simplify (chainable)\r\n\t\tfcnNames.put(\"true\",\"TRUE\");\r\n\t\tfcnNames.put(\"false\",\"FALSE\");\r\n\t\tfcnNames.put(\"ite\",ite_term);\r\n\t\t\r\n\t\tfcnNames.put(\"select\",\"select\");\r\n\t\tfcnNames.put(\"store\",\"store\");\r\n\r\n\t\tnonchainables.addAll(Arrays.asList(new String[]{ \"EQ\", \"\u003e\", \"\u003c\", \"\u003e=\", \"\u003c=\", \"IFF\" }));\r\n\t\t\r\n\t\treservedWords.addAll(Arrays.asList(new String[]\r\n\t\t  { \"FORALL\",\"EXISTS\",\"LET\",\r\n\t\t\t\"OR\",\"AND\",\"IMPLIES\",\"EXPLIES\",\"XOR\",\"DISTINCT\",\"IFF\",\"NOT\",\"TRUE\",\"FALSE\",\r\n\t\t\t\"EQ\",\"NEQ\",\"DISTINCT\",\"PATS\",\r\n\t\t\t\"+\",\"-\",\"*\",\"\u003e\",\"\u003e=\",\"\u003c\",\"\u003c=\",\"store\",\"select\",\"@true\",\r\n\t\t\t\"LBLPOS\",\"LBLNEG\",\"LBL\",\"ORDER\",\r\n\t\t\t\"BG_PUSH\",\"BG_POP\",\"DEFPRED\",\"DEFPREDMAP\",\r\n\t\t\tite_term,\r\n\t\t\t}\r\n\t\t));\r\n\t\t\r\n\t\t// These are formulas and take formulas as arguments\r\n\t\tlogicNames.addAll(Arrays.asList(new String[]\r\n\t\t   { \"OR\",\"AND\",\"IMPLIES\",\"EXPLIES\",\"XOR\",\"IFF\",\"NOT\",\"FORALL\",\"EXISTS\"}));\r\n\t}\r\n\t\r\n\tstatic public class Translator implements IVisitor\u003cString\u003e {\r\n\t\tboolean isFormula = true;\r\n\t\tfinal private Map\u003cIExpr,ISort\u003e typemap;\r\n\t\tfinal private SMT.Configuration smtConfig;\r\n\t\tprivate List\u003cString\u003e conjuncts = new LinkedList\u003cString\u003e();\r\n\t\t\r\n\t\tpublic Translator(Map\u003cIExpr,ISort\u003e typemap, SMT.Configuration smtConfig) {\r\n\t\t\tthis.typemap = typemap;\r\n\t\t\tthis.smtConfig = smtConfig;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IDecimal e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new VisitorException(\"The simplify solver cannot handle decimal literals\",e.pos());\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IStringLiteral e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new VisitorException(\"The simplify solver cannot handle string literals\",e.pos());\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(INumeral e) throws IVisitor.VisitorException {\r\n\t\t\treturn e.value().toString();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IBinaryLiteral e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new VisitorException(\"Did not expect a Binary literal in an expression to be translated\",e.pos());\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IHexLiteral e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new VisitorException(\"Did not expect a Hex literal in an expression to be translated\",e.pos());\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IFcnExpr e) throws IVisitor.VisitorException {\r\n\t\t\tboolean resultIsFormula = this.isFormula;\r\n\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\ttry {\r\n\t\t\t\tIterator\u003cIExpr\u003e iter = e.args().iterator();\r\n\t\t\t\tif (!iter.hasNext()) throw new VisitorException(\"Did not expect an empty argument list\",e.pos());\r\n\t\t\t\tif (!(e.head() instanceof ISymbol)) {\r\n\t\t\t\t\tthrow new VisitorException(\"Have not yet implemented parameterized bit-vector functions\",e.pos());\r\n\t\t\t\t}\r\n\t\t\t\tISymbol fcn = (ISymbol)e.head();\r\n\t\t\t\tString newName = fcn.accept(this);\r\n\t\t\t\t\r\n\t\t\t\t// Determine if the arguments are formulas or terms\r\n\t\t\t\tif (resultIsFormula) {\r\n\t\t\t\t\tif (newName != null \u0026\u0026 logicNames.contains(newName)) {\r\n\t\t\t\t\t\t// Propositional boolean item\r\n\t\t\t\t\t\tthis.isFormula = true;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tIExpr arg = e.args().get(1); // Use argument 1 for ite's sake\r\n\t\t\t\t\t\tISort sort = typemap.get(arg);\r\n\t\t\t\t\t\tif (sort == null) {\r\n\t\t\t\t\t\t\tthrow new VisitorException(\"INTERNAL ERROR: Encountered an un-sorted expression node: \" + smtConfig.defaultPrinter.toString(arg),arg.pos());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (sort.isBool()) {\r\n\t\t\t\t\t\t\t// Some functions can take both bool and non-bool arguments:\r\n\t\t\t\t\t\t\t//   EQ NEQ DISTINCT ite\r\n\t\t\t\t\t\t\tthis.isFormula = resultIsFormula;\r\n\t\t\t\t\t\t\tif (\"EQ\".equals(newName)) newName = \"IFF\";\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Arguments must be terms\r\n\t\t\t\t\t\t\tthis.isFormula = false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.isFormula = false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tISort s = typemap.get(e);\r\n\t\t\t\tif (s == null) {\r\n\t\t\t\t\tthrow new VisitorException(\"INTERNAL ERROR: Encountered an un-sorted expression node: \" + smtConfig.defaultPrinter.toString(e),e.pos());\r\n\t\t\t\t}\r\n\t\t\t\tif (s.isBool() \u0026\u0026 !resultIsFormula) {\r\n\t\t\t\t\tthrow new VisitorException(\"Use of boolean in a term position is not yet implemented in the Simplify adapter\",e.pos()); // FIXME - booleans as terms\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (isFormula \u0026\u0026 newName.equals(\"NEQ\")) {\r\n\t\t\t\t\t// for formulas, NEQ is (NOT (IFF p q ...))\r\n\t\t\t\t\t// In simplify, IFF is not implicitly chainable\r\n\t\t\t\t\tint length = e.args().size();\r\n\t\t\t\t\tif ((length\u00261)==0) sb.append(\"(NOT \");\r\n\t\t\t\t\tsb.append(leftassoc(\"IFF\",length,iter));\r\n\t\t\t\t\tif ((length\u00261)==0) sb.append(\")\");\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t} else if (newName.equals(\"IMPLIES\")) {\r\n\t\t\t\t\t// right-associative operators that need grouping\r\n\t\t\t\t\tif (!iter.hasNext()) {\r\n\t\t\t\t\t\tthrow new VisitorException(\"implies (=\u003e) operation without arguments\",e.pos());\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsb.append(rightassoc(newName,iter));\r\n\r\n\t\t\t\t} else if (newName.equals(\"DISTINCT\")) {\r\n\t\t\t\t\t// in simplify, DISTINCT is just for term arguments but the result is a formula\r\n\t\t\t\t\tif (isFormula) {\r\n\t\t\t\t\t\t// arguments are formulas, result is formula\r\n\t\t\t\t\t\tif (e.args().size() \u003e 2) {\r\n\t\t\t\t\t\t\t// More than two distinct boolean values?\r\n\t\t\t\t\t\t\tsb.append(\"FALSE\");\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tsb.append(\"(NOT (IFF\");\r\n\t\t\t\t\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tsb.append(\" ))\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (resultIsFormula) {\r\n\t\t\t\t\t\t// arguments are terms, result is formula - standard use in Simplify\r\n\t\t\t\t\t\tsb.append(\"(DISTINCT\");\r\n\t\t\t\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// used in a term position\r\n\t\t\t\t\t\tthrow new VisitorException(\"Use of DISTINCT in a term position is not yet implemented in the Simplify adapter\",e.pos()); // FIXME - distinact as a term\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (ite_term.equals(newName)) {\r\n\t\t\t\t\tif (isFormula) {\r\n\t\t\t\t\t\tsb.append(\"(AND (IMPLIES \");\r\n\t\t\t\t\t\tsb.append(e.args().get(0).accept(this));\r\n\t\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\t\tsb.append(e.args().get(1).accept(this));\r\n\t\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t\t\tsb.append(\"(IMPLIES (NOT \");\r\n\t\t\t\t\t\tsb.append(e.args().get(0).accept(this));\r\n\t\t\t\t\t\tsb.append(\") \");\r\n\t\t\t\t\t\tsb.append(e.args().get(2).accept(this));\r\n\t\t\t\t\t\tsb.append(\"))\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (e.args().size() \u003e 2 \u0026\u0026 nonchainables.contains(newName)) {\r\n\t\t\t\t\tIterator\u003cIExpr\u003e iter2 = e.args().iterator();\r\n\t\t\t\t\tsb.append(\"(AND \");\r\n\r\n\t\t\t\t\tIExpr left = iter2.next();\r\n\t\t\t\t\twhile (iter2.hasNext()) {\r\n\t\t\t\t\t\tIExpr right = iter2.next();\r\n\t\t\t\t\t\tsb.append(\"(\" + newName + \" \");\r\n\t\t\t\t\t\tsb.append(left.accept(this));\r\n\t\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\t\tsb.append(right.accept(this));\r\n\t\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t\t\tleft = right;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsb.append(\")\");\r\n\t\t\t\t}\r\n\t\t\t\tif (e.args().size() \u003e 2 \u0026\u0026 (newName.equals(\"-\") || newName.equals(\"/\"))) {\r\n\t\t\t\t\tIterator\u003cIExpr\u003e iter2 = e.args().iterator();\r\n\t\t\t\t\tsb.append(leftassoc(newName,e.args().size(),iter2));\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (sb.length() == 0) {\r\n\t\t\t\t\tsb.append(\"( \");\r\n\t\t\t\t\tsb.append(newName);\r\n\t\t\t\t\twhile (iter.hasNext()) {\r\n\t\t\t\t\t\tsb.append(\" \");\r\n\t\t\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsb.append(\" )\");\r\n\t\t\t\t}\r\n\t\t\t} finally {\r\n\t\t\t\tthis.isFormula = resultIsFormula;\r\n\t\t\t}\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\t\t\r\n\t\t//@ requires iter.hasNext();\r\n\t\tprivate \u003cT extends IExpr\u003e String rightassoc(String fcnname, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\r\n\t\t\tT n = iter.next();\r\n\t\t\tif (!iter.hasNext()) {\r\n\t\t\t\treturn n.accept(this);\r\n\t\t\t} else {\r\n\t\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\t\tsb.append(\"(\");\r\n\t\t\t\tsb.append(fcnname);\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(n.accept(this));\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(rightassoc(fcnname,iter));\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t\treturn sb.toString();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//@ requires iter.hasNext();\r\n\t\t//@ requires length \u003e 0;\r\n\t\tprivate \u003cT extends IExpr\u003e String leftassoc(String fcnname, int length, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\r\n\t\t\tif (length == 1) {\r\n\t\t\t\treturn iter.next().accept(this);\r\n\t\t\t} else {\r\n\t\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\t\tsb.append(\"(\");\r\n\t\t\t\tsb.append(fcnname);\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(leftassoc(fcnname,length-1,iter));\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t\tsb.append(iter.next().accept(this));\r\n\t\t\t\tsb.append(\")\");\r\n\t\t\t\treturn sb.toString();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(ISymbol e) throws IVisitor.VisitorException {\r\n\t\t\t// Symbols do not necessarily have sorts - e.g. if they are function names\r\n\t\t\tISort sort = typemap.get(e);\r\n\t\t\tif (!isFormula \u0026\u0026 sort != null \u0026\u0026 sort.isBool()) {\r\n\t\t\t\tthrow new VisitorException(\"Use of boolean in a term position is not yet implemented in the Simplify adapter\",e.pos()); // FIXME - booleans as terms\r\n\t\t\t}\r\n\t\t\t// Simplify does not allow tab, newline, cr in identifiers;\r\n\t\t\t// these are allowed by SMTLIB.\r\n\t\t\t// Note that neither simplify nor SMTLIB allows \\ or |\r\n\t\t\t// All other printable characters are allowed in both.\r\n\t\t\tString oldName = e.value();\r\n\t\t\tString newName = fcnNames.get(oldName);\r\n\t\t\tif (newName != null) {\r\n\t\t\t\t// There is a direct translation of a pre-defined SMT-LIB name\r\n\t\t\t\t// into a simplify equivalent - use it.\r\n\t\t\t} else {\r\n\t\t\t\t// Use the ? character as an escape\r\n\t\t\t\tnewName = oldName.replace(\"?\",\"??\").replace(\"\\n\",\"?n\").replace(\"\\r\",\"?r\").replace(\"\\t\",\"?t\");\r\n\t\t\t\tif (reservedWords.contains(newName)) {\r\n\t\t\t\t\tnewName = newName + \"?!\";\r\n\t\t\t\t}\r\n\t\t\t\tnewName = \"|\" + newName + \"|\";\r\n\t\t\t}\r\n\t\t\treturn newName;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IKeyword e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new VisitorException(\"Did not expect a Keyword in an expression to be translated\",e.pos());\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IError e) throws IVisitor.VisitorException {\r\n\t\t\tthrow new VisitorException(\"Did not expect a Error token in an expression to be translated\",e.pos());\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IParameterizedIdentifier e) throws IVisitor.VisitorException {\r\n\t\t\tif (!isFormula \u0026\u0026 typemap.get(e).isBool()) {\r\n\t\t\t\tthrow new VisitorException(\"Use of boolean in a term position is not yet implemented in the Simplify adapter\",e.pos()); // FIXME - booleans as terms\r\n\t\t\t}\r\n\t\t\t// Since there is no overloading, the head will be a new symbol\r\n\t\t\t// and we don't need to worry that it collides with a pre- or user-defined\r\n\t\t\t// function name\r\n\t\t\tString v = e.headSymbol().accept(this); // This will come back with bars\r\n\t\t\tif (v.charAt(0) != '|') {\r\n\t\t\t\tthrow new VisitorException(\"INTERNAL ERROR: Do not expect to ever have a pre-defined name within a parameterized identifier\",e.headSymbol().pos());\r\n\t\t\t}\r\n\t\t\tv = v.substring(0,v.length()-1);\r\n\t\t\tfor (INumeral n: e.numerals()) {\r\n\t\t\t\tv = v + \"?\" + n.toString();\r\n\t\t\t}\r\n\t\t\treturn v + \"|\";\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IForall e) throws IVisitor.VisitorException {\r\n\t\t\tif (!isFormula) {\r\n\t\t\t\tthrow new VisitorException(\"Use of forall in a term position is not yet implemented in the Simplify adapter\",e.pos()); // FIXME - booleans as terms\r\n\t\t\t}\r\n\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\tsb.append(\"(FORALL (\");\r\n\t\t\tfor (IDeclaration d: e.parameters()) {\r\n\t\t\t\tif (d.sort().isBool()) {\r\n\t\t\t\t\tthrow new VisitorException(\"Boolean quantifiers are not implemented in the Simplify adapter\",e.pos()); // FIXME - booleans as terms\r\n\t\t\t\t}\r\n\t\t\t\tsb.append(d.parameter().accept(this));\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t}\r\n\t\t\tsb.append(\") \");\r\n\t\t\tsb.append(e.expr().accept(this));\r\n\t\t\tsb.append(\")\");\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IExists e) throws IVisitor.VisitorException {\r\n\t\t\tif (!isFormula) {\r\n\t\t\t\tthrow new VisitorException(\"Use of exists in a term position is not yet implemented in the Simplify adapter\",e.pos()); // FIXME - booleans as terms\r\n\t\t\t}\r\n\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\tsb.append(\"(EXISTS (\");\r\n\t\t\tfor (IDeclaration d: e.parameters()) {\r\n\t\t\t\tif (d.sort().isBool()) {\r\n\t\t\t\t\tthrow new VisitorException(\"Boolean quantifiers are not implemented in the Simplify adapter\",e.pos()); // FIXME - booleans as terms\r\n\t\t\t\t}\r\n\t\t\t\tsb.append(d.accept(this));\r\n\t\t\t\tsb.append(\" \");\r\n\t\t\t}\r\n\t\t\tsb.append(\") \");\r\n\t\t\tsb.append(e.expr().accept(this));\r\n\t\t\tsb.append(\")\");\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\t\t\r\n\t\t@Override \r\n\t\tpublic String visit(IDeclaration e) throws IVisitor.VisitorException {\r\n\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\tsb.append(e.parameter().accept(this));\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(ILet e) throws IVisitor.VisitorException {\r\n\t\t\t// Simplify does not have let\r\n\t\t\t// We can create a new temp variable (or function of any quantified parameters)\r\n\t\t\t// and then use that.\r\n\t\t\tfor (IBinding b : e.bindings()) {\r\n\t\t\t\tString r = b.expr().accept(this);\r\n\t\t\t\tISort s = typemap.get(b.expr());\r\n\t\t\t\t// FIXME - don't use toString - also need to map to a unique new temporary\r\n\t\t\t\tr = (s.isBool()? \"(IFF \" : \"(EQ \") + b.parameter().accept(this) + \" \" + r + \" )\";\r\n\t\t\t\tconjuncts.add(r);\r\n\t\t\t}\r\n\t\t\treturn e.expr().accept(this);\r\n\t\t\t//throw new VisitorException(\"Use of let is not yet implemented in the Simplify adapter\",e.pos()); // FIXME - let in Simplify\r\n\t\t}\r\n\r\n\t\t@Override \r\n\t\tpublic String visit(IBinding e) throws IVisitor.VisitorException {\r\n//\t\t\tStringBuilder sb = new StringBuilder();\r\n//\t\t\tsb.append(e.parameter().accept(this));\r\n//\t\t\treturn sb.toString();\r\n\t\t\tthrow new VisitorException(\"Use of bindings is not yet implemented in the Simplify adapter\",e.pos()); // FIXME - let in Simplify\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IAttribute e) throws VisitorException {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IAttributedExpr e) throws VisitorException {\r\n\t\t\t// FIXME - ignoring the name - should use a LBL expression\r\n\t\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\tsb.append(\"(LBL \");\r\n\t\t\tsb.append(e.attributes().get(0).attrValue().toString()); // Use the standard printer FIXME\r\n\t\t\tsb.append(\" \");\r\n\t\t\tsb.append(e.expr().accept(this));\r\n\t\t\tsb.append(\")\");\r\n\t\t\treturn sb.toString();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(org.smtlib.IResponse.IError e)\r\n\t\t\t\tthrows VisitorException {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IAsIdentifier e) throws VisitorException {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IScript e) throws VisitorException {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(ICommand e) throws VisitorException {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IFamily s) throws VisitorException {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IAbbreviation s) throws VisitorException {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IApplication s) throws VisitorException {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IFcnSort s) throws VisitorException {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IParameter s) throws VisitorException {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(ILogic s) throws VisitorException {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(ITheory s) throws VisitorException {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IResponse e) throws VisitorException {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IAssertionsResponse e) throws VisitorException {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IAssignmentResponse e) throws VisitorException {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IProofResponse e) throws VisitorException {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IValueResponse e) throws VisitorException {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IUnsatCoreResponse e) throws VisitorException {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String visit(IAttributeList e) throws VisitorException {\r\n\t\t\t// TODO Auto-generated method stub\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\r\n//\t\t@Override\r\n//\t\tpublic String visit(IScript e) throws IVisitor.VisitorException {\r\n//\t\t\tthrow new VisitorException(e,\"Did not expect a Script in an expression to be translated\");\r\n//\t\t}\r\n\r\n//\t\t@Override\r\n//\t\tpublic String visit(IResponse e) throws IVisitor.VisitorException {\r\n//\t\t\tthrow new VisitorException(e,\"Did not expect a IResponse in an expression to be translated\");\r\n//\t\t}\r\n//\t\t\r\n\t}\r\n\r\n\r\n}\r\n",
        "name": "Solver_simplify.java",
        "path": "smt/lip6.smtlib.SMT/src/org/smtlib/solvers/Solver_simplify.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.SMT/src/org/smtlib/solvers/Solver_simplify.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 213,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires number \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 230,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires number \u003e= 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 658,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 676,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 677,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires length \u003e 0;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT plug-in project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.plugin;\r\n\r\n// FIXME implement logic, out, diag, port, relax -- check all options\r\n\r\nimport java.io.File;\r\nimport java.util.Enumeration;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\n\r\nimport org.eclipse.core.runtime.Platform;\r\nimport org.eclipse.jface.preference.IPreferenceStore;\r\nimport org.eclipse.swt.SWT;\r\nimport org.eclipse.swt.custom.CTabFolder;\r\nimport org.eclipse.swt.custom.CTabItem;\r\nimport org.eclipse.swt.widgets.Composite;\r\nimport org.eclipse.swt.widgets.Control;\r\nimport org.eclipse.swt.widgets.Label;\r\nimport org.eclipse.ui.IWorkbench;\r\nimport org.eclipse.ui.IWorkbenchPreferencePage;\r\nimport org.osgi.framework.Bundle;\r\nimport org.smtlib.SMT.Configuration;\r\n\r\n/**\r\n * @author David Cok\r\n * \r\n * This class implements the preference page for the plugin.\r\n * To add a new Preference:\r\n *  - add a String to POptions -- this is the key used in the preference database\r\n *  - add an AbstractPreference for that key to POptions - this specifies the kind of preference (Boolean, String, Choice, ...)\r\n *  - add a PreferenceWidget linked to the AbstractPreference to one of the PreferenceWidget arrays (e.g. options, pluginOptions)\r\n *  - if you create a new array, alter createContents, performOK, performDefaults\r\n */\r\npublic class Preferences extends org.eclipse.jface.preference.PreferencePage \r\nimplements IWorkbenchPreferencePage {\r\n\r\n\t/* (non-Javadoc)\r\n\t * @see org.eclipse.ui.IWorkbenchPreferencePage#init(org.eclipse.ui.IWorkbench)\r\n\t */\r\n\t// FIXME _ what might go in here?\r\n\tpublic void init(IWorkbench workbench) {\r\n\t}\r\n\r\n\t/** This class defines all the items that have a persistent\r\n\t * presence in the Preferences store. */\r\n\tstatic public class POptions {\r\n\t\t/** The prefix to be put on each key. */\r\n\t\tfinal static public String prefix = \"org.smtlib.plugin.\";\r\n\r\n\t\t/** The preference store key for the verbose option. */\r\n\t\tfinal static public String verbosePluginKey = prefix + \"verbosePlugin\";\r\n\r\n\t\t/** The preference store key for the verbose SMT app option. */\r\n\t\tfinal static public String verboseKey = prefix + \"verbose\";\r\n\r\n\t\t/** The preference store key for the verbose SMT solver option. */\r\n\t\tfinal static public String solverVerbosityKey = prefix + \"solverVerbosity\";\r\n\r\n\t\t/** The preference store key for the print-success option. */\r\n\t\tfinal static public String printSuccessKey = prefix + \"printSuccess\";\r\n\r\n\t\t/** The preference store key for the abort-on-error option. */\r\n\t\tfinal static public String abortKey = prefix + \"abort\";\r\n\r\n\t\t/** The preference store key for the print-success option. */\r\n\t\tfinal static public String relaxKey = prefix + \"relax\";\r\n\r\n\t\t/** The preference store key for the print-success option. */\r\n\t\tfinal static public String echoKey = prefix + \"echo\";\r\n\r\n\t\t/** The preference store key for the logic option. */\r\n\t\tfinal static public String logicKey = prefix + \"logic\";\r\n\r\n\t\t/** The preference store key for the logics option. */\r\n\t\tfinal static public String logicsKey = prefix + \"logics\";\r\n\r\n\t\t/** The preference store key for the default solver choice option. */\r\n\t\tfinal static public String defaultSolverKey = prefix + \"defaultSolver\";\r\n\r\n\t\t/** The preference store key for option storing the path to the given solver's executable. */\r\n\t\tfinal static public String execKey(String solver) {\r\n\t\t\treturn prefix + \"execKey_\" + solver;\r\n\t\t}\r\n\t\t// The various option objects\r\n\t\t\r\n\t\tpublic AbstractPreference.BooleanOption verbosePlugin = \r\n\t\t\tnew AbstractPreference.BooleanOption(verbosePluginKey, false, \"verbose plug-in?\", \"If true, progress and debugging information from the plug-in is printed.\");\r\n\r\n\t\tpublic AbstractPreference.BooleanOption verbose = \r\n\t\t\tnew AbstractPreference.BooleanOption(verboseKey, false, \"verbose SMT app?\", \"If true, diagnostic information from the SMT app is printed.\");\r\n\r\n\t\tpublic AbstractPreference.IntOption solverVerbosity = \r\n\t\t\tnew AbstractPreference.IntOption(solverVerbosityKey, 0, \"SMT solver verbosity\", \"Verbosity level of the SMT solver, 0 for quiet\");\r\n\r\n\t\tpublic AbstractPreference.BooleanOption printSuccess = \r\n\t\t\tnew AbstractPreference.BooleanOption(printSuccessKey, true, \"print success?\", \"If true, all command results are printed; if false, all except success are printed.\");\r\n\r\n\t\tpublic AbstractPreference.BooleanOption abort = \r\n\t\t\tnew AbstractPreference.BooleanOption(abortKey, false, \"abort on error?\", \"If true, an error aborts further processing.\");\r\n\r\n\t\tpublic AbstractPreference.BooleanOption echo = \r\n\t\t\tnew AbstractPreference.BooleanOption(echoKey, false, \"echo batch commands?\", \"If true, batch commands are echoed to the output as they are executed\");\r\n\t\tpublic AbstractPreference.BooleanOption relax = \r\n\t\t\tnew AbstractPreference.BooleanOption(relaxKey, false, \"relax conformity?\", \"If true, some not-strictlyu-SMT-LIB enahancements are allowed; if false, SMT-LIB is strictly enforced.\");\r\n\r\n\t\tpublic AbstractPreference.StringOption logics = \r\n\t\t\tnew AbstractPreference.StringOption(logicsKey,\"\",\"Directory containing logic files (if empty, built-in logic files are used)\",\"Directory that contains the files defining SMT-LIB logics and theories\");\r\n\r\n\t\tpublic String[] logicNames = new String[]{};\r\n\t\t{\r\n\t\t\tString logicsDir = logics.getValue();\r\n\t\t\tList\u003cString\u003e logicList = new LinkedList\u003cString\u003e();\r\n\t\t\tif (logicsDir.trim().length() != 0) {\r\n\t\t\t\tFile dir = new File(logicsDir);\r\n\t\t\t\tlogicList.add(\"\");\r\n\t\t\t\tif (dir.isDirectory()) {\r\n\t\t\t\t\tfor (String f : dir.list()) {\r\n\t\t\t\t\t\tif (f.endsWith(org.smtlib.Utils.SUFFIX)) {\r\n\t\t\t\t\t\t\tf = f.substring(0,f.length() - org.smtlib.Utils.SUFFIX.length());\r\n\t\t\t\t\t\t\tif (f.charAt(1) \u003c= 'Z') {\r\n\t\t\t\t\t\t\t\tlogicList.add(f);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else { // FIXME - unify this with findLogic in Activator\r\n\t\t\t\tBundle b = Platform.getBundle(org.smtlib.Utils.PLUGIN_ID);\r\n\t\t\t\t@SuppressWarnings(\"unchecked\")\r\n\t\t\t\tEnumeration\u003cString\u003e e = (Enumeration\u003cString\u003e)b.getEntryPaths(\"logics/\");\r\n\t\t\t\twhile (e.hasMoreElements()) {\r\n\t\t\t\t\tString p = e.nextElement();\r\n\t\t\t\t\tint n = 1 + p.indexOf('/');\r\n\t\t\t\t\tint nn = p.indexOf('.');\r\n\t\t\t\t\tif (nn != -1) logicList.add(p.substring(n,nn));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlogicNames = logicList.toArray(logicNames);\r\n\t\t}\r\n\t\t\r\n\t\t// FIXME - This gets set dynamically when the plugin first starts; changes in the logic path are not\r\n\t\t// changed until the plug-in restarts\r\n\t\t\r\n\t\tpublic AbstractPreference.ChoiceOption logic = dynamicLogicList(logicKey, logics.getValue());\r\n\r\n\t\t/** Names of defaultSolver to include; test must be first */\r\n\t\tpublic static final String[] solverNames = new String[]{org.smtlib.Utils.TEST_SOLVER,\"simplify\",\"yices\",\"cvc\",\"z3_2_11\",\"z3_4_3\"};\r\n\t\t\r\n\t\tpublic AbstractPreference.ChoiceOption defaultSolver = \r\n\t\t\tnew AbstractPreference.ChoiceOption(defaultSolverKey,\r\n\t\t\t\t\tsolverNames,\r\n\t\t\t\t\t0,\r\n\t\t\t\t\t\"Default solver to use\",\r\n\t\t\t\"The default solver to use in response to menu commands\");\r\n\r\n\t\tpublic List\u003cAbstractPreference.StringOption\u003e execOptions = new LinkedList\u003cAbstractPreference.StringOption\u003e();\r\n\t\t\r\n\t\tpublic POptions() {\r\n\t\t\t// Skip solverNames[0] (\"test\")\r\n\t\t\tfor (int i = 1; i\u003csolverNames.length; ++i) {\r\n\t\t\t\tString name = solverNames[i];\r\n\t\t\t\texecOptions.add(new AbstractPreference.StringOption(execKey(name),\"\",name + \" executable\",\"File system path to the executable for the \"+name+\" solver\"));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\tpublic static AbstractPreference.ChoiceOption dynamicLogicList(String logicKey, String logicsDir) {\r\n\t\tString[] logicNames = new String[]{};\r\n\t\tFile dir = new File(logicsDir);\r\n\t\tList\u003cString\u003e logicList = new LinkedList\u003cString\u003e();\r\n\t\tlogicList.add(\"\");\r\n\t\tif (dir.isDirectory()) {\r\n\t\t\tfor (String f : dir.list()) {\r\n\t\t\t\tif (f.endsWith(org.smtlib.Utils.SUFFIX)) {\r\n\t\t\t\t\tf = f.substring(0,f.length() - org.smtlib.Utils.SUFFIX.length());\r\n\t\t\t\t\tif (f.charAt(1) \u003c= 'Z') {\r\n\t\t\t\t\t\tlogicList.add(f);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tlogicNames = logicList.toArray(logicNames);\r\n\t\t\r\n\t\treturn\r\n\t\t\tnew AbstractPreference.ChoiceOption(logicKey, logicNames, 0, \"implicit logic:\", \"If set, the logic to set implicitly for each SMT execution.\");\r\n\r\n\t}\r\n\t\r\n\t/** An instance of the object that holds all of the preference store items being used. */\r\n\tstatic POptions poptions = new POptions();\r\n\r\n\t/** This method fills in a Configuration structure whose values are set from\r\n\t * the current preference store settings (which should match those in the UI).\r\n\t * We use the preference store instead of the UI widgets so that this method\r\n\t * works even if the preference page has not yet been generated.  If the \r\n\t * argument is null, a new Configuration structure is allocated; otherwise the\r\n\t * fields of the argument are filled in.  The argument or newly allocated \r\n\t * object is returned.\r\n\t * @param options if not null, the structure to fill in\r\n\t * @return An Configuration structure initialized to the current preference store settings.\r\n\t */\r\n\tstatic public Configuration extractOptions(Configuration smtConfig) {\r\n\t\tif (smtConfig == null) {\r\n\t\t\tsmtConfig = new Configuration();\r\n\t\t}\r\n\t\tActivator.verbose = poptions.verbosePlugin.getValue();\r\n\t\tsmtConfig.verbose = poptions.verbose.getValue() ? 1 : 0;\r\n\t\tsmtConfig.solverVerbosity = poptions.solverVerbosity.getValue();\r\n\t\tsmtConfig.nosuccess = !poptions.printSuccess.getValue();\r\n\t\tsmtConfig.abort = poptions.abort.getValue();\r\n\t\tsmtConfig.echo = poptions.echo.getValue();\r\n\t\tsmtConfig.relax = poptions.relax.getValue();\r\n\t\t\r\n\t\tsmtConfig.logic = null;\r\n//\t\tif (poptions.logic.getIndexValue() == 0) options.logic = null; // FIXME - implement implicit logic?\r\n//\t\telse options.logic = poptions.logic.getStringValue();\r\n\t\t\r\n\t\tsmtConfig.solvername = poptions.defaultSolver.getStringValue();\r\n\t\tsmtConfig.logicPath = poptions.logics.getValue();\r\n\t\tif (smtConfig.logicPath.trim().isEmpty()) smtConfig.logicPath = null;\r\n\t\tif (Activator.verbose) Activator.log.logln(\"Extracted options\");\r\n\t\treturn smtConfig;\r\n\t}\r\n\r\n\r\n\tstatic PreferenceWidget.ChoiceWidget logicChoiceWidget;\r\n\tstatic PreferenceWidget.DirectoryWidget logicPathWidget;\r\n\t/**\r\n\t * An array of the SMT option widgets.\r\n\t */\r\n\tstatic private PreferenceWidget[] options = {\r\n\t\tnew PreferenceWidget.BooleanWidget(poptions.verbose),\r\n\t\tnew PreferenceWidget.IntWidget(poptions.solverVerbosity, new String[]{\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"}),\r\n\t\tnew PreferenceWidget.BooleanWidget(poptions.printSuccess),\r\n\t\tnew PreferenceWidget.BooleanWidget(poptions.abort),\r\n\t\tnew PreferenceWidget.BooleanWidget(poptions.echo),\r\n\t\tnew PreferenceWidget.BooleanWidget(poptions.relax),\r\n\t\tnew PreferenceWidget.ChoiceWidget(poptions.defaultSolver),\r\n\t\tlogicChoiceWidget=new PreferenceWidget.ChoiceWidget(poptions.logic),\r\n\t\tlogicPathWidget=new PreferenceWidget.DirectoryWidget(poptions.logics),\r\n\t};\r\n\t\r\n\tstatic private PreferenceWidget[] solverConfig = new PreferenceWidget[poptions.execOptions.size()];\r\n\r\n\t\r\n\tstatic {\r\n\t\tList\u003cPreferenceWidget\u003e list = new LinkedList\u003cPreferenceWidget\u003e();\r\n\t\tfor (AbstractPreference.StringOption s: poptions.execOptions) {\r\n\t\t\tlist.add(new PreferenceWidget.FileWidget(s));\r\n\t\t}\r\n\t\tsolverConfig = list.toArray(solverConfig);\r\n\t\t// FIXME _ have not been able to get this to work\r\n//\t\tlogicPathWidget.addModifyListener( new ModifyListener() {\r\n//\t\t\tpublic void modifyText(ModifyEvent e) {\r\n//\t\t\t\tif (logicPathWidget != null \u0026\u0026 logicChoiceWidget != null \u0026\u0026 poptions != null \u0026\u0026 poptions.logic != null) {\r\n//\t\t\t\tpoptions.logic = dynamicLogicList(POptions.logicKey,logicPathWidget.value());\r\n//\t\t\t\tlogicChoiceWidget.setChoices(poptions.logic.choices());\r\n//\t\t\t\t}\r\n//\t\t\t}\r\n//\t\t});\r\n\t}\r\n\t\r\n\tstatic final public String getExec(String solver) throws java.lang.Exception {\r\n\t\tString key = POptions.execKey(solver);\r\n\t\tfor (AbstractPreference.StringOption p: poptions.execOptions) {\r\n\t\t\tif (p.key().equals(key)) return p.getValue();\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/**\r\n\t * An array of widgets for plugin options.\r\n\t */\r\n\tstatic final private PreferenceWidget[] pluginOptions = {\r\n\t\tnew PreferenceWidget.BooleanWidget(poptions.verbosePlugin),\r\n\t};\r\n\t\r\n//\tstatic final private PreferenceWidget[] execOptions = new PreferenceWidget[poptions.execOptions.size()];\r\n//\t{\r\n//\t\tint i = 0;;\r\n//\t\tfor (AbstractPreference.StringOption p: poptions.execOptions) {\r\n//\t\t\texecOptions[i++] = new PreferenceWidget.StringWidget(p);\r\n//\t\t}\r\n//\t}\r\n\r\n\t/**\r\n\t * Creates the property page controls and initializes them.\r\n\t * \r\n\t * @param parent The UI object into which to insert the controls\r\n\t * @return The new control that is added to 'parent'\r\n\t */\r\n\tprotected Control createContents(Composite parent) {\r\n\r\n\t\t// Creates the contents of the property page view.\r\n\r\n\t\tCTabFolder tf = new CTabFolder(parent, SWT.TOP|SWT.MULTI|SWT.FLAT);\r\n\t\tCTabItem mainTab = new CTabItem(tf,SWT.NONE,0);\r\n\t\tmainTab.setText(\"General\");\r\n\t\tCTabItem solverTab = new CTabItem(tf,SWT.NONE,1);\r\n\t\tsolverTab.setText(\"Solvers\");\r\n\t\tComposite generalComposite = new Widgets.VComposite(tf);\r\n\t\tmainTab.setControl(generalComposite);\r\n\t\tComposite solverComposite = new Widgets.VComposite(tf);\r\n\t\tsolverTab.setControl(solverComposite);\r\n\t\taddWidgets(solverConfig,solverComposite);\r\n\r\n\t\tComposite composite0 = generalComposite;\r\n\t\t\r\n\t\t// Patched to handle uncaught exception\r\n\t\tString version = \"unknown version\";\r\n\t\ttry { \r\n\t\t\tversion = org.smtlib.Version.version();\t\r\n\t\t} catch (RuntimeException re) {\r\n\t\t\tSystem.err.println(\"Obtaining version from bundle failed with error \"+re.getMessage());\r\n\t\t\tversion = \"JSMTLib: \" + Activator.getDefault().getBundle().getVersion().toString();\r\n\t\t}\r\n\t\tnew Label(composite0, SWT.CENTER).setText(\"SMT version: \" + version);\r\n\t\t\r\n\t\tnew Label(composite0, SWT.CENTER)\r\n\t\t.setText(\"These choices are workspace options that apply to every SMT-LIB project.\");\r\n\r\n\t\tnew Widgets.LabeledSeparator(composite0, \"Configuration relating to the plugin\");\r\n\t\taddWidgets(pluginOptions, composite0);\r\n\t\tnew Widgets.LabeledSeparator(composite0, \"Configuration relating to SMT\");\r\n\t\taddWidgets(options, composite0);\r\n\r\n\t\ttf.showItem(mainTab);\r\n\t\ttf.setSelection(mainTab);\r\n\t\treturn composite0;\r\n\r\n\t}\r\n\r\n//\t/**\r\n//\t * Constructs the view of the property page by adding different features like\r\n//\t * labels, and setting the layout. Just a helper to \u003ccode\u003ecreateContents()\r\n//\t * \u003c/code\u003e.\r\n//\t * \r\n//\t * @param parent The parent composite to which the controls are added\r\n//\t * @return The resulting control that defined the looking of the property page\r\n//\t */\r\n//\tprivate Control addControl(Composite parent) {\r\n//\t\tComposite composite0 = new Widgets.VComposite(parent);\r\n//\r\n//\t\tnew Label(composite0, SWT.CENTER).setText(\"SMT version: \" + org.smtlib.Utils.SW_VERSION);\r\n//\t\tnew Label(composite0, SWT.CENTER)\r\n//\t\t.setText(\"These options are workspace options that apply to every SMT-LIB project.\");\r\n//\t\t//  Composite composite0 = new Widgets.HComposite(composite0a, 2);\r\n//\t\t//  Composite composite1 = new Widgets.VComposite(composite0);\r\n//\t\t//  Composite composite2a = new Widgets.VComposite(composite0);\r\n//\t\t//  Composite composite2 = new Widgets.HComposite(composite2a, 2);\r\n//\t\t//  Composite composite3 = new Widgets.VComposite(composite2);\r\n//\t\t//  Composite composite4 = new Widgets.VComposite(composite2);\r\n//\r\n//\t\t//    new Widgets.LabeledSeparator(composite0, \"Configuration relating to Eclipse\");\r\n//\t\t//    addWidgets(eclipseOptions, composite0);\r\n//\t\t//    new Widgets.LabeledSeparator(composite0, \"Configuration relating to Java\");\r\n//\t\t//    addWidgets(javaOptions, composite0);\r\n//\t\tnew Widgets.LabeledSeparator(composite0, \"Configuration relating to the plugin\");\r\n//\t\taddWidgets(pluginOptions, composite0);\r\n//\t\tnew Widgets.LabeledSeparator(composite0, \"Configuration relating to SMT\");\r\n//\t\taddWidgets(options, composite0);\r\n//\t\t//    new Widgets.LabeledSeparator(composite0, \"Configuration for debugging\");\r\n//\t\t//    addWidgets(debugOptions, composite0);\r\n//\r\n//\t\treturn composite0;\r\n//\t}\r\n\r\n\t/**\r\n\t * @see org.eclipse.jface.preference.IPreferencePage#performOk()\r\n\t */\r\n\tpublic boolean performOk() {\r\n\t\t// When OK is pressed, set all the options selected.\r\n\t\tsetOptionValue(pluginOptions);\r\n\t\tsetOptionValue(options);\r\n\t\tsetOptionValue(solverConfig);\r\n\r\n\t\tif (false) {\r\n\t\t\t// FIXME _ hard coded array positions is fragile\r\n\t\t\tpoptions.logic = dynamicLogicList(POptions.logicKey,logicPathWidget.value());\r\n\t\t\tlogicChoiceWidget.setChoices(poptions.logic.choices());\r\n\t\t}\r\n\t\tAbstractPreference.notifyListeners();\r\n\t\treturn true;\r\n\t}\r\n\r\n\tpublic void performDefaults() {\r\n\t\t// When OK is pressed, set all the options selected.    \r\n\t\tsetDefaults(pluginOptions);\r\n\t\tsetDefaults(options);\r\n\t\tsetDefaults(solverConfig);\r\n\t}\r\n\r\n\t/** Calls setDefault for each widget in the list\r\n\t * \r\n\t * @param ws an array of widgets to be processed\r\n\t */\r\n\t//@ requires ws != null;\r\n\t//@ requires \\nonnullelements(ws);\r\n\tpublic void setDefaults(PreferenceWidget[] ws) {\r\n\t\tfor (int i = 0; i\u003cws.length; ++i) {\r\n\t\t\tws[i].setDefault();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Calls 'setOptionValue' on all the items in the array,\r\n\t * so that the stored options are set from the UI\r\n\t * @param ws An array of PreferenceWidget items \r\n\t */\r\n\t//@ requires ws != null;\r\n\t//@ requires \\nonnullelements(ws);\r\n\tpublic void setOptionValue(PreferenceWidget[] ws) {\r\n\t\tfor (int i=0; i\u003cws.length; ++i) {\r\n\t\t\tws[i].setOptionValue();\r\n\t\t}\r\n\t}\r\n\r\n\t// Inherited method\r\n\tprotected IPreferenceStore doGetPreferenceStore() {\r\n\t\treturn Activator.getDefault().getPreferenceStore();\r\n\t}\r\n\r\n\t// Default implementation does a performOk()\r\n\t//public void performApply();\r\n\r\n\t// Default implementation does nothing and returns true\r\n\t//public boolean performCancel();\r\n\r\n\t/* (non-Javadoc)\r\n\t * @see org.eclipse.jface.dialogs.IDialogPage#performHelp()\r\n\t */\r\n\tpublic void performHelp() {}\r\n\r\n\t/**\r\n\t * Calls 'addWidget' on all the items in the list of PreferenceWidgets, in\r\n\t * order to add them to the given composite.\r\n\t * @param ws    The list of widgets to be added\r\n\t * @param composite The composite to add them to\r\n\t */\r\n\t//@ requires ws != null \u0026\u0026 composite != null;\r\n\t//@ requires \\nonnullelements(ws);\r\n\tpublic void addWidgets(PreferenceWidget[] ws, Composite composite) {\r\n\t\taddWidgets(ws,0,ws.length,composite);\r\n\t}\r\n\r\n\t/**\r\n\t * Calls 'addWidget' on some of the items in the list of PreferenceWidgets, in\r\n\t * order to add them to the given composite.\r\n\t * @param ws    The list of widgets to be added\r\n\t * @param offset The index in the array at which to begin\r\n\t * @param num The number of widgets to add\r\n\t * @param composite The composite to add them to\r\n\t */\r\n\t//@ requires ws != null \u0026\u0026 composite != null;\r\n\t//@ requires offset \u003e= 0 \u0026\u0026 offset \u003c ws.length;\r\n\t//@ requires num \u003e= 0 \u0026\u0026 offset + num \u003c ws.length;\r\n\t//@ requires \\nonnullelements(ws);\r\n\tpublic void addWidgets(PreferenceWidget[] ws, int offset, int num, Composite composite) {\r\n\t\tfor (int i=0; i\u003cnum; ++i) {\r\n\t\t\tws[offset+i].addWidget(composite);\r\n\t\t}\r\n\t}\r\n}\r\n",
        "name": "Preferences.java",
        "path": "smt/lip6.smtlib.plugin.SMTPlugin/src/org/smtlib/plugin/Preferences.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.plugin.SMTPlugin/src/org/smtlib/plugin/Preferences.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 400,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires ws != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 401,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires \\nonnullelements(ws);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 413,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires ws != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 414,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires \\nonnullelements(ws);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 443,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires ws != null \u0026\u0026 composite != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 444,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires \\nonnullelements(ws);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 457,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires ws != null \u0026\u0026 composite != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 458,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires offset \u003e= 0 \u0026\u0026 offset \u003c ws.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 459,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires num \u003e= 0 \u0026\u0026 offset + num \u003c ws.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 460,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires \\nonnullelements(ws);\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT plugin project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.plugin;\r\n\r\nimport java.io.IOException;\r\nimport java.io.PrintStream;\r\n\r\nimport org.eclipse.core.runtime.ILog;\r\nimport org.eclipse.core.runtime.Plugin;\r\nimport org.eclipse.core.runtime.Status;\r\nimport org.eclipse.swt.graphics.Color;\r\nimport org.eclipse.ui.console.ConsolePlugin;\r\nimport org.eclipse.ui.console.IConsole;\r\nimport org.eclipse.ui.console.IConsoleManager;\r\nimport org.eclipse.ui.console.MessageConsole;\r\nimport org.eclipse.ui.console.MessageConsoleStream;\r\nimport org.smtlib.IResponse;\r\n\r\n/** This class provides Log.IListener implementation that listens\r\n * to messages written through methods in the plug-in Log and sends them to the Eclipse console;\r\n * also listens to messages written through the application log.\r\n */\r\npublic class ConsoleLogger implements org.smtlib.plugin.Log.IListener, org.smtlib.Log.IListener {\r\n\r\n\t/** Creates a new ConsoleLogger utility object\r\n\t * \r\n\t * @param consoleName The name of the console to be logged to\r\n\t */\r\n\t//@ requires consoleName != null;\r\n\t//@ requires Activator.plugin != null;\r\n\t//@ modifies \\nothing;\r\n\t//@ ensures \\result.consoleName == consoleName;\r\n\tpublic ConsoleLogger(/*@NonNull*/ String consoleName) {\r\n\t\tthis.consoleName = consoleName;\r\n\t\tPlugin plugin = Activator.getDefault();\r\n\t\tthis.pluginLog = plugin.getLog();\r\n\t\tthis.pluginID = plugin.getBundle().getSymbolicName();\r\n\t}\r\n\r\n\t// This model variable models the content of the material\r\n\t// sent to the log.\r\n\t//@ model public String content;\r\n\r\n\t/** The name of the console that this plugin writes to. */\r\n\t//@ constraint \\not_modified(consoleName);\r\n\t//@ spec_public\r\n\t//@ non_null\r\n\t/*@NonNull*/\r\n\tfinal private String consoleName;\r\n\r\n\t/** The ILog of the plugin that this ConsoleLogger object connects to */\r\n\t//@ constraint \\not_modified(pluginLog);\r\n\t//@ invariant pluginLog != null;\r\n\t//@ spec_public\r\n\tfinal private ILog pluginLog;\r\n\r\n\t/** The id of the plugin using this log */\r\n\t//@ constraint \\not_modified(pluginID);\r\n\t//@ invariant pluginID != null;\r\n\t//@ spec_public\r\n\t/*@NonNull*/\r\n\tfinal private String pluginID;\r\n\r\n\t/** Cached value of the stream to use to write to the console */\r\n\t/*@Nullable*/\r\n\tprivate MessageConsoleStream stream = null;\r\n\t//@ private constraint \\old(stream) != null ==\u003e \\not_modified(stream);\r\n\r\n\t/** The associated PrintStream, lazily initialized */\r\n\t/*@Nullable*/\r\n\tprivate PrintStream printStream = null;\r\n\r\n\t/** Creates, if necessary, and returns an instance of\r\n\t *  the stream to use to write to the console\r\n\t * @return The stream value to use\r\n\t */\r\n\t//@ modifies stream;\r\n\t//@ ensures \\result != null;\r\n\t//@ ensures \\result == stream;\r\n\tpublic MessageConsoleStream getConsoleStream() {\r\n\t\tif (stream == null) {\r\n\t\t\t/*@Mutable*/ MessageConsole console = null;\r\n\t\t\tIConsoleManager consoleManager = ConsolePlugin.getDefault().getConsoleManager();\r\n\t\t\t/*@Mutable*/ IConsole[] existing = consoleManager.getConsoles();\r\n\t\t\tfor (int i=0; i\u003cexisting.length; ++i) {\r\n\t\t\t\tif (existing[i].getName().equals(consoleName)) {\r\n\t\t\t\t\tconsole = (/*@Mutable*/ MessageConsole)existing[i];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (console == null) {\r\n\t\t\t\tconsole = new MessageConsole(consoleName,null);\r\n\t\t\t\tconsoleManager.addConsoles(new IConsole[]{console});\r\n\t\t\t}\r\n\t\t\tstream = console.newMessageStream();\r\n\t\t}\r\n\t\treturn stream;\r\n\t}\r\n\r\n\t/** Color to use for error messages */\r\n\t// TODO - should get this color from the system preferences\r\n\tstatic final private Color errorColor = new Color(null,255,0,0);\r\n\tstatic final private Color diagColor = new Color(null,0,0,255);\r\n\r\n\t/**\r\n\t * Records an informational message\r\n\t * @param msg The message to log\r\n\t */\r\n\t//@ requires msg != null;\r\n\t//@ modifies content, stream;\r\n\t@Override\r\n\tpublic void log(String msg) {\r\n\t\tgetConsoleStream().print(msg);\r\n\t}\r\n\r\n\t/**\r\n\t * Records an informational message, adding a newline\r\n\t * @param msg The message to log\r\n\t */\r\n\t//@ requires msg != null;\r\n\t//@ modifies content, stream;\r\n\t@Override\r\n\tpublic void logln(String msg) {\r\n\t\tgetConsoleStream().println(msg);\r\n\t}\r\n\r\n\t/**\r\n\t * Records an error message, writing it to the console and the plug-in error log;\r\n\t * adds line separator\r\n\t * @param msg The message to log\r\n\t * @param e An associated exception (may be null)\r\n\t */\r\n\t// TODO - must this be called from the UI thread (because it sets the color)?\r\n\t//@ modifies content;\r\n\t@Override\r\n\tpublic void errorlog(/*@NonNull*/String msg, /*@Nullable*/ Throwable e) {\r\n\t\t// Always put errors in the plug-in Error log\r\n\t\tpluginLog.log(\r\n\t\t\t\tnew Status(Status.ERROR, \r\n\t\t\t\t\t\tpluginID,\r\n\t\t\t\t\t\tStatus.OK, msg, e));\r\n\t\tMessageConsoleStream cs = getConsoleStream();\r\n\t\tColor c = cs.getColor();\r\n\t\tcs.setColor(errorColor);\r\n\t\tcs.println(msg);\r\n\t\tif (e != null) e.printStackTrace(this.stream());\r\n\t\tcs.setColor(c);\r\n\t}\r\n\r\n\t/** Flushes the associated console stream */\r\n\tpublic void flush() throws IOException {\r\n\t\tgetConsoleStream().flush();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Creates a PrintStream that, when written to, writes to the Eclipse Console\r\n\t * of the current log object\r\n\t * \r\n\t * @return a PrintStream connected to the Eclipse Console\r\n\t */\r\n\t//@ modifies printStream, stream;\r\n\t//@ ensures \\result != null;\r\n\t//@ ensures \\result == printStream;\r\n\tpublic PrintStream stream() {\r\n\t\tif (printStream == null) printStream = new PrintStream(getConsoleStream());\r\n\t\treturn printStream;\r\n\t}\r\n\r\n\r\n\t/** This listens to and echos to the console regular log messages from the SMT application;\r\n\t *  no additional line separators added. */\r\n\t@Override\r\n\tpublic void logOut(String msg) {\r\n\t\tlog(msg);\r\n\t}\r\n\r\n\t/** This listens to and echos to the console regular log messages from the SMT application;\r\n\t *  adds a line separator */\r\n\t@Override\r\n\tpublic void logOut(IResponse response) {\r\n\t\tlogln(Activator.smtConfiguration.defaultPrinter.toString(response));\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void indent(String prompt) {\r\n\t}\r\n\r\n\r\n\t/** This listens to messages from the SMT application - errors are caught by the Problem listener,\r\n\t * so they are not logged here, unless verbose is requested.  Also SMT-LIB errors are not turned into\r\n\t * Error log entries either. */\r\n\t@Override\r\n\tpublic void logError(IResponse.IError response) {\r\n\t\tlogError(Activator.smtConfiguration.defaultPrinter.toString(response));\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void logError(String msg) {\r\n\t\tif (Activator.verbose) {\r\n\t\t\tMessageConsoleStream cs = getConsoleStream();\r\n//\t\t\tColor c = cs.getColor();\r\n//\t\t\tcs.setColor(errorColor);\r\n\t\t\tcs.println(msg);\r\n//\t\t\tcs.setColor(c); // FIXME - causes \"Invalid Thread access\" errors when logging errors from a computational thread\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/** This listens to and echos to the console diagnostic messages from the SMT application.\r\n\t *  Adds a line separator */\r\n\t@Override\r\n\tpublic void logDiag(String msg) {\r\n\t\tMessageConsoleStream cs = getConsoleStream();\r\n//\t\tColor c = cs.getColor();\r\n//\t\tcs.setColor(diagColor);\r\n\t\tcs.println(msg);\r\n//\t\tcs.setColor(c); // FIXME - causes \"Invalid Thread access\" errors when logging errors from a computational thread\r\n\t}\r\n}\r\n\r\n",
        "name": "ConsoleLogger.java",
        "path": "smt/lip6.smtlib.plugin.SMTPlugin/src/org/smtlib/plugin/ConsoleLogger.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.plugin.SMTPlugin/src/org/smtlib/plugin/ConsoleLogger.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires consoleName != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 32,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires Activator.plugin != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 34,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result.consoleName == consoleName;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 80,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 81,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result == stream;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 111,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires msg != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 122,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires msg != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 165,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 166,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result == printStream;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d91dafcc2b86177022e689293efbc6f143498167"
        },
        "content": "/*\r\n * This file is part of the SMT plugin project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.plugin;\r\nimport java.util.List;\r\n\r\nimport org.eclipse.core.resources.IFile;\r\nimport org.eclipse.jface.action.IAction;\r\nimport org.eclipse.jface.viewers.ISelection;\r\nimport org.eclipse.swt.widgets.Shell;\r\nimport org.eclipse.ui.IActionDelegate;\r\nimport org.eclipse.ui.IObjectActionDelegate;\r\nimport org.eclipse.ui.IWorkbenchPart;\r\n\r\n/** This class is an abstract base class for implementing popup menu item actions.\r\n * @author David R. Cok\r\n */\r\nabstract public class ContextAction implements IObjectActionDelegate {\r\n    /** A cached value of the most recent selection */\r\n\t/*@Nullable*/ protected ISelection selection;\r\n\r\n    /** A cached value of the shell that holds the most recent editor (actually IWorkbenchPart) */\r\n    /*@Nullable*/ protected Shell shell;\r\n\t\r\n\t/**\r\n\t * Constructor, with no initialization\r\n\t */\r\n\tpublic ContextAction() {\r\n\t\tsuper();\r\n\t}\r\n\r\n\t/**\r\n\t * @see IObjectActionDelegate#setActivePart(IAction, IWorkbenchPart)\r\n\t */\r\n\t//@ ensures this.shell != null;\r\n    @Override\r\n\tpublic void setActivePart(IAction action, IWorkbenchPart targetPart) {\r\n\t\tshell = targetPart.getSite().getShell();\r\n\t}\r\n\r\n\t/**\r\n\t * @see IActionDelegate#run(IAction)\r\n\t */\r\n    @Override\r\n\tabstract public void run(IAction action);\r\n\r\n\t/**\r\n\t * @see IActionDelegate#selectionChanged(IAction, ISelection)\r\n\t */\r\n\t//@ ensures this.selection != null;\r\n    @Override\r\n\tpublic void selectionChanged(IAction action, ISelection selection) {\r\n        this.selection = selection;\r\n\t}\r\n\r\n\t/** Runs the default solver on the selected files */\r\n\tstatic public class RunSolver extends ContextAction {\r\n\t\t/**\r\n\t\t * @see IActionDelegate#run(IAction)\r\n\t\t */\r\n\t    @Override\r\n\t\tpublic void run(IAction action) {\r\n    \t\ttry {\r\n    \t\t\tfinal List\u003cString\u003e solvers = Activator.utils.getSolvers(action.getId());\r\n    \t\t\tList\u003cIFile\u003e files = Activator.utils.getSelectedFiles(selection,null,shell);\r\n    \t\t\tActivator.utils.text = null; // TODO - setting 'text' through side-effects is a bad design\r\n        \t\tif (files.isEmpty()) files = Activator.utils.resources(selection,null,shell); // sets Activator.utils.text also\r\n        \t\tif (files.isEmpty()) {\r\n        \t\t\tActivator.utils.showMessageInUI(shell,\"SMT Run Solver\",\r\n        \t\t\t\t\t\"Failed to find a resource on which to run a solver (select one or more files or an editor)\");\r\n        \t\t\treturn;\r\n        \t\t}\r\n    \t\t\tActivator.utils.runJobs(solvers,files);\r\n    \t\t} catch (Exception e) {\r\n    \t\t\tActivator.utils.topLevelException(shell,\"ContextAction.RunSolver\",e);\r\n    \t\t}\r\n        }\r\n\t}\r\n\t\r\n\t\r\n\t/** Deletes SMT markers on selected resources */\r\n\tstatic public class DeleteMarkers extends ContextAction {\r\n\t\t/**\r\n\t\t * @see IActionDelegate#run(IAction)\r\n\t\t */\r\n\t    @Override\r\n\t\tpublic void run(IAction action) {\r\n            try {\r\n                Activator.utils.deleteMarkersInSelection(selection,null,shell);\r\n            } catch (Exception e) {\r\n                Activator.utils.topLevelException(shell,\"ContextAction.DeleteMarkers\",e);\r\n            }\r\n\t\t}\r\n\t}\r\n\r\n// Not included because the ViewLogic command uses selected text; it does not make sense\r\n// to run it on a file.\r\n//\t/** Shows the content of the SMT logic or theory whose name is selected */\r\n//\tstatic public class ViewLogic extends ContextAction {\r\n//\t\t/**\r\n//\t\t * @see IActionDelegate#run(IAction)\r\n//\t\t */\r\n//\t\tpublic void run(IAction action) {\r\n//        \tActivator.utils.viewLogic(shell,selection);\r\n//\t\t}\r\n//\t}\r\n\r\n}\r\n\r\n",
        "name": "ContextAction.java",
        "path": "smt/lip6.smtlib.plugin.SMTPlugin/src/org/smtlib/plugin/ContextAction.java",
        "url": "/github.com/lip6/ITSTools/-/blob/smt/lip6.smtlib.plugin.SMTPlugin/src/org/smtlib/plugin/ContextAction.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 36,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures this.shell != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 51,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures this.selection != null;\r"
        }
      ],
      "repository": {
        "name": "github.com/lip6/ITSTools",
        "url": "/github.com/lip6/ITSTools"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 164,
  "ElapsedMilliseconds": 1195,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
