{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/LASER-UMASS/Themis lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a70f12a6a8f34cdd8b170b4dc59a78674c9e8950"
        },
        "content": "/*\r\n *    This program is free software; you can redistribute it and/or modify\r\n *    it under the terms of the GNU General Public License as published by\r\n *    the Free Software Foundation; either version 2 of the License, or\r\n *    (at your option) any later version.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU General Public License\r\n *    along with this program; if not, write to the Free Software\r\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\r\n */\r\n\r\n/*\r\n *    Utils.java\r\n *    Copyright (C) 1999-2004 University of Waikato\r\n *\r\n */\r\n\r\npackage weka.core;\r\n\r\nimport java.lang.Math;\r\nimport java.lang.reflect.Array;\r\nimport java.util.Properties;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.util.Random;\r\n\r\n/**\r\n * Class implementing some simple utility methods.\r\n *\r\n * @author Eibe Frank \r\n * @author Yong Wang \r\n * @author Len Trigg \r\n * @author Julien Prados\r\n * @version $Revision: 1.44.2.3 $\r\n */\r\npublic final class Utils {\r\n\r\n  /** The natural logarithm of 2. */\r\n  public static double log2 = Math.log(2);\r\n\r\n  /** The small deviation allowed in double comparisons */\r\n  public static double SMALL = 1e-6;\r\n\r\n  \r\n  /**\r\n   * Reads properties that inherit from three locations. Properties\r\n   * are first defined in the system resource location (i.e. in the\r\n   * CLASSPATH).  These default properties must exist. Properties\r\n   * defined in the users home directory (optional) override default\r\n   * settings. Properties defined in the current directory (optional)\r\n   * override all these settings.\r\n   *\r\n   * @param resourceName the location of the resource that should be\r\n   * loaded.  e.g.: \"weka/core/Utils.props\". (The use of hardcoded\r\n   * forward slashes here is OK - see\r\n   * jdk1.1/docs/guide/misc/resources.html) This routine will also\r\n   * look for the file (in this case) \"Utils.props\" in the users home\r\n   * directory and the current directory.\r\n   * @return the Properties\r\n   * @exception Exception if no default properties are defined, or if\r\n   * an error occurs reading the properties files.  \r\n   */\r\n  public static Properties readProperties(String resourceName)\r\n    throws Exception {\r\n\r\n    Properties defaultProps = new Properties();\r\n    try {\r\n      // Apparently hardcoded slashes are OK here\r\n      // jdk1.1/docs/guide/misc/resources.html\r\n      defaultProps.load(ClassLoader.getSystemResourceAsStream(resourceName));\r\n    } catch (Exception ex) {\r\n/*      throw new Exception(\"Problem reading default properties: \"\r\n\t+ ex.getMessage()); */\r\n      System.err.println(\"Warning, unable to load properties file from \"\r\n\t\t\t +\"system resource (Utils.java)\");\r\n    }\r\n\r\n    // Hardcoded slash is OK here\r\n    // eg: see jdk1.1/docs/guide/misc/resources.html\r\n    int slInd = resourceName.lastIndexOf('/');\r\n    if (slInd != -1) {\r\n      resourceName = resourceName.substring(slInd + 1);\r\n    }\r\n\r\n    // Allow a properties file in the home directory to override\r\n    Properties userProps = new Properties(defaultProps);    \r\n    File propFile = new File(System.getProperties().getProperty(\"user.home\")\r\n                             + File.separatorChar\r\n                             + resourceName);\r\n    if (propFile.exists()) {\r\n      try {\r\n        userProps.load(new FileInputStream(propFile));\r\n      } catch (Exception ex) {\r\n        throw new Exception(\"Problem reading user properties: \" + propFile);\r\n      }\r\n    }\r\n\r\n    // Allow a properties file in the current directory to override\r\n    Properties localProps = new Properties(userProps);\r\n    propFile = new File(resourceName);\r\n    if (propFile.exists()) {\r\n      try {\r\n        localProps.load(new FileInputStream(propFile));\r\n      } catch (Exception ex) {\r\n        throw new Exception(\"Problem reading local properties: \" + propFile);\r\n      }\r\n    }\r\n    \r\n    return localProps;\r\n  }\r\n\r\n  /**\r\n   * Returns the correlation coefficient of two double vectors.\r\n   *\r\n   * @param y1 double vector 1\r\n   * @param y2 double vector 2\r\n   * @param n the length of two double vectors\r\n   * @return the correlation coefficient\r\n   */\r\n  public static final double correlation(double y1[],double y2[],int n) {\r\n\r\n    int i;\r\n    double av1 = 0.0, av2 = 0.0, y11 = 0.0, y22 = 0.0, y12 = 0.0, c;\r\n    \r\n    if (n \u003c= 1) {\r\n      return 1.0;\r\n    }\r\n    for (i = 0; i \u003c n; i++) {\r\n      av1 += y1[i];\r\n      av2 += y2[i];\r\n    }\r\n    av1 /= (double) n;\r\n    av2 /= (double) n;\r\n    for (i = 0; i \u003c n; i++) {\r\n      y11 += (y1[i] - av1) * (y1[i] - av1);\r\n      y22 += (y2[i] - av2) * (y2[i] - av2);\r\n      y12 += (y1[i] - av1) * (y2[i] - av2);\r\n    }\r\n    if (y11 * y22 == 0.0) {\r\n      c=1.0;\r\n    } else {\r\n      c = y12 / Math.sqrt(Math.abs(y11 * y22));\r\n    }\r\n    \r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * Removes all occurrences of a string from another string.\r\n   *\r\n   * @param inString the string to remove substrings from.\r\n   * @param substring the substring to remove.\r\n   * @return the input string with occurrences of substring removed.\r\n   */\r\n  public static String removeSubstring(String inString, String substring) {\r\n\r\n    StringBuffer result = new StringBuffer();\r\n    int oldLoc = 0, loc = 0;\r\n    while ((loc = inString.indexOf(substring, oldLoc))!= -1) {\r\n      result.append(inString.substring(oldLoc, loc));\r\n      oldLoc = loc + substring.length();\r\n    }\r\n    result.append(inString.substring(oldLoc));\r\n    return result.toString();\r\n  }\r\n\r\n  /**\r\n   * Replaces with a new string, all occurrences of a string from \r\n   * another string.\r\n   *\r\n   * @param inString the string to replace substrings in.\r\n   * @param substring the substring to replace.\r\n   * @param replaceString the replacement substring\r\n   * @return the input string with occurrences of substring replaced.\r\n   */\r\n  public static String replaceSubstring(String inString, String subString,\r\n\t\t\t\t\tString replaceString) {\r\n\r\n    StringBuffer result = new StringBuffer();\r\n    int oldLoc = 0, loc = 0;\r\n    while ((loc = inString.indexOf(subString, oldLoc))!= -1) {\r\n      result.append(inString.substring(oldLoc, loc));\r\n      result.append(replaceString);\r\n      oldLoc = loc + subString.length();\r\n    }\r\n    result.append(inString.substring(oldLoc));\r\n    return result.toString();\r\n  }\r\n\r\n\r\n  /**\r\n   * Pads a string to a specified length, inserting spaces on the left\r\n   * as required. If the string is too long, characters are removed (from\r\n   * the right).\r\n   *\r\n   * @param inString the input string\r\n   * @param length the desired length of the output string\r\n   * @return the output string\r\n   */\r\n  public static String padLeft(String inString, int length) {\r\n\r\n    return fixStringLength(inString, length, false);\r\n  }\r\n  \r\n  /**\r\n   * Pads a string to a specified length, inserting spaces on the right\r\n   * as required. If the string is too long, characters are removed (from\r\n   * the right).\r\n   *\r\n   * @param inString the input string\r\n   * @param length the desired length of the output string\r\n   * @return the output string\r\n   */\r\n  public static String padRight(String inString, int length) {\r\n\r\n    return fixStringLength(inString, length, true);\r\n  }\r\n  \r\n  /**\r\n   * Pads a string to a specified length, inserting spaces as\r\n   * required. If the string is too long, characters are removed (from\r\n   * the right).\r\n   *\r\n   * @param inString the input string\r\n   * @param length the desired length of the output string\r\n   * @param right true if inserted spaces should be added to the right\r\n   * @return the output string\r\n   */\r\n  private static /*@pure@*/ String fixStringLength(String inString, int length,\r\n\t\t\t\t\tboolean right) {\r\n\r\n    if (inString.length() \u003c length) {\r\n      while (inString.length() \u003c length) {\r\n\tinString = (right ? inString.concat(\" \") : \" \".concat(inString));\r\n      }\r\n    } else if (inString.length() \u003e length) {\r\n      inString = inString.substring(0, length);\r\n    }\r\n    return inString;\r\n  }\r\n \r\n  /**\r\n   * Rounds a double and converts it into String.\r\n   *\r\n   * @param value the double value\r\n   * @param afterDecimalPoint the (maximum) number of digits permitted\r\n   * after the decimal point\r\n   * @return the double as a formatted string\r\n   */\r\n  public static /*@pure@*/ String doubleToString(double value, int afterDecimalPoint) {\r\n    \r\n    StringBuffer stringBuffer;\r\n    double temp;\r\n    int i,dotPosition;\r\n    long precisionValue;\r\n    \r\n    temp = value * Math.pow(10.0, afterDecimalPoint);\r\n    if (Math.abs(temp) \u003c Long.MAX_VALUE) {\r\n      precisionValue = \t(temp \u003e 0) ? (long)(temp + 0.5) \r\n                                   : -(long)(Math.abs(temp) + 0.5);\r\n      if (precisionValue == 0) {\r\n\tstringBuffer = new StringBuffer(String.valueOf(0));\r\n      } else {\r\n\tstringBuffer = new StringBuffer(String.valueOf(precisionValue));\r\n      }\r\n      if (afterDecimalPoint == 0) {\r\n\treturn stringBuffer.toString();\r\n      }\r\n      dotPosition = stringBuffer.length() - afterDecimalPoint;\r\n      while (((precisionValue \u003c 0) \u0026\u0026 (dotPosition \u003c 1)) ||\r\n\t     (dotPosition \u003c 0)) {\r\n\tif (precisionValue \u003c 0) {\r\n\t  stringBuffer.insert(1, '0');\r\n\t} else {\r\n\t  stringBuffer.insert(0, '0');\r\n\t}\r\n\tdotPosition++;\r\n      }\r\n      stringBuffer.insert(dotPosition, '.');\r\n      if ((precisionValue \u003c 0) \u0026\u0026 (stringBuffer.charAt(1) == '.')) {\r\n\tstringBuffer.insert(1, '0');\r\n      } else if (stringBuffer.charAt(0) == '.') {\r\n\tstringBuffer.insert(0, '0');\r\n      }\r\n      int currentPos = stringBuffer.length() - 1;\r\n      while ((currentPos \u003e dotPosition) \u0026\u0026\r\n\t     (stringBuffer.charAt(currentPos) == '0')) {\r\n\tstringBuffer.setCharAt(currentPos--, ' ');\r\n      }\r\n      if (stringBuffer.charAt(currentPos) == '.') {\r\n\tstringBuffer.setCharAt(currentPos, ' ');\r\n      }\r\n      \r\n      return stringBuffer.toString().trim();\r\n    }\r\n    return new String(\"\" + value);\r\n  }\r\n\r\n  /**\r\n   * Rounds a double and converts it into a formatted decimal-justified String.\r\n   * Trailing 0's are replaced with spaces.\r\n   *\r\n   * @param value the double value\r\n   * @param width the width of the string\r\n   * @param afterDecimalPoint the number of digits after the decimal point\r\n   * @return the double as a formatted string\r\n   */\r\n  public static /*@pure@*/ String doubleToString(double value, int width,\r\n\t\t\t\t      int afterDecimalPoint) {\r\n    \r\n    String tempString = doubleToString(value, afterDecimalPoint);\r\n    char[] result;\r\n    int dotPosition;\r\n\r\n    if ((afterDecimalPoint \u003e= width) \r\n        || (tempString.indexOf('E') != -1)) { // Protects sci notation\r\n      return tempString;\r\n    }\r\n\r\n    // Initialize result\r\n    result = new char[width];\r\n    for (int i = 0; i \u003c result.length; i++) {\r\n      result[i] = ' ';\r\n    }\r\n\r\n    if (afterDecimalPoint \u003e 0) {\r\n      // Get position of decimal point and insert decimal point\r\n      dotPosition = tempString.indexOf('.');\r\n      if (dotPosition == -1) {\r\n\tdotPosition = tempString.length();\r\n      } else {\r\n\tresult[width - afterDecimalPoint - 1] = '.';\r\n      }\r\n    } else {\r\n      dotPosition = tempString.length();\r\n    }\r\n    \r\n\r\n    int offset = width - afterDecimalPoint - dotPosition;\r\n    if (afterDecimalPoint \u003e 0) {\r\n      offset--;\r\n    }\r\n\r\n    // Not enough room to decimal align within the supplied width\r\n    if (offset \u003c 0) {\r\n      return tempString;\r\n    }\r\n\r\n    // Copy characters before decimal point\r\n    for (int i = 0; i \u003c dotPosition; i++) {\r\n      result[offset + i] = tempString.charAt(i);\r\n    }\r\n\r\n    // Copy characters after decimal point\r\n    for (int i = dotPosition + 1; i \u003c tempString.length(); i++) {\r\n      result[offset + i] = tempString.charAt(i);\r\n    }\r\n\r\n    return new String(result);\r\n  }\r\n\r\n  /**\r\n   * Returns the basic class of an array class (handles multi-dimensional\r\n   * arrays).\r\n   * @param o        the array to inspect\r\n   * @return         the class of the innermost elements\r\n   */\r\n  public static Class getArrayClass(Class c) {\r\n     if (c.getComponentType().isArray())\r\n        return getArrayClass(c.getComponentType());\r\n     else\r\n        return c.getComponentType();\r\n  }\r\n\r\n  /**\r\n   * Returns the dimensions of the given array. Even though the\r\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\r\n   * int[3] or double[2][4].\r\n   *\r\n   * @param array       the array to determine the dimensions for\r\n   * @return            the dimensions of the array\r\n   */\r\n  public static int getArrayDimensions(Class array) {\r\n    if (array.getComponentType().isArray())\r\n      return 1 + getArrayDimensions(array.getComponentType());\r\n    else\r\n      return 1;\r\n  }\r\n\r\n  /**\r\n   * Returns the dimensions of the given array. Even though the\r\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\r\n   * int[3] or double[2][4].\r\n   *\r\n   * @param array       the array to determine the dimensions for\r\n   * @return            the dimensions of the array\r\n   */\r\n  public static int getArrayDimensions(Object array) {\r\n    return getArrayDimensions(array.getClass());\r\n  }\r\n\r\n  /**\r\n   * Returns the given Array in a string representation. Even though the\r\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\r\n   * int[3] or double[2][4].\r\n   * \r\n   * @param array       the array to return in a string representation\r\n   * @return            the array as string\r\n   */\r\n  public static String arrayToString(Object array) {\r\n    String        result;\r\n    int           dimensions;\r\n    int           i;       \r\n\r\n    result     = \"\";\r\n    dimensions = getArrayDimensions(array);\r\n    \r\n    if (dimensions == 0) {\r\n      result = \"null\";\r\n    }\r\n    else if (dimensions == 1) {\r\n      for (i = 0; i \u003c Array.getLength(array); i++) {\r\n        if (i \u003e 0)\r\n          result += \",\";\r\n        if (Array.get(array, i) == null)\r\n          result += \"null\";\r\n        else\r\n          result += Array.get(array, i).toString();\r\n      }\r\n    }\r\n    else {\r\n      for (i = 0; i \u003c Array.getLength(array); i++) {\r\n        if (i \u003e 0)\r\n          result += \",\";\r\n        result += \"[\" + arrayToString(Array.get(array, i)) + \"]\";\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Tests if a is equal to b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n   */\r\n  public static /*@pure@*/ boolean eq(double a, double b){\r\n    \r\n    return (a - b \u003c SMALL) \u0026\u0026 (b - a \u003c SMALL); \r\n  }\r\n\r\n  /**\r\n   * Checks if the given array contains any non-empty options.\r\n   *\r\n   * @param strings an array of strings\r\n   * @exception Exception if there are any non-empty options\r\n   */\r\n  public static void checkForRemainingOptions(String [] options) \r\n    throws Exception {\r\n    \r\n    int illegalOptionsFound = 0;\r\n    StringBuffer text = new StringBuffer();\r\n\r\n    if (options == null) {\r\n      return;\r\n    }\r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if (options[i].length() \u003e 0) {\r\n\tillegalOptionsFound++;\r\n\ttext.append(options[i] + ' ');\r\n      }\r\n    }\r\n    if (illegalOptionsFound \u003e 0) {\r\n      throw new Exception(\"Illegal options: \" + text);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Checks if the given array contains the flag \"-Char\". Stops\r\n   * searching at the first marker \"--\". If the flag is found,\r\n   * it is replaced with the empty string.\r\n   *\r\n   * @param flag the character indicating the flag.\r\n   * @param strings the array of strings containing all the options.\r\n   * @return true if the flag was found\r\n   * @exception Exception if an illegal option was found\r\n   */\r\n  public static boolean getFlag(char flag, String [] options) \r\n    throws Exception {\r\n       return getFlag(\"\" + flag, options);\r\n  }\r\n  \r\n  /**\r\n   * Checks if the given array contains the flag \"-String\". Stops\r\n   * searching at the first marker \"--\". If the flag is found,\r\n   * it is replaced with the empty string.\r\n   *\r\n   * @param flag the String indicating the flag.\r\n   * @param strings the array of strings containing all the options.\r\n   * @return true if the flag was found\r\n   * @exception Exception if an illegal option was found\r\n   */\r\n  public static boolean getFlag(String flag, String [] options) \r\n    throws Exception {\r\n\r\n    if (options == null) {\r\n      return false;\r\n    }\r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if ((options[i].length() \u003e 1) \u0026\u0026 (options[i].charAt(0) == '-')) {\r\n\ttry {\r\n\t  Double dummy = Double.valueOf(options[i]);\r\n\t} catch (NumberFormatException e) {\r\n\t  if (options[i].equals(\"-\" + flag)) {\r\n\t    options[i] = \"\";\r\n\t    return true;\r\n\t  }\r\n\t  if (options[i].charAt(1) == '-') {\r\n\t    return false;\r\n\t  }\r\n\t}\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gets an option indicated by a flag \"-Char\" from the given array\r\n   * of strings. Stops searching at the first marker \"--\". Replaces \r\n   * flag and option with empty strings.\r\n   *\r\n   * @param flag the character indicating the option.\r\n   * @param options the array of strings containing all the options.\r\n   * @return the indicated option or an empty string\r\n   * @exception Exception if the option indicated by the flag can't be found\r\n   */\r\n  public static /*@non_null@*/ String getOption(char flag, String [] options) \r\n    throws Exception {\r\n     return getOption(\"\" + flag, options);\r\n  }\r\n\r\n  /**\r\n   * Gets an option indicated by a flag \"-String\" from the given array\r\n   * of strings. Stops searching at the first marker \"--\". Replaces \r\n   * flag and option with empty strings.\r\n   *\r\n   * @param flag the String indicating the option.\r\n   * @param options the array of strings containing all the options.\r\n   * @return the indicated option or an empty string\r\n   * @exception Exception if the option indicated by the flag can't be found\r\n   */\r\n  public static /*@non_null@*/ String getOption(String flag, String [] options) \r\n    throws Exception {\r\n\r\n    String newString;\r\n\r\n    if (options == null)\r\n      return \"\";\r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if ((options[i].length() \u003e 0) \u0026\u0026 (options[i].charAt(0) == '-')) {\r\n\t\r\n\t// Check if it is a negative number\r\n\ttry {\r\n\t  Double dummy = Double.valueOf(options[i]);\r\n\t} catch (NumberFormatException e) {\r\n\t  if (options[i].equals(\"-\" + flag)) {\r\n\t    if (i + 1 == options.length) {\r\n\t      throw new Exception(\"No value given for -\" + flag + \" option.\");\r\n\t    }\r\n\t    options[i] = \"\";\r\n\t    newString = new String(options[i + 1]);\r\n\t    options[i + 1] = \"\";\r\n\t    return newString;\r\n\t  }\r\n\t  if (options[i].charAt(1) == '-') {\r\n\t    return \"\";\r\n\t  }\r\n\t}\r\n      }\r\n    }\r\n    return \"\";\r\n  }\r\n\r\n  /**\r\n   * Quotes a string if it contains special characters.\r\n   * \r\n   * The following rules are applied:\r\n   *\r\n   * A character is backquoted version of it is one \r\n   * of \u003ctt\u003e\" ' % \\ \\n \\r \\t\u003c/tt\u003e.\r\n   *\r\n   * A string is enclosed within single quotes if a character has been\r\n   * backquoted using the previous rule above or contains \r\n   * \u003ctt\u003e{ }\u003c/tt\u003e or is exactly equal to the strings \r\n   * \u003ctt\u003e, ? space or \"\"\u003c/tt\u003e (empty string).\r\n   *\r\n   * A quoted question mark distinguishes it from the missing value which\r\n   * is represented as an unquoted question mark in arff files.\r\n   *\r\n   * @param string the string to be quoted\r\n   * @return the string (possibly quoted)\r\n   */\r\n  public static /*@pure@*/ String quote(String string) {\r\n      boolean quote = false;\r\n\r\n      // backquote the following characters \r\n      if ((string.indexOf('\\n') != -1) || (string.indexOf('\\r') != -1) || \r\n\t  (string.indexOf('\\'') != -1) || (string.indexOf('\"') != -1) || \r\n\t  (string.indexOf('\\\\') != -1) || \r\n\t  (string.indexOf('\\t') != -1) || (string.indexOf('%') != -1)) {\r\n\t  string = backQuoteChars(string);\r\n\t  quote = true;\r\n      }\r\n\r\n      // Enclose the string in 's if the string contains a recently added\r\n      // backquote or contains one of the following characters.\r\n      if((quote == true) || \r\n\t (string.indexOf('{') != -1) || (string.indexOf('}') != -1) ||\r\n\t (string.indexOf(',') != -1) || (string.equals(\"?\")) ||\r\n\t (string.indexOf(' ') != -1) || (string.equals(\"\"))) {\r\n\t  string = (\"'\".concat(string)).concat(\"'\");\r\n      }\r\n\r\n      return string;\r\n  }\r\n\r\n  /**\r\n   * Converts carriage returns and new lines in a string into \\r and \\n.\r\n   * Backquotes the following characters: ` \" \\ \\t and %\r\n   * @param string the string\r\n   * @return the converted string\r\n   */\r\n  public static /*@pure@*/ String backQuoteChars(String string) {\r\n\r\n    int index;\r\n    StringBuffer newStringBuffer;\r\n\r\n    // replace each of the following characters with the backquoted version\r\n    char   charsFind[] =    {'\\\\',   '\\'',  '\\t',  '\"',    '%'};\r\n    String charsReplace[] = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\\\\"\", \"\\\\%\"};\r\n    for(int i = 0; i \u003c charsFind.length; i++) {\r\n\tif (string.indexOf(charsFind[i]) != -1 ) {\r\n\t    newStringBuffer = new StringBuffer();\r\n\t    while ((index = string.indexOf(charsFind[i])) != -1) {\r\n\t\tif (index \u003e 0) {\r\n\t\t    newStringBuffer.append(string.substring(0, index));\r\n\t\t}\r\n\t\tnewStringBuffer.append(charsReplace[i]);\r\n\t\tif ((index + 1) \u003c string.length()) {\r\n\t\t    string = string.substring(index + 1);\r\n\t\t} else {\r\n\t\t    string = \"\";\r\n\t\t}\r\n\t    }\r\n\t    newStringBuffer.append(string);\r\n\t    string = newStringBuffer.toString();\r\n\t}\r\n    }\r\n\r\n    return Utils.convertNewLines(string);\r\n  }\r\n\r\n  /**\r\n   * Converts carriage returns and new lines in a string into \\r and \\n.\r\n   * @param string the string\r\n   * @return the converted string\r\n   */\r\n  public static /*@pure@*/ String convertNewLines(String string) {\r\n    \r\n    int index;\r\n\r\n    // Replace with \\n\r\n    StringBuffer newStringBuffer = new StringBuffer();\r\n    while ((index = string.indexOf('\\n')) != -1) {\r\n      if (index \u003e 0) {\r\n\tnewStringBuffer.append(string.substring(0, index));\r\n      }\r\n      newStringBuffer.append('\\\\');\r\n      newStringBuffer.append('n');\r\n      if ((index + 1) \u003c string.length()) {\r\n\tstring = string.substring(index + 1);\r\n      } else {\r\n\tstring = \"\";\r\n      }\r\n    }\r\n    newStringBuffer.append(string);\r\n    string = newStringBuffer.toString();\r\n\r\n    // Replace with \\r\r\n    newStringBuffer = new StringBuffer();\r\n    while ((index = string.indexOf('\\r')) != -1) {\r\n      if (index \u003e 0) {\r\n\tnewStringBuffer.append(string.substring(0, index));\r\n      }\r\n      newStringBuffer.append('\\\\');\r\n      newStringBuffer.append('r');\r\n      if ((index + 1) \u003c string.length()){\r\n\tstring = string.substring(index + 1);\r\n      } else {\r\n\tstring = \"\";\r\n      }\r\n    }\r\n    newStringBuffer.append(string);\r\n    return newStringBuffer.toString();\r\n  }\r\n    \r\n\r\n  /**\r\n   * Returns the secondary set of options (if any) contained in\r\n   * the supplied options array. The secondary set is defined to\r\n   * be any options after the first \"--\". These options are removed from\r\n   * the original options array.\r\n   *\r\n   * @param options the input array of options\r\n   * @return the array of secondary options\r\n   */\r\n  public static String [] partitionOptions(String [] options) {\r\n\r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if (options[i].equals(\"--\")) {\r\n\toptions[i++] = \"\";\r\n\tString [] result = new String [options.length - i];\r\n\tfor (int j = i; j \u003c options.length; j++) {\r\n\t  result[j - i] = options[j];\r\n\t  options[j] = \"\";\r\n\t}\r\n\treturn result;\r\n      }\r\n    }\r\n    return new String [0];\r\n  }\r\n    \r\n  /**\r\n   * The inverse operation of backQuoteChars().\r\n   * Converts back-quoted carriage returns and new lines in a string \r\n   * to the corresponding character ('\\r' and '\\n').\r\n   * Also \"un\"-back-quotes the following characters: ` \" \\ \\t and %\r\n   * @param string the string\r\n   * @return the converted string\r\n   */\r\n  public static String unbackQuoteChars(String string) {\r\n\r\n    int index;\r\n    StringBuffer newStringBuffer;\r\n    \r\n    // replace each of the following characters with the backquoted version\r\n    String charsFind[]    = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\\\\"\", \"\\\\%\"};\r\n    char   charsReplace[] = {'\\\\',   '\\'',  '\\t',  '\"',    '%'};\r\n    \r\n    for(int i = 0; i \u003c charsFind.length; i++) {\r\n      if (string.indexOf(charsFind[i]) != -1 ) {\r\n\tnewStringBuffer = new StringBuffer();\r\n\twhile ((index = string.indexOf(charsFind[i])) != -1) {\r\n\t  if (index \u003e 0) {\r\n\t    newStringBuffer.append(string.substring(0, index));\r\n\t  }\r\n\t  newStringBuffer.append(charsReplace[i]);\r\n\t  if ((index + charsFind[i].length()) \u003c string.length()) {\r\n\t    string = string.substring(index + charsFind[i].length());\r\n\t  } else {\r\n\t    string = \"\";\r\n\t  }\r\n\t}\r\n\tnewStringBuffer.append(string);\r\n\tstring = newStringBuffer.toString();\r\n      }\r\n    }\r\n    return Utils.convertNewLines(string);\r\n  }    \r\n  \r\n  /**\r\n   * Split up a string containing options into an array of strings,\r\n   * one for each option.\r\n   *\r\n   * @param optionString the string containing the options\r\n   * @return the array of options\r\n   */\r\n  public static String [] splitOptions(String quotedOptionString) throws Exception{\r\n\r\n    FastVector optionsVec = new FastVector();\r\n    String str = new String(quotedOptionString);\r\n    int i;\r\n    \r\n    while (true){\r\n\r\n      //trimLeft \r\n      i = 0;\r\n      while ((i \u003c str.length()) \u0026\u0026 (Character.isWhitespace(str.charAt(i)))) i++;\r\n      str = str.substring(i);\r\n      \r\n      //stop when str is empty\r\n      if (str.length() == 0) break;\r\n      \r\n      //if str start with a double quote\r\n      if (str.charAt(0) == '\"'){\r\n\t\r\n\t//find the first not anti-slached double quote\r\n\ti = 1;\r\n\twhile(i \u003c str.length()){\r\n\t  if (str.charAt(i) == str.charAt(0)) break;\r\n\t  if (str.charAt(i) == '\\\\'){\r\n\t    i += 1;\r\n\t    if (i \u003e= str.length()) \r\n\t      throw new Exception(\"String should not finish with \\\\\");\r\n\t    if (str.charAt(i) != '\\\\' \u0026\u0026  str.charAt(i) != '\"') \r\n\t      throw new Exception(\"Unknow character \\\\\" + str.charAt(i));\r\n\t  }\r\n\t  i += 1;\r\n\t}\r\n\tif (i \u003e= str.length()) throw new Exception(\"Quote parse error.\");\r\n\t\r\n\t//add the founded string to the option vector (without quotes)\r\n\tString optStr = str.substring(1,i);\r\n\toptStr = unbackQuoteChars(optStr);\r\n\toptionsVec.addElement(optStr);\r\n\tstr = str.substring(i+1);\r\n      } else {\r\n\t//find first whiteSpace\r\n\ti=0;\r\n\twhile((i \u003c str.length()) \u0026\u0026 (!Character.isWhitespace(str.charAt(i)))) i++;\r\n\t\r\n\t//add the founded string to the option vector\r\n\tString optStr = str.substring(0,i);\r\n\toptionsVec.addElement(optStr);\r\n\tstr = str.substring(i);\r\n      }\r\n    }\r\n    \r\n    //convert optionsVec to an array of String\r\n    String [] options = new String[optionsVec.size()];\r\n    for (i = 0; i \u003c optionsVec.size(); i++) {\r\n      options[i] = (String)optionsVec.elementAt(i);\r\n    }\r\n    return options;\r\n  }    \r\n\r\n  /**\r\n   * Joins all the options in an option array into a single string,\r\n   * as might be used on the command line.\r\n   *\r\n   * @param optionArray the array of options\r\n   * @return the string containing all options.\r\n   */\r\n  public static String joinOptions(String [] optionArray) {\r\n\r\n    String optionString = \"\";\r\n    for (int i = 0; i \u003c optionArray.length; i++) {\r\n      if (optionArray[i].equals(\"\")) {\r\n\tcontinue;\r\n      }\r\n      if (optionArray[i].indexOf(' ') != -1) {\r\n\toptionString += '\"' + optionArray[i] + '\"';\r\n      } else {\r\n\toptionString += optionArray[i];\r\n      }\r\n      optionString += \" \";\r\n    }\r\n    return optionString.trim();\r\n  }\r\n  \r\n  /**\r\n   * Creates a new instance of an object given it's class name and\r\n   * (optional) arguments to pass to it's setOptions method. If the\r\n   * object implements OptionHandler and the options parameter is\r\n   * non-null, the object will have it's options set. Example use:\u003cp\u003e\r\n   *\r\n   * \u003ccode\u003e \u003cpre\u003e\r\n   * String classifierName = Utils.getOption('W', options);\r\n   * Classifier c = (Classifier)Utils.forName(Classifier.class,\r\n   *                                          classifierName,\r\n   *                                          options);\r\n   * setClassifier(c);\r\n   * \u003c/pre\u003e\u003c/code\u003e\r\n   *\r\n   * @param classType the class that the instantiated object should\r\n   * be assignable to -- an exception is thrown if this is not the case\r\n   * @param className the fully qualified class name of the object\r\n   * @param options an array of options suitable for passing to setOptions. May\r\n   * be null. Any options accepted by the object will be removed from the\r\n   * array.\r\n   * @return the newly created object, ready for use.\r\n   * @exception Exception if the class name is invalid, or if the\r\n   * class is not assignable to the desired class type, or the options\r\n   * supplied are not acceptable to the object\r\n   */\r\n  public static Object forName(Class classType,\r\n\t\t\t       String className,\r\n\t\t\t       String [] options) throws Exception {\r\n\r\n    Class c = null;\r\n    try {\r\n      c = Class.forName(className);\r\n    } catch (Exception ex) {\r\n      throw new Exception(\"Can't find class called: \" + className);\r\n    }\r\n    if (!classType.isAssignableFrom(c)) {\r\n      throw new Exception(classType.getName() + \" is not assignable from \"\r\n\t\t\t  + className);\r\n    }\r\n    Object o = c.newInstance();\r\n    if ((o instanceof OptionHandler)\r\n\t\u0026\u0026 (options != null)) {\r\n      ((OptionHandler)o).setOptions(options);\r\n      Utils.checkForRemainingOptions(options);\r\n    }\r\n    return o;\r\n  }\r\n\r\n  /**\r\n   * Computes entropy for an array of integers.\r\n   *\r\n   * @param counts array of counts\r\n   * @return - a log2 a - b log2 b - c log2 c + (a+b+c) log2 (a+b+c)\r\n   * when given array [a b c]\r\n   */\r\n  public static /*@pure@*/ double info(int counts[]) {\r\n    \r\n    int total = 0; int c;\r\n    double x = 0;\r\n    for (int j = 0; j \u003c counts.length; j++) {\r\n      x -= xlogx(counts[j]);\r\n      total += counts[j];\r\n    }\r\n    return x + xlogx(total);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is smaller or equal to b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n   */\r\n  public static /*@pure@*/ boolean smOrEq(double a,double b) {\r\n    \r\n    return (a-b \u003c SMALL);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is greater or equal to b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n   */\r\n  public static /*@pure@*/ boolean grOrEq(double a,double b) {\r\n    \r\n    return (b-a \u003c SMALL);\r\n  }\r\n  \r\n  /**\r\n   * Tests if a is smaller than b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n   */\r\n  public static /*@pure@*/ boolean sm(double a,double b) {\r\n    \r\n    return (b-a \u003e SMALL);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is greater than b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double \r\n   */\r\n  public static /*@pure@*/ boolean gr(double a,double b) {\r\n    \r\n    return (a-b \u003e SMALL);\r\n  }\r\n\r\n  /**\r\n   * Returns the kth-smallest value in the array.\r\n   *\r\n   * @param array the array of integers\r\n   * @param k the value of k\r\n   * @return the kth-smallest value\r\n   */\r\n  public static double kthSmallestValue(int[] array, int k) {\r\n\r\n    int [] index = new int[array.length];\r\n    \r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n    }\r\n\r\n    return array[index[select(array, index, 0, array.length - 1, k)]];\r\n  }\r\n\r\n  /**\r\n   * Returns the kth-smallest value in the array\r\n   *\r\n   * @param array the array of double\r\n   * @param k the value of k\r\n   * @return the kth-smallest value\r\n   */\r\n  public static double kthSmallestValue(double[] array, int k) {\r\n\r\n    int [] index = new int[array.length];\r\n    \r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n    }\r\n\r\n    return array[index[select(array, index, 0, array.length - 1, k)]];\r\n  }\r\n\r\n  /**\r\n   * Returns the logarithm of a for base 2.\r\n   *\r\n   * @param a a double\r\n   */\r\n  public static /*@pure@*/ double log2(double a) {\r\n    \r\n    return Math.log(a) / log2;\r\n  }\r\n\r\n  /**\r\n   * Returns index of maximum element in a given\r\n   * array of doubles. First maximum is returned.\r\n   *\r\n   * @param doubles the array of doubles\r\n   * @return the index of the maximum element\r\n   */\r\n  public static /*@pure@*/ int maxIndex(double [] doubles) {\r\n\r\n    double maximum = 0;\r\n    int maxIndex = 0;\r\n\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      if ((i == 0) || (doubles[i] \u003e maximum)) {\r\n\tmaxIndex = i;\r\n\tmaximum = doubles[i];\r\n      }\r\n    }\r\n\r\n    return maxIndex;\r\n  }\r\n\r\n  /**\r\n   * Returns index of maximum element in a given\r\n   * array of integers. First maximum is returned.\r\n   *\r\n   * @param ints the array of integers\r\n   * @return the index of the maximum element\r\n   */\r\n  public static /*@pure@*/ int maxIndex(int [] ints) {\r\n\r\n    int maximum = 0;\r\n    int maxIndex = 0;\r\n\r\n    for (int i = 0; i \u003c ints.length; i++) {\r\n      if ((i == 0) || (ints[i] \u003e maximum)) {\r\n\tmaxIndex = i;\r\n\tmaximum = ints[i];\r\n      }\r\n    }\r\n\r\n    return maxIndex;\r\n  }\r\n\r\n  /**\r\n   * Computes the mean for an array of doubles.\r\n   *\r\n   * @param vector the array\r\n   * @return the mean\r\n   */\r\n  public static /*@pure@*/ double mean(double[] vector) {\r\n  \r\n    double sum = 0;\r\n\r\n    if (vector.length == 0) {\r\n      return 0;\r\n    }\r\n    for (int i = 0; i \u003c vector.length; i++) {\r\n      sum += vector[i];\r\n    }\r\n    return sum / (double) vector.length;\r\n  }\r\n\r\n  /**\r\n   * Returns index of minimum element in a given\r\n   * array of integers. First minimum is returned.\r\n   *\r\n   * @param ints the array of integers\r\n   * @return the index of the minimum element\r\n   */\r\n  public static /*@pure@*/ int minIndex(int [] ints) {\r\n\r\n    int minimum = 0;\r\n    int minIndex = 0;\r\n\r\n    for (int i = 0; i \u003c ints.length; i++) {\r\n      if ((i == 0) || (ints[i] \u003c minimum)) {\r\n\tminIndex = i;\r\n\tminimum = ints[i];\r\n      }\r\n    }\r\n\r\n    return minIndex;\r\n  }\r\n\r\n  /**\r\n   * Returns index of minimum element in a given\r\n   * array of doubles. First minimum is returned.\r\n   *\r\n   * @param doubles the array of doubles\r\n   * @return the index of the minimum element\r\n   */\r\n  public static /*@pure@*/ int minIndex(double [] doubles) {\r\n\r\n    double minimum = 0;\r\n    int minIndex = 0;\r\n\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      if ((i == 0) || (doubles[i] \u003c minimum)) {\r\n\tminIndex = i;\r\n\tminimum = doubles[i];\r\n      }\r\n    }\r\n\r\n    return minIndex;\r\n  }\r\n\r\n  /**\r\n   * Normalizes the doubles in the array by their sum.\r\n   *\r\n   * @param doubles the array of double\r\n   * @exception IllegalArgumentException if sum is Zero or NaN\r\n   */\r\n  public static void normalize(double[] doubles) {\r\n\r\n    double sum = 0;\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      sum += doubles[i];\r\n    }\r\n    normalize(doubles, sum);\r\n  }\r\n\r\n  /**\r\n   * Normalizes the doubles in the array using the given value.\r\n   *\r\n   * @param doubles the array of double\r\n   * @param sum the value by which the doubles are to be normalized\r\n   * @exception IllegalArgumentException if sum is zero or NaN\r\n   */\r\n  public static void normalize(double[] doubles, double sum) {\r\n\r\n    if (Double.isNaN(sum)) {\r\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is NaN.\");\r\n    }\r\n    if (sum == 0) {\r\n      // Maybe this should just be a return.\r\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is zero.\");\r\n    }\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      doubles[i] /= sum;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts an array containing the natural logarithms of\r\n   * probabilities stored in a vector back into probabilities.\r\n   * The probabilities are assumed to sum to one.\r\n   *\r\n   * @param a an array holding the natural logarithms of the probabilities\r\n   * @return the converted array \r\n   */\r\n  public static double[] logs2probs(double[] a) {\r\n\r\n    double max = a[maxIndex(a)];\r\n    double sum = 0.0;\r\n\r\n    double[] result = new double[a.length];\r\n    for(int i = 0; i \u003c a.length; i++) {\r\n      result[i] = Math.exp(a[i] - max);\r\n      sum += result[i];\r\n    }\r\n\r\n    normalize(result, sum);\r\n\r\n    return result;\r\n  } \r\n\r\n  /**\r\n   * Rounds a double to the next nearest integer value. The JDK version\r\n   * of it doesn't work properly.\r\n   *\r\n   * @param value the double value\r\n   * @return the resulting integer value\r\n   */\r\n  public static /*@pure@*/ int round(double value) {\r\n\r\n    int roundedValue = value \u003e 0\r\n      ? (int)(value + 0.5)\r\n      : -(int)(Math.abs(value) + 0.5);\r\n    \r\n    return roundedValue;\r\n  }\r\n\r\n  /**\r\n   * Rounds a double to the next nearest integer value in a probabilistic\r\n   * fashion (e.g. 0.8 has a 20% chance of being rounded down to 0 and a\r\n   * 80% chance of being rounded up to 1). In the limit, the average of\r\n   * the rounded numbers generated by this procedure should converge to\r\n   * the original double.\r\n   *\r\n   * @param value the double value\r\n   * @return the resulting integer value\r\n   */\r\n  public static int probRound(double value, Random rand) {\r\n\r\n    if (value \u003e= 0) {\r\n      double lower = Math.floor(value);\r\n      double prob = value - lower;\r\n      if (rand.nextDouble() \u003c prob) {\r\n\treturn (int)lower + 1;\r\n      } else {\r\n\treturn (int)lower;\r\n      }\r\n    } else {\r\n      double lower = Math.floor(Math.abs(value));\r\n      double prob = Math.abs(value) - lower;\r\n      if (rand.nextDouble() \u003c prob) {\r\n\treturn -((int)lower + 1);\r\n      } else {\r\n\treturn -(int)lower;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rounds a double to the given number of decimal places.\r\n   *\r\n   * @param value the double value\r\n   * @param afterDecimalPoint the number of digits after the decimal point\r\n   * @return the double rounded to the given precision\r\n   */\r\n  public static /*@pure@*/ double roundDouble(double value,int afterDecimalPoint) {\r\n\r\n    double mask = Math.pow(10.0, (double)afterDecimalPoint);\r\n\r\n    return (double)(Math.round(value * mask)) / mask;\r\n  }\r\n\r\n  /**\r\n   * Sorts a given array of integers in ascending order and returns an \r\n   * array of integers with the positions of the elements of the original \r\n   * array in the sorted array. The sort is stable. (Equal elements remain\r\n   * in their original order.)\r\n   *\r\n   * @param array this array is not changed by the method!\r\n   * @return an array of integers with the positions in the sorted\r\n   * array.\r\n   */\r\n  public static /*@pure@*/ int[] sort(int [] array) {\r\n\r\n    int [] index = new int[array.length];\r\n    int [] newIndex = new int[array.length];\r\n    int [] helpIndex;\r\n    int numEqual;\r\n    \r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n    }\r\n    quickSort(array, index, 0, array.length - 1);\r\n\r\n    // Make sort stable\r\n    int i = 0;\r\n    while (i \u003c index.length) {\r\n      numEqual = 1;\r\n      for (int j = i + 1; ((j \u003c index.length)\r\n\t\t\t   \u0026\u0026 (array[index[i]] == array[index[j]]));\r\n\t   j++) {\r\n\tnumEqual++;\r\n      }\r\n      if (numEqual \u003e 1) {\r\n\thelpIndex = new int[numEqual];\r\n\tfor (int j = 0; j \u003c numEqual; j++) {\r\n\t  helpIndex[j] = i + j;\r\n\t}\r\n\tquickSort(index, helpIndex, 0, numEqual - 1);\r\n\tfor (int j = 0; j \u003c numEqual; j++) {\r\n\t  newIndex[i + j] = index[helpIndex[j]];\r\n\t}\r\n\ti += numEqual;\r\n      } else {\r\n\tnewIndex[i] = index[i];\r\n\ti++;\r\n      }\r\n    }\r\n    return newIndex;\r\n  }\r\n\r\n  /**\r\n   * Sorts a given array of doubles in ascending order and returns an\r\n   * array of integers with the positions of the elements of the\r\n   * original array in the sorted array. NOTE THESE CHANGES: the sort\r\n   * is no longer stable and it doesn't use safe floating-point\r\n   * comparisons anymore. Occurrences of Double.NaN are treated as \r\n   * Double.MAX_VALUE\r\n   *\r\n   * @param array this array is not changed by the method!\r\n   * @return an array of integers with the positions in the sorted\r\n   * array.  \r\n   */\r\n  public static /*@pure@*/ int[] sort(/*@non_null@*/ double [] array) {\r\n\r\n    int [] index = new int[array.length];\r\n    array = (double [])array.clone();\r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n      if (Double.isNaN(array[i])) {\r\n        array[i] = Double.MAX_VALUE;\r\n      }\r\n    }\r\n    quickSort(array, index, 0, array.length - 1);\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Sorts a given array of doubles in ascending order and returns an \r\n   * array of integers with the positions of the elements of the original \r\n   * array in the sorted array. The sort is stable (Equal elements remain\r\n   * in their original order.) Occurrences of Double.NaN are treated as \r\n   * Double.MAX_VALUE\r\n   *\r\n   * @param array this array is not changed by the method!\r\n   * @return an array of integers with the positions in the sorted\r\n   * array.\r\n   */\r\n  public static /*@pure@*/ int[] stableSort(double [] array){\r\n\r\n    int [] index = new int[array.length];\r\n    int [] newIndex = new int[array.length];\r\n    int [] helpIndex;\r\n    int numEqual;\r\n    \r\n    array = (double [])array.clone();\r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n      if (Double.isNaN(array[i])) {\r\n        array[i] = Double.MAX_VALUE;\r\n      }\r\n    }\r\n    quickSort(array,index,0,array.length-1);\r\n\r\n    // Make sort stable\r\n\r\n    int i = 0;\r\n    while (i \u003c index.length) {\r\n      numEqual = 1;\r\n      for (int j = i+1; ((j \u003c index.length) \u0026\u0026 Utils.eq(array[index[i]],\r\n\t\t\t\t\t\t\tarray[index[j]])); j++)\r\n\tnumEqual++;\r\n      if (numEqual \u003e 1) {\r\n\thelpIndex = new int[numEqual];\r\n\tfor (int j = 0; j \u003c numEqual; j++)\r\n\t  helpIndex[j] = i+j;\r\n\tquickSort(index, helpIndex, 0, numEqual-1);\r\n\tfor (int j = 0; j \u003c numEqual; j++) \r\n\t  newIndex[i+j] = index[helpIndex[j]];\r\n\ti += numEqual;\r\n      } else {\r\n\tnewIndex[i] = index[i];\r\n\ti++;\r\n      }\r\n    }\r\n\r\n    return newIndex;\r\n  }\r\n\r\n  /**\r\n   * Computes the variance for an array of doubles.\r\n   *\r\n   * @param vector the array\r\n   * @return the variance\r\n   */\r\n  public static /*@pure@*/ double variance(double[] vector) {\r\n  \r\n    double sum = 0, sumSquared = 0;\r\n\r\n    if (vector.length \u003c= 1) {\r\n      return 0;\r\n    }\r\n    for (int i = 0; i \u003c vector.length; i++) {\r\n      sum += vector[i];\r\n      sumSquared += (vector[i] * vector[i]);\r\n    }\r\n    double result = (sumSquared - (sum * sum / (double) vector.length)) / \r\n      (double) (vector.length - 1);\r\n\r\n    // We don't like negative variance\r\n    if (result \u003c 0) {\r\n      return 0;\r\n    } else {\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Computes the sum of the elements of an array of doubles.\r\n   *\r\n   * @param doubles the array of double\r\n   * @return the sum of the elements\r\n   */\r\n  public static /*@pure@*/ double sum(double[] doubles) {\r\n\r\n    double sum = 0;\r\n\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      sum += doubles[i];\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * Computes the sum of the elements of an array of integers.\r\n   *\r\n   * @param ints the array of integers\r\n   * @return the sum of the elements\r\n   */\r\n  public static /*@pure@*/ int sum(int[] ints) {\r\n\r\n    int sum = 0;\r\n\r\n    for (int i = 0; i \u003c ints.length; i++) {\r\n      sum += ints[i];\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * Returns c*log2(c) for a given integer value c.\r\n   *\r\n   * @param c an integer value\r\n   * @return c*log2(c) (but is careful to return 0 if c is 0)\r\n   */\r\n  public static /*@pure@*/ double xlogx(int c) {\r\n    \r\n    if (c == 0) {\r\n      return 0.0;\r\n    }\r\n    return c * Utils.log2((double) c);\r\n  }\r\n\r\n  /**\r\n   * Partitions the instances around a pivot. Used by quicksort and\r\n   * kthSmallestValue.\r\n   *\r\n   * @param array the array of doubles to be sorted\r\n   * @param index the index into the array of doubles\r\n   * @param left the first index of the subset \r\n   * @param right the last index of the subset \r\n   *\r\n   * @return the index of the middle element\r\n   */\r\n  private static int partition(double[] array, int[] index, int l, int r) {\r\n    \r\n    double pivot = array[index[(l + r) / 2]];\r\n    int help;\r\n\r\n    while (l \u003c r) {\r\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\r\n        l++;\r\n      }\r\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\r\n        r--;\r\n      }\r\n      if (l \u003c r) {\r\n        help = index[l];\r\n        index[l] = index[r];\r\n        index[r] = help;\r\n        l++;\r\n        r--;\r\n      }\r\n    }\r\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\r\n      r--;\r\n    } \r\n\r\n    return r;\r\n  }\r\n\r\n  /**\r\n   * Partitions the instances around a pivot. Used by quicksort and\r\n   * kthSmallestValue.\r\n   *\r\n   * @param array the array of integers to be sorted\r\n   * @param index the index into the array of integers\r\n   * @param left the first index of the subset \r\n   * @param right the last index of the subset \r\n   *\r\n   * @return the index of the middle element\r\n   */\r\n  private static int partition(int[] array, int[] index, int l, int r) {\r\n    \r\n    double pivot = array[index[(l + r) / 2]];\r\n    int help;\r\n\r\n    while (l \u003c r) {\r\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\r\n        l++;\r\n      }\r\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\r\n        r--;\r\n      }\r\n      if (l \u003c r) {\r\n        help = index[l];\r\n        index[l] = index[r];\r\n        index[r] = help;\r\n        l++;\r\n        r--;\r\n      }\r\n    }\r\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\r\n      r--;\r\n    } \r\n\r\n    return r;\r\n  }\r\n  \r\n  /**\r\n   * Implements quicksort according to Manber's \"Introduction to\r\n   * Algorithms\".\r\n   *\r\n   * @param array the array of doubles to be sorted\r\n   * @param index the index into the array of doubles\r\n   * @param left the first index of the subset to be sorted\r\n   * @param right the last index of the subset to be sorted\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r\n  //@ requires array != index;\r\n  //  assignable index;\r\n  private static void quickSort(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \r\n                                int left, int right) {\r\n\r\n    if (left \u003c right) {\r\n      int middle = partition(array, index, left, right);\r\n      quickSort(array, index, left, middle);\r\n      quickSort(array, index, middle + 1, right);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Implements quicksort according to Manber's \"Introduction to\r\n   * Algorithms\".\r\n   *\r\n   * @param array the array of integers to be sorted\r\n   * @param index the index into the array of integers\r\n   * @param left the first index of the subset to be sorted\r\n   * @param right the last index of the subset to be sorted\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r\n  //@ requires array != index;\r\n  //  assignable index;\r\n  private static void quickSort(/*@non_null@*/ int[] array, /*@non_null@*/  int[] index, \r\n                                int left, int right) {\r\n\r\n    if (left \u003c right) {\r\n      int middle = partition(array, index, left, right);\r\n      quickSort(array, index, left, middle);\r\n      quickSort(array, index, middle + 1, right);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Implements computation of the kth-smallest element according\r\n   * to Manber's \"Introduction to Algorithms\".\r\n   *\r\n   * @param array the array of double\r\n   * @param index the index into the array of doubles\r\n   * @param left the first index of the subset \r\n   * @param right the last index of the subset \r\n   * @param k the value of k\r\n   *\r\n   * @return the index of the kth-smallest element\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  private static int select(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \r\n                            int left, int right, int k) {\r\n    \r\n    if (left == right) {\r\n      return left;\r\n    } else {\r\n      int middle = partition(array, index, left, right);\r\n      if ((middle - left + 1) \u003e= k) {\r\n        return select(array, index, left, middle, k);\r\n      } else {\r\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Implements computation of the kth-smallest element according\r\n   * to Manber's \"Introduction to Algorithms\".\r\n   *\r\n   * @param array the array of integers\r\n   * @param index the index into the array of integers\r\n   * @param left the first index of the subset \r\n   * @param right the last index of the subset \r\n   * @param k the value of k\r\n   *\r\n   * @return the index of the kth-smallest element\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  private static int select(/*@non_null@*/ int[] array, /*@non_null@*/ int[] index, \r\n                            int left, int right, int k) {\r\n    \r\n    if (left == right) {\r\n      return left;\r\n    } else {\r\n      int middle = partition(array, index, left, right);\r\n      if ((middle - left + 1) \u003e= k) {\r\n        return select(array, index, left, middle, k);\r\n      } else {\r\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Main method for testing this class.\r\n   *\r\n   * @param ops some dummy options\r\n   */\r\n  public static void main(String[] ops) {\r\n\r\n    double[] doublesWithNaN = {4.5, 6.7, Double.NaN, 3.4, 4.8, 1.2, 3.4};\r\n    double[] doubles = {4.5, 6.7, 6.7, 3.4, 4.8, 1.2, 3.4, 6.7, 6.7, 3.4};\r\n    int[] ints = {12, 6, 2, 18, 16, 6, 7, 5, 18, 18, 17};\r\n\r\n    try {\r\n\r\n      // Option handling\r\n      System.out.println(\"First option split up:\");\r\n      if (ops.length \u003e 0) {\r\n\tString[] firstOptionSplitUp = Utils.splitOptions(ops[0]);\r\n\tfor (int i = 0; i \u003c firstOptionSplitUp.length; i ++) {\r\n\t  System.out.println(firstOptionSplitUp[i]);\r\n\t}\r\n      }\t\t\t\t\t       \r\n      System.out.println(\"Partitioned options: \");\r\n      String[] partitionedOptions = Utils.partitionOptions(ops);\r\n      for (int i  = 0; i \u003c partitionedOptions.length; i++) {\r\n\tSystem.out.println(partitionedOptions[i]);\r\n      }\r\n      System.out.println(\"Get flag -f: \" + Utils.getFlag('f', ops));\r\n      System.out.println(\"Get option -o: \" + Utils.getOption('o', ops));\r\n      System.out.println(\"Checking for remaining options... \");\r\n      Utils.checkForRemainingOptions(ops);\r\n      \r\n      // Statistics\r\n      System.out.println(\"Original array with NaN (doubles): \");\r\n      for (int i = 0; i \u003c doublesWithNaN.length; i++) {\r\n\tSystem.out.print(doublesWithNaN[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Original array (doubles): \");\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(doubles[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Original array (ints): \");\r\n      for (int i = 0; i \u003c ints.length; i++) {\r\n\tSystem.out.print(ints[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Correlation: \" + Utils.correlation(doubles, doubles, \r\n\t\t\t\t\t\t\t     doubles.length));\r\n      System.out.println(\"Mean: \" + Utils.mean(doubles));\r\n      System.out.println(\"Variance: \" + Utils.variance(doubles));\r\n      System.out.println(\"Sum (doubles): \" + Utils.sum(doubles));\r\n      System.out.println(\"Sum (ints): \" + Utils.sum(ints));\r\n      System.out.println(\"Max index (doubles): \" + Utils.maxIndex(doubles));\r\n      System.out.println(\"Max index (ints): \" + Utils.maxIndex(ints));\r\n      System.out.println(\"Min index (doubles): \" + Utils.minIndex(doubles));\r\n      System.out.println(\"Min index (ints): \" + Utils.minIndex(ints));\r\n      System.out.println(\"Median (doubles): \" + \r\n                         Utils.kthSmallestValue(doubles, doubles.length / 2));\r\n      System.out.println(\"Median (ints): \" + \r\n                         Utils.kthSmallestValue(ints, ints.length / 2));\r\n\r\n      // Sorting and normalizing\r\n      System.out.println(\"Sorted array with NaN (doubles): \");\r\n      int[] sorted = Utils.sort(doublesWithNaN);\r\n      for (int i = 0; i \u003c doublesWithNaN.length; i++) {\r\n\tSystem.out.print(doublesWithNaN[sorted[i]] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Sorted array (doubles): \");\r\n      sorted = Utils.sort(doubles);\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(doubles[sorted[i]] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Sorted array (ints): \");\r\n      sorted = Utils.sort(ints);\r\n      for (int i = 0; i \u003c ints.length; i++) {\r\n\tSystem.out.print(ints[sorted[i]] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Indices from stable sort (doubles): \");\r\n      sorted = Utils.stableSort(doubles);\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(sorted[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Indices from sort (ints): \");\r\n      sorted = Utils.sort(ints);\r\n      for (int i = 0; i \u003c ints.length; i++) {\r\n\tSystem.out.print(sorted[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Normalized array (doubles): \");\r\n      Utils.normalize(doubles);\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(doubles[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Normalized again (doubles): \");\r\n      Utils.normalize(doubles, Utils.sum(doubles));\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(doubles[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      \r\n      // Pretty-printing\r\n      System.out.println(\"-4.58: \" + Utils.doubleToString(-4.57826535, 2));\r\n      System.out.println(\"-6.78: \" + Utils.doubleToString(-6.78214234, 6,2));\r\n      \r\n      // Comparisons\r\n      System.out.println(\"5.70001 == 5.7 ? \" + Utils.eq(5.70001, 5.7));\r\n      System.out.println(\"5.70001 \u003e 5.7 ? \" + Utils.gr(5.70001, 5.7));\r\n      System.out.println(\"5.70001 \u003e= 5.7 ? \" + Utils.grOrEq(5.70001, 5.7));\r\n      System.out.println(\"5.7 \u003c 5.70001 ? \" + Utils.sm(5.7, 5.70001));\r\n      System.out.println(\"5.7 \u003c= 5.70001 ? \" + Utils.smOrEq(5.7, 5.70001));\r\n      \r\n      // Math\r\n      System.out.println(\"Info (ints): \" + Utils.info(ints));\r\n      System.out.println(\"log2(4.6): \" + Utils.log2(4.6));\r\n      System.out.println(\"5 * log(5): \" + Utils.xlogx(5));\r\n      System.out.println(\"5.5 rounded: \" + Utils.round(5.5));\r\n      System.out.println(\"5.55555 rounded to 2 decimal places: \" + \r\n\t\t\t Utils.roundDouble(5.55555, 2));\r\n      \r\n      // Arrays\r\n      System.out.println(\"Array-Dimensions of 'new int[][]': \" + Utils.getArrayDimensions(new int[][]{}));\r\n      System.out.println(\"Array-Dimensions of 'new int[][]{{1,2,3},{4,5,6}}': \" + Utils.getArrayDimensions(new int[][]{{1,2,3},{4,5,6}}));\r\n      String[][][] s = new String[3][4][];\r\n      System.out.println(\"Array-Dimensions of 'new String[3][4][]': \" + Utils.getArrayDimensions(s));\r\n    } catch (Exception e) {\r\n      e.printStackTrace();\r\n    }\r\n  }\r\n}\r\n  \r\n",
        "name": "Utils.java",
        "path": "subjectSystems/C,D/core/Utils.java",
        "url": "/github.com/LASER-UMASS/Themis/-/blob/subjectSystems/C,D/core/Utils.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 1536,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1537,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1538,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1559,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1560,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1561,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1585,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1613,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        }
      ],
      "repository": {
        "name": "github.com/LASER-UMASS/Themis",
        "url": "/github.com/LASER-UMASS/Themis"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a70f12a6a8f34cdd8b170b4dc59a78674c9e8950"
        },
        "content": "/*\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; either version 2 of the License, or\n *    (at your option) any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n/*\n *    Queue.java\n *    Copyright (C) 1999 Len Trigg\n *\n *    Modified March-May 2004 by Mark Utting to add JML specs\n *    (this was done as the example solution of an assignment for a\n *     software engineering course, so the specifications are more precise\n *     and complete than one would normally do).\n *    Passed a static analysis using ESC/Java-2.0a6 with no warnings.\n*/\n\npackage weka.core;\n\nimport java.io.*;\n\n/** \n * Class representing a FIFO queue.\n *\n * @author Len Trigg (trigg@cs.waikato.ac.nz)\n * @version $Revision: 1.7 $\n */\npublic class Queue extends Object implements Serializable {\n\n  /**\n   * Represents one node in the queue.\n   */\n  protected class QueueNode implements Serializable {\n\n    /** The next node in the queue */\n    protected /*@ spec_public @*/ QueueNode m_Next;\n\n    /** The nodes contents\n     */\n    protected /*@ non_null spec_public @*/ Object m_Contents;\n\n    /** \n     * Creates a queue node with the given contents \n     */\n    //@ requires contents != null;\n    //@ assignable m_Contents, m_Next;\n    //@ ensures m_Contents == contents;\n    //@ ensures m_Next == null;\n    public QueueNode(Object contents) {\n      m_Contents = contents;\n      next(null);\n    }\n\n    /**\n     * Sets the next node in the queue, and returns it.\n     */\n    //@ requires next != this ;\n    //@ assignable m_Next;\n    //@ ensures m_Next==next \u0026\u0026 \\result==next;\n    public QueueNode next(QueueNode next) {\n      return m_Next = next;\n    } //@ nowarn Invariant; // Because it stupidly checks the Queue invariant!\n\n    /**\n     * Gets the next node in the queue. \n     */\n    //@ ensures \\result == m_Next;\n    public /*@ pure @*/ QueueNode next() {\n      return m_Next;\n    }\n\n    /**\n     * Sets the contents of the node.\n     */\n    //@ requires contents != null;\n    //@ assignable m_Contents;\n    //@ ensures  m_Contents == contents \u0026\u0026 \\result == contents;\n    public Object contents(Object contents) {\n      return m_Contents = contents;\n    }\n\n    /**\n     * Returns the contents in the node.\n     */\n      //@ ensures \\result == m_Contents;\n    public /*@ pure @*/ Object contents() {\n      return m_Contents;\n    }\n  }\n\n  /** Store a reference to the head of the queue */\n  protected /*@ spec_public @*/ QueueNode m_Head = null;\n\n  /** Store a reference to the tail of the queue */\n  protected /*@ spec_public @*/ QueueNode m_Tail = null;\n\n  /** Store the c m_Tail.m_Nexturrent number of elements in the queue */\n  protected /*@ spec_public @*/ int m_Size = 0;\n\n  //@ public invariant m_Head == null \u003c==\u003e m_Tail == null;\n  //@public invariant m_Tail != null ==\u003e m_Tail.m_Next == null;\n  //@ public invariant m_Size \u003e= 0;\n  //@ public invariant m_Size == 0 \u003c==\u003e m_Head == null;\n  //@ public invariant m_Size == 1 \u003c==\u003e m_Head != null \u0026\u0026 m_Head == m_Tail;\n  //@ public invariant m_Size \u003e 1 ==\u003e m_Head != m_Tail;\n  //@ public invariant m_Size \u003e 1 \u003c== m_Head != m_Tail;\n\n\n\n  /**\n   * Removes all objects from the queue m_Tail.m_Next.\n   */\n  //@ assignable m_Size, m_Head, m_Tail;\n  //@ ensures m_Size == 0;\n  //@ ensures m_Head == null;\n  //@ ensures m_Tail == null;\n  public final synchronized void removeAllElements() {\n    m_Size = 0;\n    m_Head = null;\n    m_Tail = null;\n  }\n\n  /**\n   * Appends an object to the back of the queue.\n   *\n   * @param item the object to be appended\n   * @return the object appended\n   */\n  //@ requires item != null;\n  //@ assignable m_Head, m_Tail, m_Tail.m_Next, m_Head.m_Next, m_Size;\n  //@ ensures m_Head != null;\n  //@ ensures m_Tail != \\old(m_Tail);\n  //@ ensures m_Size == \\old(m_Size) + 1;\n  //@ ensures \\old(m_Size) == 0 ==\u003e m_Head == m_Tail; \n  //@ ensures \\old(m_Size) != 0 ==\u003e m_Head == \\old(m_Head);\n  //@ ensures m_Tail.contents() == \\old(item);\n  //@ ensures \\result == item;\n  public synchronized Object push(Object item) {\n    QueueNode newNode = new QueueNode(item);\n    \n    if (m_Head == null) {\n      m_Head = m_Tail = newNode;\n    } else {\n      m_Tail = m_Tail.next(newNode);\n    }\n    m_Size++;\n    return item;\n  }\n\n  /**\n   * Pops an object from the front of the queue.\n   *\n   * @return the object at the front of the queue\n   * @exception RuntimeException if the queue is empty\n   */\n  //@ assignable m_Head, m_Tail, m_Size;\n  //@ ensures m_Size == \\old(m_Size) - 1;\n  //@ ensures m_Head == \\old(m_Head.m_Next);\n  //@ ensures m_Head != null ==\u003e m_Tail == \\old(m_Tail);\n  //@ ensures \\result == \\old(m_Head.m_Contents);\n  //@ signals (RuntimeException) \\old(m_Head) == null;\n  public synchronized Object pop() \n      throws RuntimeException   // REDUNDANT, BUT ESCJAVA REQUIRES THIS\n  {\n    if (m_Head == null) {\n\tthrow new RuntimeException(\"Queue is empty\");\n    }\n    Object retval = m_Head.contents();\n    m_Size--;\n    m_Head = m_Head.next();\n    // Here we need to either tell ESC/Java some facts about\n    // the contents of the list after popping off the head,\n    // or turn off the 'invariant' warnings.\n    //\n    //@ assume m_Size == 0 \u003c==\u003e m_Head == null;\n    //@ assume m_Size == 1 \u003c==\u003e m_Head == m_Tail;\n    if (m_Head == null) {\n      m_Tail = null;\n    }\n    return retval;\n  }\n\n  /**\n   * Gets object from the front of the queue.\n   *\n   * @return the object at the front of the queue\n   * @exception RuntimeException if the queue is empty\n   */\n  //@ ensures \\result == \\old(m_Head.m_Contents);\n  //@ signals (RuntimeException) \\old(m_Head) == null;\n  public /*@ pure @*/ synchronized Object peek() \n    throws RuntimeException\n  { \n    if (m_Head == null) {\n      throw new RuntimeException(\"Queue is empty\");\n    }\n    return m_Head.contents();\n  }\n\n  /**\n   * Checks if queue is empty.\n   * \n   * @return true if queue is empty\n   */\n  //@ ensures \\result \u003c==\u003e m_Head == null;\n  public /*@ pure @*/ boolean empty() {\n    return m_Head == null;\n  }\n\n  /**\n   * Gets queue's size.\n   *\n   * @return size of queue\n   */\n  //@ ensures \\result == m_Size;\n  public /*@ pure @*/ int size() {\n    return m_Size;\n  }\n\n  /**\n   * Produces textual description of queue.\n   *\n   * @return textual description of queue\n   */\n  //@ also\n  //@ ensures \\result != null;\n  //@ ensures (* \\result == textual description of the queue *);\n  public  /*@ pure @*/ String toString() {\n\n    String retval = \"Queue Contents \"+m_Size+\" elements\\n\";\n    QueueNode current = m_Head;\n    if (current == null) {\n      return retval + \"Empty\\n\";\n    } else {\n      while (current != null) {\n        retval += current.contents().toString()+\"\\n\"; //@nowarn Modifies;\n\tcurrent = current.next();\n      }\n    }\n    return retval;\n  } //@ nowarn Post;\n\n  /**\n   * Main method for testing this class.\n   *\n   * @param argv a set of strings that are pushed on a test queue\n   */\n  //@ requires argv.length \u003e= 0;\n  //@ requires argv != null;\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c argv.length; argv[i] != null);\n  public static void main(String [] argv) {\n\n    try {\n      Queue queue = new Queue();\n      for(int i = 0; i \u003c argv.length; i++) {\n\tqueue.push(argv[i]);\n      }\n      System.out.println(\"After pushing command line arguments\");\n      System.out.println(queue.toString());\n      while (!queue.empty()) {\n\tSystem.out.println(\"Pop: \" + queue.pop().toString());\n      }\n      // try one more pop, to make sure we get an exception\n      try \n\t{\n\t  queue.pop();\n\t  System.out.println(\"ERROR: pop did not throw exception!\");\n\t}\n      catch (RuntimeException ex)\n        {\n\t  System.out.println(\"Pop on empty queue correctly gave exception.\");\n\t}\n    } catch (Exception ex) {\n      System.out.println(ex.getMessage());\n    }\n  }\n}\n",
        "name": "Queue.java",
        "path": "subjectSystems/C,D/core/Queue.java",
        "url": "/github.com/LASER-UMASS/Themis/-/blob/subjectSystems/C,D/core/Queue.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 54,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires contents != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 56,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures m_Contents == contents;"
        },
        {
          "limitHit": false,
          "lineNumber": 57,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures m_Next == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 66,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires next != this ;"
        },
        {
          "limitHit": false,
          "lineNumber": 68,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures m_Next==next \u0026\u0026 \\result==next;"
        },
        {
          "limitHit": false,
          "lineNumber": 76,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result == m_Next;"
        },
        {
          "limitHit": false,
          "lineNumber": 84,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires contents != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 94,
          "offsetAndLengths": [
            [
              6,
              12
            ]
          ],
          "preview": "      //@ ensures \\result == m_Contents;"
        },
        {
          "limitHit": false,
          "lineNumber": 123,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Size == 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 124,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 125,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Tail == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 138,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires item != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 140,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 141,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Tail != \\old(m_Tail);"
        },
        {
          "limitHit": false,
          "lineNumber": 142,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Size == \\old(m_Size) + 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 143,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\old(m_Size) == 0 ==\u003e m_Head == m_Tail; "
        },
        {
          "limitHit": false,
          "lineNumber": 144,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\old(m_Size) != 0 ==\u003e m_Head == \\old(m_Head);"
        },
        {
          "limitHit": false,
          "lineNumber": 145,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Tail.contents() == \\old(item);"
        },
        {
          "limitHit": false,
          "lineNumber": 146,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == item;"
        },
        {
          "limitHit": false,
          "lineNumber": 166,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Size == \\old(m_Size) - 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 167,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head == \\old(m_Head.m_Next);"
        },
        {
          "limitHit": false,
          "lineNumber": 168,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head != null ==\u003e m_Tail == \\old(m_Tail);"
        },
        {
          "limitHit": false,
          "lineNumber": 169,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == \\old(m_Head.m_Contents);"
        },
        {
          "limitHit": false,
          "lineNumber": 198,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == \\old(m_Head.m_Contents);"
        },
        {
          "limitHit": false,
          "lineNumber": 214,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e m_Head == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 224,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Size;"
        },
        {
          "limitHit": false,
          "lineNumber": 235,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 236,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures (* \\result == textual description of the queue *);"
        },
        {
          "limitHit": false,
          "lineNumber": 257,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires argv.length \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 258,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires argv != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 259,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c argv.length; argv[i] != null);"
        },
        {
          "limitHit": false,
          "lineNumber": 86,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  m_Contents == contents \u0026\u0026 \\result == contents;"
        }
      ],
      "repository": {
        "name": "github.com/LASER-UMASS/Themis",
        "url": "/github.com/LASER-UMASS/Themis"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a70f12a6a8f34cdd8b170b4dc59a78674c9e8950"
        },
        "content": "/*\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; either version 2 of the License, or\n *    (at your option) any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n/*\n *    Instance.java\n *    Copyright (C) 1999 Eibe Frank\n *\n */\n\npackage weka.core;\n\nimport java.util.*;\nimport java.io.*;\n\n/**\n * Class for handling an instance. All values (numeric, date, nominal, or\n * string) are internally stored as floating-point numbers. If an\n * attribute is nominal (or a string), the stored value is the index\n * of the corresponding nominal (or string) value in the attribute's\n * definition. We have chosen this approach in favor of a more elegant\n * object-oriented approach because it is much faster. \u003cp\u003e\n *\n * Typical usage (code from the main() method of this class): \u003cp\u003e\n *\n * \u003ccode\u003e\n * ... \u003cbr\u003e\n *      \n * // Create empty instance with three attribute values \u003cbr\u003e\n * Instance inst = new Instance(3); \u003cbr\u003e\u003cbr\u003e\n *     \n * // Set instance's values for the attributes \"length\", \"weight\", and \"position\"\u003cbr\u003e\n * inst.setValue(length, 5.3); \u003cbr\u003e\n * inst.setValue(weight, 300); \u003cbr\u003e\n * inst.setValue(position, \"first\"); \u003cbr\u003e\u003cbr\u003e\n *   \n * // Set instance's dataset to be the dataset \"race\" \u003cbr\u003e\n * inst.setDataset(race); \u003cbr\u003e\u003cbr\u003e\n *   \n * // Print the instance \u003cbr\u003e\n * System.out.println(\"The instance: \" + inst); \u003cbr\u003e\n *\n * ... \u003cbr\u003e\n * \u003c/code\u003e\u003cp\u003e\n *\n * All methods that change an instance are safe, ie. a change of an\n * instance does not affect any other instances. All methods that\n * change an instance's attribute values clone the attribute value\n * vector before it is changed. If your application heavily modifies\n * instance values, it may be faster to create a new instance from scratch.\n *\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\n * @version $Revision: 1.19.2.2 $ \n */\npublic class Instance implements Copyable, Serializable {\n  \n  /** Constant representing a missing value. */\n  protected static final double MISSING_VALUE = Double.NaN;\n\n  /** \n   * The dataset the instance has access to.  Null if the instance\n   * doesn't have access to any dataset.  Only if an instance has\n   * access to a dataset, it knows about the actual attribute types.  \n   */\n  protected /*@spec_public@*/ Instances m_Dataset;\n\n  /** The instance's attribute values. */\n  protected /*@spec_public non_null@*/ double[] m_AttValues;\n\n  /** The instance's weight. */\n  protected double m_Weight;\n\n  /**\n   * Constructor that copies the attribute values and the weight from\n   * the given instance. Reference to the dataset is set to null.\n   * (ie. the instance doesn't have access to information about the\n   * attribute types)\n   *\n   * @param instance the instance from which the attribute\n   * values and the weight are to be copied \n   */\n  //@ ensures m_Dataset == null;\n  protected Instance(/*@non_null@*/ Instance instance) {\n    \n    m_AttValues = instance.m_AttValues;\n    m_Weight = instance.m_Weight;\n    m_Dataset = null;\n  }\n\n  /**\n   * Constructor that inititalizes instance variable with given\n   * values. Reference to the dataset is set to null. (ie. the instance\n   * doesn't have access to information about the attribute types)\n   *\n   * @param weight the instance's weight\n   * @param attValues a vector of attribute values \n   */\n  //@ ensures m_Dataset == null;\n  public Instance(double weight,  /*@non_null@*/ double[]attValues){\n    \n    m_AttValues = attValues;\n    m_Weight = weight;\n    m_Dataset = null;\n  }\n\n  /**\n   * Constructor of an instance that sets weight to one, all values to\n   * be missing, and the reference to the dataset to null. (ie. the instance\n   * doesn't have access to information about the attribute types)\n   *\n   * @param numAttributes the size of the instance \n   */\n  //@ requires numAttributes \u003e 0;    // Or maybe == 0 is okay too?\n  //@ ensures m_Dataset == null;\n  public Instance(int numAttributes) {\n    \n    m_AttValues = new double[numAttributes];\n    for (int i = 0; i \u003c m_AttValues.length; i++) {\n      m_AttValues[i] = MISSING_VALUE;\n    }\n    m_Weight = 1;\n    m_Dataset = null;\n  }\n\n  /**\n   * Returns the attribute with the given index.\n   *\n   * @param index the attribute's index\n   * @return the attribute at the given position\n   * @exception UnassignedDatasetException if instance doesn't have access to a\n   * dataset\n   */ \n  //@ requires m_Dataset != null;\n  public /*@pure@*/ Attribute attribute(int index) {\n   \n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    return m_Dataset.attribute(index);\n  }\n\n  /**\n   * Returns the attribute with the given index. Does the same\n   * thing as attribute().\n   *\n   * @param indexOfIndex the index of the attribute's index \n   * @return the attribute at the given position\n   * @exception UnassignedDatasetException if instance doesn't have access to a\n   * dataset\n   */ \n  //@ requires m_Dataset != null;\n  public /*@pure@*/ Attribute attributeSparse(int indexOfIndex) {\n   \n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    return m_Dataset.attribute(indexOfIndex);\n  }\n\n  /**\n   * Returns class attribute.\n   *\n   * @return the class attribute\n   * @exception UnassignedDatasetException if the class is not set or the\n   * instance doesn't have access to a dataset\n   */\n  //@ requires m_Dataset != null;\n  public /*@pure@*/ Attribute classAttribute() {\n\n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    return m_Dataset.classAttribute();\n  }\n\n  /**\n   * Returns the class attribute's index.\n   *\n   * @return the class index as an integer \n   * @exception UnassignedDatasetException if instance doesn't have access to a dataset \n   */\n  //@ requires m_Dataset != null;\n  //@ ensures  \\result == m_Dataset.classIndex();\n  public /*@pure@*/ int classIndex() {\n    \n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    return m_Dataset.classIndex();\n  }\n\n  /**\n   * Tests if an instance's class is missing.\n   *\n   * @return true if the instance's class is missing\n   * @exception UnassignedClassException if the class is not set or the instance doesn't\n   * have access to a dataset\n   */\n  //@ requires classIndex() \u003e= 0;\n  public /*@pure@*/ boolean classIsMissing() {\n\n    if (classIndex() \u003c 0) {\n      throw new UnassignedClassException(\"Class is not set!\");\n    }\n    return isMissing(classIndex());\n  }\n\n  /**\n   * Returns an instance's class value in internal format. (ie. as a\n   * floating-point number)\n   *\n   * @return the corresponding value as a double (If the \n   * corresponding attribute is nominal (or a string) then it returns the \n   * value's index as a double).\n   * @exception UnassignedClassException if the class is not set or the instance doesn't\n   * have access to a dataset \n   */\n  //@ requires classIndex() \u003e= 0;\n  public /*@pure@*/ double classValue() {\n    \n    if (classIndex() \u003c 0) {\n      throw new UnassignedClassException(\"Class is not set!\");\n    }\n    return value(classIndex());\n  }\n\n  /**\n   * Produces a shallow copy of this instance. The copy has\n   * access to the same dataset. (if you want to make a copy\n   * that doesn't have access to the dataset, use \n   * \u003ccode\u003enew Instance(instance)\u003c/code\u003e\n   *\n   * @return the shallow copy\n   */\n  //@ also ensures \\result != null;\n  //@ also ensures \\result instanceof Instance;\n  //@ also ensures ((Instance)\\result).m_Dataset == m_Dataset;\n  public /*@pure@*/ Object copy() {\n\n    Instance result = new Instance(this);\n    result.m_Dataset = m_Dataset;\n    return result;\n  }\n\n  /**\n   * Returns the dataset this instance has access to. (ie. obtains\n   * information about attribute types from) Null if the instance\n   * doesn't have access to a dataset.\n   *\n   * @return the dataset the instance has accesss to\n   */\n  //@ ensures \\result == m_Dataset;\n  public /*@pure@*/ Instances dataset() {\n\n    return m_Dataset;\n  }\n\n  /**\n   * Deletes an attribute at the given position (0 to \n   * numAttributes() - 1). Only succeeds if the instance does not\n   * have access to any dataset because otherwise inconsistencies\n   * could be introduced.\n   *\n   * @param pos the attribute's position\n   * @exception RuntimeException if the instance has access to a\n   * dataset \n   */\n  //@ requires m_Dataset != null;\n  public void deleteAttributeAt(int position) {\n\n    if (m_Dataset != null) {\n      throw new RuntimeException(\"Instance has access to a dataset!\");\n    }\n    forceDeleteAttributeAt(position);\n  }\n\n  /**\n   * Returns an enumeration of all the attributes.\n   *\n   * @return enumeration of all the attributes\n   * @exception UnassignedDatasetException if the instance doesn't\n   * have access to a dataset \n   */\n  //@ requires m_Dataset != null;\n  public /*@pure@*/ Enumeration enumerateAttributes() {\n\n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    return m_Dataset.enumerateAttributes();\n  }\n\n  /**\n   * Tests if the headers of two instances are equivalent.\n   *\n   * @param instance another instance\n   * @return true if the header of the given instance is \n   * equivalent to this instance's header\n   * @exception UnassignedDatasetException if instance doesn't have access to any\n   * dataset\n   */\n  //@ requires m_Dataset != null;\n  public /*@pure@*/ boolean equalHeaders(Instance inst) {\n\n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    return m_Dataset.equalHeaders(inst.m_Dataset);\n  }\n\n  /**\n   * Tests whether an instance has a missing value. Skips the class attribute if set.\n   * @return true if instance has a missing value.\n   * @exception UnassignedDatasetException if instance doesn't have access to any\n   * dataset\n   */\n  //@ requires m_Dataset != null;\n  public /*@pure@*/ boolean hasMissingValue() {\n    \n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      if (i != classIndex()) {\n\tif (isMissing(i)) {\n\t  return true;\n\t}\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Returns the index of the attribute stored at the given position.\n   * Just returns the given value.\n   *\n   * @param position the position \n   * @return the index of the attribute stored at the given position\n   */\n  public /*@pure@*/ int index(int position) {\n\n    return position;\n  }\n\n  /**\n   * Inserts an attribute at the given position (0 to \n   * numAttributes()). Only succeeds if the instance does not\n   * have access to any dataset because otherwise inconsistencies\n   * could be introduced.\n   *\n   * @param pos the attribute's position\n   * @exception RuntimeException if the instance has accesss to a\n   * dataset\n   * @exception IllegalArgumentException if the position is out of range\n   */\n  //@ requires m_Dataset == null;\n  //@ requires 0 \u003c= position \u0026\u0026 position \u003c= numAttributes();\n  public void insertAttributeAt(int position) {\n\n    if (m_Dataset != null) {\n      throw new RuntimeException(\"Instance has accesss to a dataset!\");\n    }\n    if ((position \u003c 0) ||\n\t(position \u003e numAttributes())) {\n      throw new IllegalArgumentException(\"Can't insert attribute: index out \"+\n                                         \"of range\");\n    }\n    forceInsertAttributeAt(position);\n  }\n\n  /**\n   * Tests if a specific value is \"missing\".\n   *\n   * @param attIndex the attribute's index\n   */\n  public /*@pure@*/ boolean isMissing(int attIndex) {\n\n    if (Double.isNaN(m_AttValues[attIndex])) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Tests if a specific value is \"missing\". Does\n   * the same thing as isMissing() if applied to an Instance.\n   *\n   * @param indexOfIndex the index of the attribute's index \n   */\n  public /*@pure@*/ boolean isMissingSparse(int indexOfIndex) {\n\n    if (Double.isNaN(m_AttValues[indexOfIndex])) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Tests if a specific value is \"missing\".\n   * The given attribute has to belong to a dataset.\n   *\n   * @param att the attribute\n   */\n  public /*@pure@*/ boolean isMissing(Attribute att) {\n\n    return isMissing(att.index());\n  }\n\n  /**\n   * Tests if the given value codes \"missing\".\n   *\n   * @param val the value to be tested\n   * @return true if val codes \"missing\"\n   */\n  public static /*@pure@*/ boolean isMissingValue(double val) {\n\n    return Double.isNaN(val);\n  }\n\n  /**\n   * Merges this instance with the given instance and returns\n   * the result. Dataset is set to null.\n   *\n   * @param inst the instance to be merged with this one\n   * @return the merged instances\n   */\n  public Instance mergeInstance(Instance inst) {\n\n    int m = 0;\n    double [] newVals = new double[numAttributes() + inst.numAttributes()];\n    for (int j = 0; j \u003c numAttributes(); j++, m++) {\n      newVals[m] = value(j);\n    }\n    for (int j = 0; j \u003c inst.numAttributes(); j++, m++) {\n      newVals[m] = inst.value(j);\n    }\n    return new Instance(1.0, newVals);\n  }\n\n  /**\n   * Returns the double that codes \"missing\".\n   *\n   * @return the double that codes \"missing\"\n   */\n  public /*@pure@*/ static double missingValue() {\n\n    return MISSING_VALUE;\n  }\n\n  /**\n   * Returns the number of attributes.\n   *\n   * @return the number of attributes as an integer\n   */\n  //@ ensures \\result == m_AttValues.length;\n  public /*@pure@*/ int numAttributes() {\n\n    return m_AttValues.length;\n  }\n\n  /**\n   * Returns the number of class labels.\n   *\n   * @return the number of class labels as an integer if the \n   * class attribute is nominal, 1 otherwise.\n   * @exception UnassignedDatasetException if instance doesn't have access to any\n   * dataset\n   */\n  //@ requires m_Dataset != null;\n  public /*@pure@*/ int numClasses() {\n    \n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    return m_Dataset.numClasses();\n  }\n\n  /**\n   * Returns the number of values present. Always the same as numAttributes().\n   *\n   * @return the number of values\n   */\n  //@ ensures \\result == m_AttValues.length;\n  public /*@pure@*/ int numValues() {\n\n    return m_AttValues.length;\n  }\n\n  /** \n   * Replaces all missing values in the instance with the\n   * values contained in the given array. A deep copy of\n   * the vector of attribute values is performed before the\n   * values are replaced.\n   *\n   * @param array containing the means and modes\n   * @exception IllegalArgumentException if numbers of attributes are unequal\n   */\n  public void replaceMissingValues(double[] array) {\n\t \n    if ((array == null) || \n\t(array.length != m_AttValues.length)) {\n      throw new IllegalArgumentException(\"Unequal number of attributes!\");\n    }\n    freshAttributeVector();\n    for (int i = 0; i \u003c m_AttValues.length; i++) {\n      if (isMissing(i)) {\n\tm_AttValues[i] = array[i];\n      }\n    }\n  }\n\n  /**\n   * Sets the class value of an instance to be \"missing\". A deep copy of\n   * the vector of attribute values is performed before the\n   * value is set to be missing.\n   *\n   * @exception UnassignedClassException if the class is not set\n   * @exception UnassignedDatasetException if the instance doesn't\n   * have access to a dataset\n   */\n  //@ requires classIndex() \u003e= 0;\n  public void setClassMissing() {\n\n    if (classIndex() \u003c 0) {\n      throw new UnassignedClassException(\"Class is not set!\");\n    }\n    setMissing(classIndex());\n  }\n\n  /**\n   * Sets the class value of an instance to the given value (internal\n   * floating-point format).  A deep copy of the vector of attribute\n   * values is performed before the value is set.\n   *\n   * @param value the new attribute value (If the corresponding\n   * attribute is nominal (or a string) then this is the new value's\n   * index as a double).  \n   * @exception UnassignedClassException if the class is not set\n   * @exception UnaddignedDatasetException if the instance doesn't\n   * have access to a dataset \n   */\n  //@ requires classIndex() \u003e= 0;\n  public void setClassValue(double value) {\n\n    if (classIndex() \u003c 0) {\n      throw new UnassignedClassException(\"Class is not set!\");\n    }\n    setValue(classIndex(), value);\n  }\n\n  /**\n   * Sets the class value of an instance to the given value. A deep\n   * copy of the vector of attribute values is performed before the\n   * value is set.\n   *\n   * @param value the new class value (If the class\n   * is a string attribute and the value can't be found,\n   * the value is added to the attribute).\n   * @exception UnassignedClassException if the class is not set\n   * @exception UnassignedDatasetException if the dataset is not set\n   * @exception IllegalArgumentException if the attribute is not\n   * nominal or a string, or the value couldn't be found for a nominal\n   * attribute \n   */\n  //@ requires classIndex() \u003e= 0;\n  public final void setClassValue(String value) {\n\n    if (classIndex() \u003c 0) {\n      throw new UnassignedClassException(\"Class is not set!\");\n    }\n    setValue(classIndex(), value);\n  }\n\n  /**\n   * Sets the reference to the dataset. Does not check if the instance\n   * is compatible with the dataset. Note: the dataset does not know\n   * about this instance. If the structure of the dataset's header\n   * gets changed, this instance will not be adjusted automatically.\n   *\n   * @param instances the reference to the dataset \n   */\n  public final void setDataset(Instances instances) {\n    \n    m_Dataset = instances;\n  }\n\n  /**\n   * Sets a specific value to be \"missing\". Performs a deep copy\n   * of the vector of attribute values before the value is set to\n   * be missing.\n   *\n   * @param attIndex the attribute's index\n   */\n  public final void setMissing(int attIndex) {\n\n    setValue(attIndex, MISSING_VALUE);\n  }\n\n  /**\n   * Sets a specific value to be \"missing\". Performs a deep copy\n   * of the vector of attribute values before the value is set to\n   * be missing. The given attribute has to belong to a dataset.\n   *\n   * @param att the attribute\n   */\n  public final void setMissing(Attribute att) {\n\n    setMissing(att.index());\n  }\n\n  /**\n   * Sets a specific value in the instance to the given value \n   * (internal floating-point format). Performs a deep copy\n   * of the vector of attribute values before the value is set.\n   *\n   * @param attIndex the attribute's index \n   * @param value the new attribute value (If the corresponding\n   * attribute is nominal (or a string) then this is the new value's\n   * index as a double).  \n   */\n  public void setValue(int attIndex, double value) {\n    \n    freshAttributeVector();\n    m_AttValues[attIndex] = value;\n  }\n\n  /**\n   * Sets a specific value in the instance to the given value \n   * (internal floating-point format). Performs a deep copy\n   * of the vector of attribute values before the value is set.\n   * Does exactly the same thing as setValue().\n   *\n   * @param indexOfIndex the index of the attribute's index \n   * @param value the new attribute value (If the corresponding\n   * attribute is nominal (or a string) then this is the new value's\n   * index as a double).  \n   */\n  public void setValueSparse(int indexOfIndex, double value) {\n    \n    freshAttributeVector();\n    m_AttValues[indexOfIndex] = value;\n  }\n\n  /**\n   * Sets a value of a nominal or string attribute to the given\n   * value. Performs a deep copy of the vector of attribute values\n   * before the value is set.\n   *\n   * @param attIndex the attribute's index\n   * @param value the new attribute value (If the attribute\n   * is a string attribute and the value can't be found,\n   * the value is added to the attribute).\n   * @exception UnassignedDatasetException if the dataset is not set\n   * @exception IllegalArgumentException if the selected\n   * attribute is not nominal or a string, or the supplied value couldn't \n   * be found for a nominal attribute \n   */\n  //@ requires m_Dataset != null;\n  public final void setValue(int attIndex, String value) {\n    \n    int valIndex;\n\n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    if (!attribute(attIndex).isNominal() \u0026\u0026\n\t!attribute(attIndex).isString()) {\n      throw new IllegalArgumentException(\"Attribute neither nominal nor string!\");\n    }\n    valIndex = attribute(attIndex).indexOfValue(value);\n    if (valIndex == -1) {\n      if (attribute(attIndex).isNominal()) {\n\tthrow new IllegalArgumentException(\"Value not defined for given nominal attribute!\");\n      } else {\n\tattribute(attIndex).forceAddValue(value);\n\tvalIndex = attribute(attIndex).indexOfValue(value);\n      }\n    }\n    setValue(attIndex, (double)valIndex); \n  }\n\n  /**\n   * Sets a specific value in the instance to the given value\n   * (internal floating-point format). Performs a deep copy of the\n   * vector of attribute values before the value is set, so if you are\n   * planning on calling setValue many times it may be faster to\n   * create a new instance using toDoubleArray.  The given attribute\n   * has to belong to a dataset.\n   *\n   * @param att the attribute \n   * @param value the new attribute value (If the corresponding\n   * attribute is nominal (or a string) then this is the new value's\n   * index as a double).  \n   */\n  public final void setValue(Attribute att, double value) {\n\n    setValue(att.index(), value);\n  }\n\n  /**\n   * Sets a value of an nominal or string attribute to the given\n   * value. Performs a deep copy of the vector of attribute values\n   * before the value is set, so if you are planning on calling setValue many\n   * times it may be faster to create a new instance using toDoubleArray.\n   * The given attribute has to belong to a dataset.\n   *\n   * @param att the attribute\n   * @param value the new attribute value (If the attribute\n   * is a string attribute and the value can't be found,\n   * the value is added to the attribute).\n   * @exception IllegalArgumentException if the the attribute is not\n   * nominal or a string, or the value couldn't be found for a nominal\n   * attribute \n   */\n  public final void setValue(Attribute att, String value) {\n\n    if (!att.isNominal() \u0026\u0026\n\t!att.isString()) {\n      throw new IllegalArgumentException(\"Attribute neither nominal nor string!\");\n    }\n    int valIndex = att.indexOfValue(value);\n    if (valIndex == -1) {\n      if (att.isNominal()) {\n\tthrow new IllegalArgumentException(\"Value not defined for given nominal attribute!\");\n      } else {\n\tatt.forceAddValue(value);\n\tvalIndex = att.indexOfValue(value);\n      }\n    }\n    setValue(att.index(), (double)valIndex);\n  }\n\n  /**\n   * Sets the weight of an instance.\n   *\n   * @param weight the weight\n   */\n  public final void setWeight(double weight) {\n\n    m_Weight = weight;\n  }\n\n  /** \n   * Returns the string value of a nominal, string, or date attribute\n   * for the instance.\n   *\n   * @param attIndex the attribute's index\n   * @return the value as a string\n   * @exception IllegalArgumentException if the attribute is not a nominal,\n   * string, or date attribute.\n   * @exception UnassignedDatasetException if the instance doesn't belong\n   * to a dataset.\n   */\n  //@ requires m_Dataset != null;\n  public final /*@pure@*/ String stringValue(int attIndex) {\n\n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    } \n    return stringValue(m_Dataset.attribute(attIndex));\n  }\n\n  /** \n   * Returns the string value of a nominal, string, or date attribute\n   * for the instance.\n   *\n   * @param att the attribute\n   * @return the value as a string\n   * @exception IllegalArgumentException if the attribute is not a nominal,\n   * string, or date attribute.\n   * @exception UnassignedDatasetException if the instance doesn't belong\n   * to a dataset.\n   */\n  public final /*@pure@*/ String stringValue(Attribute att) {\n\n    int attIndex = att.index();\n    switch (att.type()) {\n    case Attribute.NOMINAL:\n    case Attribute.STRING:\n      return att.value((int) value(attIndex));\n    case Attribute.DATE:\n      return att.formatDate(value(attIndex));\n    default:\n      throw new IllegalArgumentException(\"Attribute isn't nominal, string or date!\");\n    }\n  }\n\n  /**\n   * Returns the values of each attribute as an array of doubles.\n   *\n   * @return an array containing all the instance attribute values\n   */\n  public double[] toDoubleArray() {\n\n    double[] newValues = new double[m_AttValues.length];\n    System.arraycopy(m_AttValues, 0, newValues, 0, \n\t\t     m_AttValues.length);\n    return newValues;\n  }\n\n  /**\n   * Returns the description of one instance. If the instance\n   * doesn't have access to a dataset, it returns the internal\n   * floating-point values. Quotes string\n   * values that contain whitespace characters.\n   *\n   * @return the instance's description as a string\n   */\n  public String toString() {\n\n    StringBuffer text = new StringBuffer();\n    \n    for (int i = 0; i \u003c m_AttValues.length; i++) {\n      if (i \u003e 0) text.append(\",\");\n      text.append(toString(i));\n    }\n\n    return text.toString();\n  }\n\n  /**\n   * Returns the description of one value of the instance as a \n   * string. If the instance doesn't have access to a dataset, it \n   * returns the internal floating-point value. Quotes string\n   * values that contain whitespace characters, or if they\n   * are a question mark.\n   *\n   * @param attIndex the attribute's index\n   * @return the value's description as a string\n   */\n  public final /*@pure@*/ String toString(int attIndex) {\n\n   StringBuffer text = new StringBuffer();\n   \n   if (isMissing(attIndex)) {\n     text.append(\"?\");\n   } else {\n     if (m_Dataset == null) {\n       text.append(Utils.doubleToString(m_AttValues[attIndex],6));\n     } else {\n       switch (m_Dataset.attribute(attIndex).type()) {\n       case Attribute.NOMINAL:\n       case Attribute.STRING:\n       case Attribute.DATE:\n         text.append(Utils.quote(stringValue(attIndex)));\n         break;\n       case Attribute.NUMERIC:\n\t text.append(Utils.doubleToString(value(attIndex),6));\n         break;\n       default:\n         throw new IllegalStateException(\"Unknown attribute type\");\n       }\n     }\n   }\n   return text.toString();\n  }\n\n  /**\n   * Returns the description of one value of the instance as a \n   * string. If the instance doesn't have access to a dataset it \n   * returns the internal floating-point value. Quotes string\n   * values that contain whitespace characters, or if they\n   * are a question mark.\n   * The given attribute has to belong to a dataset.\n   *\n   * @param att the attribute\n   * @return the value's description as a string\n   */\n  public final String toString(Attribute att) {\n   \n   return toString(att.index());\n  }\n\n  /**\n   * Returns an instance's attribute value in internal format.\n   *\n   * @param attIndex the attribute's index\n   * @return the specified value as a double (If the corresponding\n   * attribute is nominal (or a string) then it returns the value's index as a \n   * double).\n   */\n  public /*@pure@*/ double value(int attIndex) {\n\n    return m_AttValues[attIndex];\n  }\n\n  /**\n   * Returns an instance's attribute value in internal format.\n   * Does exactly the same thing as value() if applied to an Instance.\n   *\n   * @param indexOfIndex the index of the attribute's index\n   * @return the specified value as a double (If the corresponding\n   * attribute is nominal (or a string) then it returns the value's index as a \n   * double).\n   */\n  public /*@pure@*/ double valueSparse(int indexOfIndex) {\n\n    return m_AttValues[indexOfIndex];\n  }  \n\n  /**\n   * Returns an instance's attribute value in internal format.\n   * The given attribute has to belong to a dataset.\n   *\n   * @param att the attribute\n   * @return the specified value as a double (If the corresponding\n   * attribute is nominal (or a string) then it returns the value's index as a\n   * double).\n   */\n  public /*@pure@*/ double value(Attribute att) {\n\n    return value(att.index());\n  }\n\n  /**\n   * Returns the instance's weight.\n   *\n   * @return the instance's weight as a double\n   */\n  public final /*@pure@*/ double weight() {\n\n    return m_Weight;\n  }\n\n  /**\n   * Deletes an attribute at the given position (0 to \n   * numAttributes() - 1).\n   *\n   * @param pos the attribute's position\n   */\n\n  void forceDeleteAttributeAt(int position) {\n\n    double[] newValues = new double[m_AttValues.length - 1];\n\n    System.arraycopy(m_AttValues, 0, newValues, 0, position);\n    if (position \u003c m_AttValues.length - 1) {\n      System.arraycopy(m_AttValues, position + 1, \n\t\t       newValues, position, \n\t\t       m_AttValues.length - (position + 1));\n    }\n    m_AttValues = newValues;\n  }\n\n  /**\n   * Inserts an attribute at the given position\n   * (0 to numAttributes()) and sets its value to be missing. \n   *\n   * @param pos the attribute's position\n   */\n  void forceInsertAttributeAt(int position)  {\n\n    double[] newValues = new double[m_AttValues.length + 1];\n\n    System.arraycopy(m_AttValues, 0, newValues, 0, position);\n    newValues[position] = MISSING_VALUE;\n    System.arraycopy(m_AttValues, position, newValues, \n\t\t     position + 1, m_AttValues.length - position);\n    m_AttValues = newValues;\n  }\n\n  /**\n   * Private constructor for subclasses. Does nothing.\n   */\n  protected Instance() {\n  }\n\n  /**\n   * Clones the attribute vector of the instance and\n   * overwrites it with the clone.\n   */\n  private void freshAttributeVector() {\n\n    m_AttValues = toDoubleArray();\n  }\n\n  /**\n   * Main method for testing this class.\n   */\n  //@ requires options != null;\n  public static void main(String[] options) {\n\n    try {\n\n      // Create numeric attributes \"length\" and \"weight\"\n      Attribute length = new Attribute(\"length\");\n      Attribute weight = new Attribute(\"weight\");\n      \n      // Create vector to hold nominal values \"first\", \"second\", \"third\" \n      FastVector my_nominal_values = new FastVector(3); \n      my_nominal_values.addElement(\"first\"); \n      my_nominal_values.addElement(\"second\"); \n      my_nominal_values.addElement(\"third\"); \n      \n      // Create nominal attribute \"position\" \n      Attribute position = new Attribute(\"position\", my_nominal_values);\n      \n      // Create vector of the above attributes \n      FastVector attributes = new FastVector(3);\n      attributes.addElement(length);\n      attributes.addElement(weight);\n      attributes.addElement(position);\n      \n      // Create the empty dataset \"race\" with above attributes\n      Instances race = new Instances(\"race\", attributes, 0);\n      \n      // Make position the class attribute\n      race.setClassIndex(position.index());\n      \n      // Create empty instance with three attribute values\n      Instance inst = new Instance(3);\n      \n      // Set instance's values for the attributes \"length\", \"weight\", and \"position\"\n      inst.setValue(length, 5.3);\n      inst.setValue(weight, 300);\n      inst.setValue(position, \"first\");\n      \n      // Set instance's dataset to be the dataset \"race\"\n      inst.setDataset(race);\n      \n      // Print the instance\n      System.out.println(\"The instance: \" + inst);\n      \n      // Print the first attribute\n      System.out.println(\"First attribute: \" + inst.attribute(0));\n      \n      // Print the class attribute\n      System.out.println(\"Class attribute: \" + inst.classAttribute());\n      \n      // Print the class index\n      System.out.println(\"Class index: \" + inst.classIndex());\n      \n      // Say if class is missing\n      System.out.println(\"Class is missing: \" + inst.classIsMissing());\n      \n      // Print the instance's class value in internal format\n      System.out.println(\"Class value (internal format): \" + inst.classValue());\n      \n      // Print a shallow copy of this instance\n      Instance copy = (Instance) inst.copy();\n      System.out.println(\"Shallow copy: \" + copy);\n      \n      // Set dataset for shallow copy\n      copy.setDataset(inst.dataset());\n      System.out.println(\"Shallow copy with dataset set: \" + copy);\n      \n      // Unset dataset for copy, delete first attribute, and insert it again\n      copy.setDataset(null);\n      copy.deleteAttributeAt(0);\n      copy.insertAttributeAt(0);\n      copy.setDataset(inst.dataset());\n      System.out.println(\"Copy with first attribute deleted and inserted: \" + copy); \n      \n      // Enumerate attributes (leaving out the class attribute)\n      System.out.println(\"Enumerating attributes (leaving out class):\");\n      Enumeration enu = inst.enumerateAttributes();\n      while (enu.hasMoreElements()) {\n\tAttribute att = (Attribute) enu.nextElement();\n\tSystem.out.println(att);\n      }\n      \n      // Headers are equivalent?\n      System.out.println(\"Header of original and copy equivalent: \" +\n\t\t\t inst.equalHeaders(copy));\n\n      // Test for missing values\n      System.out.println(\"Length of copy missing: \" + copy.isMissing(length));\n      System.out.println(\"Weight of copy missing: \" + copy.isMissing(weight.index()));\n      System.out.println(\"Length of copy missing: \" + \n\t\t\t Instance.isMissingValue(copy.value(length)));\n      System.out.println(\"Missing value coded as: \" + Instance.missingValue());\n\n      // Prints number of attributes and classes\n      System.out.println(\"Number of attributes: \" + copy.numAttributes());\n      System.out.println(\"Number of classes: \" + copy.numClasses());\n\n      // Replace missing values\n      double[] meansAndModes = {2, 3, 0};\n      copy.replaceMissingValues(meansAndModes);\n      System.out.println(\"Copy with missing value replaced: \" + copy);\n\n      // Setting and getting values and weights\n      copy.setClassMissing();\n      System.out.println(\"Copy with missing class: \" + copy);\n      copy.setClassValue(0);\n      System.out.println(\"Copy with class value set to first value: \" + copy);\n      copy.setClassValue(\"third\");\n      System.out.println(\"Copy with class value set to \\\"third\\\": \" + copy);\n      copy.setMissing(1);\n      System.out.println(\"Copy with second attribute set to be missing: \" + copy);\n      copy.setMissing(length);\n      System.out.println(\"Copy with length set to be missing: \" + copy);\n      copy.setValue(0, 0);\n      System.out.println(\"Copy with first attribute set to 0: \" + copy);\n      copy.setValue(weight, 1);\n      System.out.println(\"Copy with weight attribute set to 1: \" + copy);\n      copy.setValue(position, \"second\");\n      System.out.println(\"Copy with position set to \\\"second\\\": \" + copy);\n      copy.setValue(2, \"first\");\n      System.out.println(\"Copy with last attribute set to \\\"first\\\": \" + copy);\n      System.out.println(\"Current weight of instance copy: \" + copy.weight());\n      copy.setWeight(2);\n      System.out.println(\"Current weight of instance copy (set to 2): \" + copy.weight());\n      System.out.println(\"Last value of copy: \" + copy.toString(2));\n      System.out.println(\"Value of position for copy: \" + copy.toString(position));\n      System.out.println(\"Last value of copy (internal format): \" + copy.value(2));\n      System.out.println(\"Value of position for copy (internal format): \" + \n\t\t\t copy.value(position));\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n",
        "name": "Instance.java",
        "path": "subjectSystems/C,D/core/Instance.java",
        "url": "/github.com/LASER-UMASS/Themis/-/blob/subjectSystems/C,D/core/Instance.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 93,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Dataset == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 109,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Dataset == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 124,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires numAttributes \u003e 0;    // Or maybe == 0 is okay too?"
        },
        {
          "limitHit": false,
          "lineNumber": 125,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Dataset == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 144,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 162,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 178,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 193,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 210,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 229,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 263,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Dataset;"
        },
        {
          "limitHit": false,
          "lineNumber": 279,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 295,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 313,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 328,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 367,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 368,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= position \u0026\u0026 position \u003c= numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 466,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_AttValues.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 480,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 494,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_AttValues.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 532,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 553,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 576,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 669,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 765,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 991,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires options != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 194,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  \\result == m_Dataset.classIndex();"
        }
      ],
      "repository": {
        "name": "github.com/LASER-UMASS/Themis",
        "url": "/github.com/LASER-UMASS/Themis"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a70f12a6a8f34cdd8b170b4dc59a78674c9e8950"
        },
        "content": "/*\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; either version 2 of the License, or\n *    (at your option) any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n/*\n *    Instances.java\n *    Copyright (C) 1999 Eibe Frank\n *\n */\n\npackage weka.core;\n\nimport java.io.*;\nimport java.text.ParseException;\nimport java.util.*;\n\n\n/**\n * Class for handling an ordered set of weighted instances. \u003cp\u003e\n *\n * Typical usage (code from the main() method of this class): \u003cp\u003e\n *\n * \u003ccode\u003e\n * ... \u003cbr\u003e\n * \n * // Read all the instances in the file \u003cbr\u003e\n * reader = new FileReader(filename); \u003cbr\u003e\n * instances = new Instances(reader); \u003cbr\u003e\u003cbr\u003e\n *\n * // Make the last attribute be the class \u003cbr\u003e\n * instances.setClassIndex(instances.numAttributes() - 1); \u003cbr\u003e\u003cbr\u003e\n * \n * // Print header and instances. \u003cbr\u003e\n * System.out.println(\"\\nDataset:\\n\"); \u003cbr\u003e \n * System.out.println(instances); \u003cbr\u003e\u003cbr\u003e\n *\n * ... \u003cbr\u003e\n * \u003c/code\u003e\u003cp\u003e\n *\n * All methods that change a set of instances are safe, ie. a change\n * of a set of instances does not affect any other sets of\n * instances. All methods that change a datasets's attribute\n * information clone the dataset before it is changed.\n *\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\n * @author Len Trigg (trigg@cs.waikato.ac.nz)\n * @version $Revision: 1.58.2.6 $ \n */\npublic class Instances implements Serializable {\n \n  /** The filename extension that should be used for arff files */\n  public static String FILE_EXTENSION = \".arff\";\n\n  /** The filename extension that should be used for bin. serialized instances files */\n  public static String SERIALIZED_OBJ_FILE_EXTENSION = \".bsi\";\n\n  /** The keyword used to denote the start of an arff header */\n  static String ARFF_RELATION = \"@relation\";\n\n  /** The keyword used to denote the start of the arff data section */\n  static String ARFF_DATA = \"@data\";\n\n  /** The dataset's name. */\n  protected /*@spec_public non_null@*/ String m_RelationName;         \n\n  /** The attribute information. */\n  protected /*@spec_public non_null@*/ FastVector m_Attributes;\n  /*  public invariant (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c m_Attributes.size(); \n                    m_Attributes.elementAt(i) != null);\n  */\n\n  /** The instances. */\n  protected /*@spec_public non_null@*/ FastVector m_Instances;\n\n  /** The class attribute's index */\n  protected int m_ClassIndex;\n  //@ protected invariant classIndex() == m_ClassIndex;\n\n  /** Buffer of values for sparse instance */\n  protected double[] m_ValueBuffer;\n\n  /** Buffer of indices for sparse instance */\n  protected int[] m_IndicesBuffer;\n\n   \n  /**\n   * Reads an ARFF file from a reader, and assigns a weight of\n   * one to each instance. Lets the index of the class \n   * attribute be undefined (negative).\n   *\n   * @param reader the reader\n   * @exception IOException if the ARFF file is not read \n   * successfully\n   */\n  public Instances(/*@non_null@*/Reader reader) throws IOException {\n\n    StreamTokenizer tokenizer;\n\n    tokenizer = new StreamTokenizer(reader);\n    initTokenizer(tokenizer);\n    readHeader(tokenizer);\n    m_ClassIndex = -1;\n    m_Instances = new FastVector(1000);\n    while (getInstance(tokenizer, true)) {};\n    compactify();\n  }\n\n   \n \n  /**\n   * Reads the header of an ARFF file from a reader and \n   * reserves space for the given number of instances. Lets\n   * the class index be undefined (negative).\n   *\n   * @param reader the reader\n   * @param capacity the capacity\n   * @exception IllegalArgumentException if the header is not read successfully\n   * or the capacity is negative.\n   * @exception IOException if there is a problem with the reader.\n   */\n  //@ requires capacity \u003e= 0;\n  //@ ensures classIndex() == -1;\n  public Instances(/*@non_null@*/Reader reader, int capacity)\n    throws IOException {\n\n    StreamTokenizer tokenizer;\n\n    if (capacity \u003c 0) {\n      throw new IllegalArgumentException(\"Capacity has to be positive!\");\n    }\n    tokenizer = new StreamTokenizer(reader); \n    initTokenizer(tokenizer);\n    readHeader(tokenizer);\n    m_ClassIndex = -1;\n    m_Instances = new FastVector(capacity);\n  }\n\n  /**\n   * Constructor copying all instances and references to\n   * the header information from the given set of instances.\n   *\n   * @param instances the set to be copied\n   */\n  public Instances(/*@non_null@*/Instances dataset) {\n\n    this(dataset, dataset.numInstances());\n\n    dataset.copyInstances(0, this, dataset.numInstances());\n  }\n\n  /**\n   * Constructor creating an empty set of instances. Copies references\n   * to the header information from the given set of instances. Sets\n   * the capacity of the set of instances to 0 if its negative.\n   *\n   * @param instances the instances from which the header \n   * information is to be taken\n   * @param capacity the capacity of the new dataset \n   */\n  public Instances(/*@non_null@*/Instances dataset, int capacity) {\n    \n    if (capacity \u003c 0) {\n      capacity = 0;\n    }\n    \n    // Strings only have to be \"shallow\" copied because\n    // they can't be modified.\n    m_ClassIndex = dataset.m_ClassIndex;\n    m_RelationName = dataset.m_RelationName;\n    m_Attributes = dataset.m_Attributes;\n    m_Instances = new FastVector(capacity);\n  }\n\n  /**\n   * Creates a new set of instances by copying a \n   * subset of another set.\n   *\n   * @param source the set of instances from which a subset \n   * is to be created\n   * @param first the index of the first instance to be copied\n   * @param toCopy the number of instances to be copied\n   * @exception IllegalArgumentException if first and toCopy are out of range\n   */\n  //@ requires 0 \u003c= first;\n  //@ requires 0 \u003c= toCopy;\n  //@ requires first + toCopy \u003c= source.numInstances();\n  public Instances(/*@non_null@*/Instances source, int first, int toCopy) {\n    \n    this(source, toCopy);\n\n    if ((first \u003c 0) || ((first + toCopy) \u003e source.numInstances())) {\n      throw new IllegalArgumentException(\"Parameters first and/or toCopy out \"+\n                                         \"of range\");\n    }\n    source.copyInstances(first, this, toCopy);\n  }\n\n  /**\n   * Creates an empty set of instances. Uses the given\n   * attribute information. Sets the capacity of the set of \n   * instances to 0 if its negative. Given attribute information\n   * must not be changed after this constructor has been used.\n   *\n   * @param name the name of the relation\n   * @param attInfo the attribute information\n   * @param capacity the capacity of the set\n   */\n  public Instances(/*@non_null@*/String name, \n\t\t   /*@non_null@*/FastVector attInfo, int capacity) {\n\n    m_RelationName = name;\n    m_ClassIndex = -1;\n    m_Attributes = attInfo;\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      attribute(i).setIndex(i);\n    }\n    m_Instances = new FastVector(capacity);\n  }\n \n  /**\n   * Create a copy of the structure, but \"cleanse\" string types (i.e.\n   * doesn't contain references to the strings seen in the past).\n   *\n   * @return a copy of the instance structure.\n   */\n  public Instances stringFreeStructure() {\n\n    FastVector atts = (FastVector)m_Attributes.copy();\n    for (int i = 0 ; i \u003c atts.size(); i++) {\n      Attribute att = (Attribute)atts.elementAt(i);\n      if (att.type() == Attribute.STRING) {\n        atts.setElementAt(new Attribute(att.name(), (FastVector)null), i);\n      }\n    }\n    Instances result = new Instances(relationName(), atts, 0);\n    result.m_ClassIndex = m_ClassIndex;\n    return result;\n  }\n\n  /**\n   * Adds one instance to the end of the set. \n   * Shallow copies instance before it is added. Increases the\n   * size of the dataset if it is not large enough. Does not\n   * check if the instance is compatible with the dataset.\n   * Note: String values are not transferred.\n   *\n   * @param instance the instance to be added\n   */\n  public void add(/*@non_null@*/ Instance instance) {\n\n    Instance newInstance = (Instance)instance.copy();\n\n    newInstance.setDataset(this);\n    m_Instances.addElement(newInstance);\n  }\n\n  /**\n   * Returns an attribute.\n   *\n   * @param index the attribute's index\n   * @return the attribute at the given position\n   */\n  //@ requires 0 \u003c= index;\n  //@ requires index \u003c m_Attributes.size();\n  //@ ensures \\result != null;\n  public /*@pure@*/ Attribute attribute(int index) {\n    \n    return (Attribute) m_Attributes.elementAt(index);\n  }\n\n  /**\n   * Returns an attribute given its name. If there is more than\n   * one attribute with the same name, it returns the first one.\n   * Returns null if the attribute can't be found.\n   *\n   * @param name the attribute's name\n   * @return the attribute with the given name, null if the\n   * attribute can't be found\n   */ \n  public /*@pure@*/ Attribute attribute(String name) {\n    \n    for (int i = 0; i \u003c numAttributes(); i++) {\n      if (attribute(i).name().equals(name)) {\n\treturn attribute(i);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Checks for string attributes in the dataset\n   *\n   * @return true if string attributes are present, false otherwise\n   */\n  public /*@pure@*/ boolean checkForStringAttributes() {\n\n    int i = 0;\n   \n    while (i \u003c m_Attributes.size()) {\n      if (attribute(i++).isString()) {\n\treturn true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Checks if the given instance is compatible\n   * with this dataset. Only looks at the size of\n   * the instance and the ranges of the values for \n   * nominal and string attributes.\n   *\n   * @return true if the instance is compatible with the dataset \n   */\n  public /*@pure@*/ boolean checkInstance(Instance instance) {\n\n    if (instance.numAttributes() != numAttributes()) {\n      return false;\n    }\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      if (instance.isMissing(i)) {\n\tcontinue;\n      } else if (attribute(i).isNominal() ||\n\t\t attribute(i).isString()) {\n\tif (!(Utils.eq(instance.value(i),\n\t\t       (double)(int)instance.value(i)))) {\n\t  return false;\n\t} else if (Utils.sm(instance.value(i), 0) ||\n\t\t   Utils.gr(instance.value(i),\n\t\t\t    attribute(i).numValues())) {\n\t  return false;\n\t}\n      }\n    }\n    return true;\n  }\n\t\n  /**\n   * Returns the class attribute.\n   *\n   * @return the class attribute\n   * @exception UnassignedClassException if the class is not set\n   */\n  //@ requires classIndex() \u003e= 0;\n  public /*@pure@*/ Attribute classAttribute() {\n\n    if (m_ClassIndex \u003c 0) {\n      throw new UnassignedClassException(\"Class index is negative (not set)!\");\n    }\n    return attribute(m_ClassIndex);\n  }\n\n  /**\n   * Returns the class attribute's index. Returns negative number\n   * if it's undefined.\n   *\n   * @return the class index as an integer\n   */\n  // ensures \\result == m_ClassIndex;\n  public /*@pure@*/ int classIndex() {\n    \n    return m_ClassIndex;\n  }\n \n  /**\n   * Compactifies the set of instances. Decreases the capacity of\n   * the set so that it matches the number of instances in the set.\n   */\n  public void compactify() {\n\n    m_Instances.trimToSize();\n  }\n\n  /**\n   * Removes all instances from the set.\n   */\n  public void delete() {\n    \n    m_Instances = new FastVector();\n  }\n\n  /**\n   * Removes an instance at the given position from the set.\n   *\n   * @param index the instance's position\n   */\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numInstances();\n  public void delete(int index) {\n    \n    m_Instances.removeElementAt(index);\n  }\n\n  /**\n   * Deletes an attribute at the given position \n   * (0 to numAttributes() - 1). A deep copy of the attribute\n   * information is performed before the attribute is deleted.\n   *\n   * @param pos the attribute's position\n   * @exception IllegalArgumentException if the given index is out of range \n   *            or the class attribute is being deleted\n   */\n  //@ requires 0 \u003c= position \u0026\u0026 position \u003c numAttributes();\n  //@ requires position != classIndex();\n  public void deleteAttributeAt(int position) {\n\t \n    if ((position \u003c 0) || (position \u003e= m_Attributes.size())) {\n      throw new IllegalArgumentException(\"Index out of range\");\n    }\n    if (position == m_ClassIndex) {\n      throw new IllegalArgumentException(\"Can't delete class attribute\");\n    }\n    freshAttributeInfo();\n    if (m_ClassIndex \u003e position) {\n      m_ClassIndex--;\n    }\n    m_Attributes.removeElementAt(position);\n    for (int i = position; i \u003c m_Attributes.size(); i++) {\n      Attribute current = (Attribute)m_Attributes.elementAt(i);\n      current.setIndex(current.index() - 1);\n    }\n    for (int i = 0; i \u003c numInstances(); i++) {\n      instance(i).forceDeleteAttributeAt(position); \n    }\n  }\n\n  /**\n   * Deletes all string attributes in the dataset. A deep copy of the attribute\n   * information is performed before an attribute is deleted.\n   *\n   * @exception IllegalArgumentException if string attribute couldn't be \n   * successfully deleted (probably because it is the class attribute).\n   */\n  public void deleteStringAttributes() {\n\n    int i = 0;\n    while (i \u003c m_Attributes.size()) {\n      if (attribute(i).isString()) {\n\tdeleteAttributeAt(i);\n      } else {\n\ti++;\n      }\n    }\n  }\n\n  /**\n   * Removes all instances with missing values for a particular\n   * attribute from the dataset.\n   *\n   * @param attIndex the attribute's index\n   */\n  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\n  public void deleteWithMissing(int attIndex) {\n\n    FastVector newInstances = new FastVector(numInstances());\n\n    for (int i = 0; i \u003c numInstances(); i++) {\n      if (!instance(i).isMissing(attIndex)) {\n\tnewInstances.addElement(instance(i));\n      }\n    }\n    m_Instances = newInstances;\n  }\n\n  /**\n   * Removes all instances with missing values for a particular\n   * attribute from the dataset.\n   *\n   * @param att the attribute\n   */\n  public void deleteWithMissing(/*@non_null@*/ Attribute att) {\n\n    deleteWithMissing(att.index());\n  }\n\n  /**\n   * Removes all instances with a missing class value\n   * from the dataset.\n   *\n   * @exception UnassignedClassException if class is not set\n   */\n  public void deleteWithMissingClass() {\n\n    if (m_ClassIndex \u003c 0) {\n      throw new UnassignedClassException(\"Class index is negative (not set)!\");\n    }\n    deleteWithMissing(m_ClassIndex);\n  }\n\n  /**\n   * Returns an enumeration of all the attributes.\n   *\n   * @return enumeration of all the attributes.\n   */\n  public /*@non_null pure@*/ Enumeration enumerateAttributes() {\n\n    return m_Attributes.elements(m_ClassIndex);\n  }\n\n  /**\n   * Returns an enumeration of all instances in the dataset.\n   *\n   * @return enumeration of all instances in the dataset\n   */\n  public /*@non_null pure@*/ Enumeration enumerateInstances() {\n\n    return m_Instances.elements();\n  }\n\n  /**\n   * Checks if two headers are equivalent.\n   *\n   * @param dataset another dataset\n   * @return true if the header of the given dataset is equivalent \n   * to this header\n   */\n  public /*@pure@*/ boolean equalHeaders(Instances dataset){\n\n    // Check class and all attributes\n    if (m_ClassIndex != dataset.m_ClassIndex) {\n      return false;\n    }\n    if (m_Attributes.size() != dataset.m_Attributes.size()) {\n      return false;\n    }\n    for (int i = 0; i \u003c m_Attributes.size(); i++) {\n      if (!(attribute(i).equals(dataset.attribute(i)))) {\n\treturn false;\n      }\n    }\n    return true;\n  }\n \n  /**\n   * Returns the first instance in the set.\n   *\n   * @return the first instance in the set\n   */\n  //@ requires numInstances() \u003e 0;\n  public /*@non_null pure@*/ Instance firstInstance() {\n    \n    return (Instance)m_Instances.firstElement();\n  }\n\n  /**\n   * Returns a random number generator. The initial seed of the random\n   * number generator depends on the given seed and the hash code of\n   * a string representation of a instances chosen based on the given\n   * seed. \n   *\n   * @param seed the given seed\n   * @return the random number generator\n   */\n  public Random getRandomNumberGenerator(long seed) {\n\n    Random r = new Random(seed);\n    r.setSeed(instance(r.nextInt(numInstances())).toString().hashCode() + seed);\n    return r;\n  }\n \n  /**\n   * Inserts an attribute at the given position (0 to \n   * numAttributes()) and sets all values to be missing.\n   * Shallow copies the attribute before it is inserted, and performs\n   * a deep copy of the existing attribute information.\n   *\n   * @param att the attribute to be inserted\n   * @param pos the attribute's position\n   * @exception IllegalArgumentException if the given index is out of range\n   */\n  //@ requires 0 \u003c= position;\n  //@ requires position \u003c= numAttributes();\n  public void insertAttributeAt(/*@non_null@*/ Attribute att, int position) {\n\t \n    if ((position \u003c 0) ||\n\t(position \u003e m_Attributes.size())) {\n      throw new IllegalArgumentException(\"Index out of range\");\n    }\n    att = (Attribute)att.copy();\n    freshAttributeInfo();\n    att.setIndex(position);\n    m_Attributes.insertElementAt(att, position);\n    for (int i = position + 1; i \u003c m_Attributes.size(); i++) {\n      Attribute current = (Attribute)m_Attributes.elementAt(i);\n      current.setIndex(current.index() + 1);\n    }\n    for (int i = 0; i \u003c numInstances(); i++) {\n      instance(i).forceInsertAttributeAt(position);\n    }\n    if (m_ClassIndex \u003e= position) {\n      m_ClassIndex++;\n    }\n  }\n\n  /**\n   * Returns the instance at the given position.\n   *\n   * @param index the instance's index\n   * @return the instance at the given position\n   */\n  //@ requires 0 \u003c= index;\n  //@ requires index \u003c numInstances();\n  public /*@non_null pure@*/ Instance instance(int index) {\n\n    return (Instance)m_Instances.elementAt(index);\n  }\n\n  /**\n   * Returns the kth-smallest attribute value of a numeric attribute.\n   * Note that calling this method will change the order of the data!\n   *\n   * @param att the Attribute object\n   * @param k the value of k\n   * @return the kth-smallest value\n   */\n  public double kthSmallestValue(Attribute att, int k) {\n\n    return kthSmallestValue(att.index(), k);\n  }\n\n  /**\n   * Returns the kth-smallest attribute value of a numeric attribute.\n   * Note that calling this method will change the order of the data!\n   * The number of non-missing values in the data must be as least\n   * as last as k for this to work.\n   *\n   * @param attIndex the attribute's index\n   * @param k the value of k\n   * @return the kth-smallest value\n   */\n  public double kthSmallestValue(int attIndex, int k) {\n    \n    if (!attribute(attIndex).isNumeric()) {\n      throw new IllegalArgumentException(\"Instances: attribute must be numeric to compute kth-smallest value.\");\n    }\n\n    int i,j;\n\n    // move all instances with missing values to end\n    j = numInstances() - 1;\n    i = 0;\n    while (i \u003c= j) {\n      if (instance(j).isMissing(attIndex)) {\n\tj--;\n      } else {\n\tif (instance(i).isMissing(attIndex)) {\n\t  swap(i,j);\n\t  j--;\n\t}\n\ti++;\n      }\n    }\n\n    if ((k \u003c 1) || (k \u003e j+1)) {\n      throw new IllegalArgumentException(\"Instances: value for k for computing kth-smallest value too large.\");\n    }\n\n    return instance(select(attIndex, 0, j, k)).value(attIndex);\n  }\n\n  /**\n   * Returns the last instance in the set.\n   *\n   * @return the last instance in the set\n   */\n  //@ requires numInstances() \u003e 0;\n  public /*@non_null pure@*/ Instance lastInstance() {\n    \n    return (Instance)m_Instances.lastElement();\n  }\n\n  /**\n   * Returns the mean (mode) for a numeric (nominal) attribute as\n   * a floating-point value. Returns 0 if the attribute is neither nominal nor \n   * numeric. If all values are missing it returns zero.\n   *\n   * @param attIndex the attribute's index\n   * @return the mean or the mode\n   */\n  public /*@pure@*/ double meanOrMode(int attIndex) {\n\n    double result, found;\n    int [] counts;\n\n    if (attribute(attIndex).isNumeric()) {\n      result = found = 0;\n      for (int j = 0; j \u003c numInstances(); j++) {\n\tif (!instance(j).isMissing(attIndex)) {\n\t  found += instance(j).weight();\n\t  result += instance(j).weight()*instance(j).value(attIndex);\n\t}\n      }\n      if (found \u003c= 0) {\n\treturn 0;\n      } else {\n\treturn result / found;\n      }\n    } else if (attribute(attIndex).isNominal()) {\n      counts = new int[attribute(attIndex).numValues()];\n      for (int j = 0; j \u003c numInstances(); j++) {\n\tif (!instance(j).isMissing(attIndex)) {\n\t  counts[(int) instance(j).value(attIndex)] += instance(j).weight();\n\t}\n      }\n      return (double)Utils.maxIndex(counts);\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n   * Returns the mean (mode) for a numeric (nominal) attribute as a\n   * floating-point value.  Returns 0 if the attribute is neither\n   * nominal nor numeric.  If all values are missing it returns zero.\n   *\n   * @param att the attribute\n   * @return the mean or the mode \n   */\n  public /*@pure@*/ double meanOrMode(Attribute att) {\n\n    return meanOrMode(att.index());\n  }\n\n  /**\n   * Returns the number of attributes.\n   *\n   * @return the number of attributes as an integer\n   */\n  //@ ensures \\result == m_Attributes.size();\n  public /*@pure@*/ int numAttributes() {\n\n    return m_Attributes.size();\n  }\n\n  /**\n   * Returns the number of class labels.\n   *\n   * @return the number of class labels as an integer if the class \n   * attribute is nominal, 1 otherwise.\n   * @exception UnassignedClassException if the class is not set\n   */\n  //@ requires classIndex() \u003e= 0;\n  public /*@pure@*/ int numClasses() {\n    \n    if (m_ClassIndex \u003c 0) {\n      throw new UnassignedClassException(\"Class index is negative (not set)!\");\n    }\n    if (!classAttribute().isNominal()) {\n      return 1;\n    } else {\n      return classAttribute().numValues();\n    }\n  }\n\n  /**\n   * Returns the number of distinct values of a given attribute.\n   * Returns the number of instances if the attribute is a\n   * string attribute. The value 'missing' is not counted.\n   *\n   * @param attIndex the attribute\n   * @return the number of distinct values of a given attribute\n   */\n  //@ requires 0 \u003c= attIndex;\n  //@ requires attIndex \u003c numAttributes();\n  public /*@pure@*/ int numDistinctValues(int attIndex) {\n\n    if (attribute(attIndex).isNumeric()) {\n      double [] attVals = attributeToDoubleArray(attIndex);\n      int [] sorted = Utils.sort(attVals);\n      double prev = 0;\n      int counter = 0;\n      for (int i = 0; i \u003c sorted.length; i++) {\n\tInstance current = instance(sorted[i]);\n\tif (current.isMissing(attIndex)) {\n\t  break;\n\t}\n\tif ((i == 0) || \n\t    (current.value(attIndex) \u003e prev)) {\n\t  prev = current.value(attIndex);\n\t  counter++;\n\t}\n      }\n      return counter;\n    } else {\n      return attribute(attIndex).numValues();\n    }\n  }\n\n  /**\n   * Returns the number of distinct values of a given attribute.\n   * Returns the number of instances if the attribute is a\n   * string attribute. The value 'missing' is not counted.\n   *\n   * @param att the attribute\n   * @return the number of distinct values of a given attribute\n   */\n  public /*@pure@*/ int numDistinctValues(/*@non_null@*/Attribute att) {\n\n    return numDistinctValues(att.index());\n  }\n  \n  /**\n   * Returns the number of instances in the dataset.\n   *\n   * @return the number of instances in the dataset as an integer\n   */\n  //@ ensures \\result == m_Instances.size();\n  public /*@pure@*/ int numInstances() {\n\n    return m_Instances.size();\n  }\n\n  /**\n   * Shuffles the instances in the set so that they are ordered \n   * randomly.\n   *\n   * @param random a random number generator\n   */\n  public void randomize(Random random) {\n\n    for (int j = numInstances() - 1; j \u003e 0; j--)\n      swap(j, random.nextInt(j+1));\n  }\n\n  /**\n   * Reads a single instance from the reader and appends it\n   * to the dataset.  Automatically expands the dataset if it\n   * is not large enough to hold the instance. This method does\n   * not check for carriage return at the end of the line.\n   *\n   * @param reader the reader \n   * @return false if end of file has been reached\n   * @exception IOException if the information is not read \n   * successfully\n   */ \n  public boolean readInstance(Reader reader) \n       throws IOException {\n\n    StreamTokenizer tokenizer = new StreamTokenizer(reader);\n    \n    initTokenizer(tokenizer);\n    return getInstance(tokenizer, false);\n  }    \n\n  /**\n   * Returns the relation's name.\n   *\n   * @return the relation's name as a string\n   */\n  //@ ensures \\result == m_RelationName;\n  public /*@pure@*/ String relationName() {\n\n    return m_RelationName;\n  }\n\n  /**\n   * Renames an attribute. This change only affects this\n   * dataset.\n   *\n   * @param att the attribute's index\n   * @param name the new name\n   */\n  public void renameAttribute(int att, String name) {\n\n    Attribute newAtt = attribute(att).copy(name);\n    FastVector newVec = new FastVector(numAttributes());\n\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      if (i == att) {\n\tnewVec.addElement(newAtt);\n      } else {\n\tnewVec.addElement(attribute(i));\n      }\n    }\n    m_Attributes = newVec;\n  }\n\n  /**\n   * Renames an attribute. This change only affects this\n   * dataset.\n   *\n   * @param att the attribute\n   * @param name the new name\n   */\n  public void renameAttribute(Attribute att, String name) {\n\n    renameAttribute(att.index(), name);\n  }\n\n  /**\n   * Renames the value of a nominal (or string) attribute value. This\n   * change only affects this dataset.\n   *\n   * @param att the attribute's index\n   * @param val the value's index\n   * @param name the new name \n   */\n  public void renameAttributeValue(int att, int val, String name) {\n\n    Attribute newAtt = (Attribute)attribute(att).copy();\n    FastVector newVec = new FastVector(numAttributes());\n\n    newAtt.setValue(val, name);\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      if (i == att) {\n\tnewVec.addElement(newAtt);\n      } else {\n\tnewVec.addElement(attribute(i));\n      }\n    }\n    m_Attributes = newVec;\n  }\n\n  /**\n   * Renames the value of a nominal (or string) attribute value. This\n   * change only affects this dataset.\n   *\n   * @param att the attribute\n   * @param val the value\n   * @param name the new name\n   */\n  public void renameAttributeValue(Attribute att, String val, \n                                         String name) {\n\n    int v = att.indexOfValue(val);\n    if (v == -1) throw new IllegalArgumentException(val + \" not found\");\n    renameAttributeValue(att.index(), v, name);\n  }\n\n  /**\n   * Creates a new dataset of the same size using random sampling\n   * with replacement.\n   *\n   * @param random a random number generator\n   * @return the new dataset\n   */\n  public Instances resample(Random random) {\n\n    Instances newData = new Instances(this, numInstances());\n    while (newData.numInstances() \u003c numInstances()) {\n      newData.add(instance(random.nextInt(numInstances())));\n    }\n    return newData;\n  }\n\n  /**\n   * Creates a new dataset of the same size using random sampling\n   * with replacement according to the current instance weights. The\n   * weights of the instances in the new dataset are set to one.\n   *\n   * @param random a random number generator\n   * @return the new dataset\n   */\n  public Instances resampleWithWeights(Random random) {\n\n    double [] weights = new double[numInstances()];\n    for (int i = 0; i \u003c weights.length; i++) {\n      weights[i] = instance(i).weight();\n    }\n    return resampleWithWeights(random, weights);\n  }\n\n\n  /**\n   * Creates a new dataset of the same size using random sampling\n   * with replacement according to the given weight vector. The\n   * weights of the instances in the new dataset are set to one.\n   * The length of the weight vector has to be the same as the\n   * number of instances in the dataset, and all weights have to\n   * be positive.\n   *\n   * @param random a random number generator\n   * @param weights the weight vector\n   * @return the new dataset\n   * @exception IllegalArgumentException if the weights array is of the wrong\n   * length or contains negative weights.\n   */\n  public Instances resampleWithWeights(Random random, \n\t\t\t\t\t     double[] weights) {\n\n    if (weights.length != numInstances()) {\n      throw new IllegalArgumentException(\"weights.length != numInstances.\");\n    }\n    Instances newData = new Instances(this, numInstances());\n    if (numInstances() == 0) {\n      return newData;\n    }\n    double[] probabilities = new double[numInstances()];\n    double sumProbs = 0, sumOfWeights = Utils.sum(weights);\n    for (int i = 0; i \u003c numInstances(); i++) {\n      sumProbs += random.nextDouble();\n      probabilities[i] = sumProbs;\n    }\n    Utils.normalize(probabilities, sumProbs / sumOfWeights);\n\n    // Make sure that rounding errors don't mess things up\n    probabilities[numInstances() - 1] = sumOfWeights;\n    int k = 0; int l = 0;\n    sumProbs = 0;\n    while ((k \u003c numInstances() \u0026\u0026 (l \u003c numInstances()))) {\n      if (weights[l] \u003c 0) {\n\tthrow new IllegalArgumentException(\"Weights have to be positive.\");\n      }\n      sumProbs += weights[l];\n      while ((k \u003c numInstances()) \u0026\u0026\n\t     (probabilities[k] \u003c= sumProbs)) { \n\tnewData.add(instance(l));\n\tnewData.instance(k).setWeight(1);\n\tk++;\n      }\n      l++;\n    }\n    return newData;\n  }\n\n  /** \n   * Sets the class attribute.\n   *\n   * @param att attribute to be the class\n   */\n  public void setClass(Attribute att) {\n\n    m_ClassIndex = att.index();\n  }\n\n  /** \n   * Sets the class index of the set.\n   * If the class index is negative there is assumed to be no class.\n   * (ie. it is undefined)\n   *\n   * @param classIndex the new class index\n   * @exception IllegalArgumentException if the class index is too big or \u003c 0\n   */\n  public void setClassIndex(int classIndex) {\n\n    if (classIndex \u003e= numAttributes()) {\n      throw new IllegalArgumentException(\"Invalid class index: \" + classIndex);\n    }\n    m_ClassIndex = classIndex;\n  }\n\n  /**\n   * Sets the relation's name.\n   *\n   * @param newName the new relation name.\n   */\n  public void setRelationName(/*@non_null@*/String newName) {\n    \n    m_RelationName = newName;\n  }\n\n  /**\n   * Sorts the instances based on an attribute. For numeric attributes, \n   * instances are sorted in ascending order. For nominal attributes, \n   * instances are sorted based on the attribute label ordering \n   * specified in the header. Instances with missing values for the \n   * attribute are placed at the end of the dataset.\n   *\n   * @param attIndex the attribute's index\n   */\n  public void sort(int attIndex) {\n\n    int i,j;\n\n    // move all instances with missing values to end\n    j = numInstances() - 1;\n    i = 0;\n    while (i \u003c= j) {\n      if (instance(j).isMissing(attIndex)) {\n\tj--;\n      } else {\n\tif (instance(i).isMissing(attIndex)) {\n\t  swap(i,j);\n\t  j--;\n\t}\n\ti++;\n      }\n    }\n    quickSort(attIndex, 0, j);\n  }\n\n  /**\n   * Sorts the instances based on an attribute. For numeric attributes, \n   * instances are sorted into ascending order. For nominal attributes, \n   * instances are sorted based on the attribute label ordering \n   * specified in the header. Instances with missing values for the \n   * attribute are placed at the end of the dataset.\n   *\n   * @param att the attribute\n   */\n  public void sort(Attribute att) {\n\n    sort(att.index());\n  }\n\n  /**\n   * Stratifies a set of instances according to its class values \n   * if the class attribute is nominal (so that afterwards a \n   * stratified cross-validation can be performed).\n   *\n   * @param numFolds the number of folds in the cross-validation\n   * @exception UnassignedClassException if the class is not set\n   */\n  public void stratify(int numFolds) {\n    \n    if (numFolds \u003c= 0) {\n      throw new IllegalArgumentException(\"Number of folds must be greater than 1\");\n    }\n    if (m_ClassIndex \u003c 0) {\n      throw new UnassignedClassException(\"Class index is negative (not set)!\");\n    }\n    if (classAttribute().isNominal()) {\n\n      // sort by class\n      int index = 1;\n      while (index \u003c numInstances()) {\n\tInstance instance1 = instance(index - 1);\n\tfor (int j = index; j \u003c numInstances(); j++) {\n\t  Instance instance2 = instance(j);\n\t  if ((instance1.classValue() == instance2.classValue()) ||\n\t      (instance1.classIsMissing() \u0026\u0026 \n\t       instance2.classIsMissing())) {\n\t    swap(index,j);\n\t    index++;\n\t  }\n\t}\n\tindex++;\n      }\n      stratStep(numFolds);\n    }\n  }\n \n  /**\n   * Computes the sum of all the instances' weights.\n   *\n   * @return the sum of all the instances' weights as a double\n   */\n  public /*@pure@*/ double sumOfWeights() {\n    \n    double sum = 0;\n\n    for (int i = 0; i \u003c numInstances(); i++) {\n      sum += instance(i).weight();\n    }\n    return sum;\n  }\n\n  /**\n   * Creates the test set for one fold of a cross-validation on \n   * the dataset.\n   *\n   * @param numFolds the number of folds in the cross-validation. Must\n   * be greater than 1.\n   * @param numFold 0 for the first fold, 1 for the second, ...\n   * @return the test set as a set of weighted instances\n   * @exception IllegalArgumentException if the number of folds is less than 2\n   * or greater than the number of instances.\n   */\n  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\n  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\n  public Instances testCV(int numFolds, int numFold) {\n\n    int numInstForFold, first, offset;\n    Instances test;\n    \n    if (numFolds \u003c 2) {\n      throw new IllegalArgumentException(\"Number of folds must be at least 2!\");\n    }\n    if (numFolds \u003e numInstances()) {\n      throw new IllegalArgumentException(\"Can't have more folds than instances!\");\n    }\n    numInstForFold = numInstances() / numFolds;\n    if (numFold \u003c numInstances() % numFolds){\n      numInstForFold++;\n      offset = numFold;\n    }else\n      offset = numInstances() % numFolds;\n    test = new Instances(this, numInstForFold);\n    first = numFold * (numInstances() / numFolds) + offset;\n    copyInstances(first, test, numInstForFold);\n    return test;\n  }\n \n  /**\n   * Returns the dataset as a string in ARFF format. Strings\n   * are quoted if they contain whitespace characters, or if they\n   * are a question mark.\n   *\n   * @return the dataset in ARFF format as a string\n   */\n  public String toString() {\n    \n    StringBuffer text = new StringBuffer();\n    \n    text.append(ARFF_RELATION).append(\" \").\n      append(Utils.quote(m_RelationName)).append(\"\\n\\n\");\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      text.append(attribute(i)).append(\"\\n\");\n    }\n    text.append(\"\\n\").append(ARFF_DATA).append(\"\\n\");\n    for (int i = 0; i \u003c numInstances(); i++) {\n      text.append(instance(i));\n      if (i \u003c numInstances() - 1) {\n\ttext.append('\\n');\n      }\n    }\n    return text.toString();\n  }\n\n  /**\n   * Creates the training set for one fold of a cross-validation \n   * on the dataset. \n   *\n   * @param numFolds the number of folds in the cross-validation. Must\n   * be greater than 1.\n   * @param numFold 0 for the first fold, 1 for the second, ...\n   * @return the training set \n   * @exception IllegalArgumentException if the number of folds is less than 2\n   * or greater than the number of instances.\n   */\n  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\n  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\n  public Instances trainCV(int numFolds, int numFold) {\n\n    int numInstForFold, first, offset;\n    Instances train;\n \n    if (numFolds \u003c 2) {\n      throw new IllegalArgumentException(\"Number of folds must be at least 2!\");\n    }\n    if (numFolds \u003e numInstances()) {\n      throw new IllegalArgumentException(\"Can't have more folds than instances!\");\n    }\n    numInstForFold = numInstances() / numFolds;\n    if (numFold \u003c numInstances() % numFolds) {\n      numInstForFold++;\n      offset = numFold;\n    }else\n      offset = numInstances() % numFolds;\n    train = new Instances(this, numInstances() - numInstForFold);\n    first = numFold * (numInstances() / numFolds) + offset;\n    copyInstances(0, train, first);\n    copyInstances(first + numInstForFold, train,\n\t\t  numInstances() - first - numInstForFold);\n\n    return train;\n  }\n\n  /**\n   * Creates the training set for one fold of a cross-validation \n   * on the dataset. The data is subsequently randomized based\n   * on the given random number generator.\n   *\n   * @param numFolds the number of folds in the cross-validation. Must\n   * be greater than 1.\n   * @param numFold 0 for the first fold, 1 for the second, ...\n   * @param random the random number generator\n   * @return the training set \n   * @exception IllegalArgumentException if the number of folds is less than 2\n   * or greater than the number of instances.\n   */\n  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\n  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\n  public Instances trainCV(int numFolds, int numFold, Random random) {\n\n    Instances train = trainCV(numFolds, numFold);\n    train.randomize(random);\n    return train;\n  }\n\n  /**\n   * Computes the variance for a numeric attribute.\n   *\n   * @param attIndex the numeric attribute\n   * @return the variance if the attribute is numeric\n   * @exception IllegalArgumentException if the attribute is not numeric\n   */\n  public /*@pure@*/ double variance(int attIndex) {\n  \n    double sum = 0, sumSquared = 0, sumOfWeights = 0;\n\n    if (!attribute(attIndex).isNumeric()) {\n      throw new IllegalArgumentException(\"Can't compute variance because attribute is \" +\n\t\t\t  \"not numeric!\");\n    }\n    for (int i = 0; i \u003c numInstances(); i++) {\n      if (!instance(i).isMissing(attIndex)) {\n\tsum += instance(i).weight() * \n\t  instance(i).value(attIndex);\n\tsumSquared += instance(i).weight() * \n\t  instance(i).value(attIndex) *\n\t  instance(i).value(attIndex);\n\tsumOfWeights += instance(i).weight();\n      }\n    }\n    if (sumOfWeights \u003c= 1) {\n      return 0;\n    }\n    double result = (sumSquared - (sum * sum / sumOfWeights)) / \n      (sumOfWeights - 1);\n\n    // We don't like negative variance\n    if (result \u003c 0) {\n      return 0;\n    } else {\n      return result;\n    }\n  }\n\n  /**\n   * Computes the variance for a numeric attribute.\n   *\n   * @param att the numeric attribute\n   * @return the variance if the attribute is numeric\n   * @exception IllegalArgumentException if the attribute is not numeric\n   */\n  public /*@pure@*/ double variance(Attribute att) {\n    \n    return variance(att.index());\n  }\n  \n  /**\n   * Calculates summary statistics on the values that appear in this\n   * set of instances for a specified attribute.\n   *\n   * @param index the index of the attribute to summarize.\n   * @return an AttributeStats object with it's fields calculated.\n   */\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numAttributes();\n  public AttributeStats attributeStats(int index) {\n\n    AttributeStats result = new AttributeStats();\n    if (attribute(index).isNominal()) {\n      result.nominalCounts = new int [attribute(index).numValues()];\n    }\n    if (attribute(index).isNumeric()) {\n      result.numericStats = new weka.experiment.Stats();\n    }\n    result.totalCount = numInstances();\n\n    double [] attVals = attributeToDoubleArray(index);\n    int [] sorted = Utils.sort(attVals);\n    int currentCount = 0;\n    double prev = Instance.missingValue();\n    for (int j = 0; j \u003c numInstances(); j++) {\n      Instance current = instance(sorted[j]);\n      if (current.isMissing(index)) {\n\tresult.missingCount = numInstances() - j;\n\tbreak;\n      }\n      if (current.value(index) == prev) {\n\tcurrentCount++;\n      } else {\n\tresult.addDistinct(prev, currentCount);\n\tcurrentCount = 1;\n\tprev = current.value(index);\n      }\n    }\n    result.addDistinct(prev, currentCount);\n    result.distinctCount--; // So we don't count \"missing\" as a value \n    return result;\n  }\n  \n  /**\n   * Gets the value of all instances in this dataset for a particular\n   * attribute. Useful in conjunction with Utils.sort to allow iterating\n   * through the dataset in sorted order for some attribute.\n   *\n   * @param index the index of the attribute.\n   * @return an array containing the value of the desired attribute for\n   * each instance in the dataset. \n   */\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numAttributes();\n  public /*@pure@*/ double [] attributeToDoubleArray(int index) {\n\n    double [] result = new double[numInstances()];\n    for (int i = 0; i \u003c result.length; i++) {\n      result[i] = instance(i).value(index);\n    }\n    return result;\n  }\n\n  /**\n   * Generates a string summarizing the set of instances. Gives a breakdown\n   * for each attribute indicating the number of missing/discrete/unique\n   * values and other information.\n   *\n   * @return a string summarizing the dataset\n   */\n  public String toSummaryString() {\n\n    StringBuffer result = new StringBuffer();\n    result.append(\"Relation Name:  \").append(relationName()).append('\\n');\n    result.append(\"Num Instances:  \").append(numInstances()).append('\\n');\n    result.append(\"Num Attributes: \").append(numAttributes()).append('\\n');\n    result.append('\\n');\n\n    result.append(Utils.padLeft(\"\", 5)).append(Utils.padRight(\"Name\", 25));\n    result.append(Utils.padLeft(\"Type\", 5)).append(Utils.padLeft(\"Nom\", 5));\n    result.append(Utils.padLeft(\"Int\", 5)).append(Utils.padLeft(\"Real\", 5));\n    result.append(Utils.padLeft(\"Missing\", 12));\n    result.append(Utils.padLeft(\"Unique\", 12));\n    result.append(Utils.padLeft(\"Dist\", 6)).append('\\n');\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      Attribute a = attribute(i);\n      AttributeStats as = attributeStats(i);\n      result.append(Utils.padLeft(\"\" + (i + 1), 4)).append(' ');\n      result.append(Utils.padRight(a.name(), 25)).append(' ');\n      long percent;\n      switch (a.type()) {\n      case Attribute.NOMINAL:\n\tresult.append(Utils.padLeft(\"Nom\", 4)).append(' ');\n\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tbreak;\n      case Attribute.NUMERIC:\n\tresult.append(Utils.padLeft(\"Num\", 4)).append(' ');\n\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tbreak;\n      case Attribute.DATE:\n\tresult.append(Utils.padLeft(\"Dat\", 4)).append(' ');\n\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tbreak;\n      case Attribute.STRING:\n\tresult.append(Utils.padLeft(\"Str\", 4)).append(' ');\n\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tbreak;\n      default:\n\tresult.append(Utils.padLeft(\"???\", 4)).append(' ');\n\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tbreak;\n      }\n      result.append(Utils.padLeft(\"\" + as.missingCount, 5)).append(\" /\");\n      percent = Math.round(100.0 * as.missingCount / as.totalCount);\n      result.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n      result.append(Utils.padLeft(\"\" + as.uniqueCount, 5)).append(\" /\");\n      percent = Math.round(100.0 * as.uniqueCount / as.totalCount);\n      result.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n      result.append(Utils.padLeft(\"\" + as.distinctCount, 5)).append(' ');\n      result.append('\\n');\n    }\n    return result.toString();\n  }\n  \n  /**\n   * Reads a single instance using the tokenizer and appends it\n   * to the dataset. Automatically expands the dataset if it\n   * is not large enough to hold the instance.\n   *\n   * @param tokenizer the tokenizer to be used\n   * @param flag if method should test for carriage return after \n   * each instance\n   * @return false if end of file has been reached\n   * @exception IOException if the information is not read \n   * successfully\n   */ \n  protected boolean getInstance(StreamTokenizer tokenizer, \n\t\t\t\tboolean flag) \n       throws IOException {\n    \n    // Check if any attributes have been declared.\n    if (m_Attributes.size() == 0) {\n      errms(tokenizer,\"no header information available\");\n    }\n\n    // Check if end of file reached.\n    getFirstToken(tokenizer);\n    if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n      return false;\n    }\n    \n    // Parse instance\n    if (tokenizer.ttype == '{') {\n      return getInstanceSparse(tokenizer, flag);\n    } else {\n      return getInstanceFull(tokenizer, flag);\n    }\n  }\n\n  /**\n   * Reads a single instance using the tokenizer and appends it\n   * to the dataset. Automatically expands the dataset if it\n   * is not large enough to hold the instance.\n   *\n   * @param tokenizer the tokenizer to be used\n   * @param flag if method should test for carriage return after \n   * each instance\n   * @return false if end of file has been reached\n   * @exception IOException if the information is not read \n   * successfully\n   */ \n  protected boolean getInstanceSparse(StreamTokenizer tokenizer, \n\t\t\t\t      boolean flag) \n       throws IOException {\n\n    int valIndex, numValues = 0, maxIndex = -1;\n    \n    // Get values\n    do {\n      \n      // Get index\n      getIndex(tokenizer);\n      if (tokenizer.ttype == '}') {\n\tbreak;\n      }\n       \n      // Is index valid?\n      try{\n\tm_IndicesBuffer[numValues] = Integer.valueOf(tokenizer.sval).intValue();\n      } catch (NumberFormatException e) {\n\terrms(tokenizer,\"index number expected\");\n      }\n      if (m_IndicesBuffer[numValues] \u003c= maxIndex) {\n\terrms(tokenizer,\"indices have to be ordered\");\n      }\n      if ((m_IndicesBuffer[numValues] \u003c 0) || \n\t  (m_IndicesBuffer[numValues] \u003e= numAttributes())) {\n\terrms(tokenizer,\"index out of bounds\");\n      }\n      maxIndex = m_IndicesBuffer[numValues];\n\n      // Get value;\n      getNextToken(tokenizer);\n\n      // Check if value is missing.\n      if  (tokenizer.ttype == '?') {\n\tm_ValueBuffer[numValues] = Instance.missingValue();\n      } else {\n\n\t// Check if token is valid.\n\tif (tokenizer.ttype != StreamTokenizer.TT_WORD) {\n\t  errms(tokenizer,\"not a valid value\");\n\t}\n        switch (attribute(m_IndicesBuffer[numValues]).type()) {\n          case Attribute.NOMINAL:\n            // Check if value appears in header.\n            valIndex = \n              attribute(m_IndicesBuffer[numValues]).indexOfValue(tokenizer.sval);\n            if (valIndex == -1) {\n              errms(tokenizer,\"nominal value not declared in header\");\n            }\n            m_ValueBuffer[numValues] = (double)valIndex;\n            break;\n\tcase Attribute.NUMERIC:\n\t  // Check if value is really a number.\n\t  try{\n\t    m_ValueBuffer[numValues] = Double.valueOf(tokenizer.sval).\n\t      doubleValue();\n\t  } catch (NumberFormatException e) {\n\t    errms(tokenizer,\"number expected\");\n\t  }\n          break;\n\tcase Attribute.STRING:\n\t  m_ValueBuffer[numValues] = \n\t    attribute(m_IndicesBuffer[numValues]).addStringValue(tokenizer.sval);\n          break;\n        case Attribute.DATE:\n          try {\n            m_ValueBuffer[numValues] = \n              attribute(m_IndicesBuffer[numValues]).parseDate(tokenizer.sval);\n          } catch (ParseException e) {\n            errms(tokenizer,\"unparseable date: \" + tokenizer.sval);\n          }\n          break;\n        default:\n          errms(tokenizer,\"unknown attribute type in column \" + m_IndicesBuffer[numValues]);\n\t}\n      }\n      numValues++;\n    } while (true);\n    if (flag) {\n      getLastToken(tokenizer,true);\n    }\n      \n    // Add instance to dataset\n    double[] tempValues = new double[numValues];\n    int[] tempIndices = new int[numValues];\n    System.arraycopy(m_ValueBuffer, 0, tempValues, 0, numValues);\n    System.arraycopy(m_IndicesBuffer, 0, tempIndices, 0, numValues);\n    add(new SparseInstance(1, tempValues, tempIndices, numAttributes()));\n    return true;\n  }\n\n  /**\n   * Reads a single instance using the tokenizer and appends it\n   * to the dataset. Automatically expands the dataset if it\n   * is not large enough to hold the instance.\n   *\n   * @param tokenizer the tokenizer to be used\n   * @param flag if method should test for carriage return after \n   * each instance\n   * @return false if end of file has been reached\n   * @exception IOException if the information is not read \n   * successfully\n   */ \n  protected boolean getInstanceFull(StreamTokenizer tokenizer, \n\t\t\t\t    boolean flag) \n       throws IOException {\n\n    double[] instance = new double[numAttributes()];\n    int index;\n    \n    // Get values for all attributes.\n    for (int i = 0; i \u003c numAttributes(); i++){\n      \n      // Get next token\n      if (i \u003e 0) {\n\tgetNextToken(tokenizer);\n      }\n            \n      // Check if value is missing.\n      if  (tokenizer.ttype == '?') {\n\tinstance[i] = Instance.missingValue();\n      } else {\n\n\t// Check if token is valid.\n\tif (tokenizer.ttype != StreamTokenizer.TT_WORD) {\n\t  errms(tokenizer,\"not a valid value\");\n\t}\n        switch (attribute(i).type()) {\n        case Attribute.NOMINAL:\n\t  // Check if value appears in header.\n\t  index = attribute(i).indexOfValue(tokenizer.sval);\n\t  if (index == -1) {\n\t    errms(tokenizer,\"nominal value not declared in header\");\n\t  }\n\t  instance[i] = (double)index;\n          break;\n\tcase Attribute.NUMERIC:\n\t  // Check if value is really a number.\n\t  try{\n\t    instance[i] = Double.valueOf(tokenizer.sval).\n\t      doubleValue();\n\t  } catch (NumberFormatException e) {\n\t    errms(tokenizer,\"number expected\");\n\t  }\n          break;\n\tcase Attribute.STRING:\n\t  instance[i] = attribute(i).addStringValue(tokenizer.sval);\n          break;\n        case Attribute.DATE:\n          try {\n            instance[i] = attribute(i).parseDate(tokenizer.sval);\n          } catch (ParseException e) {\n            errms(tokenizer,\"unparseable date: \" + tokenizer.sval);\n          }\n          break;\n        default:\n          errms(tokenizer,\"unknown attribute type in column \" + i);\n\t}\n      }\n    }\n    if (flag) {\n      getLastToken(tokenizer,true);\n    }\n      \n    // Add instance to dataset\n    add(new Instance(1, instance));\n    return true;\n  }\n\n  /**\n   * Reads and stores header of an ARFF file.\n   *\n   * @param tokenizer the stream tokenizer\n   * @exception IOException if the information is not read \n   * successfully\n   */ \n  protected void readHeader(StreamTokenizer tokenizer) \n     throws IOException {\n    \n    String attributeName;\n    FastVector attributeValues;\n    int i;\n\n    // Get name of relation.\n    getFirstToken(tokenizer);\n    if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n      errms(tokenizer,\"premature end of file\");\n    }\n    if (ARFF_RELATION.equalsIgnoreCase(tokenizer.sval)) {\n      getNextToken(tokenizer);\n      m_RelationName = tokenizer.sval;\n      getLastToken(tokenizer,false);\n    } else {\n      errms(tokenizer,\"keyword \" + ARFF_RELATION + \" expected\");\n    }\n\n    // Create vectors to hold information temporarily.\n    m_Attributes = new FastVector();\n \n    // Get attribute declarations.\n    getFirstToken(tokenizer);\n    if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n      errms(tokenizer,\"premature end of file\");\n    }\n\n    while (Attribute.ARFF_ATTRIBUTE.equalsIgnoreCase(tokenizer.sval)) {\n\n      // Get attribute name.\n      getNextToken(tokenizer);\n      attributeName = tokenizer.sval;\n      getNextToken(tokenizer);\n\n      // Check if attribute is nominal.\n      if (tokenizer.ttype == StreamTokenizer.TT_WORD) {\n\n\t// Attribute is real, integer, or string.\n\tif (tokenizer.sval.equalsIgnoreCase(Attribute.ARFF_ATTRIBUTE_REAL) ||\n\t    tokenizer.sval.equalsIgnoreCase(Attribute.ARFF_ATTRIBUTE_INTEGER) ||\n\t    tokenizer.sval.equalsIgnoreCase(Attribute.ARFF_ATTRIBUTE_NUMERIC)) {\n\t  m_Attributes.addElement(new Attribute(attributeName, numAttributes()));\n\t  readTillEOL(tokenizer);\n\t} else if (tokenizer.sval.equalsIgnoreCase(Attribute.ARFF_ATTRIBUTE_STRING)) {\n\t  m_Attributes.\n\t    addElement(new Attribute(attributeName, (FastVector)null,\n\t\t\t\t     numAttributes()));\n\t  readTillEOL(tokenizer);\n\t} else if (tokenizer.sval.equalsIgnoreCase(Attribute.ARFF_ATTRIBUTE_DATE)) {\n          String format = null;\n          if (tokenizer.nextToken() != StreamTokenizer.TT_EOL) {\n            if ((tokenizer.ttype != StreamTokenizer.TT_WORD) \u0026\u0026\n                (tokenizer.ttype != '\\'') \u0026\u0026\n                (tokenizer.ttype != '\\\"')) {\n              errms(tokenizer,\"not a valid date format\");\n            }\n            format = tokenizer.sval;\n            readTillEOL(tokenizer);\n          } else {\n            tokenizer.pushBack();\n          }\n\t  m_Attributes.addElement(new Attribute(attributeName, format,\n                                                numAttributes()));\n\n\t} else {\n\t  errms(tokenizer,\"no valid attribute type or invalid \"+\n\t\t\"enumeration\");\n\t}\n      } else {\n\n\t// Attribute is nominal.\n\tattributeValues = new FastVector();\n\ttokenizer.pushBack();\n\t\n\t// Get values for nominal attribute.\n\tif (tokenizer.nextToken() != '{') {\n\t  errms(tokenizer,\"{ expected at beginning of enumeration\");\n\t}\n\twhile (tokenizer.nextToken() != '}') {\n\t  if (tokenizer.ttype == StreamTokenizer.TT_EOL) {\n\t    errms(tokenizer,\"} expected at end of enumeration\");\n\t  } else {\n\t    attributeValues.addElement(tokenizer.sval);\n\t  }\n\t}\n\tm_Attributes.\n\t  addElement(new Attribute(attributeName, attributeValues,\n\t\t\t\t   numAttributes()));\n      }\n      getLastToken(tokenizer,false);\n      getFirstToken(tokenizer);\n      if (tokenizer.ttype == StreamTokenizer.TT_EOF)\n\terrms(tokenizer,\"premature end of file\");\n    }\n\n    // Check if data part follows. We can't easily check for EOL.\n    if (!ARFF_DATA.equalsIgnoreCase(tokenizer.sval)) {\n      errms(tokenizer,\"keyword \" + ARFF_DATA + \" expected\");\n    }\n    \n    // Check if any attributes have been declared.\n    if (m_Attributes.size() == 0) {\n      errms(tokenizer,\"no attributes declared\");\n    }\n\n    // Allocate buffers in case sparse instances have to be read\n    m_ValueBuffer = new double[numAttributes()];\n    m_IndicesBuffer = new int[numAttributes()];\n  }\n\n  /**\n   * Copies instances from one set to the end of another \n   * one.\n   *\n   * @param source the source of the instances\n   * @param from the position of the first instance to be copied\n   * @param dest the destination for the instances\n   * @param num the number of instances to be copied\n   */\n  //@ requires 0 \u003c= from \u0026\u0026 from \u003c= numInstances() - num;\n  //@ requires 0 \u003c= num;\n  protected void copyInstances(int from, /*@non_null@*/ Instances dest, int num) {\n    \n    for (int i = 0; i \u003c num; i++) {\n      dest.add(instance(from + i));\n    }\n  }\n  \n  /**\n   * Throws error message with line number and last token read.\n   *\n   * @param theMsg the error message to be thrown\n   * @param tokenizer the stream tokenizer\n   * @throws IOExcpetion containing the error message\n   */\n  protected void errms(StreamTokenizer tokenizer, String theMsg) \n       throws IOException {\n    \n    throw new IOException(theMsg + \", read \" + tokenizer.toString());\n  }\n  \n  /**\n   * Replaces the attribute information by a clone of\n   * itself.\n   */\n  protected void freshAttributeInfo() {\n\n    m_Attributes = (FastVector) m_Attributes.copyElements();\n  }\n\n  /**\n   * Gets next token, skipping empty lines.\n   *\n   * @param tokenizer the stream tokenizer\n   * @exception IOException if reading the next token fails\n   */\n  protected void getFirstToken(StreamTokenizer tokenizer) \n    throws IOException {\n    \n    while (tokenizer.nextToken() == StreamTokenizer.TT_EOL){};\n    if ((tokenizer.ttype == '\\'') ||\n\t(tokenizer.ttype == '\"')) {\n      tokenizer.ttype = StreamTokenizer.TT_WORD;\n    } else if ((tokenizer.ttype == StreamTokenizer.TT_WORD) \u0026\u0026\n\t       (tokenizer.sval.equals(\"?\"))){\n      tokenizer.ttype = '?';\n    }\n  }\n\n  /**\n   * Gets index, checking for a premature and of line.\n   *\n   * @param tokenizer the stream tokenizer\n   * @exception IOException if it finds a premature end of line\n   */\n  protected void getIndex(StreamTokenizer tokenizer) throws IOException {\n    \n    if (tokenizer.nextToken() == StreamTokenizer.TT_EOL) {\n      errms(tokenizer,\"premature end of line\");\n    }\n    if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n      errms(tokenizer,\"premature end of file\");\n    }\n  }\n  \n  /**\n   * Gets token and checks if its end of line.\n   *\n   * @param tokenizer the stream tokenizer\n   * @exception IOException if it doesn't find an end of line\n   */\n  protected void getLastToken(StreamTokenizer tokenizer, boolean endOfFileOk) \n       throws IOException {\n\n    if ((tokenizer.nextToken() != StreamTokenizer.TT_EOL) \u0026\u0026\n\t((tokenizer.ttype != StreamTokenizer.TT_EOF) || !endOfFileOk)) {\n      errms(tokenizer,\"end of line expected\");\n    }\n  }\n\n  /**\n   * Gets next token, checking for a premature and of line.\n   *\n   * @param tokenizer the stream tokenizer\n   * @exception IOException if it finds a premature end of line\n   */\n  protected void getNextToken(StreamTokenizer tokenizer) \n       throws IOException {\n    \n    if (tokenizer.nextToken() == StreamTokenizer.TT_EOL) {\n      errms(tokenizer,\"premature end of line\");\n    }\n    if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n      errms(tokenizer,\"premature end of file\");\n    } else if ((tokenizer.ttype == '\\'') ||\n\t       (tokenizer.ttype == '\"')) {\n      tokenizer.ttype = StreamTokenizer.TT_WORD;\n    } else if ((tokenizer.ttype == StreamTokenizer.TT_WORD) \u0026\u0026\n\t       (tokenizer.sval.equals(\"?\"))){\n      tokenizer.ttype = '?';\n    }\n  }\n\t\n  /**\n   * Initializes the StreamTokenizer used for reading the ARFF file.\n   *\n   * @param tokenizer the stream tokenizer\n   */\n  protected void initTokenizer(StreamTokenizer tokenizer){\n\n    tokenizer.resetSyntax();         \n    tokenizer.whitespaceChars(0, ' ');    \n    tokenizer.wordChars(' '+1,'\\u00FF');\n    tokenizer.whitespaceChars(',',',');\n    tokenizer.commentChar('%');\n    tokenizer.quoteChar('\"');\n    tokenizer.quoteChar('\\'');\n    tokenizer.ordinaryChar('{');\n    tokenizer.ordinaryChar('}');\n    tokenizer.eolIsSignificant(true);\n  }\n \n  /**\n   * Returns string including all instances, their weights and\n   * their indices in the original dataset.\n   *\n   * @return description of instance and its weight as a string\n   */\n  protected /*@pure@*/ String instancesAndWeights(){\n\n    StringBuffer text = new StringBuffer();\n\n    for (int i = 0; i \u003c numInstances(); i++) {\n      text.append(instance(i) + \" \" + instance(i).weight());\n      if (i \u003c numInstances() - 1) {\n\ttext.append(\"\\n\");\n      }\n    }\n    return text.toString();\n  }\n  \n  /**\n   * Partitions the instances around a pivot. Used by quicksort and\n   * kthSmallestValue.\n   *\n   * @param attIndex the attribute's index\n   * @param left the first index of the subset \n   * @param right the last index of the subset \n   *\n   * @return the index of the middle element\n   */\n  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\n  //@ requires 0 \u003c= left \u0026\u0026 left \u003c= right \u0026\u0026 right \u003c numInstances();\n  protected int partition(int attIndex, int l, int r) {\n    \n    double pivot = instance((l + r) / 2).value(attIndex);\n\n    while (l \u003c r) {\n      while ((instance(l).value(attIndex) \u003c pivot) \u0026\u0026 (l \u003c r)) {\n        l++;\n      }\n      while ((instance(r).value(attIndex) \u003e pivot) \u0026\u0026 (l \u003c r)) {\n        r--;\n      }\n      if (l \u003c r) {\n        swap(l, r);\n        l++;\n        r--;\n      }\n    }\n    if ((l == r) \u0026\u0026 (instance(r).value(attIndex) \u003e pivot)) {\n      r--;\n    } \n\n    return r;\n  }\n  \n  /**\n   * Implements quicksort according to Manber's \"Introduction to\n   * Algorithms\".\n   *\n   * @param attIndex the attribute's index\n   * @param left the first index of the subset to be sorted\n   * @param right the last index of the subset to be sorted\n   */\n  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c numInstances();\n  protected void quickSort(int attIndex, int left, int right) {\n\n    if (left \u003c right) {\n      int middle = partition(attIndex, left, right);\n      quickSort(attIndex, left, middle);\n      quickSort(attIndex, middle + 1, right);\n    }\n  }\n\n  /**\n   * Reads and skips all tokens before next end of line token.\n   *\n   * @param tokenizer the stream tokenizer\n   */\n  protected void readTillEOL(StreamTokenizer tokenizer) \n       throws IOException {\n    \n    while (tokenizer.nextToken() != StreamTokenizer.TT_EOL) {};\n    tokenizer.pushBack();\n  }\n  \n  /**\n   * Implements computation of the kth-smallest element according\n   * to Manber's \"Introduction to Algorithms\".\n   *\n   * @param attIndex the attribute's index\n   * @param left the first index of the subset \n   * @param right the last index of the subset \n   * @param k the value of k\n   *\n   * @return the index of the kth-smallest element\n   */\n  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c numInstances();\n  protected int select(int attIndex, int left, int right, int k) {\n    \n    if (left == right) {\n      return left;\n    } else {\n      int middle = partition(attIndex, left, right);\n      if ((middle - left + 1) \u003e= k) {\n        return select(attIndex, left, middle, k);\n      } else {\n        return select(attIndex, middle + 1, right, k - (middle - left + 1));\n      }\n    }\n  }\n\n  /**\n   * Help function needed for stratification of set.\n   *\n   * @param numFolds the number of folds for the stratification\n   */\n  protected void stratStep (int numFolds){\n    \n    FastVector newVec = new FastVector(m_Instances.capacity());\n    int start = 0, j;\n\n    // create stratified batch\n    while (newVec.size() \u003c numInstances()) {\n      j = start;\n      while (j \u003c numInstances()) {\n\tnewVec.addElement(instance(j));\n\tj = j + numFolds;\n      }\n      start++;\n    }\n    m_Instances = newVec;\n  }\n  \n  /**\n   * Swaps two instances in the set.\n   *\n   * @param i the first instance's index\n   * @param j the second instance's index\n   */\n  //@ requires 0 \u003c= i \u0026\u0026 i \u003c numInstances();\n  //@ requires 0 \u003c= j \u0026\u0026 j \u003c numInstances();\n  public void swap(int i, int j){\n    \n    m_Instances.swap(i, j);\n  }\n\n  /**\n   * Merges two sets of Instances together. The resulting set will have\n   * all the attributes of the first set plus all the attributes of the \n   * second set. The number of instances in both sets must be the same.\n   *\n   * @param first the first set of Instances\n   * @param second the second set of Instances\n   * @return the merged set of Instances\n   * @exception IllegalArgumentException if the datasets are not the same size\n   */\n  public static Instances mergeInstances(Instances first, Instances second) {\n\n    if (first.numInstances() != second.numInstances()) {\n      throw new IllegalArgumentException(\"Instance sets must be of the same size\");\n    }\n\n    // Create the vector of merged attributes\n    FastVector newAttributes = new FastVector();\n    for (int i = 0; i \u003c first.numAttributes(); i++) {\n      newAttributes.addElement(first.attribute(i));\n    }\n    for (int i = 0; i \u003c second.numAttributes(); i++) {\n      newAttributes.addElement(second.attribute(i));\n    }\n    \n    // Create the set of Instances\n    Instances merged = new Instances(first.relationName() + '_'\n\t\t\t\t     + second.relationName(), \n\t\t\t\t     newAttributes, \n\t\t\t\t     first.numInstances());\n    // Merge each instance\n    for (int i = 0; i \u003c first.numInstances(); i++) {\n      merged.add(first.instance(i).mergeInstance(second.instance(i)));\n    }\n    return merged;\n  }\n\n  /**\n   * Method for testing this class.\n   *\n   * @param argv should contain one element: the name of an ARFF file\n   */\n  //@ requires argv != null;\n  //@ requires argv.length == 1;\n  //@ requires argv[0] != null;\n  public static void test(String [] argv) {\n\n    Instances instances, secondInstances, train, test, transformed, empty;\n    Instance instance;\n    Random random = new Random(2);\n    Reader reader;\n    int start, num;\n    double newWeight;\n    FastVector testAtts, testVals;\n    int i,j;\n    \n    try{\n      if (argv.length \u003e 1) {\n\tthrow (new Exception(\"Usage: Instances [\u003cfilename\u003e]\"));\n      }\n      \n      // Creating set of instances from scratch\n      testVals = new FastVector(2);\n      testVals.addElement(\"first_value\");\n      testVals.addElement(\"second_value\");\n      testAtts = new FastVector(2);\n      testAtts.addElement(new Attribute(\"nominal_attribute\", testVals));\n      testAtts.addElement(new Attribute(\"numeric_attribute\"));\n      instances = new Instances(\"test_set\", testAtts, 10);\n      instances.add(new Instance(instances.numAttributes()));\n      instances.add(new Instance(instances.numAttributes()));\n      instances.add(new Instance(instances.numAttributes()));\n      instances.setClassIndex(0);\n      System.out.println(\"\\nSet of instances created from scratch:\\n\");\n      System.out.println(instances);\n      \n      if (argv.length == 1) {\n\tString filename = argv[0];\n\treader = new FileReader(filename);\n\t\n\t// Read first five instances and print them\n\tSystem.out.println(\"\\nFirst five instances from file:\\n\");\n\tinstances = new Instances(reader, 1);\n\tinstances.setClassIndex(instances.numAttributes() - 1);\n\ti = 0;\n\twhile ((i \u003c 5) \u0026\u0026 (instances.readInstance(reader))) {\n\t  i++;\n\t}\n\tSystem.out.println(instances);\n\n\t// Read all the instances in the file\n\treader = new FileReader(filename);\n\tinstances = new Instances(reader);\n\n\t// Make the last attribute be the class \n\tinstances.setClassIndex(instances.numAttributes() - 1);\n\t\n\t// Print header and instances.\n\tSystem.out.println(\"\\nDataset:\\n\");\n\tSystem.out.println(instances);\n\tSystem.out.println(\"\\nClass index: \"+instances.classIndex());\n      }\n      \n      // Test basic methods based on class index.\n      System.out.println(\"\\nClass name: \"+instances.classAttribute().name());\n      System.out.println(\"\\nClass index: \"+instances.classIndex());\n      System.out.println(\"\\nClass is nominal: \" +\n\t\t\t instances.classAttribute().isNominal());\n      System.out.println(\"\\nClass is numeric: \" +\n\t\t\t instances.classAttribute().isNumeric());\n      System.out.println(\"\\nClasses:\\n\");\n      for (i = 0; i \u003c instances.numClasses(); i++) {\n\tSystem.out.println(instances.classAttribute().value(i));\n      }\n      System.out.println(\"\\nClass values and labels of instances:\\n\");\n      for (i = 0; i \u003c instances.numInstances(); i++) {\n\tInstance inst = instances.instance(i);\n\tSystem.out.print(inst.classValue() + \"\\t\");\n\tSystem.out.print(inst.toString(inst.classIndex()));\n\tif (instances.instance(i).classIsMissing()) {\n\t  System.out.println(\"\\tis missing\");\n\t} else {\n\t  System.out.println();\n\t}\n      }\n      \n      // Create random weights.\n      System.out.println(\"\\nCreating random weights for instances.\");\n      for (i = 0; i \u003c instances.numInstances(); i++) {\n\tinstances.instance(i).setWeight(random.nextDouble()); \n      }\n      \n      // Print all instances and their weights (and the sum of weights).\n      System.out.println(\"\\nInstances and their weights:\\n\");\n      System.out.println(instances.instancesAndWeights());\n      System.out.print(\"\\nSum of weights: \");\n      System.out.println(instances.sumOfWeights());\n      \n      // Insert an attribute\n      secondInstances = new Instances(instances);\n      Attribute testAtt = new Attribute(\"Inserted\");\n      secondInstances.insertAttributeAt(testAtt, 0);\n      System.out.println(\"\\nSet with inserted attribute:\\n\");\n      System.out.println(secondInstances);\n      System.out.println(\"\\nClass name: \"\n\t\t\t + secondInstances.classAttribute().name());\n      \n      // Delete the attribute\n      secondInstances.deleteAttributeAt(0);\n      System.out.println(\"\\nSet with attribute deleted:\\n\");\n      System.out.println(secondInstances);\n      System.out.println(\"\\nClass name: \"\n\t\t\t + secondInstances.classAttribute().name());\n      \n      // Test if headers are equal\n      System.out.println(\"\\nHeaders equal: \"+\n\t\t\t instances.equalHeaders(secondInstances) + \"\\n\");\n      \n      // Print data in internal format.\n      System.out.println(\"\\nData (internal values):\\n\");\n      for (i = 0; i \u003c instances.numInstances(); i++) {\n\tfor (j = 0; j \u003c instances.numAttributes(); j++) {\n\t  if (instances.instance(i).isMissing(j)) {\n\t    System.out.print(\"? \");\n\t  } else {\n\t    System.out.print(instances.instance(i).value(j) + \" \");\n\t  }\n\t}\n\tSystem.out.println();\n      }\n      \n      // Just print header\n      System.out.println(\"\\nEmpty dataset:\\n\");\n      empty = new Instances(instances, 0);\n      System.out.println(empty);\n      System.out.println(\"\\nClass name: \"+empty.classAttribute().name());\n\n      // Create copy and rename an attribute and a value (if possible)\n      if (empty.classAttribute().isNominal()) {\n\tInstances copy = new Instances(empty, 0);\n\tcopy.renameAttribute(copy.classAttribute(), \"new_name\");\n\tcopy.renameAttributeValue(copy.classAttribute(), \n\t\t\t\t  copy.classAttribute().value(0), \n\t\t\t\t  \"new_val_name\");\n\tSystem.out.println(\"\\nDataset with names changed:\\n\" + copy);\n\tSystem.out.println(\"\\nOriginal dataset:\\n\" + empty);\n      }\n\n      // Create and prints subset of instances.\n      start = instances.numInstances() / 4;\n      num = instances.numInstances() / 2;\n      System.out.print(\"\\nSubset of dataset: \");\n      System.out.println(num + \" instances from \" + (start + 1) \n\t\t\t + \". instance\");\n      secondInstances = new Instances(instances, start, num);\n      System.out.println(\"\\nClass name: \"\n\t\t\t + secondInstances.classAttribute().name());\n\n      // Print all instances and their weights (and the sum of weights).\n      System.out.println(\"\\nInstances and their weights:\\n\");\n      System.out.println(secondInstances.instancesAndWeights());\n      System.out.print(\"\\nSum of weights: \");\n      System.out.println(secondInstances.sumOfWeights());\n      \n      // Create and print training and test sets for 3-fold\n      // cross-validation.\n      System.out.println(\"\\nTrain and test folds for 3-fold CV:\");\n      if (instances.classAttribute().isNominal()) {\n\tinstances.stratify(3);\n      }\n      for (j = 0; j \u003c 3; j++) {\n        train = instances.trainCV(3,j, new Random(1));\n\ttest = instances.testCV(3,j);\n                      \n\t// Print all instances and their weights (and the sum of weights).\n\tSystem.out.println(\"\\nTrain: \");\n\tSystem.out.println(\"\\nInstances and their weights:\\n\");\n\tSystem.out.println(train.instancesAndWeights());\n\tSystem.out.print(\"\\nSum of weights: \");\n\tSystem.out.println(train.sumOfWeights());\n\tSystem.out.println(\"\\nClass name: \"+train.classAttribute().name());\n\tSystem.out.println(\"\\nTest: \");\n\tSystem.out.println(\"\\nInstances and their weights:\\n\");\n\tSystem.out.println(test.instancesAndWeights());\n\tSystem.out.print(\"\\nSum of weights: \");\n\tSystem.out.println(test.sumOfWeights());\n\tSystem.out.println(\"\\nClass name: \"+test.classAttribute().name());\n      }\n\n      // Randomize instances and print them.\n      System.out.println(\"\\nRandomized dataset:\");\n      instances.randomize(random);\n      \n      // Print all instances and their weights (and the sum of weights).\n      System.out.println(\"\\nInstances and their weights:\\n\");\n      System.out.println(instances.instancesAndWeights());\n      System.out.print(\"\\nSum of weights: \");\n      System.out.println(instances.sumOfWeights());\n\n      // Sort instances according to first attribute and\n      // print them.\n      System.out.print(\"\\nInstances sorted according to first attribute:\\n \");\n      instances.sort(0);\n        \n      // Print all instances and their weights (and the sum of weights).\n      System.out.println(\"\\nInstances and their weights:\\n\");\n      System.out.println(instances.instancesAndWeights());\n      System.out.print(\"\\nSum of weights: \");\n      System.out.println(instances.sumOfWeights());\n    } catch (Exception e) {\n      e.printStackTrace(); \n    }\n  }\n\n  /**\n   * Main method for this class. The following calls are possible:\n   * \u003cul\u003e\n   *   \u003cli\u003e\n   *     \u003ccode\u003eweka.core.Instances\u003c/code\u003e \u0026lt;filename\u0026gt;\u003cbr/\u003e\n   *     prints a summary of a set of instances.\n   *   \u003c/li\u003e\n   *   \u003cli\u003e\n   *     \u003ccode\u003eweka.core.Instances\u003c/code\u003e merge \u0026lt;filename1\u0026gt; \u0026lt;filename2\u0026gt;\u003cbr/\u003e\n   *     merges the two datasets (must have same number of instances) and\n   *     outputs the results on stdout.\n   *   \u003c/li\u003e\n   * \u003c/ul\u003e\n   *\n   * @param args \tthe commandline parameters\n   */\n  public static void main(String[] args) {\n\n    try {\n      Instances i;\n      // read from stdin and print statistics\n      if (args.length == 0) {\n\ti = new Instances(new BufferedReader(new InputStreamReader(System.in)));\n\tSystem.out.println(i.toSummaryString());\n      }\n      // read file and print statistics\n      else if (args.length == 1) {\n\ti = new Instances(new BufferedReader(new FileReader(args[0])));\n\tSystem.out.println(i.toSummaryString());\n      }\n      // read two files, merge them and print result to stdout\n      else if ((args.length == 3) \u0026\u0026 (args[0].toLowerCase().equals(\"merge\"))) {\n\ti = Instances.mergeInstances(\n            new Instances(new BufferedReader(new FileReader(args[1]))),\n            new Instances(new BufferedReader(new FileReader(args[2]))));\n\tSystem.out.println(i);\n      }\n      // wrong parameters\n      else {\n\tSystem.err.println(\n\t    \"\\nUsage:\\n\"\n\t    + \"\\tweka.core.Instances \u003cfilename\u003e\\n\"\n\t    + \"\\tweka.core.Instances merge \u003cfilename1\u003e \u003cfilename2\u003e\\n\");\n\tSystem.exit(1);\n      }\n    }\n    catch (Exception ex) {\n      ex.printStackTrace();\n      System.err.println(ex.getMessage());\n    }\n  }\n}\n\n",
        "name": "Instances.java",
        "path": "subjectSystems/C,D/core/Instances.java",
        "url": "/github.com/LASER-UMASS/Themis/-/blob/subjectSystems/C,D/core/Instances.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 132,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires capacity \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 133,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures classIndex() == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 195,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first;"
        },
        {
          "limitHit": false,
          "lineNumber": 196,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= toCopy;"
        },
        {
          "limitHit": false,
          "lineNumber": 197,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires first + toCopy \u003c= source.numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 274,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;"
        },
        {
          "limitHit": false,
          "lineNumber": 275,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003c m_Attributes.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 276,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 355,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 398,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 413,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= position \u0026\u0026 position \u003c numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 414,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires position != classIndex();"
        },
        {
          "limitHit": false,
          "lineNumber": 462,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 549,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires numInstances() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 581,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= position;"
        },
        {
          "limitHit": false,
          "lineNumber": 582,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires position \u003c= numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 611,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;"
        },
        {
          "limitHit": false,
          "lineNumber": 612,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 676,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires numInstances() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 739,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Attributes.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 752,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 773,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= attIndex;"
        },
        {
          "limitHit": false,
          "lineNumber": 774,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attIndex \u003c numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 817,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Instances.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 860,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_RelationName;"
        },
        {
          "limitHit": false,
          "lineNumber": 1169,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 1170,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;"
        },
        {
          "limitHit": false,
          "lineNumber": 1231,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 1232,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;"
        },
        {
          "limitHit": false,
          "lineNumber": 1272,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 1273,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;"
        },
        {
          "limitHit": false,
          "lineNumber": 1339,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 1383,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 1819,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= from \u0026\u0026 from \u003c= numInstances() - num;"
        },
        {
          "limitHit": false,
          "lineNumber": 1820,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= num;"
        },
        {
          "limitHit": false,
          "lineNumber": 1971,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 1972,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= left \u0026\u0026 left \u003c= right \u0026\u0026 right \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 2005,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 2006,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 2039,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 2040,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 2083,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= i \u0026\u0026 i \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 2084,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= j \u0026\u0026 j \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 2132,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires argv != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 2133,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires argv.length == 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 2134,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires argv[0] != null;"
        }
      ],
      "repository": {
        "name": "github.com/LASER-UMASS/Themis",
        "url": "/github.com/LASER-UMASS/Themis"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a70f12a6a8f34cdd8b170b4dc59a78674c9e8950"
        },
        "content": "/*\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; either version 2 of the License, or\n *    (at your option) any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n/*\n *    Attribute.java\n *    Copyright (C) 1999 Eibe Frank\n *\n */\n\npackage weka.core;\n\nimport java.io.Serializable;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport java.io.StreamTokenizer;\nimport java.io.StringReader;\nimport java.io.IOException;\n\n/** \n * Class for handling an attribute. Once an attribute has been created,\n * it can't be changed. \u003cp\u003e\n *\n * The following attribute types are supported:\n * \u003cul\u003e\n *    \u003cli\u003e numeric: \u003cbr/\u003e\n *         This type of attribute represents a floating-point number.\n *    \u003c/li\u003e\n *    \u003cli\u003e nominal: \u003cbr/\u003e\n *         This type of attribute represents a fixed set of nominal values.\n *    \u003c/li\u003e\n *    \u003cli\u003e string: \u003cbr/\u003e\n *         This type of attribute represents a dynamically expanding set of\n *         nominal values. Usually used in text classification.\n *    \u003c/li\u003e\n *    \u003cli\u003e date: \u003cbr/\u003e\n *         This type of attribute represents a date, internally represented as \n *         floating-point number storing the milliseconds since January 1, \n *         1970, 00:00:00 GMT. The string representation of the date must be\n *         \u003ca href=\"http://www.iso.org/iso/en/prods-services/popstds/datesandtime.html\" target=\"_blank\"\u003e\n *         ISO-8601\u003c/a\u003e compliant, the default is \u003ccode\u003eyyyy-MM-dd'T'HH:mm:ss\u003c/code\u003e.\n *    \u003c/li\u003e\n * \u003c/ul\u003e\n * \n * Typical usage (code from the main() method of this class): \u003cp\u003e\n *\n * \u003ccode\u003e\n * ... \u003cbr\u003e\n *\n * // Create numeric attributes \"length\" and \"weight\" \u003cbr\u003e\n * Attribute length = new Attribute(\"length\"); \u003cbr\u003e\n * Attribute weight = new Attribute(\"weight\"); \u003cbr\u003e\u003cbr\u003e\n * \n * // Create vector to hold nominal values \"first\", \"second\", \"third\" \u003cbr\u003e\n * FastVector my_nominal_values = new FastVector(3); \u003cbr\u003e\n * my_nominal_values.addElement(\"first\"); \u003cbr\u003e\n * my_nominal_values.addElement(\"second\"); \u003cbr\u003e\n * my_nominal_values.addElement(\"third\"); \u003cbr\u003e\u003cbr\u003e\n *\n * // Create nominal attribute \"position\" \u003cbr\u003e\n * Attribute position = new Attribute(\"position\", my_nominal_values);\u003cbr\u003e\n *\n * ... \u003cbr\u003e\n * \u003c/code\u003e\u003cp\u003e\n *\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\n * @version $Revision: 1.32.2.3 $\n */\npublic class Attribute implements Copyable, Serializable {\n\n  /** Constant set for numeric attributes. */\n  public static final int NUMERIC = 0;\n\n  /** Constant set for nominal attributes. */\n  public static final int NOMINAL = 1;\n\n  /** Constant set for attributes with string values. */\n  public static final int STRING = 2;\n\n  /** Constant set for attributes with date values. */\n  public static final int DATE = 3;\n\n  /** Constant set for symbolic attributes. */\n  public static final int ORDERING_SYMBOLIC = 0;\n\n  /** Constant set for ordered attributes. */\n  public static final int ORDERING_ORDERED  = 1;\n\n  /** Constant set for modulo-ordered attributes. */\n  public static final int ORDERING_MODULO   = 2;\n\n  /** The keyword used to denote the start of an arff attribute declaration */\n  static String ARFF_ATTRIBUTE = \"@attribute\";\n\n  /** A keyword used to denote a numeric attribute */\n  static String ARFF_ATTRIBUTE_INTEGER = \"integer\";\n\n  /** A keyword used to denote a numeric attribute */\n  static String ARFF_ATTRIBUTE_REAL = \"real\";\n\n  /** A keyword used to denote a numeric attribute */\n  static String ARFF_ATTRIBUTE_NUMERIC = \"numeric\";\n\n  /** The keyword used to denote a string attribute */\n  static String ARFF_ATTRIBUTE_STRING = \"string\";\n\n  /** The keyword used to denote a date attribute */\n  static String ARFF_ATTRIBUTE_DATE = \"date\";\n\n  /** Strings longer than this will be stored compressed. */\n  private static final int STRING_COMPRESS_THRESHOLD = 200;\n\n  /** The attribute's name. */\n  private /*@ spec_public non_null @*/ String m_Name;\n\n  /** The attribute's type. */\n  private /*@ spec_public @*/ int m_Type;\n  /*@ invariant m_Type == NUMERIC || \n                m_Type == DATE || \n                m_Type == STRING || \n                m_Type == NOMINAL;\n  */\n\n  /** The attribute's values (if nominal or string). */\n  private /*@ spec_public @*/ FastVector m_Values;\n\n  /** Mapping of values to indices (if nominal or string). */\n  private Hashtable m_Hashtable;\n\n  /** Date format specification for date attributes */\n  private SimpleDateFormat m_DateFormat;\n\n  /** The attribute's index. */\n  private /*@ spec_public @*/ int m_Index;\n\n  /** The attribute's metadata. */\n  private ProtectedProperties m_Metadata;\n\n  /** The attribute's ordering. */\n  private int m_Ordering;\n\n  /** Whether the attribute is regular. */\n  private boolean m_IsRegular;\n\n  /** Whether the attribute is averagable. */\n  private boolean m_IsAveragable;\n\n  /** Whether the attribute has a zeropoint. */\n  private boolean m_HasZeropoint;\n\n  /** The attribute's weight. */\n  private double m_Weight;\n\n  /** The attribute's lower numeric bound. */\n  private double m_LowerBound;\n\n  /** Whether the lower bound is open. */\n  private boolean m_LowerBoundIsOpen;\n\n  /** The attribute's upper numeric bound. */\n  private double m_UpperBound;\n\n  /** Whether the upper bound is open */\n  private boolean m_UpperBoundIsOpen;\n\n  /**\n   * Constructor for a numeric attribute.\n   *\n   * @param attributeName the name for the attribute\n   */\n  //@ requires attributeName != null;\n  //@ ensures  m_Name == attributeName;\n  public Attribute(String attributeName) {\n\n    this(attributeName, new ProtectedProperties(new Properties()));\n  }\n\n  /**\n   * Constructor for a numeric attribute, where metadata is supplied.\n   *\n   * @param attributeName the name for the attribute\n   * @param metadata the attribute's properties\n   */\n  //@ requires attributeName != null;\n  //@ requires metadata != null;\n  //@ ensures  m_Name == attributeName;\n  public Attribute(String attributeName, ProtectedProperties metadata) {\n\n    m_Name = attributeName;\n    m_Index = -1;\n    m_Values = null;\n    m_Hashtable = null;\n    m_Type = NUMERIC;\n    setMetadata(metadata);\n  }\n\n  /**\n   * Constructor for a date attribute.\n   *\n   * @param attributeName the name for the attribute\n   * @param dateFormat a string suitable for use with\n   * SimpleDateFormatter for parsing dates.\n   */\n  //@ requires attributeName != null;\n  //@ requires dateFormat != null;\n  //@ ensures  m_Name == attributeName;\n  public Attribute(String attributeName, String dateFormat) {\n\n    this(attributeName, dateFormat,\n\t new ProtectedProperties(new Properties()));\n  }\n\n  /**\n   * Constructor for a date attribute, where metadata is supplied.\n   *\n   * @param attributeName the name for the attribute\n   * @param dateFormat a string suitable for use with\n   * SimpleDateFormatter for parsing dates.\n   * @param metadata the attribute's properties\n   */\n  //@ requires attributeName != null;\n  //@ requires dateFormat != null;\n  //@ requires metadata != null;\n  //@ ensures  m_Name == attributeName;\n  public Attribute(String attributeName, String dateFormat,\n\t\t   ProtectedProperties metadata) {\n\n    m_Name = attributeName;\n    m_Index = -1;\n    m_Values = null;\n    m_Hashtable = null;\n    m_Type = DATE;\n    if (dateFormat != null) {\n      m_DateFormat = new SimpleDateFormat(dateFormat);\n    } else {\n      m_DateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n    }\n    m_DateFormat.setLenient(false);\n    setMetadata(metadata);\n  }\n\n  /**\n   * Constructor for nominal attributes and string attributes.\n   * If a null vector of attribute values is passed to the method,\n   * the attribute is assumed to be a string.\n   *\n   * @param attributeName the name for the attribute\n   * @param attributeValues a vector of strings denoting the \n   * attribute values. Null if the attribute is a string attribute.\n   */\n  //@ requires attributeName != null;\n  //@ ensures  m_Name == attributeName;\n  public Attribute(String attributeName, \n\t\t   FastVector attributeValues) {\n\n    this(attributeName, attributeValues,\n\t new ProtectedProperties(new Properties()));\n  }\n\n  /**\n   * Constructor for nominal attributes and string attributes, where\n   * metadata is supplied. If a null vector of attribute values is passed\n   * to the method, the attribute is assumed to be a string.\n   *\n   * @param attributeName the name for the attribute\n   * @param attributeValues a vector of strings denoting the \n   * attribute values. Null if the attribute is a string attribute.\n   * @param metadata the attribute's properties\n   */\n  //@ requires attributeName != null;\n  //@ requires metadata != null;\n  /*@ ensures  m_Name == attributeName;\n      ensures  m_Index == -1;\n      ensures  attributeValues == null \u0026\u0026 m_Type == STRING\n            || attributeValues != null \u0026\u0026 m_Type == NOMINAL \n                  \u0026\u0026 m_Values.size() == attributeValues.size();\n      signals (IllegalArgumentException ex) \n                 (* if duplicate strings in attributeValues *);\n  */\n  public Attribute(String attributeName, \n\t\t   FastVector attributeValues,\n\t\t   ProtectedProperties metadata) {\n\n    m_Name = attributeName;\n    m_Index = -1;\n    if (attributeValues == null) {\n      m_Values = new FastVector();\n      m_Hashtable = new Hashtable();\n      m_Type = STRING;\n    } else {\n      m_Values = new FastVector(attributeValues.size());\n      m_Hashtable = new Hashtable(attributeValues.size());\n      for (int i = 0; i \u003c attributeValues.size(); i++) {\n\tObject store = attributeValues.elementAt(i);\n\tif (((String)store).length() \u003e STRING_COMPRESS_THRESHOLD) {\n\t  try {\n\t    store = new SerializedObject(attributeValues.elementAt(i), true);\n\t  } catch (Exception ex) {\n\t    System.err.println(\"Couldn't compress nominal attribute value -\"\n\t\t\t       + \" storing uncompressed.\");\n\t  }\n\t}\n\tif (m_Hashtable.containsKey(store)) {\n\t  throw new IllegalArgumentException(\"A nominal attribute (\" +\n\t\t\t\t\t     attributeName + \") cannot\"\n\t\t\t\t\t     + \" have duplicate labels (\" + store + \").\");\n\t}\n\tm_Values.addElement(store);\n\tm_Hashtable.put(store, new Integer(i));\n      }\n      m_Type = NOMINAL;\n    }\n    setMetadata(metadata);\n  }\n\n  /**\n   * Produces a shallow copy of this attribute.\n   *\n   * @return a copy of this attribute with the same index\n   */\n  //@ also ensures \\result instanceof Attribute;\n  public /*@ pure non_null @*/ Object copy() {\n\n    Attribute copy = new Attribute(m_Name);\n\n    copy.m_Index = m_Index;\n    copy.m_Type = m_Type;\n    copy.m_Values = m_Values;\n    copy.m_Hashtable = m_Hashtable;\n    copy.m_DateFormat = m_DateFormat;\n    copy.setMetadata(m_Metadata);\n \n    return copy;\n  }\n\n  /**\n   * Returns an enumeration of all the attribute's values if\n   * the attribute is nominal or a string, null otherwise. \n   *\n   * @return enumeration of all the attribute's values\n   */\n  public final /*@ pure @*/ Enumeration enumerateValues() {\n\n    if (isNominal() || isString()) {\n      final Enumeration ee = m_Values.elements();\n      return new Enumeration () {\n          public boolean hasMoreElements() {\n            return ee.hasMoreElements();\n          }\n          public Object nextElement() {\n            Object oo = ee.nextElement();\n            if (oo instanceof SerializedObject) {\n              return ((SerializedObject)oo).getObject();\n            } else {\n              return oo;\n            }\n          }\n        };\n    }\n    return null;\n  }\n\n  /**\n   * Tests if given attribute is equal to this attribute.\n   *\n   * @param other the Object to be compared to this attribute\n   * @return true if the given attribute is equal to this attribute\n   */\n  public final /*@ pure @*/ boolean equals(Object other) {\n\n    if ((other == null) || !(other.getClass().equals(this.getClass()))) {\n      return false;\n    }\n    Attribute att = (Attribute) other;\n    if (!m_Name.equals(att.m_Name)) {\n      return false;\n    }\n    if (isNominal() \u0026\u0026 att.isNominal()) {\n      if (m_Values.size() != att.m_Values.size()) {\n        return false;\n      }\n      for (int i = 0; i \u003c m_Values.size(); i++) {\n        if (!m_Values.elementAt(i).equals(att.m_Values.elementAt(i))) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n      return (type() == att.type());\n    }\n  }\n\n  /**\n   * Returns the index of this attribute.\n   *\n   * @return the index of this attribute\n   */\n  //@ ensures \\result == m_Index;\n  public final /*@ pure @*/ int index() {\n\n    return m_Index;\n  }\n\n  /**\n   * Returns the index of a given attribute value. (The index of\n   * the first occurence of this value.)\n   *\n   * @param value the value for which the index is to be returned\n   * @return the index of the given attribute value if attribute\n   * is nominal or a string, -1 if it is numeric or the value \n   * can't be found\n   */\n  public final int indexOfValue(String value) {\n\n    if (!isNominal() \u0026\u0026 !isString())\n      return -1;\n    Object store = value;\n    if (value.length() \u003e STRING_COMPRESS_THRESHOLD) {\n      try {\n        store = new SerializedObject(value, true);\n      } catch (Exception ex) {\n        System.err.println(\"Couldn't compress string attribute value -\"\n                           + \" searching uncompressed.\");\n      }\n    }\n    Integer val = (Integer)m_Hashtable.get(store);\n    if (val == null) return -1;\n    else return val.intValue();\n  }\n\n  /**\n   * Test if the attribute is nominal.\n   *\n   * @return true if the attribute is nominal\n   */\n  //@ ensures \\result \u003c==\u003e (m_Type == NOMINAL);\n  public final /*@ pure @*/ boolean isNominal() {\n\n    return (m_Type == NOMINAL);\n  }\n\n  /**\n   * Tests if the attribute is numeric.\n   *\n   * @return true if the attribute is numeric\n   */\n  //@ ensures \\result \u003c==\u003e ((m_Type == NUMERIC) || (m_Type == DATE));\n  public final /*@ pure @*/ boolean isNumeric() {\n\n    return ((m_Type == NUMERIC) || (m_Type == DATE));\n  }\n\n  /**\n   * Tests if the attribute is a string.\n   *\n   * @return true if the attribute is a string\n   */\n  //@ ensures \\result \u003c==\u003e (m_Type == STRING);\n  public final /*@ pure @*/ boolean isString() {\n\n    return (m_Type == STRING);\n  }\n\n  /**\n   * Tests if the attribute is a date type.\n   *\n   * @return true if the attribute is a date type\n   */\n  //@ ensures \\result \u003c==\u003e (m_Type == DATE);\n  public final /*@ pure @*/ boolean isDate() {\n\n    return (m_Type == DATE);\n  }\n\n  /**\n   * Returns the attribute's name.\n   *\n   * @return the attribute's name as a string\n   */\n  //@ ensures \\result == m_Name;\n  public final /*@ pure @*/ String name() {\n\n    return m_Name;\n  }\n  \n  /**\n   * Returns the number of attribute values. Returns 0 for numeric attributes.\n   *\n   * @return the number of attribute values\n   */\n  public final /*@ pure @*/ int numValues() {\n\n    if (!isNominal() \u0026\u0026 !isString()) {\n      return 0;\n    } else {\n      return m_Values.size();\n    }\n  }\n\n  /**\n   * Returns a description of this attribute in ARFF format. Quotes\n   * strings if they contain whitespace characters, or if they\n   * are a question mark.\n   *\n   * @return a description of this attribute as a string\n   */\n  public final String toString() {\n    \n    StringBuffer text = new StringBuffer();\n    \n    text.append(ARFF_ATTRIBUTE).append(\" \").append(Utils.quote(m_Name)).append(\" \");\n    switch (m_Type) {\n    case NOMINAL:\n      text.append('{');\n      Enumeration enu = enumerateValues();\n      while (enu.hasMoreElements()) {\n\ttext.append(Utils.quote((String) enu.nextElement()));\n\tif (enu.hasMoreElements())\n\t  text.append(',');\n      }\n      text.append('}');\n      break;\n    case NUMERIC:\n      text.append(ARFF_ATTRIBUTE_NUMERIC);\n      break;\n    case STRING:\n      text.append(ARFF_ATTRIBUTE_STRING);\n      break;\n    case DATE:\n      text.append(ARFF_ATTRIBUTE_DATE).append(\" \").append(Utils.quote(m_DateFormat.toPattern()));\n      break;\n    default:\n      text.append(\"UNKNOWN\");\n      break;\n    }\n    return text.toString();\n  }\n\n  /**\n   * Returns the attribute's type as an integer.\n   *\n   * @return the attribute's type.\n   */\n  //@ ensures \\result == m_Type;\n  public final /*@ pure @*/ int type() {\n\n    return m_Type;\n  }\n\n  /**\n   * Returns a value of a nominal or string attribute. \n   * Returns an empty string if the attribute is neither\n   * nominal nor a string attribute.\n   *\n   * @param valIndex the value's index\n   * @return the attribute's value as a string\n   */\n  public final /*@ non_null pure @*/ String value(int valIndex) {\n    \n    if (!isNominal() \u0026\u0026 !isString()) {\n      return \"\";\n    } else {\n      Object val = m_Values.elementAt(valIndex);\n      \n      // If we're storing strings compressed, uncompress it.\n      if (val instanceof SerializedObject) {\n        val = ((SerializedObject)val).getObject();\n      }\n      return (String) val;\n    }\n  }\n\n  /**\n   * Constructor for a numeric attribute with a particular index.\n   *\n   * @param attributeName the name for the attribute\n   * @param index the attribute's index\n   */\n  //@ requires attributeName != null;\n  //@ requires index \u003e= 0;\n  //@ ensures  m_Name == attributeName;\n  //@ ensures  m_Index == index;\n  Attribute(String attributeName, int index) {\n\n    this(attributeName);\n    m_Index = index;\n  }\n\n  /**\n   * Constructor for date attributes with a particular index.\n   *\n   * @param attributeName the name for the attribute\n   * @param dateFormat a string suitable for use with\n   * SimpleDateFormatter for parsing dates.  Null for a default format\n   * string.\n   * @param index the attribute's index\n   */\n  //@ requires attributeName != null;\n  //@ requires index \u003e= 0;\n  //@ ensures  m_Name == attributeName;\n  //@ ensures  m_Index == index;\n  Attribute(String attributeName, String dateFormat, \n\t    int index) {\n\n    this(attributeName, dateFormat);\n    m_Index = index;\n  }\n\n  /**\n   * Constructor for nominal attributes and string attributes with\n   * a particular index.\n   * If a null vector of attribute values is passed to the method,\n   * the attribute is assumed to be a string.\n   *\n   * @param attributeName the name for the attribute\n   * @param attributeValues a vector of strings denoting the attribute values.\n   * Null if the attribute is a string attribute.\n   * @param index the attribute's index\n   */\n  //@ requires attributeName != null;\n  //@ requires index \u003e= 0;\n  //@ ensures  m_Name == attributeName;\n  //@ ensures  m_Index == index;\n  Attribute(String attributeName, FastVector attributeValues, \n\t    int index) {\n\n    this(attributeName, attributeValues);\n    m_Index = index;\n  }\n\n  /**\n   * Adds a string value to the list of valid strings for attributes\n   * of type STRING and returns the index of the string.\n   *\n   * @param value The string value to add\n   * @return the index assigned to the string, or -1 if the attribute is not\n   * of type Attribute.STRING \n   */\n  /*@ requires value != null;\n      ensures  isString() \u0026\u0026 0 \u003c= \\result \u0026\u0026 \\result \u003c m_Values.size() ||\n             ! isString() \u0026\u0026 \\result == -1;\n  */\n  public int addStringValue(String value) {\n\n    if (!isString()) {\n      return -1;\n    }\n    Object store = value;\n\n    if (value.length() \u003e STRING_COMPRESS_THRESHOLD) {\n      try {\n        store = new SerializedObject(value, true);\n      } catch (Exception ex) {\n        System.err.println(\"Couldn't compress string attribute value -\"\n                           + \" storing uncompressed.\");\n      }\n    }\n    Integer index = (Integer)m_Hashtable.get(store);\n    if (index != null) {\n      return index.intValue();\n    } else {\n      int intIndex = m_Values.size();\n      m_Values.addElement(store);\n      m_Hashtable.put(store, new Integer(intIndex));\n      return intIndex;\n    }\n  }\n\n  /**\n   * Adds a string value to the list of valid strings for attributes\n   * of type STRING and returns the index of the string. This method is\n   * more efficient than addStringValue(String) for long strings.\n   *\n   * @param src The Attribute containing the string value to add.\n   * @param int index the index of the string value in the source attribute.\n   * @return the index assigned to the string, or -1 if the attribute is not\n   * of type Attribute.STRING \n   */\n  /*@ requires src != null;\n      requires 0 \u003c= index \u0026\u0026 index \u003c src.m_Values.size();\n      ensures  isString() \u0026\u0026 0 \u003c= \\result \u0026\u0026 \\result \u003c m_Values.size() ||\n             ! isString() \u0026\u0026 \\result == -1;\n  */\n  public int addStringValue(Attribute src, int index) {\n\n    if (!isString()) {\n      return -1;\n    }\n    Object store = src.m_Values.elementAt(index);\n    Integer oldIndex = (Integer)m_Hashtable.get(store);\n    if (oldIndex != null) {\n      return oldIndex.intValue();\n    } else {\n      int intIndex = m_Values.size();\n      m_Values.addElement(store);\n      m_Hashtable.put(store, new Integer(intIndex));\n      return intIndex;\n    }\n  }\n\n  /**\n   * Adds an attribute value. Creates a fresh list of attribute\n   * values before adding it.\n   *\n   * @param value the attribute value\n   */\n  final void addValue(String value) {\n\n    m_Values = (FastVector)m_Values.copy();\n    m_Hashtable = (Hashtable)m_Hashtable.clone();\n    forceAddValue(value);\n  }\n\n  /**\n   * Produces a shallow copy of this attribute with a new name.\n   *\n   * @param newName the name of the new attribute\n   * @return a copy of this attribute with the same index\n   */\n  //@ requires newName != null;\n  //@ ensures \\result.m_Name  == newName;\n  //@ ensures \\result.m_Index == m_Index;\n  //@ ensures \\result.m_Type  == m_Type;\n  final /*@ pure non_null @*/ Attribute copy(String newName) {\n\n    Attribute copy = new Attribute(newName);\n\n    copy.m_Index = m_Index;\n    copy.m_DateFormat = m_DateFormat;\n    copy.m_Type = m_Type;\n    copy.m_Values = m_Values;\n    copy.m_Hashtable = m_Hashtable;\n    copy.setMetadata(m_Metadata);\n \n    return copy;\n  }\n\n  /**\n   * Removes a value of a nominal or string attribute. Creates a \n   * fresh list of attribute values before removing it.\n   *\n   * @param index the value's index\n   * @exception IllegalArgumentException if the attribute is not nominal\n   */\n  //@ requires isNominal() || isString();\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Values.size();\n  final void delete(int index) {\n    \n    if (!isNominal() \u0026\u0026 !isString()) \n      throw new IllegalArgumentException(\"Can only remove value of\" +\n                                         \"nominal or string attribute!\");\n    else {\n      m_Values = (FastVector)m_Values.copy();\n      m_Values.removeElementAt(index);\n      Hashtable hash = new Hashtable(m_Hashtable.size());\n      Enumeration enu = m_Hashtable.keys();\n      while (enu.hasMoreElements()) {\n\tObject string = enu.nextElement();\n\tInteger valIndexObject = (Integer)m_Hashtable.get(string);\n\tint valIndex = valIndexObject.intValue();\n\tif (valIndex \u003e index) {\n\t  hash.put(string, new Integer(valIndex - 1));\n\t} else if (valIndex \u003c index) {\n\t  hash.put(string, valIndexObject);\n\t}\n      }\n      m_Hashtable = hash;\n    }\n  }\n\n  /**\n   * Adds an attribute value.\n   *\n   * @param value the attribute value\n   */\n  //@ requires value != null;\n  //@ ensures  m_Values.size() == \\old(m_Values.size()) + 1;\n  final void forceAddValue(String value) {\n\n    Object store = value;\n    if (value.length() \u003e STRING_COMPRESS_THRESHOLD) {\n      try {\n        store = new SerializedObject(value, true);\n      } catch (Exception ex) {\n        System.err.println(\"Couldn't compress string attribute value -\"\n                           + \" storing uncompressed.\");\n      }\n    }\n    m_Values.addElement(store);\n    m_Hashtable.put(store, new Integer(m_Values.size() - 1));\n  }\n\n  /**\n   * Sets the index of this attribute.\n   *\n   * @param the index of this attribute\n   */\n  //@ requires 0 \u003c= index;\n  //@ assignable m_Index;\n  //@ ensures m_Index == index;\n  final void setIndex(int index) {\n\n    m_Index = index;\n  }\n\n  /**\n   * Sets a value of a nominal attribute or string attribute.\n   * Creates a fresh list of attribute values before it is set.\n   *\n   * @param index the value's index\n   * @param string the value\n   * @exception IllegalArgumentException if the attribute is not nominal or \n   * string.\n   */\n  //@ requires string != null;\n  //@ requires isNominal() || isString();\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Values.size();\n  final void setValue(int index, String string) {\n    \n    switch (m_Type) {\n    case NOMINAL:\n    case STRING:\n      m_Values = (FastVector)m_Values.copy();\n      m_Hashtable = (Hashtable)m_Hashtable.clone();\n      Object store = string;\n      if (string.length() \u003e STRING_COMPRESS_THRESHOLD) {\n        try {\n          store = new SerializedObject(string, true);\n        } catch (Exception ex) {\n          System.err.println(\"Couldn't compress string attribute value -\"\n                             + \" storing uncompressed.\");\n        }\n      }\n      m_Hashtable.remove(m_Values.elementAt(index));\n      m_Values.setElementAt(store, index);\n      m_Hashtable.put(store, new Integer(index));\n      break;\n    default:\n      throw new IllegalArgumentException(\"Can only set values for nominal\"\n                                         + \" or string attributes!\");\n    }\n  }\n\n  //@ requires isDate();\n  public /*@pure@*/ String formatDate(double date) {\n    switch (m_Type) {\n    case DATE:\n      return m_DateFormat.format(new Date((long)date));\n    default:\n      throw new IllegalArgumentException(\"Can only format date values for date\"\n                                         + \" attributes!\");\n    }\n  }\n\n  //@ requires isDate();\n  //@ requires string != null;\n  public double parseDate(String string) throws ParseException {\n    switch (m_Type) {\n    case DATE:\n      long time = m_DateFormat.parse(string).getTime();\n      // TODO put in a safety check here if we can't store the value in a double.\n      return (double)time;\n    default:\n      throw new IllegalArgumentException(\"Can only parse date values for date\"\n                                         + \" attributes!\");\n    }\n  }\n\n  /**\n   * Returns the properties supplied for this attribute.\n   *\n   * @return metadata for this attribute\n   */  \n  public final /*@ pure @*/ ProtectedProperties getMetadata() {\n\n    return m_Metadata;\n  }\n\n  /**\n   * Returns the ordering of the attribute. One of the following:\n   * \n   * ORDERING_SYMBOLIC - attribute values should be treated as symbols.\n   * ORDERING_ORDERED  - attribute values have a global ordering.\n   * ORDERING_MODULO   - attribute values have an ordering which wraps.\n   *\n   * @return the ordering type of the attribute\n   */\n  public final /*@ pure @*/ int ordering() {\n\n    return m_Ordering;\n  }\n\n  /**\n   * Returns whether the attribute values are equally spaced.\n   *\n   * @return whether the attribute is regular or not\n   */\n  public final /*@ pure @*/ boolean isRegular() {\n\n    return m_IsRegular;\n  }\n\n  /**\n   * Returns whether the attribute can be averaged meaningfully.\n   *\n   * @return whether the attribute can be averaged or not\n   */\n  public final /*@ pure @*/ boolean isAveragable() {\n\n    return m_IsAveragable;\n  }\n\n  /**\n   * Returns whether the attribute has a zeropoint and may be\n   * added meaningfully.\n   *\n   * @return whether the attribute has a zeropoint or not\n   */\n  public final /*@ pure @*/ boolean hasZeropoint() {\n\n    return m_HasZeropoint;\n  }\n\n  /**\n   * Returns the attribute's weight.\n   *\n   * @return the attribute's weight as a double\n   */\n  public final /*@ pure @*/ double weight() {\n\n    return m_Weight;\n  }\n\n  /**\n   * Returns the lower bound of a numeric attribute.\n   *\n   * @return the lower bound of the specified numeric range\n   */\n  public final /*@ pure @*/ double getLowerNumericBound() {\n\n    return m_LowerBound;\n  }\n\n  /**\n   * Returns whether the lower numeric bound of the attribute is open.\n   *\n   * @return whether the lower numeric bound is open or not (closed)\n   */\n  public final /*@ pure @*/ boolean lowerNumericBoundIsOpen() {\n\n    return m_LowerBoundIsOpen;\n  }\n\n  /**\n   * Returns the upper bound of a numeric attribute.\n   *\n   * @return the upper bound of the specified numeric range\n   */\n  public final /*@ pure @*/ double getUpperNumericBound() {\n\n    return m_UpperBound;\n  }\n\n  /**\n   * Returns whether the upper numeric bound of the attribute is open.\n   *\n   * @return whether the upper numeric bound is open or not (closed)\n   */\n  public final /*@ pure @*/ boolean upperNumericBoundIsOpen() {\n\n    return m_UpperBoundIsOpen;\n  }\n\n  /**\n   * Determines whether a value lies within the bounds of the attribute.\n   *\n   * @return whether the value is in range\n   */\n  public final /*@ pure @*/ boolean isInRange(double value) {\n\n    // dates and missing values are a special case \n    if (m_Type == DATE || value == Instance.missingValue()) return true;\n    if (m_Type != NUMERIC) {\n      // do label range check\n      int intVal = (int) value;\n      if (intVal \u003c 0 || intVal \u003e= m_Hashtable.size()) return false;\n    } else {\n      // do numeric bounds check\n      if (m_LowerBoundIsOpen) {\n\tif (value \u003c= m_LowerBound) return false;\n      } else {\n\tif (value \u003c m_LowerBound) return false;\n      }\n      if (m_UpperBoundIsOpen) {\n\tif (value \u003e= m_UpperBound) return false;\n      } else {\n\tif (value \u003e m_UpperBound) return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Sets the metadata for the attribute. Processes the strings stored in the\n   * metadata of the attribute so that the properties can be set up for the\n   * easy-access metadata methods. Any strings sought that are omitted will\n   * cause default values to be set.\n   * \n   * The following properties are recognised:\n   * ordering, averageable, zeropoint, regular, weight, and range.\n   *\n   * All other properties can be queried and handled appropriately by classes\n   * calling the getMetadata() method.\n   *\n   * @param metadata the metadata\n   * @exception IllegalArgumentException if the properties are not consistent\n   */\n  //@ requires metadata != null;\n  private void setMetadata(ProtectedProperties metadata) {\n    \n    m_Metadata = metadata;\n\n    if (m_Type == DATE) {\n      m_Ordering = ORDERING_ORDERED;\n      m_IsRegular = true;\n      m_IsAveragable = false;\n      m_HasZeropoint = false;\n    } else {\n\n      // get ordering\n      String orderString = m_Metadata.getProperty(\"ordering\",\"\");\n      \n      // numeric ordered attributes are averagable and zeropoint by default\n      String def;\n      if (m_Type == NUMERIC\n\t  \u0026\u0026 orderString.compareTo(\"modulo\") != 0\n\t  \u0026\u0026 orderString.compareTo(\"symbolic\") != 0)\n\tdef = \"true\";\n      else def = \"false\";\n      \n      // determine boolean states\n      m_IsAveragable =\n\t(m_Metadata.getProperty(\"averageable\",def).compareTo(\"true\") == 0);\n      m_HasZeropoint =\n\t(m_Metadata.getProperty(\"zeropoint\",def).compareTo(\"true\") == 0);\n      // averagable or zeropoint implies regular\n      if (m_IsAveragable || m_HasZeropoint) def = \"true\";\n      m_IsRegular =\n\t(m_Metadata.getProperty(\"regular\",def).compareTo(\"true\") == 0);\n      \n      // determine ordering\n      if (orderString.compareTo(\"symbolic\") == 0)\n\tm_Ordering = ORDERING_SYMBOLIC;\n      else if (orderString.compareTo(\"ordered\") == 0)\n\tm_Ordering = ORDERING_ORDERED;\n      else if (orderString.compareTo(\"modulo\") == 0)\n\tm_Ordering = ORDERING_MODULO;\n      else {\n\tif (m_Type == NUMERIC || m_IsAveragable || m_HasZeropoint)\n\t  m_Ordering = ORDERING_ORDERED;\n\telse m_Ordering = ORDERING_SYMBOLIC;\n      }\n    }\n\n    // consistency checks\n    if (m_IsAveragable \u0026\u0026 !m_IsRegular)\n      throw new IllegalArgumentException(\"An averagable attribute must be\"\n\t\t\t\t\t + \" regular\");\n    if (m_HasZeropoint \u0026\u0026 !m_IsRegular)\n      throw new IllegalArgumentException(\"A zeropoint attribute must be\"\n\t\t\t\t\t + \" regular\");\n    if (m_IsRegular \u0026\u0026 m_Ordering == ORDERING_SYMBOLIC)\n      throw new IllegalArgumentException(\"A symbolic attribute cannot be\"\n\t\t\t\t\t + \" regular\");\n    if (m_IsAveragable \u0026\u0026 m_Ordering != ORDERING_ORDERED)\n      throw new IllegalArgumentException(\"An averagable attribute must be\"\n\t\t\t\t\t + \" ordered\");\n    if (m_HasZeropoint \u0026\u0026 m_Ordering != ORDERING_ORDERED)\n      throw new IllegalArgumentException(\"A zeropoint attribute must be\"\n\t\t\t\t\t + \" ordered\");\n\n    // determine weight\n    m_Weight = 1.0;\n    String weightString = m_Metadata.getProperty(\"weight\");\n    if (weightString != null) {\n      try{\n\tm_Weight = Double.valueOf(weightString).doubleValue();\n      } catch (NumberFormatException e) {\n\t// Check if value is really a number\n\tthrow new IllegalArgumentException(\"Not a valid attribute weight: '\" \n\t\t\t\t\t   + weightString + \"'\");\n      }\n    }\n\n    // determine numeric range\n    if (m_Type == NUMERIC) setNumericRange(m_Metadata.getProperty(\"range\"));\n  }\n\n  /**\n   * Sets the numeric range based on a string. If the string is null the range\n   * will default to [-inf,+inf]. A square brace represents a closed interval, a\n   * curved brace represents an open interval, and 'inf' represents infinity.\n   * Examples of valid range strings: \"[-inf,20)\",\"(-13.5,-5.2)\",\"(5,inf]\"\n   *\n   * @param rangeString the string to parse as the attribute's numeric range\n   * @exception IllegalArgumentException if the range is not valid\n   */\n  //@ requires rangeString != null;\n  private void setNumericRange(String rangeString)\n  {\n    // set defaults\n    m_LowerBound = Double.NEGATIVE_INFINITY;\n    m_LowerBoundIsOpen = false;\n    m_UpperBound = Double.POSITIVE_INFINITY;\n    m_UpperBoundIsOpen = false;\n\n    if (rangeString == null) return;\n\n    // set up a tokenzier to parse the string\n    StreamTokenizer tokenizer =\n      new StreamTokenizer(new StringReader(rangeString));\n    tokenizer.resetSyntax();         \n    tokenizer.whitespaceChars(0, ' ');    \n    tokenizer.wordChars(' '+1,'\\u00FF');\n    tokenizer.ordinaryChar('[');\n    tokenizer.ordinaryChar('(');\n    tokenizer.ordinaryChar(',');\n    tokenizer.ordinaryChar(']');\n    tokenizer.ordinaryChar(')');\n\n    try {\n\n      // get opening brace\n      tokenizer.nextToken();\n    \n      if (tokenizer.ttype == '[') m_LowerBoundIsOpen = false;\n      else if (tokenizer.ttype == '(') m_LowerBoundIsOpen = true;\n      else throw new IllegalArgumentException(\"Expected opening brace on range,\"\n\t\t\t\t\t      + \" found: \"\n\t\t\t\t\t      + tokenizer.toString());\n\n      // get lower bound\n      tokenizer.nextToken();\n      if (tokenizer.ttype != tokenizer.TT_WORD)\n\tthrow new IllegalArgumentException(\"Expected lower bound in range,\"\n\t\t\t\t\t   + \" found: \"\n\t\t\t\t\t   + tokenizer.toString());\n      if (tokenizer.sval.compareToIgnoreCase(\"-inf\") == 0)\n\tm_LowerBound = Double.NEGATIVE_INFINITY;\n      else if (tokenizer.sval.compareToIgnoreCase(\"+inf\") == 0)\n\tm_LowerBound = Double.POSITIVE_INFINITY;\n      else if (tokenizer.sval.compareToIgnoreCase(\"inf\") == 0)\n\tm_LowerBound = Double.NEGATIVE_INFINITY;\n      else try {\n\tm_LowerBound = Double.valueOf(tokenizer.sval).doubleValue();\n      } catch (NumberFormatException e) {\n\tthrow new IllegalArgumentException(\"Expected lower bound in range,\"\n\t\t\t\t\t   + \" found: '\" + tokenizer.sval + \"'\");\n      }\n\n      // get separating comma\n      if (tokenizer.nextToken() != ',')\n\tthrow new IllegalArgumentException(\"Expected comma in range,\"\n\t\t\t\t\t   + \" found: \"\n\t\t\t\t\t   + tokenizer.toString());\n\n      // get upper bound\n      tokenizer.nextToken();\n      if (tokenizer.ttype != tokenizer.TT_WORD)\n\tthrow new IllegalArgumentException(\"Expected upper bound in range,\"\n\t\t\t\t\t   + \" found: \"\n\t\t\t\t\t   + tokenizer.toString());\n      if (tokenizer.sval.compareToIgnoreCase(\"-inf\") == 0)\n\tm_UpperBound = Double.NEGATIVE_INFINITY;\n      else if (tokenizer.sval.compareToIgnoreCase(\"+inf\") == 0)\n\tm_UpperBound = Double.POSITIVE_INFINITY;\n      else if (tokenizer.sval.compareToIgnoreCase(\"inf\") == 0)\n\tm_UpperBound = Double.POSITIVE_INFINITY;\n      else try {\n\tm_UpperBound = Double.valueOf(tokenizer.sval).doubleValue();\n      } catch (NumberFormatException e) {\n\tthrow new IllegalArgumentException(\"Expected upper bound in range,\"\n\t\t\t\t\t   + \" found: '\" + tokenizer.sval + \"'\");\n      }\n\n      // get closing brace\n      tokenizer.nextToken();\n    \n      if (tokenizer.ttype == ']') m_UpperBoundIsOpen = false;\n      else if (tokenizer.ttype == ')') m_UpperBoundIsOpen = true;\n      else throw new IllegalArgumentException(\"Expected closing brace on range,\"\n\t\t\t\t\t      + \" found: \"\n\t\t\t\t\t      + tokenizer.toString());\n\n      // check for rubbish on end\n      if (tokenizer.nextToken() != tokenizer.TT_EOF)\n\tthrow new IllegalArgumentException(\"Expected end of range string,\"\n\t\t\t\t\t   + \" found: \"\n\t\t\t\t\t   + tokenizer.toString());\n\n    } catch (IOException e) {\n      throw new IllegalArgumentException(\"IOException reading attribute range\"\n\t\t\t\t\t + \" string: \" + e.getMessage());\n    }\n\n    if (m_UpperBound \u003c m_LowerBound)\n      throw new IllegalArgumentException(\"Upper bound (\" + m_UpperBound\n\t\t\t\t\t + \") on numeric range is\"\n\t\t\t\t\t + \" less than lower bound (\"\n\t\t\t\t\t + m_LowerBound + \")!\");\n  }\n\n  /**\n   * Simple main method for testing this class.\n   */\n  //@ requires ops != null;\n  //@ requires \\nonnullelements(ops);\n  public static void main(String[] ops) {\n\n    try {\n      \n      // Create numeric attributes \"length\" and \"weight\"\n      Attribute length = new Attribute(\"length\");\n      Attribute weight = new Attribute(\"weight\");\n\n      // Create date attribute \"date\"\n      Attribute date = new Attribute(\"date\", \"yyyy-MM-dd HH:mm:ss\");\n\n      System.out.println(date);\n      double dd = date.parseDate(\"2001-04-04 14:13:55\");\n      System.out.println(\"Test date = \" + dd);\n      System.out.println(date.formatDate(dd));\n\n      dd = new Date().getTime();\n      System.out.println(\"Date now = \" + dd);\n      System.out.println(date.formatDate(dd));\n      \n      // Create vector to hold nominal values \"first\", \"second\", \"third\" \n      FastVector my_nominal_values = new FastVector(3); \n      my_nominal_values.addElement(\"first\"); \n      my_nominal_values.addElement(\"second\"); \n      my_nominal_values.addElement(\"third\"); \n      \n      // Create nominal attribute \"position\" \n      Attribute position = new Attribute(\"position\", my_nominal_values);\n\n      // Print the name of \"position\"\n      System.out.println(\"Name of \\\"position\\\": \" + position.name());\n\n      // Print the values of \"position\"\n      Enumeration attValues = position.enumerateValues();\n      while (attValues.hasMoreElements()) {\n\tString string = (String)attValues.nextElement();\n\tSystem.out.println(\"Value of \\\"position\\\": \" + string);\n      }\n\n      // Shallow copy attribute \"position\"\n      Attribute copy = (Attribute) position.copy();\n\n      // Test if attributes are the same\n      System.out.println(\"Copy is the same as original: \" + copy.equals(position));\n\n      // Print index of attribute \"weight\" (should be unset: -1)\n      System.out.println(\"Index of attribute \\\"weight\\\" (should be -1): \" + \n\t\t\t weight.index());\n\n      // Print index of value \"first\" of attribute \"position\"\n      System.out.println(\"Index of value \\\"first\\\" of \\\"position\\\" (should be 0): \" +\n\t\t\t position.indexOfValue(\"first\"));\n\n      // Tests type of attribute \"position\"\n      System.out.println(\"\\\"position\\\" is numeric: \" + position.isNumeric());\n      System.out.println(\"\\\"position\\\" is nominal: \" + position.isNominal());\n      System.out.println(\"\\\"position\\\" is string: \" + position.isString());\n\n      // Prints name of attribute \"position\"\n      System.out.println(\"Name of \\\"position\\\": \" + position.name());\n    \n      // Prints number of values of attribute \"position\"\n      System.out.println(\"Number of values for \\\"position\\\": \" + position.numValues());\n\n      // Prints the values (againg)\n      for (int i = 0; i \u003c position.numValues(); i++) {\n\tSystem.out.println(\"Value \" + i + \": \" + position.value(i));\n      }\n\n      // Prints the attribute \"position\" in ARFF format\n      System.out.println(position);\n\n      // Checks type of attribute \"position\" using constants\n      switch (position.type()) {\n      case Attribute.NUMERIC:\n\tSystem.out.println(\"\\\"position\\\" is numeric\");\n\tbreak;\n      case Attribute.NOMINAL:\n\tSystem.out.println(\"\\\"position\\\" is nominal\");\n\tbreak;\n      case Attribute.STRING:\n\tSystem.out.println(\"\\\"position\\\" is string\");\n\tbreak;\n      case Attribute.DATE:\n\tSystem.out.println(\"\\\"position\\\" is date\");\n\tbreak;\n      default:\n\tSystem.out.println(\"\\\"position\\\" has unknown type\");\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n  \n",
        "name": "Attribute.java",
        "path": "subjectSystems/C,D/core/Attribute.java",
        "url": "/github.com/LASER-UMASS/Themis/-/blob/subjectSystems/C,D/core/Attribute.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 186,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 199,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 200,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires metadata != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 219,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 220,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires dateFormat != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 236,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 237,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires dateFormat != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 238,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires metadata != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 266,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 285,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 286,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires metadata != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 413,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Index;"
        },
        {
          "limitHit": false,
          "lineNumber": 451,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e (m_Type == NOMINAL);"
        },
        {
          "limitHit": false,
          "lineNumber": 462,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e ((m_Type == NUMERIC) || (m_Type == DATE));"
        },
        {
          "limitHit": false,
          "lineNumber": 473,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e (m_Type == STRING);"
        },
        {
          "limitHit": false,
          "lineNumber": 484,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e (m_Type == DATE);"
        },
        {
          "limitHit": false,
          "lineNumber": 495,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Name;"
        },
        {
          "limitHit": false,
          "lineNumber": 559,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Type;"
        },
        {
          "limitHit": false,
          "lineNumber": 594,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 595,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 613,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 614,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 635,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 636,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 735,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires newName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 736,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result.m_Name  == newName;"
        },
        {
          "limitHit": false,
          "lineNumber": 737,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result.m_Index == m_Index;"
        },
        {
          "limitHit": false,
          "lineNumber": 738,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result.m_Type  == m_Type;"
        },
        {
          "limitHit": false,
          "lineNumber": 760,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires isNominal() || isString();"
        },
        {
          "limitHit": false,
          "lineNumber": 761,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Values.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 791,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires value != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 813,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;"
        },
        {
          "limitHit": false,
          "lineNumber": 815,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Index == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 830,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires string != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 831,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires isNominal() || isString();"
        },
        {
          "limitHit": false,
          "lineNumber": 832,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Values.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 859,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires isDate();"
        },
        {
          "limitHit": false,
          "lineNumber": 870,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires isDate();"
        },
        {
          "limitHit": false,
          "lineNumber": 871,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires string != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1033,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires metadata != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1123,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires rangeString != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1231,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires ops != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1232,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires \\nonnullelements(ops);"
        },
        {
          "limitHit": false,
          "lineNumber": 187,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 201,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 221,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 239,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 267,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 596,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 597,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Index == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 615,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 616,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Index == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 637,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 638,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Index == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 792,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Values.size() == \\old(m_Values.size()) + 1;"
        }
      ],
      "repository": {
        "name": "github.com/LASER-UMASS/Themis",
        "url": "/github.com/LASER-UMASS/Themis"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a70f12a6a8f34cdd8b170b4dc59a78674c9e8950"
        },
        "content": "/*\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; either version 2 of the License, or\n *    (at your option) any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n/*\n *    FastVector.java\n *    Copyright (C) 1999 Eibe Frank\n *\n */\n\npackage weka.core;\n\nimport java.util.*;\nimport java.io.*;\n\n/**\n * Implements a fast vector class without synchronized\n * methods. Replaces java.util.Vector. (Synchronized methods tend to\n * be slow.)\n *\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\n * @version $Revision: 1.11 $ */\npublic class FastVector implements Copyable, Serializable {\n\n  /**\n   * Class for enumerating the vector's elements.\n   */\n  public class FastVectorEnumeration implements Enumeration {\n\n    /** The counter. */\n    private int m_Counter;\n    // These JML commands say how m_Counter implements Enumeration\n    //@ in moreElements;\n    //@ private represents moreElements = m_Counter \u003c m_Vector.size();\n    //@ private invariant 0 \u003c= m_Counter \u0026\u0026 m_Counter \u003c= m_Vector.size();\n\n    /** The vector. */\n    private /*@non_null@*/ FastVector m_Vector;\n\n    /** Special element. Skipped during enumeration. */\n    private int m_SpecialElement;\n    //@ private invariant -1 \u003c= m_SpecialElement;\n    //@ private invariant m_SpecialElement \u003c m_Vector.size();\n    //@ private invariant m_SpecialElement\u003e=0 ==\u003e m_Counter!=m_SpecialElement;\n\n    /**\n     * Constructs an enumeration.\n     *\n     * @param vector the vector which is to be enumerated\n     */\n    public FastVectorEnumeration(/*@non_null@*/FastVector vector) {\n\n      m_Counter = 0;\n      m_Vector = vector;\n      m_SpecialElement = -1;\n    }\n\n    /**\n     * Constructs an enumeration with a special element.\n     * The special element is skipped during the enumeration.\n     *\n     * @param vector the vector which is to be enumerated\n     * @param special the index of the special element\n     */\n    //@ requires 0 \u003c= special \u0026\u0026 special \u003c vector.size();\n    public FastVectorEnumeration(/*@non_null@*/FastVector vector, int special){\n\n      m_Vector = vector;\n      m_SpecialElement = special;\n      if (special == 0) {\n\tm_Counter = 1;\n      } else {\n\tm_Counter = 0;\n      }\n    }\n\n\n    /**\n     * Tests if there are any more elements to enumerate.\n     *\n     * @return true if there are some elements left\n     */\n    public final /*@pure@*/ boolean hasMoreElements() {\n\n      if (m_Counter \u003c m_Vector.size()) {\n\treturn true;\n      }\n      return false;\n    }\n\n    /**\n     * Returns the next element.\n     *\n     * @return the next element to be enumerated\n     */\n    //@ also requires hasMoreElements();\n    public final Object nextElement() {\n  \n      Object result = m_Vector.elementAt(m_Counter);\n\n      m_Counter++;\n      if (m_Counter == m_SpecialElement) {\n\tm_Counter++;\n      }\n      return result;\n    }\n  }\n\n  /** The array of objects. */\n  private /*@spec_public@*/ Object[] m_Objects;\n  //@ invariant m_Objects != null;\n  //@ invariant m_Objects.length \u003e= 0;\n\n  /** The current size; */\n  private /*@spec_public@*/ int m_Size = 0;\n  //@ invariant 0 \u003c= m_Size;\n  //@ invariant m_Size \u003c= m_Objects.length;\n\n  /** The capacity increment */\n  private /*@spec_public@*/ int m_CapacityIncrement = 1;\n  //@ invariant 1 \u003c= m_CapacityIncrement;\n  \n  /** The capacity multiplier. */\n  private /*@spec_public@*/ int m_CapacityMultiplier = 2;\n  //@ invariant 1 \u003c= m_CapacityMultiplier;\n\n  // Make sure the size will increase...\n  //@ invariant 3 \u003c= m_CapacityMultiplier + m_CapacityIncrement;\n\n  /**\n   * Constructs an empty vector with initial\n   * capacity zero.\n   */\n  public FastVector() {\n  \n    m_Objects = new Object[0];\n  }\n\n  /**\n   * Constructs a vector with the given capacity.\n   *\n   * @param capacity the vector's initial capacity\n   */\n  //@ requires capacity \u003e= 0;\n  public FastVector(int capacity) {\n\n    m_Objects = new Object[capacity];\n  }\n\n  /**\n   * Adds an element to this vector. Increases its\n   * capacity if its not large enough.\n   *\n   * @param element the element to add\n   */\n  public final void addElement(Object element) {\n\n    Object[] newObjects;\n\n    if (m_Size == m_Objects.length) {\n      newObjects = new Object[m_CapacityMultiplier *\n\t\t\t     (m_Objects.length +\n\t\t\t      m_CapacityIncrement)];\n      System.arraycopy(m_Objects, 0, newObjects, 0, m_Size);\n      m_Objects = newObjects;\n    }\n    m_Objects[m_Size] = element;\n    m_Size++;\n  }\n\n  /**\n   * Returns the capacity of the vector.\n   *\n   * @return the capacity of the vector\n   */\n  //@ ensures \\result == m_Objects.length;\n  public final /*@pure@*/ int capacity() {\n  \n    return m_Objects.length;\n  }\n\n  /**\n   * Produces a shallow copy of this vector.\n   *\n   * @return the new vector\n   */\n  public final Object copy() {\n\n    FastVector copy = new FastVector(m_Objects.length);\n\n    copy.m_Size = m_Size;\n    copy.m_CapacityIncrement = m_CapacityIncrement;\n    copy.m_CapacityMultiplier = m_CapacityMultiplier;\n    System.arraycopy(m_Objects, 0, copy.m_Objects, 0, m_Size);\n    return copy;\n  }\n\n  /**\n   * Clones the vector and shallow copies all its elements.\n   * The elements have to implement the Copyable interface.\n   * \n   * @return the new vector\n   */\n  public final Object copyElements() {\n\n    FastVector copy = new FastVector(m_Objects.length);\n\n    copy.m_Size = m_Size;\n    copy.m_CapacityIncrement = m_CapacityIncrement;\n    copy.m_CapacityMultiplier = m_CapacityMultiplier;\n    for (int i = 0; i \u003c m_Size; i++) {\n      copy.m_Objects[i] = ((Copyable)m_Objects[i]).copy();\n    }\n    return copy;\n  }\n\n  /**\n   * Returns the element at the given position.\n   *\n   * @param index the element's index\n   * @return the element with the given index\n   */\n  //@ requires 0 \u003c= index;\n  //@ requires index \u003c m_Objects.length;\n  public final /*@pure@*/ Object elementAt(int index) {\n\n    return m_Objects[index];\n  }\n\n  /**\n   * Returns an enumeration of this vector.\n   *\n   * @return an enumeration of this vector\n   */\n  public final /*@pure@*/ Enumeration elements() {\n  \n    return new FastVectorEnumeration(this);\n  }\n\n  /**\n   * Returns an enumeration of this vector, skipping the\n   * element with the given index.\n   *\n   * @param index the element to skip\n   * @return an enumeration of this vector\n   */\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();\n  public final /*@pure@*/ Enumeration elements(int index) {\n  \n    return new FastVectorEnumeration(this, index);\n  }\n\n    /**\n     * added by akibriya\n     */\n  public /*@pure@*/ boolean contains(Object o) {\n      if(o==null)\n\t  return false;\n\n      for(int i=0; i\u003cm_Objects.length; i++) \n\t  if(o.equals(m_Objects[i]))\n\t      return true;\n      \n      return false;\n  }\n\n\n  /**\n   * Returns the first element of the vector.\n   *\n   * @return the first element of the vector\n   */\n  //@ requires m_Size \u003e 0;\n  public final /*@pure@*/ Object firstElement() {\n\n    return m_Objects[0];\n  }\n\n  /**\n   * Searches for the first occurence of the given argument, \n   * testing for equality using the equals method. \n   *\n   * @param element the element to be found\n   * @return the index of the first occurrence of the argument \n   * in this vector; returns -1 if the object is not found\n   */\n  public final /*@pure@*/ int indexOf(/*@non_null@*/ Object element) {\n\n    for (int i = 0; i \u003c m_Size; i++) {\n      if (element.equals(m_Objects[i])) {\n\treturn i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Inserts an element at the given position.\n   *\n   * @param element the element to be inserted\n   * @param index the element's index\n   */\n  public final void insertElementAt(Object element, int index) {\n\n    Object[] newObjects;\n\n    if (m_Size \u003c m_Objects.length) {\n      System.arraycopy(m_Objects, index, m_Objects, index + 1, \n                       m_Size - index);\n      m_Objects[index] = element;\n    } else {\n      newObjects = new Object[m_CapacityMultiplier *\n\t\t\t     (m_Objects.length +\n\t\t\t      m_CapacityIncrement)];\n      System.arraycopy(m_Objects, 0, newObjects, 0, index);\n      newObjects[index] = element;\n      System.arraycopy(m_Objects, index, newObjects, index + 1,\n\t\t       m_Size - index);\n      m_Objects = newObjects;\n    }\n    m_Size++;\n  }\n\n  /**\n   * Returns the last element of the vector.\n   *\n   * @return the last element of the vector\n   */\n  //@ requires m_Size \u003e 0;\n  public final /*@pure@*/ Object lastElement() {\n\n    return m_Objects[m_Size - 1];\n  }\n\n  /**\n   * Deletes an element from this vector.\n   *\n   * @param index the index of the element to be deleted\n   */\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Size;\n  public final void removeElementAt(int index) {\n\n    System.arraycopy(m_Objects, index + 1, m_Objects, index, \n                     m_Size - index - 1);\n    m_Size--;\n  }\n\n  /**\n   * Removes all components from this vector and sets its \n   * size to zero. \n   */\n  public final void removeAllElements() {\n\n    m_Objects = new Object[m_Objects.length];\n    m_Size = 0;\n  }\n\n  /**\n   * Appends all elements of the supplied vector to this vector.\n   *\n   * @param toAppend the FastVector containing elements to append.\n   */\n  public final void appendElements(FastVector toAppend) {\n\n    setCapacity(size() + toAppend.size());\n    System.arraycopy(toAppend.m_Objects, 0, m_Objects, size(), toAppend.size());\n    m_Size = m_Objects.length;\n  }\n\n  /** \n   * Returns all the elements of this vector as an array\n   *\n   * @param an array containing all the elements of this vector\n   */\n  public final Object [] toArray() {\n\n    Object [] newObjects = new Object[size()];\n    System.arraycopy(m_Objects, 0, newObjects, 0, size());\n    return newObjects;\n  }\n\n  /**\n   * Sets the vector's capacity to the given value.\n   *\n   * @param capacity the new capacity\n   */\n  public final void setCapacity(int capacity) {\n\n    Object[] newObjects = new Object[capacity];\n   \n    System.arraycopy(m_Objects, 0, newObjects, 0, Math.min(capacity, m_Size));\n    m_Objects = newObjects;\n    if (m_Objects.length \u003c m_Size)\n      m_Size = m_Objects.length;\n  }\n\n  /**\n   * Sets the element at the given index.\n   *\n   * @param element the element to be put into the vector\n   * @param index the index at which the element is to be placed\n   */\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();\n  public final void setElementAt(Object element, int index) {\n\n    m_Objects[index] = element;\n  }\n\n  /**\n   * Returns the vector's current size.\n   *\n   * @return the vector's current size\n   */\n  //@ ensures \\result == m_Size;\n  public final /*@pure@*/ int size() {\n\n    return m_Size;\n  }\n\n  /**\n   * Swaps two elements in the vector.\n   *\n   * @param first index of the first element\n   * @param second index of the second element\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c size();\n  //@ requires 0 \u003c= second \u0026\u0026 second \u003c size();\n  public final void swap(int first, int second) {\n\n    Object help = m_Objects[first];\n\n    m_Objects[first] = m_Objects[second];\n    m_Objects[second] = help;\n  }\n\n  /**\n   * Sets the vector's capacity to its size.\n   */\n  public final void trimToSize() {\n\n    Object[] newObjects = new Object[m_Size];\n    \n    System.arraycopy(m_Objects, 0, newObjects, 0, m_Size);\n    m_Objects = newObjects;\n  }\n}\n\n",
        "name": "FastVector.java",
        "path": "subjectSystems/C,D/core/FastVector.java",
        "url": "/github.com/LASER-UMASS/Themis/-/blob/subjectSystems/C,D/core/FastVector.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 76,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= special \u0026\u0026 special \u003c vector.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 155,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires capacity \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 187,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Objects.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 234,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;"
        },
        {
          "limitHit": false,
          "lineNumber": 235,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003c m_Objects.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 258,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();"
        },
        {
          "limitHit": false,
          "lineNumber": 284,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Size \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 340,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Size \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 351,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Size;"
        },
        {
          "limitHit": false,
          "lineNumber": 414,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();"
        },
        {
          "limitHit": false,
          "lineNumber": 425,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Size;"
        },
        {
          "limitHit": false,
          "lineNumber": 437,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c size();"
        },
        {
          "limitHit": false,
          "lineNumber": 438,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= second \u0026\u0026 second \u003c size();"
        }
      ],
      "repository": {
        "name": "github.com/LASER-UMASS/Themis",
        "url": "/github.com/LASER-UMASS/Themis"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a70f12a6a8f34cdd8b170b4dc59a78674c9e8950"
        },
        "content": "/*\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; either version 2 of the License, or\n *    (at your option) any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n/*\n *    SingleIndex.java\n *    Copyright (C) 2003 University of Waikato\n *\n */\n\npackage weka.core;\n\nimport java.io.*;\nimport java.util.*;\n\n/** \n * Class representing a single cardinal number. The number is set by a \n * string representation such as: \u003cP\u003e\n *\n * \u003ccode\u003e\n *   first\n *   last\n *   1\n *   3\n * \u003c/code\u003e \u003cP\u003e\n * The number is internally converted from 1-based to 0-based (so methods that \n * set or get numbers not in string format should use 0-based numbers).\n *\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\n * @version $Revision: 1.5 $\n */\npublic class SingleIndex implements Serializable {\n\n  /** Record the string representation of the number */\n  protected /*@non_null spec_public@*/ String m_IndexString = \"\";\n\n  /** The selected index */\n  protected /*@ spec_public @*/ int m_SelectedIndex = -1;\n\n  /** Store the maximum value permitted. -1 indicates that no upper\n      value has been set */\n  protected /*@ spec_public @*/ int m_Upper = -1;\n\n  /**\n   * Default constructor.\n   *\n   */\n  //@ assignable m_IndexString, m_SelectedIndex, m_Upper;\n  //@ ensures m_SelectedIndex == -1;\n  //@ ensures m_Upper == -1;\n  public SingleIndex() {\n  }\n\n  /**\n   * Constructor to set initial index.\n   *\n   * @param rangeList the initial index\n   * @exception IllegalArgumentException if the index is invalid\n   */\n  //@ assignable m_IndexString, m_SelectedIndex, m_Upper;\n  //@ ensures m_IndexString == index;\n  //@ ensures m_SelectedIndex == -1;\n  //@ ensures m_Upper == -1;\n  public SingleIndex(/*@non_null@*/ String index) {\n\n    setSingleIndex(index);\n  }\n\n  /**\n   * Sets the value of \"last\".\n   *\n   * @param newUpper the value of \"last\"\n   */\n  //@ assignable m_Upper, m_IndexString, m_SelectedIndex;\n  //@ ensures newUpper \u003c 0 ==\u003e m_Upper == \\old(m_Upper);\n  //@ ensures newUpper \u003e= 0 ==\u003e m_Upper == newUpper;\n  public void setUpper(int newUpper) {\n\n    if (newUpper \u003e= 0) {\n      m_Upper = newUpper;\n      setValue();\n    }\n  }\n\n  /**\n   * Gets the string representing the selected range of values\n   *\n   * @return the range selection string\n   */\n  //@ ensures \\result == m_IndexString;\n  public /*@pure@*/ String getSingleIndex() {\n\n    return m_IndexString;\n  }\n\n  /**\n   * Sets the index from a string representation. Note that setUpper()\n   * must be called for the value to be actually set\n   *\n   * @param index the index set\n   * @exception IllegalArgumentException if the index was not well formed\n   */\n  //@ assignable m_IndexString, m_SelectedIndex;\n  //@ ensures m_IndexString == index;\n  //@ ensures m_SelectedIndex == -1;\n  public void setSingleIndex(/*@non_null@*/ String index) {\n\n    m_IndexString = index;\n    m_SelectedIndex = -1;\n  }\n\n  /**\n   * Constructs a representation of the current range. Being a string\n   * representation, the numbers are based from 1.\n   * \n   * @return the string representation of the current range\n   */\n  //@ also signals (RuntimeException e) \\old(m_Upper) \u003c 0;\n  //@ ensures \\result != null;\n  public /*@pure@*/ String toString() {\n\n    if (m_IndexString.equals(\"\")) {\n      return \"No index set\";\n    }\n    if (m_Upper == -1) {\n      throw new RuntimeException(\"Upper limit has not been specified\");\n    }\n    return m_IndexString;\n  }\n\n  /**\n   * Gets the selected index\n   *\n   * @return the selected index\n   * @exception RuntimeException if the upper limit of the index hasn't been defined\n   */\n  //@ requires m_Upper \u003e= 0;\n  //@ requires m_IndexString.length() \u003e 0;\n  //@ ensures \\result == m_SelectedIndex;\n  public /*@pure@*/ int getIndex() {\n\n    if (m_IndexString.equals(\"\")) {\n      throw new RuntimeException(\"No index set\");\n    }\n    if (m_Upper == -1) {\n      throw new RuntimeException(\"No upper limit has been specified for index\");\n    }\n    return m_SelectedIndex;\n  }\n\n  /**\n   * Creates a string representation of the given index.\n   *\n   * @param indices an array containing indices to select.\n   * Since the array will typically come from a program, indices are assumed\n   * from 0, and thus will have 1 added in the String representation.\n   */\n  //@ requires index \u003e= 0;\n  public static /*@pure non_null@*/ String indexToString(int index) {\n\n    return \"\" + (index + 1);\n  }\n\n  /**\n   * Translates a single string selection into it's internal 0-based equivalent\n   *\n   * @param single the string representing the selection (eg: 1 first last)\n   * @return the number corresponding to the selected value\n   */\n  //@ assignable m_SelectedIndex, m_IndexString;\n  protected void setValue() {\n\n    if (m_IndexString.equals(\"\")) {\n      throw new RuntimeException(\"No index set\");\n    }\n    if (m_IndexString.toLowerCase().equals(\"first\")) {\n      m_SelectedIndex = 0;\n    } else if (m_IndexString.toLowerCase().equals(\"last\")) {\n      m_SelectedIndex = m_Upper;\n    } else {\n      m_SelectedIndex = Integer.parseInt(m_IndexString) - 1;\n      if (m_SelectedIndex \u003c 0) {\n\tm_IndexString = \"\";\n\tthrow new IllegalArgumentException(\"Index must be greater than zero\");\n      }\n      if (m_SelectedIndex \u003e m_Upper) {\n\tm_IndexString = \"\";\n\tthrow new IllegalArgumentException(\"Index is too large\");\n      }\n    }\n  }\n\n  /**\n   * Main method for testing this class.\n   *\n   * @param argv one parameter: a test index specification\n   */\n  //@ requires \\nonnullelements(argv);\n  public static void main(/*@non_null@*/ String [] argv) {\n\n    try {\n      if (argv.length == 0) {\n\tthrow new Exception(\"Usage: SingleIndex \u003cindexspec\u003e\");\n      }\n      SingleIndex singleIndex = new SingleIndex();\n      singleIndex.setSingleIndex(argv[0]);\n      singleIndex.setUpper(9);\n      System.out.println(\"Input: \" + argv[0] + \"\\n\"\n\t\t\t + singleIndex.toString());\n      int selectedIndex = singleIndex.getIndex();\n      System.out.println(selectedIndex + \"\");\n    } catch (Exception ex) {\n      ex.printStackTrace();\n      System.out.println(ex.getMessage());\n    }\n  }\n}\n",
        "name": "SingleIndex.java",
        "path": "subjectSystems/C,D/core/SingleIndex.java",
        "url": "/github.com/LASER-UMASS/Themis/-/blob/subjectSystems/C,D/core/SingleIndex.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 60,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_SelectedIndex == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 61,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Upper == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 72,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_IndexString == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 73,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_SelectedIndex == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 74,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Upper == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 86,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures newUpper \u003c 0 ==\u003e m_Upper == \\old(m_Upper);"
        },
        {
          "limitHit": false,
          "lineNumber": 87,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures newUpper \u003e= 0 ==\u003e m_Upper == newUpper;"
        },
        {
          "limitHit": false,
          "lineNumber": 101,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_IndexString;"
        },
        {
          "limitHit": false,
          "lineNumber": 115,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_IndexString == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 116,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_SelectedIndex == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 130,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 148,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Upper \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 149,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_IndexString.length() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 150,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_SelectedIndex;"
        },
        {
          "limitHit": false,
          "lineNumber": 169,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 209,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires \\nonnullelements(argv);"
        }
      ],
      "repository": {
        "name": "github.com/LASER-UMASS/Themis",
        "url": "/github.com/LASER-UMASS/Themis"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a70f12a6a8f34cdd8b170b4dc59a78674c9e8950"
        },
        "content": "/*\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; either version 2 of the License, or\n *    (at your option) any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n/*\n *    OptionHandler.java\n *    Copyright (C) 1999 Eibe Frank,Len Trigg\n *\n */\n\npackage weka.core;\n\nimport java.util.*;\n\n/** \n * Interface to something that understands options.\n *\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\n * @author Len Trigg (trigg@cs.waikato.ac.nz)\n * @version $Revision: 1.7 $\n */\npublic interface OptionHandler {\n\n  /**\n   * Returns an enumeration of all the available options..\n   *\n   * @return an enumeration of all available options.\n   */\n  Enumeration listOptions();\n\n  /**\n   * Sets the OptionHandler's options using the given list. All options\n   * will be set (or reset) during this call (i.e. incremental setting\n   * of options is not possible).\n   *\n   * @param options the list of options as an array of strings\n   * @exception Exception if an option is not supported\n   */\n  //@ requires options != null;\n  //@ requires \\nonnullelements(options);\n  void setOptions(String[] options) throws Exception;\n\n  /**\n   * Gets the current option settings for the OptionHandler.\n   *\n   * @return the list of current option settings as an array of strings\n   */\n  //@ ensures \\result != null;\n  //@ ensures \\nonnullelements(\\result);\n  /*@pure@*/ String[] getOptions();\n}\n\n\n\n\n\n\n\n\n",
        "name": "OptionHandler.java",
        "path": "subjectSystems/C,D/core/OptionHandler.java",
        "url": "/github.com/LASER-UMASS/Themis/-/blob/subjectSystems/C,D/core/OptionHandler.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 50,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires options != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 51,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires \\nonnullelements(options);"
        },
        {
          "limitHit": false,
          "lineNumber": 59,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 60,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\nonnullelements(\\result);"
        }
      ],
      "repository": {
        "name": "github.com/LASER-UMASS/Themis",
        "url": "/github.com/LASER-UMASS/Themis"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a70f12a6a8f34cdd8b170b4dc59a78674c9e8950"
        },
        "content": "/*\r\n *    This program is free software; you can redistribute it and/or modify\r\n *    it under the terms of the GNU General Public License as published by\r\n *    the Free Software Foundation; either version 2 of the License, or\r\n *    (at your option) any later version.\r\n *\r\n *    This program is distributed in the hope that it will be useful,\r\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *    GNU General Public License for more details.\r\n *\r\n *    You should have received a copy of the GNU General Public License\r\n *    along with this program; if not, write to the Free Software\r\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\r\n */\r\n\r\n/*\r\n *    Utils.java\r\n *    Copyright (C) 1999-2004 University of Waikato\r\n *\r\n */\r\n\r\npackage weka.core;\r\n\r\nimport java.lang.Math;\r\nimport java.lang.reflect.Array;\r\nimport java.util.Properties;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.util.Random;\r\n\r\n/**\r\n * Class implementing some simple utility methods.\r\n *\r\n * @author Eibe Frank \r\n * @author Yong Wang \r\n * @author Len Trigg \r\n * @author Julien Prados\r\n * @version $Revision: 1.44.2.3 $\r\n */\r\npublic final class Utils {\r\n\r\n  /** The natural logarithm of 2. */\r\n  public static double log2 = Math.log(2);\r\n\r\n  /** The small deviation allowed in double comparisons */\r\n  public static double SMALL = 1e-6;\r\n\r\n  \r\n  /**\r\n   * Reads properties that inherit from three locations. Properties\r\n   * are first defined in the system resource location (i.e. in the\r\n   * CLASSPATH).  These default properties must exist. Properties\r\n   * defined in the users home directory (optional) override default\r\n   * settings. Properties defined in the current directory (optional)\r\n   * override all these settings.\r\n   *\r\n   * @param resourceName the location of the resource that should be\r\n   * loaded.  e.g.: \"weka/core/Utils.props\". (The use of hardcoded\r\n   * forward slashes here is OK - see\r\n   * jdk1.1/docs/guide/misc/resources.html) This routine will also\r\n   * look for the file (in this case) \"Utils.props\" in the users home\r\n   * directory and the current directory.\r\n   * @return the Properties\r\n   * @exception Exception if no default properties are defined, or if\r\n   * an error occurs reading the properties files.  \r\n   */\r\n  public static Properties readProperties(String resourceName)\r\n    throws Exception {\r\n\r\n    Properties defaultProps = new Properties();\r\n    try {\r\n      // Apparently hardcoded slashes are OK here\r\n      // jdk1.1/docs/guide/misc/resources.html\r\n      defaultProps.load(ClassLoader.getSystemResourceAsStream(resourceName));\r\n    } catch (Exception ex) {\r\n/*      throw new Exception(\"Problem reading default properties: \"\r\n\t+ ex.getMessage()); */\r\n      System.err.println(\"Warning, unable to load properties file from \"\r\n\t\t\t +\"system resource (Utils.java)\");\r\n    }\r\n\r\n    // Hardcoded slash is OK here\r\n    // eg: see jdk1.1/docs/guide/misc/resources.html\r\n    int slInd = resourceName.lastIndexOf('/');\r\n    if (slInd != -1) {\r\n      resourceName = resourceName.substring(slInd + 1);\r\n    }\r\n\r\n    // Allow a properties file in the home directory to override\r\n    Properties userProps = new Properties(defaultProps);    \r\n    File propFile = new File(System.getProperties().getProperty(\"user.home\")\r\n                             + File.separatorChar\r\n                             + resourceName);\r\n    if (propFile.exists()) {\r\n      try {\r\n        userProps.load(new FileInputStream(propFile));\r\n      } catch (Exception ex) {\r\n        throw new Exception(\"Problem reading user properties: \" + propFile);\r\n      }\r\n    }\r\n\r\n    // Allow a properties file in the current directory to override\r\n    Properties localProps = new Properties(userProps);\r\n    propFile = new File(resourceName);\r\n    if (propFile.exists()) {\r\n      try {\r\n        localProps.load(new FileInputStream(propFile));\r\n      } catch (Exception ex) {\r\n        throw new Exception(\"Problem reading local properties: \" + propFile);\r\n      }\r\n    }\r\n    \r\n    return localProps;\r\n  }\r\n\r\n  /**\r\n   * Returns the correlation coefficient of two double vectors.\r\n   *\r\n   * @param y1 double vector 1\r\n   * @param y2 double vector 2\r\n   * @param n the length of two double vectors\r\n   * @return the correlation coefficient\r\n   */\r\n  public static final double correlation(double y1[],double y2[],int n) {\r\n\r\n    int i;\r\n    double av1 = 0.0, av2 = 0.0, y11 = 0.0, y22 = 0.0, y12 = 0.0, c;\r\n    \r\n    if (n \u003c= 1) {\r\n      return 1.0;\r\n    }\r\n    for (i = 0; i \u003c n; i++) {\r\n      av1 += y1[i];\r\n      av2 += y2[i];\r\n    }\r\n    av1 /= (double) n;\r\n    av2 /= (double) n;\r\n    for (i = 0; i \u003c n; i++) {\r\n      y11 += (y1[i] - av1) * (y1[i] - av1);\r\n      y22 += (y2[i] - av2) * (y2[i] - av2);\r\n      y12 += (y1[i] - av1) * (y2[i] - av2);\r\n    }\r\n    if (y11 * y22 == 0.0) {\r\n      c=1.0;\r\n    } else {\r\n      c = y12 / Math.sqrt(Math.abs(y11 * y22));\r\n    }\r\n    \r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * Removes all occurrences of a string from another string.\r\n   *\r\n   * @param inString the string to remove substrings from.\r\n   * @param substring the substring to remove.\r\n   * @return the input string with occurrences of substring removed.\r\n   */\r\n  public static String removeSubstring(String inString, String substring) {\r\n\r\n    StringBuffer result = new StringBuffer();\r\n    int oldLoc = 0, loc = 0;\r\n    while ((loc = inString.indexOf(substring, oldLoc))!= -1) {\r\n      result.append(inString.substring(oldLoc, loc));\r\n      oldLoc = loc + substring.length();\r\n    }\r\n    result.append(inString.substring(oldLoc));\r\n    return result.toString();\r\n  }\r\n\r\n  /**\r\n   * Replaces with a new string, all occurrences of a string from \r\n   * another string.\r\n   *\r\n   * @param inString the string to replace substrings in.\r\n   * @param substring the substring to replace.\r\n   * @param replaceString the replacement substring\r\n   * @return the input string with occurrences of substring replaced.\r\n   */\r\n  public static String replaceSubstring(String inString, String subString,\r\n\t\t\t\t\tString replaceString) {\r\n\r\n    StringBuffer result = new StringBuffer();\r\n    int oldLoc = 0, loc = 0;\r\n    while ((loc = inString.indexOf(subString, oldLoc))!= -1) {\r\n      result.append(inString.substring(oldLoc, loc));\r\n      result.append(replaceString);\r\n      oldLoc = loc + subString.length();\r\n    }\r\n    result.append(inString.substring(oldLoc));\r\n    return result.toString();\r\n  }\r\n\r\n\r\n  /**\r\n   * Pads a string to a specified length, inserting spaces on the left\r\n   * as required. If the string is too long, characters are removed (from\r\n   * the right).\r\n   *\r\n   * @param inString the input string\r\n   * @param length the desired length of the output string\r\n   * @return the output string\r\n   */\r\n  public static String padLeft(String inString, int length) {\r\n\r\n    return fixStringLength(inString, length, false);\r\n  }\r\n  \r\n  /**\r\n   * Pads a string to a specified length, inserting spaces on the right\r\n   * as required. If the string is too long, characters are removed (from\r\n   * the right).\r\n   *\r\n   * @param inString the input string\r\n   * @param length the desired length of the output string\r\n   * @return the output string\r\n   */\r\n  public static String padRight(String inString, int length) {\r\n\r\n    return fixStringLength(inString, length, true);\r\n  }\r\n  \r\n  /**\r\n   * Pads a string to a specified length, inserting spaces as\r\n   * required. If the string is too long, characters are removed (from\r\n   * the right).\r\n   *\r\n   * @param inString the input string\r\n   * @param length the desired length of the output string\r\n   * @param right true if inserted spaces should be added to the right\r\n   * @return the output string\r\n   */\r\n  private static /*@pure@*/ String fixStringLength(String inString, int length,\r\n\t\t\t\t\tboolean right) {\r\n\r\n    if (inString.length() \u003c length) {\r\n      while (inString.length() \u003c length) {\r\n\tinString = (right ? inString.concat(\" \") : \" \".concat(inString));\r\n      }\r\n    } else if (inString.length() \u003e length) {\r\n      inString = inString.substring(0, length);\r\n    }\r\n    return inString;\r\n  }\r\n \r\n  /**\r\n   * Rounds a double and converts it into String.\r\n   *\r\n   * @param value the double value\r\n   * @param afterDecimalPoint the (maximum) number of digits permitted\r\n   * after the decimal point\r\n   * @return the double as a formatted string\r\n   */\r\n  public static /*@pure@*/ String doubleToString(double value, int afterDecimalPoint) {\r\n    \r\n    StringBuffer stringBuffer;\r\n    double temp;\r\n    int i,dotPosition;\r\n    long precisionValue;\r\n    \r\n    temp = value * Math.pow(10.0, afterDecimalPoint);\r\n    if (Math.abs(temp) \u003c Long.MAX_VALUE) {\r\n      precisionValue = \t(temp \u003e 0) ? (long)(temp + 0.5) \r\n                                   : -(long)(Math.abs(temp) + 0.5);\r\n      if (precisionValue == 0) {\r\n\tstringBuffer = new StringBuffer(String.valueOf(0));\r\n      } else {\r\n\tstringBuffer = new StringBuffer(String.valueOf(precisionValue));\r\n      }\r\n      if (afterDecimalPoint == 0) {\r\n\treturn stringBuffer.toString();\r\n      }\r\n      dotPosition = stringBuffer.length() - afterDecimalPoint;\r\n      while (((precisionValue \u003c 0) \u0026\u0026 (dotPosition \u003c 1)) ||\r\n\t     (dotPosition \u003c 0)) {\r\n\tif (precisionValue \u003c 0) {\r\n\t  stringBuffer.insert(1, '0');\r\n\t} else {\r\n\t  stringBuffer.insert(0, '0');\r\n\t}\r\n\tdotPosition++;\r\n      }\r\n      stringBuffer.insert(dotPosition, '.');\r\n      if ((precisionValue \u003c 0) \u0026\u0026 (stringBuffer.charAt(1) == '.')) {\r\n\tstringBuffer.insert(1, '0');\r\n      } else if (stringBuffer.charAt(0) == '.') {\r\n\tstringBuffer.insert(0, '0');\r\n      }\r\n      int currentPos = stringBuffer.length() - 1;\r\n      while ((currentPos \u003e dotPosition) \u0026\u0026\r\n\t     (stringBuffer.charAt(currentPos) == '0')) {\r\n\tstringBuffer.setCharAt(currentPos--, ' ');\r\n      }\r\n      if (stringBuffer.charAt(currentPos) == '.') {\r\n\tstringBuffer.setCharAt(currentPos, ' ');\r\n      }\r\n      \r\n      return stringBuffer.toString().trim();\r\n    }\r\n    return new String(\"\" + value);\r\n  }\r\n\r\n  /**\r\n   * Rounds a double and converts it into a formatted decimal-justified String.\r\n   * Trailing 0's are replaced with spaces.\r\n   *\r\n   * @param value the double value\r\n   * @param width the width of the string\r\n   * @param afterDecimalPoint the number of digits after the decimal point\r\n   * @return the double as a formatted string\r\n   */\r\n  public static /*@pure@*/ String doubleToString(double value, int width,\r\n\t\t\t\t      int afterDecimalPoint) {\r\n    \r\n    String tempString = doubleToString(value, afterDecimalPoint);\r\n    char[] result;\r\n    int dotPosition;\r\n\r\n    if ((afterDecimalPoint \u003e= width) \r\n        || (tempString.indexOf('E') != -1)) { // Protects sci notation\r\n      return tempString;\r\n    }\r\n\r\n    // Initialize result\r\n    result = new char[width];\r\n    for (int i = 0; i \u003c result.length; i++) {\r\n      result[i] = ' ';\r\n    }\r\n\r\n    if (afterDecimalPoint \u003e 0) {\r\n      // Get position of decimal point and insert decimal point\r\n      dotPosition = tempString.indexOf('.');\r\n      if (dotPosition == -1) {\r\n\tdotPosition = tempString.length();\r\n      } else {\r\n\tresult[width - afterDecimalPoint - 1] = '.';\r\n      }\r\n    } else {\r\n      dotPosition = tempString.length();\r\n    }\r\n    \r\n\r\n    int offset = width - afterDecimalPoint - dotPosition;\r\n    if (afterDecimalPoint \u003e 0) {\r\n      offset--;\r\n    }\r\n\r\n    // Not enough room to decimal align within the supplied width\r\n    if (offset \u003c 0) {\r\n      return tempString;\r\n    }\r\n\r\n    // Copy characters before decimal point\r\n    for (int i = 0; i \u003c dotPosition; i++) {\r\n      result[offset + i] = tempString.charAt(i);\r\n    }\r\n\r\n    // Copy characters after decimal point\r\n    for (int i = dotPosition + 1; i \u003c tempString.length(); i++) {\r\n      result[offset + i] = tempString.charAt(i);\r\n    }\r\n\r\n    return new String(result);\r\n  }\r\n\r\n  /**\r\n   * Returns the basic class of an array class (handles multi-dimensional\r\n   * arrays).\r\n   * @param o        the array to inspect\r\n   * @return         the class of the innermost elements\r\n   */\r\n  public static Class getArrayClass(Class c) {\r\n     if (c.getComponentType().isArray())\r\n        return getArrayClass(c.getComponentType());\r\n     else\r\n        return c.getComponentType();\r\n  }\r\n\r\n  /**\r\n   * Returns the dimensions of the given array. Even though the\r\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\r\n   * int[3] or double[2][4].\r\n   *\r\n   * @param array       the array to determine the dimensions for\r\n   * @return            the dimensions of the array\r\n   */\r\n  public static int getArrayDimensions(Class array) {\r\n    if (array.getComponentType().isArray())\r\n      return 1 + getArrayDimensions(array.getComponentType());\r\n    else\r\n      return 1;\r\n  }\r\n\r\n  /**\r\n   * Returns the dimensions of the given array. Even though the\r\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\r\n   * int[3] or double[2][4].\r\n   *\r\n   * @param array       the array to determine the dimensions for\r\n   * @return            the dimensions of the array\r\n   */\r\n  public static int getArrayDimensions(Object array) {\r\n    return getArrayDimensions(array.getClass());\r\n  }\r\n\r\n  /**\r\n   * Returns the given Array in a string representation. Even though the\r\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\r\n   * int[3] or double[2][4].\r\n   * \r\n   * @param array       the array to return in a string representation\r\n   * @return            the array as string\r\n   */\r\n  public static String arrayToString(Object array) {\r\n    String        result;\r\n    int           dimensions;\r\n    int           i;       \r\n\r\n    result     = \"\";\r\n    dimensions = getArrayDimensions(array);\r\n    \r\n    if (dimensions == 0) {\r\n      result = \"null\";\r\n    }\r\n    else if (dimensions == 1) {\r\n      for (i = 0; i \u003c Array.getLength(array); i++) {\r\n        if (i \u003e 0)\r\n          result += \",\";\r\n        if (Array.get(array, i) == null)\r\n          result += \"null\";\r\n        else\r\n          result += Array.get(array, i).toString();\r\n      }\r\n    }\r\n    else {\r\n      for (i = 0; i \u003c Array.getLength(array); i++) {\r\n        if (i \u003e 0)\r\n          result += \",\";\r\n        result += \"[\" + arrayToString(Array.get(array, i)) + \"]\";\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Tests if a is equal to b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n   */\r\n  public static /*@pure@*/ boolean eq(double a, double b){\r\n    \r\n    return (a - b \u003c SMALL) \u0026\u0026 (b - a \u003c SMALL); \r\n  }\r\n\r\n  /**\r\n   * Checks if the given array contains any non-empty options.\r\n   *\r\n   * @param strings an array of strings\r\n   * @exception Exception if there are any non-empty options\r\n   */\r\n  public static void checkForRemainingOptions(String [] options) \r\n    throws Exception {\r\n    \r\n    int illegalOptionsFound = 0;\r\n    StringBuffer text = new StringBuffer();\r\n\r\n    if (options == null) {\r\n      return;\r\n    }\r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if (options[i].length() \u003e 0) {\r\n\tillegalOptionsFound++;\r\n\ttext.append(options[i] + ' ');\r\n      }\r\n    }\r\n    if (illegalOptionsFound \u003e 0) {\r\n      throw new Exception(\"Illegal options: \" + text);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Checks if the given array contains the flag \"-Char\". Stops\r\n   * searching at the first marker \"--\". If the flag is found,\r\n   * it is replaced with the empty string.\r\n   *\r\n   * @param flag the character indicating the flag.\r\n   * @param strings the array of strings containing all the options.\r\n   * @return true if the flag was found\r\n   * @exception Exception if an illegal option was found\r\n   */\r\n  public static boolean getFlag(char flag, String [] options) \r\n    throws Exception {\r\n       return getFlag(\"\" + flag, options);\r\n  }\r\n  \r\n  /**\r\n   * Checks if the given array contains the flag \"-String\". Stops\r\n   * searching at the first marker \"--\". If the flag is found,\r\n   * it is replaced with the empty string.\r\n   *\r\n   * @param flag the String indicating the flag.\r\n   * @param strings the array of strings containing all the options.\r\n   * @return true if the flag was found\r\n   * @exception Exception if an illegal option was found\r\n   */\r\n  public static boolean getFlag(String flag, String [] options) \r\n    throws Exception {\r\n\r\n    if (options == null) {\r\n      return false;\r\n    }\r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if ((options[i].length() \u003e 1) \u0026\u0026 (options[i].charAt(0) == '-')) {\r\n\ttry {\r\n\t  Double dummy = Double.valueOf(options[i]);\r\n\t} catch (NumberFormatException e) {\r\n\t  if (options[i].equals(\"-\" + flag)) {\r\n\t    options[i] = \"\";\r\n\t    return true;\r\n\t  }\r\n\t  if (options[i].charAt(1) == '-') {\r\n\t    return false;\r\n\t  }\r\n\t}\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gets an option indicated by a flag \"-Char\" from the given array\r\n   * of strings. Stops searching at the first marker \"--\". Replaces \r\n   * flag and option with empty strings.\r\n   *\r\n   * @param flag the character indicating the option.\r\n   * @param options the array of strings containing all the options.\r\n   * @return the indicated option or an empty string\r\n   * @exception Exception if the option indicated by the flag can't be found\r\n   */\r\n  public static /*@non_null@*/ String getOption(char flag, String [] options) \r\n    throws Exception {\r\n     return getOption(\"\" + flag, options);\r\n  }\r\n\r\n  /**\r\n   * Gets an option indicated by a flag \"-String\" from the given array\r\n   * of strings. Stops searching at the first marker \"--\". Replaces \r\n   * flag and option with empty strings.\r\n   *\r\n   * @param flag the String indicating the option.\r\n   * @param options the array of strings containing all the options.\r\n   * @return the indicated option or an empty string\r\n   * @exception Exception if the option indicated by the flag can't be found\r\n   */\r\n  public static /*@non_null@*/ String getOption(String flag, String [] options) \r\n    throws Exception {\r\n\r\n    String newString;\r\n\r\n    if (options == null)\r\n      return \"\";\r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if ((options[i].length() \u003e 0) \u0026\u0026 (options[i].charAt(0) == '-')) {\r\n\t\r\n\t// Check if it is a negative number\r\n\ttry {\r\n\t  Double dummy = Double.valueOf(options[i]);\r\n\t} catch (NumberFormatException e) {\r\n\t  if (options[i].equals(\"-\" + flag)) {\r\n\t    if (i + 1 == options.length) {\r\n\t      throw new Exception(\"No value given for -\" + flag + \" option.\");\r\n\t    }\r\n\t    options[i] = \"\";\r\n\t    newString = new String(options[i + 1]);\r\n\t    options[i + 1] = \"\";\r\n\t    return newString;\r\n\t  }\r\n\t  if (options[i].charAt(1) == '-') {\r\n\t    return \"\";\r\n\t  }\r\n\t}\r\n      }\r\n    }\r\n    return \"\";\r\n  }\r\n\r\n  /**\r\n   * Quotes a string if it contains special characters.\r\n   * \r\n   * The following rules are applied:\r\n   *\r\n   * A character is backquoted version of it is one \r\n   * of \u003ctt\u003e\" ' % \\ \\n \\r \\t\u003c/tt\u003e.\r\n   *\r\n   * A string is enclosed within single quotes if a character has been\r\n   * backquoted using the previous rule above or contains \r\n   * \u003ctt\u003e{ }\u003c/tt\u003e or is exactly equal to the strings \r\n   * \u003ctt\u003e, ? space or \"\"\u003c/tt\u003e (empty string).\r\n   *\r\n   * A quoted question mark distinguishes it from the missing value which\r\n   * is represented as an unquoted question mark in arff files.\r\n   *\r\n   * @param string the string to be quoted\r\n   * @return the string (possibly quoted)\r\n   */\r\n  public static /*@pure@*/ String quote(String string) {\r\n      boolean quote = false;\r\n\r\n      // backquote the following characters \r\n      if ((string.indexOf('\\n') != -1) || (string.indexOf('\\r') != -1) || \r\n\t  (string.indexOf('\\'') != -1) || (string.indexOf('\"') != -1) || \r\n\t  (string.indexOf('\\\\') != -1) || \r\n\t  (string.indexOf('\\t') != -1) || (string.indexOf('%') != -1)) {\r\n\t  string = backQuoteChars(string);\r\n\t  quote = true;\r\n      }\r\n\r\n      // Enclose the string in 's if the string contains a recently added\r\n      // backquote or contains one of the following characters.\r\n      if((quote == true) || \r\n\t (string.indexOf('{') != -1) || (string.indexOf('}') != -1) ||\r\n\t (string.indexOf(',') != -1) || (string.equals(\"?\")) ||\r\n\t (string.indexOf(' ') != -1) || (string.equals(\"\"))) {\r\n\t  string = (\"'\".concat(string)).concat(\"'\");\r\n      }\r\n\r\n      return string;\r\n  }\r\n\r\n  /**\r\n   * Converts carriage returns and new lines in a string into \\r and \\n.\r\n   * Backquotes the following characters: ` \" \\ \\t and %\r\n   * @param string the string\r\n   * @return the converted string\r\n   */\r\n  public static /*@pure@*/ String backQuoteChars(String string) {\r\n\r\n    int index;\r\n    StringBuffer newStringBuffer;\r\n\r\n    // replace each of the following characters with the backquoted version\r\n    char   charsFind[] =    {'\\\\',   '\\'',  '\\t',  '\"',    '%'};\r\n    String charsReplace[] = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\\\\"\", \"\\\\%\"};\r\n    for(int i = 0; i \u003c charsFind.length; i++) {\r\n\tif (string.indexOf(charsFind[i]) != -1 ) {\r\n\t    newStringBuffer = new StringBuffer();\r\n\t    while ((index = string.indexOf(charsFind[i])) != -1) {\r\n\t\tif (index \u003e 0) {\r\n\t\t    newStringBuffer.append(string.substring(0, index));\r\n\t\t}\r\n\t\tnewStringBuffer.append(charsReplace[i]);\r\n\t\tif ((index + 1) \u003c string.length()) {\r\n\t\t    string = string.substring(index + 1);\r\n\t\t} else {\r\n\t\t    string = \"\";\r\n\t\t}\r\n\t    }\r\n\t    newStringBuffer.append(string);\r\n\t    string = newStringBuffer.toString();\r\n\t}\r\n    }\r\n\r\n    return Utils.convertNewLines(string);\r\n  }\r\n\r\n  /**\r\n   * Converts carriage returns and new lines in a string into \\r and \\n.\r\n   * @param string the string\r\n   * @return the converted string\r\n   */\r\n  public static /*@pure@*/ String convertNewLines(String string) {\r\n    \r\n    int index;\r\n\r\n    // Replace with \\n\r\n    StringBuffer newStringBuffer = new StringBuffer();\r\n    while ((index = string.indexOf('\\n')) != -1) {\r\n      if (index \u003e 0) {\r\n\tnewStringBuffer.append(string.substring(0, index));\r\n      }\r\n      newStringBuffer.append('\\\\');\r\n      newStringBuffer.append('n');\r\n      if ((index + 1) \u003c string.length()) {\r\n\tstring = string.substring(index + 1);\r\n      } else {\r\n\tstring = \"\";\r\n      }\r\n    }\r\n    newStringBuffer.append(string);\r\n    string = newStringBuffer.toString();\r\n\r\n    // Replace with \\r\r\n    newStringBuffer = new StringBuffer();\r\n    while ((index = string.indexOf('\\r')) != -1) {\r\n      if (index \u003e 0) {\r\n\tnewStringBuffer.append(string.substring(0, index));\r\n      }\r\n      newStringBuffer.append('\\\\');\r\n      newStringBuffer.append('r');\r\n      if ((index + 1) \u003c string.length()){\r\n\tstring = string.substring(index + 1);\r\n      } else {\r\n\tstring = \"\";\r\n      }\r\n    }\r\n    newStringBuffer.append(string);\r\n    return newStringBuffer.toString();\r\n  }\r\n    \r\n\r\n  /**\r\n   * Returns the secondary set of options (if any) contained in\r\n   * the supplied options array. The secondary set is defined to\r\n   * be any options after the first \"--\". These options are removed from\r\n   * the original options array.\r\n   *\r\n   * @param options the input array of options\r\n   * @return the array of secondary options\r\n   */\r\n  public static String [] partitionOptions(String [] options) {\r\n\r\n    for (int i = 0; i \u003c options.length; i++) {\r\n      if (options[i].equals(\"--\")) {\r\n\toptions[i++] = \"\";\r\n\tString [] result = new String [options.length - i];\r\n\tfor (int j = i; j \u003c options.length; j++) {\r\n\t  result[j - i] = options[j];\r\n\t  options[j] = \"\";\r\n\t}\r\n\treturn result;\r\n      }\r\n    }\r\n    return new String [0];\r\n  }\r\n    \r\n  /**\r\n   * The inverse operation of backQuoteChars().\r\n   * Converts back-quoted carriage returns and new lines in a string \r\n   * to the corresponding character ('\\r' and '\\n').\r\n   * Also \"un\"-back-quotes the following characters: ` \" \\ \\t and %\r\n   * @param string the string\r\n   * @return the converted string\r\n   */\r\n  public static String unbackQuoteChars(String string) {\r\n\r\n    int index;\r\n    StringBuffer newStringBuffer;\r\n    \r\n    // replace each of the following characters with the backquoted version\r\n    String charsFind[]    = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\\\\"\", \"\\\\%\"};\r\n    char   charsReplace[] = {'\\\\',   '\\'',  '\\t',  '\"',    '%'};\r\n    \r\n    for(int i = 0; i \u003c charsFind.length; i++) {\r\n      if (string.indexOf(charsFind[i]) != -1 ) {\r\n\tnewStringBuffer = new StringBuffer();\r\n\twhile ((index = string.indexOf(charsFind[i])) != -1) {\r\n\t  if (index \u003e 0) {\r\n\t    newStringBuffer.append(string.substring(0, index));\r\n\t  }\r\n\t  newStringBuffer.append(charsReplace[i]);\r\n\t  if ((index + charsFind[i].length()) \u003c string.length()) {\r\n\t    string = string.substring(index + charsFind[i].length());\r\n\t  } else {\r\n\t    string = \"\";\r\n\t  }\r\n\t}\r\n\tnewStringBuffer.append(string);\r\n\tstring = newStringBuffer.toString();\r\n      }\r\n    }\r\n    return Utils.convertNewLines(string);\r\n  }    \r\n  \r\n  /**\r\n   * Split up a string containing options into an array of strings,\r\n   * one for each option.\r\n   *\r\n   * @param optionString the string containing the options\r\n   * @return the array of options\r\n   */\r\n  public static String [] splitOptions(String quotedOptionString) throws Exception{\r\n\r\n    FastVector optionsVec = new FastVector();\r\n    String str = new String(quotedOptionString);\r\n    int i;\r\n    \r\n    while (true){\r\n\r\n      //trimLeft \r\n      i = 0;\r\n      while ((i \u003c str.length()) \u0026\u0026 (Character.isWhitespace(str.charAt(i)))) i++;\r\n      str = str.substring(i);\r\n      \r\n      //stop when str is empty\r\n      if (str.length() == 0) break;\r\n      \r\n      //if str start with a double quote\r\n      if (str.charAt(0) == '\"'){\r\n\t\r\n\t//find the first not anti-slached double quote\r\n\ti = 1;\r\n\twhile(i \u003c str.length()){\r\n\t  if (str.charAt(i) == str.charAt(0)) break;\r\n\t  if (str.charAt(i) == '\\\\'){\r\n\t    i += 1;\r\n\t    if (i \u003e= str.length()) \r\n\t      throw new Exception(\"String should not finish with \\\\\");\r\n\t    if (str.charAt(i) != '\\\\' \u0026\u0026  str.charAt(i) != '\"') \r\n\t      throw new Exception(\"Unknow character \\\\\" + str.charAt(i));\r\n\t  }\r\n\t  i += 1;\r\n\t}\r\n\tif (i \u003e= str.length()) throw new Exception(\"Quote parse error.\");\r\n\t\r\n\t//add the founded string to the option vector (without quotes)\r\n\tString optStr = str.substring(1,i);\r\n\toptStr = unbackQuoteChars(optStr);\r\n\toptionsVec.addElement(optStr);\r\n\tstr = str.substring(i+1);\r\n      } else {\r\n\t//find first whiteSpace\r\n\ti=0;\r\n\twhile((i \u003c str.length()) \u0026\u0026 (!Character.isWhitespace(str.charAt(i)))) i++;\r\n\t\r\n\t//add the founded string to the option vector\r\n\tString optStr = str.substring(0,i);\r\n\toptionsVec.addElement(optStr);\r\n\tstr = str.substring(i);\r\n      }\r\n    }\r\n    \r\n    //convert optionsVec to an array of String\r\n    String [] options = new String[optionsVec.size()];\r\n    for (i = 0; i \u003c optionsVec.size(); i++) {\r\n      options[i] = (String)optionsVec.elementAt(i);\r\n    }\r\n    return options;\r\n  }    \r\n\r\n  /**\r\n   * Joins all the options in an option array into a single string,\r\n   * as might be used on the command line.\r\n   *\r\n   * @param optionArray the array of options\r\n   * @return the string containing all options.\r\n   */\r\n  public static String joinOptions(String [] optionArray) {\r\n\r\n    String optionString = \"\";\r\n    for (int i = 0; i \u003c optionArray.length; i++) {\r\n      if (optionArray[i].equals(\"\")) {\r\n\tcontinue;\r\n      }\r\n      if (optionArray[i].indexOf(' ') != -1) {\r\n\toptionString += '\"' + optionArray[i] + '\"';\r\n      } else {\r\n\toptionString += optionArray[i];\r\n      }\r\n      optionString += \" \";\r\n    }\r\n    return optionString.trim();\r\n  }\r\n  \r\n  /**\r\n   * Creates a new instance of an object given it's class name and\r\n   * (optional) arguments to pass to it's setOptions method. If the\r\n   * object implements OptionHandler and the options parameter is\r\n   * non-null, the object will have it's options set. Example use:\u003cp\u003e\r\n   *\r\n   * \u003ccode\u003e \u003cpre\u003e\r\n   * String classifierName = Utils.getOption('W', options);\r\n   * Classifier c = (Classifier)Utils.forName(Classifier.class,\r\n   *                                          classifierName,\r\n   *                                          options);\r\n   * setClassifier(c);\r\n   * \u003c/pre\u003e\u003c/code\u003e\r\n   *\r\n   * @param classType the class that the instantiated object should\r\n   * be assignable to -- an exception is thrown if this is not the case\r\n   * @param className the fully qualified class name of the object\r\n   * @param options an array of options suitable for passing to setOptions. May\r\n   * be null. Any options accepted by the object will be removed from the\r\n   * array.\r\n   * @return the newly created object, ready for use.\r\n   * @exception Exception if the class name is invalid, or if the\r\n   * class is not assignable to the desired class type, or the options\r\n   * supplied are not acceptable to the object\r\n   */\r\n  public static Object forName(Class classType,\r\n\t\t\t       String className,\r\n\t\t\t       String [] options) throws Exception {\r\n\r\n    Class c = null;\r\n    try {\r\n      c = Class.forName(className);\r\n    } catch (Exception ex) {\r\n      throw new Exception(\"Can't find class called: \" + className);\r\n    }\r\n    if (!classType.isAssignableFrom(c)) {\r\n      throw new Exception(classType.getName() + \" is not assignable from \"\r\n\t\t\t  + className);\r\n    }\r\n    Object o = c.newInstance();\r\n    if ((o instanceof OptionHandler)\r\n\t\u0026\u0026 (options != null)) {\r\n      ((OptionHandler)o).setOptions(options);\r\n      Utils.checkForRemainingOptions(options);\r\n    }\r\n    return o;\r\n  }\r\n\r\n  /**\r\n   * Computes entropy for an array of integers.\r\n   *\r\n   * @param counts array of counts\r\n   * @return - a log2 a - b log2 b - c log2 c + (a+b+c) log2 (a+b+c)\r\n   * when given array [a b c]\r\n   */\r\n  public static /*@pure@*/ double info(int counts[]) {\r\n    \r\n    int total = 0; int c;\r\n    double x = 0;\r\n    for (int j = 0; j \u003c counts.length; j++) {\r\n      x -= xlogx(counts[j]);\r\n      total += counts[j];\r\n    }\r\n    return x + xlogx(total);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is smaller or equal to b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n   */\r\n  public static /*@pure@*/ boolean smOrEq(double a,double b) {\r\n    \r\n    return (a-b \u003c SMALL);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is greater or equal to b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n   */\r\n  public static /*@pure@*/ boolean grOrEq(double a,double b) {\r\n    \r\n    return (b-a \u003c SMALL);\r\n  }\r\n  \r\n  /**\r\n   * Tests if a is smaller than b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double\r\n   */\r\n  public static /*@pure@*/ boolean sm(double a,double b) {\r\n    \r\n    return (b-a \u003e SMALL);\r\n  }\r\n\r\n  /**\r\n   * Tests if a is greater than b.\r\n   *\r\n   * @param a a double\r\n   * @param b a double \r\n   */\r\n  public static /*@pure@*/ boolean gr(double a,double b) {\r\n    \r\n    return (a-b \u003e SMALL);\r\n  }\r\n\r\n  /**\r\n   * Returns the kth-smallest value in the array.\r\n   *\r\n   * @param array the array of integers\r\n   * @param k the value of k\r\n   * @return the kth-smallest value\r\n   */\r\n  public static double kthSmallestValue(int[] array, int k) {\r\n\r\n    int [] index = new int[array.length];\r\n    \r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n    }\r\n\r\n    return array[index[select(array, index, 0, array.length - 1, k)]];\r\n  }\r\n\r\n  /**\r\n   * Returns the kth-smallest value in the array\r\n   *\r\n   * @param array the array of double\r\n   * @param k the value of k\r\n   * @return the kth-smallest value\r\n   */\r\n  public static double kthSmallestValue(double[] array, int k) {\r\n\r\n    int [] index = new int[array.length];\r\n    \r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n    }\r\n\r\n    return array[index[select(array, index, 0, array.length - 1, k)]];\r\n  }\r\n\r\n  /**\r\n   * Returns the logarithm of a for base 2.\r\n   *\r\n   * @param a a double\r\n   */\r\n  public static /*@pure@*/ double log2(double a) {\r\n    \r\n    return Math.log(a) / log2;\r\n  }\r\n\r\n  /**\r\n   * Returns index of maximum element in a given\r\n   * array of doubles. First maximum is returned.\r\n   *\r\n   * @param doubles the array of doubles\r\n   * @return the index of the maximum element\r\n   */\r\n  public static /*@pure@*/ int maxIndex(double [] doubles) {\r\n\r\n    double maximum = 0;\r\n    int maxIndex = 0;\r\n\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      if ((i == 0) || (doubles[i] \u003e maximum)) {\r\n\tmaxIndex = i;\r\n\tmaximum = doubles[i];\r\n      }\r\n    }\r\n\r\n    return maxIndex;\r\n  }\r\n\r\n  /**\r\n   * Returns index of maximum element in a given\r\n   * array of integers. First maximum is returned.\r\n   *\r\n   * @param ints the array of integers\r\n   * @return the index of the maximum element\r\n   */\r\n  public static /*@pure@*/ int maxIndex(int [] ints) {\r\n\r\n    int maximum = 0;\r\n    int maxIndex = 0;\r\n\r\n    for (int i = 0; i \u003c ints.length; i++) {\r\n      if ((i == 0) || (ints[i] \u003e maximum)) {\r\n\tmaxIndex = i;\r\n\tmaximum = ints[i];\r\n      }\r\n    }\r\n\r\n    return maxIndex;\r\n  }\r\n\r\n  /**\r\n   * Computes the mean for an array of doubles.\r\n   *\r\n   * @param vector the array\r\n   * @return the mean\r\n   */\r\n  public static /*@pure@*/ double mean(double[] vector) {\r\n  \r\n    double sum = 0;\r\n\r\n    if (vector.length == 0) {\r\n      return 0;\r\n    }\r\n    for (int i = 0; i \u003c vector.length; i++) {\r\n      sum += vector[i];\r\n    }\r\n    return sum / (double) vector.length;\r\n  }\r\n\r\n  /**\r\n   * Returns index of minimum element in a given\r\n   * array of integers. First minimum is returned.\r\n   *\r\n   * @param ints the array of integers\r\n   * @return the index of the minimum element\r\n   */\r\n  public static /*@pure@*/ int minIndex(int [] ints) {\r\n\r\n    int minimum = 0;\r\n    int minIndex = 0;\r\n\r\n    for (int i = 0; i \u003c ints.length; i++) {\r\n      if ((i == 0) || (ints[i] \u003c minimum)) {\r\n\tminIndex = i;\r\n\tminimum = ints[i];\r\n      }\r\n    }\r\n\r\n    return minIndex;\r\n  }\r\n\r\n  /**\r\n   * Returns index of minimum element in a given\r\n   * array of doubles. First minimum is returned.\r\n   *\r\n   * @param doubles the array of doubles\r\n   * @return the index of the minimum element\r\n   */\r\n  public static /*@pure@*/ int minIndex(double [] doubles) {\r\n\r\n    double minimum = 0;\r\n    int minIndex = 0;\r\n\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      if ((i == 0) || (doubles[i] \u003c minimum)) {\r\n\tminIndex = i;\r\n\tminimum = doubles[i];\r\n      }\r\n    }\r\n\r\n    return minIndex;\r\n  }\r\n\r\n  /**\r\n   * Normalizes the doubles in the array by their sum.\r\n   *\r\n   * @param doubles the array of double\r\n   * @exception IllegalArgumentException if sum is Zero or NaN\r\n   */\r\n  public static void normalize(double[] doubles) {\r\n\r\n    double sum = 0;\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      sum += doubles[i];\r\n    }\r\n    normalize(doubles, sum);\r\n  }\r\n\r\n  /**\r\n   * Normalizes the doubles in the array using the given value.\r\n   *\r\n   * @param doubles the array of double\r\n   * @param sum the value by which the doubles are to be normalized\r\n   * @exception IllegalArgumentException if sum is zero or NaN\r\n   */\r\n  public static void normalize(double[] doubles, double sum) {\r\n\r\n    if (Double.isNaN(sum)) {\r\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is NaN.\");\r\n    }\r\n    if (sum == 0) {\r\n      // Maybe this should just be a return.\r\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is zero.\");\r\n    }\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      doubles[i] /= sum;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts an array containing the natural logarithms of\r\n   * probabilities stored in a vector back into probabilities.\r\n   * The probabilities are assumed to sum to one.\r\n   *\r\n   * @param a an array holding the natural logarithms of the probabilities\r\n   * @return the converted array \r\n   */\r\n  public static double[] logs2probs(double[] a) {\r\n\r\n    double max = a[maxIndex(a)];\r\n    double sum = 0.0;\r\n\r\n    double[] result = new double[a.length];\r\n    for(int i = 0; i \u003c a.length; i++) {\r\n      result[i] = Math.exp(a[i] - max);\r\n      sum += result[i];\r\n    }\r\n\r\n    normalize(result, sum);\r\n\r\n    return result;\r\n  } \r\n\r\n  /**\r\n   * Rounds a double to the next nearest integer value. The JDK version\r\n   * of it doesn't work properly.\r\n   *\r\n   * @param value the double value\r\n   * @return the resulting integer value\r\n   */\r\n  public static /*@pure@*/ int round(double value) {\r\n\r\n    int roundedValue = value \u003e 0\r\n      ? (int)(value + 0.5)\r\n      : -(int)(Math.abs(value) + 0.5);\r\n    \r\n    return roundedValue;\r\n  }\r\n\r\n  /**\r\n   * Rounds a double to the next nearest integer value in a probabilistic\r\n   * fashion (e.g. 0.8 has a 20% chance of being rounded down to 0 and a\r\n   * 80% chance of being rounded up to 1). In the limit, the average of\r\n   * the rounded numbers generated by this procedure should converge to\r\n   * the original double.\r\n   *\r\n   * @param value the double value\r\n   * @return the resulting integer value\r\n   */\r\n  public static int probRound(double value, Random rand) {\r\n\r\n    if (value \u003e= 0) {\r\n      double lower = Math.floor(value);\r\n      double prob = value - lower;\r\n      if (rand.nextDouble() \u003c prob) {\r\n\treturn (int)lower + 1;\r\n      } else {\r\n\treturn (int)lower;\r\n      }\r\n    } else {\r\n      double lower = Math.floor(Math.abs(value));\r\n      double prob = Math.abs(value) - lower;\r\n      if (rand.nextDouble() \u003c prob) {\r\n\treturn -((int)lower + 1);\r\n      } else {\r\n\treturn -(int)lower;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rounds a double to the given number of decimal places.\r\n   *\r\n   * @param value the double value\r\n   * @param afterDecimalPoint the number of digits after the decimal point\r\n   * @return the double rounded to the given precision\r\n   */\r\n  public static /*@pure@*/ double roundDouble(double value,int afterDecimalPoint) {\r\n\r\n    double mask = Math.pow(10.0, (double)afterDecimalPoint);\r\n\r\n    return (double)(Math.round(value * mask)) / mask;\r\n  }\r\n\r\n  /**\r\n   * Sorts a given array of integers in ascending order and returns an \r\n   * array of integers with the positions of the elements of the original \r\n   * array in the sorted array. The sort is stable. (Equal elements remain\r\n   * in their original order.)\r\n   *\r\n   * @param array this array is not changed by the method!\r\n   * @return an array of integers with the positions in the sorted\r\n   * array.\r\n   */\r\n  public static /*@pure@*/ int[] sort(int [] array) {\r\n\r\n    int [] index = new int[array.length];\r\n    int [] newIndex = new int[array.length];\r\n    int [] helpIndex;\r\n    int numEqual;\r\n    \r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n    }\r\n    quickSort(array, index, 0, array.length - 1);\r\n\r\n    // Make sort stable\r\n    int i = 0;\r\n    while (i \u003c index.length) {\r\n      numEqual = 1;\r\n      for (int j = i + 1; ((j \u003c index.length)\r\n\t\t\t   \u0026\u0026 (array[index[i]] == array[index[j]]));\r\n\t   j++) {\r\n\tnumEqual++;\r\n      }\r\n      if (numEqual \u003e 1) {\r\n\thelpIndex = new int[numEqual];\r\n\tfor (int j = 0; j \u003c numEqual; j++) {\r\n\t  helpIndex[j] = i + j;\r\n\t}\r\n\tquickSort(index, helpIndex, 0, numEqual - 1);\r\n\tfor (int j = 0; j \u003c numEqual; j++) {\r\n\t  newIndex[i + j] = index[helpIndex[j]];\r\n\t}\r\n\ti += numEqual;\r\n      } else {\r\n\tnewIndex[i] = index[i];\r\n\ti++;\r\n      }\r\n    }\r\n    return newIndex;\r\n  }\r\n\r\n  /**\r\n   * Sorts a given array of doubles in ascending order and returns an\r\n   * array of integers with the positions of the elements of the\r\n   * original array in the sorted array. NOTE THESE CHANGES: the sort\r\n   * is no longer stable and it doesn't use safe floating-point\r\n   * comparisons anymore. Occurrences of Double.NaN are treated as \r\n   * Double.MAX_VALUE\r\n   *\r\n   * @param array this array is not changed by the method!\r\n   * @return an array of integers with the positions in the sorted\r\n   * array.  \r\n   */\r\n  public static /*@pure@*/ int[] sort(/*@non_null@*/ double [] array) {\r\n\r\n    int [] index = new int[array.length];\r\n    array = (double [])array.clone();\r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n      if (Double.isNaN(array[i])) {\r\n        array[i] = Double.MAX_VALUE;\r\n      }\r\n    }\r\n    quickSort(array, index, 0, array.length - 1);\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Sorts a given array of doubles in ascending order and returns an \r\n   * array of integers with the positions of the elements of the original \r\n   * array in the sorted array. The sort is stable (Equal elements remain\r\n   * in their original order.) Occurrences of Double.NaN are treated as \r\n   * Double.MAX_VALUE\r\n   *\r\n   * @param array this array is not changed by the method!\r\n   * @return an array of integers with the positions in the sorted\r\n   * array.\r\n   */\r\n  public static /*@pure@*/ int[] stableSort(double [] array){\r\n\r\n    int [] index = new int[array.length];\r\n    int [] newIndex = new int[array.length];\r\n    int [] helpIndex;\r\n    int numEqual;\r\n    \r\n    array = (double [])array.clone();\r\n    for (int i = 0; i \u003c index.length; i++) {\r\n      index[i] = i;\r\n      if (Double.isNaN(array[i])) {\r\n        array[i] = Double.MAX_VALUE;\r\n      }\r\n    }\r\n    quickSort(array,index,0,array.length-1);\r\n\r\n    // Make sort stable\r\n\r\n    int i = 0;\r\n    while (i \u003c index.length) {\r\n      numEqual = 1;\r\n      for (int j = i+1; ((j \u003c index.length) \u0026\u0026 Utils.eq(array[index[i]],\r\n\t\t\t\t\t\t\tarray[index[j]])); j++)\r\n\tnumEqual++;\r\n      if (numEqual \u003e 1) {\r\n\thelpIndex = new int[numEqual];\r\n\tfor (int j = 0; j \u003c numEqual; j++)\r\n\t  helpIndex[j] = i+j;\r\n\tquickSort(index, helpIndex, 0, numEqual-1);\r\n\tfor (int j = 0; j \u003c numEqual; j++) \r\n\t  newIndex[i+j] = index[helpIndex[j]];\r\n\ti += numEqual;\r\n      } else {\r\n\tnewIndex[i] = index[i];\r\n\ti++;\r\n      }\r\n    }\r\n\r\n    return newIndex;\r\n  }\r\n\r\n  /**\r\n   * Computes the variance for an array of doubles.\r\n   *\r\n   * @param vector the array\r\n   * @return the variance\r\n   */\r\n  public static /*@pure@*/ double variance(double[] vector) {\r\n  \r\n    double sum = 0, sumSquared = 0;\r\n\r\n    if (vector.length \u003c= 1) {\r\n      return 0;\r\n    }\r\n    for (int i = 0; i \u003c vector.length; i++) {\r\n      sum += vector[i];\r\n      sumSquared += (vector[i] * vector[i]);\r\n    }\r\n    double result = (sumSquared - (sum * sum / (double) vector.length)) / \r\n      (double) (vector.length - 1);\r\n\r\n    // We don't like negative variance\r\n    if (result \u003c 0) {\r\n      return 0;\r\n    } else {\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Computes the sum of the elements of an array of doubles.\r\n   *\r\n   * @param doubles the array of double\r\n   * @return the sum of the elements\r\n   */\r\n  public static /*@pure@*/ double sum(double[] doubles) {\r\n\r\n    double sum = 0;\r\n\r\n    for (int i = 0; i \u003c doubles.length; i++) {\r\n      sum += doubles[i];\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * Computes the sum of the elements of an array of integers.\r\n   *\r\n   * @param ints the array of integers\r\n   * @return the sum of the elements\r\n   */\r\n  public static /*@pure@*/ int sum(int[] ints) {\r\n\r\n    int sum = 0;\r\n\r\n    for (int i = 0; i \u003c ints.length; i++) {\r\n      sum += ints[i];\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * Returns c*log2(c) for a given integer value c.\r\n   *\r\n   * @param c an integer value\r\n   * @return c*log2(c) (but is careful to return 0 if c is 0)\r\n   */\r\n  public static /*@pure@*/ double xlogx(int c) {\r\n    \r\n    if (c == 0) {\r\n      return 0.0;\r\n    }\r\n    return c * Utils.log2((double) c);\r\n  }\r\n\r\n  /**\r\n   * Partitions the instances around a pivot. Used by quicksort and\r\n   * kthSmallestValue.\r\n   *\r\n   * @param array the array of doubles to be sorted\r\n   * @param index the index into the array of doubles\r\n   * @param left the first index of the subset \r\n   * @param right the last index of the subset \r\n   *\r\n   * @return the index of the middle element\r\n   */\r\n  private static int partition(double[] array, int[] index, int l, int r) {\r\n    \r\n    double pivot = array[index[(l + r) / 2]];\r\n    int help;\r\n\r\n    while (l \u003c r) {\r\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\r\n        l++;\r\n      }\r\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\r\n        r--;\r\n      }\r\n      if (l \u003c r) {\r\n        help = index[l];\r\n        index[l] = index[r];\r\n        index[r] = help;\r\n        l++;\r\n        r--;\r\n      }\r\n    }\r\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\r\n      r--;\r\n    } \r\n\r\n    return r;\r\n  }\r\n\r\n  /**\r\n   * Partitions the instances around a pivot. Used by quicksort and\r\n   * kthSmallestValue.\r\n   *\r\n   * @param array the array of integers to be sorted\r\n   * @param index the index into the array of integers\r\n   * @param left the first index of the subset \r\n   * @param right the last index of the subset \r\n   *\r\n   * @return the index of the middle element\r\n   */\r\n  private static int partition(int[] array, int[] index, int l, int r) {\r\n    \r\n    double pivot = array[index[(l + r) / 2]];\r\n    int help;\r\n\r\n    while (l \u003c r) {\r\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\r\n        l++;\r\n      }\r\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\r\n        r--;\r\n      }\r\n      if (l \u003c r) {\r\n        help = index[l];\r\n        index[l] = index[r];\r\n        index[r] = help;\r\n        l++;\r\n        r--;\r\n      }\r\n    }\r\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\r\n      r--;\r\n    } \r\n\r\n    return r;\r\n  }\r\n  \r\n  /**\r\n   * Implements quicksort according to Manber's \"Introduction to\r\n   * Algorithms\".\r\n   *\r\n   * @param array the array of doubles to be sorted\r\n   * @param index the index into the array of doubles\r\n   * @param left the first index of the subset to be sorted\r\n   * @param right the last index of the subset to be sorted\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r\n  //@ requires array != index;\r\n  //  assignable index;\r\n  private static void quickSort(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \r\n                                int left, int right) {\r\n\r\n    if (left \u003c right) {\r\n      int middle = partition(array, index, left, right);\r\n      quickSort(array, index, left, middle);\r\n      quickSort(array, index, middle + 1, right);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Implements quicksort according to Manber's \"Introduction to\r\n   * Algorithms\".\r\n   *\r\n   * @param array the array of integers to be sorted\r\n   * @param index the index into the array of integers\r\n   * @param left the first index of the subset to be sorted\r\n   * @param right the last index of the subset to be sorted\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r\n  //@ requires array != index;\r\n  //  assignable index;\r\n  private static void quickSort(/*@non_null@*/ int[] array, /*@non_null@*/  int[] index, \r\n                                int left, int right) {\r\n\r\n    if (left \u003c right) {\r\n      int middle = partition(array, index, left, right);\r\n      quickSort(array, index, left, middle);\r\n      quickSort(array, index, middle + 1, right);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Implements computation of the kth-smallest element according\r\n   * to Manber's \"Introduction to Algorithms\".\r\n   *\r\n   * @param array the array of double\r\n   * @param index the index into the array of doubles\r\n   * @param left the first index of the subset \r\n   * @param right the last index of the subset \r\n   * @param k the value of k\r\n   *\r\n   * @return the index of the kth-smallest element\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  private static int select(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \r\n                            int left, int right, int k) {\r\n    \r\n    if (left == right) {\r\n      return left;\r\n    } else {\r\n      int middle = partition(array, index, left, right);\r\n      if ((middle - left + 1) \u003e= k) {\r\n        return select(array, index, left, middle, k);\r\n      } else {\r\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Implements computation of the kth-smallest element according\r\n   * to Manber's \"Introduction to Algorithms\".\r\n   *\r\n   * @param array the array of integers\r\n   * @param index the index into the array of integers\r\n   * @param left the first index of the subset \r\n   * @param right the last index of the subset \r\n   * @param k the value of k\r\n   *\r\n   * @return the index of the kth-smallest element\r\n   */\r\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n  private static int select(/*@non_null@*/ int[] array, /*@non_null@*/ int[] index, \r\n                            int left, int right, int k) {\r\n    \r\n    if (left == right) {\r\n      return left;\r\n    } else {\r\n      int middle = partition(array, index, left, right);\r\n      if ((middle - left + 1) \u003e= k) {\r\n        return select(array, index, left, middle, k);\r\n      } else {\r\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Main method for testing this class.\r\n   *\r\n   * @param ops some dummy options\r\n   */\r\n  public static void main(String[] ops) {\r\n\r\n    double[] doublesWithNaN = {4.5, 6.7, Double.NaN, 3.4, 4.8, 1.2, 3.4};\r\n    double[] doubles = {4.5, 6.7, 6.7, 3.4, 4.8, 1.2, 3.4, 6.7, 6.7, 3.4};\r\n    int[] ints = {12, 6, 2, 18, 16, 6, 7, 5, 18, 18, 17};\r\n\r\n    try {\r\n\r\n      // Option handling\r\n      System.out.println(\"First option split up:\");\r\n      if (ops.length \u003e 0) {\r\n\tString[] firstOptionSplitUp = Utils.splitOptions(ops[0]);\r\n\tfor (int i = 0; i \u003c firstOptionSplitUp.length; i ++) {\r\n\t  System.out.println(firstOptionSplitUp[i]);\r\n\t}\r\n      }\t\t\t\t\t       \r\n      System.out.println(\"Partitioned options: \");\r\n      String[] partitionedOptions = Utils.partitionOptions(ops);\r\n      for (int i  = 0; i \u003c partitionedOptions.length; i++) {\r\n\tSystem.out.println(partitionedOptions[i]);\r\n      }\r\n      System.out.println(\"Get flag -f: \" + Utils.getFlag('f', ops));\r\n      System.out.println(\"Get option -o: \" + Utils.getOption('o', ops));\r\n      System.out.println(\"Checking for remaining options... \");\r\n      Utils.checkForRemainingOptions(ops);\r\n      \r\n      // Statistics\r\n      System.out.println(\"Original array with NaN (doubles): \");\r\n      for (int i = 0; i \u003c doublesWithNaN.length; i++) {\r\n\tSystem.out.print(doublesWithNaN[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Original array (doubles): \");\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(doubles[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Original array (ints): \");\r\n      for (int i = 0; i \u003c ints.length; i++) {\r\n\tSystem.out.print(ints[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Correlation: \" + Utils.correlation(doubles, doubles, \r\n\t\t\t\t\t\t\t     doubles.length));\r\n      System.out.println(\"Mean: \" + Utils.mean(doubles));\r\n      System.out.println(\"Variance: \" + Utils.variance(doubles));\r\n      System.out.println(\"Sum (doubles): \" + Utils.sum(doubles));\r\n      System.out.println(\"Sum (ints): \" + Utils.sum(ints));\r\n      System.out.println(\"Max index (doubles): \" + Utils.maxIndex(doubles));\r\n      System.out.println(\"Max index (ints): \" + Utils.maxIndex(ints));\r\n      System.out.println(\"Min index (doubles): \" + Utils.minIndex(doubles));\r\n      System.out.println(\"Min index (ints): \" + Utils.minIndex(ints));\r\n      System.out.println(\"Median (doubles): \" + \r\n                         Utils.kthSmallestValue(doubles, doubles.length / 2));\r\n      System.out.println(\"Median (ints): \" + \r\n                         Utils.kthSmallestValue(ints, ints.length / 2));\r\n\r\n      // Sorting and normalizing\r\n      System.out.println(\"Sorted array with NaN (doubles): \");\r\n      int[] sorted = Utils.sort(doublesWithNaN);\r\n      for (int i = 0; i \u003c doublesWithNaN.length; i++) {\r\n\tSystem.out.print(doublesWithNaN[sorted[i]] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Sorted array (doubles): \");\r\n      sorted = Utils.sort(doubles);\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(doubles[sorted[i]] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Sorted array (ints): \");\r\n      sorted = Utils.sort(ints);\r\n      for (int i = 0; i \u003c ints.length; i++) {\r\n\tSystem.out.print(ints[sorted[i]] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Indices from stable sort (doubles): \");\r\n      sorted = Utils.stableSort(doubles);\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(sorted[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Indices from sort (ints): \");\r\n      sorted = Utils.sort(ints);\r\n      for (int i = 0; i \u003c ints.length; i++) {\r\n\tSystem.out.print(sorted[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Normalized array (doubles): \");\r\n      Utils.normalize(doubles);\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(doubles[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      System.out.println(\"Normalized again (doubles): \");\r\n      Utils.normalize(doubles, Utils.sum(doubles));\r\n      for (int i = 0; i \u003c doubles.length; i++) {\r\n\tSystem.out.print(doubles[i] + \" \");\r\n      }\r\n      System.out.println();\r\n      \r\n      // Pretty-printing\r\n      System.out.println(\"-4.58: \" + Utils.doubleToString(-4.57826535, 2));\r\n      System.out.println(\"-6.78: \" + Utils.doubleToString(-6.78214234, 6,2));\r\n      \r\n      // Comparisons\r\n      System.out.println(\"5.70001 == 5.7 ? \" + Utils.eq(5.70001, 5.7));\r\n      System.out.println(\"5.70001 \u003e 5.7 ? \" + Utils.gr(5.70001, 5.7));\r\n      System.out.println(\"5.70001 \u003e= 5.7 ? \" + Utils.grOrEq(5.70001, 5.7));\r\n      System.out.println(\"5.7 \u003c 5.70001 ? \" + Utils.sm(5.7, 5.70001));\r\n      System.out.println(\"5.7 \u003c= 5.70001 ? \" + Utils.smOrEq(5.7, 5.70001));\r\n      \r\n      // Math\r\n      System.out.println(\"Info (ints): \" + Utils.info(ints));\r\n      System.out.println(\"log2(4.6): \" + Utils.log2(4.6));\r\n      System.out.println(\"5 * log(5): \" + Utils.xlogx(5));\r\n      System.out.println(\"5.5 rounded: \" + Utils.round(5.5));\r\n      System.out.println(\"5.55555 rounded to 2 decimal places: \" + \r\n\t\t\t Utils.roundDouble(5.55555, 2));\r\n      \r\n      // Arrays\r\n      System.out.println(\"Array-Dimensions of 'new int[][]': \" + Utils.getArrayDimensions(new int[][]{}));\r\n      System.out.println(\"Array-Dimensions of 'new int[][]{{1,2,3},{4,5,6}}': \" + Utils.getArrayDimensions(new int[][]{{1,2,3},{4,5,6}}));\r\n      String[][][] s = new String[3][4][];\r\n      System.out.println(\"Array-Dimensions of 'new String[3][4][]': \" + Utils.getArrayDimensions(s));\r\n    } catch (Exception e) {\r\n      e.printStackTrace();\r\n    }\r\n  }\r\n}\r\n  \r\n",
        "name": "Utils.java",
        "path": "subjectSystems/C,D/src/weka/core/Utils.java",
        "url": "/github.com/LASER-UMASS/Themis/-/blob/subjectSystems/C,D/src/weka/core/Utils.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 1536,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1537,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1538,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1559,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1560,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1561,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1585,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1613,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        }
      ],
      "repository": {
        "name": "github.com/LASER-UMASS/Themis",
        "url": "/github.com/LASER-UMASS/Themis"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a70f12a6a8f34cdd8b170b4dc59a78674c9e8950"
        },
        "content": "/*\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; either version 2 of the License, or\n *    (at your option) any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n/*\n *    Queue.java\n *    Copyright (C) 1999 Len Trigg\n *\n *    Modified March-May 2004 by Mark Utting to add JML specs\n *    (this was done as the example solution of an assignment for a\n *     software engineering course, so the specifications are more precise\n *     and complete than one would normally do).\n *    Passed a static analysis using ESC/Java-2.0a6 with no warnings.\n*/\n\npackage weka.core;\n\nimport java.io.*;\n\n/** \n * Class representing a FIFO queue.\n *\n * @author Len Trigg (trigg@cs.waikato.ac.nz)\n * @version $Revision: 1.7 $\n */\npublic class Queue extends Object implements Serializable {\n\n  /**\n   * Represents one node in the queue.\n   */\n  protected class QueueNode implements Serializable {\n\n    /** The next node in the queue */\n    protected /*@ spec_public @*/ QueueNode m_Next;\n\n    /** The nodes contents\n     */\n    protected /*@ non_null spec_public @*/ Object m_Contents;\n\n    /** \n     * Creates a queue node with the given contents \n     */\n    //@ requires contents != null;\n    //@ assignable m_Contents, m_Next;\n    //@ ensures m_Contents == contents;\n    //@ ensures m_Next == null;\n    public QueueNode(Object contents) {\n      m_Contents = contents;\n      next(null);\n    }\n\n    /**\n     * Sets the next node in the queue, and returns it.\n     */\n    //@ requires next != this ;\n    //@ assignable m_Next;\n    //@ ensures m_Next==next \u0026\u0026 \\result==next;\n    public QueueNode next(QueueNode next) {\n      return m_Next = next;\n    } //@ nowarn Invariant; // Because it stupidly checks the Queue invariant!\n\n    /**\n     * Gets the next node in the queue. \n     */\n    //@ ensures \\result == m_Next;\n    public /*@ pure @*/ QueueNode next() {\n      return m_Next;\n    }\n\n    /**\n     * Sets the contents of the node.\n     */\n    //@ requires contents != null;\n    //@ assignable m_Contents;\n    //@ ensures  m_Contents == contents \u0026\u0026 \\result == contents;\n    public Object contents(Object contents) {\n      return m_Contents = contents;\n    }\n\n    /**\n     * Returns the contents in the node.\n     */\n      //@ ensures \\result == m_Contents;\n    public /*@ pure @*/ Object contents() {\n      return m_Contents;\n    }\n  }\n\n  /** Store a reference to the head of the queue */\n  protected /*@ spec_public @*/ QueueNode m_Head = null;\n\n  /** Store a reference to the tail of the queue */\n  protected /*@ spec_public @*/ QueueNode m_Tail = null;\n\n  /** Store the c m_Tail.m_Nexturrent number of elements in the queue */\n  protected /*@ spec_public @*/ int m_Size = 0;\n\n  //@ public invariant m_Head == null \u003c==\u003e m_Tail == null;\n  //@public invariant m_Tail != null ==\u003e m_Tail.m_Next == null;\n  //@ public invariant m_Size \u003e= 0;\n  //@ public invariant m_Size == 0 \u003c==\u003e m_Head == null;\n  //@ public invariant m_Size == 1 \u003c==\u003e m_Head != null \u0026\u0026 m_Head == m_Tail;\n  //@ public invariant m_Size \u003e 1 ==\u003e m_Head != m_Tail;\n  //@ public invariant m_Size \u003e 1 \u003c== m_Head != m_Tail;\n\n\n\n  /**\n   * Removes all objects from the queue m_Tail.m_Next.\n   */\n  //@ assignable m_Size, m_Head, m_Tail;\n  //@ ensures m_Size == 0;\n  //@ ensures m_Head == null;\n  //@ ensures m_Tail == null;\n  public final synchronized void removeAllElements() {\n    m_Size = 0;\n    m_Head = null;\n    m_Tail = null;\n  }\n\n  /**\n   * Appends an object to the back of the queue.\n   *\n   * @param item the object to be appended\n   * @return the object appended\n   */\n  //@ requires item != null;\n  //@ assignable m_Head, m_Tail, m_Tail.m_Next, m_Head.m_Next, m_Size;\n  //@ ensures m_Head != null;\n  //@ ensures m_Tail != \\old(m_Tail);\n  //@ ensures m_Size == \\old(m_Size) + 1;\n  //@ ensures \\old(m_Size) == 0 ==\u003e m_Head == m_Tail; \n  //@ ensures \\old(m_Size) != 0 ==\u003e m_Head == \\old(m_Head);\n  //@ ensures m_Tail.contents() == \\old(item);\n  //@ ensures \\result == item;\n  public synchronized Object push(Object item) {\n    QueueNode newNode = new QueueNode(item);\n    \n    if (m_Head == null) {\n      m_Head = m_Tail = newNode;\n    } else {\n      m_Tail = m_Tail.next(newNode);\n    }\n    m_Size++;\n    return item;\n  }\n\n  /**\n   * Pops an object from the front of the queue.\n   *\n   * @return the object at the front of the queue\n   * @exception RuntimeException if the queue is empty\n   */\n  //@ assignable m_Head, m_Tail, m_Size;\n  //@ ensures m_Size == \\old(m_Size) - 1;\n  //@ ensures m_Head == \\old(m_Head.m_Next);\n  //@ ensures m_Head != null ==\u003e m_Tail == \\old(m_Tail);\n  //@ ensures \\result == \\old(m_Head.m_Contents);\n  //@ signals (RuntimeException) \\old(m_Head) == null;\n  public synchronized Object pop() \n      throws RuntimeException   // REDUNDANT, BUT ESCJAVA REQUIRES THIS\n  {\n    if (m_Head == null) {\n\tthrow new RuntimeException(\"Queue is empty\");\n    }\n    Object retval = m_Head.contents();\n    m_Size--;\n    m_Head = m_Head.next();\n    // Here we need to either tell ESC/Java some facts about\n    // the contents of the list after popping off the head,\n    // or turn off the 'invariant' warnings.\n    //\n    //@ assume m_Size == 0 \u003c==\u003e m_Head == null;\n    //@ assume m_Size == 1 \u003c==\u003e m_Head == m_Tail;\n    if (m_Head == null) {\n      m_Tail = null;\n    }\n    return retval;\n  }\n\n  /**\n   * Gets object from the front of the queue.\n   *\n   * @return the object at the front of the queue\n   * @exception RuntimeException if the queue is empty\n   */\n  //@ ensures \\result == \\old(m_Head.m_Contents);\n  //@ signals (RuntimeException) \\old(m_Head) == null;\n  public /*@ pure @*/ synchronized Object peek() \n    throws RuntimeException\n  { \n    if (m_Head == null) {\n      throw new RuntimeException(\"Queue is empty\");\n    }\n    return m_Head.contents();\n  }\n\n  /**\n   * Checks if queue is empty.\n   * \n   * @return true if queue is empty\n   */\n  //@ ensures \\result \u003c==\u003e m_Head == null;\n  public /*@ pure @*/ boolean empty() {\n    return m_Head == null;\n  }\n\n  /**\n   * Gets queue's size.\n   *\n   * @return size of queue\n   */\n  //@ ensures \\result == m_Size;\n  public /*@ pure @*/ int size() {\n    return m_Size;\n  }\n\n  /**\n   * Produces textual description of queue.\n   *\n   * @return textual description of queue\n   */\n  //@ also\n  //@ ensures \\result != null;\n  //@ ensures (* \\result == textual description of the queue *);\n  public  /*@ pure @*/ String toString() {\n\n    String retval = \"Queue Contents \"+m_Size+\" elements\\n\";\n    QueueNode current = m_Head;\n    if (current == null) {\n      return retval + \"Empty\\n\";\n    } else {\n      while (current != null) {\n        retval += current.contents().toString()+\"\\n\"; //@nowarn Modifies;\n\tcurrent = current.next();\n      }\n    }\n    return retval;\n  } //@ nowarn Post;\n\n  /**\n   * Main method for testing this class.\n   *\n   * @param argv a set of strings that are pushed on a test queue\n   */\n  //@ requires argv.length \u003e= 0;\n  //@ requires argv != null;\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c argv.length; argv[i] != null);\n  public static void main(String [] argv) {\n\n    try {\n      Queue queue = new Queue();\n      for(int i = 0; i \u003c argv.length; i++) {\n\tqueue.push(argv[i]);\n      }\n      System.out.println(\"After pushing command line arguments\");\n      System.out.println(queue.toString());\n      while (!queue.empty()) {\n\tSystem.out.println(\"Pop: \" + queue.pop().toString());\n      }\n      // try one more pop, to make sure we get an exception\n      try \n\t{\n\t  queue.pop();\n\t  System.out.println(\"ERROR: pop did not throw exception!\");\n\t}\n      catch (RuntimeException ex)\n        {\n\t  System.out.println(\"Pop on empty queue correctly gave exception.\");\n\t}\n    } catch (Exception ex) {\n      System.out.println(ex.getMessage());\n    }\n  }\n}\n",
        "name": "Queue.java",
        "path": "subjectSystems/C,D/src/weka/core/Queue.java",
        "url": "/github.com/LASER-UMASS/Themis/-/blob/subjectSystems/C,D/src/weka/core/Queue.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 54,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires contents != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 56,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures m_Contents == contents;"
        },
        {
          "limitHit": false,
          "lineNumber": 57,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures m_Next == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 66,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires next != this ;"
        },
        {
          "limitHit": false,
          "lineNumber": 68,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures m_Next==next \u0026\u0026 \\result==next;"
        },
        {
          "limitHit": false,
          "lineNumber": 76,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result == m_Next;"
        },
        {
          "limitHit": false,
          "lineNumber": 84,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires contents != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 94,
          "offsetAndLengths": [
            [
              6,
              12
            ]
          ],
          "preview": "      //@ ensures \\result == m_Contents;"
        },
        {
          "limitHit": false,
          "lineNumber": 123,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Size == 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 124,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 125,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Tail == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 138,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires item != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 140,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 141,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Tail != \\old(m_Tail);"
        },
        {
          "limitHit": false,
          "lineNumber": 142,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Size == \\old(m_Size) + 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 143,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\old(m_Size) == 0 ==\u003e m_Head == m_Tail; "
        },
        {
          "limitHit": false,
          "lineNumber": 144,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\old(m_Size) != 0 ==\u003e m_Head == \\old(m_Head);"
        },
        {
          "limitHit": false,
          "lineNumber": 145,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Tail.contents() == \\old(item);"
        },
        {
          "limitHit": false,
          "lineNumber": 146,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == item;"
        },
        {
          "limitHit": false,
          "lineNumber": 166,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Size == \\old(m_Size) - 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 167,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head == \\old(m_Head.m_Next);"
        },
        {
          "limitHit": false,
          "lineNumber": 168,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head != null ==\u003e m_Tail == \\old(m_Tail);"
        },
        {
          "limitHit": false,
          "lineNumber": 169,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == \\old(m_Head.m_Contents);"
        },
        {
          "limitHit": false,
          "lineNumber": 198,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == \\old(m_Head.m_Contents);"
        },
        {
          "limitHit": false,
          "lineNumber": 214,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e m_Head == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 224,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Size;"
        },
        {
          "limitHit": false,
          "lineNumber": 235,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 236,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures (* \\result == textual description of the queue *);"
        },
        {
          "limitHit": false,
          "lineNumber": 257,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires argv.length \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 258,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires argv != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 259,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c argv.length; argv[i] != null);"
        },
        {
          "limitHit": false,
          "lineNumber": 86,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  m_Contents == contents \u0026\u0026 \\result == contents;"
        }
      ],
      "repository": {
        "name": "github.com/LASER-UMASS/Themis",
        "url": "/github.com/LASER-UMASS/Themis"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a70f12a6a8f34cdd8b170b4dc59a78674c9e8950"
        },
        "content": "/*\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; either version 2 of the License, or\n *    (at your option) any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n/*\n *    Instance.java\n *    Copyright (C) 1999 Eibe Frank\n *\n */\n\npackage weka.core;\n\nimport java.util.*;\nimport java.io.*;\n\n/**\n * Class for handling an instance. All values (numeric, date, nominal, or\n * string) are internally stored as floating-point numbers. If an\n * attribute is nominal (or a string), the stored value is the index\n * of the corresponding nominal (or string) value in the attribute's\n * definition. We have chosen this approach in favor of a more elegant\n * object-oriented approach because it is much faster. \u003cp\u003e\n *\n * Typical usage (code from the main() method of this class): \u003cp\u003e\n *\n * \u003ccode\u003e\n * ... \u003cbr\u003e\n *      \n * // Create empty instance with three attribute values \u003cbr\u003e\n * Instance inst = new Instance(3); \u003cbr\u003e\u003cbr\u003e\n *     \n * // Set instance's values for the attributes \"length\", \"weight\", and \"position\"\u003cbr\u003e\n * inst.setValue(length, 5.3); \u003cbr\u003e\n * inst.setValue(weight, 300); \u003cbr\u003e\n * inst.setValue(position, \"first\"); \u003cbr\u003e\u003cbr\u003e\n *   \n * // Set instance's dataset to be the dataset \"race\" \u003cbr\u003e\n * inst.setDataset(race); \u003cbr\u003e\u003cbr\u003e\n *   \n * // Print the instance \u003cbr\u003e\n * System.out.println(\"The instance: \" + inst); \u003cbr\u003e\n *\n * ... \u003cbr\u003e\n * \u003c/code\u003e\u003cp\u003e\n *\n * All methods that change an instance are safe, ie. a change of an\n * instance does not affect any other instances. All methods that\n * change an instance's attribute values clone the attribute value\n * vector before it is changed. If your application heavily modifies\n * instance values, it may be faster to create a new instance from scratch.\n *\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\n * @version $Revision: 1.19.2.2 $ \n */\npublic class Instance implements Copyable, Serializable {\n  \n  /** Constant representing a missing value. */\n  protected static final double MISSING_VALUE = Double.NaN;\n\n  /** \n   * The dataset the instance has access to.  Null if the instance\n   * doesn't have access to any dataset.  Only if an instance has\n   * access to a dataset, it knows about the actual attribute types.  \n   */\n  protected /*@spec_public@*/ Instances m_Dataset;\n\n  /** The instance's attribute values. */\n  protected /*@spec_public non_null@*/ double[] m_AttValues;\n\n  /** The instance's weight. */\n  protected double m_Weight;\n\n  /**\n   * Constructor that copies the attribute values and the weight from\n   * the given instance. Reference to the dataset is set to null.\n   * (ie. the instance doesn't have access to information about the\n   * attribute types)\n   *\n   * @param instance the instance from which the attribute\n   * values and the weight are to be copied \n   */\n  //@ ensures m_Dataset == null;\n  protected Instance(/*@non_null@*/ Instance instance) {\n    \n    m_AttValues = instance.m_AttValues;\n    m_Weight = instance.m_Weight;\n    m_Dataset = null;\n  }\n\n  /**\n   * Constructor that inititalizes instance variable with given\n   * values. Reference to the dataset is set to null. (ie. the instance\n   * doesn't have access to information about the attribute types)\n   *\n   * @param weight the instance's weight\n   * @param attValues a vector of attribute values \n   */\n  //@ ensures m_Dataset == null;\n  public Instance(double weight,  /*@non_null@*/ double[]attValues){\n    \n    m_AttValues = attValues;\n    m_Weight = weight;\n    m_Dataset = null;\n  }\n\n  /**\n   * Constructor of an instance that sets weight to one, all values to\n   * be missing, and the reference to the dataset to null. (ie. the instance\n   * doesn't have access to information about the attribute types)\n   *\n   * @param numAttributes the size of the instance \n   */\n  //@ requires numAttributes \u003e 0;    // Or maybe == 0 is okay too?\n  //@ ensures m_Dataset == null;\n  public Instance(int numAttributes) {\n    \n    m_AttValues = new double[numAttributes];\n    for (int i = 0; i \u003c m_AttValues.length; i++) {\n      m_AttValues[i] = MISSING_VALUE;\n    }\n    m_Weight = 1;\n    m_Dataset = null;\n  }\n\n  /**\n   * Returns the attribute with the given index.\n   *\n   * @param index the attribute's index\n   * @return the attribute at the given position\n   * @exception UnassignedDatasetException if instance doesn't have access to a\n   * dataset\n   */ \n  //@ requires m_Dataset != null;\n  public /*@pure@*/ Attribute attribute(int index) {\n   \n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    return m_Dataset.attribute(index);\n  }\n\n  /**\n   * Returns the attribute with the given index. Does the same\n   * thing as attribute().\n   *\n   * @param indexOfIndex the index of the attribute's index \n   * @return the attribute at the given position\n   * @exception UnassignedDatasetException if instance doesn't have access to a\n   * dataset\n   */ \n  //@ requires m_Dataset != null;\n  public /*@pure@*/ Attribute attributeSparse(int indexOfIndex) {\n   \n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    return m_Dataset.attribute(indexOfIndex);\n  }\n\n  /**\n   * Returns class attribute.\n   *\n   * @return the class attribute\n   * @exception UnassignedDatasetException if the class is not set or the\n   * instance doesn't have access to a dataset\n   */\n  //@ requires m_Dataset != null;\n  public /*@pure@*/ Attribute classAttribute() {\n\n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    return m_Dataset.classAttribute();\n  }\n\n  /**\n   * Returns the class attribute's index.\n   *\n   * @return the class index as an integer \n   * @exception UnassignedDatasetException if instance doesn't have access to a dataset \n   */\n  //@ requires m_Dataset != null;\n  //@ ensures  \\result == m_Dataset.classIndex();\n  public /*@pure@*/ int classIndex() {\n    \n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    return m_Dataset.classIndex();\n  }\n\n  /**\n   * Tests if an instance's class is missing.\n   *\n   * @return true if the instance's class is missing\n   * @exception UnassignedClassException if the class is not set or the instance doesn't\n   * have access to a dataset\n   */\n  //@ requires classIndex() \u003e= 0;\n  public /*@pure@*/ boolean classIsMissing() {\n\n    if (classIndex() \u003c 0) {\n      throw new UnassignedClassException(\"Class is not set!\");\n    }\n    return isMissing(classIndex());\n  }\n\n  /**\n   * Returns an instance's class value in internal format. (ie. as a\n   * floating-point number)\n   *\n   * @return the corresponding value as a double (If the \n   * corresponding attribute is nominal (or a string) then it returns the \n   * value's index as a double).\n   * @exception UnassignedClassException if the class is not set or the instance doesn't\n   * have access to a dataset \n   */\n  //@ requires classIndex() \u003e= 0;\n  public /*@pure@*/ double classValue() {\n    \n    if (classIndex() \u003c 0) {\n      throw new UnassignedClassException(\"Class is not set!\");\n    }\n    return value(classIndex());\n  }\n\n  /**\n   * Produces a shallow copy of this instance. The copy has\n   * access to the same dataset. (if you want to make a copy\n   * that doesn't have access to the dataset, use \n   * \u003ccode\u003enew Instance(instance)\u003c/code\u003e\n   *\n   * @return the shallow copy\n   */\n  //@ also ensures \\result != null;\n  //@ also ensures \\result instanceof Instance;\n  //@ also ensures ((Instance)\\result).m_Dataset == m_Dataset;\n  public /*@pure@*/ Object copy() {\n\n    Instance result = new Instance(this);\n    result.m_Dataset = m_Dataset;\n    return result;\n  }\n\n  /**\n   * Returns the dataset this instance has access to. (ie. obtains\n   * information about attribute types from) Null if the instance\n   * doesn't have access to a dataset.\n   *\n   * @return the dataset the instance has accesss to\n   */\n  //@ ensures \\result == m_Dataset;\n  public /*@pure@*/ Instances dataset() {\n\n    return m_Dataset;\n  }\n\n  /**\n   * Deletes an attribute at the given position (0 to \n   * numAttributes() - 1). Only succeeds if the instance does not\n   * have access to any dataset because otherwise inconsistencies\n   * could be introduced.\n   *\n   * @param pos the attribute's position\n   * @exception RuntimeException if the instance has access to a\n   * dataset \n   */\n  //@ requires m_Dataset != null;\n  public void deleteAttributeAt(int position) {\n\n    if (m_Dataset != null) {\n      throw new RuntimeException(\"Instance has access to a dataset!\");\n    }\n    forceDeleteAttributeAt(position);\n  }\n\n  /**\n   * Returns an enumeration of all the attributes.\n   *\n   * @return enumeration of all the attributes\n   * @exception UnassignedDatasetException if the instance doesn't\n   * have access to a dataset \n   */\n  //@ requires m_Dataset != null;\n  public /*@pure@*/ Enumeration enumerateAttributes() {\n\n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    return m_Dataset.enumerateAttributes();\n  }\n\n  /**\n   * Tests if the headers of two instances are equivalent.\n   *\n   * @param instance another instance\n   * @return true if the header of the given instance is \n   * equivalent to this instance's header\n   * @exception UnassignedDatasetException if instance doesn't have access to any\n   * dataset\n   */\n  //@ requires m_Dataset != null;\n  public /*@pure@*/ boolean equalHeaders(Instance inst) {\n\n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    return m_Dataset.equalHeaders(inst.m_Dataset);\n  }\n\n  /**\n   * Tests whether an instance has a missing value. Skips the class attribute if set.\n   * @return true if instance has a missing value.\n   * @exception UnassignedDatasetException if instance doesn't have access to any\n   * dataset\n   */\n  //@ requires m_Dataset != null;\n  public /*@pure@*/ boolean hasMissingValue() {\n    \n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      if (i != classIndex()) {\n\tif (isMissing(i)) {\n\t  return true;\n\t}\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Returns the index of the attribute stored at the given position.\n   * Just returns the given value.\n   *\n   * @param position the position \n   * @return the index of the attribute stored at the given position\n   */\n  public /*@pure@*/ int index(int position) {\n\n    return position;\n  }\n\n  /**\n   * Inserts an attribute at the given position (0 to \n   * numAttributes()). Only succeeds if the instance does not\n   * have access to any dataset because otherwise inconsistencies\n   * could be introduced.\n   *\n   * @param pos the attribute's position\n   * @exception RuntimeException if the instance has accesss to a\n   * dataset\n   * @exception IllegalArgumentException if the position is out of range\n   */\n  //@ requires m_Dataset == null;\n  //@ requires 0 \u003c= position \u0026\u0026 position \u003c= numAttributes();\n  public void insertAttributeAt(int position) {\n\n    if (m_Dataset != null) {\n      throw new RuntimeException(\"Instance has accesss to a dataset!\");\n    }\n    if ((position \u003c 0) ||\n\t(position \u003e numAttributes())) {\n      throw new IllegalArgumentException(\"Can't insert attribute: index out \"+\n                                         \"of range\");\n    }\n    forceInsertAttributeAt(position);\n  }\n\n  /**\n   * Tests if a specific value is \"missing\".\n   *\n   * @param attIndex the attribute's index\n   */\n  public /*@pure@*/ boolean isMissing(int attIndex) {\n\n    if (Double.isNaN(m_AttValues[attIndex])) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Tests if a specific value is \"missing\". Does\n   * the same thing as isMissing() if applied to an Instance.\n   *\n   * @param indexOfIndex the index of the attribute's index \n   */\n  public /*@pure@*/ boolean isMissingSparse(int indexOfIndex) {\n\n    if (Double.isNaN(m_AttValues[indexOfIndex])) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Tests if a specific value is \"missing\".\n   * The given attribute has to belong to a dataset.\n   *\n   * @param att the attribute\n   */\n  public /*@pure@*/ boolean isMissing(Attribute att) {\n\n    return isMissing(att.index());\n  }\n\n  /**\n   * Tests if the given value codes \"missing\".\n   *\n   * @param val the value to be tested\n   * @return true if val codes \"missing\"\n   */\n  public static /*@pure@*/ boolean isMissingValue(double val) {\n\n    return Double.isNaN(val);\n  }\n\n  /**\n   * Merges this instance with the given instance and returns\n   * the result. Dataset is set to null.\n   *\n   * @param inst the instance to be merged with this one\n   * @return the merged instances\n   */\n  public Instance mergeInstance(Instance inst) {\n\n    int m = 0;\n    double [] newVals = new double[numAttributes() + inst.numAttributes()];\n    for (int j = 0; j \u003c numAttributes(); j++, m++) {\n      newVals[m] = value(j);\n    }\n    for (int j = 0; j \u003c inst.numAttributes(); j++, m++) {\n      newVals[m] = inst.value(j);\n    }\n    return new Instance(1.0, newVals);\n  }\n\n  /**\n   * Returns the double that codes \"missing\".\n   *\n   * @return the double that codes \"missing\"\n   */\n  public /*@pure@*/ static double missingValue() {\n\n    return MISSING_VALUE;\n  }\n\n  /**\n   * Returns the number of attributes.\n   *\n   * @return the number of attributes as an integer\n   */\n  //@ ensures \\result == m_AttValues.length;\n  public /*@pure@*/ int numAttributes() {\n\n    return m_AttValues.length;\n  }\n\n  /**\n   * Returns the number of class labels.\n   *\n   * @return the number of class labels as an integer if the \n   * class attribute is nominal, 1 otherwise.\n   * @exception UnassignedDatasetException if instance doesn't have access to any\n   * dataset\n   */\n  //@ requires m_Dataset != null;\n  public /*@pure@*/ int numClasses() {\n    \n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    return m_Dataset.numClasses();\n  }\n\n  /**\n   * Returns the number of values present. Always the same as numAttributes().\n   *\n   * @return the number of values\n   */\n  //@ ensures \\result == m_AttValues.length;\n  public /*@pure@*/ int numValues() {\n\n    return m_AttValues.length;\n  }\n\n  /** \n   * Replaces all missing values in the instance with the\n   * values contained in the given array. A deep copy of\n   * the vector of attribute values is performed before the\n   * values are replaced.\n   *\n   * @param array containing the means and modes\n   * @exception IllegalArgumentException if numbers of attributes are unequal\n   */\n  public void replaceMissingValues(double[] array) {\n\t \n    if ((array == null) || \n\t(array.length != m_AttValues.length)) {\n      throw new IllegalArgumentException(\"Unequal number of attributes!\");\n    }\n    freshAttributeVector();\n    for (int i = 0; i \u003c m_AttValues.length; i++) {\n      if (isMissing(i)) {\n\tm_AttValues[i] = array[i];\n      }\n    }\n  }\n\n  /**\n   * Sets the class value of an instance to be \"missing\". A deep copy of\n   * the vector of attribute values is performed before the\n   * value is set to be missing.\n   *\n   * @exception UnassignedClassException if the class is not set\n   * @exception UnassignedDatasetException if the instance doesn't\n   * have access to a dataset\n   */\n  //@ requires classIndex() \u003e= 0;\n  public void setClassMissing() {\n\n    if (classIndex() \u003c 0) {\n      throw new UnassignedClassException(\"Class is not set!\");\n    }\n    setMissing(classIndex());\n  }\n\n  /**\n   * Sets the class value of an instance to the given value (internal\n   * floating-point format).  A deep copy of the vector of attribute\n   * values is performed before the value is set.\n   *\n   * @param value the new attribute value (If the corresponding\n   * attribute is nominal (or a string) then this is the new value's\n   * index as a double).  \n   * @exception UnassignedClassException if the class is not set\n   * @exception UnaddignedDatasetException if the instance doesn't\n   * have access to a dataset \n   */\n  //@ requires classIndex() \u003e= 0;\n  public void setClassValue(double value) {\n\n    if (classIndex() \u003c 0) {\n      throw new UnassignedClassException(\"Class is not set!\");\n    }\n    setValue(classIndex(), value);\n  }\n\n  /**\n   * Sets the class value of an instance to the given value. A deep\n   * copy of the vector of attribute values is performed before the\n   * value is set.\n   *\n   * @param value the new class value (If the class\n   * is a string attribute and the value can't be found,\n   * the value is added to the attribute).\n   * @exception UnassignedClassException if the class is not set\n   * @exception UnassignedDatasetException if the dataset is not set\n   * @exception IllegalArgumentException if the attribute is not\n   * nominal or a string, or the value couldn't be found for a nominal\n   * attribute \n   */\n  //@ requires classIndex() \u003e= 0;\n  public final void setClassValue(String value) {\n\n    if (classIndex() \u003c 0) {\n      throw new UnassignedClassException(\"Class is not set!\");\n    }\n    setValue(classIndex(), value);\n  }\n\n  /**\n   * Sets the reference to the dataset. Does not check if the instance\n   * is compatible with the dataset. Note: the dataset does not know\n   * about this instance. If the structure of the dataset's header\n   * gets changed, this instance will not be adjusted automatically.\n   *\n   * @param instances the reference to the dataset \n   */\n  public final void setDataset(Instances instances) {\n    \n    m_Dataset = instances;\n  }\n\n  /**\n   * Sets a specific value to be \"missing\". Performs a deep copy\n   * of the vector of attribute values before the value is set to\n   * be missing.\n   *\n   * @param attIndex the attribute's index\n   */\n  public final void setMissing(int attIndex) {\n\n    setValue(attIndex, MISSING_VALUE);\n  }\n\n  /**\n   * Sets a specific value to be \"missing\". Performs a deep copy\n   * of the vector of attribute values before the value is set to\n   * be missing. The given attribute has to belong to a dataset.\n   *\n   * @param att the attribute\n   */\n  public final void setMissing(Attribute att) {\n\n    setMissing(att.index());\n  }\n\n  /**\n   * Sets a specific value in the instance to the given value \n   * (internal floating-point format). Performs a deep copy\n   * of the vector of attribute values before the value is set.\n   *\n   * @param attIndex the attribute's index \n   * @param value the new attribute value (If the corresponding\n   * attribute is nominal (or a string) then this is the new value's\n   * index as a double).  \n   */\n  public void setValue(int attIndex, double value) {\n    \n    freshAttributeVector();\n    m_AttValues[attIndex] = value;\n  }\n\n  /**\n   * Sets a specific value in the instance to the given value \n   * (internal floating-point format). Performs a deep copy\n   * of the vector of attribute values before the value is set.\n   * Does exactly the same thing as setValue().\n   *\n   * @param indexOfIndex the index of the attribute's index \n   * @param value the new attribute value (If the corresponding\n   * attribute is nominal (or a string) then this is the new value's\n   * index as a double).  \n   */\n  public void setValueSparse(int indexOfIndex, double value) {\n    \n    freshAttributeVector();\n    m_AttValues[indexOfIndex] = value;\n  }\n\n  /**\n   * Sets a value of a nominal or string attribute to the given\n   * value. Performs a deep copy of the vector of attribute values\n   * before the value is set.\n   *\n   * @param attIndex the attribute's index\n   * @param value the new attribute value (If the attribute\n   * is a string attribute and the value can't be found,\n   * the value is added to the attribute).\n   * @exception UnassignedDatasetException if the dataset is not set\n   * @exception IllegalArgumentException if the selected\n   * attribute is not nominal or a string, or the supplied value couldn't \n   * be found for a nominal attribute \n   */\n  //@ requires m_Dataset != null;\n  public final void setValue(int attIndex, String value) {\n    \n    int valIndex;\n\n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    }\n    if (!attribute(attIndex).isNominal() \u0026\u0026\n\t!attribute(attIndex).isString()) {\n      throw new IllegalArgumentException(\"Attribute neither nominal nor string!\");\n    }\n    valIndex = attribute(attIndex).indexOfValue(value);\n    if (valIndex == -1) {\n      if (attribute(attIndex).isNominal()) {\n\tthrow new IllegalArgumentException(\"Value not defined for given nominal attribute!\");\n      } else {\n\tattribute(attIndex).forceAddValue(value);\n\tvalIndex = attribute(attIndex).indexOfValue(value);\n      }\n    }\n    setValue(attIndex, (double)valIndex); \n  }\n\n  /**\n   * Sets a specific value in the instance to the given value\n   * (internal floating-point format). Performs a deep copy of the\n   * vector of attribute values before the value is set, so if you are\n   * planning on calling setValue many times it may be faster to\n   * create a new instance using toDoubleArray.  The given attribute\n   * has to belong to a dataset.\n   *\n   * @param att the attribute \n   * @param value the new attribute value (If the corresponding\n   * attribute is nominal (or a string) then this is the new value's\n   * index as a double).  \n   */\n  public final void setValue(Attribute att, double value) {\n\n    setValue(att.index(), value);\n  }\n\n  /**\n   * Sets a value of an nominal or string attribute to the given\n   * value. Performs a deep copy of the vector of attribute values\n   * before the value is set, so if you are planning on calling setValue many\n   * times it may be faster to create a new instance using toDoubleArray.\n   * The given attribute has to belong to a dataset.\n   *\n   * @param att the attribute\n   * @param value the new attribute value (If the attribute\n   * is a string attribute and the value can't be found,\n   * the value is added to the attribute).\n   * @exception IllegalArgumentException if the the attribute is not\n   * nominal or a string, or the value couldn't be found for a nominal\n   * attribute \n   */\n  public final void setValue(Attribute att, String value) {\n\n    if (!att.isNominal() \u0026\u0026\n\t!att.isString()) {\n      throw new IllegalArgumentException(\"Attribute neither nominal nor string!\");\n    }\n    int valIndex = att.indexOfValue(value);\n    if (valIndex == -1) {\n      if (att.isNominal()) {\n\tthrow new IllegalArgumentException(\"Value not defined for given nominal attribute!\");\n      } else {\n\tatt.forceAddValue(value);\n\tvalIndex = att.indexOfValue(value);\n      }\n    }\n    setValue(att.index(), (double)valIndex);\n  }\n\n  /**\n   * Sets the weight of an instance.\n   *\n   * @param weight the weight\n   */\n  public final void setWeight(double weight) {\n\n    m_Weight = weight;\n  }\n\n  /** \n   * Returns the string value of a nominal, string, or date attribute\n   * for the instance.\n   *\n   * @param attIndex the attribute's index\n   * @return the value as a string\n   * @exception IllegalArgumentException if the attribute is not a nominal,\n   * string, or date attribute.\n   * @exception UnassignedDatasetException if the instance doesn't belong\n   * to a dataset.\n   */\n  //@ requires m_Dataset != null;\n  public final /*@pure@*/ String stringValue(int attIndex) {\n\n    if (m_Dataset == null) {\n      throw new UnassignedDatasetException(\"Instance doesn't have access to a dataset!\");\n    } \n    return stringValue(m_Dataset.attribute(attIndex));\n  }\n\n  /** \n   * Returns the string value of a nominal, string, or date attribute\n   * for the instance.\n   *\n   * @param att the attribute\n   * @return the value as a string\n   * @exception IllegalArgumentException if the attribute is not a nominal,\n   * string, or date attribute.\n   * @exception UnassignedDatasetException if the instance doesn't belong\n   * to a dataset.\n   */\n  public final /*@pure@*/ String stringValue(Attribute att) {\n\n    int attIndex = att.index();\n    switch (att.type()) {\n    case Attribute.NOMINAL:\n    case Attribute.STRING:\n      return att.value((int) value(attIndex));\n    case Attribute.DATE:\n      return att.formatDate(value(attIndex));\n    default:\n      throw new IllegalArgumentException(\"Attribute isn't nominal, string or date!\");\n    }\n  }\n\n  /**\n   * Returns the values of each attribute as an array of doubles.\n   *\n   * @return an array containing all the instance attribute values\n   */\n  public double[] toDoubleArray() {\n\n    double[] newValues = new double[m_AttValues.length];\n    System.arraycopy(m_AttValues, 0, newValues, 0, \n\t\t     m_AttValues.length);\n    return newValues;\n  }\n\n  /**\n   * Returns the description of one instance. If the instance\n   * doesn't have access to a dataset, it returns the internal\n   * floating-point values. Quotes string\n   * values that contain whitespace characters.\n   *\n   * @return the instance's description as a string\n   */\n  public String toString() {\n\n    StringBuffer text = new StringBuffer();\n    \n    for (int i = 0; i \u003c m_AttValues.length; i++) {\n      if (i \u003e 0) text.append(\",\");\n      text.append(toString(i));\n    }\n\n    return text.toString();\n  }\n\n  /**\n   * Returns the description of one value of the instance as a \n   * string. If the instance doesn't have access to a dataset, it \n   * returns the internal floating-point value. Quotes string\n   * values that contain whitespace characters, or if they\n   * are a question mark.\n   *\n   * @param attIndex the attribute's index\n   * @return the value's description as a string\n   */\n  public final /*@pure@*/ String toString(int attIndex) {\n\n   StringBuffer text = new StringBuffer();\n   \n   if (isMissing(attIndex)) {\n     text.append(\"?\");\n   } else {\n     if (m_Dataset == null) {\n       text.append(Utils.doubleToString(m_AttValues[attIndex],6));\n     } else {\n       switch (m_Dataset.attribute(attIndex).type()) {\n       case Attribute.NOMINAL:\n       case Attribute.STRING:\n       case Attribute.DATE:\n         text.append(Utils.quote(stringValue(attIndex)));\n         break;\n       case Attribute.NUMERIC:\n\t text.append(Utils.doubleToString(value(attIndex),6));\n         break;\n       default:\n         throw new IllegalStateException(\"Unknown attribute type\");\n       }\n     }\n   }\n   return text.toString();\n  }\n\n  /**\n   * Returns the description of one value of the instance as a \n   * string. If the instance doesn't have access to a dataset it \n   * returns the internal floating-point value. Quotes string\n   * values that contain whitespace characters, or if they\n   * are a question mark.\n   * The given attribute has to belong to a dataset.\n   *\n   * @param att the attribute\n   * @return the value's description as a string\n   */\n  public final String toString(Attribute att) {\n   \n   return toString(att.index());\n  }\n\n  /**\n   * Returns an instance's attribute value in internal format.\n   *\n   * @param attIndex the attribute's index\n   * @return the specified value as a double (If the corresponding\n   * attribute is nominal (or a string) then it returns the value's index as a \n   * double).\n   */\n  public /*@pure@*/ double value(int attIndex) {\n\n    return m_AttValues[attIndex];\n  }\n\n  /**\n   * Returns an instance's attribute value in internal format.\n   * Does exactly the same thing as value() if applied to an Instance.\n   *\n   * @param indexOfIndex the index of the attribute's index\n   * @return the specified value as a double (If the corresponding\n   * attribute is nominal (or a string) then it returns the value's index as a \n   * double).\n   */\n  public /*@pure@*/ double valueSparse(int indexOfIndex) {\n\n    return m_AttValues[indexOfIndex];\n  }  \n\n  /**\n   * Returns an instance's attribute value in internal format.\n   * The given attribute has to belong to a dataset.\n   *\n   * @param att the attribute\n   * @return the specified value as a double (If the corresponding\n   * attribute is nominal (or a string) then it returns the value's index as a\n   * double).\n   */\n  public /*@pure@*/ double value(Attribute att) {\n\n    return value(att.index());\n  }\n\n  /**\n   * Returns the instance's weight.\n   *\n   * @return the instance's weight as a double\n   */\n  public final /*@pure@*/ double weight() {\n\n    return m_Weight;\n  }\n\n  /**\n   * Deletes an attribute at the given position (0 to \n   * numAttributes() - 1).\n   *\n   * @param pos the attribute's position\n   */\n\n  void forceDeleteAttributeAt(int position) {\n\n    double[] newValues = new double[m_AttValues.length - 1];\n\n    System.arraycopy(m_AttValues, 0, newValues, 0, position);\n    if (position \u003c m_AttValues.length - 1) {\n      System.arraycopy(m_AttValues, position + 1, \n\t\t       newValues, position, \n\t\t       m_AttValues.length - (position + 1));\n    }\n    m_AttValues = newValues;\n  }\n\n  /**\n   * Inserts an attribute at the given position\n   * (0 to numAttributes()) and sets its value to be missing. \n   *\n   * @param pos the attribute's position\n   */\n  void forceInsertAttributeAt(int position)  {\n\n    double[] newValues = new double[m_AttValues.length + 1];\n\n    System.arraycopy(m_AttValues, 0, newValues, 0, position);\n    newValues[position] = MISSING_VALUE;\n    System.arraycopy(m_AttValues, position, newValues, \n\t\t     position + 1, m_AttValues.length - position);\n    m_AttValues = newValues;\n  }\n\n  /**\n   * Private constructor for subclasses. Does nothing.\n   */\n  protected Instance() {\n  }\n\n  /**\n   * Clones the attribute vector of the instance and\n   * overwrites it with the clone.\n   */\n  private void freshAttributeVector() {\n\n    m_AttValues = toDoubleArray();\n  }\n\n  /**\n   * Main method for testing this class.\n   */\n  //@ requires options != null;\n  public static void main(String[] options) {\n\n    try {\n\n      // Create numeric attributes \"length\" and \"weight\"\n      Attribute length = new Attribute(\"length\");\n      Attribute weight = new Attribute(\"weight\");\n      \n      // Create vector to hold nominal values \"first\", \"second\", \"third\" \n      FastVector my_nominal_values = new FastVector(3); \n      my_nominal_values.addElement(\"first\"); \n      my_nominal_values.addElement(\"second\"); \n      my_nominal_values.addElement(\"third\"); \n      \n      // Create nominal attribute \"position\" \n      Attribute position = new Attribute(\"position\", my_nominal_values);\n      \n      // Create vector of the above attributes \n      FastVector attributes = new FastVector(3);\n      attributes.addElement(length);\n      attributes.addElement(weight);\n      attributes.addElement(position);\n      \n      // Create the empty dataset \"race\" with above attributes\n      Instances race = new Instances(\"race\", attributes, 0);\n      \n      // Make position the class attribute\n      race.setClassIndex(position.index());\n      \n      // Create empty instance with three attribute values\n      Instance inst = new Instance(3);\n      \n      // Set instance's values for the attributes \"length\", \"weight\", and \"position\"\n      inst.setValue(length, 5.3);\n      inst.setValue(weight, 300);\n      inst.setValue(position, \"first\");\n      \n      // Set instance's dataset to be the dataset \"race\"\n      inst.setDataset(race);\n      \n      // Print the instance\n      System.out.println(\"The instance: \" + inst);\n      \n      // Print the first attribute\n      System.out.println(\"First attribute: \" + inst.attribute(0));\n      \n      // Print the class attribute\n      System.out.println(\"Class attribute: \" + inst.classAttribute());\n      \n      // Print the class index\n      System.out.println(\"Class index: \" + inst.classIndex());\n      \n      // Say if class is missing\n      System.out.println(\"Class is missing: \" + inst.classIsMissing());\n      \n      // Print the instance's class value in internal format\n      System.out.println(\"Class value (internal format): \" + inst.classValue());\n      \n      // Print a shallow copy of this instance\n      Instance copy = (Instance) inst.copy();\n      System.out.println(\"Shallow copy: \" + copy);\n      \n      // Set dataset for shallow copy\n      copy.setDataset(inst.dataset());\n      System.out.println(\"Shallow copy with dataset set: \" + copy);\n      \n      // Unset dataset for copy, delete first attribute, and insert it again\n      copy.setDataset(null);\n      copy.deleteAttributeAt(0);\n      copy.insertAttributeAt(0);\n      copy.setDataset(inst.dataset());\n      System.out.println(\"Copy with first attribute deleted and inserted: \" + copy); \n      \n      // Enumerate attributes (leaving out the class attribute)\n      System.out.println(\"Enumerating attributes (leaving out class):\");\n      Enumeration enu = inst.enumerateAttributes();\n      while (enu.hasMoreElements()) {\n\tAttribute att = (Attribute) enu.nextElement();\n\tSystem.out.println(att);\n      }\n      \n      // Headers are equivalent?\n      System.out.println(\"Header of original and copy equivalent: \" +\n\t\t\t inst.equalHeaders(copy));\n\n      // Test for missing values\n      System.out.println(\"Length of copy missing: \" + copy.isMissing(length));\n      System.out.println(\"Weight of copy missing: \" + copy.isMissing(weight.index()));\n      System.out.println(\"Length of copy missing: \" + \n\t\t\t Instance.isMissingValue(copy.value(length)));\n      System.out.println(\"Missing value coded as: \" + Instance.missingValue());\n\n      // Prints number of attributes and classes\n      System.out.println(\"Number of attributes: \" + copy.numAttributes());\n      System.out.println(\"Number of classes: \" + copy.numClasses());\n\n      // Replace missing values\n      double[] meansAndModes = {2, 3, 0};\n      copy.replaceMissingValues(meansAndModes);\n      System.out.println(\"Copy with missing value replaced: \" + copy);\n\n      // Setting and getting values and weights\n      copy.setClassMissing();\n      System.out.println(\"Copy with missing class: \" + copy);\n      copy.setClassValue(0);\n      System.out.println(\"Copy with class value set to first value: \" + copy);\n      copy.setClassValue(\"third\");\n      System.out.println(\"Copy with class value set to \\\"third\\\": \" + copy);\n      copy.setMissing(1);\n      System.out.println(\"Copy with second attribute set to be missing: \" + copy);\n      copy.setMissing(length);\n      System.out.println(\"Copy with length set to be missing: \" + copy);\n      copy.setValue(0, 0);\n      System.out.println(\"Copy with first attribute set to 0: \" + copy);\n      copy.setValue(weight, 1);\n      System.out.println(\"Copy with weight attribute set to 1: \" + copy);\n      copy.setValue(position, \"second\");\n      System.out.println(\"Copy with position set to \\\"second\\\": \" + copy);\n      copy.setValue(2, \"first\");\n      System.out.println(\"Copy with last attribute set to \\\"first\\\": \" + copy);\n      System.out.println(\"Current weight of instance copy: \" + copy.weight());\n      copy.setWeight(2);\n      System.out.println(\"Current weight of instance copy (set to 2): \" + copy.weight());\n      System.out.println(\"Last value of copy: \" + copy.toString(2));\n      System.out.println(\"Value of position for copy: \" + copy.toString(position));\n      System.out.println(\"Last value of copy (internal format): \" + copy.value(2));\n      System.out.println(\"Value of position for copy (internal format): \" + \n\t\t\t copy.value(position));\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n",
        "name": "Instance.java",
        "path": "subjectSystems/C,D/src/weka/core/Instance.java",
        "url": "/github.com/LASER-UMASS/Themis/-/blob/subjectSystems/C,D/src/weka/core/Instance.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 93,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Dataset == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 109,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Dataset == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 124,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires numAttributes \u003e 0;    // Or maybe == 0 is okay too?"
        },
        {
          "limitHit": false,
          "lineNumber": 125,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Dataset == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 144,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 162,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 178,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 193,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 210,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 229,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 263,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Dataset;"
        },
        {
          "limitHit": false,
          "lineNumber": 279,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 295,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 313,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 328,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 367,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 368,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= position \u0026\u0026 position \u003c= numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 466,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_AttValues.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 480,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 494,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_AttValues.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 532,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 553,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 576,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 669,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 765,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Dataset != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 991,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires options != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 194,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  \\result == m_Dataset.classIndex();"
        }
      ],
      "repository": {
        "name": "github.com/LASER-UMASS/Themis",
        "url": "/github.com/LASER-UMASS/Themis"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a70f12a6a8f34cdd8b170b4dc59a78674c9e8950"
        },
        "content": "/*\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; either version 2 of the License, or\n *    (at your option) any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n/*\n *    Instances.java\n *    Copyright (C) 1999 Eibe Frank\n *\n */\n\npackage weka.core;\n\nimport java.io.*;\nimport java.text.ParseException;\nimport java.util.*;\n\n\n/**\n * Class for handling an ordered set of weighted instances. \u003cp\u003e\n *\n * Typical usage (code from the main() method of this class): \u003cp\u003e\n *\n * \u003ccode\u003e\n * ... \u003cbr\u003e\n * \n * // Read all the instances in the file \u003cbr\u003e\n * reader = new FileReader(filename); \u003cbr\u003e\n * instances = new Instances(reader); \u003cbr\u003e\u003cbr\u003e\n *\n * // Make the last attribute be the class \u003cbr\u003e\n * instances.setClassIndex(instances.numAttributes() - 1); \u003cbr\u003e\u003cbr\u003e\n * \n * // Print header and instances. \u003cbr\u003e\n * System.out.println(\"\\nDataset:\\n\"); \u003cbr\u003e \n * System.out.println(instances); \u003cbr\u003e\u003cbr\u003e\n *\n * ... \u003cbr\u003e\n * \u003c/code\u003e\u003cp\u003e\n *\n * All methods that change a set of instances are safe, ie. a change\n * of a set of instances does not affect any other sets of\n * instances. All methods that change a datasets's attribute\n * information clone the dataset before it is changed.\n *\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\n * @author Len Trigg (trigg@cs.waikato.ac.nz)\n * @version $Revision: 1.58.2.6 $ \n */\npublic class Instances implements Serializable {\n \n  /** The filename extension that should be used for arff files */\n  public static String FILE_EXTENSION = \".arff\";\n\n  /** The filename extension that should be used for bin. serialized instances files */\n  public static String SERIALIZED_OBJ_FILE_EXTENSION = \".bsi\";\n\n  /** The keyword used to denote the start of an arff header */\n  static String ARFF_RELATION = \"@relation\";\n\n  /** The keyword used to denote the start of the arff data section */\n  static String ARFF_DATA = \"@data\";\n\n  /** The dataset's name. */\n  protected /*@spec_public non_null@*/ String m_RelationName;         \n\n  /** The attribute information. */\n  protected /*@spec_public non_null@*/ FastVector m_Attributes;\n  /*  public invariant (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c m_Attributes.size(); \n                    m_Attributes.elementAt(i) != null);\n  */\n\n  /** The instances. */\n  protected /*@spec_public non_null@*/ FastVector m_Instances;\n\n  /** The class attribute's index */\n  protected int m_ClassIndex;\n  //@ protected invariant classIndex() == m_ClassIndex;\n\n  /** Buffer of values for sparse instance */\n  protected double[] m_ValueBuffer;\n\n  /** Buffer of indices for sparse instance */\n  protected int[] m_IndicesBuffer;\n\n   \n  /**\n   * Reads an ARFF file from a reader, and assigns a weight of\n   * one to each instance. Lets the index of the class \n   * attribute be undefined (negative).\n   *\n   * @param reader the reader\n   * @exception IOException if the ARFF file is not read \n   * successfully\n   */\n  public Instances(/*@non_null@*/Reader reader) throws IOException {\n\n    StreamTokenizer tokenizer;\n\n    tokenizer = new StreamTokenizer(reader);\n    initTokenizer(tokenizer);\n    readHeader(tokenizer);\n    m_ClassIndex = -1;\n    m_Instances = new FastVector(1000);\n    while (getInstance(tokenizer, true)) {};\n    compactify();\n  }\n\n   \n \n  /**\n   * Reads the header of an ARFF file from a reader and \n   * reserves space for the given number of instances. Lets\n   * the class index be undefined (negative).\n   *\n   * @param reader the reader\n   * @param capacity the capacity\n   * @exception IllegalArgumentException if the header is not read successfully\n   * or the capacity is negative.\n   * @exception IOException if there is a problem with the reader.\n   */\n  //@ requires capacity \u003e= 0;\n  //@ ensures classIndex() == -1;\n  public Instances(/*@non_null@*/Reader reader, int capacity)\n    throws IOException {\n\n    StreamTokenizer tokenizer;\n\n    if (capacity \u003c 0) {\n      throw new IllegalArgumentException(\"Capacity has to be positive!\");\n    }\n    tokenizer = new StreamTokenizer(reader); \n    initTokenizer(tokenizer);\n    readHeader(tokenizer);\n    m_ClassIndex = -1;\n    m_Instances = new FastVector(capacity);\n  }\n\n  /**\n   * Constructor copying all instances and references to\n   * the header information from the given set of instances.\n   *\n   * @param instances the set to be copied\n   */\n  public Instances(/*@non_null@*/Instances dataset) {\n\n    this(dataset, dataset.numInstances());\n\n    dataset.copyInstances(0, this, dataset.numInstances());\n  }\n\n  /**\n   * Constructor creating an empty set of instances. Copies references\n   * to the header information from the given set of instances. Sets\n   * the capacity of the set of instances to 0 if its negative.\n   *\n   * @param instances the instances from which the header \n   * information is to be taken\n   * @param capacity the capacity of the new dataset \n   */\n  public Instances(/*@non_null@*/Instances dataset, int capacity) {\n    \n    if (capacity \u003c 0) {\n      capacity = 0;\n    }\n    \n    // Strings only have to be \"shallow\" copied because\n    // they can't be modified.\n    m_ClassIndex = dataset.m_ClassIndex;\n    m_RelationName = dataset.m_RelationName;\n    m_Attributes = dataset.m_Attributes;\n    m_Instances = new FastVector(capacity);\n  }\n\n  /**\n   * Creates a new set of instances by copying a \n   * subset of another set.\n   *\n   * @param source the set of instances from which a subset \n   * is to be created\n   * @param first the index of the first instance to be copied\n   * @param toCopy the number of instances to be copied\n   * @exception IllegalArgumentException if first and toCopy are out of range\n   */\n  //@ requires 0 \u003c= first;\n  //@ requires 0 \u003c= toCopy;\n  //@ requires first + toCopy \u003c= source.numInstances();\n  public Instances(/*@non_null@*/Instances source, int first, int toCopy) {\n    \n    this(source, toCopy);\n\n    if ((first \u003c 0) || ((first + toCopy) \u003e source.numInstances())) {\n      throw new IllegalArgumentException(\"Parameters first and/or toCopy out \"+\n                                         \"of range\");\n    }\n    source.copyInstances(first, this, toCopy);\n  }\n\n  /**\n   * Creates an empty set of instances. Uses the given\n   * attribute information. Sets the capacity of the set of \n   * instances to 0 if its negative. Given attribute information\n   * must not be changed after this constructor has been used.\n   *\n   * @param name the name of the relation\n   * @param attInfo the attribute information\n   * @param capacity the capacity of the set\n   */\n  public Instances(/*@non_null@*/String name, \n\t\t   /*@non_null@*/FastVector attInfo, int capacity) {\n\n    m_RelationName = name;\n    m_ClassIndex = -1;\n    m_Attributes = attInfo;\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      attribute(i).setIndex(i);\n    }\n    m_Instances = new FastVector(capacity);\n  }\n \n  /**\n   * Create a copy of the structure, but \"cleanse\" string types (i.e.\n   * doesn't contain references to the strings seen in the past).\n   *\n   * @return a copy of the instance structure.\n   */\n  public Instances stringFreeStructure() {\n\n    FastVector atts = (FastVector)m_Attributes.copy();\n    for (int i = 0 ; i \u003c atts.size(); i++) {\n      Attribute att = (Attribute)atts.elementAt(i);\n      if (att.type() == Attribute.STRING) {\n        atts.setElementAt(new Attribute(att.name(), (FastVector)null), i);\n      }\n    }\n    Instances result = new Instances(relationName(), atts, 0);\n    result.m_ClassIndex = m_ClassIndex;\n    return result;\n  }\n\n  /**\n   * Adds one instance to the end of the set. \n   * Shallow copies instance before it is added. Increases the\n   * size of the dataset if it is not large enough. Does not\n   * check if the instance is compatible with the dataset.\n   * Note: String values are not transferred.\n   *\n   * @param instance the instance to be added\n   */\n  public void add(/*@non_null@*/ Instance instance) {\n\n    Instance newInstance = (Instance)instance.copy();\n\n    newInstance.setDataset(this);\n    m_Instances.addElement(newInstance);\n  }\n\n  /**\n   * Returns an attribute.\n   *\n   * @param index the attribute's index\n   * @return the attribute at the given position\n   */\n  //@ requires 0 \u003c= index;\n  //@ requires index \u003c m_Attributes.size();\n  //@ ensures \\result != null;\n  public /*@pure@*/ Attribute attribute(int index) {\n    \n    return (Attribute) m_Attributes.elementAt(index);\n  }\n\n  /**\n   * Returns an attribute given its name. If there is more than\n   * one attribute with the same name, it returns the first one.\n   * Returns null if the attribute can't be found.\n   *\n   * @param name the attribute's name\n   * @return the attribute with the given name, null if the\n   * attribute can't be found\n   */ \n  public /*@pure@*/ Attribute attribute(String name) {\n    \n    for (int i = 0; i \u003c numAttributes(); i++) {\n      if (attribute(i).name().equals(name)) {\n\treturn attribute(i);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Checks for string attributes in the dataset\n   *\n   * @return true if string attributes are present, false otherwise\n   */\n  public /*@pure@*/ boolean checkForStringAttributes() {\n\n    int i = 0;\n   \n    while (i \u003c m_Attributes.size()) {\n      if (attribute(i++).isString()) {\n\treturn true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Checks if the given instance is compatible\n   * with this dataset. Only looks at the size of\n   * the instance and the ranges of the values for \n   * nominal and string attributes.\n   *\n   * @return true if the instance is compatible with the dataset \n   */\n  public /*@pure@*/ boolean checkInstance(Instance instance) {\n\n    if (instance.numAttributes() != numAttributes()) {\n      return false;\n    }\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      if (instance.isMissing(i)) {\n\tcontinue;\n      } else if (attribute(i).isNominal() ||\n\t\t attribute(i).isString()) {\n\tif (!(Utils.eq(instance.value(i),\n\t\t       (double)(int)instance.value(i)))) {\n\t  return false;\n\t} else if (Utils.sm(instance.value(i), 0) ||\n\t\t   Utils.gr(instance.value(i),\n\t\t\t    attribute(i).numValues())) {\n\t  return false;\n\t}\n      }\n    }\n    return true;\n  }\n\t\n  /**\n   * Returns the class attribute.\n   *\n   * @return the class attribute\n   * @exception UnassignedClassException if the class is not set\n   */\n  //@ requires classIndex() \u003e= 0;\n  public /*@pure@*/ Attribute classAttribute() {\n\n    if (m_ClassIndex \u003c 0) {\n      throw new UnassignedClassException(\"Class index is negative (not set)!\");\n    }\n    return attribute(m_ClassIndex);\n  }\n\n  /**\n   * Returns the class attribute's index. Returns negative number\n   * if it's undefined.\n   *\n   * @return the class index as an integer\n   */\n  // ensures \\result == m_ClassIndex;\n  public /*@pure@*/ int classIndex() {\n    \n    return m_ClassIndex;\n  }\n \n  /**\n   * Compactifies the set of instances. Decreases the capacity of\n   * the set so that it matches the number of instances in the set.\n   */\n  public void compactify() {\n\n    m_Instances.trimToSize();\n  }\n\n  /**\n   * Removes all instances from the set.\n   */\n  public void delete() {\n    \n    m_Instances = new FastVector();\n  }\n\n  /**\n   * Removes an instance at the given position from the set.\n   *\n   * @param index the instance's position\n   */\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numInstances();\n  public void delete(int index) {\n    \n    m_Instances.removeElementAt(index);\n  }\n\n  /**\n   * Deletes an attribute at the given position \n   * (0 to numAttributes() - 1). A deep copy of the attribute\n   * information is performed before the attribute is deleted.\n   *\n   * @param pos the attribute's position\n   * @exception IllegalArgumentException if the given index is out of range \n   *            or the class attribute is being deleted\n   */\n  //@ requires 0 \u003c= position \u0026\u0026 position \u003c numAttributes();\n  //@ requires position != classIndex();\n  public void deleteAttributeAt(int position) {\n\t \n    if ((position \u003c 0) || (position \u003e= m_Attributes.size())) {\n      throw new IllegalArgumentException(\"Index out of range\");\n    }\n    if (position == m_ClassIndex) {\n      throw new IllegalArgumentException(\"Can't delete class attribute\");\n    }\n    freshAttributeInfo();\n    if (m_ClassIndex \u003e position) {\n      m_ClassIndex--;\n    }\n    m_Attributes.removeElementAt(position);\n    for (int i = position; i \u003c m_Attributes.size(); i++) {\n      Attribute current = (Attribute)m_Attributes.elementAt(i);\n      current.setIndex(current.index() - 1);\n    }\n    for (int i = 0; i \u003c numInstances(); i++) {\n      instance(i).forceDeleteAttributeAt(position); \n    }\n  }\n\n  /**\n   * Deletes all string attributes in the dataset. A deep copy of the attribute\n   * information is performed before an attribute is deleted.\n   *\n   * @exception IllegalArgumentException if string attribute couldn't be \n   * successfully deleted (probably because it is the class attribute).\n   */\n  public void deleteStringAttributes() {\n\n    int i = 0;\n    while (i \u003c m_Attributes.size()) {\n      if (attribute(i).isString()) {\n\tdeleteAttributeAt(i);\n      } else {\n\ti++;\n      }\n    }\n  }\n\n  /**\n   * Removes all instances with missing values for a particular\n   * attribute from the dataset.\n   *\n   * @param attIndex the attribute's index\n   */\n  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\n  public void deleteWithMissing(int attIndex) {\n\n    FastVector newInstances = new FastVector(numInstances());\n\n    for (int i = 0; i \u003c numInstances(); i++) {\n      if (!instance(i).isMissing(attIndex)) {\n\tnewInstances.addElement(instance(i));\n      }\n    }\n    m_Instances = newInstances;\n  }\n\n  /**\n   * Removes all instances with missing values for a particular\n   * attribute from the dataset.\n   *\n   * @param att the attribute\n   */\n  public void deleteWithMissing(/*@non_null@*/ Attribute att) {\n\n    deleteWithMissing(att.index());\n  }\n\n  /**\n   * Removes all instances with a missing class value\n   * from the dataset.\n   *\n   * @exception UnassignedClassException if class is not set\n   */\n  public void deleteWithMissingClass() {\n\n    if (m_ClassIndex \u003c 0) {\n      throw new UnassignedClassException(\"Class index is negative (not set)!\");\n    }\n    deleteWithMissing(m_ClassIndex);\n  }\n\n  /**\n   * Returns an enumeration of all the attributes.\n   *\n   * @return enumeration of all the attributes.\n   */\n  public /*@non_null pure@*/ Enumeration enumerateAttributes() {\n\n    return m_Attributes.elements(m_ClassIndex);\n  }\n\n  /**\n   * Returns an enumeration of all instances in the dataset.\n   *\n   * @return enumeration of all instances in the dataset\n   */\n  public /*@non_null pure@*/ Enumeration enumerateInstances() {\n\n    return m_Instances.elements();\n  }\n\n  /**\n   * Checks if two headers are equivalent.\n   *\n   * @param dataset another dataset\n   * @return true if the header of the given dataset is equivalent \n   * to this header\n   */\n  public /*@pure@*/ boolean equalHeaders(Instances dataset){\n\n    // Check class and all attributes\n    if (m_ClassIndex != dataset.m_ClassIndex) {\n      return false;\n    }\n    if (m_Attributes.size() != dataset.m_Attributes.size()) {\n      return false;\n    }\n    for (int i = 0; i \u003c m_Attributes.size(); i++) {\n      if (!(attribute(i).equals(dataset.attribute(i)))) {\n\treturn false;\n      }\n    }\n    return true;\n  }\n \n  /**\n   * Returns the first instance in the set.\n   *\n   * @return the first instance in the set\n   */\n  //@ requires numInstances() \u003e 0;\n  public /*@non_null pure@*/ Instance firstInstance() {\n    \n    return (Instance)m_Instances.firstElement();\n  }\n\n  /**\n   * Returns a random number generator. The initial seed of the random\n   * number generator depends on the given seed and the hash code of\n   * a string representation of a instances chosen based on the given\n   * seed. \n   *\n   * @param seed the given seed\n   * @return the random number generator\n   */\n  public Random getRandomNumberGenerator(long seed) {\n\n    Random r = new Random(seed);\n    r.setSeed(instance(r.nextInt(numInstances())).toString().hashCode() + seed);\n    return r;\n  }\n \n  /**\n   * Inserts an attribute at the given position (0 to \n   * numAttributes()) and sets all values to be missing.\n   * Shallow copies the attribute before it is inserted, and performs\n   * a deep copy of the existing attribute information.\n   *\n   * @param att the attribute to be inserted\n   * @param pos the attribute's position\n   * @exception IllegalArgumentException if the given index is out of range\n   */\n  //@ requires 0 \u003c= position;\n  //@ requires position \u003c= numAttributes();\n  public void insertAttributeAt(/*@non_null@*/ Attribute att, int position) {\n\t \n    if ((position \u003c 0) ||\n\t(position \u003e m_Attributes.size())) {\n      throw new IllegalArgumentException(\"Index out of range\");\n    }\n    att = (Attribute)att.copy();\n    freshAttributeInfo();\n    att.setIndex(position);\n    m_Attributes.insertElementAt(att, position);\n    for (int i = position + 1; i \u003c m_Attributes.size(); i++) {\n      Attribute current = (Attribute)m_Attributes.elementAt(i);\n      current.setIndex(current.index() + 1);\n    }\n    for (int i = 0; i \u003c numInstances(); i++) {\n      instance(i).forceInsertAttributeAt(position);\n    }\n    if (m_ClassIndex \u003e= position) {\n      m_ClassIndex++;\n    }\n  }\n\n  /**\n   * Returns the instance at the given position.\n   *\n   * @param index the instance's index\n   * @return the instance at the given position\n   */\n  //@ requires 0 \u003c= index;\n  //@ requires index \u003c numInstances();\n  public /*@non_null pure@*/ Instance instance(int index) {\n\n    return (Instance)m_Instances.elementAt(index);\n  }\n\n  /**\n   * Returns the kth-smallest attribute value of a numeric attribute.\n   * Note that calling this method will change the order of the data!\n   *\n   * @param att the Attribute object\n   * @param k the value of k\n   * @return the kth-smallest value\n   */\n  public double kthSmallestValue(Attribute att, int k) {\n\n    return kthSmallestValue(att.index(), k);\n  }\n\n  /**\n   * Returns the kth-smallest attribute value of a numeric attribute.\n   * Note that calling this method will change the order of the data!\n   * The number of non-missing values in the data must be as least\n   * as last as k for this to work.\n   *\n   * @param attIndex the attribute's index\n   * @param k the value of k\n   * @return the kth-smallest value\n   */\n  public double kthSmallestValue(int attIndex, int k) {\n    \n    if (!attribute(attIndex).isNumeric()) {\n      throw new IllegalArgumentException(\"Instances: attribute must be numeric to compute kth-smallest value.\");\n    }\n\n    int i,j;\n\n    // move all instances with missing values to end\n    j = numInstances() - 1;\n    i = 0;\n    while (i \u003c= j) {\n      if (instance(j).isMissing(attIndex)) {\n\tj--;\n      } else {\n\tif (instance(i).isMissing(attIndex)) {\n\t  swap(i,j);\n\t  j--;\n\t}\n\ti++;\n      }\n    }\n\n    if ((k \u003c 1) || (k \u003e j+1)) {\n      throw new IllegalArgumentException(\"Instances: value for k for computing kth-smallest value too large.\");\n    }\n\n    return instance(select(attIndex, 0, j, k)).value(attIndex);\n  }\n\n  /**\n   * Returns the last instance in the set.\n   *\n   * @return the last instance in the set\n   */\n  //@ requires numInstances() \u003e 0;\n  public /*@non_null pure@*/ Instance lastInstance() {\n    \n    return (Instance)m_Instances.lastElement();\n  }\n\n  /**\n   * Returns the mean (mode) for a numeric (nominal) attribute as\n   * a floating-point value. Returns 0 if the attribute is neither nominal nor \n   * numeric. If all values are missing it returns zero.\n   *\n   * @param attIndex the attribute's index\n   * @return the mean or the mode\n   */\n  public /*@pure@*/ double meanOrMode(int attIndex) {\n\n    double result, found;\n    int [] counts;\n\n    if (attribute(attIndex).isNumeric()) {\n      result = found = 0;\n      for (int j = 0; j \u003c numInstances(); j++) {\n\tif (!instance(j).isMissing(attIndex)) {\n\t  found += instance(j).weight();\n\t  result += instance(j).weight()*instance(j).value(attIndex);\n\t}\n      }\n      if (found \u003c= 0) {\n\treturn 0;\n      } else {\n\treturn result / found;\n      }\n    } else if (attribute(attIndex).isNominal()) {\n      counts = new int[attribute(attIndex).numValues()];\n      for (int j = 0; j \u003c numInstances(); j++) {\n\tif (!instance(j).isMissing(attIndex)) {\n\t  counts[(int) instance(j).value(attIndex)] += instance(j).weight();\n\t}\n      }\n      return (double)Utils.maxIndex(counts);\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n   * Returns the mean (mode) for a numeric (nominal) attribute as a\n   * floating-point value.  Returns 0 if the attribute is neither\n   * nominal nor numeric.  If all values are missing it returns zero.\n   *\n   * @param att the attribute\n   * @return the mean or the mode \n   */\n  public /*@pure@*/ double meanOrMode(Attribute att) {\n\n    return meanOrMode(att.index());\n  }\n\n  /**\n   * Returns the number of attributes.\n   *\n   * @return the number of attributes as an integer\n   */\n  //@ ensures \\result == m_Attributes.size();\n  public /*@pure@*/ int numAttributes() {\n\n    return m_Attributes.size();\n  }\n\n  /**\n   * Returns the number of class labels.\n   *\n   * @return the number of class labels as an integer if the class \n   * attribute is nominal, 1 otherwise.\n   * @exception UnassignedClassException if the class is not set\n   */\n  //@ requires classIndex() \u003e= 0;\n  public /*@pure@*/ int numClasses() {\n    \n    if (m_ClassIndex \u003c 0) {\n      throw new UnassignedClassException(\"Class index is negative (not set)!\");\n    }\n    if (!classAttribute().isNominal()) {\n      return 1;\n    } else {\n      return classAttribute().numValues();\n    }\n  }\n\n  /**\n   * Returns the number of distinct values of a given attribute.\n   * Returns the number of instances if the attribute is a\n   * string attribute. The value 'missing' is not counted.\n   *\n   * @param attIndex the attribute\n   * @return the number of distinct values of a given attribute\n   */\n  //@ requires 0 \u003c= attIndex;\n  //@ requires attIndex \u003c numAttributes();\n  public /*@pure@*/ int numDistinctValues(int attIndex) {\n\n    if (attribute(attIndex).isNumeric()) {\n      double [] attVals = attributeToDoubleArray(attIndex);\n      int [] sorted = Utils.sort(attVals);\n      double prev = 0;\n      int counter = 0;\n      for (int i = 0; i \u003c sorted.length; i++) {\n\tInstance current = instance(sorted[i]);\n\tif (current.isMissing(attIndex)) {\n\t  break;\n\t}\n\tif ((i == 0) || \n\t    (current.value(attIndex) \u003e prev)) {\n\t  prev = current.value(attIndex);\n\t  counter++;\n\t}\n      }\n      return counter;\n    } else {\n      return attribute(attIndex).numValues();\n    }\n  }\n\n  /**\n   * Returns the number of distinct values of a given attribute.\n   * Returns the number of instances if the attribute is a\n   * string attribute. The value 'missing' is not counted.\n   *\n   * @param att the attribute\n   * @return the number of distinct values of a given attribute\n   */\n  public /*@pure@*/ int numDistinctValues(/*@non_null@*/Attribute att) {\n\n    return numDistinctValues(att.index());\n  }\n  \n  /**\n   * Returns the number of instances in the dataset.\n   *\n   * @return the number of instances in the dataset as an integer\n   */\n  //@ ensures \\result == m_Instances.size();\n  public /*@pure@*/ int numInstances() {\n\n    return m_Instances.size();\n  }\n\n  /**\n   * Shuffles the instances in the set so that they are ordered \n   * randomly.\n   *\n   * @param random a random number generator\n   */\n  public void randomize(Random random) {\n\n    for (int j = numInstances() - 1; j \u003e 0; j--)\n      swap(j, random.nextInt(j+1));\n  }\n\n  /**\n   * Reads a single instance from the reader and appends it\n   * to the dataset.  Automatically expands the dataset if it\n   * is not large enough to hold the instance. This method does\n   * not check for carriage return at the end of the line.\n   *\n   * @param reader the reader \n   * @return false if end of file has been reached\n   * @exception IOException if the information is not read \n   * successfully\n   */ \n  public boolean readInstance(Reader reader) \n       throws IOException {\n\n    StreamTokenizer tokenizer = new StreamTokenizer(reader);\n    \n    initTokenizer(tokenizer);\n    return getInstance(tokenizer, false);\n  }    \n\n  /**\n   * Returns the relation's name.\n   *\n   * @return the relation's name as a string\n   */\n  //@ ensures \\result == m_RelationName;\n  public /*@pure@*/ String relationName() {\n\n    return m_RelationName;\n  }\n\n  /**\n   * Renames an attribute. This change only affects this\n   * dataset.\n   *\n   * @param att the attribute's index\n   * @param name the new name\n   */\n  public void renameAttribute(int att, String name) {\n\n    Attribute newAtt = attribute(att).copy(name);\n    FastVector newVec = new FastVector(numAttributes());\n\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      if (i == att) {\n\tnewVec.addElement(newAtt);\n      } else {\n\tnewVec.addElement(attribute(i));\n      }\n    }\n    m_Attributes = newVec;\n  }\n\n  /**\n   * Renames an attribute. This change only affects this\n   * dataset.\n   *\n   * @param att the attribute\n   * @param name the new name\n   */\n  public void renameAttribute(Attribute att, String name) {\n\n    renameAttribute(att.index(), name);\n  }\n\n  /**\n   * Renames the value of a nominal (or string) attribute value. This\n   * change only affects this dataset.\n   *\n   * @param att the attribute's index\n   * @param val the value's index\n   * @param name the new name \n   */\n  public void renameAttributeValue(int att, int val, String name) {\n\n    Attribute newAtt = (Attribute)attribute(att).copy();\n    FastVector newVec = new FastVector(numAttributes());\n\n    newAtt.setValue(val, name);\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      if (i == att) {\n\tnewVec.addElement(newAtt);\n      } else {\n\tnewVec.addElement(attribute(i));\n      }\n    }\n    m_Attributes = newVec;\n  }\n\n  /**\n   * Renames the value of a nominal (or string) attribute value. This\n   * change only affects this dataset.\n   *\n   * @param att the attribute\n   * @param val the value\n   * @param name the new name\n   */\n  public void renameAttributeValue(Attribute att, String val, \n                                         String name) {\n\n    int v = att.indexOfValue(val);\n    if (v == -1) throw new IllegalArgumentException(val + \" not found\");\n    renameAttributeValue(att.index(), v, name);\n  }\n\n  /**\n   * Creates a new dataset of the same size using random sampling\n   * with replacement.\n   *\n   * @param random a random number generator\n   * @return the new dataset\n   */\n  public Instances resample(Random random) {\n\n    Instances newData = new Instances(this, numInstances());\n    while (newData.numInstances() \u003c numInstances()) {\n      newData.add(instance(random.nextInt(numInstances())));\n    }\n    return newData;\n  }\n\n  /**\n   * Creates a new dataset of the same size using random sampling\n   * with replacement according to the current instance weights. The\n   * weights of the instances in the new dataset are set to one.\n   *\n   * @param random a random number generator\n   * @return the new dataset\n   */\n  public Instances resampleWithWeights(Random random) {\n\n    double [] weights = new double[numInstances()];\n    for (int i = 0; i \u003c weights.length; i++) {\n      weights[i] = instance(i).weight();\n    }\n    return resampleWithWeights(random, weights);\n  }\n\n\n  /**\n   * Creates a new dataset of the same size using random sampling\n   * with replacement according to the given weight vector. The\n   * weights of the instances in the new dataset are set to one.\n   * The length of the weight vector has to be the same as the\n   * number of instances in the dataset, and all weights have to\n   * be positive.\n   *\n   * @param random a random number generator\n   * @param weights the weight vector\n   * @return the new dataset\n   * @exception IllegalArgumentException if the weights array is of the wrong\n   * length or contains negative weights.\n   */\n  public Instances resampleWithWeights(Random random, \n\t\t\t\t\t     double[] weights) {\n\n    if (weights.length != numInstances()) {\n      throw new IllegalArgumentException(\"weights.length != numInstances.\");\n    }\n    Instances newData = new Instances(this, numInstances());\n    if (numInstances() == 0) {\n      return newData;\n    }\n    double[] probabilities = new double[numInstances()];\n    double sumProbs = 0, sumOfWeights = Utils.sum(weights);\n    for (int i = 0; i \u003c numInstances(); i++) {\n      sumProbs += random.nextDouble();\n      probabilities[i] = sumProbs;\n    }\n    Utils.normalize(probabilities, sumProbs / sumOfWeights);\n\n    // Make sure that rounding errors don't mess things up\n    probabilities[numInstances() - 1] = sumOfWeights;\n    int k = 0; int l = 0;\n    sumProbs = 0;\n    while ((k \u003c numInstances() \u0026\u0026 (l \u003c numInstances()))) {\n      if (weights[l] \u003c 0) {\n\tthrow new IllegalArgumentException(\"Weights have to be positive.\");\n      }\n      sumProbs += weights[l];\n      while ((k \u003c numInstances()) \u0026\u0026\n\t     (probabilities[k] \u003c= sumProbs)) { \n\tnewData.add(instance(l));\n\tnewData.instance(k).setWeight(1);\n\tk++;\n      }\n      l++;\n    }\n    return newData;\n  }\n\n  /** \n   * Sets the class attribute.\n   *\n   * @param att attribute to be the class\n   */\n  public void setClass(Attribute att) {\n\n    m_ClassIndex = att.index();\n  }\n\n  /** \n   * Sets the class index of the set.\n   * If the class index is negative there is assumed to be no class.\n   * (ie. it is undefined)\n   *\n   * @param classIndex the new class index\n   * @exception IllegalArgumentException if the class index is too big or \u003c 0\n   */\n  public void setClassIndex(int classIndex) {\n\n    if (classIndex \u003e= numAttributes()) {\n      throw new IllegalArgumentException(\"Invalid class index: \" + classIndex);\n    }\n    m_ClassIndex = classIndex;\n  }\n\n  /**\n   * Sets the relation's name.\n   *\n   * @param newName the new relation name.\n   */\n  public void setRelationName(/*@non_null@*/String newName) {\n    \n    m_RelationName = newName;\n  }\n\n  /**\n   * Sorts the instances based on an attribute. For numeric attributes, \n   * instances are sorted in ascending order. For nominal attributes, \n   * instances are sorted based on the attribute label ordering \n   * specified in the header. Instances with missing values for the \n   * attribute are placed at the end of the dataset.\n   *\n   * @param attIndex the attribute's index\n   */\n  public void sort(int attIndex) {\n\n    int i,j;\n\n    // move all instances with missing values to end\n    j = numInstances() - 1;\n    i = 0;\n    while (i \u003c= j) {\n      if (instance(j).isMissing(attIndex)) {\n\tj--;\n      } else {\n\tif (instance(i).isMissing(attIndex)) {\n\t  swap(i,j);\n\t  j--;\n\t}\n\ti++;\n      }\n    }\n    quickSort(attIndex, 0, j);\n  }\n\n  /**\n   * Sorts the instances based on an attribute. For numeric attributes, \n   * instances are sorted into ascending order. For nominal attributes, \n   * instances are sorted based on the attribute label ordering \n   * specified in the header. Instances with missing values for the \n   * attribute are placed at the end of the dataset.\n   *\n   * @param att the attribute\n   */\n  public void sort(Attribute att) {\n\n    sort(att.index());\n  }\n\n  /**\n   * Stratifies a set of instances according to its class values \n   * if the class attribute is nominal (so that afterwards a \n   * stratified cross-validation can be performed).\n   *\n   * @param numFolds the number of folds in the cross-validation\n   * @exception UnassignedClassException if the class is not set\n   */\n  public void stratify(int numFolds) {\n    \n    if (numFolds \u003c= 0) {\n      throw new IllegalArgumentException(\"Number of folds must be greater than 1\");\n    }\n    if (m_ClassIndex \u003c 0) {\n      throw new UnassignedClassException(\"Class index is negative (not set)!\");\n    }\n    if (classAttribute().isNominal()) {\n\n      // sort by class\n      int index = 1;\n      while (index \u003c numInstances()) {\n\tInstance instance1 = instance(index - 1);\n\tfor (int j = index; j \u003c numInstances(); j++) {\n\t  Instance instance2 = instance(j);\n\t  if ((instance1.classValue() == instance2.classValue()) ||\n\t      (instance1.classIsMissing() \u0026\u0026 \n\t       instance2.classIsMissing())) {\n\t    swap(index,j);\n\t    index++;\n\t  }\n\t}\n\tindex++;\n      }\n      stratStep(numFolds);\n    }\n  }\n \n  /**\n   * Computes the sum of all the instances' weights.\n   *\n   * @return the sum of all the instances' weights as a double\n   */\n  public /*@pure@*/ double sumOfWeights() {\n    \n    double sum = 0;\n\n    for (int i = 0; i \u003c numInstances(); i++) {\n      sum += instance(i).weight();\n    }\n    return sum;\n  }\n\n  /**\n   * Creates the test set for one fold of a cross-validation on \n   * the dataset.\n   *\n   * @param numFolds the number of folds in the cross-validation. Must\n   * be greater than 1.\n   * @param numFold 0 for the first fold, 1 for the second, ...\n   * @return the test set as a set of weighted instances\n   * @exception IllegalArgumentException if the number of folds is less than 2\n   * or greater than the number of instances.\n   */\n  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\n  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\n  public Instances testCV(int numFolds, int numFold) {\n\n    int numInstForFold, first, offset;\n    Instances test;\n    \n    if (numFolds \u003c 2) {\n      throw new IllegalArgumentException(\"Number of folds must be at least 2!\");\n    }\n    if (numFolds \u003e numInstances()) {\n      throw new IllegalArgumentException(\"Can't have more folds than instances!\");\n    }\n    numInstForFold = numInstances() / numFolds;\n    if (numFold \u003c numInstances() % numFolds){\n      numInstForFold++;\n      offset = numFold;\n    }else\n      offset = numInstances() % numFolds;\n    test = new Instances(this, numInstForFold);\n    first = numFold * (numInstances() / numFolds) + offset;\n    copyInstances(first, test, numInstForFold);\n    return test;\n  }\n \n  /**\n   * Returns the dataset as a string in ARFF format. Strings\n   * are quoted if they contain whitespace characters, or if they\n   * are a question mark.\n   *\n   * @return the dataset in ARFF format as a string\n   */\n  public String toString() {\n    \n    StringBuffer text = new StringBuffer();\n    \n    text.append(ARFF_RELATION).append(\" \").\n      append(Utils.quote(m_RelationName)).append(\"\\n\\n\");\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      text.append(attribute(i)).append(\"\\n\");\n    }\n    text.append(\"\\n\").append(ARFF_DATA).append(\"\\n\");\n    for (int i = 0; i \u003c numInstances(); i++) {\n      text.append(instance(i));\n      if (i \u003c numInstances() - 1) {\n\ttext.append('\\n');\n      }\n    }\n    return text.toString();\n  }\n\n  /**\n   * Creates the training set for one fold of a cross-validation \n   * on the dataset. \n   *\n   * @param numFolds the number of folds in the cross-validation. Must\n   * be greater than 1.\n   * @param numFold 0 for the first fold, 1 for the second, ...\n   * @return the training set \n   * @exception IllegalArgumentException if the number of folds is less than 2\n   * or greater than the number of instances.\n   */\n  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\n  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\n  public Instances trainCV(int numFolds, int numFold) {\n\n    int numInstForFold, first, offset;\n    Instances train;\n \n    if (numFolds \u003c 2) {\n      throw new IllegalArgumentException(\"Number of folds must be at least 2!\");\n    }\n    if (numFolds \u003e numInstances()) {\n      throw new IllegalArgumentException(\"Can't have more folds than instances!\");\n    }\n    numInstForFold = numInstances() / numFolds;\n    if (numFold \u003c numInstances() % numFolds) {\n      numInstForFold++;\n      offset = numFold;\n    }else\n      offset = numInstances() % numFolds;\n    train = new Instances(this, numInstances() - numInstForFold);\n    first = numFold * (numInstances() / numFolds) + offset;\n    copyInstances(0, train, first);\n    copyInstances(first + numInstForFold, train,\n\t\t  numInstances() - first - numInstForFold);\n\n    return train;\n  }\n\n  /**\n   * Creates the training set for one fold of a cross-validation \n   * on the dataset. The data is subsequently randomized based\n   * on the given random number generator.\n   *\n   * @param numFolds the number of folds in the cross-validation. Must\n   * be greater than 1.\n   * @param numFold 0 for the first fold, 1 for the second, ...\n   * @param random the random number generator\n   * @return the training set \n   * @exception IllegalArgumentException if the number of folds is less than 2\n   * or greater than the number of instances.\n   */\n  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\n  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\n  public Instances trainCV(int numFolds, int numFold, Random random) {\n\n    Instances train = trainCV(numFolds, numFold);\n    train.randomize(random);\n    return train;\n  }\n\n  /**\n   * Computes the variance for a numeric attribute.\n   *\n   * @param attIndex the numeric attribute\n   * @return the variance if the attribute is numeric\n   * @exception IllegalArgumentException if the attribute is not numeric\n   */\n  public /*@pure@*/ double variance(int attIndex) {\n  \n    double sum = 0, sumSquared = 0, sumOfWeights = 0;\n\n    if (!attribute(attIndex).isNumeric()) {\n      throw new IllegalArgumentException(\"Can't compute variance because attribute is \" +\n\t\t\t  \"not numeric!\");\n    }\n    for (int i = 0; i \u003c numInstances(); i++) {\n      if (!instance(i).isMissing(attIndex)) {\n\tsum += instance(i).weight() * \n\t  instance(i).value(attIndex);\n\tsumSquared += instance(i).weight() * \n\t  instance(i).value(attIndex) *\n\t  instance(i).value(attIndex);\n\tsumOfWeights += instance(i).weight();\n      }\n    }\n    if (sumOfWeights \u003c= 1) {\n      return 0;\n    }\n    double result = (sumSquared - (sum * sum / sumOfWeights)) / \n      (sumOfWeights - 1);\n\n    // We don't like negative variance\n    if (result \u003c 0) {\n      return 0;\n    } else {\n      return result;\n    }\n  }\n\n  /**\n   * Computes the variance for a numeric attribute.\n   *\n   * @param att the numeric attribute\n   * @return the variance if the attribute is numeric\n   * @exception IllegalArgumentException if the attribute is not numeric\n   */\n  public /*@pure@*/ double variance(Attribute att) {\n    \n    return variance(att.index());\n  }\n  \n  /**\n   * Calculates summary statistics on the values that appear in this\n   * set of instances for a specified attribute.\n   *\n   * @param index the index of the attribute to summarize.\n   * @return an AttributeStats object with it's fields calculated.\n   */\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numAttributes();\n  public AttributeStats attributeStats(int index) {\n\n    AttributeStats result = new AttributeStats();\n    if (attribute(index).isNominal()) {\n      result.nominalCounts = new int [attribute(index).numValues()];\n    }\n    if (attribute(index).isNumeric()) {\n      result.numericStats = new weka.experiment.Stats();\n    }\n    result.totalCount = numInstances();\n\n    double [] attVals = attributeToDoubleArray(index);\n    int [] sorted = Utils.sort(attVals);\n    int currentCount = 0;\n    double prev = Instance.missingValue();\n    for (int j = 0; j \u003c numInstances(); j++) {\n      Instance current = instance(sorted[j]);\n      if (current.isMissing(index)) {\n\tresult.missingCount = numInstances() - j;\n\tbreak;\n      }\n      if (current.value(index) == prev) {\n\tcurrentCount++;\n      } else {\n\tresult.addDistinct(prev, currentCount);\n\tcurrentCount = 1;\n\tprev = current.value(index);\n      }\n    }\n    result.addDistinct(prev, currentCount);\n    result.distinctCount--; // So we don't count \"missing\" as a value \n    return result;\n  }\n  \n  /**\n   * Gets the value of all instances in this dataset for a particular\n   * attribute. Useful in conjunction with Utils.sort to allow iterating\n   * through the dataset in sorted order for some attribute.\n   *\n   * @param index the index of the attribute.\n   * @return an array containing the value of the desired attribute for\n   * each instance in the dataset. \n   */\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numAttributes();\n  public /*@pure@*/ double [] attributeToDoubleArray(int index) {\n\n    double [] result = new double[numInstances()];\n    for (int i = 0; i \u003c result.length; i++) {\n      result[i] = instance(i).value(index);\n    }\n    return result;\n  }\n\n  /**\n   * Generates a string summarizing the set of instances. Gives a breakdown\n   * for each attribute indicating the number of missing/discrete/unique\n   * values and other information.\n   *\n   * @return a string summarizing the dataset\n   */\n  public String toSummaryString() {\n\n    StringBuffer result = new StringBuffer();\n    result.append(\"Relation Name:  \").append(relationName()).append('\\n');\n    result.append(\"Num Instances:  \").append(numInstances()).append('\\n');\n    result.append(\"Num Attributes: \").append(numAttributes()).append('\\n');\n    result.append('\\n');\n\n    result.append(Utils.padLeft(\"\", 5)).append(Utils.padRight(\"Name\", 25));\n    result.append(Utils.padLeft(\"Type\", 5)).append(Utils.padLeft(\"Nom\", 5));\n    result.append(Utils.padLeft(\"Int\", 5)).append(Utils.padLeft(\"Real\", 5));\n    result.append(Utils.padLeft(\"Missing\", 12));\n    result.append(Utils.padLeft(\"Unique\", 12));\n    result.append(Utils.padLeft(\"Dist\", 6)).append('\\n');\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      Attribute a = attribute(i);\n      AttributeStats as = attributeStats(i);\n      result.append(Utils.padLeft(\"\" + (i + 1), 4)).append(' ');\n      result.append(Utils.padRight(a.name(), 25)).append(' ');\n      long percent;\n      switch (a.type()) {\n      case Attribute.NOMINAL:\n\tresult.append(Utils.padLeft(\"Nom\", 4)).append(' ');\n\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tbreak;\n      case Attribute.NUMERIC:\n\tresult.append(Utils.padLeft(\"Num\", 4)).append(' ');\n\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tbreak;\n      case Attribute.DATE:\n\tresult.append(Utils.padLeft(\"Dat\", 4)).append(' ');\n\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tbreak;\n      case Attribute.STRING:\n\tresult.append(Utils.padLeft(\"Str\", 4)).append(' ');\n\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tbreak;\n      default:\n\tresult.append(Utils.padLeft(\"???\", 4)).append(' ');\n\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tbreak;\n      }\n      result.append(Utils.padLeft(\"\" + as.missingCount, 5)).append(\" /\");\n      percent = Math.round(100.0 * as.missingCount / as.totalCount);\n      result.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n      result.append(Utils.padLeft(\"\" + as.uniqueCount, 5)).append(\" /\");\n      percent = Math.round(100.0 * as.uniqueCount / as.totalCount);\n      result.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n      result.append(Utils.padLeft(\"\" + as.distinctCount, 5)).append(' ');\n      result.append('\\n');\n    }\n    return result.toString();\n  }\n  \n  /**\n   * Reads a single instance using the tokenizer and appends it\n   * to the dataset. Automatically expands the dataset if it\n   * is not large enough to hold the instance.\n   *\n   * @param tokenizer the tokenizer to be used\n   * @param flag if method should test for carriage return after \n   * each instance\n   * @return false if end of file has been reached\n   * @exception IOException if the information is not read \n   * successfully\n   */ \n  protected boolean getInstance(StreamTokenizer tokenizer, \n\t\t\t\tboolean flag) \n       throws IOException {\n    \n    // Check if any attributes have been declared.\n    if (m_Attributes.size() == 0) {\n      errms(tokenizer,\"no header information available\");\n    }\n\n    // Check if end of file reached.\n    getFirstToken(tokenizer);\n    if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n      return false;\n    }\n    \n    // Parse instance\n    if (tokenizer.ttype == '{') {\n      return getInstanceSparse(tokenizer, flag);\n    } else {\n      return getInstanceFull(tokenizer, flag);\n    }\n  }\n\n  /**\n   * Reads a single instance using the tokenizer and appends it\n   * to the dataset. Automatically expands the dataset if it\n   * is not large enough to hold the instance.\n   *\n   * @param tokenizer the tokenizer to be used\n   * @param flag if method should test for carriage return after \n   * each instance\n   * @return false if end of file has been reached\n   * @exception IOException if the information is not read \n   * successfully\n   */ \n  protected boolean getInstanceSparse(StreamTokenizer tokenizer, \n\t\t\t\t      boolean flag) \n       throws IOException {\n\n    int valIndex, numValues = 0, maxIndex = -1;\n    \n    // Get values\n    do {\n      \n      // Get index\n      getIndex(tokenizer);\n      if (tokenizer.ttype == '}') {\n\tbreak;\n      }\n       \n      // Is index valid?\n      try{\n\tm_IndicesBuffer[numValues] = Integer.valueOf(tokenizer.sval).intValue();\n      } catch (NumberFormatException e) {\n\terrms(tokenizer,\"index number expected\");\n      }\n      if (m_IndicesBuffer[numValues] \u003c= maxIndex) {\n\terrms(tokenizer,\"indices have to be ordered\");\n      }\n      if ((m_IndicesBuffer[numValues] \u003c 0) || \n\t  (m_IndicesBuffer[numValues] \u003e= numAttributes())) {\n\terrms(tokenizer,\"index out of bounds\");\n      }\n      maxIndex = m_IndicesBuffer[numValues];\n\n      // Get value;\n      getNextToken(tokenizer);\n\n      // Check if value is missing.\n      if  (tokenizer.ttype == '?') {\n\tm_ValueBuffer[numValues] = Instance.missingValue();\n      } else {\n\n\t// Check if token is valid.\n\tif (tokenizer.ttype != StreamTokenizer.TT_WORD) {\n\t  errms(tokenizer,\"not a valid value\");\n\t}\n        switch (attribute(m_IndicesBuffer[numValues]).type()) {\n          case Attribute.NOMINAL:\n            // Check if value appears in header.\n            valIndex = \n              attribute(m_IndicesBuffer[numValues]).indexOfValue(tokenizer.sval);\n            if (valIndex == -1) {\n              errms(tokenizer,\"nominal value not declared in header\");\n            }\n            m_ValueBuffer[numValues] = (double)valIndex;\n            break;\n\tcase Attribute.NUMERIC:\n\t  // Check if value is really a number.\n\t  try{\n\t    m_ValueBuffer[numValues] = Double.valueOf(tokenizer.sval).\n\t      doubleValue();\n\t  } catch (NumberFormatException e) {\n\t    errms(tokenizer,\"number expected\");\n\t  }\n          break;\n\tcase Attribute.STRING:\n\t  m_ValueBuffer[numValues] = \n\t    attribute(m_IndicesBuffer[numValues]).addStringValue(tokenizer.sval);\n          break;\n        case Attribute.DATE:\n          try {\n            m_ValueBuffer[numValues] = \n              attribute(m_IndicesBuffer[numValues]).parseDate(tokenizer.sval);\n          } catch (ParseException e) {\n            errms(tokenizer,\"unparseable date: \" + tokenizer.sval);\n          }\n          break;\n        default:\n          errms(tokenizer,\"unknown attribute type in column \" + m_IndicesBuffer[numValues]);\n\t}\n      }\n      numValues++;\n    } while (true);\n    if (flag) {\n      getLastToken(tokenizer,true);\n    }\n      \n    // Add instance to dataset\n    double[] tempValues = new double[numValues];\n    int[] tempIndices = new int[numValues];\n    System.arraycopy(m_ValueBuffer, 0, tempValues, 0, numValues);\n    System.arraycopy(m_IndicesBuffer, 0, tempIndices, 0, numValues);\n    add(new SparseInstance(1, tempValues, tempIndices, numAttributes()));\n    return true;\n  }\n\n  /**\n   * Reads a single instance using the tokenizer and appends it\n   * to the dataset. Automatically expands the dataset if it\n   * is not large enough to hold the instance.\n   *\n   * @param tokenizer the tokenizer to be used\n   * @param flag if method should test for carriage return after \n   * each instance\n   * @return false if end of file has been reached\n   * @exception IOException if the information is not read \n   * successfully\n   */ \n  protected boolean getInstanceFull(StreamTokenizer tokenizer, \n\t\t\t\t    boolean flag) \n       throws IOException {\n\n    double[] instance = new double[numAttributes()];\n    int index;\n    \n    // Get values for all attributes.\n    for (int i = 0; i \u003c numAttributes(); i++){\n      \n      // Get next token\n      if (i \u003e 0) {\n\tgetNextToken(tokenizer);\n      }\n            \n      // Check if value is missing.\n      if  (tokenizer.ttype == '?') {\n\tinstance[i] = Instance.missingValue();\n      } else {\n\n\t// Check if token is valid.\n\tif (tokenizer.ttype != StreamTokenizer.TT_WORD) {\n\t  errms(tokenizer,\"not a valid value\");\n\t}\n        switch (attribute(i).type()) {\n        case Attribute.NOMINAL:\n\t  // Check if value appears in header.\n\t  index = attribute(i).indexOfValue(tokenizer.sval);\n\t  if (index == -1) {\n\t    errms(tokenizer,\"nominal value not declared in header\");\n\t  }\n\t  instance[i] = (double)index;\n          break;\n\tcase Attribute.NUMERIC:\n\t  // Check if value is really a number.\n\t  try{\n\t    instance[i] = Double.valueOf(tokenizer.sval).\n\t      doubleValue();\n\t  } catch (NumberFormatException e) {\n\t    errms(tokenizer,\"number expected\");\n\t  }\n          break;\n\tcase Attribute.STRING:\n\t  instance[i] = attribute(i).addStringValue(tokenizer.sval);\n          break;\n        case Attribute.DATE:\n          try {\n            instance[i] = attribute(i).parseDate(tokenizer.sval);\n          } catch (ParseException e) {\n            errms(tokenizer,\"unparseable date: \" + tokenizer.sval);\n          }\n          break;\n        default:\n          errms(tokenizer,\"unknown attribute type in column \" + i);\n\t}\n      }\n    }\n    if (flag) {\n      getLastToken(tokenizer,true);\n    }\n      \n    // Add instance to dataset\n    add(new Instance(1, instance));\n    return true;\n  }\n\n  /**\n   * Reads and stores header of an ARFF file.\n   *\n   * @param tokenizer the stream tokenizer\n   * @exception IOException if the information is not read \n   * successfully\n   */ \n  protected void readHeader(StreamTokenizer tokenizer) \n     throws IOException {\n    \n    String attributeName;\n    FastVector attributeValues;\n    int i;\n\n    // Get name of relation.\n    getFirstToken(tokenizer);\n    if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n      errms(tokenizer,\"premature end of file\");\n    }\n    if (ARFF_RELATION.equalsIgnoreCase(tokenizer.sval)) {\n      getNextToken(tokenizer);\n      m_RelationName = tokenizer.sval;\n      getLastToken(tokenizer,false);\n    } else {\n      errms(tokenizer,\"keyword \" + ARFF_RELATION + \" expected\");\n    }\n\n    // Create vectors to hold information temporarily.\n    m_Attributes = new FastVector();\n \n    // Get attribute declarations.\n    getFirstToken(tokenizer);\n    if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n      errms(tokenizer,\"premature end of file\");\n    }\n\n    while (Attribute.ARFF_ATTRIBUTE.equalsIgnoreCase(tokenizer.sval)) {\n\n      // Get attribute name.\n      getNextToken(tokenizer);\n      attributeName = tokenizer.sval;\n      getNextToken(tokenizer);\n\n      // Check if attribute is nominal.\n      if (tokenizer.ttype == StreamTokenizer.TT_WORD) {\n\n\t// Attribute is real, integer, or string.\n\tif (tokenizer.sval.equalsIgnoreCase(Attribute.ARFF_ATTRIBUTE_REAL) ||\n\t    tokenizer.sval.equalsIgnoreCase(Attribute.ARFF_ATTRIBUTE_INTEGER) ||\n\t    tokenizer.sval.equalsIgnoreCase(Attribute.ARFF_ATTRIBUTE_NUMERIC)) {\n\t  m_Attributes.addElement(new Attribute(attributeName, numAttributes()));\n\t  readTillEOL(tokenizer);\n\t} else if (tokenizer.sval.equalsIgnoreCase(Attribute.ARFF_ATTRIBUTE_STRING)) {\n\t  m_Attributes.\n\t    addElement(new Attribute(attributeName, (FastVector)null,\n\t\t\t\t     numAttributes()));\n\t  readTillEOL(tokenizer);\n\t} else if (tokenizer.sval.equalsIgnoreCase(Attribute.ARFF_ATTRIBUTE_DATE)) {\n          String format = null;\n          if (tokenizer.nextToken() != StreamTokenizer.TT_EOL) {\n            if ((tokenizer.ttype != StreamTokenizer.TT_WORD) \u0026\u0026\n                (tokenizer.ttype != '\\'') \u0026\u0026\n                (tokenizer.ttype != '\\\"')) {\n              errms(tokenizer,\"not a valid date format\");\n            }\n            format = tokenizer.sval;\n            readTillEOL(tokenizer);\n          } else {\n            tokenizer.pushBack();\n          }\n\t  m_Attributes.addElement(new Attribute(attributeName, format,\n                                                numAttributes()));\n\n\t} else {\n\t  errms(tokenizer,\"no valid attribute type or invalid \"+\n\t\t\"enumeration\");\n\t}\n      } else {\n\n\t// Attribute is nominal.\n\tattributeValues = new FastVector();\n\ttokenizer.pushBack();\n\t\n\t// Get values for nominal attribute.\n\tif (tokenizer.nextToken() != '{') {\n\t  errms(tokenizer,\"{ expected at beginning of enumeration\");\n\t}\n\twhile (tokenizer.nextToken() != '}') {\n\t  if (tokenizer.ttype == StreamTokenizer.TT_EOL) {\n\t    errms(tokenizer,\"} expected at end of enumeration\");\n\t  } else {\n\t    attributeValues.addElement(tokenizer.sval);\n\t  }\n\t}\n\tm_Attributes.\n\t  addElement(new Attribute(attributeName, attributeValues,\n\t\t\t\t   numAttributes()));\n      }\n      getLastToken(tokenizer,false);\n      getFirstToken(tokenizer);\n      if (tokenizer.ttype == StreamTokenizer.TT_EOF)\n\terrms(tokenizer,\"premature end of file\");\n    }\n\n    // Check if data part follows. We can't easily check for EOL.\n    if (!ARFF_DATA.equalsIgnoreCase(tokenizer.sval)) {\n      errms(tokenizer,\"keyword \" + ARFF_DATA + \" expected\");\n    }\n    \n    // Check if any attributes have been declared.\n    if (m_Attributes.size() == 0) {\n      errms(tokenizer,\"no attributes declared\");\n    }\n\n    // Allocate buffers in case sparse instances have to be read\n    m_ValueBuffer = new double[numAttributes()];\n    m_IndicesBuffer = new int[numAttributes()];\n  }\n\n  /**\n   * Copies instances from one set to the end of another \n   * one.\n   *\n   * @param source the source of the instances\n   * @param from the position of the first instance to be copied\n   * @param dest the destination for the instances\n   * @param num the number of instances to be copied\n   */\n  //@ requires 0 \u003c= from \u0026\u0026 from \u003c= numInstances() - num;\n  //@ requires 0 \u003c= num;\n  protected void copyInstances(int from, /*@non_null@*/ Instances dest, int num) {\n    \n    for (int i = 0; i \u003c num; i++) {\n      dest.add(instance(from + i));\n    }\n  }\n  \n  /**\n   * Throws error message with line number and last token read.\n   *\n   * @param theMsg the error message to be thrown\n   * @param tokenizer the stream tokenizer\n   * @throws IOExcpetion containing the error message\n   */\n  protected void errms(StreamTokenizer tokenizer, String theMsg) \n       throws IOException {\n    \n    throw new IOException(theMsg + \", read \" + tokenizer.toString());\n  }\n  \n  /**\n   * Replaces the attribute information by a clone of\n   * itself.\n   */\n  protected void freshAttributeInfo() {\n\n    m_Attributes = (FastVector) m_Attributes.copyElements();\n  }\n\n  /**\n   * Gets next token, skipping empty lines.\n   *\n   * @param tokenizer the stream tokenizer\n   * @exception IOException if reading the next token fails\n   */\n  protected void getFirstToken(StreamTokenizer tokenizer) \n    throws IOException {\n    \n    while (tokenizer.nextToken() == StreamTokenizer.TT_EOL){};\n    if ((tokenizer.ttype == '\\'') ||\n\t(tokenizer.ttype == '\"')) {\n      tokenizer.ttype = StreamTokenizer.TT_WORD;\n    } else if ((tokenizer.ttype == StreamTokenizer.TT_WORD) \u0026\u0026\n\t       (tokenizer.sval.equals(\"?\"))){\n      tokenizer.ttype = '?';\n    }\n  }\n\n  /**\n   * Gets index, checking for a premature and of line.\n   *\n   * @param tokenizer the stream tokenizer\n   * @exception IOException if it finds a premature end of line\n   */\n  protected void getIndex(StreamTokenizer tokenizer) throws IOException {\n    \n    if (tokenizer.nextToken() == StreamTokenizer.TT_EOL) {\n      errms(tokenizer,\"premature end of line\");\n    }\n    if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n      errms(tokenizer,\"premature end of file\");\n    }\n  }\n  \n  /**\n   * Gets token and checks if its end of line.\n   *\n   * @param tokenizer the stream tokenizer\n   * @exception IOException if it doesn't find an end of line\n   */\n  protected void getLastToken(StreamTokenizer tokenizer, boolean endOfFileOk) \n       throws IOException {\n\n    if ((tokenizer.nextToken() != StreamTokenizer.TT_EOL) \u0026\u0026\n\t((tokenizer.ttype != StreamTokenizer.TT_EOF) || !endOfFileOk)) {\n      errms(tokenizer,\"end of line expected\");\n    }\n  }\n\n  /**\n   * Gets next token, checking for a premature and of line.\n   *\n   * @param tokenizer the stream tokenizer\n   * @exception IOException if it finds a premature end of line\n   */\n  protected void getNextToken(StreamTokenizer tokenizer) \n       throws IOException {\n    \n    if (tokenizer.nextToken() == StreamTokenizer.TT_EOL) {\n      errms(tokenizer,\"premature end of line\");\n    }\n    if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n      errms(tokenizer,\"premature end of file\");\n    } else if ((tokenizer.ttype == '\\'') ||\n\t       (tokenizer.ttype == '\"')) {\n      tokenizer.ttype = StreamTokenizer.TT_WORD;\n    } else if ((tokenizer.ttype == StreamTokenizer.TT_WORD) \u0026\u0026\n\t       (tokenizer.sval.equals(\"?\"))){\n      tokenizer.ttype = '?';\n    }\n  }\n\t\n  /**\n   * Initializes the StreamTokenizer used for reading the ARFF file.\n   *\n   * @param tokenizer the stream tokenizer\n   */\n  protected void initTokenizer(StreamTokenizer tokenizer){\n\n    tokenizer.resetSyntax();         \n    tokenizer.whitespaceChars(0, ' ');    \n    tokenizer.wordChars(' '+1,'\\u00FF');\n    tokenizer.whitespaceChars(',',',');\n    tokenizer.commentChar('%');\n    tokenizer.quoteChar('\"');\n    tokenizer.quoteChar('\\'');\n    tokenizer.ordinaryChar('{');\n    tokenizer.ordinaryChar('}');\n    tokenizer.eolIsSignificant(true);\n  }\n \n  /**\n   * Returns string including all instances, their weights and\n   * their indices in the original dataset.\n   *\n   * @return description of instance and its weight as a string\n   */\n  protected /*@pure@*/ String instancesAndWeights(){\n\n    StringBuffer text = new StringBuffer();\n\n    for (int i = 0; i \u003c numInstances(); i++) {\n      text.append(instance(i) + \" \" + instance(i).weight());\n      if (i \u003c numInstances() - 1) {\n\ttext.append(\"\\n\");\n      }\n    }\n    return text.toString();\n  }\n  \n  /**\n   * Partitions the instances around a pivot. Used by quicksort and\n   * kthSmallestValue.\n   *\n   * @param attIndex the attribute's index\n   * @param left the first index of the subset \n   * @param right the last index of the subset \n   *\n   * @return the index of the middle element\n   */\n  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\n  //@ requires 0 \u003c= left \u0026\u0026 left \u003c= right \u0026\u0026 right \u003c numInstances();\n  protected int partition(int attIndex, int l, int r) {\n    \n    double pivot = instance((l + r) / 2).value(attIndex);\n\n    while (l \u003c r) {\n      while ((instance(l).value(attIndex) \u003c pivot) \u0026\u0026 (l \u003c r)) {\n        l++;\n      }\n      while ((instance(r).value(attIndex) \u003e pivot) \u0026\u0026 (l \u003c r)) {\n        r--;\n      }\n      if (l \u003c r) {\n        swap(l, r);\n        l++;\n        r--;\n      }\n    }\n    if ((l == r) \u0026\u0026 (instance(r).value(attIndex) \u003e pivot)) {\n      r--;\n    } \n\n    return r;\n  }\n  \n  /**\n   * Implements quicksort according to Manber's \"Introduction to\n   * Algorithms\".\n   *\n   * @param attIndex the attribute's index\n   * @param left the first index of the subset to be sorted\n   * @param right the last index of the subset to be sorted\n   */\n  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c numInstances();\n  protected void quickSort(int attIndex, int left, int right) {\n\n    if (left \u003c right) {\n      int middle = partition(attIndex, left, right);\n      quickSort(attIndex, left, middle);\n      quickSort(attIndex, middle + 1, right);\n    }\n  }\n\n  /**\n   * Reads and skips all tokens before next end of line token.\n   *\n   * @param tokenizer the stream tokenizer\n   */\n  protected void readTillEOL(StreamTokenizer tokenizer) \n       throws IOException {\n    \n    while (tokenizer.nextToken() != StreamTokenizer.TT_EOL) {};\n    tokenizer.pushBack();\n  }\n  \n  /**\n   * Implements computation of the kth-smallest element according\n   * to Manber's \"Introduction to Algorithms\".\n   *\n   * @param attIndex the attribute's index\n   * @param left the first index of the subset \n   * @param right the last index of the subset \n   * @param k the value of k\n   *\n   * @return the index of the kth-smallest element\n   */\n  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c numInstances();\n  protected int select(int attIndex, int left, int right, int k) {\n    \n    if (left == right) {\n      return left;\n    } else {\n      int middle = partition(attIndex, left, right);\n      if ((middle - left + 1) \u003e= k) {\n        return select(attIndex, left, middle, k);\n      } else {\n        return select(attIndex, middle + 1, right, k - (middle - left + 1));\n      }\n    }\n  }\n\n  /**\n   * Help function needed for stratification of set.\n   *\n   * @param numFolds the number of folds for the stratification\n   */\n  protected void stratStep (int numFolds){\n    \n    FastVector newVec = new FastVector(m_Instances.capacity());\n    int start = 0, j;\n\n    // create stratified batch\n    while (newVec.size() \u003c numInstances()) {\n      j = start;\n      while (j \u003c numInstances()) {\n\tnewVec.addElement(instance(j));\n\tj = j + numFolds;\n      }\n      start++;\n    }\n    m_Instances = newVec;\n  }\n  \n  /**\n   * Swaps two instances in the set.\n   *\n   * @param i the first instance's index\n   * @param j the second instance's index\n   */\n  //@ requires 0 \u003c= i \u0026\u0026 i \u003c numInstances();\n  //@ requires 0 \u003c= j \u0026\u0026 j \u003c numInstances();\n  public void swap(int i, int j){\n    \n    m_Instances.swap(i, j);\n  }\n\n  /**\n   * Merges two sets of Instances together. The resulting set will have\n   * all the attributes of the first set plus all the attributes of the \n   * second set. The number of instances in both sets must be the same.\n   *\n   * @param first the first set of Instances\n   * @param second the second set of Instances\n   * @return the merged set of Instances\n   * @exception IllegalArgumentException if the datasets are not the same size\n   */\n  public static Instances mergeInstances(Instances first, Instances second) {\n\n    if (first.numInstances() != second.numInstances()) {\n      throw new IllegalArgumentException(\"Instance sets must be of the same size\");\n    }\n\n    // Create the vector of merged attributes\n    FastVector newAttributes = new FastVector();\n    for (int i = 0; i \u003c first.numAttributes(); i++) {\n      newAttributes.addElement(first.attribute(i));\n    }\n    for (int i = 0; i \u003c second.numAttributes(); i++) {\n      newAttributes.addElement(second.attribute(i));\n    }\n    \n    // Create the set of Instances\n    Instances merged = new Instances(first.relationName() + '_'\n\t\t\t\t     + second.relationName(), \n\t\t\t\t     newAttributes, \n\t\t\t\t     first.numInstances());\n    // Merge each instance\n    for (int i = 0; i \u003c first.numInstances(); i++) {\n      merged.add(first.instance(i).mergeInstance(second.instance(i)));\n    }\n    return merged;\n  }\n\n  /**\n   * Method for testing this class.\n   *\n   * @param argv should contain one element: the name of an ARFF file\n   */\n  //@ requires argv != null;\n  //@ requires argv.length == 1;\n  //@ requires argv[0] != null;\n  public static void test(String [] argv) {\n\n    Instances instances, secondInstances, train, test, transformed, empty;\n    Instance instance;\n    Random random = new Random(2);\n    Reader reader;\n    int start, num;\n    double newWeight;\n    FastVector testAtts, testVals;\n    int i,j;\n    \n    try{\n      if (argv.length \u003e 1) {\n\tthrow (new Exception(\"Usage: Instances [\u003cfilename\u003e]\"));\n      }\n      \n      // Creating set of instances from scratch\n      testVals = new FastVector(2);\n      testVals.addElement(\"first_value\");\n      testVals.addElement(\"second_value\");\n      testAtts = new FastVector(2);\n      testAtts.addElement(new Attribute(\"nominal_attribute\", testVals));\n      testAtts.addElement(new Attribute(\"numeric_attribute\"));\n      instances = new Instances(\"test_set\", testAtts, 10);\n      instances.add(new Instance(instances.numAttributes()));\n      instances.add(new Instance(instances.numAttributes()));\n      instances.add(new Instance(instances.numAttributes()));\n      instances.setClassIndex(0);\n      System.out.println(\"\\nSet of instances created from scratch:\\n\");\n      System.out.println(instances);\n      \n      if (argv.length == 1) {\n\tString filename = argv[0];\n\treader = new FileReader(filename);\n\t\n\t// Read first five instances and print them\n\tSystem.out.println(\"\\nFirst five instances from file:\\n\");\n\tinstances = new Instances(reader, 1);\n\tinstances.setClassIndex(instances.numAttributes() - 1);\n\ti = 0;\n\twhile ((i \u003c 5) \u0026\u0026 (instances.readInstance(reader))) {\n\t  i++;\n\t}\n\tSystem.out.println(instances);\n\n\t// Read all the instances in the file\n\treader = new FileReader(filename);\n\tinstances = new Instances(reader);\n\n\t// Make the last attribute be the class \n\tinstances.setClassIndex(instances.numAttributes() - 1);\n\t\n\t// Print header and instances.\n\tSystem.out.println(\"\\nDataset:\\n\");\n\tSystem.out.println(instances);\n\tSystem.out.println(\"\\nClass index: \"+instances.classIndex());\n      }\n      \n      // Test basic methods based on class index.\n      System.out.println(\"\\nClass name: \"+instances.classAttribute().name());\n      System.out.println(\"\\nClass index: \"+instances.classIndex());\n      System.out.println(\"\\nClass is nominal: \" +\n\t\t\t instances.classAttribute().isNominal());\n      System.out.println(\"\\nClass is numeric: \" +\n\t\t\t instances.classAttribute().isNumeric());\n      System.out.println(\"\\nClasses:\\n\");\n      for (i = 0; i \u003c instances.numClasses(); i++) {\n\tSystem.out.println(instances.classAttribute().value(i));\n      }\n      System.out.println(\"\\nClass values and labels of instances:\\n\");\n      for (i = 0; i \u003c instances.numInstances(); i++) {\n\tInstance inst = instances.instance(i);\n\tSystem.out.print(inst.classValue() + \"\\t\");\n\tSystem.out.print(inst.toString(inst.classIndex()));\n\tif (instances.instance(i).classIsMissing()) {\n\t  System.out.println(\"\\tis missing\");\n\t} else {\n\t  System.out.println();\n\t}\n      }\n      \n      // Create random weights.\n      System.out.println(\"\\nCreating random weights for instances.\");\n      for (i = 0; i \u003c instances.numInstances(); i++) {\n\tinstances.instance(i).setWeight(random.nextDouble()); \n      }\n      \n      // Print all instances and their weights (and the sum of weights).\n      System.out.println(\"\\nInstances and their weights:\\n\");\n      System.out.println(instances.instancesAndWeights());\n      System.out.print(\"\\nSum of weights: \");\n      System.out.println(instances.sumOfWeights());\n      \n      // Insert an attribute\n      secondInstances = new Instances(instances);\n      Attribute testAtt = new Attribute(\"Inserted\");\n      secondInstances.insertAttributeAt(testAtt, 0);\n      System.out.println(\"\\nSet with inserted attribute:\\n\");\n      System.out.println(secondInstances);\n      System.out.println(\"\\nClass name: \"\n\t\t\t + secondInstances.classAttribute().name());\n      \n      // Delete the attribute\n      secondInstances.deleteAttributeAt(0);\n      System.out.println(\"\\nSet with attribute deleted:\\n\");\n      System.out.println(secondInstances);\n      System.out.println(\"\\nClass name: \"\n\t\t\t + secondInstances.classAttribute().name());\n      \n      // Test if headers are equal\n      System.out.println(\"\\nHeaders equal: \"+\n\t\t\t instances.equalHeaders(secondInstances) + \"\\n\");\n      \n      // Print data in internal format.\n      System.out.println(\"\\nData (internal values):\\n\");\n      for (i = 0; i \u003c instances.numInstances(); i++) {\n\tfor (j = 0; j \u003c instances.numAttributes(); j++) {\n\t  if (instances.instance(i).isMissing(j)) {\n\t    System.out.print(\"? \");\n\t  } else {\n\t    System.out.print(instances.instance(i).value(j) + \" \");\n\t  }\n\t}\n\tSystem.out.println();\n      }\n      \n      // Just print header\n      System.out.println(\"\\nEmpty dataset:\\n\");\n      empty = new Instances(instances, 0);\n      System.out.println(empty);\n      System.out.println(\"\\nClass name: \"+empty.classAttribute().name());\n\n      // Create copy and rename an attribute and a value (if possible)\n      if (empty.classAttribute().isNominal()) {\n\tInstances copy = new Instances(empty, 0);\n\tcopy.renameAttribute(copy.classAttribute(), \"new_name\");\n\tcopy.renameAttributeValue(copy.classAttribute(), \n\t\t\t\t  copy.classAttribute().value(0), \n\t\t\t\t  \"new_val_name\");\n\tSystem.out.println(\"\\nDataset with names changed:\\n\" + copy);\n\tSystem.out.println(\"\\nOriginal dataset:\\n\" + empty);\n      }\n\n      // Create and prints subset of instances.\n      start = instances.numInstances() / 4;\n      num = instances.numInstances() / 2;\n      System.out.print(\"\\nSubset of dataset: \");\n      System.out.println(num + \" instances from \" + (start + 1) \n\t\t\t + \". instance\");\n      secondInstances = new Instances(instances, start, num);\n      System.out.println(\"\\nClass name: \"\n\t\t\t + secondInstances.classAttribute().name());\n\n      // Print all instances and their weights (and the sum of weights).\n      System.out.println(\"\\nInstances and their weights:\\n\");\n      System.out.println(secondInstances.instancesAndWeights());\n      System.out.print(\"\\nSum of weights: \");\n      System.out.println(secondInstances.sumOfWeights());\n      \n      // Create and print training and test sets for 3-fold\n      // cross-validation.\n      System.out.println(\"\\nTrain and test folds for 3-fold CV:\");\n      if (instances.classAttribute().isNominal()) {\n\tinstances.stratify(3);\n      }\n      for (j = 0; j \u003c 3; j++) {\n        train = instances.trainCV(3,j, new Random(1));\n\ttest = instances.testCV(3,j);\n                      \n\t// Print all instances and their weights (and the sum of weights).\n\tSystem.out.println(\"\\nTrain: \");\n\tSystem.out.println(\"\\nInstances and their weights:\\n\");\n\tSystem.out.println(train.instancesAndWeights());\n\tSystem.out.print(\"\\nSum of weights: \");\n\tSystem.out.println(train.sumOfWeights());\n\tSystem.out.println(\"\\nClass name: \"+train.classAttribute().name());\n\tSystem.out.println(\"\\nTest: \");\n\tSystem.out.println(\"\\nInstances and their weights:\\n\");\n\tSystem.out.println(test.instancesAndWeights());\n\tSystem.out.print(\"\\nSum of weights: \");\n\tSystem.out.println(test.sumOfWeights());\n\tSystem.out.println(\"\\nClass name: \"+test.classAttribute().name());\n      }\n\n      // Randomize instances and print them.\n      System.out.println(\"\\nRandomized dataset:\");\n      instances.randomize(random);\n      \n      // Print all instances and their weights (and the sum of weights).\n      System.out.println(\"\\nInstances and their weights:\\n\");\n      System.out.println(instances.instancesAndWeights());\n      System.out.print(\"\\nSum of weights: \");\n      System.out.println(instances.sumOfWeights());\n\n      // Sort instances according to first attribute and\n      // print them.\n      System.out.print(\"\\nInstances sorted according to first attribute:\\n \");\n      instances.sort(0);\n        \n      // Print all instances and their weights (and the sum of weights).\n      System.out.println(\"\\nInstances and their weights:\\n\");\n      System.out.println(instances.instancesAndWeights());\n      System.out.print(\"\\nSum of weights: \");\n      System.out.println(instances.sumOfWeights());\n    } catch (Exception e) {\n      e.printStackTrace(); \n    }\n  }\n\n  /**\n   * Main method for this class. The following calls are possible:\n   * \u003cul\u003e\n   *   \u003cli\u003e\n   *     \u003ccode\u003eweka.core.Instances\u003c/code\u003e \u0026lt;filename\u0026gt;\u003cbr/\u003e\n   *     prints a summary of a set of instances.\n   *   \u003c/li\u003e\n   *   \u003cli\u003e\n   *     \u003ccode\u003eweka.core.Instances\u003c/code\u003e merge \u0026lt;filename1\u0026gt; \u0026lt;filename2\u0026gt;\u003cbr/\u003e\n   *     merges the two datasets (must have same number of instances) and\n   *     outputs the results on stdout.\n   *   \u003c/li\u003e\n   * \u003c/ul\u003e\n   *\n   * @param args \tthe commandline parameters\n   */\n  public static void main(String[] args) {\n\n    try {\n      Instances i;\n      // read from stdin and print statistics\n      if (args.length == 0) {\n\ti = new Instances(new BufferedReader(new InputStreamReader(System.in)));\n\tSystem.out.println(i.toSummaryString());\n      }\n      // read file and print statistics\n      else if (args.length == 1) {\n\ti = new Instances(new BufferedReader(new FileReader(args[0])));\n\tSystem.out.println(i.toSummaryString());\n      }\n      // read two files, merge them and print result to stdout\n      else if ((args.length == 3) \u0026\u0026 (args[0].toLowerCase().equals(\"merge\"))) {\n\ti = Instances.mergeInstances(\n            new Instances(new BufferedReader(new FileReader(args[1]))),\n            new Instances(new BufferedReader(new FileReader(args[2]))));\n\tSystem.out.println(i);\n      }\n      // wrong parameters\n      else {\n\tSystem.err.println(\n\t    \"\\nUsage:\\n\"\n\t    + \"\\tweka.core.Instances \u003cfilename\u003e\\n\"\n\t    + \"\\tweka.core.Instances merge \u003cfilename1\u003e \u003cfilename2\u003e\\n\");\n\tSystem.exit(1);\n      }\n    }\n    catch (Exception ex) {\n      ex.printStackTrace();\n      System.err.println(ex.getMessage());\n    }\n  }\n}\n\n",
        "name": "Instances.java",
        "path": "subjectSystems/C,D/src/weka/core/Instances.java",
        "url": "/github.com/LASER-UMASS/Themis/-/blob/subjectSystems/C,D/src/weka/core/Instances.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 132,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires capacity \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 133,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures classIndex() == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 195,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first;"
        },
        {
          "limitHit": false,
          "lineNumber": 196,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= toCopy;"
        },
        {
          "limitHit": false,
          "lineNumber": 197,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires first + toCopy \u003c= source.numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 274,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;"
        },
        {
          "limitHit": false,
          "lineNumber": 275,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003c m_Attributes.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 276,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 355,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 398,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 413,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= position \u0026\u0026 position \u003c numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 414,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires position != classIndex();"
        },
        {
          "limitHit": false,
          "lineNumber": 462,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 549,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires numInstances() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 581,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= position;"
        },
        {
          "limitHit": false,
          "lineNumber": 582,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires position \u003c= numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 611,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;"
        },
        {
          "limitHit": false,
          "lineNumber": 612,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 676,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires numInstances() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 739,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Attributes.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 752,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 773,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= attIndex;"
        },
        {
          "limitHit": false,
          "lineNumber": 774,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attIndex \u003c numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 817,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Instances.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 860,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_RelationName;"
        },
        {
          "limitHit": false,
          "lineNumber": 1169,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 1170,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;"
        },
        {
          "limitHit": false,
          "lineNumber": 1231,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 1232,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;"
        },
        {
          "limitHit": false,
          "lineNumber": 1272,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 1273,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;"
        },
        {
          "limitHit": false,
          "lineNumber": 1339,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 1383,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 1819,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= from \u0026\u0026 from \u003c= numInstances() - num;"
        },
        {
          "limitHit": false,
          "lineNumber": 1820,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= num;"
        },
        {
          "limitHit": false,
          "lineNumber": 1971,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 1972,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= left \u0026\u0026 left \u003c= right \u0026\u0026 right \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 2005,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 2006,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 2039,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 2040,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 2083,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= i \u0026\u0026 i \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 2084,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= j \u0026\u0026 j \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 2132,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires argv != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 2133,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires argv.length == 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 2134,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires argv[0] != null;"
        }
      ],
      "repository": {
        "name": "github.com/LASER-UMASS/Themis",
        "url": "/github.com/LASER-UMASS/Themis"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a70f12a6a8f34cdd8b170b4dc59a78674c9e8950"
        },
        "content": "/*\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; either version 2 of the License, or\n *    (at your option) any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n/*\n *    Attribute.java\n *    Copyright (C) 1999 Eibe Frank\n *\n */\n\npackage weka.core;\n\nimport java.io.Serializable;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport java.io.StreamTokenizer;\nimport java.io.StringReader;\nimport java.io.IOException;\n\n/** \n * Class for handling an attribute. Once an attribute has been created,\n * it can't be changed. \u003cp\u003e\n *\n * The following attribute types are supported:\n * \u003cul\u003e\n *    \u003cli\u003e numeric: \u003cbr/\u003e\n *         This type of attribute represents a floating-point number.\n *    \u003c/li\u003e\n *    \u003cli\u003e nominal: \u003cbr/\u003e\n *         This type of attribute represents a fixed set of nominal values.\n *    \u003c/li\u003e\n *    \u003cli\u003e string: \u003cbr/\u003e\n *         This type of attribute represents a dynamically expanding set of\n *         nominal values. Usually used in text classification.\n *    \u003c/li\u003e\n *    \u003cli\u003e date: \u003cbr/\u003e\n *         This type of attribute represents a date, internally represented as \n *         floating-point number storing the milliseconds since January 1, \n *         1970, 00:00:00 GMT. The string representation of the date must be\n *         \u003ca href=\"http://www.iso.org/iso/en/prods-services/popstds/datesandtime.html\" target=\"_blank\"\u003e\n *         ISO-8601\u003c/a\u003e compliant, the default is \u003ccode\u003eyyyy-MM-dd'T'HH:mm:ss\u003c/code\u003e.\n *    \u003c/li\u003e\n * \u003c/ul\u003e\n * \n * Typical usage (code from the main() method of this class): \u003cp\u003e\n *\n * \u003ccode\u003e\n * ... \u003cbr\u003e\n *\n * // Create numeric attributes \"length\" and \"weight\" \u003cbr\u003e\n * Attribute length = new Attribute(\"length\"); \u003cbr\u003e\n * Attribute weight = new Attribute(\"weight\"); \u003cbr\u003e\u003cbr\u003e\n * \n * // Create vector to hold nominal values \"first\", \"second\", \"third\" \u003cbr\u003e\n * FastVector my_nominal_values = new FastVector(3); \u003cbr\u003e\n * my_nominal_values.addElement(\"first\"); \u003cbr\u003e\n * my_nominal_values.addElement(\"second\"); \u003cbr\u003e\n * my_nominal_values.addElement(\"third\"); \u003cbr\u003e\u003cbr\u003e\n *\n * // Create nominal attribute \"position\" \u003cbr\u003e\n * Attribute position = new Attribute(\"position\", my_nominal_values);\u003cbr\u003e\n *\n * ... \u003cbr\u003e\n * \u003c/code\u003e\u003cp\u003e\n *\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\n * @version $Revision: 1.32.2.3 $\n */\npublic class Attribute implements Copyable, Serializable {\n\n  /** Constant set for numeric attributes. */\n  public static final int NUMERIC = 0;\n\n  /** Constant set for nominal attributes. */\n  public static final int NOMINAL = 1;\n\n  /** Constant set for attributes with string values. */\n  public static final int STRING = 2;\n\n  /** Constant set for attributes with date values. */\n  public static final int DATE = 3;\n\n  /** Constant set for symbolic attributes. */\n  public static final int ORDERING_SYMBOLIC = 0;\n\n  /** Constant set for ordered attributes. */\n  public static final int ORDERING_ORDERED  = 1;\n\n  /** Constant set for modulo-ordered attributes. */\n  public static final int ORDERING_MODULO   = 2;\n\n  /** The keyword used to denote the start of an arff attribute declaration */\n  static String ARFF_ATTRIBUTE = \"@attribute\";\n\n  /** A keyword used to denote a numeric attribute */\n  static String ARFF_ATTRIBUTE_INTEGER = \"integer\";\n\n  /** A keyword used to denote a numeric attribute */\n  static String ARFF_ATTRIBUTE_REAL = \"real\";\n\n  /** A keyword used to denote a numeric attribute */\n  static String ARFF_ATTRIBUTE_NUMERIC = \"numeric\";\n\n  /** The keyword used to denote a string attribute */\n  static String ARFF_ATTRIBUTE_STRING = \"string\";\n\n  /** The keyword used to denote a date attribute */\n  static String ARFF_ATTRIBUTE_DATE = \"date\";\n\n  /** Strings longer than this will be stored compressed. */\n  private static final int STRING_COMPRESS_THRESHOLD = 200;\n\n  /** The attribute's name. */\n  private /*@ spec_public non_null @*/ String m_Name;\n\n  /** The attribute's type. */\n  private /*@ spec_public @*/ int m_Type;\n  /*@ invariant m_Type == NUMERIC || \n                m_Type == DATE || \n                m_Type == STRING || \n                m_Type == NOMINAL;\n  */\n\n  /** The attribute's values (if nominal or string). */\n  private /*@ spec_public @*/ FastVector m_Values;\n\n  /** Mapping of values to indices (if nominal or string). */\n  private Hashtable m_Hashtable;\n\n  /** Date format specification for date attributes */\n  private SimpleDateFormat m_DateFormat;\n\n  /** The attribute's index. */\n  private /*@ spec_public @*/ int m_Index;\n\n  /** The attribute's metadata. */\n  private ProtectedProperties m_Metadata;\n\n  /** The attribute's ordering. */\n  private int m_Ordering;\n\n  /** Whether the attribute is regular. */\n  private boolean m_IsRegular;\n\n  /** Whether the attribute is averagable. */\n  private boolean m_IsAveragable;\n\n  /** Whether the attribute has a zeropoint. */\n  private boolean m_HasZeropoint;\n\n  /** The attribute's weight. */\n  private double m_Weight;\n\n  /** The attribute's lower numeric bound. */\n  private double m_LowerBound;\n\n  /** Whether the lower bound is open. */\n  private boolean m_LowerBoundIsOpen;\n\n  /** The attribute's upper numeric bound. */\n  private double m_UpperBound;\n\n  /** Whether the upper bound is open */\n  private boolean m_UpperBoundIsOpen;\n\n  /**\n   * Constructor for a numeric attribute.\n   *\n   * @param attributeName the name for the attribute\n   */\n  //@ requires attributeName != null;\n  //@ ensures  m_Name == attributeName;\n  public Attribute(String attributeName) {\n\n    this(attributeName, new ProtectedProperties(new Properties()));\n  }\n\n  /**\n   * Constructor for a numeric attribute, where metadata is supplied.\n   *\n   * @param attributeName the name for the attribute\n   * @param metadata the attribute's properties\n   */\n  //@ requires attributeName != null;\n  //@ requires metadata != null;\n  //@ ensures  m_Name == attributeName;\n  public Attribute(String attributeName, ProtectedProperties metadata) {\n\n    m_Name = attributeName;\n    m_Index = -1;\n    m_Values = null;\n    m_Hashtable = null;\n    m_Type = NUMERIC;\n    setMetadata(metadata);\n  }\n\n  /**\n   * Constructor for a date attribute.\n   *\n   * @param attributeName the name for the attribute\n   * @param dateFormat a string suitable for use with\n   * SimpleDateFormatter for parsing dates.\n   */\n  //@ requires attributeName != null;\n  //@ requires dateFormat != null;\n  //@ ensures  m_Name == attributeName;\n  public Attribute(String attributeName, String dateFormat) {\n\n    this(attributeName, dateFormat,\n\t new ProtectedProperties(new Properties()));\n  }\n\n  /**\n   * Constructor for a date attribute, where metadata is supplied.\n   *\n   * @param attributeName the name for the attribute\n   * @param dateFormat a string suitable for use with\n   * SimpleDateFormatter for parsing dates.\n   * @param metadata the attribute's properties\n   */\n  //@ requires attributeName != null;\n  //@ requires dateFormat != null;\n  //@ requires metadata != null;\n  //@ ensures  m_Name == attributeName;\n  public Attribute(String attributeName, String dateFormat,\n\t\t   ProtectedProperties metadata) {\n\n    m_Name = attributeName;\n    m_Index = -1;\n    m_Values = null;\n    m_Hashtable = null;\n    m_Type = DATE;\n    if (dateFormat != null) {\n      m_DateFormat = new SimpleDateFormat(dateFormat);\n    } else {\n      m_DateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n    }\n    m_DateFormat.setLenient(false);\n    setMetadata(metadata);\n  }\n\n  /**\n   * Constructor for nominal attributes and string attributes.\n   * If a null vector of attribute values is passed to the method,\n   * the attribute is assumed to be a string.\n   *\n   * @param attributeName the name for the attribute\n   * @param attributeValues a vector of strings denoting the \n   * attribute values. Null if the attribute is a string attribute.\n   */\n  //@ requires attributeName != null;\n  //@ ensures  m_Name == attributeName;\n  public Attribute(String attributeName, \n\t\t   FastVector attributeValues) {\n\n    this(attributeName, attributeValues,\n\t new ProtectedProperties(new Properties()));\n  }\n\n  /**\n   * Constructor for nominal attributes and string attributes, where\n   * metadata is supplied. If a null vector of attribute values is passed\n   * to the method, the attribute is assumed to be a string.\n   *\n   * @param attributeName the name for the attribute\n   * @param attributeValues a vector of strings denoting the \n   * attribute values. Null if the attribute is a string attribute.\n   * @param metadata the attribute's properties\n   */\n  //@ requires attributeName != null;\n  //@ requires metadata != null;\n  /*@ ensures  m_Name == attributeName;\n      ensures  m_Index == -1;\n      ensures  attributeValues == null \u0026\u0026 m_Type == STRING\n            || attributeValues != null \u0026\u0026 m_Type == NOMINAL \n                  \u0026\u0026 m_Values.size() == attributeValues.size();\n      signals (IllegalArgumentException ex) \n                 (* if duplicate strings in attributeValues *);\n  */\n  public Attribute(String attributeName, \n\t\t   FastVector attributeValues,\n\t\t   ProtectedProperties metadata) {\n\n    m_Name = attributeName;\n    m_Index = -1;\n    if (attributeValues == null) {\n      m_Values = new FastVector();\n      m_Hashtable = new Hashtable();\n      m_Type = STRING;\n    } else {\n      m_Values = new FastVector(attributeValues.size());\n      m_Hashtable = new Hashtable(attributeValues.size());\n      for (int i = 0; i \u003c attributeValues.size(); i++) {\n\tObject store = attributeValues.elementAt(i);\n\tif (((String)store).length() \u003e STRING_COMPRESS_THRESHOLD) {\n\t  try {\n\t    store = new SerializedObject(attributeValues.elementAt(i), true);\n\t  } catch (Exception ex) {\n\t    System.err.println(\"Couldn't compress nominal attribute value -\"\n\t\t\t       + \" storing uncompressed.\");\n\t  }\n\t}\n\tif (m_Hashtable.containsKey(store)) {\n\t  throw new IllegalArgumentException(\"A nominal attribute (\" +\n\t\t\t\t\t     attributeName + \") cannot\"\n\t\t\t\t\t     + \" have duplicate labels (\" + store + \").\");\n\t}\n\tm_Values.addElement(store);\n\tm_Hashtable.put(store, new Integer(i));\n      }\n      m_Type = NOMINAL;\n    }\n    setMetadata(metadata);\n  }\n\n  /**\n   * Produces a shallow copy of this attribute.\n   *\n   * @return a copy of this attribute with the same index\n   */\n  //@ also ensures \\result instanceof Attribute;\n  public /*@ pure non_null @*/ Object copy() {\n\n    Attribute copy = new Attribute(m_Name);\n\n    copy.m_Index = m_Index;\n    copy.m_Type = m_Type;\n    copy.m_Values = m_Values;\n    copy.m_Hashtable = m_Hashtable;\n    copy.m_DateFormat = m_DateFormat;\n    copy.setMetadata(m_Metadata);\n \n    return copy;\n  }\n\n  /**\n   * Returns an enumeration of all the attribute's values if\n   * the attribute is nominal or a string, null otherwise. \n   *\n   * @return enumeration of all the attribute's values\n   */\n  public final /*@ pure @*/ Enumeration enumerateValues() {\n\n    if (isNominal() || isString()) {\n      final Enumeration ee = m_Values.elements();\n      return new Enumeration () {\n          public boolean hasMoreElements() {\n            return ee.hasMoreElements();\n          }\n          public Object nextElement() {\n            Object oo = ee.nextElement();\n            if (oo instanceof SerializedObject) {\n              return ((SerializedObject)oo).getObject();\n            } else {\n              return oo;\n            }\n          }\n        };\n    }\n    return null;\n  }\n\n  /**\n   * Tests if given attribute is equal to this attribute.\n   *\n   * @param other the Object to be compared to this attribute\n   * @return true if the given attribute is equal to this attribute\n   */\n  public final /*@ pure @*/ boolean equals(Object other) {\n\n    if ((other == null) || !(other.getClass().equals(this.getClass()))) {\n      return false;\n    }\n    Attribute att = (Attribute) other;\n    if (!m_Name.equals(att.m_Name)) {\n      return false;\n    }\n    if (isNominal() \u0026\u0026 att.isNominal()) {\n      if (m_Values.size() != att.m_Values.size()) {\n        return false;\n      }\n      for (int i = 0; i \u003c m_Values.size(); i++) {\n        if (!m_Values.elementAt(i).equals(att.m_Values.elementAt(i))) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n      return (type() == att.type());\n    }\n  }\n\n  /**\n   * Returns the index of this attribute.\n   *\n   * @return the index of this attribute\n   */\n  //@ ensures \\result == m_Index;\n  public final /*@ pure @*/ int index() {\n\n    return m_Index;\n  }\n\n  /**\n   * Returns the index of a given attribute value. (The index of\n   * the first occurence of this value.)\n   *\n   * @param value the value for which the index is to be returned\n   * @return the index of the given attribute value if attribute\n   * is nominal or a string, -1 if it is numeric or the value \n   * can't be found\n   */\n  public final int indexOfValue(String value) {\n\n    if (!isNominal() \u0026\u0026 !isString())\n      return -1;\n    Object store = value;\n    if (value.length() \u003e STRING_COMPRESS_THRESHOLD) {\n      try {\n        store = new SerializedObject(value, true);\n      } catch (Exception ex) {\n        System.err.println(\"Couldn't compress string attribute value -\"\n                           + \" searching uncompressed.\");\n      }\n    }\n    Integer val = (Integer)m_Hashtable.get(store);\n    if (val == null) return -1;\n    else return val.intValue();\n  }\n\n  /**\n   * Test if the attribute is nominal.\n   *\n   * @return true if the attribute is nominal\n   */\n  //@ ensures \\result \u003c==\u003e (m_Type == NOMINAL);\n  public final /*@ pure @*/ boolean isNominal() {\n\n    return (m_Type == NOMINAL);\n  }\n\n  /**\n   * Tests if the attribute is numeric.\n   *\n   * @return true if the attribute is numeric\n   */\n  //@ ensures \\result \u003c==\u003e ((m_Type == NUMERIC) || (m_Type == DATE));\n  public final /*@ pure @*/ boolean isNumeric() {\n\n    return ((m_Type == NUMERIC) || (m_Type == DATE));\n  }\n\n  /**\n   * Tests if the attribute is a string.\n   *\n   * @return true if the attribute is a string\n   */\n  //@ ensures \\result \u003c==\u003e (m_Type == STRING);\n  public final /*@ pure @*/ boolean isString() {\n\n    return (m_Type == STRING);\n  }\n\n  /**\n   * Tests if the attribute is a date type.\n   *\n   * @return true if the attribute is a date type\n   */\n  //@ ensures \\result \u003c==\u003e (m_Type == DATE);\n  public final /*@ pure @*/ boolean isDate() {\n\n    return (m_Type == DATE);\n  }\n\n  /**\n   * Returns the attribute's name.\n   *\n   * @return the attribute's name as a string\n   */\n  //@ ensures \\result == m_Name;\n  public final /*@ pure @*/ String name() {\n\n    return m_Name;\n  }\n  \n  /**\n   * Returns the number of attribute values. Returns 0 for numeric attributes.\n   *\n   * @return the number of attribute values\n   */\n  public final /*@ pure @*/ int numValues() {\n\n    if (!isNominal() \u0026\u0026 !isString()) {\n      return 0;\n    } else {\n      return m_Values.size();\n    }\n  }\n\n  /**\n   * Returns a description of this attribute in ARFF format. Quotes\n   * strings if they contain whitespace characters, or if they\n   * are a question mark.\n   *\n   * @return a description of this attribute as a string\n   */\n  public final String toString() {\n    \n    StringBuffer text = new StringBuffer();\n    \n    text.append(ARFF_ATTRIBUTE).append(\" \").append(Utils.quote(m_Name)).append(\" \");\n    switch (m_Type) {\n    case NOMINAL:\n      text.append('{');\n      Enumeration enu = enumerateValues();\n      while (enu.hasMoreElements()) {\n\ttext.append(Utils.quote((String) enu.nextElement()));\n\tif (enu.hasMoreElements())\n\t  text.append(',');\n      }\n      text.append('}');\n      break;\n    case NUMERIC:\n      text.append(ARFF_ATTRIBUTE_NUMERIC);\n      break;\n    case STRING:\n      text.append(ARFF_ATTRIBUTE_STRING);\n      break;\n    case DATE:\n      text.append(ARFF_ATTRIBUTE_DATE).append(\" \").append(Utils.quote(m_DateFormat.toPattern()));\n      break;\n    default:\n      text.append(\"UNKNOWN\");\n      break;\n    }\n    return text.toString();\n  }\n\n  /**\n   * Returns the attribute's type as an integer.\n   *\n   * @return the attribute's type.\n   */\n  //@ ensures \\result == m_Type;\n  public final /*@ pure @*/ int type() {\n\n    return m_Type;\n  }\n\n  /**\n   * Returns a value of a nominal or string attribute. \n   * Returns an empty string if the attribute is neither\n   * nominal nor a string attribute.\n   *\n   * @param valIndex the value's index\n   * @return the attribute's value as a string\n   */\n  public final /*@ non_null pure @*/ String value(int valIndex) {\n    \n    if (!isNominal() \u0026\u0026 !isString()) {\n      return \"\";\n    } else {\n      Object val = m_Values.elementAt(valIndex);\n      \n      // If we're storing strings compressed, uncompress it.\n      if (val instanceof SerializedObject) {\n        val = ((SerializedObject)val).getObject();\n      }\n      return (String) val;\n    }\n  }\n\n  /**\n   * Constructor for a numeric attribute with a particular index.\n   *\n   * @param attributeName the name for the attribute\n   * @param index the attribute's index\n   */\n  //@ requires attributeName != null;\n  //@ requires index \u003e= 0;\n  //@ ensures  m_Name == attributeName;\n  //@ ensures  m_Index == index;\n  Attribute(String attributeName, int index) {\n\n    this(attributeName);\n    m_Index = index;\n  }\n\n  /**\n   * Constructor for date attributes with a particular index.\n   *\n   * @param attributeName the name for the attribute\n   * @param dateFormat a string suitable for use with\n   * SimpleDateFormatter for parsing dates.  Null for a default format\n   * string.\n   * @param index the attribute's index\n   */\n  //@ requires attributeName != null;\n  //@ requires index \u003e= 0;\n  //@ ensures  m_Name == attributeName;\n  //@ ensures  m_Index == index;\n  Attribute(String attributeName, String dateFormat, \n\t    int index) {\n\n    this(attributeName, dateFormat);\n    m_Index = index;\n  }\n\n  /**\n   * Constructor for nominal attributes and string attributes with\n   * a particular index.\n   * If a null vector of attribute values is passed to the method,\n   * the attribute is assumed to be a string.\n   *\n   * @param attributeName the name for the attribute\n   * @param attributeValues a vector of strings denoting the attribute values.\n   * Null if the attribute is a string attribute.\n   * @param index the attribute's index\n   */\n  //@ requires attributeName != null;\n  //@ requires index \u003e= 0;\n  //@ ensures  m_Name == attributeName;\n  //@ ensures  m_Index == index;\n  Attribute(String attributeName, FastVector attributeValues, \n\t    int index) {\n\n    this(attributeName, attributeValues);\n    m_Index = index;\n  }\n\n  /**\n   * Adds a string value to the list of valid strings for attributes\n   * of type STRING and returns the index of the string.\n   *\n   * @param value The string value to add\n   * @return the index assigned to the string, or -1 if the attribute is not\n   * of type Attribute.STRING \n   */\n  /*@ requires value != null;\n      ensures  isString() \u0026\u0026 0 \u003c= \\result \u0026\u0026 \\result \u003c m_Values.size() ||\n             ! isString() \u0026\u0026 \\result == -1;\n  */\n  public int addStringValue(String value) {\n\n    if (!isString()) {\n      return -1;\n    }\n    Object store = value;\n\n    if (value.length() \u003e STRING_COMPRESS_THRESHOLD) {\n      try {\n        store = new SerializedObject(value, true);\n      } catch (Exception ex) {\n        System.err.println(\"Couldn't compress string attribute value -\"\n                           + \" storing uncompressed.\");\n      }\n    }\n    Integer index = (Integer)m_Hashtable.get(store);\n    if (index != null) {\n      return index.intValue();\n    } else {\n      int intIndex = m_Values.size();\n      m_Values.addElement(store);\n      m_Hashtable.put(store, new Integer(intIndex));\n      return intIndex;\n    }\n  }\n\n  /**\n   * Adds a string value to the list of valid strings for attributes\n   * of type STRING and returns the index of the string. This method is\n   * more efficient than addStringValue(String) for long strings.\n   *\n   * @param src The Attribute containing the string value to add.\n   * @param int index the index of the string value in the source attribute.\n   * @return the index assigned to the string, or -1 if the attribute is not\n   * of type Attribute.STRING \n   */\n  /*@ requires src != null;\n      requires 0 \u003c= index \u0026\u0026 index \u003c src.m_Values.size();\n      ensures  isString() \u0026\u0026 0 \u003c= \\result \u0026\u0026 \\result \u003c m_Values.size() ||\n             ! isString() \u0026\u0026 \\result == -1;\n  */\n  public int addStringValue(Attribute src, int index) {\n\n    if (!isString()) {\n      return -1;\n    }\n    Object store = src.m_Values.elementAt(index);\n    Integer oldIndex = (Integer)m_Hashtable.get(store);\n    if (oldIndex != null) {\n      return oldIndex.intValue();\n    } else {\n      int intIndex = m_Values.size();\n      m_Values.addElement(store);\n      m_Hashtable.put(store, new Integer(intIndex));\n      return intIndex;\n    }\n  }\n\n  /**\n   * Adds an attribute value. Creates a fresh list of attribute\n   * values before adding it.\n   *\n   * @param value the attribute value\n   */\n  final void addValue(String value) {\n\n    m_Values = (FastVector)m_Values.copy();\n    m_Hashtable = (Hashtable)m_Hashtable.clone();\n    forceAddValue(value);\n  }\n\n  /**\n   * Produces a shallow copy of this attribute with a new name.\n   *\n   * @param newName the name of the new attribute\n   * @return a copy of this attribute with the same index\n   */\n  //@ requires newName != null;\n  //@ ensures \\result.m_Name  == newName;\n  //@ ensures \\result.m_Index == m_Index;\n  //@ ensures \\result.m_Type  == m_Type;\n  final /*@ pure non_null @*/ Attribute copy(String newName) {\n\n    Attribute copy = new Attribute(newName);\n\n    copy.m_Index = m_Index;\n    copy.m_DateFormat = m_DateFormat;\n    copy.m_Type = m_Type;\n    copy.m_Values = m_Values;\n    copy.m_Hashtable = m_Hashtable;\n    copy.setMetadata(m_Metadata);\n \n    return copy;\n  }\n\n  /**\n   * Removes a value of a nominal or string attribute. Creates a \n   * fresh list of attribute values before removing it.\n   *\n   * @param index the value's index\n   * @exception IllegalArgumentException if the attribute is not nominal\n   */\n  //@ requires isNominal() || isString();\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Values.size();\n  final void delete(int index) {\n    \n    if (!isNominal() \u0026\u0026 !isString()) \n      throw new IllegalArgumentException(\"Can only remove value of\" +\n                                         \"nominal or string attribute!\");\n    else {\n      m_Values = (FastVector)m_Values.copy();\n      m_Values.removeElementAt(index);\n      Hashtable hash = new Hashtable(m_Hashtable.size());\n      Enumeration enu = m_Hashtable.keys();\n      while (enu.hasMoreElements()) {\n\tObject string = enu.nextElement();\n\tInteger valIndexObject = (Integer)m_Hashtable.get(string);\n\tint valIndex = valIndexObject.intValue();\n\tif (valIndex \u003e index) {\n\t  hash.put(string, new Integer(valIndex - 1));\n\t} else if (valIndex \u003c index) {\n\t  hash.put(string, valIndexObject);\n\t}\n      }\n      m_Hashtable = hash;\n    }\n  }\n\n  /**\n   * Adds an attribute value.\n   *\n   * @param value the attribute value\n   */\n  //@ requires value != null;\n  //@ ensures  m_Values.size() == \\old(m_Values.size()) + 1;\n  final void forceAddValue(String value) {\n\n    Object store = value;\n    if (value.length() \u003e STRING_COMPRESS_THRESHOLD) {\n      try {\n        store = new SerializedObject(value, true);\n      } catch (Exception ex) {\n        System.err.println(\"Couldn't compress string attribute value -\"\n                           + \" storing uncompressed.\");\n      }\n    }\n    m_Values.addElement(store);\n    m_Hashtable.put(store, new Integer(m_Values.size() - 1));\n  }\n\n  /**\n   * Sets the index of this attribute.\n   *\n   * @param the index of this attribute\n   */\n  //@ requires 0 \u003c= index;\n  //@ assignable m_Index;\n  //@ ensures m_Index == index;\n  final void setIndex(int index) {\n\n    m_Index = index;\n  }\n\n  /**\n   * Sets a value of a nominal attribute or string attribute.\n   * Creates a fresh list of attribute values before it is set.\n   *\n   * @param index the value's index\n   * @param string the value\n   * @exception IllegalArgumentException if the attribute is not nominal or \n   * string.\n   */\n  //@ requires string != null;\n  //@ requires isNominal() || isString();\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Values.size();\n  final void setValue(int index, String string) {\n    \n    switch (m_Type) {\n    case NOMINAL:\n    case STRING:\n      m_Values = (FastVector)m_Values.copy();\n      m_Hashtable = (Hashtable)m_Hashtable.clone();\n      Object store = string;\n      if (string.length() \u003e STRING_COMPRESS_THRESHOLD) {\n        try {\n          store = new SerializedObject(string, true);\n        } catch (Exception ex) {\n          System.err.println(\"Couldn't compress string attribute value -\"\n                             + \" storing uncompressed.\");\n        }\n      }\n      m_Hashtable.remove(m_Values.elementAt(index));\n      m_Values.setElementAt(store, index);\n      m_Hashtable.put(store, new Integer(index));\n      break;\n    default:\n      throw new IllegalArgumentException(\"Can only set values for nominal\"\n                                         + \" or string attributes!\");\n    }\n  }\n\n  //@ requires isDate();\n  public /*@pure@*/ String formatDate(double date) {\n    switch (m_Type) {\n    case DATE:\n      return m_DateFormat.format(new Date((long)date));\n    default:\n      throw new IllegalArgumentException(\"Can only format date values for date\"\n                                         + \" attributes!\");\n    }\n  }\n\n  //@ requires isDate();\n  //@ requires string != null;\n  public double parseDate(String string) throws ParseException {\n    switch (m_Type) {\n    case DATE:\n      long time = m_DateFormat.parse(string).getTime();\n      // TODO put in a safety check here if we can't store the value in a double.\n      return (double)time;\n    default:\n      throw new IllegalArgumentException(\"Can only parse date values for date\"\n                                         + \" attributes!\");\n    }\n  }\n\n  /**\n   * Returns the properties supplied for this attribute.\n   *\n   * @return metadata for this attribute\n   */  \n  public final /*@ pure @*/ ProtectedProperties getMetadata() {\n\n    return m_Metadata;\n  }\n\n  /**\n   * Returns the ordering of the attribute. One of the following:\n   * \n   * ORDERING_SYMBOLIC - attribute values should be treated as symbols.\n   * ORDERING_ORDERED  - attribute values have a global ordering.\n   * ORDERING_MODULO   - attribute values have an ordering which wraps.\n   *\n   * @return the ordering type of the attribute\n   */\n  public final /*@ pure @*/ int ordering() {\n\n    return m_Ordering;\n  }\n\n  /**\n   * Returns whether the attribute values are equally spaced.\n   *\n   * @return whether the attribute is regular or not\n   */\n  public final /*@ pure @*/ boolean isRegular() {\n\n    return m_IsRegular;\n  }\n\n  /**\n   * Returns whether the attribute can be averaged meaningfully.\n   *\n   * @return whether the attribute can be averaged or not\n   */\n  public final /*@ pure @*/ boolean isAveragable() {\n\n    return m_IsAveragable;\n  }\n\n  /**\n   * Returns whether the attribute has a zeropoint and may be\n   * added meaningfully.\n   *\n   * @return whether the attribute has a zeropoint or not\n   */\n  public final /*@ pure @*/ boolean hasZeropoint() {\n\n    return m_HasZeropoint;\n  }\n\n  /**\n   * Returns the attribute's weight.\n   *\n   * @return the attribute's weight as a double\n   */\n  public final /*@ pure @*/ double weight() {\n\n    return m_Weight;\n  }\n\n  /**\n   * Returns the lower bound of a numeric attribute.\n   *\n   * @return the lower bound of the specified numeric range\n   */\n  public final /*@ pure @*/ double getLowerNumericBound() {\n\n    return m_LowerBound;\n  }\n\n  /**\n   * Returns whether the lower numeric bound of the attribute is open.\n   *\n   * @return whether the lower numeric bound is open or not (closed)\n   */\n  public final /*@ pure @*/ boolean lowerNumericBoundIsOpen() {\n\n    return m_LowerBoundIsOpen;\n  }\n\n  /**\n   * Returns the upper bound of a numeric attribute.\n   *\n   * @return the upper bound of the specified numeric range\n   */\n  public final /*@ pure @*/ double getUpperNumericBound() {\n\n    return m_UpperBound;\n  }\n\n  /**\n   * Returns whether the upper numeric bound of the attribute is open.\n   *\n   * @return whether the upper numeric bound is open or not (closed)\n   */\n  public final /*@ pure @*/ boolean upperNumericBoundIsOpen() {\n\n    return m_UpperBoundIsOpen;\n  }\n\n  /**\n   * Determines whether a value lies within the bounds of the attribute.\n   *\n   * @return whether the value is in range\n   */\n  public final /*@ pure @*/ boolean isInRange(double value) {\n\n    // dates and missing values are a special case \n    if (m_Type == DATE || value == Instance.missingValue()) return true;\n    if (m_Type != NUMERIC) {\n      // do label range check\n      int intVal = (int) value;\n      if (intVal \u003c 0 || intVal \u003e= m_Hashtable.size()) return false;\n    } else {\n      // do numeric bounds check\n      if (m_LowerBoundIsOpen) {\n\tif (value \u003c= m_LowerBound) return false;\n      } else {\n\tif (value \u003c m_LowerBound) return false;\n      }\n      if (m_UpperBoundIsOpen) {\n\tif (value \u003e= m_UpperBound) return false;\n      } else {\n\tif (value \u003e m_UpperBound) return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Sets the metadata for the attribute. Processes the strings stored in the\n   * metadata of the attribute so that the properties can be set up for the\n   * easy-access metadata methods. Any strings sought that are omitted will\n   * cause default values to be set.\n   * \n   * The following properties are recognised:\n   * ordering, averageable, zeropoint, regular, weight, and range.\n   *\n   * All other properties can be queried and handled appropriately by classes\n   * calling the getMetadata() method.\n   *\n   * @param metadata the metadata\n   * @exception IllegalArgumentException if the properties are not consistent\n   */\n  //@ requires metadata != null;\n  private void setMetadata(ProtectedProperties metadata) {\n    \n    m_Metadata = metadata;\n\n    if (m_Type == DATE) {\n      m_Ordering = ORDERING_ORDERED;\n      m_IsRegular = true;\n      m_IsAveragable = false;\n      m_HasZeropoint = false;\n    } else {\n\n      // get ordering\n      String orderString = m_Metadata.getProperty(\"ordering\",\"\");\n      \n      // numeric ordered attributes are averagable and zeropoint by default\n      String def;\n      if (m_Type == NUMERIC\n\t  \u0026\u0026 orderString.compareTo(\"modulo\") != 0\n\t  \u0026\u0026 orderString.compareTo(\"symbolic\") != 0)\n\tdef = \"true\";\n      else def = \"false\";\n      \n      // determine boolean states\n      m_IsAveragable =\n\t(m_Metadata.getProperty(\"averageable\",def).compareTo(\"true\") == 0);\n      m_HasZeropoint =\n\t(m_Metadata.getProperty(\"zeropoint\",def).compareTo(\"true\") == 0);\n      // averagable or zeropoint implies regular\n      if (m_IsAveragable || m_HasZeropoint) def = \"true\";\n      m_IsRegular =\n\t(m_Metadata.getProperty(\"regular\",def).compareTo(\"true\") == 0);\n      \n      // determine ordering\n      if (orderString.compareTo(\"symbolic\") == 0)\n\tm_Ordering = ORDERING_SYMBOLIC;\n      else if (orderString.compareTo(\"ordered\") == 0)\n\tm_Ordering = ORDERING_ORDERED;\n      else if (orderString.compareTo(\"modulo\") == 0)\n\tm_Ordering = ORDERING_MODULO;\n      else {\n\tif (m_Type == NUMERIC || m_IsAveragable || m_HasZeropoint)\n\t  m_Ordering = ORDERING_ORDERED;\n\telse m_Ordering = ORDERING_SYMBOLIC;\n      }\n    }\n\n    // consistency checks\n    if (m_IsAveragable \u0026\u0026 !m_IsRegular)\n      throw new IllegalArgumentException(\"An averagable attribute must be\"\n\t\t\t\t\t + \" regular\");\n    if (m_HasZeropoint \u0026\u0026 !m_IsRegular)\n      throw new IllegalArgumentException(\"A zeropoint attribute must be\"\n\t\t\t\t\t + \" regular\");\n    if (m_IsRegular \u0026\u0026 m_Ordering == ORDERING_SYMBOLIC)\n      throw new IllegalArgumentException(\"A symbolic attribute cannot be\"\n\t\t\t\t\t + \" regular\");\n    if (m_IsAveragable \u0026\u0026 m_Ordering != ORDERING_ORDERED)\n      throw new IllegalArgumentException(\"An averagable attribute must be\"\n\t\t\t\t\t + \" ordered\");\n    if (m_HasZeropoint \u0026\u0026 m_Ordering != ORDERING_ORDERED)\n      throw new IllegalArgumentException(\"A zeropoint attribute must be\"\n\t\t\t\t\t + \" ordered\");\n\n    // determine weight\n    m_Weight = 1.0;\n    String weightString = m_Metadata.getProperty(\"weight\");\n    if (weightString != null) {\n      try{\n\tm_Weight = Double.valueOf(weightString).doubleValue();\n      } catch (NumberFormatException e) {\n\t// Check if value is really a number\n\tthrow new IllegalArgumentException(\"Not a valid attribute weight: '\" \n\t\t\t\t\t   + weightString + \"'\");\n      }\n    }\n\n    // determine numeric range\n    if (m_Type == NUMERIC) setNumericRange(m_Metadata.getProperty(\"range\"));\n  }\n\n  /**\n   * Sets the numeric range based on a string. If the string is null the range\n   * will default to [-inf,+inf]. A square brace represents a closed interval, a\n   * curved brace represents an open interval, and 'inf' represents infinity.\n   * Examples of valid range strings: \"[-inf,20)\",\"(-13.5,-5.2)\",\"(5,inf]\"\n   *\n   * @param rangeString the string to parse as the attribute's numeric range\n   * @exception IllegalArgumentException if the range is not valid\n   */\n  //@ requires rangeString != null;\n  private void setNumericRange(String rangeString)\n  {\n    // set defaults\n    m_LowerBound = Double.NEGATIVE_INFINITY;\n    m_LowerBoundIsOpen = false;\n    m_UpperBound = Double.POSITIVE_INFINITY;\n    m_UpperBoundIsOpen = false;\n\n    if (rangeString == null) return;\n\n    // set up a tokenzier to parse the string\n    StreamTokenizer tokenizer =\n      new StreamTokenizer(new StringReader(rangeString));\n    tokenizer.resetSyntax();         \n    tokenizer.whitespaceChars(0, ' ');    \n    tokenizer.wordChars(' '+1,'\\u00FF');\n    tokenizer.ordinaryChar('[');\n    tokenizer.ordinaryChar('(');\n    tokenizer.ordinaryChar(',');\n    tokenizer.ordinaryChar(']');\n    tokenizer.ordinaryChar(')');\n\n    try {\n\n      // get opening brace\n      tokenizer.nextToken();\n    \n      if (tokenizer.ttype == '[') m_LowerBoundIsOpen = false;\n      else if (tokenizer.ttype == '(') m_LowerBoundIsOpen = true;\n      else throw new IllegalArgumentException(\"Expected opening brace on range,\"\n\t\t\t\t\t      + \" found: \"\n\t\t\t\t\t      + tokenizer.toString());\n\n      // get lower bound\n      tokenizer.nextToken();\n      if (tokenizer.ttype != tokenizer.TT_WORD)\n\tthrow new IllegalArgumentException(\"Expected lower bound in range,\"\n\t\t\t\t\t   + \" found: \"\n\t\t\t\t\t   + tokenizer.toString());\n      if (tokenizer.sval.compareToIgnoreCase(\"-inf\") == 0)\n\tm_LowerBound = Double.NEGATIVE_INFINITY;\n      else if (tokenizer.sval.compareToIgnoreCase(\"+inf\") == 0)\n\tm_LowerBound = Double.POSITIVE_INFINITY;\n      else if (tokenizer.sval.compareToIgnoreCase(\"inf\") == 0)\n\tm_LowerBound = Double.NEGATIVE_INFINITY;\n      else try {\n\tm_LowerBound = Double.valueOf(tokenizer.sval).doubleValue();\n      } catch (NumberFormatException e) {\n\tthrow new IllegalArgumentException(\"Expected lower bound in range,\"\n\t\t\t\t\t   + \" found: '\" + tokenizer.sval + \"'\");\n      }\n\n      // get separating comma\n      if (tokenizer.nextToken() != ',')\n\tthrow new IllegalArgumentException(\"Expected comma in range,\"\n\t\t\t\t\t   + \" found: \"\n\t\t\t\t\t   + tokenizer.toString());\n\n      // get upper bound\n      tokenizer.nextToken();\n      if (tokenizer.ttype != tokenizer.TT_WORD)\n\tthrow new IllegalArgumentException(\"Expected upper bound in range,\"\n\t\t\t\t\t   + \" found: \"\n\t\t\t\t\t   + tokenizer.toString());\n      if (tokenizer.sval.compareToIgnoreCase(\"-inf\") == 0)\n\tm_UpperBound = Double.NEGATIVE_INFINITY;\n      else if (tokenizer.sval.compareToIgnoreCase(\"+inf\") == 0)\n\tm_UpperBound = Double.POSITIVE_INFINITY;\n      else if (tokenizer.sval.compareToIgnoreCase(\"inf\") == 0)\n\tm_UpperBound = Double.POSITIVE_INFINITY;\n      else try {\n\tm_UpperBound = Double.valueOf(tokenizer.sval).doubleValue();\n      } catch (NumberFormatException e) {\n\tthrow new IllegalArgumentException(\"Expected upper bound in range,\"\n\t\t\t\t\t   + \" found: '\" + tokenizer.sval + \"'\");\n      }\n\n      // get closing brace\n      tokenizer.nextToken();\n    \n      if (tokenizer.ttype == ']') m_UpperBoundIsOpen = false;\n      else if (tokenizer.ttype == ')') m_UpperBoundIsOpen = true;\n      else throw new IllegalArgumentException(\"Expected closing brace on range,\"\n\t\t\t\t\t      + \" found: \"\n\t\t\t\t\t      + tokenizer.toString());\n\n      // check for rubbish on end\n      if (tokenizer.nextToken() != tokenizer.TT_EOF)\n\tthrow new IllegalArgumentException(\"Expected end of range string,\"\n\t\t\t\t\t   + \" found: \"\n\t\t\t\t\t   + tokenizer.toString());\n\n    } catch (IOException e) {\n      throw new IllegalArgumentException(\"IOException reading attribute range\"\n\t\t\t\t\t + \" string: \" + e.getMessage());\n    }\n\n    if (m_UpperBound \u003c m_LowerBound)\n      throw new IllegalArgumentException(\"Upper bound (\" + m_UpperBound\n\t\t\t\t\t + \") on numeric range is\"\n\t\t\t\t\t + \" less than lower bound (\"\n\t\t\t\t\t + m_LowerBound + \")!\");\n  }\n\n  /**\n   * Simple main method for testing this class.\n   */\n  //@ requires ops != null;\n  //@ requires \\nonnullelements(ops);\n  public static void main(String[] ops) {\n\n    try {\n      \n      // Create numeric attributes \"length\" and \"weight\"\n      Attribute length = new Attribute(\"length\");\n      Attribute weight = new Attribute(\"weight\");\n\n      // Create date attribute \"date\"\n      Attribute date = new Attribute(\"date\", \"yyyy-MM-dd HH:mm:ss\");\n\n      System.out.println(date);\n      double dd = date.parseDate(\"2001-04-04 14:13:55\");\n      System.out.println(\"Test date = \" + dd);\n      System.out.println(date.formatDate(dd));\n\n      dd = new Date().getTime();\n      System.out.println(\"Date now = \" + dd);\n      System.out.println(date.formatDate(dd));\n      \n      // Create vector to hold nominal values \"first\", \"second\", \"third\" \n      FastVector my_nominal_values = new FastVector(3); \n      my_nominal_values.addElement(\"first\"); \n      my_nominal_values.addElement(\"second\"); \n      my_nominal_values.addElement(\"third\"); \n      \n      // Create nominal attribute \"position\" \n      Attribute position = new Attribute(\"position\", my_nominal_values);\n\n      // Print the name of \"position\"\n      System.out.println(\"Name of \\\"position\\\": \" + position.name());\n\n      // Print the values of \"position\"\n      Enumeration attValues = position.enumerateValues();\n      while (attValues.hasMoreElements()) {\n\tString string = (String)attValues.nextElement();\n\tSystem.out.println(\"Value of \\\"position\\\": \" + string);\n      }\n\n      // Shallow copy attribute \"position\"\n      Attribute copy = (Attribute) position.copy();\n\n      // Test if attributes are the same\n      System.out.println(\"Copy is the same as original: \" + copy.equals(position));\n\n      // Print index of attribute \"weight\" (should be unset: -1)\n      System.out.println(\"Index of attribute \\\"weight\\\" (should be -1): \" + \n\t\t\t weight.index());\n\n      // Print index of value \"first\" of attribute \"position\"\n      System.out.println(\"Index of value \\\"first\\\" of \\\"position\\\" (should be 0): \" +\n\t\t\t position.indexOfValue(\"first\"));\n\n      // Tests type of attribute \"position\"\n      System.out.println(\"\\\"position\\\" is numeric: \" + position.isNumeric());\n      System.out.println(\"\\\"position\\\" is nominal: \" + position.isNominal());\n      System.out.println(\"\\\"position\\\" is string: \" + position.isString());\n\n      // Prints name of attribute \"position\"\n      System.out.println(\"Name of \\\"position\\\": \" + position.name());\n    \n      // Prints number of values of attribute \"position\"\n      System.out.println(\"Number of values for \\\"position\\\": \" + position.numValues());\n\n      // Prints the values (againg)\n      for (int i = 0; i \u003c position.numValues(); i++) {\n\tSystem.out.println(\"Value \" + i + \": \" + position.value(i));\n      }\n\n      // Prints the attribute \"position\" in ARFF format\n      System.out.println(position);\n\n      // Checks type of attribute \"position\" using constants\n      switch (position.type()) {\n      case Attribute.NUMERIC:\n\tSystem.out.println(\"\\\"position\\\" is numeric\");\n\tbreak;\n      case Attribute.NOMINAL:\n\tSystem.out.println(\"\\\"position\\\" is nominal\");\n\tbreak;\n      case Attribute.STRING:\n\tSystem.out.println(\"\\\"position\\\" is string\");\n\tbreak;\n      case Attribute.DATE:\n\tSystem.out.println(\"\\\"position\\\" is date\");\n\tbreak;\n      default:\n\tSystem.out.println(\"\\\"position\\\" has unknown type\");\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n  \n",
        "name": "Attribute.java",
        "path": "subjectSystems/C,D/src/weka/core/Attribute.java",
        "url": "/github.com/LASER-UMASS/Themis/-/blob/subjectSystems/C,D/src/weka/core/Attribute.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 186,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 199,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 200,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires metadata != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 219,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 220,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires dateFormat != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 236,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 237,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires dateFormat != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 238,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires metadata != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 266,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 285,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 286,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires metadata != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 413,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Index;"
        },
        {
          "limitHit": false,
          "lineNumber": 451,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e (m_Type == NOMINAL);"
        },
        {
          "limitHit": false,
          "lineNumber": 462,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e ((m_Type == NUMERIC) || (m_Type == DATE));"
        },
        {
          "limitHit": false,
          "lineNumber": 473,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e (m_Type == STRING);"
        },
        {
          "limitHit": false,
          "lineNumber": 484,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e (m_Type == DATE);"
        },
        {
          "limitHit": false,
          "lineNumber": 495,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Name;"
        },
        {
          "limitHit": false,
          "lineNumber": 559,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Type;"
        },
        {
          "limitHit": false,
          "lineNumber": 594,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 595,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 613,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 614,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 635,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 636,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 735,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires newName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 736,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result.m_Name  == newName;"
        },
        {
          "limitHit": false,
          "lineNumber": 737,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result.m_Index == m_Index;"
        },
        {
          "limitHit": false,
          "lineNumber": 738,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result.m_Type  == m_Type;"
        },
        {
          "limitHit": false,
          "lineNumber": 760,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires isNominal() || isString();"
        },
        {
          "limitHit": false,
          "lineNumber": 761,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Values.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 791,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires value != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 813,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;"
        },
        {
          "limitHit": false,
          "lineNumber": 815,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Index == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 830,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires string != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 831,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires isNominal() || isString();"
        },
        {
          "limitHit": false,
          "lineNumber": 832,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Values.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 859,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires isDate();"
        },
        {
          "limitHit": false,
          "lineNumber": 870,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires isDate();"
        },
        {
          "limitHit": false,
          "lineNumber": 871,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires string != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1033,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires metadata != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1123,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires rangeString != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1231,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires ops != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1232,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires \\nonnullelements(ops);"
        },
        {
          "limitHit": false,
          "lineNumber": 187,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 201,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 221,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 239,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 267,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 596,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 597,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Index == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 615,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 616,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Index == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 637,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 638,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Index == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 792,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Values.size() == \\old(m_Values.size()) + 1;"
        }
      ],
      "repository": {
        "name": "github.com/LASER-UMASS/Themis",
        "url": "/github.com/LASER-UMASS/Themis"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a70f12a6a8f34cdd8b170b4dc59a78674c9e8950"
        },
        "content": "/*\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; either version 2 of the License, or\n *    (at your option) any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n/*\n *    FastVector.java\n *    Copyright (C) 1999 Eibe Frank\n *\n */\n\npackage weka.core;\n\nimport java.util.*;\nimport java.io.*;\n\n/**\n * Implements a fast vector class without synchronized\n * methods. Replaces java.util.Vector. (Synchronized methods tend to\n * be slow.)\n *\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\n * @version $Revision: 1.11 $ */\npublic class FastVector implements Copyable, Serializable {\n\n  /**\n   * Class for enumerating the vector's elements.\n   */\n  public class FastVectorEnumeration implements Enumeration {\n\n    /** The counter. */\n    private int m_Counter;\n    // These JML commands say how m_Counter implements Enumeration\n    //@ in moreElements;\n    //@ private represents moreElements = m_Counter \u003c m_Vector.size();\n    //@ private invariant 0 \u003c= m_Counter \u0026\u0026 m_Counter \u003c= m_Vector.size();\n\n    /** The vector. */\n    private /*@non_null@*/ FastVector m_Vector;\n\n    /** Special element. Skipped during enumeration. */\n    private int m_SpecialElement;\n    //@ private invariant -1 \u003c= m_SpecialElement;\n    //@ private invariant m_SpecialElement \u003c m_Vector.size();\n    //@ private invariant m_SpecialElement\u003e=0 ==\u003e m_Counter!=m_SpecialElement;\n\n    /**\n     * Constructs an enumeration.\n     *\n     * @param vector the vector which is to be enumerated\n     */\n    public FastVectorEnumeration(/*@non_null@*/FastVector vector) {\n\n      m_Counter = 0;\n      m_Vector = vector;\n      m_SpecialElement = -1;\n    }\n\n    /**\n     * Constructs an enumeration with a special element.\n     * The special element is skipped during the enumeration.\n     *\n     * @param vector the vector which is to be enumerated\n     * @param special the index of the special element\n     */\n    //@ requires 0 \u003c= special \u0026\u0026 special \u003c vector.size();\n    public FastVectorEnumeration(/*@non_null@*/FastVector vector, int special){\n\n      m_Vector = vector;\n      m_SpecialElement = special;\n      if (special == 0) {\n\tm_Counter = 1;\n      } else {\n\tm_Counter = 0;\n      }\n    }\n\n\n    /**\n     * Tests if there are any more elements to enumerate.\n     *\n     * @return true if there are some elements left\n     */\n    public final /*@pure@*/ boolean hasMoreElements() {\n\n      if (m_Counter \u003c m_Vector.size()) {\n\treturn true;\n      }\n      return false;\n    }\n\n    /**\n     * Returns the next element.\n     *\n     * @return the next element to be enumerated\n     */\n    //@ also requires hasMoreElements();\n    public final Object nextElement() {\n  \n      Object result = m_Vector.elementAt(m_Counter);\n\n      m_Counter++;\n      if (m_Counter == m_SpecialElement) {\n\tm_Counter++;\n      }\n      return result;\n    }\n  }\n\n  /** The array of objects. */\n  private /*@spec_public@*/ Object[] m_Objects;\n  //@ invariant m_Objects != null;\n  //@ invariant m_Objects.length \u003e= 0;\n\n  /** The current size; */\n  private /*@spec_public@*/ int m_Size = 0;\n  //@ invariant 0 \u003c= m_Size;\n  //@ invariant m_Size \u003c= m_Objects.length;\n\n  /** The capacity increment */\n  private /*@spec_public@*/ int m_CapacityIncrement = 1;\n  //@ invariant 1 \u003c= m_CapacityIncrement;\n  \n  /** The capacity multiplier. */\n  private /*@spec_public@*/ int m_CapacityMultiplier = 2;\n  //@ invariant 1 \u003c= m_CapacityMultiplier;\n\n  // Make sure the size will increase...\n  //@ invariant 3 \u003c= m_CapacityMultiplier + m_CapacityIncrement;\n\n  /**\n   * Constructs an empty vector with initial\n   * capacity zero.\n   */\n  public FastVector() {\n  \n    m_Objects = new Object[0];\n  }\n\n  /**\n   * Constructs a vector with the given capacity.\n   *\n   * @param capacity the vector's initial capacity\n   */\n  //@ requires capacity \u003e= 0;\n  public FastVector(int capacity) {\n\n    m_Objects = new Object[capacity];\n  }\n\n  /**\n   * Adds an element to this vector. Increases its\n   * capacity if its not large enough.\n   *\n   * @param element the element to add\n   */\n  public final void addElement(Object element) {\n\n    Object[] newObjects;\n\n    if (m_Size == m_Objects.length) {\n      newObjects = new Object[m_CapacityMultiplier *\n\t\t\t     (m_Objects.length +\n\t\t\t      m_CapacityIncrement)];\n      System.arraycopy(m_Objects, 0, newObjects, 0, m_Size);\n      m_Objects = newObjects;\n    }\n    m_Objects[m_Size] = element;\n    m_Size++;\n  }\n\n  /**\n   * Returns the capacity of the vector.\n   *\n   * @return the capacity of the vector\n   */\n  //@ ensures \\result == m_Objects.length;\n  public final /*@pure@*/ int capacity() {\n  \n    return m_Objects.length;\n  }\n\n  /**\n   * Produces a shallow copy of this vector.\n   *\n   * @return the new vector\n   */\n  public final Object copy() {\n\n    FastVector copy = new FastVector(m_Objects.length);\n\n    copy.m_Size = m_Size;\n    copy.m_CapacityIncrement = m_CapacityIncrement;\n    copy.m_CapacityMultiplier = m_CapacityMultiplier;\n    System.arraycopy(m_Objects, 0, copy.m_Objects, 0, m_Size);\n    return copy;\n  }\n\n  /**\n   * Clones the vector and shallow copies all its elements.\n   * The elements have to implement the Copyable interface.\n   * \n   * @return the new vector\n   */\n  public final Object copyElements() {\n\n    FastVector copy = new FastVector(m_Objects.length);\n\n    copy.m_Size = m_Size;\n    copy.m_CapacityIncrement = m_CapacityIncrement;\n    copy.m_CapacityMultiplier = m_CapacityMultiplier;\n    for (int i = 0; i \u003c m_Size; i++) {\n      copy.m_Objects[i] = ((Copyable)m_Objects[i]).copy();\n    }\n    return copy;\n  }\n\n  /**\n   * Returns the element at the given position.\n   *\n   * @param index the element's index\n   * @return the element with the given index\n   */\n  //@ requires 0 \u003c= index;\n  //@ requires index \u003c m_Objects.length;\n  public final /*@pure@*/ Object elementAt(int index) {\n\n    return m_Objects[index];\n  }\n\n  /**\n   * Returns an enumeration of this vector.\n   *\n   * @return an enumeration of this vector\n   */\n  public final /*@pure@*/ Enumeration elements() {\n  \n    return new FastVectorEnumeration(this);\n  }\n\n  /**\n   * Returns an enumeration of this vector, skipping the\n   * element with the given index.\n   *\n   * @param index the element to skip\n   * @return an enumeration of this vector\n   */\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();\n  public final /*@pure@*/ Enumeration elements(int index) {\n  \n    return new FastVectorEnumeration(this, index);\n  }\n\n    /**\n     * added by akibriya\n     */\n  public /*@pure@*/ boolean contains(Object o) {\n      if(o==null)\n\t  return false;\n\n      for(int i=0; i\u003cm_Objects.length; i++) \n\t  if(o.equals(m_Objects[i]))\n\t      return true;\n      \n      return false;\n  }\n\n\n  /**\n   * Returns the first element of the vector.\n   *\n   * @return the first element of the vector\n   */\n  //@ requires m_Size \u003e 0;\n  public final /*@pure@*/ Object firstElement() {\n\n    return m_Objects[0];\n  }\n\n  /**\n   * Searches for the first occurence of the given argument, \n   * testing for equality using the equals method. \n   *\n   * @param element the element to be found\n   * @return the index of the first occurrence of the argument \n   * in this vector; returns -1 if the object is not found\n   */\n  public final /*@pure@*/ int indexOf(/*@non_null@*/ Object element) {\n\n    for (int i = 0; i \u003c m_Size; i++) {\n      if (element.equals(m_Objects[i])) {\n\treturn i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Inserts an element at the given position.\n   *\n   * @param element the element to be inserted\n   * @param index the element's index\n   */\n  public final void insertElementAt(Object element, int index) {\n\n    Object[] newObjects;\n\n    if (m_Size \u003c m_Objects.length) {\n      System.arraycopy(m_Objects, index, m_Objects, index + 1, \n                       m_Size - index);\n      m_Objects[index] = element;\n    } else {\n      newObjects = new Object[m_CapacityMultiplier *\n\t\t\t     (m_Objects.length +\n\t\t\t      m_CapacityIncrement)];\n      System.arraycopy(m_Objects, 0, newObjects, 0, index);\n      newObjects[index] = element;\n      System.arraycopy(m_Objects, index, newObjects, index + 1,\n\t\t       m_Size - index);\n      m_Objects = newObjects;\n    }\n    m_Size++;\n  }\n\n  /**\n   * Returns the last element of the vector.\n   *\n   * @return the last element of the vector\n   */\n  //@ requires m_Size \u003e 0;\n  public final /*@pure@*/ Object lastElement() {\n\n    return m_Objects[m_Size - 1];\n  }\n\n  /**\n   * Deletes an element from this vector.\n   *\n   * @param index the index of the element to be deleted\n   */\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Size;\n  public final void removeElementAt(int index) {\n\n    System.arraycopy(m_Objects, index + 1, m_Objects, index, \n                     m_Size - index - 1);\n    m_Size--;\n  }\n\n  /**\n   * Removes all components from this vector and sets its \n   * size to zero. \n   */\n  public final void removeAllElements() {\n\n    m_Objects = new Object[m_Objects.length];\n    m_Size = 0;\n  }\n\n  /**\n   * Appends all elements of the supplied vector to this vector.\n   *\n   * @param toAppend the FastVector containing elements to append.\n   */\n  public final void appendElements(FastVector toAppend) {\n\n    setCapacity(size() + toAppend.size());\n    System.arraycopy(toAppend.m_Objects, 0, m_Objects, size(), toAppend.size());\n    m_Size = m_Objects.length;\n  }\n\n  /** \n   * Returns all the elements of this vector as an array\n   *\n   * @param an array containing all the elements of this vector\n   */\n  public final Object [] toArray() {\n\n    Object [] newObjects = new Object[size()];\n    System.arraycopy(m_Objects, 0, newObjects, 0, size());\n    return newObjects;\n  }\n\n  /**\n   * Sets the vector's capacity to the given value.\n   *\n   * @param capacity the new capacity\n   */\n  public final void setCapacity(int capacity) {\n\n    Object[] newObjects = new Object[capacity];\n   \n    System.arraycopy(m_Objects, 0, newObjects, 0, Math.min(capacity, m_Size));\n    m_Objects = newObjects;\n    if (m_Objects.length \u003c m_Size)\n      m_Size = m_Objects.length;\n  }\n\n  /**\n   * Sets the element at the given index.\n   *\n   * @param element the element to be put into the vector\n   * @param index the index at which the element is to be placed\n   */\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();\n  public final void setElementAt(Object element, int index) {\n\n    m_Objects[index] = element;\n  }\n\n  /**\n   * Returns the vector's current size.\n   *\n   * @return the vector's current size\n   */\n  //@ ensures \\result == m_Size;\n  public final /*@pure@*/ int size() {\n\n    return m_Size;\n  }\n\n  /**\n   * Swaps two elements in the vector.\n   *\n   * @param first index of the first element\n   * @param second index of the second element\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c size();\n  //@ requires 0 \u003c= second \u0026\u0026 second \u003c size();\n  public final void swap(int first, int second) {\n\n    Object help = m_Objects[first];\n\n    m_Objects[first] = m_Objects[second];\n    m_Objects[second] = help;\n  }\n\n  /**\n   * Sets the vector's capacity to its size.\n   */\n  public final void trimToSize() {\n\n    Object[] newObjects = new Object[m_Size];\n    \n    System.arraycopy(m_Objects, 0, newObjects, 0, m_Size);\n    m_Objects = newObjects;\n  }\n}\n\n",
        "name": "FastVector.java",
        "path": "subjectSystems/C,D/src/weka/core/FastVector.java",
        "url": "/github.com/LASER-UMASS/Themis/-/blob/subjectSystems/C,D/src/weka/core/FastVector.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 76,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= special \u0026\u0026 special \u003c vector.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 155,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires capacity \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 187,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Objects.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 234,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;"
        },
        {
          "limitHit": false,
          "lineNumber": 235,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003c m_Objects.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 258,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();"
        },
        {
          "limitHit": false,
          "lineNumber": 284,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Size \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 340,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Size \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 351,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Size;"
        },
        {
          "limitHit": false,
          "lineNumber": 414,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c size();"
        },
        {
          "limitHit": false,
          "lineNumber": 425,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Size;"
        },
        {
          "limitHit": false,
          "lineNumber": 437,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c size();"
        },
        {
          "limitHit": false,
          "lineNumber": 438,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= second \u0026\u0026 second \u003c size();"
        }
      ],
      "repository": {
        "name": "github.com/LASER-UMASS/Themis",
        "url": "/github.com/LASER-UMASS/Themis"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a70f12a6a8f34cdd8b170b4dc59a78674c9e8950"
        },
        "content": "/*\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; either version 2 of the License, or\n *    (at your option) any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n/*\n *    SingleIndex.java\n *    Copyright (C) 2003 University of Waikato\n *\n */\n\npackage weka.core;\n\nimport java.io.*;\nimport java.util.*;\n\n/** \n * Class representing a single cardinal number. The number is set by a \n * string representation such as: \u003cP\u003e\n *\n * \u003ccode\u003e\n *   first\n *   last\n *   1\n *   3\n * \u003c/code\u003e \u003cP\u003e\n * The number is internally converted from 1-based to 0-based (so methods that \n * set or get numbers not in string format should use 0-based numbers).\n *\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\n * @version $Revision: 1.5 $\n */\npublic class SingleIndex implements Serializable {\n\n  /** Record the string representation of the number */\n  protected /*@non_null spec_public@*/ String m_IndexString = \"\";\n\n  /** The selected index */\n  protected /*@ spec_public @*/ int m_SelectedIndex = -1;\n\n  /** Store the maximum value permitted. -1 indicates that no upper\n      value has been set */\n  protected /*@ spec_public @*/ int m_Upper = -1;\n\n  /**\n   * Default constructor.\n   *\n   */\n  //@ assignable m_IndexString, m_SelectedIndex, m_Upper;\n  //@ ensures m_SelectedIndex == -1;\n  //@ ensures m_Upper == -1;\n  public SingleIndex() {\n  }\n\n  /**\n   * Constructor to set initial index.\n   *\n   * @param rangeList the initial index\n   * @exception IllegalArgumentException if the index is invalid\n   */\n  //@ assignable m_IndexString, m_SelectedIndex, m_Upper;\n  //@ ensures m_IndexString == index;\n  //@ ensures m_SelectedIndex == -1;\n  //@ ensures m_Upper == -1;\n  public SingleIndex(/*@non_null@*/ String index) {\n\n    setSingleIndex(index);\n  }\n\n  /**\n   * Sets the value of \"last\".\n   *\n   * @param newUpper the value of \"last\"\n   */\n  //@ assignable m_Upper, m_IndexString, m_SelectedIndex;\n  //@ ensures newUpper \u003c 0 ==\u003e m_Upper == \\old(m_Upper);\n  //@ ensures newUpper \u003e= 0 ==\u003e m_Upper == newUpper;\n  public void setUpper(int newUpper) {\n\n    if (newUpper \u003e= 0) {\n      m_Upper = newUpper;\n      setValue();\n    }\n  }\n\n  /**\n   * Gets the string representing the selected range of values\n   *\n   * @return the range selection string\n   */\n  //@ ensures \\result == m_IndexString;\n  public /*@pure@*/ String getSingleIndex() {\n\n    return m_IndexString;\n  }\n\n  /**\n   * Sets the index from a string representation. Note that setUpper()\n   * must be called for the value to be actually set\n   *\n   * @param index the index set\n   * @exception IllegalArgumentException if the index was not well formed\n   */\n  //@ assignable m_IndexString, m_SelectedIndex;\n  //@ ensures m_IndexString == index;\n  //@ ensures m_SelectedIndex == -1;\n  public void setSingleIndex(/*@non_null@*/ String index) {\n\n    m_IndexString = index;\n    m_SelectedIndex = -1;\n  }\n\n  /**\n   * Constructs a representation of the current range. Being a string\n   * representation, the numbers are based from 1.\n   * \n   * @return the string representation of the current range\n   */\n  //@ also signals (RuntimeException e) \\old(m_Upper) \u003c 0;\n  //@ ensures \\result != null;\n  public /*@pure@*/ String toString() {\n\n    if (m_IndexString.equals(\"\")) {\n      return \"No index set\";\n    }\n    if (m_Upper == -1) {\n      throw new RuntimeException(\"Upper limit has not been specified\");\n    }\n    return m_IndexString;\n  }\n\n  /**\n   * Gets the selected index\n   *\n   * @return the selected index\n   * @exception RuntimeException if the upper limit of the index hasn't been defined\n   */\n  //@ requires m_Upper \u003e= 0;\n  //@ requires m_IndexString.length() \u003e 0;\n  //@ ensures \\result == m_SelectedIndex;\n  public /*@pure@*/ int getIndex() {\n\n    if (m_IndexString.equals(\"\")) {\n      throw new RuntimeException(\"No index set\");\n    }\n    if (m_Upper == -1) {\n      throw new RuntimeException(\"No upper limit has been specified for index\");\n    }\n    return m_SelectedIndex;\n  }\n\n  /**\n   * Creates a string representation of the given index.\n   *\n   * @param indices an array containing indices to select.\n   * Since the array will typically come from a program, indices are assumed\n   * from 0, and thus will have 1 added in the String representation.\n   */\n  //@ requires index \u003e= 0;\n  public static /*@pure non_null@*/ String indexToString(int index) {\n\n    return \"\" + (index + 1);\n  }\n\n  /**\n   * Translates a single string selection into it's internal 0-based equivalent\n   *\n   * @param single the string representing the selection (eg: 1 first last)\n   * @return the number corresponding to the selected value\n   */\n  //@ assignable m_SelectedIndex, m_IndexString;\n  protected void setValue() {\n\n    if (m_IndexString.equals(\"\")) {\n      throw new RuntimeException(\"No index set\");\n    }\n    if (m_IndexString.toLowerCase().equals(\"first\")) {\n      m_SelectedIndex = 0;\n    } else if (m_IndexString.toLowerCase().equals(\"last\")) {\n      m_SelectedIndex = m_Upper;\n    } else {\n      m_SelectedIndex = Integer.parseInt(m_IndexString) - 1;\n      if (m_SelectedIndex \u003c 0) {\n\tm_IndexString = \"\";\n\tthrow new IllegalArgumentException(\"Index must be greater than zero\");\n      }\n      if (m_SelectedIndex \u003e m_Upper) {\n\tm_IndexString = \"\";\n\tthrow new IllegalArgumentException(\"Index is too large\");\n      }\n    }\n  }\n\n  /**\n   * Main method for testing this class.\n   *\n   * @param argv one parameter: a test index specification\n   */\n  //@ requires \\nonnullelements(argv);\n  public static void main(/*@non_null@*/ String [] argv) {\n\n    try {\n      if (argv.length == 0) {\n\tthrow new Exception(\"Usage: SingleIndex \u003cindexspec\u003e\");\n      }\n      SingleIndex singleIndex = new SingleIndex();\n      singleIndex.setSingleIndex(argv[0]);\n      singleIndex.setUpper(9);\n      System.out.println(\"Input: \" + argv[0] + \"\\n\"\n\t\t\t + singleIndex.toString());\n      int selectedIndex = singleIndex.getIndex();\n      System.out.println(selectedIndex + \"\");\n    } catch (Exception ex) {\n      ex.printStackTrace();\n      System.out.println(ex.getMessage());\n    }\n  }\n}\n",
        "name": "SingleIndex.java",
        "path": "subjectSystems/C,D/src/weka/core/SingleIndex.java",
        "url": "/github.com/LASER-UMASS/Themis/-/blob/subjectSystems/C,D/src/weka/core/SingleIndex.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 60,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_SelectedIndex == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 61,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Upper == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 72,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_IndexString == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 73,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_SelectedIndex == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 74,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Upper == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 86,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures newUpper \u003c 0 ==\u003e m_Upper == \\old(m_Upper);"
        },
        {
          "limitHit": false,
          "lineNumber": 87,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures newUpper \u003e= 0 ==\u003e m_Upper == newUpper;"
        },
        {
          "limitHit": false,
          "lineNumber": 101,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_IndexString;"
        },
        {
          "limitHit": false,
          "lineNumber": 115,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_IndexString == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 116,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_SelectedIndex == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 130,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 148,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Upper \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 149,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_IndexString.length() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 150,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_SelectedIndex;"
        },
        {
          "limitHit": false,
          "lineNumber": 169,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 209,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires \\nonnullelements(argv);"
        }
      ],
      "repository": {
        "name": "github.com/LASER-UMASS/Themis",
        "url": "/github.com/LASER-UMASS/Themis"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a70f12a6a8f34cdd8b170b4dc59a78674c9e8950"
        },
        "content": "/*\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; either version 2 of the License, or\n *    (at your option) any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n/*\n *    OptionHandler.java\n *    Copyright (C) 1999 Eibe Frank,Len Trigg\n *\n */\n\npackage weka.core;\n\nimport java.util.*;\n\n/** \n * Interface to something that understands options.\n *\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\n * @author Len Trigg (trigg@cs.waikato.ac.nz)\n * @version $Revision: 1.7 $\n */\npublic interface OptionHandler {\n\n  /**\n   * Returns an enumeration of all the available options..\n   *\n   * @return an enumeration of all available options.\n   */\n  Enumeration listOptions();\n\n  /**\n   * Sets the OptionHandler's options using the given list. All options\n   * will be set (or reset) during this call (i.e. incremental setting\n   * of options is not possible).\n   *\n   * @param options the list of options as an array of strings\n   * @exception Exception if an option is not supported\n   */\n  //@ requires options != null;\n  //@ requires \\nonnullelements(options);\n  void setOptions(String[] options) throws Exception;\n\n  /**\n   * Gets the current option settings for the OptionHandler.\n   *\n   * @return the list of current option settings as an array of strings\n   */\n  //@ ensures \\result != null;\n  //@ ensures \\nonnullelements(\\result);\n  /*@pure@*/ String[] getOptions();\n}\n\n\n\n\n\n\n\n\n",
        "name": "OptionHandler.java",
        "path": "subjectSystems/C,D/src/weka/core/OptionHandler.java",
        "url": "/github.com/LASER-UMASS/Themis/-/blob/subjectSystems/C,D/src/weka/core/OptionHandler.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 50,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires options != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 51,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires \\nonnullelements(options);"
        },
        {
          "limitHit": false,
          "lineNumber": 59,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 60,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\nonnullelements(\\result);"
        }
      ],
      "repository": {
        "name": "github.com/LASER-UMASS/Themis",
        "url": "/github.com/LASER-UMASS/Themis"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 402,
  "ElapsedMilliseconds": 72,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
