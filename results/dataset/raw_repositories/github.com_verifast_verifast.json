{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/verifast/verifast lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "/*@\r\n\r\npredicate_family MapFunc(Class c)(MapFunc f, list\u003cint\u003e in, list\u003cint\u003e out, any info);\r\n\r\n@*/\r\n\r\ninterface MapFunc {\r\n\r\n    int apply(int x);\r\n        //@ requires MapFunc(this.getClass())(this, ?in, ?out, ?info) \u0026*\u0026 switch (in) { case nil: return false; case cons(h, t): return x == h; };\r\n        //@ ensures MapFunc(this.getClass())(this, tail(in), append(out, cons(result, nil)), info);\r\n\r\n}\r\n\r\n/*@\r\n\r\npredicate_family List(Class c)(List l, list\u003cint\u003e xs);\r\n\r\nlemma void list_split_fractions(List l)\r\n    requires [_]List(?c)(l, ?xs);\r\n    ensures List(c)(l, xs) \u0026*\u0026 List(c)(l, xs);\r\n{\r\n    assume(false);\r\n}\r\n\r\n@*/\r\n\r\ninterface List {\r\n\r\n    boolean isEmpty();\r\n        //@ requires List(this.getClass())(this, ?xs);\r\n        //@ ensures List(this.getClass())(this, xs) \u0026*\u0026 result == (xs == nil);\r\n    \r\n    int head();\r\n        //@ requires List(this.getClass())(this, ?xs) \u0026*\u0026 xs != nil;\r\n        //@ ensures List(this.getClass())(this, xs) \u0026*\u0026 result == head(xs);\r\n    \r\n    List tail();\r\n        //@ requires List(this.getClass())(this, ?xs) \u0026*\u0026 xs != nil;\r\n        //@ ensures List(this.getClass())(this, xs) \u0026*\u0026 result != null \u0026*\u0026 List(result.getClass())(result, tail(xs));\r\n    \r\n    List map(MapFunc f);\r\n        //@ requires List(this.getClass())(this, ?xs) \u0026*\u0026 f != null \u0026*\u0026 MapFunc(f.getClass())(f, xs, ?ys, ?info);\r\n        //@ ensures List(this.getClass())(this, xs) \u0026*\u0026 result != null \u0026*\u0026 List(result.getClass())(result, ?zs) \u0026*\u0026 MapFunc(f.getClass())(f, nil, append(ys, zs), info);\r\n    \r\n    boolean equals(List other);\r\n        //@ requires List(this.getClass())(this, ?xs) \u0026*\u0026 other != null \u0026*\u0026 List(other.getClass())(other, ?ys);\r\n        //@ ensures List(this.getClass())(this, xs) \u0026*\u0026 List(other.getClass())(other, ys) \u0026*\u0026 result == (xs == ys);\r\n\r\n}\r\n\r\n/*@\r\n\r\npredicate_family_instance List(Nil.class)(Nil l, list\u003cint\u003e xs) =\r\n    l != null \u0026*\u0026 xs == nil;\r\n\r\n@*/\r\n\r\nclass Nil implements List {\r\n\r\n    Nil()\r\n        //@ requires true;\r\n        //@ ensures List(Nil.class)(this,nil);\r\n    {\r\n        //@ close List(Nil.class)(this, nil);\r\n    }\r\n    boolean isEmpty()\r\n        //@ requires List(Nil.class)(this, ?xs);\r\n        //@ ensures List(Nil.class)(this, xs) \u0026*\u0026 result == (xs == nil);\r\n    {\r\n        //@ open List(Nil.class)(this, xs);\r\n        //@ close List(Nil.class)(this, xs);\r\n        return true;\r\n    }\r\n    \r\n    int head()\r\n        //@ requires List(Nil.class)(this, ?xs) \u0026*\u0026 xs != nil;\r\n        //@ ensures List(Nil.class)(this, xs) \u0026*\u0026 result == head(xs);\r\n    {\r\n        //@ open List(Nil.class)(this, xs);\r\n        return 0; //~allow_dead_code\r\n    }\r\n    \r\n    List tail()\r\n        //@ requires List(Nil.class)(this, ?xs) \u0026*\u0026 xs != nil;\r\n        //@ ensures List(Nil.class)(this, xs) \u0026*\u0026 result != null \u0026*\u0026 List(result.getClass())(result, tail(xs));\r\n    {\r\n        //@ open List(Nil.class)(this, xs);\r\n        return null; //~allow_dead_code\r\n    }\r\n    \r\n    List map(MapFunc f)\r\n        //@ requires List(Nil.class)(this, ?xs) \u0026*\u0026 f != null \u0026*\u0026 MapFunc(f.getClass())(f, xs, ?ys, ?info);\r\n        //@ ensures List(Nil.class)(this, xs) \u0026*\u0026 result!= null \u0026*\u0026 List(result.getClass())(result, ?zs) \u0026*\u0026 MapFunc(f.getClass())(f, nil, append(ys, zs), info);\r\n    {\r\n        //@ open List(Nil.class)(this, xs);\r\n        //@ close List(Nil.class)(this, xs);\r\n        //@ append_nil(ys);\r\n        //@ assume(this.getClass() == Nil.class);\r\n        //@ list_split_fractions(this);\r\n        return this;\r\n    }\r\n    \r\n    boolean equals(List other)\r\n        //@ requires List(Nil.class)(this, ?xs) \u0026*\u0026 other!= null \u0026*\u0026 List(other.getClass())(other, ?ys);\r\n        //@ ensures List(Nil.class)(this, xs) \u0026*\u0026 List(other.getClass())(other, ys) \u0026*\u0026 result ? xs == ys : xs != ys;\r\n    {\r\n        //@ open List(Nil.class)(this, xs);\r\n        //@ close List(Nil.class)(this, xs);\r\n        return other.isEmpty();\r\n    }\r\n\r\n}\r\n\r\n/*@\r\n\r\npredicate_family_instance List(Cons.class)(Cons l, list\u003cint\u003e xs) =\r\n    [_]l.head |-\u003e ?head \u0026*\u0026 [_]l.tail |-\u003e ?tail \u0026*\u0026 tail != null \u0026*\u0026 List(tail.getClass())(tail, ?t) \u0026*\u0026 xs == cons(head, t);\r\n\r\n@*/\r\n\r\nclass Cons implements List {\r\n\r\n    int head;\r\n    List tail;\r\n    \r\n    Cons(int head, List tail)\r\n        //@ requires tail != null \u0026*\u0026 List(tail.getClass())(tail, ?t);\r\n        //@ ensures List(Cons.class)(this, cons(head, t));\r\n    {\r\n        this.head = head;\r\n        this.tail = tail;\r\n        //@ close List(Cons.class)(this, cons(head, t));\r\n    }\r\n\r\n    boolean isEmpty()\r\n        //@ requires List(Cons.class)(this, ?xs);\r\n        //@ ensures List(Cons.class)(this, xs) \u0026*\u0026 result == (xs == nil);\r\n    {\r\n        //@ open List(Cons.class)(this, ?xs_);\r\n        //@ close List(Cons.class)(this, xs_);\r\n        return false;\r\n    }\r\n    \r\n    int head()\r\n        //@ requires List(Cons.class)(this, ?xs) \u0026*\u0026 xs != nil;\r\n        //@ ensures List(Cons.class)(this, xs) \u0026*\u0026 result == head(xs);\r\n    {\r\n        //@ open List(Cons.class)(this, ?xs_);\r\n        return this.head;\r\n        //@ close List(Cons.class)(this, xs_);\r\n    }\r\n    \r\n    List tail()\r\n        //@ requires List(Cons.class)(this, ?xs) \u0026*\u0026 xs != nil;\r\n        //@ ensures List(Cons.class)(this, xs) \u0026*\u0026 result!= null \u0026*\u0026 List(result.getClass())(result, tail(xs));\r\n    {\r\n        //@ open List(Cons.class)(this, ?xs_);\r\n        List result = this.tail;\r\n        //@ list_split_fractions(result);\r\n        //@ close List(Cons.class)(this, xs_);\r\n        return result;\r\n    }\r\n    \r\n    List map(MapFunc f)\r\n        //@ requires List(Cons.class)(this, ?xs) \u0026*\u0026 f != null \u0026*\u0026 MapFunc(f.getClass())(f, xs, ?ys, ?info);\r\n        //@ ensures List(Cons.class)(this, xs) \u0026*\u0026 result != null \u0026*\u0026 List(result.getClass())(result, ?zs) \u0026*\u0026 MapFunc(f.getClass())(f, nil, append(ys, zs), info);\r\n    {\r\n        //@ open List(Cons.class)(this, ?xs_);\r\n        int fhead = f.apply(this.head);\r\n        List tail = this.tail;\r\n        List ftail = tail.map(f);\r\n        //@ assert List(_)(ftail, ?ftailxs);\r\n        return new Cons(fhead, ftail);\r\n        //@ close List(Cons.class)(this, xs_);\r\n        //@ append_assoc(ys, cons(fhead, nil), ftailxs);\r\n    }\r\n    \r\n    boolean equals(List other)\r\n        //@ requires List(Cons.class)(this, ?xs) \u0026*\u0026 other != null \u0026*\u0026 List(other.getClass())(other, ?ys);\r\n        //@ ensures List(Cons.class)(this, xs) \u0026*\u0026 List(other.getClass())(other, ys) \u0026*\u0026 result ? xs == ys : xs != ys;\r\n    {\r\n        //@ switch (ys) { case nil: case cons(h, t): }\r\n        //@ open List(Cons.class)(this, ?xs_);\r\n        boolean otherEmpty = other.isEmpty();\r\n        if (otherEmpty) {\r\n            //@ close List(Cons.class)(this, xs_);\r\n            return false;\r\n        } else {\r\n            int otherHead = other.head();\r\n            if (this.head == otherHead) {\r\n                List otherTail = other.tail();\r\n                List tail = this.tail;\r\n                return tail.equals(otherTail);\r\n                //@ close List(Cons.class)(this, xs_);\r\n            } else {\r\n                //@ close List(Cons.class)(this, xs_);\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/*@\r\n\r\nfixpoint list\u003cint\u003e plusOne(list\u003cint\u003e xs) {\r\n    switch (xs) {\r\n        case nil: return nil;\r\n        case cons(h, t): return cons\u003cint\u003e(h + 1, plusOne(t));\r\n    }\r\n}\r\n\r\npredicate_family_instance MapFunc(PlusOne.class)(PlusOne f, list\u003cint\u003e in, list\u003cint\u003e out, list\u003cint\u003e info) =\r\n    plusOne(info) == append(out, plusOne(in));\r\n\r\n@*/\r\n\r\nclass PlusOne implements MapFunc {\r\n\r\n    PlusOne()\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n    }\r\n    \r\n    int apply(int x)\r\n        //@ requires MapFunc(PlusOne.class)(this, ?in, ?out, ?info) \u0026*\u0026 switch (in) { case nil: return false; case cons(h, t): return x == h; };\r\n        //@ ensures MapFunc(PlusOne.class)(this, tail(in), append(out, cons(result, nil)), info);\r\n    {\r\n        //@ open MapFunc(PlusOne.class)(this, ?in_, ?out_, ?info_);\r\n        //@ append_assoc(out_, cons(x + 1, nil), plusOne(tail(in_)));\r\n        //@ close MapFunc(PlusOne.class)(this, tail(in_), append(out_, cons(x + 1, nil)), info_);\r\n        return x + 1;\r\n    }\r\n    \r\n}\r\n\r\nclass Program {\r\n    public static void main(String[] args)\r\n    //@ requires true;\r\n    //@ ensures true;\r\n    {\r\n        List l = new Nil();\r\n        l = new Cons(3, l);\r\n        l = new Cons(2, l);\r\n        l = new Cons(1, l);\r\n        PlusOne f = new PlusOne();\r\n        //@ close MapFunc(PlusOne.class)(f, cons(1, cons(2, cons(3, nil))), nil, cons(1, cons(2, cons(3, nil))));\r\n        List l2 = l.map(f);\r\n        //@ open MapFunc(PlusOne.class)(f, nil, ?ys, cons(1, cons(2, cons(3, nil))));\r\n        List l3 = new Nil();\r\n        l3 = new Cons(4, l3);\r\n        l3 = new Cons(3, l3);\r\n        l3 = new Cons(2, l3);\r\n        boolean eq = l2.equals(l3);\r\n        //@ append_nil(ys);\r\n        assert(eq);\r\n    }\r\n}\r\n",
        "name": "map.java",
        "path": "examples/java/map.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/map.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires MapFunc(this.getClass())(this, ?in, ?out, ?info) \u0026*\u0026 switch (in) { case nil: return false; case cons(h, t): return x == h; };\r"
        },
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures MapFunc(this.getClass())(this, tail(in), append(out, cons(result, nil)), info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 30,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List(this.getClass())(this, ?xs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(this.getClass())(this, xs) \u0026*\u0026 result == (xs == nil);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 34,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List(this.getClass())(this, ?xs) \u0026*\u0026 xs != nil;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 35,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(this.getClass())(this, xs) \u0026*\u0026 result == head(xs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List(this.getClass())(this, ?xs) \u0026*\u0026 xs != nil;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 39,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(this.getClass())(this, xs) \u0026*\u0026 result != null \u0026*\u0026 List(result.getClass())(result, tail(xs));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 42,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List(this.getClass())(this, ?xs) \u0026*\u0026 f != null \u0026*\u0026 MapFunc(f.getClass())(f, xs, ?ys, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 43,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(this.getClass())(this, xs) \u0026*\u0026 result != null \u0026*\u0026 List(result.getClass())(result, ?zs) \u0026*\u0026 MapFunc(f.getClass())(f, nil, append(ys, zs), info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 46,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List(this.getClass())(this, ?xs) \u0026*\u0026 other != null \u0026*\u0026 List(other.getClass())(other, ?ys);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 47,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(this.getClass())(this, xs) \u0026*\u0026 List(other.getClass())(other, ys) \u0026*\u0026 result == (xs == ys);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 61,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 62,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(Nil.class)(this,nil);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 67,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List(Nil.class)(this, ?xs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 68,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(Nil.class)(this, xs) \u0026*\u0026 result == (xs == nil);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 76,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List(Nil.class)(this, ?xs) \u0026*\u0026 xs != nil;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 77,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(Nil.class)(this, xs) \u0026*\u0026 result == head(xs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 84,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List(Nil.class)(this, ?xs) \u0026*\u0026 xs != nil;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 85,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(Nil.class)(this, xs) \u0026*\u0026 result != null \u0026*\u0026 List(result.getClass())(result, tail(xs));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 92,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List(Nil.class)(this, ?xs) \u0026*\u0026 f != null \u0026*\u0026 MapFunc(f.getClass())(f, xs, ?ys, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 93,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(Nil.class)(this, xs) \u0026*\u0026 result!= null \u0026*\u0026 List(result.getClass())(result, ?zs) \u0026*\u0026 MapFunc(f.getClass())(f, nil, append(ys, zs), info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 104,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List(Nil.class)(this, ?xs) \u0026*\u0026 other!= null \u0026*\u0026 List(other.getClass())(other, ?ys);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 105,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(Nil.class)(this, xs) \u0026*\u0026 List(other.getClass())(other, ys) \u0026*\u0026 result ? xs == ys : xs != ys;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 127,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires tail != null \u0026*\u0026 List(tail.getClass())(tail, ?t);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 128,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(Cons.class)(this, cons(head, t));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 136,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List(Cons.class)(this, ?xs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 137,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(Cons.class)(this, xs) \u0026*\u0026 result == (xs == nil);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 145,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List(Cons.class)(this, ?xs) \u0026*\u0026 xs != nil;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 146,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(Cons.class)(this, xs) \u0026*\u0026 result == head(xs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 154,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List(Cons.class)(this, ?xs) \u0026*\u0026 xs != nil;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 155,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(Cons.class)(this, xs) \u0026*\u0026 result!= null \u0026*\u0026 List(result.getClass())(result, tail(xs));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 165,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List(Cons.class)(this, ?xs) \u0026*\u0026 f != null \u0026*\u0026 MapFunc(f.getClass())(f, xs, ?ys, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 166,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(Cons.class)(this, xs) \u0026*\u0026 result != null \u0026*\u0026 List(result.getClass())(result, ?zs) \u0026*\u0026 MapFunc(f.getClass())(f, nil, append(ys, zs), info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 179,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List(Cons.class)(this, ?xs) \u0026*\u0026 other != null \u0026*\u0026 List(other.getClass())(other, ?ys);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 180,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(Cons.class)(this, xs) \u0026*\u0026 List(other.getClass())(other, ys) \u0026*\u0026 result ? xs == ys : xs != ys;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 221,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 222,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 227,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires MapFunc(PlusOne.class)(this, ?in, ?out, ?info) \u0026*\u0026 switch (in) { case nil: return false; case cons(h, t): return x == h; };\r"
        },
        {
          "limitHit": false,
          "lineNumber": 228,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures MapFunc(PlusOne.class)(this, tail(in), append(out, cons(result, nil)), info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 240,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 241,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "/*@\r\n\r\n// Definition of minimum of a list of values.\r\n\r\nfixpoint int min0(int x, list\u003cint\u003e xs) {\r\n    switch (xs) {\r\n        case nil: return x;\r\n        case cons(x1, xs1): return min0(x1 \u003c x ? x1 : x, xs1);\r\n    }\r\n}\r\n\r\nfixpoint int min(list\u003cint\u003e xs) {\r\n    return min0(head(xs), tail(xs));\r\n}\r\n\r\nlemma void min0_append(int x, list\u003cint\u003e xs1, list\u003cint\u003e xs2)\r\n    requires true;\r\n    ensures min0(x, append(xs1, xs2)) == min0(min0(x, xs1), xs2);\r\n{\r\n    switch (xs1) {\r\n        case nil:\r\n        case cons(x1, xs11):\r\n            min0_append(x1 \u003c x ? x1 : x, xs11, xs2);\r\n    }\r\n}\r\n\r\n// Definition of the relation \"list A is a permutation of list B\"\r\n\r\nfixpoint list\u003ct\u003e do_swap\u003ct\u003e(pair\u003cint, int\u003e swap, list\u003ct\u003e xs) {\r\n    switch (swap) {\r\n        case pair(i, j): return 0 \u003c= i \u0026\u0026 i \u003c= j \u0026\u0026 j \u003c length(xs) ? update(i, nth(j, xs), update(j, nth(i, xs), xs)) : xs;\r\n    }\r\n}\r\n\r\nfixpoint list\u003ct\u003e do_swaps\u003ct\u003e(list\u003cpair\u003cint, int\u003e \u003e swaps, list\u003ct\u003e xs) {\r\n    switch (swaps) {\r\n        case nil: return xs;\r\n        case cons(swap, swaps0): return do_swap(swap, do_swaps(swaps0, xs));\r\n    }\r\n}\r\n\r\npredicate permut\u003ct\u003e(list\u003ct\u003e xs, list\u003cpair\u003cint, int\u003e \u003e swaps; list\u003ct\u003e ys) = ys == do_swaps(swaps, xs);\r\n\r\n// Some lemmas about the interaction between list update, append, and take. (Applied automatically; should be in the VeriFast library.)\r\n\r\nlemma_auto void update_append_r\u003ct\u003e(int i, t v, list\u003ct\u003e xs, list\u003ct\u003e ys)\r\n    requires length(xs) \u003c= i \u0026\u0026 i \u003c length(xs) + length(ys);\r\n    ensures update(i, v, append(xs, ys)) == append(xs, update(i - length(xs), v, ys));\r\n{\r\n    switch (xs) {\r\n        case nil:\r\n        case cons(x0, xs0):\r\n            update_append_r(i - 1, v, xs0, ys);\r\n    }\r\n}\r\n\r\nlemma_auto void update_append_l\u003ct\u003e(int i, t v, list\u003ct\u003e xs, list\u003ct\u003e ys)\r\n    requires 0 \u003c= i \u0026\u0026 i \u003c length(xs);\r\n    ensures update(i, v, append(xs, ys)) == append(update(i, v, xs), ys);\r\n{\r\n    switch (xs) {\r\n        case nil:\r\n        case cons(x0, xs0):\r\n            if (i == 0) {\r\n            } else {\r\n                update_append_l(i - 1, v, xs0, ys);\r\n            }\r\n    }\r\n}\r\n\r\nlemma_auto void update_take\u003ct\u003e(int i, t v, int n, list\u003ct\u003e xs)\r\n    requires 0 \u003c= i \u0026\u0026 i \u003c n \u0026\u0026 n \u003c= length(xs);\r\n    ensures update(i, v, take(n, xs)) == take(n, update(i, v, xs));\r\n{\r\n    switch (xs) {\r\n        case nil:\r\n        case cons(x0, xs0):\r\n            if (i == 0) {\r\n            } else {\r\n                update_take(i - 1, v, n - 1, xs0);\r\n            }\r\n    }\r\n}\r\n\r\n@*/\r\n\r\nclass Bag {\r\n  \r\n  int[] a;\r\n  int n;\r\n  \r\n  //@ predicate valid(list\u003cint\u003e elems) = a |-\u003e ?a \u0026*\u0026 n |-\u003e ?n \u0026*\u0026 array_slice(a, 0, n, elems);\r\n  \r\n  Bag(int[] input)\r\n    //@ requires array_slice(input, 0, input.length, ?xs);\r\n    //@ ensures valid(xs);\r\n  {\r\n    n = input.length;\r\n    a = new int[n];\r\n\r\n    // Some magic to deal with System.arraycopy's polymorphism over the array element type.\r\n    //@ close array_slice_dynamic(array_slice_int, input, 0, n, _);\r\n    //@ close array_slice_dynamic(array_slice_int, a, 0, n, _);\r\n    //@ close arraycopy_pre(array_slice_int, false, 1, input, 0, n, _, a, 0);\r\n    System.arraycopy(input, 0, a, 0, n);\r\n    //@ open arraycopy_post(_, _, _, _, _, _, _, _, _);\r\n    //@ open array_slice_dynamic(_, a, _, _, _);\r\n  }\r\n  \r\n  int extractMin()\r\n    //@ requires valid(?xs) \u0026*\u0026 xs != nil;\r\n    /*@\r\n    ensures\r\n        valid(?xs1) \u0026*\u0026 result == min(xs) \u0026*\u0026\r\n        permut(xs, _, append(xs1, cons(result, nil))); // The new elements plus the result are a permutation of the old elements.\r\n    @*/\r\n  {\r\n    int mindex = 0;\r\n    //@ switch (xs) { case nil: case cons(x0, xs0): }\r\n    int m = a[mindex];\r\n    for (int i = 1; i \u003c n; i++)\r\n      /*@\r\n      invariant\r\n        a |-\u003e ?ar \u0026*\u0026 n |-\u003e ?num \u0026*\u0026 array_slice(ar, 0, num, xs) \u0026*\u0026\r\n        0 \u003c= mindex \u0026*\u0026 mindex \u003c num \u0026*\u0026\r\n        1 \u003c= i \u0026*\u0026 i \u003c= num \u0026*\u0026\r\n        nth(mindex, xs) == m \u0026*\u0026 m == min(take(i, xs));\r\n      @*/\r\n    {\r\n      //@ take_one_more(i, xs);\r\n      //@ min0_append(head(take(i, xs)), take(i, xs), cons(nth(i, xs), nil));\r\n      if (a[i] \u003c m) {\r\n        mindex = i;\r\n        m = a[i];\r\n      }\r\n    }\r\n    n--;\r\n    a[mindex] = a[n];\r\n    return m;\r\n    //@ assert a |-\u003e ?array \u0026*\u0026 n |-\u003e ?number \u0026*\u0026 array_slice(array, 0, number, ?xs1);\r\n    //@ assert xs == append(take(number, xs), drop(number, xs));\r\n    //@ assert drop(number, xs) == cons(?nv, ?tail);\r\n    //@ switch (tail) { case nil: case cons(h, t): length_nonnegative(t); }\r\n    /*@\r\n    if (mindex \u003c number) {\r\n        update_append_l(mindex, nv, take(number, xs), cons(m, nil));\r\n    }\r\n    @*/\r\n    //@ close permut(xs, cons(pair(mindex, number), nil), append(xs1, cons(m, nil)));\r\n  }\r\n  \r\n} ",
        "name": "Bag.java",
        "path": "examples/java/Bag.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Bag.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 94,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires array_slice(input, 0, input.length, ?xs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 95,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures valid(xs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 110,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires valid(?xs) \u0026*\u0026 xs != nil;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Node {\r\n\r\n    int value;\r\n    Node next;\r\n\r\n}\r\n\r\n/*@\r\n\r\npredicate nodes(Node n0; int count) =\r\n    n0 == null ?\r\n        count == 0\r\n    :\r\n        n0.value |-\u003e _ \u0026*\u0026 n0.next |-\u003e ?next \u0026*\u0026\r\n        nodes(next, ?ncount) \u0026*\u0026\r\n        count == 1 + ncount;\r\n\r\n@*/\r\n\r\nclass Stack {\r\n\r\n    Node head;\r\n    \r\n    //@ predicate valid(int count) = head |-\u003e ?h \u0026*\u0026 nodes(h, count);\r\n    \r\n    Stack()\r\n        //@ requires true;\r\n        //@ ensures valid(0);\r\n    {\r\n        //@ close valid(0);\r\n    }\r\n    \r\n    void push(int element)\r\n        //@ requires valid(?count);\r\n        //@ ensures valid(count + 1);\r\n    {\r\n        //@ open valid(count);\r\n        Node n = new Node();\r\n        n.value = element;\r\n        n.next = head;\r\n        head = n;\r\n        //@ close nodes(head, count + 1);\r\n        //@ close valid(count + 1);\r\n    }\r\n    \r\n    int pop()\r\n        //@ requires valid(?count) \u0026*\u0026 0 \u003c count;\r\n        //@ ensures valid(count - 1);\r\n    {\r\n        //@ open valid(count);\r\n        //@ open nodes(_, _);\r\n        int result = head.value;\r\n        head = head.next;\r\n        //@ close valid(count - 1);\r\n        return result;\r\n    }\r\n\r\n}\r\n\r\nclass Program {\r\n\r\n    public static void main(String[] args)\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        Stack s = new Stack();\r\n        s.push(10);\r\n        s.push(20);\r\n        s.push(30);\r\n        s.pop();\r\n        s.pop();\r\n        s.pop();\r\n    }\r\n\r\n}",
        "name": "Stack.java",
        "path": "examples/java/Stack.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Stack.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 26,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(0);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 33,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?count);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 34,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(count + 1);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 46,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?count) \u0026*\u0026 0 \u003c count;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 47,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(count - 1);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 62,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 63,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Person {\r\n\r\n    protected Person spouse;\r\n\r\n    /*@\r\n    \r\n    predicate valid(Person spouse) =\r\n        [1/2]this.spouse |-\u003e spouse \u0026*\u0026 spouse == null ? [1/2]this.spouse |-\u003e null : [1/2]spouse.spouse |-\u003e this;\r\n    \r\n    protected lemma void spouse_symm_helper()\r\n        requires valid(?s) \u0026*\u0026 [1/2]this.spouse |-\u003e ?s0;\r\n        ensures valid(s) \u0026*\u0026 [1/2]this.spouse |-\u003e s0 \u0026*\u0026 s == s0;\r\n    {\r\n        open valid(s);\r\n        close valid(s);\r\n    }\r\n    \r\n    @*/\r\n    \r\n    public /*lemma*/ void spouse_symm()\r\n        //@ requires valid(?s) \u0026*\u0026 s.valid(?ss);\r\n        //@ ensures valid(s) \u0026*\u0026 s.valid(ss) \u0026*\u0026 ss == this;\r\n    {\r\n        //@ open valid(s);\r\n        //@ spouse.spouse_symm_helper();\r\n        //@ close valid(s);\r\n    }\r\n\r\n    public Person()\r\n        //@ requires true;\r\n        //@ ensures valid(null);\r\n    {\r\n        //@ close valid(null);\r\n    }\r\n    \r\n    public Person getSpouse()\r\n        //@ requires valid(?s);\r\n        //@ ensures valid(s) \u0026*\u0026 result == s;\r\n    {\r\n        //@ open valid(s);\r\n        return spouse;\r\n        //@ close valid(s);\r\n    }\r\n    \r\n    protected void setSpouse(Person other)\r\n        //@ requires valid(null) \u0026*\u0026 other.spouse |-\u003e null;\r\n        //@ ensures valid(other) \u0026*\u0026 [1/2]other.spouse |-\u003e this \u0026*\u0026 [1/2]spouse |-\u003e other;\r\n    {\r\n        //@ open valid(null);\r\n        spouse = other;\r\n        other.spouse = this;\r\n        //@ close valid(other);\r\n    }\r\n    \r\n    protected void clearSpouse()\r\n        //@ requires [1/2]spouse |-\u003e ?s \u0026*\u0026 valid(?ss) \u0026*\u0026 [1/2]s.spouse |-\u003e _;\r\n        //@ ensures valid(null) \u0026*\u0026 s.spouse |-\u003e null \u0026*\u0026 ss == s;\r\n    {\r\n        //@ open valid(ss);\r\n        spouse.spouse = null;\r\n        spouse = null;\r\n        //@ close valid(null);\r\n    }\r\n    \r\n    void marry(Person other)\r\n        //@ requires valid(null) \u0026*\u0026 other.valid(null);\r\n        //@ ensures valid(other) \u0026*\u0026 other.valid(this);\r\n    {\r\n        //@ open valid(null);\r\n        other.setSpouse(this);\r\n        //@ close valid(other);\r\n    }\r\n    \r\n    void divorce()\r\n        //@ requires valid(?other) \u0026*\u0026 other.valid(?ss);\r\n        //@ ensures valid(null) \u0026*\u0026 other.valid(null) \u0026*\u0026 ss == this;\r\n    {\r\n        //@ open valid(other);\r\n        spouse.clearSpouse();\r\n        //@ close valid(null);\r\n    }\r\n\r\n}\r\n\r\nclass Program {\r\n\r\n    public static void main(String[] args)\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        Person a = new Person();\r\n        Person b = new Person();\r\n        a.marry(b);\r\n        b.divorce();\r\n    }\r\n\r\n}",
        "name": "Spouse.java",
        "path": "examples/java/Spouse.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Spouse.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?s) \u0026*\u0026 s.valid(?ss);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(s) \u0026*\u0026 s.valid(ss) \u0026*\u0026 ss == this;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 29,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 30,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(null);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 36,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?s);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 37,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(s) \u0026*\u0026 result == s;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 45,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(null) \u0026*\u0026 other.spouse |-\u003e null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 46,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(other) \u0026*\u0026 [1/2]other.spouse |-\u003e this \u0026*\u0026 [1/2]spouse |-\u003e other;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 55,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [1/2]spouse |-\u003e ?s \u0026*\u0026 valid(?ss) \u0026*\u0026 [1/2]s.spouse |-\u003e _;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 56,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(null) \u0026*\u0026 s.spouse |-\u003e null \u0026*\u0026 ss == s;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 65,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(null) \u0026*\u0026 other.valid(null);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 66,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(other) \u0026*\u0026 other.valid(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 74,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?other) \u0026*\u0026 other.valid(?ss);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 75,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(null) \u0026*\u0026 other.valid(null) \u0026*\u0026 ss == this;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 87,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 88,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "// This example shows that behavioral subtyping is more flexible than one might expect.\r\n\r\nclass Cell {\r\n\r\n    int value;\r\n\r\n    //@ predicate valid(int x) = value |-\u003e x;\r\n\r\n    Cell()\r\n        //@ requires true;\r\n        //@ ensures valid(0);\r\n    {\r\n        //@ close valid(0);\r\n    }\r\n\r\n    void increment()\r\n        //@ requires valid(?x);\r\n        //@ ensures valid(x + 1);\r\n    {\r\n        //@ open valid(x);\r\n        value++;\r\n        //@ close valid(x + 1);\r\n    }\r\n\r\n}\r\n\r\nclass Recell extends Cell {\r\n\r\n    //@ predicate valid(int x) = false \u0026*\u0026 x == 0;\r\n    \r\n    void increment()\r\n        //@ requires valid(?x);\r\n        //@ ensures valid(x + 1);\r\n    {\r\n        //@ open valid(x);\r\n        value--; //~allow_dead_code\r\n    }\r\n\r\n}",
        "name": "Recell.java",
        "path": "examples/java/Recell.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Recell.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(0);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?x);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(x + 1);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?x);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 32,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(x + 1);\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "// An extremely flexible Person class, where subclasses are not required to store the spouse in the spouse field.\r\n// Two layers of specification seem to be required: an inner layer that deals with storage of the spouse field, and\r\n// an outer layer that encapsulates the bidirectionality of the association.\r\n\r\nclass Person {\r\n\r\n    private Person spouse;\r\n\r\n    /*@\r\n    \r\n    protected predicate ticket(Person spouse) = [1/2]this.spouse |-\u003e spouse \u0026*\u0026 spouse != null;\r\n    protected predicate valid0(Person spouse) = [1/2]this.spouse |-\u003e spouse \u0026*\u0026 spouse == null ? [1/2]this.spouse |-\u003e null : emp;\r\n    \r\n    public predicate valid(Person spouse) = this.valid0(spouse) \u0026*\u0026 spouse != null ? spouse.ticket(this) : emp;\r\n    \r\n    @*/\r\n    \r\n    protected Person getSpouse0()\r\n        //@ requires valid0(?s);\r\n        //@ ensures valid0(s) \u0026*\u0026 result == s;\r\n    {\r\n        //@ open valid0(s);\r\n        Person result = spouse;\r\n        //@ close valid0(s);\r\n        return result;\r\n    }\r\n    \r\n    protected void setSpouse0(Person other)\r\n        //@ requires valid0(null) \u0026*\u0026 other != null;\r\n        //@ ensures valid0(other) \u0026*\u0026 ticket(other);\r\n    {\r\n        //@ open valid0(null);\r\n        spouse = other;\r\n        //@ close valid0(other);\r\n        //@ close ticket(other);\r\n    }\r\n    \r\n    protected void clearSpouse0()\r\n        //@ requires valid0(?other) \u0026*\u0026 ticket(_);\r\n        //@ ensures valid0(null) \u0026*\u0026 other != null;\r\n    {\r\n        //@ open valid0(other);\r\n        //@ open ticket(_);\r\n        spouse = null;\r\n        //@ close valid0(null);\r\n    }\r\n    \r\n    protected void setSpouse(Person other)\r\n        //@ requires valid(null) \u0026*\u0026 other.ticket(this);\r\n        //@ ensures valid(other) \u0026*\u0026 this.ticket(other);\r\n    {\r\n        //@ open valid(null);\r\n        setSpouse0(other);\r\n        //@ close valid(other);\r\n    }\r\n    \r\n    protected void clearSpouse()\r\n        //@ requires valid(?s) \u0026*\u0026 this.ticket(_);\r\n        //@ ensures valid(null) \u0026*\u0026 s.ticket(this);\r\n    {\r\n        //@ open valid(s);\r\n        clearSpouse0();\r\n        //@ close valid(null);\r\n    }\r\n    \r\n    /*@\r\n    \r\n    protected lemma void ticketLemma0()\r\n        requires valid0(?s) \u0026*\u0026 ticket(?s0);\r\n        ensures valid0(s) \u0026*\u0026 ticket(s0) \u0026*\u0026 s == s0;\r\n    {\r\n        open valid0(s);\r\n        open ticket(s0);\r\n        close valid0(s);\r\n        close ticket(s0);\r\n    }\r\n    \r\n    @*/\r\n    \r\n    protected /*lemma*/ void ticketLemma()\r\n        //@ requires valid(?s) \u0026*\u0026 this.ticket(?s0);\r\n        //@ ensures valid(s) \u0026*\u0026 this.ticket(s0) \u0026*\u0026 s == s0;\r\n    {\r\n        //@ open valid(s);\r\n        //@ ticketLemma0();\r\n        //@ close valid(s);\r\n    }\r\n    \r\n    public /*lemma*/ void symmetryLemma()\r\n        //@ requires valid(?s) \u0026*\u0026 s.valid(?ss);\r\n        //@ ensures valid(s) \u0026*\u0026 s.valid(ss) \u0026*\u0026 ss == this;\r\n    {\r\n        //@ open valid(s);\r\n        Person spouse = getSpouse0();\r\n        spouse.ticketLemma();\r\n        //@ close valid(s);\r\n    }\r\n\r\n    protected Person()\r\n        //@ requires true;\r\n        //@ ensures valid0(null);\r\n    {\r\n        //@ close valid0(null);\r\n    }\r\n    \r\n    /*@\r\n    \r\n    protected lemma void initLemma()\r\n        requires this.valid0(null);\r\n        ensures valid(null);\r\n    {\r\n        close valid(null);\r\n    }\r\n    \r\n    @*/\r\n    \r\n    public static Person create()\r\n        //@ requires true;\r\n        //@ ensures result.valid(null);\r\n    {\r\n        Person p = new Person();\r\n        //@ p.initLemma();\r\n        return p;\r\n    }\r\n    \r\n    public Person getSpouse()\r\n        //@ requires valid(?s);\r\n        //@ ensures valid(s) \u0026*\u0026 result == s;\r\n    {\r\n        //@ open valid(s);\r\n        return getSpouse0();\r\n        //@ close valid(s);\r\n    }\r\n    \r\n    void marry(Person other)\r\n        //@ requires valid(null) \u0026*\u0026 other.valid(null);\r\n        //@ ensures valid(other) \u0026*\u0026 other.valid(this);\r\n    {\r\n        //@ open valid(null);\r\n        setSpouse0(other);\r\n        other.setSpouse(this);\r\n        //@ close valid(other);\r\n    }\r\n    \r\n    void divorce()\r\n        //@ requires valid(?other) \u0026*\u0026 other.valid(this);\r\n        //@ ensures valid(null) \u0026*\u0026 other.valid(null);\r\n    {\r\n        //@ open valid(other);\r\n        Person spouse = getSpouse0();\r\n        spouse.clearSpouse();\r\n        clearSpouse0();\r\n        //@ close valid(null);\r\n    }\r\n\r\n}\r\n\r\nclass Program {\r\n\r\n    public static void main(String[] args)\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        Person a = Person.create();\r\n        Person b = Person.create();\r\n        a.marry(b);\r\n        b.divorce();\r\n    }\r\n\r\n}",
        "name": "Spouse2.java",
        "path": "examples/java/Spouse2.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Spouse2.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 18,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid0(?s);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 19,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid0(s) \u0026*\u0026 result == s;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid0(null) \u0026*\u0026 other != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 29,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid0(other) \u0026*\u0026 ticket(other);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid0(?other) \u0026*\u0026 ticket(_);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 39,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid0(null) \u0026*\u0026 other != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 48,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(null) \u0026*\u0026 other.ticket(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 49,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(other) \u0026*\u0026 this.ticket(other);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 57,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?s) \u0026*\u0026 this.ticket(_);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 58,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(null) \u0026*\u0026 s.ticket(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 80,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?s) \u0026*\u0026 this.ticket(?s0);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 81,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(s) \u0026*\u0026 this.ticket(s0) \u0026*\u0026 s == s0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 89,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?s) \u0026*\u0026 s.valid(?ss);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 90,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(s) \u0026*\u0026 s.valid(ss) \u0026*\u0026 ss == this;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 99,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 100,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid0(null);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 117,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 118,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures result.valid(null);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 126,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?s);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 127,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(s) \u0026*\u0026 result == s;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 135,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(null) \u0026*\u0026 other.valid(null);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 136,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(other) \u0026*\u0026 other.valid(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 145,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?other) \u0026*\u0026 other.valid(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 146,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(null) \u0026*\u0026 other.valid(null);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 160,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 161,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import java.util.concurrent.*;\r\nimport verifast.*;\r\n\r\nclass Counter {\r\n    \r\n    int value;\r\n    //@ int c1;\r\n    //@ int c2;\r\n    \r\n}\r\n\r\n/*@\r\n\r\npredicate_ctor Counter(Counter counter)() =\r\n    counter.value |-\u003e ?value\r\n    \u0026*\u0026 [1/2]counter.c1 |-\u003e ?v1\r\n    \u0026*\u0026 [1/2]counter.c2 |-\u003e ?v2\r\n    \u0026*\u0026 value == v1 + v2;\r\n\r\n@*/\r\n\r\nfinal class Session1 implements Runnable {\r\n    \r\n    Counter counter;\r\n    Semaphore lock;\r\n    \r\n    //@ predicate pre() = [1/2]counter |-\u003e ?c \u0026*\u0026 [1/2]lock |-\u003e ?l \u0026*\u0026 semaphore_handle(l, Counter(c), 1/3, 0) \u0026*\u0026 [1/2]c.c1 |-\u003e 0;\r\n    //@ predicate post() = [1/2]counter |-\u003e ?c \u0026*\u0026 [1/2]lock |-\u003e ?l \u0026*\u0026 semaphore_handle(l, Counter(c), 1/3, 0) \u0026*\u0026 [1/2]c.c1 |-\u003e 1;\r\n    \r\n    public void run()\r\n        //@ requires pre();\r\n        //@ ensures post();\r\n    {\r\n        try {\r\n            this.runCore();\r\n        } catch (InterruptedException e) {\r\n            RuntimeException e0 = new RuntimeException(e);\r\n            throw e0;\r\n        }\r\n    }\r\n    \r\n    public void runCore() throws InterruptedException /*@ ensures true; @*/\r\n        //@ requires pre();\r\n        //@ ensures post();\r\n    {\r\n        lock.acquire();\r\n        //@ open Counter(counter)();\r\n        counter.value++;\r\n        //@ counter.c1++;\r\n        //@ close Counter(counter)();\r\n        lock.release();\r\n    }\r\n    \r\n}\r\n\r\nfinal class Session2 implements Runnable {\r\n    \r\n    Counter counter;\r\n    Semaphore lock;\r\n    \r\n    //@ predicate pre() = [1/2]counter |-\u003e ?c \u0026*\u0026 [1/2]lock |-\u003e ?l \u0026*\u0026 semaphore_handle(l, Counter(c), 1/3, 0) \u0026*\u0026 [1/2]c.c2 |-\u003e 0;\r\n    //@ predicate post() = [1/2]counter |-\u003e ?c \u0026*\u0026 [1/2]lock |-\u003e ?l \u0026*\u0026 semaphore_handle(l, Counter(c), 1/3, 0) \u0026*\u0026 [1/2]c.c2 |-\u003e 1;\r\n    \r\n    public void run()\r\n        //@ requires pre();\r\n        //@ ensures post();\r\n    {\r\n        try {\r\n            this.runCore();\r\n        } catch (InterruptedException e) {\r\n            RuntimeException e0 = new RuntimeException(e);\r\n            throw e0;\r\n        }\r\n    }\r\n    \r\n    public void runCore() throws InterruptedException /*@ ensures true; @*/\r\n        //@ requires pre();\r\n        //@ ensures post();\r\n    {\r\n        lock.acquire();\r\n        //@ open Counter(counter)();\r\n        counter.value++;\r\n        //@ counter.c2++;\r\n        //@ close Counter(counter)();\r\n        lock.release();\r\n    }\r\n    \r\n}\r\n\r\nclass Program {\r\n    public static void main(String[] args)\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        Counter c = new Counter();\r\n        //@ close Counter(c)();\r\n        //@ one_time(Counter(c));\r\n        Semaphore lock = new Semaphore(1);\r\n        //@ lock.splitHandle(1r, 1, 1r/3, 1);\r\n        //@ lock.splitHandle(2r/3, 0, 1r/3, 0);\r\n        \r\n        Session1 session1 = new Session1();\r\n        session1.counter = c;\r\n        session1.lock = lock;\r\n        JoinableRunnable session1Joinable = ThreadingHelper.createJoinableRunnable(session1);\r\n        //@ close session1.pre();\r\n        //@ session1Joinable.closeIt();\r\n        Thread thread1 = new Thread(session1Joinable);\r\n        thread1.start();\r\n        \r\n        Session2 session2 = new Session2();\r\n        session2.counter = c;\r\n        session2.lock = lock;\r\n        JoinableRunnable session2Joinable = ThreadingHelper.createJoinableRunnable(session2);\r\n        //@ close session2.pre();\r\n        //@ session2Joinable.closeIt();\r\n        Thread thread2 = new Thread(session2Joinable);\r\n        thread2.start();\r\n        \r\n        ThreadingHelper.join(thread1, session1Joinable);\r\n        //@ open session1.post();\r\n        ThreadingHelper.join(thread2, session2Joinable);\r\n        //@ open session2.post();\r\n        \r\n        //@ lock.mergeHandles(1r/3, 0, 1r/3, 0);\r\n        //@ lock.mergeHandles(1r/3, 1, 2r/3, 0);\r\n        //@ lock.destroy();\r\n        //@ open n_times(1, Counter(c));\r\n        //@ open Counter(c)();\r\n        \r\n        int sum = c.value;\r\n        assert(sum == 2);\r\n    }\r\n} ",
        "name": "Contrib.java",
        "path": "examples/java/Contrib.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Contrib.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 30,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 42,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 43,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 64,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 65,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 76,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 77,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 91,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 92,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class Counter {\r\n\r\n  int value;\r\n\r\n  Counter(int v)\r\n    //@ requires emp;\r\n    //@ ensures this.value |-\u003e v;\r\n  {\r\n    this.value=v;\r\n  }\r\n  Counter(Counter v)\r\n    //@ requires v.value |-\u003e ?t;\r\n    //@ ensures v.value |-\u003e t \u0026*\u0026 this.value |-\u003e t;\r\n  {\r\n    this.value=v.value;\r\n  }\r\n  Counter(int v,int b)\r\n    //@ requires emp;\r\n    //@ ensures this.value |-\u003e v+b;\r\n  {\r\n    this.value=v+b;\r\n  }\r\n    \r\n  void increment()\r\n    //@ requires this.value |-\u003e ?v;\r\n    //@ ensures this.value |-\u003e v + 1;\r\n  {\r\n    this.value = this.value + 1;\r\n  }\r\n  \r\n  void add(int x)\r\n    //@ requires this.value |-\u003e ?v;\r\n    //@ ensures this.value |-\u003e v + x;\r\n  {\r\n    this.value = this.value + x;\r\n  }\r\n  void add(Counter x)\r\n    //@ requires this.value |-\u003e ?v \u0026*\u0026 x.value |-\u003e ?v';\r\n    //@ ensures this.value |-\u003e v + v' \u0026*\u0026 x.value |-\u003e v';\r\n  {\r\n    add(x.value);\r\n  }\r\n  \r\n  static void swap(Counter c1, Counter c2)\r\n    //@ requires c1.value |-\u003e ?v1 \u0026*\u0026 c2.value |-\u003e ?v2;\r\n    //@ ensures c1.value |-\u003e v2 \u0026*\u0026 c2.value |-\u003e v1;\r\n  {\r\n    int tmp = c1.value;\r\n    c1.value = c2.value;\r\n    c2.value = tmp;\r\n  }\r\n\r\n  public static void main(String[] args)\r\n    //@ requires true;\r\n    //@ ensures true;\r\n  {\r\n    Counter c1 = new Counter(0);\r\n    Counter c2 = new Counter(5);\r\n    Counter c3 = new Counter(5,5);\r\n    Counter c4= new Counter(c2);\r\n    c1.increment();\r\n    Counter.swap(c1, c2);\r\n    int tmp = c2.value;\r\n    //@ assert tmp == 1;\r\n    tmp=c3.value;\r\n    //@ assert tmp==10;\r\n    tmp=c4.value;\r\n    int tmp2=c1.value;\r\n    //@ assert tmp==tmp2;\r\n    \r\n    c1.add(10);\r\n    tmp=c1.value;\r\n    //@ assert tmp==15;\r\n    \r\n    c1.add(c2);\r\n    tmp=c1.value;\r\n    //@ assert tmp==16;\r\n  }\r\n}\r\n",
        "name": "Counter.java",
        "path": "examples/java/Counter.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Counter.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires emp;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures this.value |-\u003e v;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires v.value |-\u003e ?t;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures v.value |-\u003e t \u0026*\u0026 this.value |-\u003e t;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires emp;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 18,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures this.value |-\u003e v+b;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 24,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires this.value |-\u003e ?v;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 25,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures this.value |-\u003e v + 1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires this.value |-\u003e ?v;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 32,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures this.value |-\u003e v + x;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 37,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires this.value |-\u003e ?v \u0026*\u0026 x.value |-\u003e ?v';\r"
        },
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures this.value |-\u003e v + v' \u0026*\u0026 x.value |-\u003e v';\r"
        },
        {
          "limitHit": false,
          "lineNumber": 44,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires c1.value |-\u003e ?v1 \u0026*\u0026 c2.value |-\u003e ?v2;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 45,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures c1.value |-\u003e v2 \u0026*\u0026 c2.value |-\u003e v1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 53,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 54,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Account {\r\n\r\n    int balance;\r\n    \r\n    //@ predicate valid(int balance) = this.balance |-\u003e balance;\r\n    \r\n    Account()\r\n        //@ requires true;\r\n        //@ ensures valid(0);\r\n    {\r\n        //@ close valid(0);\r\n    }\r\n    \r\n    int getBalance()\r\n        //@ requires valid(?b);\r\n        //@ ensures valid(b) \u0026*\u0026 result == b;\r\n    {\r\n        //@ open valid(b);\r\n        return balance;\r\n        //@ close valid(b);\r\n    }\r\n    \r\n    void deposit(int amount)\r\n        //@ requires valid(?b);\r\n        //@ ensures valid(b + amount);\r\n    {\r\n        //@ open valid(b);\r\n        balance += amount;\r\n        //@ close valid(_);\r\n    }\r\n    \r\n    void transferTo(Account target, int amount)\r\n        //@ requires this.valid(?b) \u0026*\u0026 target.valid(?bt);\r\n        //@ ensures this.valid(b - amount) \u0026*\u0026 target.valid(bt + amount);\r\n    {\r\n        deposit(-amount);\r\n        target.deposit(amount);\r\n    }\r\n\r\n}\r\n\r\nclass Program {\r\n\r\n    public static void main(String[] args)\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        Account a = new Account();\r\n        a.deposit(1000);\r\n        \r\n        Account b = new Account();\r\n        b.deposit(2000);\r\n        \r\n        a.transferTo(b, 500);\r\n        \r\n        int ba = a.getBalance();\r\n        int bb = b.getBalance();\r\n        assert ba == 500 \u0026\u0026 bb == 2500;\r\n    }\r\n\r\n}\r\n",
        "name": "Account.java",
        "path": "examples/java/Account.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Account.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(0);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?b);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(b) \u0026*\u0026 result == b;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 23,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?b);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 24,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(b + amount);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 32,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires this.valid(?b) \u0026*\u0026 target.valid(?bt);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 33,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures this.valid(b - amount) \u0026*\u0026 target.valid(bt + amount);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 44,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 45,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Program {\r\n    static short abs(short x)\r\n        //@ requires true;\r\n        //@ ensures 0 \u003c= result \u0026*\u0026 result == x || result == -x;\r\n    {\r\n        if (x \u003c 0) {\r\n            x = (short)-x;\r\n            return x;\r\n        } else {\r\n            return x;\r\n        }\r\n    }\r\n}\r\n",
        "name": "abs.java",
        "path": "javacard_tutorial/abs.java",
        "url": "/github.com/verifast/verifast/-/blob/javacard_tutorial/abs.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 2,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures 0 \u003c= result \u0026*\u0026 result == x || result == -x;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Program {\r\n    static short min(short x, short y, short z)\r\n        //@ requires true;\r\n        /*@\r\n        ensures\r\n            result \u003c= x \u0026\u0026 result \u003c= y \u0026\u0026 result \u003c= z \u0026\u0026\r\n            (result == x || result == y || result == z);\r\n        @*/\r\n    {\r\n        if (x \u003c y) {\r\n            if (x \u003c z) {\r\n                return x;\r\n            } else {\r\n                return z;\r\n            }\r\n        } else {\r\n            return y;\r\n        }\r\n    }\r\n}\r\n",
        "name": "min.java",
        "path": "javacard_tutorial/min.java",
        "url": "/github.com/verifast/verifast/-/blob/javacard_tutorial/min.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 2,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import java.io.*;\r\nimport java.util.*;\r\n\r\nclass Program {\r\n    static void readLinesIntoList(BufferedReader reader, List list)\r\n        //@ requires reader.Reader() \u0026*\u0026 list.List(_);\r\n        //@ ensures reader.Reader() \u0026*\u0026 list.List(_);\r\n    {\r\n        boolean repeat = true;\r\n        do\r\n            //@ invariant reader.Reader() \u0026*\u0026 list.List(_);\r\n        {\r\n            String line = reader.readLine();\r\n            if (line == null)\r\n                repeat = false;\r\n            else\r\n                list.add(line);\r\n        }\r\n        while (repeat);\r\n    }\r\n}",
        "name": "DoWhile.java",
        "path": "examples/java/DoWhile.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/DoWhile.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires reader.Reader() \u0026*\u0026 list.List(_);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures reader.Reader() \u0026*\u0026 list.List(_);\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class C {\r\n    int x;\r\n    \r\n    C()\r\n        //@ requires true;\r\n        //@ ensures C(0);\r\n    {\r\n        //@ close C(0);\r\n    }\r\n\r\n    //@ predicate C(int x) = this.x |-\u003e x;\r\n}\r\n\r\nclass D extends C {\r\n    int y;\r\n\r\n    D()\r\n        //@ requires true;\r\n        //@ ensures D(0, 0);\r\n    {\r\n        //@ close D(0, 0);\r\n    }\r\n    \r\n    /*@\r\n    \r\n    predicate C(int x) = D(x, _);\r\n    predicate D(int x, int y) = this.C(C.class)(x) \u0026*\u0026 this.y |-\u003e y;\r\n\r\n    lemma void castCToD()\r\n        requires C(?x);\r\n        ensures D(x, _);\r\n    {\r\n        open C(x);\r\n    }\r\n    \r\n    lemma void castDToC()\r\n        requires D(?x, _);\r\n        ensures C(x);\r\n    {\r\n        close C(_);\r\n    }\r\n    \r\n    @*/\r\n    \r\n    int getY()\r\n        //@ requires D(?x, ?y);\r\n        //@ ensures D(x, y) \u0026*\u0026 result == y;\r\n    {\r\n        //@ open D(x, y);\r\n        return this.y;\r\n        //@ close D(x, y);\r\n    }\r\n}\r\n\r\nclass E extends D {\r\n    int z;\r\n    \r\n    E()\r\n        //@ requires true;\r\n        //@ ensures E(0, 0, 0);\r\n    {\r\n        //@ close E(0, 0, 0);\r\n    }\r\n    \r\n    /*@\r\n\r\n    predicate C(int x) = E(x, _, _);\r\n    predicate D(int x, int y) = E(x, y, _);\r\n    predicate E(int x, int y, int z) = this.D(D.class)(x, y) \u0026*\u0026 this.z |-\u003e z;\r\n\r\n    lemma void castCToD()\r\n        requires C(?x);\r\n        ensures D(x, _);\r\n    {\r\n        open C(x);\r\n        close D(x, _);\r\n    }\r\n\r\n    lemma void castDToC()\r\n        requires D(?x, _);\r\n        ensures C(x);\r\n    {\r\n        open D(_, _);\r\n        close C(_);\r\n    }\r\n    \r\n    @*/\r\n    \r\n    int getY()\r\n        //@ requires D(?x, ?y);\r\n        //@ ensures D(x, y) \u0026*\u0026 result == y;\r\n    {\r\n        //@ open D(x, y);\r\n        //@ open E(x, y, _);\r\n        return super.getY();\r\n        //@ close E(x, y, _);\r\n        //@ close D(x, y);\r\n    }\r\n}\r\n\r\nclass Program {\r\n    static int getY(C c)\r\n        //@ requires c.C(?x);\r\n        //@ ensures c.C(x);\r\n    {\r\n        if (c instanceof D) {\r\n            D d = (D)c;\r\n            //@ d.castCToD();\r\n            return d.getY();\r\n            //@ d.castDToC();\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    static void test()\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        E e = new E();\r\n        //@ close e.C(_);\r\n        getY(e);\r\n    }\r\n}",
        "name": "Downcast.java",
        "path": "examples/java/Downcast.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Downcast.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures C(0);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 18,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures D(0, 0);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 45,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires D(?x, ?y);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 46,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures D(x, y) \u0026*\u0026 result == y;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 58,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 59,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures E(0, 0, 0);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 89,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires D(?x, ?y);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 90,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures D(x, y) \u0026*\u0026 result == y;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 102,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires c.C(?x);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 103,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures c.C(x);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 116,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 117,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package iterator;\r\n\r\ninterface Iterator {\r\n\r\n    //@ predicate valid(list\u003cObject\u003e xs);\r\n    \r\n    boolean hasNext();\r\n        //@ requires valid(?xs);\r\n        //@ ensures valid(xs) \u0026*\u0026 result == (xs != nil);\r\n\r\n    Object next();\r\n        //@ requires valid(?xs) \u0026*\u0026 xs != nil;\r\n        //@ ensures valid(tail(xs)) \u0026*\u0026 result == head(xs) \u0026*\u0026 result != null;\r\n\r\n}\r\n\r\n/*@\r\n\r\nfixpoint Object objects_last(list\u003cObject\u003e a) {\r\n    switch (a) {\r\n        case nil: return null;\r\n        case cons(x, xs): return x != null \u0026\u0026 xs == nil ? x : objects_last(xs);\r\n    }\r\n}\r\n\r\n@*/\r\n\r\nclass SingletonIterator implements Iterator {\r\n\r\n    Object value;\r\n    boolean done;\r\n\r\n    /*@\r\n    \r\n    predicate valid(list\u003cObject\u003e xs) =\r\n        value |-\u003e ?v \u0026*\u0026 v != null \u0026*\u0026 done |-\u003e ?d \u0026*\u0026 d ? xs == nil : xs == cons(v, nil);\r\n    \r\n    @*/\r\n    \r\n    public SingletonIterator(Object value)\r\n        //@ requires value != null;\r\n        //@ ensures valid(cons(value, nil));\r\n    {\r\n        this.value = value;\r\n        this.done = false;\r\n        //@ close valid(cons(value, nil));\r\n    }\r\n    \r\n    public boolean hasNext()\r\n        //@ requires valid(?xs);\r\n        //@ ensures valid(xs) \u0026*\u0026 result == (xs != nil);\r\n    {\r\n        //@ open valid(xs);\r\n        return !done;\r\n        //@ close valid(xs);\r\n    }\r\n    \r\n    public Object next()\r\n        //@ requires valid(?xs) \u0026*\u0026 xs != nil;\r\n        //@ ensures valid(tail(xs)) \u0026*\u0026 result == head(xs) \u0026*\u0026 result != null;\r\n    {\r\n        //@ open valid(xs);\r\n        done = true;\r\n        return value;\r\n        //@ close valid(nil);\r\n    }\r\n\r\n}\r\n\r\nclass IteratorUtil {\r\n\r\n    public static Object getLast(Iterator iterator)\r\n        //@ requires iterator.valid(?xs);\r\n        //@ ensures iterator.valid(nil) \u0026*\u0026 result == objects_last(xs);\r\n    {\r\n        Object value = null;\r\n        boolean more = iterator.hasNext();\r\n        while (more)\r\n            //@ invariant iterator.valid(?ys) \u0026*\u0026 more == (ys != nil) \u0026*\u0026 objects_last(cons(value, ys)) == objects_last(xs);\r\n        {\r\n            //@ switch (ys) { case nil: case cons(y, ys0): }\r\n            value = iterator.next();\r\n            more = iterator.hasNext();\r\n        }\r\n        return value;\r\n    }\r\n\r\n}\r\n\r\nclass Program {\r\n\r\n    public static void main(String[] args)\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        Object o = new Object();\r\n        SingletonIterator i = new SingletonIterator(o);\r\n        boolean before = i.hasNext();\r\n        assert(before);\r\n\r\n        Object last = IteratorUtil.getLast(i);\r\n        assert last == o;\r\n      \r\n        boolean after = i.hasNext();\r\n        assert(!after);\r\n    }\r\n\r\n}",
        "name": "Iterator.java",
        "path": "examples/java/Iterator.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Iterator.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?xs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(xs) \u0026*\u0026 result == (xs != nil);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?xs) \u0026*\u0026 xs != nil;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(tail(xs)) \u0026*\u0026 result == head(xs) \u0026*\u0026 result != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 40,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires value != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 41,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(cons(value, nil));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 49,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?xs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 50,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(xs) \u0026*\u0026 result == (xs != nil);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 58,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?xs) \u0026*\u0026 xs != nil;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 59,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(tail(xs)) \u0026*\u0026 result == head(xs) \u0026*\u0026 result != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 72,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires iterator.valid(?xs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 73,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures iterator.valid(nil) \u0026*\u0026 result == objects_last(xs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 92,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 93,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "/*@\r\nfixpoint int div(int x, int y) {\r\n  return x / y;\r\n}\r\n@*/\r\n\r\nclass Division {\r\n  int division_test(int nom, int denom) \r\n    //@ requires denom != 0 \u0026\u0026 !((nom == -2147483648) \u0026\u0026 (denom == -1));\r\n    //@ ensures result == nom / denom;\r\n  {\r\n    int tmp = nom / denom;\r\n    return tmp;\r\n  }\r\n  \r\n  void division_test2(int nom, int denom) \r\n    //@ requires denom != 0 \u0026\u0026 !((nom == -2147483648) \u0026\u0026 (denom == -1));\r\n    //@ ensures true;\r\n  {\r\n    int tmp = nom / denom;\r\n    int rest = nom % denom;\r\n    //@ assert denom*tmp + rest == nom;\r\n  }\r\n  \r\n  void bigwiseand_test(int x) \r\n    //@ requires 0 \u003c= x;\r\n    //@ ensures true;\r\n  {\r\n    int tmp = x \u0026 255;\r\n    //@ assert 255 \u003e= (x \u0026 255);\r\n  }\r\n  \r\n  int division_test_fail(int nom, int denom) \r\n    //@ requires true;\r\n    //@ ensures result == nom / denom;\r\n  {\r\n    int tmp = nom / denom; //~ should_fail\r\n    return tmp; //~allow_dead_code\r\n  }\r\n}",
        "name": "Division.java",
        "path": "examples/java/Division.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Division.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires denom != 0 \u0026\u0026 !((nom == -2147483648) \u0026\u0026 (denom == -1));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == nom / denom;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires denom != 0 \u0026\u0026 !((nom == -2147483648) \u0026\u0026 (denom == -1));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 25,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= x;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 26,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 33,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 34,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == nom / denom;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package foo;\r\n\r\nclass Bar {\r\n    public static final short BAR = (byte)0x103;\r\n    public static final short QUUX = (short) (Foo.FOO + BAR);\r\n    public static final short BLA = (short)QUUX;\r\n\r\n    private Bar() \r\n      //@ requires true;\r\n      //@ ensures true;\r\n    {\r\n      \r\n      this.m(Foo.FOO);\r\n    }\r\n    \r\n    public void m(int s) \r\n      //@ requires true;\r\n      //@ ensures true;\r\n    {\r\n    }\r\n        \r\n    public static void main(String[] args)\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        short tmp0 = 0;\r\n        tmp0 = BLA;\r\n        assert Foo.FOO == 12345;\r\n        assert BAR == 3;\r\n        assert QUUX == 12348;\r\n    }\r\n    \r\n}\r\n\r\nclass Foo {\r\n\r\n    private Foo() \r\n      //@ requires true;\r\n      //@ ensures true;\r\n    {\r\n    }\r\n    public static final int FOO = 12345;\r\n}\r\n\r\ninterface Baz {\r\n    int ONE = 1;\r\n    int TWO = 2;\r\n}\r\n\r\nclass BazUser1 {\r\n    static void user()\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        assert Baz.ONE == 1;\r\n    }\r\n}\r\n\r\nclass BazUser2 implements Baz {\r\n    void instanceMethod()\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        assert TWO == 2;\r\n    }\r\n    \r\n    static void staticMethod()\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        assert TWO == 2;\r\n    }\r\n}",
        "name": "Constants.java",
        "path": "examples/java/Constants.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Constants.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              6,
              13
            ]
          ],
          "preview": "      //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              6,
              12
            ]
          ],
          "preview": "      //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              6,
              13
            ]
          ],
          "preview": "      //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              6,
              12
            ]
          ],
          "preview": "      //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 22,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 23,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 37,
          "offsetAndLengths": [
            [
              6,
              13
            ]
          ],
          "preview": "      //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              6,
              12
            ]
          ],
          "preview": "      //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 51,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 52,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 60,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 61,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 67,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 68,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import java.util.*;\r\n\r\n/*@\r\n\r\nlemma_auto void length_append_auto\u003ct\u003e(list\u003ct\u003e xs, list\u003ct\u003e ys)\r\n    requires true;\r\n    ensures length(append(xs, ys)) == length(xs) + length(ys);\r\n{\r\n    length_append(xs, ys);\r\n}\r\n\r\nlemma_auto(length(drop(n, xs))) void length_drop_auto\u003ct\u003e(int n, list\u003ct\u003e xs)\r\n    requires 0 \u003c= n \u0026\u0026 n \u003c= length(xs);\r\n    ensures length(drop(n, xs)) == length(xs) - n;\r\n{\r\n    length_drop(n, xs);\r\n}\r\n\r\nlemma_auto void drop_drop_auto\u003ct\u003e(int m, int n, list\u003ct\u003e xs)\r\n    requires 0 \u003c= m \u0026\u0026 0 \u003c= n \u0026\u0026 m + n \u003c= length(xs);\r\n    ensures drop(m, drop(n, xs)) == drop(m + n, xs);\r\n{\r\n    drop_drop(m, n, xs);\r\n}\r\n\r\nfixpoint boolean descendingFrom(int x0, list\u003cint\u003e xs) {\r\n    switch (xs) {\r\n        case nil: return true;\r\n        case cons(x1, xs1): return x0 \u003e x1 \u0026\u0026 x1 \u003e= 0 \u0026\u0026 descendingFrom(x1, xs1);\r\n    }\r\n}\r\n\r\nlemma_auto void length_remove_nth\u003ct\u003e(int n, list\u003ct\u003e xs)\r\n    requires 0 \u003c= n \u0026\u0026 n \u003c length(xs);\r\n    ensures length(remove_nth(n, xs)) == length(xs) - 1;\r\n{\r\n    switch (xs) {\r\n        case nil:\r\n        case cons(x0, xs0):\r\n            if (n == 0) {\r\n            } else {\r\n                length_remove_nth(n - 1, xs0);\r\n            }\r\n    }\r\n}\r\n\r\nlemma void length_remove_nths(list\u003cint\u003e rs, list\u003cObject\u003e es)\r\n    requires descendingFrom(length(es), rs) == true;\r\n    ensures length(remove_nths(rs, es)) == length(es) - length(rs);\r\n{\r\n    switch (rs) {\r\n        case nil:\r\n        case cons(r, rs1):\r\n            length_remove_nth(r, es);\r\n            switch (rs1) { case nil: case cons(r1, rs2): }\r\n            length_remove_nths(rs1, remove_nth(r, es));\r\n    }\r\n}\r\n\r\nlemma void nth_remove_nth\u003ct\u003e(int i, int n, list\u003ct\u003e es)\r\n    requires 0 \u003c= n \u0026*\u0026 n \u003c i \u0026*\u0026 i \u003c length(es);\r\n    ensures nth(i, es) == nth(i - 1, remove_nth(n, es));\r\n{\r\n    switch (es) {\r\n        case nil:\r\n        case cons(e, es0):\r\n            if (n == 0) {\r\n            } else {\r\n                nth_remove_nth(i - 1, n - 1, es0);\r\n            }\r\n    }\r\n}\r\n\r\nlemma_auto void nth_remove_nth_0\u003ct\u003e(int i, int n, list\u003ct\u003e es)\r\n    requires 0 \u003c= n \u0026\u0026 n \u003c length(es) \u0026\u0026 0 \u003c= i \u0026\u0026 i + 1 \u003c length(es);\r\n    ensures nth(i, remove_nth(n, es)) == (i \u003c n ? nth(i, es) : nth(i + 1, es));\r\n{\r\n    switch (es) {\r\n        case nil:\r\n        case cons(e, es0):\r\n            if (i == 0) {\r\n            } else if (n == 0) {\r\n            } else {\r\n                nth_remove_nth_0(i - 1, n - 1, es0);\r\n            }\r\n    }\r\n}\r\n\r\nlemma void nth_remove_nths(int i, list\u003cint\u003e rs, list\u003cObject\u003e es)\r\n    requires length(es) \u003e i \u0026*\u0026 descendingFrom(i, rs) == true;\r\n    ensures nth(i, es) == nth(i - length(rs), remove_nths(rs, es));\r\n{\r\n    switch (rs) {\r\n        case nil:\r\n        case cons(r, rs1):\r\n            nth_remove_nth(i, r, es);\r\n            length_remove_nth(r, es);\r\n            switch (rs1) { case nil: case cons(r1, rs2): }\r\n            nth_remove_nths(i - 1, rs1, remove_nth(r, es));\r\n    }\r\n}\r\n\r\nlemma void remove_nth_remove_nth\u003ct\u003e(int i, int n, list\u003ct\u003e es)\r\n    requires 0 \u003c= n \u0026*\u0026 n \u003c i \u0026*\u0026 i \u003c length(es);\r\n    ensures remove_nth(n, remove_nth(i, es)) == remove_nth(i - 1, remove_nth(n, es));\r\n{\r\n    switch (es) {\r\n        case nil:\r\n        case cons(e0, es0):\r\n            if (n == 0) {\r\n            } else {\r\n                remove_nth_remove_nth(i - 1, n - 1, es0);\r\n            }\r\n    }\r\n}\r\n\r\nlemma void remove_nth_remove_nths(int i, list\u003cint\u003e rs, list\u003cObject\u003e es)\r\n    requires length(es) \u003e i \u0026*\u0026 descendingFrom(i, rs) == true;\r\n    ensures remove_nths(cons(i, rs), es) == remove_nth(i - length(rs), remove_nths(rs, es));\r\n{\r\n    switch (rs) {\r\n        case nil:\r\n        case cons(r0, rs0):\r\n            length_remove_nth(r0, es);\r\n            switch (rs0) { case nil: case cons(r1, rs1): }\r\n            remove_nth_remove_nths(i - 1, rs0, remove_nth(r0, es));\r\n            remove_nth_remove_nth(i, r0, es);\r\n    }\r\n}\r\n\r\n@*/\r\n    \r\nfinal class ArrayListIterator\u003cT\u003e implements Iterator\u003cT\u003e {\r\n    \r\n    ArrayList\u003cT\u003e list;\r\n    //@ real frac;\r\n    //@ list\u003cObject\u003e oldElements;\r\n    //@ list\u003cint\u003e removals;\r\n    //@ int nextRemoveIndex;\r\n    //@ boolean hasCurrentElement;\r\n    int index;\r\n    \r\n    /*@\r\n    \r\n    predicate Iterator(fixpoint(int, option\u003cObject\u003e) elements, option\u003cint\u003e currentIndex, int nextIndex) =\r\n        [_]list |-\u003e ?l \u0026*\u0026 [_]frac |-\u003e ?f \u0026*\u0026 [f]l.List(?es) \u0026*\u0026\r\n        [_]oldElements |-\u003e ?oes \u0026*\u0026 [1/2]removals |-\u003e ?rs \u0026*\u0026\r\n        elements == (seq_of_list)(oes) \u0026*\u0026\r\n        es == remove_nths(rs, oes) \u0026*\u0026\r\n        index |-\u003e ?i \u0026*\u0026 0 \u003c= i \u0026*\u0026 i \u003c= length(es) \u0026*\u0026\r\n        hasCurrentElement |-\u003e ?hce \u0026*\u0026\r\n        nextIndex == i + length(rs) \u0026*\u0026 nextIndex \u003c= length(oes) \u0026*\u0026\r\n        nextRemoveIndex |-\u003e ?nri \u0026*\u0026\r\n        currentIndex == (hce ? some(nri) : none) \u0026*\u0026\r\n        (hce ? nextIndex == nri + 1 \u0026*\u0026 length(rs) \u003c= nri : nextIndex == nri) \u0026*\u0026\r\n        f == 1 || rs == nil \u0026*\u0026\r\n        descendingFrom(nri, rs) == true;\r\n    \r\n    predicate Iterator_removals(list\u003cint\u003e indices) =\r\n        [_]frac |-\u003e 1 \u0026*\u0026 [1/2]removals |-\u003e indices;\r\n    \r\n    @*/\r\n    \r\n    ArrayListIterator(ArrayList\u003cT\u003e list)\r\n        //@ requires [?f]list.List(?es);\r\n        /*@ ensures Iterator((seq_of_list)(es), none, 0) \u0026*\u0026 (f == 1 ? Iterator_removals(nil) : true) \u0026*\u0026 \r\n                    [_]this.list |-\u003e list \u0026*\u0026 [_]oldElements |-\u003e es \u0026*\u0026 [_]frac |-\u003e f \u0026*\u0026\r\n                    Iterable_iterating(ArrayList.class)(list, es, f, this);\r\n        @*/\r\n    {\r\n        this.list = list;\r\n        //@ frac = f;\r\n        //@ oldElements = es;\r\n        //@ removals = nil;\r\n        //@ leak this.list |-\u003e _ \u0026*\u0026 frac |-\u003e _ \u0026*\u0026 oldElements |-\u003e _;\r\n        //@ close Iterable_iterating(ArrayList.class) (list, es, f, this);\r\n    }\r\n    \r\n    public boolean hasNext()\r\n        //@ requires Iterator(?es, ?c, ?n);\r\n        //@ ensures Iterator(es, c, n) \u0026*\u0026 result ? es(n) != none : es(n) == none; // Force case split.\r\n    {\r\n        return index \u003c list.size();\r\n        //@ switch (removals) { case nil: case cons(r, rs1): }\r\n        //@ length_remove_nths(removals, oldElements);\r\n        \r\n    }\r\n    \r\n    public T next()\r\n        //@ requires Iterator(?es, ?c, ?n) \u0026*\u0026 es(n) != none;\r\n        //@ ensures Iterator(es, some(n), n + 1) \u0026*\u0026 result == the(es(n));\r\n    {\r\n        //@ list.size_limits();\r\n        //@ switch (removals) { case nil: case cons(r, rs1): }\r\n        //@ length_remove_nths(removals, oldElements);\r\n        //@ assert [_]oldElements |-\u003e ?oes;\r\n        //@ seq_of_list_length(oes, n);\r\n        return list.get(index++);\r\n        //@ hasCurrentElement = true;\r\n        //@ nextRemoveIndex = n;\r\n        //@ nth_remove_nths(n, removals, oldElements);\r\n    }\r\n    \r\n    public void remove()\r\n        //@ requires Iterator(?es, ?c, ?n) \u0026*\u0026 Iterator_removals(?rs) \u0026*\u0026 c != none;\r\n        //@ ensures Iterator(es, none, n) \u0026*\u0026 Iterator_removals(cons(the(c), rs));\r\n    {\r\n        //@ open Iterator_removals(_);\r\n        list.remove(--index);\r\n        //@ removals = cons(the(c), rs);\r\n        //@ hasCurrentElement = false;\r\n        //@ nextRemoveIndex = n;\r\n        //@ remove_nth_remove_nths(the(c), rs, oldElements);\r\n        //@ length_remove_nths(cons(the(c), rs), oldElements);\r\n    }\r\n    \r\n}\r\n\r\n/*@\r\n\r\nlemma int list_neq_nth\u003ct\u003e(list\u003ct\u003e xs, list\u003ct\u003e ys)\r\n    requires length(xs) == length(ys) \u0026*\u0026 xs != ys;\r\n    ensures 0 \u003c= result \u0026*\u0026 result \u003c length(xs) \u0026*\u0026 nth(result, xs) != nth(result, ys);\r\n{\r\n    switch (xs) {\r\n        case nil:\r\n            switch (ys) { case nil: case cons(y0, ys0): }\r\n        case cons(x0, xs0):\r\n            switch (ys) {\r\n                case nil:\r\n                case cons(y0, ys0):\r\n                    if (x0 != y0) {\r\n                        return 0;\r\n                    } else {\r\n                        return list_neq_nth(xs0, ys0) + 1;\r\n                    }\r\n            }\r\n    }\r\n}\r\n\r\n@*/\r\n\r\n/*@\r\n\r\npredicate_family_instance Iterable_iterating(ArrayList.class)(ArrayList list, list\u003cObject\u003e elements, real frac, ArrayListIterator it) =\r\n    [_]it.list |-\u003e list \u0026*\u0026 [_]it.oldElements |-\u003e elements \u0026*\u0026 [_]it.frac |-\u003e frac \u0026*\u0026 it.getClass() == ArrayListIterator.class;\r\n\r\n@*/\r\n\r\nfinal class ArrayList\u003cT\u003e implements List\u003cT\u003e {\r\n\r\n    Object[] elements;\r\n    int size;\r\n    \r\n    /*@\r\n    predicate Iterable(list\u003cObject\u003e elements) =\r\n        List(elements);\r\n\r\n    predicate List(list\u003cObject\u003e elements) =\r\n        this.elements |-\u003e ?e \u0026*\u0026 this.size |-\u003e ?s \u0026*\u0026\r\n        array_slice(e, 0, s, elements) \u0026*\u0026\r\n        array_slice(e, s, e.length, _);\r\n    \r\n    lemma void listToIterable()\r\n        requires [?f]List(?es);\r\n        ensures  [f]Iterable(es);\r\n    {\r\n        close [f]Iterable(es);\r\n    }\r\n    \r\n    lemma void iterableToList()\r\n        requires [?f]Iterable(?es);\r\n        ensures  [f]List(es);\r\n    {\r\n        open [f]Iterable(es);\r\n    }\r\n    \r\n    @*/\r\n\r\n    public ArrayList()\r\n        //@ requires true;\r\n        //@ ensures List(nil);\r\n    {\r\n        elements = new Object[10];\r\n        //@ close Iterable(nil);\r\n        //@ iterableToList();\r\n    }\r\n    \r\n    public int size()\r\n        //@ requires [?f]List(?es);\r\n        //@ ensures [f]List(es) \u0026*\u0026 result == length(es);\r\n    {\r\n        //@ listToIterable();\r\n        return size;\r\n        //@ iterableToList();\r\n    }\r\n    \r\n    public T get(int index)\r\n        //@ requires [?f]List(?es) \u0026*\u0026 0 \u003c= index \u0026*\u0026 index \u003c length(es);\r\n        //@ ensures [f]List(es) \u0026*\u0026 result == nth(index, es);\r\n    {\r\n        return elements[index];\r\n    }\r\n    \r\n    public Iterator\u003cT\u003e iterator()\r\n        //@ requires [?f]Iterable(?es);\r\n        /*@\r\n        ensures\r\n            result.Iterator((seq_of_list)(es), none, 0) \u0026*\u0026\r\n            (f == 1 ? result.Iterator_removals(nil) : true) \u0026*\u0026\r\n            Iterable_iterating(this.getClass())(this, es, f, result);\r\n        @*/\r\n    {\r\n        //@ this.iterableToList();\r\n        ArrayListIterator\u003cT\u003e i = new ArrayListIterator\u003cT\u003e(this);\r\n        //@ close Iterable_iterating(ArrayList.class)(this, es, f, i);\r\n        return i;\r\n    }\r\n    \r\n    /*@\r\n    \r\n    lemma void destroyIterator()\r\n        requires Iterable_iterating(this.getClass())(this, ?es, 1, ?it) \u0026*\u0026 it.Iterator(_, _, _) \u0026*\u0026 it.Iterator_removals(?rs);\r\n        ensures Iterable(remove_nths(rs, es));\r\n    {\r\n        open Iterable_iterating(ArrayList.class)(_, _, _, ?iter);\r\n        open iter.Iterator(_, _, _);\r\n        open iter.Iterator_removals(_);\r\n        close List(remove_nths(rs, es));\r\n    }\r\n    \r\n    lemma void destroyIteratorFrac()\r\n        requires Iterable_iterating(this.getClass())(this, ?es, ?f, ?it) \u0026*\u0026 it.Iterator(_, _, _) \u0026*\u0026 f \u003c 1;\r\n        ensures [f]Iterable(es);\r\n    {\r\n        open Iterable_iterating(ArrayList.class)(_, _, _, ?iter);\r\n        open iter.Iterator(_, _, _);\r\n    }\r\n    \r\n    @*/\r\n\r\n    boolean add(T e)\r\n        //@ requires List(?es);\r\n        //@ ensures List(append(es, cons(e, nil))) \u0026*\u0026 result;\r\n    {\r\n        if (size == elements.length) {\r\n            Object[] newArray = new Object[2 * size + 1];\r\n            //@ close array_slice_dynamic(array_slice_Object, elements, 0, size, _);\r\n            //@ close array_slice_dynamic(array_slice_Object, newArray, 0, size, _);\r\n            //@ close arraycopy_pre(array_slice_Object, false, 1, elements, 0, size, _, newArray, 0);\r\n            System.arraycopy(elements, 0, newArray, 0, size);\r\n            //@ open arraycopy_post(_, _, _, _, _, _, _, _, _);\r\n            //@ open array_slice_dynamic(array_slice_Object, newArray, _, _, _);\r\n            elements = newArray;\r\n        }\r\n        elements[size++] = e;\r\n        return true;\r\n    }\r\n    \r\n    boolean addAll(Collection\u003cT\u003e other)\r\n        //@ requires List(?es) \u0026*\u0026 listIsCollection(?li, other) \u0026*\u0026 li.List(?other_es);\r\n        //@ ensures List(append(es, other_es)) \u0026*\u0026 li.List(other_es);\r\n    {\r\n        //@ open listIsCollection(li, other);\r\n        List l = (List) other;\r\n        int n = l.size();\r\n        //@ list\u003cObject\u003e ys = nil;\r\n        //@ list\u003cObject\u003e zs = other_es;\r\n        for (int i = 0; i \u003c n; i++)\r\n            //@ requires List(?xs) \u0026*\u0026 l.List(append(ys, zs)) \u0026*\u0026 length(ys) == i \u0026*\u0026 length(ys) + length(zs) == n \u0026*\u0026 switch (zs) { case nil: return true; case cons(h, t): return true; };\r\n            //@ ensures List(append(xs, old_zs)) \u0026*\u0026 l.List(append(old_ys, old_zs));\r\n        {\r\n            add(l.get(i));\r\n            //@ assert zs == cons(?h, ?t);\r\n            //@ append_assoc(ys, {h}, t);\r\n            //@ ys = append(ys, {h});\r\n            //@ zs = t;\r\n            //@ append_assoc(xs, {h}, t);\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    T remove(int index)\r\n        //@ requires List(?es) \u0026*\u0026 0 \u003c= index \u0026*\u0026 index \u003c length(es);\r\n        //@ ensures List(remove_nth(index, es)) \u0026*\u0026 result == nth(index, es);\r\n    {\r\n        T result = elements[index];\r\n        /*@\r\n        if (index + 1 == size) {\r\n            close array_slice_dynamic(array_slice_Object, elements, index + 1, index + 1, array_slice_Objects(nil));\r\n            close array_slice_dynamic(array_slice_Object, elements, index, index, array_slice_Objects(nil));\r\n            close arraycopy_pre(array_slice_Object, false, 1, elements, index + 1, 0, array_slice_Objects(nil), elements, index);\r\n        } else {\r\n            close array_slice_dynamic(array_slice_Object, elements, index, index + 1, _);\r\n            assert elements |-\u003e ?e \u0026*\u0026 size |-\u003e ?s \u0026*\u0026 array_slice(e, index + 1, s, ?elems);\r\n            close array_slice_dynamic(array_slice_Object, elements, index + 1, size - 1, _);\r\n            close array_slice_dynamic(array_slice_Object, elements, size - 1, size, _);\r\n            close arraycopy_pre(array_slice_Object, true, 1, elements, index + 1, size - index - 1, array_slice_Objects(elems), elements, index);\r\n        }\r\n        @*/\r\n        System.arraycopy(elements, index + 1, elements, index, size - index - 1);\r\n        //@ open arraycopy_post(_, _, _, _, _, _, _, _, _);\r\n        //@ open array_slice_dynamic(_, _, _, _, _);\r\n        //@ open array_slice_dynamic(_, _, _, _, _);\r\n        elements[--size] = null;\r\n        return result;\r\n        //@ remove_nth_take_drop(es, index);\r\n    }\r\n    \r\n    /*@\r\n    \r\n    lemma void size_limits()\r\n        requires [?f]List(?es);\r\n        ensures [f]List(es) \u0026*\u0026 length(es) \u003c= Integer.MAX_VALUE;\r\n    {\r\n        open List(es);\r\n    }\r\n    \r\n    @*/\r\n    \r\n}",
        "name": "ArrayList.java",
        "path": "examples/java/ArrayList.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/ArrayList.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 164,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [?f]list.List(?es);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 179,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires Iterator(?es, ?c, ?n);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 180,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Iterator(es, c, n) \u0026*\u0026 result ? es(n) != none : es(n) == none; // Force case split.\r"
        },
        {
          "limitHit": false,
          "lineNumber": 189,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires Iterator(?es, ?c, ?n) \u0026*\u0026 es(n) != none;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 190,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Iterator(es, some(n), n + 1) \u0026*\u0026 result == the(es(n));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 204,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires Iterator(?es, ?c, ?n) \u0026*\u0026 Iterator_removals(?rs) \u0026*\u0026 c != none;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 205,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Iterator(es, none, n) \u0026*\u0026 Iterator_removals(cons(the(c), rs));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 280,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 281,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(nil);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 289,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [?f]List(?es);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 290,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [f]List(es) \u0026*\u0026 result == length(es);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 298,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [?f]List(?es) \u0026*\u0026 0 \u003c= index \u0026*\u0026 index \u003c length(es);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 299,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [f]List(es) \u0026*\u0026 result == nth(index, es);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 305,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [?f]Iterable(?es);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 342,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List(?es);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 343,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(append(es, cons(e, nil))) \u0026*\u0026 result;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 360,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List(?es) \u0026*\u0026 listIsCollection(?li, other) \u0026*\u0026 li.List(?other_es);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 361,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(append(es, other_es)) \u0026*\u0026 li.List(other_es);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 369,
          "offsetAndLengths": [
            [
              12,
              13
            ]
          ],
          "preview": "            //@ requires List(?xs) \u0026*\u0026 l.List(append(ys, zs)) \u0026*\u0026 length(ys) == i \u0026*\u0026 length(ys) + length(zs) == n \u0026*\u0026 switch (zs) { case nil: return true; case cons(h, t): return true; };\r"
        },
        {
          "limitHit": false,
          "lineNumber": 370,
          "offsetAndLengths": [
            [
              12,
              12
            ]
          ],
          "preview": "            //@ ensures List(append(xs, old_zs)) \u0026*\u0026 l.List(append(old_ys, old_zs));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 383,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List(?es) \u0026*\u0026 0 \u003c= index \u0026*\u0026 index \u003c length(es);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 384,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(remove_nth(index, es)) \u0026*\u0026 result == nth(index, es);\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "//@ predicate started(Thread t);\r\n\r\nclass Thread {\r\n\r\n    //@ predicate pre() = true;\r\n    //@ predicate post() = true;\r\n\r\n    Thread()\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n    }\r\n\r\n    void start()\r\n        //@ requires this.pre();\r\n        //@ ensures started(this);\r\n    {\r\n        throw new NullPointerException();\r\n    }\r\n\r\n    void run()\r\n        //@ requires pre();\r\n        //@ ensures post();\r\n    {\r\n        //@ open pre();\r\n        //@ close post();\r\n    }\r\n\r\n    void join()\r\n        //@ requires started(this);\r\n        //@ ensures this.post();\r\n    {\r\n        throw new NullPointerException();\r\n    }\r\n\r\n}\r\n\r\nclass MyThread extends Thread {\r\n\r\n    int x;\r\n\r\n    MyThread()\r\n        //@ requires true;\r\n        //@ ensures pre();\r\n    {\r\n        //@ close pre();\r\n    }\r\n\r\n    //@ predicate pre() = x |-\u003e 0;\r\n    //@ predicate post() = x |-\u003e 1;\r\n\r\n    void run()\r\n        //@ requires pre();\r\n        //@ ensures post();\r\n    {\r\n        //@ open pre();\r\n        x++;\r\n        //@ close post();\r\n    }\r\n\r\n    int getResult()\r\n        //@ requires post();\r\n        //@ ensures x |-\u003e 1 \u0026*\u0026 result == 1;\r\n    {\r\n        //@ open post();\r\n        return x;\r\n    }\r\n}\r\n\r\nclass Program {\r\n\r\n    public static void main(String[] args)\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        MyThread t = new MyThread();\r\n        t.start();\r\n        t.join();\r\n        int result = t.getResult();\r\n        assert result == 1;\r\n    }\r\n\r\n}\r\n",
        "name": "ThreadRun.java",
        "path": "examples/java/ThreadRun.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/ThreadRun.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires this.pre();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures started(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 22,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 29,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires started(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 30,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures this.post();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 42,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 43,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures pre();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 52,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 53,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 61,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires post();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 62,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures x |-\u003e 1 \u0026*\u0026 result == 1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 72,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 73,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Purse {\r\n    short balance;\r\n}\r\n\r\nclass Program {\r\n    Purse p1, p2;\r\n    \r\n    void deposit(Purse p, short amount)\r\n        //@ requires Purse_balance(p, ?b);\r\n        //@ ensures Purse_balance(p, (short)(b + amount));\r\n    {\r\n        p.balance += amount;\r\n    }\r\n    \r\n    Program()\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        p1 = new Purse();\r\n        deposit(p1, (short)100);\r\n        p2 = new Purse();\r\n        deposit(p2, (short)50);\r\n        \r\n        short b1 = p1.balance;\r\n        short b2 = p2.balance;\r\n        assert b1 == 100 \u0026\u0026 b2 == 50;\r\n    }\r\n}",
        "name": "purse.java",
        "path": "javacard_tutorial/purse.java",
        "url": "/github.com/verifast/verifast/-/blob/javacard_tutorial/purse.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires Purse_balance(p, ?b);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Purse_balance(p, (short)(b + amount));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package chat;\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\n/*@\r\n\r\npredicate room(Room room) =\r\n    room.members |-\u003e ?membersList \u0026*\u0026 membersList != null \u0026*\u0026 foreach\u003cMember\u003e(?members, member) \u0026*\u0026 membersList.List(members);\r\n\r\n@*/\r\n\r\npublic class Room {\r\n    List\u003cMember\u003e members;\r\n\r\n    public Room()\r\n        //@ requires emp;\r\n        //@ ensures room(this);\r\n    {\r\n        List\u003cMember\u003e a = new ArrayList\u003c \u003e();\r\n        this.members = a;\r\n        //@ close foreach\u003cMember\u003e(nil, member);\r\n        //@ close room(this);\r\n    }\r\n    \r\n    public boolean has_member(String nick)\r\n        //@ requires room(this) \u0026*\u0026 nick != null;\r\n        //@ ensures room(this);\r\n    {\r\n        //@ open room(this);\r\n        //@ assert foreach(?members, _);\r\n        List\u003cMember\u003e membersList = this.members;\r\n        //@ membersList.listToIterable();\r\n        Iterator\u003cMember\u003e iter = membersList.iterator();\r\n        boolean hasMember = false;\r\n        boolean hasNext = iter.hasNext();\r\n        while (hasNext \u0026\u0026 !hasMember)\r\n            /*@\r\n            invariant\r\n                iter.Iterator((seq_of_list)(members), _, ?i) \u0026*\u0026 Iterable_iterating(membersList.getClass())(membersList, members, 1, iter) \u0026*\u0026 foreach(members, @member)\r\n                \u0026*\u0026 hasNext == (i \u003c length(members)) \u0026*\u0026 0 \u003c= i \u0026*\u0026 i \u003c= length(members);\r\n            @*/\r\n        {\r\n            Member member = iter.next();\r\n            //@ foreach_remove\u003cMember\u003e(member, members);\r\n            //@ open member(member);\r\n            hasMember = nick.equals(member.nick);\r\n            //@ close member(member);\r\n            //@ foreach_unremove\u003cMember\u003e(member, members);\r\n            hasNext = iter.hasNext();\r\n        }\r\n        //@ membersList.destroyIterator();\r\n        //@ membersList.iterableToList();\r\n        //@ close room(this);\r\n        return hasMember;\r\n    }\r\n    \r\n    public void broadcast_message(String message) throws IOException /*@ ensures true; @*/\r\n        //@ requires room(this) \u0026*\u0026 message != null;\r\n        //@ ensures room(this);\r\n    {\r\n        //@ open room(this);\r\n        //@ assert foreach(?members0, _);\r\n        List\u003cMember\u003e membersList = this.members;\r\n        //@ membersList.listToIterable();\r\n        Iterator\u003cMember\u003e iter = membersList.iterator();\r\n        boolean hasNext = iter.hasNext();\r\n        //@ length_nonnegative(members0);\r\n        while (hasNext)\r\n            /*@\r\n            invariant\r\n                foreach\u003cMember\u003e(?members, @member) \u0026*\u0026 iter.Iterator((seq_of_list)(members), _, ?i) \u0026*\u0026 Iterable_iterating(membersList.getClass())(membersList, members, 1, iter)\r\n                \u0026*\u0026 hasNext == (i \u003c length(members)) \u0026*\u0026 0 \u003c= i \u0026*\u0026 i \u003c= length(members);\r\n            @*/\r\n        {\r\n            Member member = iter.next();\r\n            //@ mem_nth(i, members);\r\n            //@ foreach_remove\u003cMember\u003e(member, members);\r\n            //@ open member(member);\r\n            Writer writer = member.writer;\r\n            writer.write(message);\r\n            writer.write(\"\\r\\n\");\r\n            writer.flush();\r\n            //@ close member(member);\r\n            //@ foreach_unremove\u003cMember\u003e(member, members);\r\n            hasNext = iter.hasNext();\r\n        }\r\n        //@ membersList.destroyIterator();\r\n        //@ membersList.iterableToList();\r\n        //@ close room(this);\r\n    }\r\n}",
        "name": "Room.java",
        "path": "examples/java/chat/Room.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/chat/Room.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires emp;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures room(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 26,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires room(this) \u0026*\u0026 nick != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures room(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 58,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires room(this) \u0026*\u0026 message != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 59,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures room(this);\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "//@ predicate a(boolean x; int y) = x ? b(0, 0, 0, y) : y == 0;\r\n//@ predicate b\u003ct1, t2\u003e(t1 x, t1 y, t2 z1; t2 z2) = x == y ? c\u003ct1, t2\u003e(x, z2) : z2 == z1;\r\n//@ predicate c\u003ctp1, tp2\u003e(tp1 x; tp2 y);\r\n\r\n//@ predicate n(;);\r\n//@ predicate p(;) = [1/2]n();\r\n\r\nclass Automation {\r\n  void test1() \r\n    //@ requires a(true, 5);\r\n    //@ ensures true;\r\n  {\r\n    //@ assert c(0, 5);\r\n  }\r\n  \r\n  void test2()\r\n    //@ requires p();\r\n    //@ ensures true;\r\n  {\r\n     //@ assert [1/2]n();\r\n  }\r\n}\r\n\r\n/*@\r\npredicate_family cell(Class c)(Cell c;);\r\n\r\npredicate_family_instance cell(CellImpl.class)(CellImpl c) = c.value |-\u003e _;\r\npredicate_family_instance cell(BackupCell.class)(BackupCell c) = cell(CellImpl.class)(c);\r\npredicate_family_instance cell(BackupCellWrapper.class)(BackupCellWrapper c) = c.b |-\u003e ?b \u0026*\u0026 b ? c.myvalue |-\u003e _ : cell(BackupCell.class)(c);\r\n@*/\r\ninterface Cell {\r\n}\r\n\r\nclass CellImpl implements Cell {\r\n  int value;\r\n}\r\n\r\nclass BackupCell extends CellImpl {\r\n}\r\n\r\nclass BackupCellWrapper extends CellImpl {\r\n  boolean b;\r\n  int myvalue;\r\n}\r\n\r\nclass Test {\r\n  void test1(CellImpl c) \r\n    //@ requires cell(BackupCell.class)(c);\r\n    //@ ensures true;\r\n  {\r\n    c.value = 5;\r\n  }\r\n  \r\n  void test2(BackupCellWrapper c) \r\n    //@ requires cell(BackupCellWrapper.class)(c);\r\n    //@ ensures true;\r\n  {\r\n    if(! c.b) {\r\n      c.value = 5;\r\n    } else {\r\n      c.myvalue = 10;\r\n    }\r\n  }\r\n}\r\n",
        "name": "Automation.java",
        "path": "examples/java/Automation.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Automation.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires a(true, 5);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires p();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 47,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires cell(BackupCell.class)(c);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 48,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 54,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires cell(BackupCellWrapper.class)(c);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 55,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class MyException extends Exception {\r\n}\r\n\r\nclass YourException extends Exception {\r\n}\r\n\r\nclass Program {\r\n\r\n  void test() throws MyException /*@ ensures true; @*/\r\n    //@ requires true;\r\n    //@ ensures false;\r\n  {\r\n    throw new MyException();\r\n  }\r\n  \r\n  void throwsMyException(boolean thrw) throws MyException /*@ ensures thrw == true; @*/\r\n    //@ requires true;\r\n    //@ ensures thrw == false;\r\n  {\r\n    if(thrw) {\r\n      throw new MyException();\r\n    }\r\n  }\r\n  \r\n  void test2() throws YourException /*@ ensures true; @*/\r\n    //@ requires true;\r\n    //@ ensures false;\r\n  {\r\n    try {\r\n      throwsMyException(true);\r\n    } catch(MyException e) {\r\n      throw new YourException();\r\n    }\r\n  }\r\n  \r\n  void test3() throws YourException /*@ ensures true; @*/\r\n    //@ requires true;\r\n    //@ ensures true;\r\n  {\r\n    try {\r\n      throwsMyException(true);\r\n    } catch(MyException e) {\r\n    }\r\n  }\r\n  \r\n  void test4()\r\n    //@ requires true;\r\n    //@ ensures true;\r\n  {\r\n    try {\r\n      throw new MyException();\r\n    } catch(YourException e) {\r\n      assert(false);\r\n    } catch(MyException e) {\r\n    }\r\n  } \r\n}\r\n\r\nclass Super {\r\n  void m(int i) throws MyException /*@ ensures true; @*/\r\n    //@ requires true;\r\n    //@ ensures true;\r\n  {\r\n  }\r\n}\r\n\r\nclass Sub extends Super {\r\n  void m(int i) throws MyException /*@ ensures i == 0; @*/\r\n    //@ requires true;\r\n    //@ ensures true;\r\n  {\r\n  }\r\n}",
        "name": "Exceptions.java",
        "path": "examples/java/Exceptions.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Exceptions.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures false;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures thrw == false;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 25,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 26,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures false;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 36,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 37,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 46,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 47,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 60,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 61,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 68,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 69,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import java.util.Arrays;\n\n/*@\n\nfixpoint int power(int n, nat e) {\n    switch (e) {\n        case zero: return 1;\n        case succ(e0): return n * pow(n, e0);\n    }\n}\n\ninductive bintree = leaf(int) | node(bintree, bintree);\n\nfixpoint bintree bintree_of_list(nat n, list\u003cint\u003e xs) {\n    switch (n) {\n        case zero: return leaf(head(xs));\n        case succ(n0): return node(bintree_of_list(n0, take(length(xs) / 2, xs)), bintree_of_list(n0, drop(length(xs) / 2, xs)));\n    }\n}\n\nlemma void note(boolean b)\n    requires b;\n    ensures b;\n{\n}\n\nlemma void pow2_gt_zero(nat n)\n    requires true;\n    ensures 0 \u003c pow(2, n);\n{\n    switch (n) {\n        case zero:\n        case succ(n0):\n            pow2_gt_zero(n0);\n    }\n}\n\nlemma void flatten_bintree_of_list(nat n, list\u003cint\u003e xs)\n    requires length(xs) == pow(2, n);\n    ensures flatten(bintree_of_list(n, xs)) == xs;\n{\n    switch (n) {\n        case zero:\n            switch (xs) { case nil: case cons(x0, xs0): }\n        case succ(n0):\n            pow2_gt_zero(n);\n            append_take_drop(length(xs) / 2, xs);\n            flatten_bintree_of_list(n0, take(length(xs) / 2, xs));\n            //assume(length(xs) - length(xs) / 2 == length(xs) / 2);\n            length_drop(length(xs) / 2, xs);\n            assert length(drop(length(xs) / 2, xs)) == length(xs) / 2;\n            flatten_bintree_of_list(n0, drop(length(xs) / 2, xs));\n    }\n}\n\nfixpoint list\u003cint\u003e flatten(bintree t) {\n    switch (t) {\n        case leaf(n): return cons(n, nil);\n        case node(t1, t2): return append(flatten(t1), flatten(t2));\n    }\n}\n\npredicate array_tree0(int[] a, int left, int right, bintree values) =\n    0 \u003c= left \u0026*\u0026 left \u003c right \u0026*\u0026\n    right \u003e left + 1 ?\n        array_tree0(a, left - (right - left) / 2, left, ?lvalues) \u0026*\u0026\n        array_tree0(a, right - (right - left) / 2, right, ?rvalues) \u0026*\u0026\n        values == node(lvalues, rvalues) \u0026*\u0026\n        right - left == (right - left) / 2 * 2\n    :\n        array_element(a, left, ?l) \u0026*\u0026 array_element(a, right, ?r) \u0026*\u0026 values == node(leaf(l), leaf(r)) \u0026*\u0026\n        right == left + 1;\n\nlemma void even_lemma(int x)\n    requires x == x / 2 * 2;\n    ensures x - x / 2 == x / 2;\n{\n}\n\nlemma void array_slice_to_array_tree0(nat n, int[] a, int start, int end)\n    requires array_slice\u003cint\u003e(a, start, end, ?vs) \u0026*\u0026 length(vs) == pow(2, succ(n));\n    ensures array_tree0(a, start + (end - start) / 2 - 1, end - 1, bintree_of_list(succ(n), vs));\n{\n    switch (n) {\n        case zero:\n            switch (vs) { case nil: case cons(h, t): switch (t) { case nil: assert true; case cons(th, tt):\n                assert tt == nil;\n                assert take(length(vs) / 2, vs) == cons(h, nil);\n                assert drop(length(vs) / 2, vs) == cons(th, nil);\n                assert bintree_of_list(succ(zero), vs) == node(leaf(h), leaf(th));\n                \n            } }\n            close array_tree0(a, start + (end - start) / 2 - 1, end - 1, bintree_of_list(succ(n), vs));\n        case succ(n0):\n            assert length(take(length(vs) / 2, vs)) == pow(2, n);\n            array_slice_to_array_tree0(n0, a, start, start + (end - start) / 2);\n            assert start + (end - start) / 2 - start == length(vs) / 2;\n            assert length(vs) / 2 == pow(2, n);\n            assert length(vs) \u003e= (end - start) / 2;\n            assert end - start == (end - start) / 2 * 2;\n            note(end - start == (end - start) / 2 * 2);\n            even_lemma(end - start);\n            assert 0 \u003c= (end - start) / 2;\n            length_drop((end - start) / 2, vs);\n            assert length(drop((end - start) / 2, vs)) == (end - start) - (end - start) / 2;\n            assert length(drop((end - start) / 2, vs)) == pow(2, n);\n            assert length(drop((end - start) / 2, drop(0, vs))) == pow(2, n);\n            array_slice_to_array_tree0(n0, a, start + (end - start) / 2, end);\n            pow2_gt_zero(n0);\n            assert 0 \u003c (end - start) / 2;\n            assert end == start + (end - start) / 2 * 2;\n            note(end == start + (end - start) / 2 * 2);\n            assert end - start - (end - start) / 2 \u003e= 2;\n            assert end \u003e= (start + (end - start) / 2) + 2;\n            assert end - 1 \u003e (start + (end - start) / 2 - 1) + 1;\n            close array_tree0(a, start + (end - start) / 2 - 1, end - 1, bintree_of_list(succ(n), vs));\n    }\n}\n\nfixpoint int treesum(bintree t) {\n    switch (t) {\n        case leaf(n): return n;\n        case node(n1, n2): return treesum(n1) + treesum(n2);\n    }\n}\n\nfixpoint bintree getleft(bintree t) {\n    switch (t) {\n        case leaf(n): return t;\n        case node(t1, t2): return t1;\n    }\n}\n\nfixpoint bintree getright(bintree t) {\n    switch (t) {\n        case leaf(n): return t;\n        case node(t1, t2): return t2;\n    }\n}\n\nfixpoint boolean isleaf(bintree t) {\n    switch (t) {\n        case leaf(n): return true;\n        case node(t1, t2): return false;\n    }\n}\n\npredicate array_tree1(int[] a, int left, int right, bintree values) =\n    right \u003e left + 1 ?\n        array_tree1(a, left - (right - left) / 2, left, ?lvalues) \u0026*\u0026 array_element(a, left, treesum(lvalues)) \u0026*\u0026\n        array_tree1(a, right - (right - left) / 2, right, ?rvalues) \u0026*\u0026\n        values == node(lvalues, rvalues) \u0026*\u0026\n        right - left == (right - left) / 2 * 2\n    :\n        array_element(a, left, ?l) \u0026*\u0026 getleft(values) == leaf(l) \u0026*\u0026 isleaf(getright(values)) == true \u0026*\u0026 !isleaf(values) \u0026*\u0026\n        right == left + 1;\n\npredicate array_tree2(int[] a, int left, int right, int leftSum, bintree values) =\n    right \u003e left + 1 ?\n        array_tree2(a, left - (right - left) / 2, left, leftSum, ?lvalues) \u0026*\u0026\n        array_tree2(a, right - (right - left) / 2, right, leftSum + treesum(lvalues), ?rvalues) \u0026*\u0026\n        values == node(lvalues, rvalues) \u0026*\u0026\n        right - left == (right - left) / 2 * 2\n    :\n        array_element(a, left, leftSum) \u0026*\u0026 array_element(a, right, ?r) \u0026*\u0026 getleft(values) == leaf(r - leftSum) \u0026*\u0026 !isleaf(values) \u0026*\u0026 isleaf(getright(values)) == true \u0026*\u0026\n        right == left + 1;\n\nfixpoint list\u003cint\u003e prefixSums(int leftSum, bintree b) {\n    switch (b) {\n        case leaf(n): return cons(leftSum, nil);\n        case node(t1, t2): return append(prefixSums(leftSum, t1), prefixSums(leftSum + treesum(t1), t2));\n    }\n}\n\nfixpoint list\u003cint\u003e list_prefixSums(int leftSum, list\u003cint\u003e xs) {\n    switch (xs) {\n        case nil: return nil;\n        case cons(x0, xs0): return cons(leftSum, list_prefixSums(leftSum + x0, xs0));\n    }\n}\n\nfixpoint int sum(list\u003cint\u003e xs) {\n    switch (xs) {\n        case nil: return 0;\n        case cons(x0, xs0): return x0 + sum(xs0);\n    }\n}\n\nlemma void sum_append(list\u003cint\u003e xs, list\u003cint\u003e ys)\n    requires true;\n    ensures sum(append(xs, ys)) == sum(xs) + sum(ys);\n{\n    switch (xs) {\n        case nil:\n        case cons(x0, xs0):\n            sum_append(xs0, ys);\n    }\n}\n\nlemma void sum_flatten(bintree b)\n    requires true;\n    ensures sum(flatten(b)) == treesum(b);\n{\n    switch (b) {\n        case leaf(n):\n        case node(b1, b2):\n            sum_flatten(b1);\n            sum_flatten(b2);\n            sum_append(flatten(b1), flatten(b2));\n    }\n}\n\nlemma void list_prefixSums_append(int leftSum, list\u003cint\u003e xs, list\u003cint\u003e ys)\n    requires true;\n    ensures list_prefixSums(leftSum, append(xs, ys)) == append(list_prefixSums(leftSum, xs), list_prefixSums(leftSum + sum(xs), ys));\n{\n    switch (xs) {\n        case nil:\n        case cons(x0, xs0):\n            list_prefixSums_append(leftSum + x0, xs0, ys);\n    }\n}\n\nlemma void list_prefixSums_flatten(int leftSum, bintree b)\n    requires true;\n    ensures prefixSums(leftSum, b) == list_prefixSums(leftSum, flatten(b));\n{\n    switch (b) {\n        case leaf(n):\n        case node(b1, b2):\n            list_prefixSums_flatten(leftSum, b1);\n            list_prefixSums_flatten(leftSum + treesum(b1), b2);\n            sum_flatten(b1);\n            list_prefixSums_append(leftSum, flatten(b1), flatten(b2));\n    }\n}\n\nlemma void array_tree2_prefixsums()\n    requires array_tree2(?a, ?left, ?right, ?leftSum, ?values);\n    ensures array_slice(a, left + 1 - (right - left), right + 1, prefixSums(leftSum, values));\n{\n    open array_tree2(_, _, _, _, _);\n    if (right \u003e left + 1) {\n        array_tree2_prefixsums();\n        array_tree2_prefixsums();\n    } else {\n        assert right == left + 1;\n        switch (values) {\n            case leaf(n): assert true;\n            case node(t1, t2):\n                switch (t2) {\n                    case leaf (m): assert true;\n                    case node(t21, t22): assert true;\n                }\n        }\n    }\n}\n\n@*/\n\nclass PrefixSumRec {\n\n    private int[] a;\n\n    PrefixSumRec(int [] a)\n        //@ requires true;\n        //@ ensures this.a |-\u003e a;\n    {\n\tthis.a = a;\n    }\n\n\n    public void upsweep(int left, int right)\n        //@ requires a |-\u003e ?a_ \u0026*\u0026 array_tree0(a_, left, right, ?values);\n        //@ ensures a |-\u003e a_ \u0026*\u0026 array_tree1(a_, left, right, values) \u0026*\u0026 array_element(a_, right, treesum(values));\n    {\n        //@ open array_tree0(_, _, _, _);\n        if (right \u003e left+1) {\n            int space = right - left;\n            upsweep(left-space/2,left);\n            upsweep(right-space/2,right);\n        }\n        a[right] = a[left]+a[right];\n        //@ close array_tree1(a_, left, right, values);\n    }\n    \n\n    public void downsweep(int left, int right)\n        //@ requires a |-\u003e ?a_ \u0026*\u0026 array_tree1(a_, left, right, ?values) \u0026*\u0026 array_element(a_, right, ?leftSum);\n        //@ ensures a |-\u003e a_ \u0026*\u0026 array_tree2(a_, left, right, leftSum, values);\n    {\n        //@ open array_tree1(_, _, _, _);\n        int tmp = a[right];\n        a[right] = a[right] + a[left];\n        a[left] = tmp;\n        if (right \u003e left+1) {\n            int space = right - left;\n            downsweep(left-space/2,left);\n            downsweep(right-space/2,right);\n        }\n        //@ close array_tree2(a_, left, right, leftSum, values);\n    }\n    \n    public static void prefixsums(int[] a)\n        //@ requires array_slice(a, 0, a.length, ?vs) \u0026*\u0026 exists\u003cnat\u003e(?n) \u0026*\u0026 length(vs) == pow(2, succ(n));\n        //@ ensures array_slice(a, 0, a.length, list_prefixSums(0, vs));\n    {\n        int left = a.length / 2 - 1;\n        int right = a.length - 1;\n        PrefixSumRec p = new PrefixSumRec(a);\n        //@ array_slice_to_array_tree0(n, a, 0, a.length);\n        p.upsweep(left, right);\n        a[a.length - 1]=0;\n        p.downsweep(left, right);\n        //@ array_tree2_prefixsums();\n        //@ flatten_bintree_of_list(succ(n), vs);\n        //@ list_prefixSums_flatten(0, bintree_of_list(succ(n), vs));\n    }\n    \n    public static void main (String [] args)\n        //@ requires true;\n        //@ ensures true;\n    {\n        int [] a = {3,1,7,0,4,1,6,3};\n        //@ close exists(succ(succ(zero)));\n        prefixsums(a);\n        //@ assert a[..] |-\u003e {0,3,4,11,11,15,16,22};\n    }\n\n}\n",
        "name": "problem2.java",
        "path": "examples/fm2012/problem2.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/fm2012/problem2.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 265,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 266,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures this.a |-\u003e a;"
        },
        {
          "limitHit": false,
          "lineNumber": 273,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires a |-\u003e ?a_ \u0026*\u0026 array_tree0(a_, left, right, ?values);"
        },
        {
          "limitHit": false,
          "lineNumber": 274,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures a |-\u003e a_ \u0026*\u0026 array_tree1(a_, left, right, values) \u0026*\u0026 array_element(a_, right, treesum(values));"
        },
        {
          "limitHit": false,
          "lineNumber": 288,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires a |-\u003e ?a_ \u0026*\u0026 array_tree1(a_, left, right, ?values) \u0026*\u0026 array_element(a_, right, ?leftSum);"
        },
        {
          "limitHit": false,
          "lineNumber": 289,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures a |-\u003e a_ \u0026*\u0026 array_tree2(a_, left, right, leftSum, values);"
        },
        {
          "limitHit": false,
          "lineNumber": 304,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires array_slice(a, 0, a.length, ?vs) \u0026*\u0026 exists\u003cnat\u003e(?n) \u0026*\u0026 length(vs) == pow(2, succ(n));"
        },
        {
          "limitHit": false,
          "lineNumber": 305,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures array_slice(a, 0, a.length, list_prefixSums(0, vs));"
        },
        {
          "limitHit": false,
          "lineNumber": 320,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 321,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "interface I {\r\n}\r\n\r\nclass A implements I {\r\n}\r\n\r\nclass B extends A {\r\n}\r\n\r\nclass Program {\r\n  void test(A[] a) \r\n    //@ requires true;\r\n    //@ ensures true;\r\n  {\r\n    if(! (a instanceof B[])) {\r\n    }\r\n    \r\n    if(a instanceof I[]) {\r\n    }\r\n  }\r\n}",
        "name": "InstanceOf.java",
        "path": "examples/java/InstanceOf.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/InstanceOf.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class A {\r\n  int x;\r\n\r\n  public int m(int y) \r\n    //@ requires valid(?v) \u0026*\u0026 0 \u003c= y;\r\n    //@ ensures valid(y) \u0026*\u0026 result == y;\r\n  {\r\n    //@ open valid(v);\r\n    x = y;\r\n    //@ close valid(y);\r\n    return y;\r\n  }\r\n\r\n  //@ predicate valid(int v) = this.x |-\u003e v \u0026*\u0026 0 \u003c= v;\r\n}\r\n\r\nclass B extends A {\r\n  //@ predicate valid(int v) = this.x |-\u003e v \u0026*\u0026 0 \u003c= v;\r\n\r\n  public int m(int y) \r\n    //@ requires valid(?v) \u0026*\u0026 0 \u003c= y;\r\n    //@ ensures valid(y) \u0026*\u0026 result == y;\r\n  {\r\n    //@ open valid(v);\r\n    //@ close valid(A.class)(v);\r\n    int tmp = super.m(y);\r\n   //@ open valid(A.class)(y);\r\n   //@ close valid(y);\r\n   return tmp;\r\n  }\r\n}",
        "name": "SuperCalls.java",
        "path": "examples/java/SuperCalls.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/SuperCalls.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires valid(?v) \u0026*\u0026 0 \u003c= y;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures valid(y) \u0026*\u0026 result == y;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires valid(?v) \u0026*\u0026 0 \u003c= y;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures valid(y) \u0026*\u0026 result == y;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class InitTest {\r\n    static void test2()\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        int[] xs = new int[100];\r\n        //@ assert array_slice(xs, 0, 100, ?elems);\r\n        int x = xs[50];\r\n        assert x == 0;\r\n        test3(xs);\r\n    }\r\n    \r\n    static void test3(int[] xs)\r\n        //@ requires array_slice(xs, 60, 70, ?elems) \u0026*\u0026 all_eq(elems, 0) == true;\r\n        //@ ensures true;\r\n    {\r\n    }\r\n}\r\n",
        "name": "ArraysAuto.java",
        "path": "examples/java/ArraysAuto.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/ArraysAuto.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 2,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires array_slice(xs, 60, 70, ?elems) \u0026*\u0026 all_eq(elems, 0) == true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class HelloWorld \n{\n  public static void main(String[] args) \n    //@ requires System_out(?o) \u0026*\u0026 o != null;\n    //@ ensures true; \n  {\n    System.out.println(\"Hello, World\");\n  }\n}\n",
        "name": "HelloWorld.java",
        "path": "examples/java/HelloWorld.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/HelloWorld.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires System_out(?o) \u0026*\u0026 o != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true; "
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Program {\r\n    static short min(short x, short y, short z)\r\n        //@ requires true;\r\n        /*@\r\n        ensures\r\n            result \u003c= x \u0026*\u0026 result \u003c= y \u0026*\u0026 result \u003c= z \u0026*\u0026\r\n            (result == x || result == y || result == z);\r\n        @*/\r\n    {\r\n        if (x \u003c y) {\r\n            if (x \u003c z) {\r\n                return x;\r\n            } else {\r\n                return z;\r\n            }\r\n        } else {\r\n            return y;\r\n        }\r\n    }\r\n}\r\n",
        "name": "minsep.java",
        "path": "javacard_tutorial/minsep.java",
        "url": "/github.com/verifast/verifast/-/blob/javacard_tutorial/minsep.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 2,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Program {\r\n    static void rotate(byte[] xs, short start, short end)\r\n        //@ requires array_slice(xs, start, end, _);\r\n        //@ ensures array_slice(xs, start, end, _);\r\n    {\r\n        if (start \u003e= end - 1)\r\n            return;\r\n        byte last = xs[end - 1];\r\n        for (short i = start; i \u003c end - 1; i++)\r\n            //@ invariant array_slice(xs, start, end, _) \u0026*\u0026 start \u003c= i;\r\n        {\r\n            xs[i + 1] = xs[i];\r\n        }\r\n        xs[start] = last;\r\n    }\r\n}",
        "name": "rotate.java",
        "path": "javacard_tutorial/rotate.java",
        "url": "/github.com/verifast/verifast/-/blob/javacard_tutorial/rotate.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 2,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires array_slice(xs, start, end, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures array_slice(xs, start, end, _);\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Foo {\r\n\r\n    int x;\r\n    short y;\r\n    byte z;\r\n    Object o;\r\n    Object[] p;\r\n\r\n}\r\n\r\nclass Bar extends Foo {\r\n\r\n    int xx;\r\n\r\n}\r\n\r\nclass Program {\r\n\r\n    public static void doAssert(boolean b)\r\n        //@ requires b;\r\n        //@ ensures true;\r\n    {\r\n        assert b;\r\n    }\r\n\r\n    public static void main(String[] args)\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        Bar b = new Bar();\r\n        Foo f = b;\r\n        \r\n        doAssert(f.x == 0);\r\n        doAssert(f.y == 0);\r\n        doAssert(f.z == 0);\r\n        doAssert(f.o == null);\r\n        doAssert(f.p == null);\r\n        doAssert(b.xx == 0);\r\n    }\r\n\r\n}",
        "name": "DefaultCtor.java",
        "path": "examples/java/DefaultCtor.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/DefaultCtor.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 19,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires b;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 26,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "final class Person {\r\n\r\n    private Person spouse;\r\n\r\n    /*@\r\n    \r\n    predicate valid(Person spouse) =\r\n        [1/2]this.spouse |-\u003e spouse \u0026*\u0026 spouse == null ? [1/2]this.spouse |-\u003e null : [1/2]spouse.spouse |-\u003e this;\r\n    \r\n    public lemma void spouse_symm()\r\n        requires valid(?s) \u0026*\u0026 s.valid(?ss);\r\n        ensures valid(s) \u0026*\u0026 s.valid(ss) \u0026*\u0026 ss == this;\r\n    {\r\n        open valid(s);\r\n        open s.valid(ss);\r\n        close s.valid(ss);\r\n        close valid(s);\r\n    }\r\n    \r\n    @*/\r\n\r\n    public Person()\r\n        //@ requires true;\r\n        //@ ensures valid(null);\r\n    {\r\n        //@ close valid(null);\r\n    }\r\n    \r\n    public Person getSpouse()\r\n        //@ requires valid(?s);\r\n        //@ ensures valid(s) \u0026*\u0026 result == s;\r\n    {\r\n        //@ open valid(s);\r\n        return spouse;\r\n        //@ close valid(s);\r\n    }\r\n    \r\n    void marry(Person other)\r\n        //@ requires valid(null) \u0026*\u0026 other.valid(null);\r\n        //@ ensures valid(other) \u0026*\u0026 other.valid(this);\r\n    {\r\n        //@ open valid(null);\r\n        //@ open other.valid(null);\r\n        spouse = other;\r\n        other.spouse = this;\r\n        //@ close other.valid(this);\r\n        //@ close valid(other);\r\n    }\r\n    \r\n    void divorce()\r\n        //@ requires valid(?other) \u0026*\u0026 other.valid(?ss);\r\n        //@ ensures valid(null) \u0026*\u0026 other.valid(null) \u0026*\u0026 ss == this;\r\n    {\r\n        //@ open valid(other);\r\n        //@ open other.valid(ss);\r\n        spouse.spouse = null;\r\n        spouse = null;\r\n        //@ close other.valid(null);\r\n        //@ close valid(null);\r\n    }\r\n\r\n}\r\n\r\nclass Program {\r\n\r\n    public static void foo(Person a, Person b)\r\n        //@ requires a.valid(?aSpouse_) \u0026*\u0026 b.valid(?bSpouse_);\r\n        //@ ensures a.valid(aSpouse_) \u0026*\u0026 b.valid(bSpouse_);\r\n    {\r\n        Person aSpouse = a.getSpouse();\r\n        Person bSpouse = b.getSpouse();\r\n        if (aSpouse == b) {\r\n            //@ a.spouse_symm();\r\n            assert bSpouse == a;\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args)\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        Person a = new Person();\r\n        Person b = new Person();\r\n        a.marry(b);\r\n        foo(a, b);\r\n        b.divorce();\r\n    }\r\n\r\n}",
        "name": "SpouseFinal.java",
        "path": "examples/java/SpouseFinal.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/SpouseFinal.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 22,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 23,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(null);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 29,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?s);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 30,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(s) \u0026*\u0026 result == s;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(null) \u0026*\u0026 other.valid(null);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 39,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(other) \u0026*\u0026 other.valid(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 50,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?other) \u0026*\u0026 other.valid(?ss);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 51,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(null) \u0026*\u0026 other.valid(null) \u0026*\u0026 ss == this;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 66,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires a.valid(?aSpouse_) \u0026*\u0026 b.valid(?bSpouse_);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 67,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures a.valid(aSpouse_) \u0026*\u0026 b.valid(bSpouse_);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 78,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 79,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package chat;\r\n\r\nimport java.io.*;\r\nimport java.net.*;\r\nimport java.util.*;\r\n\r\n/*@\r\n\r\npredicate member(Member member) =\r\n    member.nick |-\u003e ?nick \u0026*\u0026 [1/2]member.writer |-\u003e ?writer \u0026*\u0026 writer != null \u0026*\u0026 writer.Writer();\r\n\r\nlemma void member_distinct(Member m1,Member m2)\r\n    requires member(m1) \u0026*\u0026 member(m2);\r\n    ensures member(m1) \u0026*\u0026 member(m2) \u0026*\u0026 m1 != m2;\r\n{\r\n    open member(m1);\r\n    open member(m2);\r\n    close member(m2);\r\n    close member(m1);\r\n}\r\n\r\nlemma void foreach_member_not_contains(list\u003cMember\u003e members, Member member)\r\n    requires foreach(members, @member) \u0026*\u0026 member(member);\r\n    ensures foreach(members, @member) \u0026*\u0026 member(member) \u0026*\u0026 !mem\u003cObject\u003e(member, members);\r\n{\r\n    switch (members) {\r\n        case nil:\r\n        case cons(m, ms):\r\n            open foreach(members, @member);\r\n            member_distinct(m, member);\r\n            foreach_member_not_contains(ms, member);\r\n            close foreach(members, @member);\r\n    }\r\n}\r\n\r\n@*/\r\n\r\nclass Member {\r\n    String nick;\r\n    Writer writer;\r\n    \r\n    public Member(String nick, Writer writer)\r\n        //@ requires writer != null \u0026*\u0026 writer.Writer();\r\n        //@ ensures member(this) \u0026*\u0026 [1/2]this.writer |-\u003e writer;\r\n    {\r\n        this.nick = nick;\r\n        this.writer = writer;\r\n        //@ close member(this);\r\n    }\r\n}\r\n",
        "name": "Member.java",
        "path": "examples/java/chat/Member.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/chat/Member.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 42,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires writer != null \u0026*\u0026 writer.Writer();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 43,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures member(this) \u0026*\u0026 [1/2]this.writer |-\u003e writer;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package chatbot;\r\n\r\nimport java.io.*;\r\nimport java.net.*;\r\n\r\npublic class Bot {\r\n    public static void main(String[] args) throws IOException /*@ ensures true; @*/\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        Socket s = new Socket(\"localhost\", 12345);\r\n      \r\n        InputStream in = s.getInputStream();\r\n        InputStreamReader reader0 = new InputStreamReader(in);\r\n        BufferedReader r = new BufferedReader(reader0);\r\n        OutputStream out = s.getOutputStream();\r\n        OutputStreamWriter writer0 = new OutputStreamWriter(out);\r\n        Writer w = writer0;\r\n\r\n        r.readLine();\r\n        r.readLine();\r\n        r.readLine();\r\n        \r\n        w.write(\"BoT\\r\\n\");\r\n        w.flush();\r\n        \r\n        while (true)\r\n            //@ invariant r.Reader() \u0026*\u0026 w.Writer();\r\n        {\r\n            String line = r.readLine();\r\n            if (line == null)\r\n                break;\r\n            int index = line.indexOf(\" says: \");\r\n            if (index \u003e -1) {\r\n                String nick = line.substring(0, index);\r\n                int length = line.length();\r\n                String text = line.substring(index + 7, length);\r\n                boolean isSelf = nick.equals(\"BoT\");\r\n                if (!isSelf) {\r\n                    boolean isHello = text.equals(\"!hello\");\r\n                    if (isHello) {\r\n                        w.write(\"Hello \");\r\n                        w.write(nick);\r\n                        w.write(\"!\\r\\n\");\r\n                        w.flush();\r\n                    } else {\r\n                        boolean isQuit = text.equals(\"!quit\");\r\n                        if (isQuit) {\r\n                            w.write(\"Byebye!\\r\\n\");\r\n                            w.flush();\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        s.shutdownOutput();\r\n        while (true)\r\n            //@ invariant r.Reader();\r\n        {\r\n            String line = r.readLine();\r\n            if (line == null)\r\n                break;\r\n        }\r\n        \r\n        //@ r.destroy();\r\n        //@ reader0.destroy();\r\n        //@ writer0.destroy();\r\n        s.close();\r\n    }\r\n}",
        "name": "Bot.java",
        "path": "examples/java/chatbot/Bot.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/chatbot/Bot.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Arrays;\n\n// Contains examples on how to work with generics in VeriFast.\n\npublic class GenericClass\u003cT\u003e{\n\tpublic T field;\n\tpublic GenericClass(T f)\n\t//@ requires true;\n\t//@ ensures this.field |-\u003e f;\n\t{\n\t\tfield = f;\n\t}\n\t\n\tpublic T add(T arg)\n\t//@ requires this.field |-\u003e ?f;\n\t//@ ensures this.field |-\u003e arg;\n\t{\n\t\tfield = arg;\n\t\treturn field;\n\t}\n\t\n\tpublic T get()\n\t//@ requires this.field |-\u003e ?f;\n\t//@ ensures this.field |-\u003e f;\n\t{\n\t\treturn field;\n\t}\n}\n\npublic class Foo\u003cT\u003e {\n\tpublic Foo(T arg)\n\t//@ requires true;\n\t//@ ensures true;\n\t{\n\t\tGenericClass\u003cT\u003e b = new GenericClass\u003cT\u003e(arg);\n\t}\n}\n\n\n/*\n\tProper method overrides\n*/\n// Case A: Interface implements interface\npublic interface Parent\u003cA,B\u003e{\n\tpublic A get1(A arg1);\n\tpublic B get2();\n}\n\npublic interface Child\u003cC,D\u003e extends Parent\u003cD,C\u003e{\n\tpublic D get1(D arg1);\n\tpublic C get2();\n}\n// Case B: Class implements interface\npublic class ChildClass\u003cC,D\u003e implements Parent\u003cD,C\u003e{\n\tpublic D get1(D arg1) {return null;}\n\tpublic C get2() {return null;}\n}\n\n// Case C: Class extends class\npublic abstract class AbstractParentClass\u003cA,B\u003e {\n\tpublic abstract A get1(A arg1);\n}\npublic class ChildClassInheritance\u003cC,D\u003e extends AbstractParentClass\u003cC,D\u003e{\n\tpublic C get1(C arg1){return null;}\n}\n\npublic class HelloWorld \n{\n  public static GenericClass\u003cGenericClass\u003cFoo\u003e \u003e genericInstance;\n  \n  public static void main(String[] args) \n    //@ requires true;\n    //@ ensures true; \n  {\n    String[] sentence = {\"Hello\", \"World\"};\n    List\u003cString\u003e sentenceList = Arrays.\u003cString\u003easList(sentence);\n    Foo\u003cString\u003e foo = new Foo\u003cString\u003e(\"test\");\n    GenericClass\u003cString\u003e simple = new GenericClass\u003cString\u003e(\"Example\");\n    GenericClass\u003cGenericClass\u003cString\u003e \u003e nested = new GenericClass\u003cGenericClass\u003cString\u003e \u003e(new GenericClass\u003cString\u003e(\"foo\"));\n    nested.add(new GenericClass\u003cString\u003e(\"hello\"));\n    GenericClass\u003cString\u003e s = nested.get();   // no cast\n    \n    List\u003cString\u003e l = new ArrayList\u003c \u003e();\n    l.add(\"foo\");\n    String abba = l.get(0);\n  }\n}\n",
        "name": "GenericClass.java",
        "path": "examples/java/GenericClass.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/GenericClass.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 73,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 74,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true; "
        },
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures this.field |-\u003e f;"
        },
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires this.field |-\u003e ?f;"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures this.field |-\u003e arg;"
        },
        {
          "limitHit": false,
          "lineNumber": 24,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires this.field |-\u003e ?f;"
        },
        {
          "limitHit": false,
          "lineNumber": 25,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures this.field |-\u003e f;"
        },
        {
          "limitHit": false,
          "lineNumber": 33,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 34,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class LimitsTest {\r\n    static void test(byte[] xs, byte[] ys)\r\n        //@ requires xs[0..10] |-\u003e _ \u0026*\u0026 ys[0] |-\u003e _;\r\n        //@ ensures true;\r\n    {\r\n        int x = xs[0];\r\n        assert -128 \u003c= x \u0026\u0026 x \u003c= 127;\r\n        int y = ys[0];\r\n        assert -128 \u003c= y \u0026\u0026 y \u003c= 127;\r\n    }\r\n}\r\n\r\nclass AutoSliceUpcastTest {\r\n    static void foo(Object[] xs)\r\n        //@ requires [?f]array_slice(xs, 0, xs.length, ?elems);\r\n        //@ ensures [f]array_slice(xs, 0, xs.length, elems);\r\n    {\r\n    }\r\n    \r\n    static void bar(Integer[] xs)\r\n        //@ requires [_]xs[..] |-\u003e ?elems;\r\n        //@ ensures [_]xs[..] |-\u003e elems;\r\n    {\r\n        // Here, an auto-upcast of the array_slice chunk happens.\r\n        // This leaks half of the fraction (to prevent assignment, which may raise ArrayStoreException).\r\n        // Only makes sense for read-only arrays.\r\n        foo(xs);\r\n    }\r\n}\r\n    \r\nclass AutoSliceUpcastTest1 {\r\n    static void foo(Object[] xs)\r\n        //@ requires [?f]xs[..] |-\u003e ?elems;\r\n        //@ ensures [f]xs[..] |-\u003e elems;\r\n    {\r\n    }\r\n    \r\n    static void bar(Integer[] xs)\r\n        //@ requires [_]xs[..] |-\u003e ?elems;\r\n        //@ ensures [_]xs[..] |-\u003e elems;\r\n    {\r\n        // Here, an auto-upcast of the array_slice chunk happens.\r\n        // This leaks half of the fraction (to prevent assignment, which may raise ArrayStoreException).\r\n        // Only makes sense for read-only arrays.\r\n        foo(xs);\r\n    }\r\n}\r\n\r\nclass InitTest {\r\n    static void test()\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        int[] xs = new int[] { 1, 2, 3 };\r\n        assert xs.length == 3;\r\n        int x = xs[0];\r\n        assert x == 1;\r\n        x = xs[1];\r\n        assert x == 2;\r\n        x = xs[2];\r\n        assert x == 3;\r\n    }\r\n}\r\n\r\nclass Incrementor {\r\n    static void increment(int[] xs, int i)\r\n        //@ requires xs[i] |-\u003e ?n;\r\n        //@ ensures xs[i] |-\u003e n + 1;\r\n    {\r\n        xs[i]++;\r\n    }\r\n}\r\n\r\nclass Person {\r\n    int age;\r\n}\r\n\r\n//@ predicate person(int minAge, Person person; int age) = person.age |-\u003e age \u0026*\u0026 minAge \u003c= age;\r\n\r\nclass Persons {\r\n    Person[] persons;\r\n    \r\n    void processBirthday(int i)\r\n        //@ requires this.persons |-\u003e ?persons \u0026*\u0026 array_slice_deep(persons, 0, persons.length, person, 18, _, _) \u0026*\u0026 0 \u003c= i \u0026*\u0026 i \u003c persons.length;\r\n        //@ ensures this.persons |-\u003e persons \u0026*\u0026 array_slice_deep(persons, 0, persons.length, person, 18, _, _);\r\n    {\r\n        Person p = this.persons[i];\r\n        p.age++;\r\n    }\r\n}\r\n\r\n//@ predicate record(int recordLength, Object record; unit value) = array_slice\u003cbyte\u003e(^record, 0, recordLength, _) \u0026*\u0026 value == unit;\r\n\r\n/*@\r\n\r\nlemma void all_eq_take\u003ct\u003e(int n, list\u003ct\u003e xs, t x)\r\n    requires 0 \u003c= n \u0026*\u0026 n \u003c= length(xs) \u0026*\u0026 all_eq(xs, x) == true;\r\n    ensures all_eq(take(n, xs), x) == true;\r\n{\r\n    switch (xs) {\r\n        case nil:\r\n        case cons(x0, xs0):\r\n            if (n == 0) {\r\n            } else {\r\n                all_eq_take(n - 1, xs0, x);\r\n            }\r\n    }\r\n}\r\n\r\n@*/\r\n\r\nclass ArrayTest {\r\n    static void test(Object[] a, int i)\r\n      /*@\r\n      requires\r\n          0 \u003c= i \u0026*\u0026\r\n          a[0..i + 10] |-\u003e ?l \u0026*\u0026\r\n          a[i + 10..i + 20] |-\u003e ?l2 \u0026*\u0026\r\n          a[i + 20..i + 35] |-\u003e ?l3;\r\n      @*/\r\n      /*@\r\n      ensures\r\n          a[i..i + 30] |-\u003e append(drop(i,l), append(l2, take(10,l3))) \u0026*\u0026\r\n          a[0..i] |-\u003e take(i, l) \u0026*\u0026\r\n          a[i + 30..i + 35] |-\u003e drop(10, l3);\r\n      @*/\r\n    {\r\n    }\r\n    \r\n    static void testDeep(Object[] a, int i)\r\n      /*@\r\n      requires\r\n          0 \u003c= i \u0026*\u0026\r\n          array_slice_deep(a, 0, i + 10, ?p, ?info, ?elems1, ?vs1) \u0026*\u0026\r\n          array_slice_deep(a, i + 10, i + 20, p, info, ?elems2, ?vs2) \u0026*\u0026\r\n          array_slice_deep(a, i + 20, i + 35, p, info, ?elems3, ?vs3);\r\n      @*/\r\n      /*@\r\n      ensures\r\n          array_slice_deep(a, i, i + 30, p, info, append(drop(i, elems1), append(elems2, take(10, elems3))), append(drop(i, vs1), append(vs2, take(10, vs3)))) \u0026*\u0026\r\n          array_slice_deep(a, 0, i, p, info, take(i, elems1), take(i, vs1)) \u0026*\u0026\r\n          array_slice_deep(a, i + 30, i + 35, p, info, drop(10, elems3), drop(10, vs3));\r\n      @*/\r\n    {\r\n    }\r\n    \r\n    static void deleteRecord(Object[] records, int recordLength, int i)\r\n        /*@\r\n        requires\r\n            array_slice_deep(records, 0, records.length, record, recordLength, ?rs, _) \u0026*\u0026\r\n            0 \u003c= i \u0026*\u0026 i \u003c records.length \u0026*\u0026 0 \u003c recordLength;\r\n        @*/\r\n        //@ ensures array_slice_deep(records, 0, records.length, record, recordLength, _, _);\r\n    {\r\n        Object record0 = records[i];\r\n        byte[] record = (byte[])record0;\r\n        record[recordLength - 1] = 0;\r\n    }\r\n    \r\n    static Object[] createRecords(int count, int recordLength)\r\n        //@ requires 0 \u003c= count \u0026*\u0026 0 \u003c= recordLength;\r\n        //@ ensures array_slice_deep(result, 0, result.length, record, recordLength, _, _);\r\n    {\r\n        Object[] records = new Object[count];\r\n        int i = 0;\r\n        while (i \u003c count)\r\n            //@ invariant 0 \u003c= i \u0026*\u0026 i \u003c= count \u0026*\u0026 array_slice_deep(records, 0, i, record, recordLength, _, _) \u0026*\u0026 records[i..] |-\u003e ?elems \u0026*\u0026 all_eq(elems, null) == true;\r\n        {\r\n            Object tmp = records[i];\r\n            assert tmp == null;\r\n            records[i] = new byte[recordLength];\r\n            i++;\r\n        }\r\n        return records;\r\n    }\r\n\r\n    static Object[] createRecords2(int count, int recordLength)\r\n        //@ requires 0 \u003c= count \u0026*\u0026 0 \u003c= recordLength;\r\n        //@ ensures array_slice_deep(result, 0, result.length, record, recordLength, _, _);\r\n    {\r\n        Object[] records = new Object[count];\r\n        int i = count;\r\n        while (0 \u003c i)\r\n            //@ invariant 0 \u003c= i \u0026*\u0026 i \u003c= count \u0026*\u0026 array_slice_deep(records, i, count, record, recordLength, _, _) \u0026*\u0026 records[..i] |-\u003e ?elems \u0026*\u0026 all_eq(elems, null) == true;\r\n        {\r\n            i--;\r\n            Object tmp = records[i];\r\n            assert tmp == null;\r\n            records[i] = new byte[recordLength];\r\n            //@ all_eq_take(i, elems, null);\r\n        }\r\n        return records;\r\n    }\r\n}",
        "name": "ArraysManual.java",
        "path": "examples/java/ArraysManual.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/ArraysManual.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 2,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires xs[0..10] |-\u003e _ \u0026*\u0026 ys[0] |-\u003e _;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [?f]array_slice(xs, 0, xs.length, ?elems);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [f]array_slice(xs, 0, xs.length, elems);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]xs[..] |-\u003e ?elems;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [_]xs[..] |-\u003e elems;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 32,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [?f]xs[..] |-\u003e ?elems;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 33,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [f]xs[..] |-\u003e elems;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]xs[..] |-\u003e ?elems;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 39,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [_]xs[..] |-\u003e elems;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 50,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 51,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 66,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires xs[i] |-\u003e ?n;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 67,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures xs[i] |-\u003e n + 1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 83,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires this.persons |-\u003e ?persons \u0026*\u0026 array_slice_deep(persons, 0, persons.length, person, 18, _, _) \u0026*\u0026 0 \u003c= i \u0026*\u0026 i \u003c persons.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 84,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures this.persons |-\u003e persons \u0026*\u0026 array_slice_deep(persons, 0, persons.length, person, 18, _, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 152,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures array_slice_deep(records, 0, records.length, record, recordLength, _, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 160,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires 0 \u003c= count \u0026*\u0026 0 \u003c= recordLength;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 161,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures array_slice_deep(result, 0, result.length, record, recordLength, _, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 177,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires 0 \u003c= count \u0026*\u0026 0 \u003c= recordLength;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 178,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures array_slice_deep(result, 0, result.length, record, recordLength, _, _);\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "// TODO: Support lemma methods\r\n\r\nclass C {\r\n    int x;\r\n    \r\n    C()\r\n        //@ requires true;\r\n        //@ ensures C(0, unit);\r\n    {\r\n        //@ close C(0, unit);\r\n    }\r\n\r\n    //@ predicate C(int x, any info) = this.x |-\u003e x \u0026*\u0026 info == unit;\r\n}\r\n\r\nclass D extends C {\r\n    int y;\r\n\r\n    D()\r\n        //@ requires true;\r\n        //@ ensures D(0, 0, unit);\r\n    {\r\n        //@ close D(0, 0, unit);\r\n    }\r\n    \r\n    /*@\r\n    \r\n    predicate C(int x, pair\u003cint, any\u003e info) = D(x, ?y, ?info0) \u0026*\u0026 info == pair(y, info0);\r\n    predicate D(int x, int y, any info) = this.C(C.class)(x, _) \u0026*\u0026 this.y |-\u003e y \u0026*\u0026 info == unit;\r\n\r\n    lemma void castCToD()\r\n        requires C(?x, ?info);\r\n        ensures switch (info) { case pair(y, info0): return D(x, y, info0); };\r\n    {\r\n        open C(x, _);\r\n    }\r\n    \r\n    lemma void castDToC()\r\n        requires D(?x, ?y, ?info);\r\n        ensures C(x, pair(y, info));\r\n    {\r\n        close C(_, _);\r\n    }\r\n    \r\n    @*/\r\n    \r\n    int getY()\r\n        //@ requires D(?x, ?y, ?info);\r\n        //@ ensures D(x, y, info) \u0026*\u0026 result == y;\r\n    {\r\n        //@ open D(x, y, _);\r\n        return this.y;\r\n        //@ close D(x, y, _);\r\n    }\r\n}\r\n\rclass E extends D {\r\n    int z;\r\n    \r\n    E()\r\n        //@ requires true;\r\n        //@ ensures E(0, 0, 0, unit);\r\n    {\r\n        //@ close E(0, 0, 0, unit);\r\n    }\r\n    \r\n    /*@\r\n\r\n    predicate C(int x, pair\u003cint, pair\u003cint, any\u003e \u003e info) = E(x, ?y, ?z, unit) \u0026*\u0026 info == pair(y, pair(z, unit));\r\n    predicate D(int x, int y, pair\u003cint, any\u003e info) = E(x, y, ?z, unit) \u0026*\u0026 info == pair(z, unit);\r\n    predicate E(int x, int y, int z, any info) = this.D(D.class)(x, y, _) \u0026*\u0026 this.z |-\u003e z \u0026*\u0026 info == unit;\r\n\r\n    lemma void castCToD()\r\n        requires C(?x, ?info);\r\n        ensures switch (info) { case pair(y, info0): return D(x, y, info0); };\r\n    {\r\n        open C(x, _);\r\n        close D(x, _, _);\r\n    }\r\n\r\n    lemma void castDToC()\r\n        requires D(?x, ?y, ?info);\r\n        ensures C(x, pair(y, info));\r\n    {\r\n        open D(_, _, _);\r\n        close C(_, _);\r\n    }\r\n    \r\n    @*/\r\n    \r\n    int getY()\r\n        //@ requires D(?x, ?y, ?info);\r\n        //@ ensures D(x, y, info) \u0026*\u0026 result == y;\r\n    {\r\n        //@ open D(x, y, _);\r\n        //@ open E(x, y, _, _);\r\n        return super.getY();\r\n        //@ close E(x, y, _, _);\r\n        //@ close D(x, y, _);\r\n    }\r\n}\r\n\r\n//@ predicate getY_result(any info0) = true;\r\n\r\nclass Program {\r\n    static int getY(C c)\r\n        //@ requires c.C(?x, ?info);\r\n        //@ ensures c.C(x, info) \u0026*\u0026 true == (c instanceof D) ? getY_result(?info0) \u0026*\u0026 info == pair(result, info0) : true;\r\n    {\r\n        if (c instanceof D) {\r\n            D d = (D)c;\r\n            //@ d.castCToD();\r\n            //@ assert d.D(_, _, ?info0);\r\n            //@ close getY_result(info0);\r\n            return d.getY();\r\n            //@ d.castDToC();\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    static void test()\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        E e = new E();\r\n        //@ close e.C(_, _);\r\n        getY(e);\r\n    }\r\n}",
        "name": "DowncastInfo.java",
        "path": "examples/java/DowncastInfo.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/DowncastInfo.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures C(0, unit);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 19,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures D(0, 0, unit);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 47,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires D(?x, ?y, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 48,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures D(x, y, info) \u0026*\u0026 result == y;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 59,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 60,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures E(0, 0, 0, unit);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 90,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires D(?x, ?y, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 91,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures D(x, y, info) \u0026*\u0026 result == y;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 105,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires c.C(?x, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 106,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures c.C(x, info) \u0026*\u0026 true == (c instanceof D) ? getY_result(?info0) \u0026*\u0026 info == pair(result, info0) : true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 121,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 122,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package chat;\r\n\r\nimport java.io.*;\r\nimport java.net.*;\r\nimport java.util.*;\r\nimport java.util.concurrent.*;\r\n\r\nclass ListUtil {\r\n    \r\n    static \u003cT\u003e void remove(List\u003cT\u003e l, T o) // Like l.remove(o), except uses identity comparison instead of .equals().\r\n        //@ requires l.List(?es);\r\n        //@ ensures l.List(remove(o, es));\r\n    {\r\n        for (int i = 0; i \u003c l.size(); i++)\r\n            //@ invariant l.List(es) \u0026*\u0026 0 \u003c= i \u0026*\u0026 i \u003c= index_of(o, es);\r\n        {\r\n            if (l.get(i) == o) {\r\n                l.remove(i);\r\n                //@ remove_remove_nth(o, es);\r\n                //@ index_of_nth(i, es);\r\n                break;\r\n            }\r\n            //@ if (index_of(o, es) == i) { nth_index_of(o, es); }\r\n        }\r\n        //@ if (mem(o, es)) { mem_index_of(o, es); } else { mem_remove_eq(o, es); }\r\n    }\r\n    \r\n}\r\n\r\n/*@\r\n\r\npredicate_ctor room_ctor(Room room)() = room(room);\r\n\r\npredicate session(Session session;) =\r\n    session.room |-\u003e ?room \u0026*\u0026 session.room_lock |-\u003e ?roomLock \u0026*\u0026 session.socket |-\u003e ?socket \u0026*\u0026 socket != null \u0026*\u0026 socket.Socket(?i, ?o)\r\n    \u0026*\u0026 roomLock != null \u0026*\u0026 [_]roomLock.Semaphore(room_ctor(room)) \u0026*\u0026 i.InputStream() \u0026*\u0026 o.OutputStream();\r\n\r\n@*/\r\n\r\npublic final class Session implements Runnable {\r\n    Room room;\r\n    Semaphore room_lock;\r\n    Socket socket;\r\n    \r\n    //@ predicate pre() = session(this);\r\n    //@ predicate post() = true;\r\n    \r\n    public Session(Room room, Semaphore roomLock, Socket socket)\r\n        /*@\r\n        requires\r\n            roomLock != null \u0026*\u0026 [_]roomLock.Semaphore(room_ctor(room)) \u0026*\u0026\r\n            socket != null \u0026*\u0026 socket.Socket(?i, ?o) \u0026*\u0026 i.InputStream() \u0026*\u0026 o.OutputStream();\r\n        @*/\r\n        //@ ensures session(this);\r\n    {\r\n        this.room = room;\r\n        this.room_lock = roomLock;\r\n        this.socket = socket;\r\n        //@ close session(this);\r\n    }\r\n    \r\n    public void run_with_nick(Room room, Semaphore roomLock, BufferedReader reader, Writer writer, String nick) throws InterruptedException /*@ ensures true; @*/, IOException /*@ ensures true; @*/\r\n        /*@\r\n        requires\r\n            roomLock != null \u0026*\u0026 [_]roomLock.Semaphore(room_ctor(room)) \u0026*\u0026 room != null \u0026*\u0026 room(room) \u0026*\u0026\r\n            reader != null \u0026*\u0026 reader.Reader() \u0026*\u0026\r\n            writer != null \u0026*\u0026 writer.Writer();\r\n        @*/\r\n        //@ ensures [_]roomLock.Semaphore(room_ctor(room)) \u0026*\u0026 reader.Reader() \u0026*\u0026 writer.Writer();\r\n    {\r\n        Member member = null;\r\n        String joinMessage = nick + \" has joined the room.\";\r\n        room.broadcast_message(joinMessage);\r\n        {\r\n            //@ open room(room);\r\n            member = new Member(nick, writer);\r\n            List\u003cMember\u003e list = room.members;\r\n            list.add(member);\r\n            //@ open foreach\u003cMember\u003e(?members, @member);\r\n            //@ close foreach(members, @member);\r\n            //@ foreach_member_not_contains(members, member);\r\n            //@ close foreach\u003cMember\u003e(nil, @member);\r\n            //@ close foreach\u003cMember\u003e(cons\u003cMember\u003e(member, nil), @member);\r\n            //@ foreach_append\u003cMember\u003e(members, cons\u003cMember\u003e(member, nil));\r\n            //@ close room(room);\r\n        }\r\n        //@ close room_ctor(room)();\r\n        //@ roomLock.makeHandle();\r\n        roomLock.release();\r\n        \r\n        {\r\n            String message = reader.readLine();\r\n            while (message != null)\r\n                //@ invariant reader.Reader() \u0026*\u0026 [_]roomLock.Semaphore(room_ctor(room));\r\n            {\r\n                //@ roomLock.makeHandle();\r\n                roomLock.acquire();\r\n                //@ open room_ctor(room)();\r\n                room.broadcast_message(nick + \" says: \" + message);\r\n                //@ close room_ctor(room)();\r\n                roomLock.release();\r\n                message = reader.readLine();\r\n            }\r\n        }\r\n        \r\n        roomLock.acquire();\r\n        //@ open room_ctor(room)();\r\n        //@ open room(room);\r\n        {\r\n            List\u003cMember\u003e membersList = room.members;\r\n            //@ assert foreach\u003cMember\u003e(?members, @member);\r\n            //@ assume(mem\u003cMember\u003e(member, members)); // TODO: Eliminate using a ghost list.\r\n            ListUtil.remove(membersList, member);\r\n            //@ foreach_remove\u003cMember\u003e(member, members);\r\n        }\r\n        //@ close room(room);\r\n        {\r\n            room.broadcast_message(nick + \" left the room.\");\r\n        }\r\n        //@ close room_ctor(room)();\r\n        roomLock.release();\r\n        \r\n        //@ open member(member);\r\n    }\r\n    \r\n    public void run()\r\n        //@ requires pre();\r\n        //@ ensures post();\r\n    {\r\n        try {\r\n            this.runCore();\r\n        } catch (InterruptedException e) {\r\n            throw new RuntimeException(e);\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n    \r\n    public void runCore() throws InterruptedException /*@ ensures true; @*/, IOException /*@ ensures true; @*/\r\n        //@ requires pre();\r\n        //@ ensures post();\r\n    {\r\n        //@ open pre();\r\n        //@ open session(this);\r\n        Room room = this.room;\r\n        Semaphore roomLock = this.room_lock;\r\n        Socket socket = this.socket;\r\n        InputStream in = socket.getInputStream();\r\n        InputStreamReader reader0 = new InputStreamReader(in);\r\n        BufferedReader reader = new BufferedReader(reader0);\r\n        OutputStream out = socket.getOutputStream();\r\n        OutputStreamWriter writer0 = new OutputStreamWriter(out);\r\n        BufferedWriter writer1 = new BufferedWriter(writer0);\r\n        Writer writer = writer1;\r\n        \r\n        writer.write(\"Welcome to the chat room.\\r\\n\");\r\n        writer.write(\"The following members are present: \");\r\n        \r\n        //@ roomLock.makeHandle();\r\n        roomLock.acquire();\r\n        //@ open room_ctor(room)();\r\n        //@ open room(room);\r\n        {\r\n            List\u003cMember\u003e membersList = room.members;\r\n            //@ assert foreach\u003cMember\u003e(?members, @member);\r\n            //@ membersList.listToIterable();\r\n            Iterator\u003cMember\u003e iter = membersList.iterator();\r\n            boolean hasNext = iter.hasNext();\r\n            while (hasNext)\r\n                /*@\r\n                invariant\r\n                    writer.Writer() \u0026*\u0026\r\n                    iter.Iterator((seq_of_list)(members), _, ?i) \u0026*\u0026 Iterable_iterating(membersList.getClass())(membersList, members, 1, iter)\r\n                    \u0026*\u0026 foreach(members, @member) \u0026*\u0026 hasNext == (i \u003c length(members)) \u0026*\u0026 0 \u003c= i \u0026*\u0026 i \u003c= length(members);\r\n                @*/\r\n            {\r\n                Member member = iter.next();\r\n                //@ foreach_remove\u003cMember\u003e(member, members);\r\n                //@ open member(member);\r\n                writer.write(member.nick);\r\n                writer.write(\"  \");\r\n                //@ close member(member);\r\n                //@ foreach_unremove\u003cMember\u003e(member, members);\r\n                hasNext = iter.hasNext();\r\n            }\r\n            writer.write(\"\\r\\n\");\r\n            writer.flush();\r\n            //@ membersList.destroyIterator();\r\n            //@ membersList.iterableToList();\r\n        }\r\n        \r\n        //@ close room(room);\r\n        //@ close room_ctor(room)();\r\n        roomLock.release();\r\n\r\n        {\r\n            boolean done = false;\r\n            while (!done)\r\n                //@ invariant writer.Writer() \u0026*\u0026 reader.Reader() \u0026*\u0026 [_]roomLock.Semaphore(room_ctor(room));\r\n            {\r\n                writer.write(\"Please enter your nick: \\r\\n\");\r\n                writer.flush();\r\n                {\r\n                    String nick = reader.readLine();\r\n                    if (nick == null) {\r\n                        done = true;\r\n                    } else {\r\n                        //@ roomLock.makeHandle();\r\n                        roomLock.acquire();\r\n                        //@ open room_ctor(room)();\r\n                        {\r\n                            if (room.has_member(nick)) {\r\n                                //@ close room_ctor(room)();\r\n                                roomLock.release();\r\n                                writer.write(\"Error: This nick is already in use.\\r\\n\");\r\n                                writer.flush();\r\n                            } else {\r\n                                this.run_with_nick(room, roomLock, reader, writer, nick);\r\n                                done = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        //@ reader.destroy();\r\n        //@ reader0.destroy();\r\n        //@ writer1.destroy();\r\n        //@ writer0.destroy();\r\n        socket.close();\r\n        //@ close post();\r\n    }\r\n}",
        "name": "Session.java",
        "path": "examples/java/chat/Session.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/chat/Session.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires l.List(?es);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures l.List(remove(o, es));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 53,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures session(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 68,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [_]roomLock.Semaphore(room_ctor(room)) \u0026*\u0026 reader.Reader() \u0026*\u0026 writer.Writer();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 126,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 127,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 139,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 140,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post();\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Program {\r\n    static int x;\r\n    static void foo()\r\n        //@ requires x |-\u003e ?v;\r\n        //@ ensures x |-\u003e v + 1;\r\n    {\r\n        x = x + 1;\r\n    }\r\n    \r\n    static int[] y = {1,2,3,4};\r\n    public static void main(String[] args)\r\n        //@ requires class_init_token(Program.class);\r\n        //@ ensures true;\r\n    {\r\n        //@ init_class(Program.class);\r\n        foo();\r\n        assertEq(x, 1);\r\n        assertEq(y.length, 4);\r\n        assertEq(y[0], 1);\r\n        assertEq(y[1], 2);\r\n        assertEq(y[2], 3);\r\n        assertEq(y[3], 4);\r\n    }\r\n    \r\n    static void assertEq(int expected, int actual)\r\n        //@ requires expected == actual;\r\n        //@ ensures true;\r\n    {\r\n        assert(expected == actual);\r\n    }\r\n    \r\n    //@ predicate foo(int v) = Program.x |-\u003e v \u0026*\u0026 x |-\u003e v;\r\n}",
        "name": "StaticFields.java",
        "path": "examples/java/StaticFields.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/StaticFields.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires x |-\u003e ?v;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures x |-\u003e v + 1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires class_init_token(Program.class);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 25,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires expected == actual;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 26,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package chat;\r\n\r\nimport java.io.*;\r\nimport java.net.*;\r\nimport java.util.*;\r\nimport java.util.concurrent.*;\r\n\r\npublic class Program {\r\n    public static void main(String[] args) throws IOException /*@ ensures true; @*/\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        Room room = new Room();\r\n        //@ close room_ctor(room)();\r\n        //@ one_time(room_ctor(room));\r\n        Semaphore roomLock = new Semaphore(1);\r\n        //@ roomLock.leakHandle();\r\n        ServerSocket serverSocket = new ServerSocket(12345);\r\n\r\n        while (true)\r\n            //@ invariant [_]roomLock.Semaphore(room_ctor(room)) \u0026*\u0026 serverSocket.ServerSocket();\r\n        {\r\n            Socket socket = serverSocket.accept();\r\n            Session session = new Session(room, roomLock, socket);\r\n            //@ close session.pre();\r\n            Thread t = new Thread(session);\r\n            t.start();\r\n        }\r\n    }\r\n}",
        "name": "Program.java",
        "path": "examples/java/chat/Program.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/chat/Program.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "/*@\r\npredicate linkedlist(LinkedList l; list\u003cint\u003e vs) =\r\n  l != null \u0026*\u0026\r\n  [_]l.head |-\u003e ?head \u0026*\u0026\r\n  [_]l.tail |-\u003e ?tail \u0026*\u0026\r\n  [_]l.length |-\u003e ?length \u0026*\u0026\r\n  (tail == null ? vs == nil :\r\n  linkedlist(tail, ?vs2) \u0026*\u0026 vs == cons(head, vs2)) \u0026*\u0026\r\n  length(vs) == length;\r\n  \r\nlemma void copy(LinkedList l)\r\n  requires linkedlist(l, ?vs);\r\n  ensures linkedlist(l, vs) \u0026*\u0026 linkedlist(l, vs);\r\n{\r\n  open linkedlist(l, vs);\r\n  if(l.tail == null) {\r\n\r\n  } else {\r\n    copy(l.tail);\r\n  }\r\n  close linkedlist(l, vs);\r\n  close linkedlist(l, vs);\r\n}\r\n@*/\r\n\r\nclass LinkedList {\r\n  int head;\r\n  LinkedList tail;\r\n  int length;\r\n  \r\n  public LinkedList() \r\n    //@ requires true;\r\n    //@ ensures this.head |-\u003e 0 \u0026*\u0026 this.tail |-\u003e null \u0026*\u0026 this.length |-\u003e 0;\r\n  {\r\n    \r\n  }\r\n  \r\n  public static LinkedList New()\r\n    //@ requires true;\r\n    //@ ensures result != null \u0026*\u0026 linkedlist(result, nil);\r\n  {\r\n    LinkedList l = new LinkedList();\r\n    //@ leak l.head |-\u003e _;\r\n    //@ leak l.tail |-\u003e null;\r\n    //@ leak l.length |-\u003e 0;\r\n    //@ close linkedlist(l, nil);\r\n    return l;\r\n  }\r\n  \r\n  public LinkedList Cons(int d)\r    //@ requires linkedlist(this, ?vs);\r\n    //@ ensures result != null \u0026*\u0026 linkedlist(this, vs) \u0026*\u0026 linkedlist(result, cons(d, vs));\r\n  {\r\n    //@ copy(this);\r\n    //@ open linkedlist(this, vs);\r\n    LinkedList r = new LinkedList();\r\n    r.head = d;\r\n    r.tail = this;\r\n    r.length = length+1;\r\n    //@ close linkedlist(this, vs);\r\n    //@ leak r.head |-\u003e d;\r\n    //@ leak r.tail |-\u003e _;\r\n    //@ leak r.length |-\u003e _;\r\n    //@ close linkedlist(r, cons(d, vs));\r\n    return r;\r\n  }\r\n  \r\n  public LinkedList Concat(LinkedList end)\r\n    //@ requires linkedlist(this, ?vs) \u0026*\u0026 linkedlist(end, ?vs2);\r\n    //@ ensures result != null \u0026*\u0026 linkedlist(this, vs) \u0026*\u0026 linkedlist(end, vs2) \u0026*\u0026 linkedlist(result, append(vs, vs2));\r\n  {\r\n    //@ open linkedlist(this,vs);\r\n    if(length == 0) {\r\n      //@ copy(end);\r\n      //@ open linkedlist(end, vs2);\r\n      //@ close linkedlist(end, vs2);\r\n      return end;\r\n      //@ close linkedlist(this,vs);\r\n    } else {\r\n      LinkedList c = tail.Concat(end);\r\n      LinkedList r = c.Cons(head);\r\n      //@ close linkedlist(this,vs);\r\n      return r;\r\n    }\r\n  }\r\n  \r\n  public LinkedList reverse()\r\n    //@ requires linkedlist(this, ?vs);\r\n    //@ ensures result != null \u0026*\u0026 linkedlist(this, vs) \u0026*\u0026 linkedlist(result, reverse(vs));\r\n  {\r\n    //@ open linkedlist(this, vs);\r\n    LinkedList r;\r\n    if(length == 0) {\r\n      r = New();\r\n    } else {\r\n      r = tail.reverse();\r\n      LinkedList e = New();\r\n      e = e.Cons(head);\r\n      r = r.Concat(e);\r\n    }\r\n    //@ close linkedlist(this, vs);\r\n    return r;\r\n  }\r\n}\r\n\r\n/*@\r\npredicate queue(AmortizedQueue q; list\u003cint\u003e vs) =\r\n  q != null \u0026*\u0026 q.front |-\u003e ?front \u0026*\u0026 q.rear |-\u003e ?rear \u0026*\u0026 linkedlist(front, ?vs1) \u0026*\u0026 linkedlist(rear, ?vs2) \u0026*\u0026 vs == append(vs1, reverse(vs2)) \u0026*\u0026 length(vs2) \u003c= length(vs1);\r\n@*/\r\n\r\nclass AmortizedQueue {\n  LinkedList front;\n  LinkedList rear;\n  \n  AmortizedQueue() \n    //@ requires true;\n    //@ ensures queue(this, nil);\n  {\n    front = LinkedList.New();\n    rear = LinkedList.New();\n  }\n  \n  AmortizedQueue(LinkedList front, LinkedList rear) \n    //@ requires linkedlist(front, ?vs1) \u0026*\u0026 linkedlist(rear, ?vs2);\n    //@ ensures queue(this, append(vs1, reverse(vs2))) \u0026*\u0026 linkedlist(front, vs1) \u0026*\u0026 linkedlist(rear, vs2);\n  {\n    //@ copy(front);\n    //@ copy(rear);\n    //@ open linkedlist(front, vs1);\n    //@ open linkedlist(rear, vs2);\n    if(rear.length \u003c= front.length) {\n      this.front = front;\n      this.rear = rear;\n    } else {\n      LinkedList f = rear.reverse();\n      this.front = front.Concat(f);\n      this.rear = LinkedList.New();\n    }\n    //@ close linkedlist(front, vs1);\n    //@ close linkedlist(rear, vs2);\n  }\n\n  int front()\n    //@ requires queue(this, ?vs) \u0026*\u0026 vs != nil;\n    //@ ensures queue(this, vs) \u0026*\u0026 result == head(vs);\n  {\n    //@ LinkedList front = this.front;\n    //@ LinkedList rear = this.rear;\n    //@ open linkedlist(front, ?vs1);\n    //@ open linkedlist(rear, ?vs2);\n    int r = this.front.head;\n    //@ close linkedlist(front, vs1);\n    //@ close linkedlist(rear, vs2);\n    return r;\n  }\n  \n  AmortizedQueue tail() \n    //@ requires queue(this, ?vs) \u0026*\u0026 vs != nil;\n    //@ ensures queue(this, vs) \u0026*\u0026 queue(result, tail(vs));\n  {\n    //@ LinkedList front = this.front;\n    //@ LinkedList rear = this.rear;\n    //@ open linkedlist(front, ?vs1);\n    //@ open linkedlist(rear, ?vs2);\n    //@ close linkedlist(rear, vs2);\n    AmortizedQueue r = new AmortizedQueue(this.front.tail, this.rear);\n    //@ close linkedlist(front, vs1);\n    return r;\n  }\n  \n  AmortizedQueue enqueue(int item)\n    //@ requires queue(this, ?vs);\n    //@ ensures result != null \u0026*\u0026 queue(this, vs) \u0026*\u0026 queue(result, append(vs, cons(item, nil)));\n  {\n    //@ LinkedList rear2 = this.rear;\n    //@ open linkedlist(rear2, ?vs2);\n    //@ close linkedlist(rear2, vs2);\n    //@ LinkedList front = this.front;\n    //@ open linkedlist(front, ?vs1);\n    //@ close linkedlist(front, vs1);\n    LinkedList r = rear.Cons(item);\n    AmortizedQueue q = new AmortizedQueue(this.front, r);\n    //@ append_assoc(vs1, reverse(vs2), cons(item, nil));\n    return q;\n  }\n}\n\nclass Program {\n  public static void main(String[] args) \n    //@ requires true;\n    //@ ensures true;\n  {\n    AmortizedQueue q1 = new AmortizedQueue();\n    AmortizedQueue q2 = q1.enqueue(5);\n    AmortizedQueue q3 = q1.enqueue(6);\n    int res1 = q2.front();\n    int res2 = q3.front();\n    assert(res1 == 5);\n    assert(res2 == 6);\n  }\n}",
        "name": "problem5.java",
        "path": "examples/vstte2010/problem5.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/vstte2010/problem5.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 32,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures this.head |-\u003e 0 \u0026*\u0026 this.tail |-\u003e null \u0026*\u0026 this.length |-\u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 39,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result != null \u0026*\u0026 linkedlist(result, nil);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 49,
          "offsetAndLengths": [
            [
              36,
              13
            ]
          ],
          "preview": "  public LinkedList Cons(int d)\r    //@ requires linkedlist(this, ?vs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 50,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result != null \u0026*\u0026 linkedlist(this, vs) \u0026*\u0026 linkedlist(result, cons(d, vs));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 67,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires linkedlist(this, ?vs) \u0026*\u0026 linkedlist(end, ?vs2);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 68,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result != null \u0026*\u0026 linkedlist(this, vs) \u0026*\u0026 linkedlist(end, vs2) \u0026*\u0026 linkedlist(result, append(vs, vs2));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 86,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires linkedlist(this, ?vs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 87,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result != null \u0026*\u0026 linkedlist(this, vs) \u0026*\u0026 linkedlist(result, reverse(vs));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 114,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 115,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures queue(this, nil);"
        },
        {
          "limitHit": false,
          "lineNumber": 122,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires linkedlist(front, ?vs1) \u0026*\u0026 linkedlist(rear, ?vs2);"
        },
        {
          "limitHit": false,
          "lineNumber": 123,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures queue(this, append(vs1, reverse(vs2))) \u0026*\u0026 linkedlist(front, vs1) \u0026*\u0026 linkedlist(rear, vs2);"
        },
        {
          "limitHit": false,
          "lineNumber": 142,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires queue(this, ?vs) \u0026*\u0026 vs != nil;"
        },
        {
          "limitHit": false,
          "lineNumber": 143,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures queue(this, vs) \u0026*\u0026 result == head(vs);"
        },
        {
          "limitHit": false,
          "lineNumber": 156,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires queue(this, ?vs) \u0026*\u0026 vs != nil;"
        },
        {
          "limitHit": false,
          "lineNumber": 157,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures queue(this, vs) \u0026*\u0026 queue(result, tail(vs));"
        },
        {
          "limitHit": false,
          "lineNumber": 170,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires queue(this, ?vs);"
        },
        {
          "limitHit": false,
          "lineNumber": 171,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result != null \u0026*\u0026 queue(this, vs) \u0026*\u0026 queue(result, append(vs, cons(item, nil)));"
        },
        {
          "limitHit": false,
          "lineNumber": 188,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 189,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "/*@\n\nfixpoint list\u003cint\u003e suffixOffsets\u003ct\u003e(int offset0, list\u003ct\u003e xs) {\n    switch (xs) {\n        case nil: return nil;\n        case cons(x, xs0): return cons(offset0, suffixOffsets(offset0 + 1, xs0));\n    }\n}\n\npredicate is_swap\u003ct\u003e(list\u003ct\u003e xs, int i, int j, list\u003ct\u003e ys) =\n    0 \u003c= i \u0026*\u0026 i \u003c length(xs) \u0026*\u0026 0 \u003c= j \u0026*\u0026 j \u003c length(xs) \u0026*\u0026\n    ys == update(i, nth(j, xs), update(j, nth(i, xs), xs));\n\npredicate is_perm\u003ct\u003e(list\u003ct\u003e xs, list\u003ct\u003e ys) =\n    exists\u003cboolean\u003e(?b) \u0026*\u0026 b ? xs == ys : is_swap(xs, _, _, ?zs) \u0026*\u0026 is_perm(zs, ys);\n\nfixpoint boolean is_sorted\u003ct\u003e(fixpoint(t, t, bool) le, t x0, list\u003ct\u003e xs) {\n    switch (xs) {\n        case nil: return true;\n        case cons(x, xs0): return le(x0, x) \u0026\u0026 is_sorted(le, x, xs0);\n    }\n}\n\n@*/\n\npublic class SuffixArray {\n\n    private final int[] a;\n    private final int[] suffixes;\n    private final int N;\n    \n    /*@\n    \n    predicate SuffixArray(list\u003cint\u003e elems, list\u003cint\u003e suffixes_) =\n        a |-\u003e ?a \u0026*\u0026 suffixes |-\u003e ?suffixes \u0026*\u0026 N |-\u003e ?N \u0026*\u0026 N == a.length \u0026*\u0026\n        array_slice(a, 0, N, elems_) \u0026*\u0026\n        array_slice(suffixes, 0, N, suffixes_);\n    \n    @*/\n\n    public SuffixArray(int[] a)\n        //@ requires array_slice(a, 0, a.length, ?elems);\n        //@ ensures SuffixArray(elems, ?suffixes_) \u0026*\u0026 ;\n    {\n        this.a = a;\n        N = a.length;\n        suffixes = new int[N];\n        for (int i = 0; i \u003c N; i++) suffixes[i] = i;\n        sort(suffixes);\n    }\n\n\n    public int select(int i)\n        //@ requires false;\n        //@ ensures true;\n    { \n        return suffixes[i]; \n    }\n\n \n    private int lcp(int x, int y)\n        //@ requires false;\n        //@ ensures true;\n    {\n        int l = 0;\n        while (x+l\u003cN \u0026\u0026 y+l\u003cN \u0026\u0026 a[x+l]==a[y+l]) {\n            l++;\n        }\n        return l;\n    }\n\n\n    public int lcp(int i)\n        //@ requires false;\n        //@ ensures true;\n    {\n        return lcp(suffixes[i], suffixes[i-1]);\n    }\n\n\n    public int compare(int x, int y)\n        //@ requires false;\n        //@ ensures true;\n    {\n        if (x == y) return 0;\n        int l = 0;\n\n        while (x+l\u003cN \u0026\u0026 y+l\u003cN \u0026\u0026 a[x+l] == a[y+l]) {\n            l++;\n        }\n\n        if (x+l == N) return -1;\n        if (y+l == N) return 1;\n        if (a[x+l] \u003c a[y+l]) return -1;\n        if (a[x+l] \u003e a[y+l]) return 1;\n        \n        throw new RuntimeException();\n    }\n\n\n    public void sort(int[] data)\n        //@ requires false;\n        //@ ensures true;\n    {\n        for(int i = 0; i \u003c data.length + 0; i++) {\n            for(int j = i; j \u003e 0 \u0026\u0026 compare(data[j - 1], data[j]) \u003e 0; j--) {\n                int b = j - 1;\n                int t = data[j];\n                data[j] = data[b];\n                data[b] = t;\n            }\n        }\n    }\n\n\n    public static void main(String[] argv)\n        //@ requires false;\n        //@ ensures true;\n    {\n        int[] arr = {1,2,2,5};\n        SuffixArray sa = new SuffixArray(arr);\n        System.out.println(sa.lcp(1,2));\n        int[] brr = {1,2,3,5};\n        sa = new SuffixArray(brr);\n        System.out.println(sa.lcp(1,2));\n        int[] crr = {1,2,3,5};\n        sa = new SuffixArray(crr);\n        System.out.println(sa.lcp(2,3));\n        int[] drr = {1,2,3,3};\n        sa = new SuffixArray(drr);\n        System.out.println(sa.lcp(2,3));\n    }\n\n\n}\n\n\n\n//Based on code by Robert Sedgewick and Kevin Wayne.\n",
        "name": "SuffixArray.java",
        "path": "examples/fm2012/SuffixArray.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/fm2012/SuffixArray.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 41,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires array_slice(a, 0, a.length, ?elems);"
        },
        {
          "limitHit": false,
          "lineNumber": 42,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures SuffixArray(elems, ?suffixes_) \u0026*\u0026 ;"
        },
        {
          "limitHit": false,
          "lineNumber": 53,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires false;"
        },
        {
          "limitHit": false,
          "lineNumber": 54,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 61,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires false;"
        },
        {
          "limitHit": false,
          "lineNumber": 62,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 73,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires false;"
        },
        {
          "limitHit": false,
          "lineNumber": 74,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 81,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires false;"
        },
        {
          "limitHit": false,
          "lineNumber": 82,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 101,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires false;"
        },
        {
          "limitHit": false,
          "lineNumber": 102,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 116,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires false;"
        },
        {
          "limitHit": false,
          "lineNumber": 117,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class ArrayList {\r\n    byte[] elems;\r\n    short count;\r\n    \r\n    /*@\r\n    predicate ArrayList(short n) =\r\n        elems |-\u003e ?es \u0026*\u0026 count |-\u003e n \u0026*\u0026\r\n        array_slice(es, 0, n, _) \u0026*\u0026 array_slice(es, n, es.length, _) \u0026*\u0026\r\n        es.length \u003c= 32767;\r\n    @*/\r\n        \r\n    ArrayList(short size)\r\n        //@ requires 0 \u003c= size;\r\n        //@ ensures ArrayList(0);\r\n    {\r\n        elems = new byte[size];\r\n    }\r\n    \r\n    short getCount()\r\n        //@ requires ArrayList(?n);\r\n        //@ ensures ArrayList(n) \u0026*\u0026 result == n;\r\n    {\r\n        return count;\r\n    }\r\n    \r\n    byte get(short index)\r\n        //@ requires ArrayList(?n) \u0026*\u0026 0 \u003c= index \u0026*\u0026 index \u003c n;\r\n        //@ ensures ArrayList(n);\r\n    {\r\n        return elems[index];\r\n    }\r\n    \r\n    boolean add(byte value)\r\n        //@ requires ArrayList(?n);\r\n        //@ ensures result ? ArrayList((short)(n + 1)) : ArrayList(n);\r\n    {\r\n        if (count == elems.length)\r\n            return false;\r\n        elems[count++] = value;\r\n        return true;\r\n    }\r\n}\r\n\r\nclass Program {\r\n    static void test()\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        ArrayList list = new ArrayList((short)10);\r\n        if (list.add((byte)1) \u0026\u0026 list.add((byte)2) \u0026\u0026 list.add((byte)3)) {\r\n            short count = list.getCount();\r\n            assert count == 3;\r\n            list.get((short)2);\r\n        }\r\n    }\r\n}",
        "name": "arraylist.java",
        "path": "javacard_tutorial/arraylist.java",
        "url": "/github.com/verifast/verifast/-/blob/javacard_tutorial/arraylist.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires 0 \u003c= size;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures ArrayList(0);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 19,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires ArrayList(?n);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures ArrayList(n) \u0026*\u0026 result == n;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 26,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires ArrayList(?n) \u0026*\u0026 0 \u003c= index \u0026*\u0026 index \u003c n;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures ArrayList(n);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 33,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires ArrayList(?n);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 34,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures result ? ArrayList((short)(n + 1)) : ArrayList(n);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 45,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 46,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package chat;\n\nimport java.io.*;\nimport java.util.*;\n\n/*@\n\npredicate room(Room room) =\n    room.members |-\u003e ?membersList \u0026*\u0026 membersList != null \u0026*\u0026 foreach\u003cMember\u003e(?members, member) \u0026*\u0026 membersList.List(members);\n\n@*/\n\npublic class Room {\n    List members;\n\n    public Room()\n        //@ requires emp;\n        //@ ensures room(this);\n    {\n        List a = new ArrayList();\n        this.members = a;\n        //@ close foreach\u003cMember\u003e(nil, member);\n        //@ close room(this);\n    }\n    \n    public boolean has_member(String nick)\n        //@ requires room(this) \u0026*\u0026 nick != null;\n        //@ ensures room(this);\n    {\n        //@ open room(this);\n        //@ assert foreach(?members, _);\n        List membersList = this.members;\n        //@ membersList.listToIterable();\n        Iterator iter = membersList.iterator();\n        boolean hasMember = false;\n        boolean hasNext = iter.hasNext();\n        while (hasNext \u0026\u0026 !hasMember)\n            /*@\n            invariant\n                iter.Iterator((seq_of_list)(members), _, ?i) \u0026*\u0026 Iterable_iterating(membersList.getClass())(membersList, members, 1, iter) \u0026*\u0026 foreach(members, @member)\n                \u0026*\u0026 hasNext == (i \u003c length(members)) \u0026*\u0026 0 \u003c= i \u0026*\u0026 i \u003c= length(members);\n            @*/\n        {\n            Member member = (Member) iter.next();\n            //@ foreach_remove\u003cMember\u003e(member, members);\n            //@ open member(member);\n            hasMember = nick.equals(member.nick);\n            //@ close member(member);\n            //@ foreach_unremove\u003cMember\u003e(member, members);\n            hasNext = iter.hasNext();\n        }\n        //@ membersList.destroyIterator();\n        //@ membersList.iterableToList();\n        //@ close room(this);\n        return hasMember;\n    }\n    \n    public void broadcast_message(String message) throws IOException /*@ ensures true; @*/\n        //@ requires room(this) \u0026*\u0026 message != null;\n        //@ ensures room(this);\n    {\n        //@ open room(this);\n        //@ assert foreach(?members0, _);\n        List membersList = this.members;\n        //@ membersList.listToIterable();\n        Iterator iter = membersList.iterator();\n        boolean hasNext = iter.hasNext();\n        //@ length_nonnegative(members0);\n        while (hasNext)\n            /*@\n            invariant\n                foreach\u003cMember\u003e(?members, @member) \u0026*\u0026 iter.Iterator((seq_of_list)(members), _, ?i) \u0026*\u0026 Iterable_iterating(membersList.getClass())(membersList, members, 1, iter)\n                \u0026*\u0026 hasNext == (i \u003c length(members)) \u0026*\u0026 0 \u003c= i \u0026*\u0026 i \u003c= length(members);\n            @*/\n        {\n            Member member = (Member) iter.next();\n            //@ mem_nth(i, members);\n            //@ foreach_remove\u003cMember\u003e(member, members);\n            //@ open member(member);\n            Writer writer = member.writer;\n            writer.write(message);\n            writer.write(\"\\r\\n\");\n            writer.flush();\n            //@ close member(member);\n            //@ foreach_unremove\u003cMember\u003e(member, members);\n            hasNext = iter.hasNext();\n        }\n        //@ membersList.destroyIterator();\n        //@ membersList.iterableToList();\n        //@ close room(this);\n    }\n}",
        "name": "Room.java",
        "path": "examples/java/chat_raw/Room.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/chat_raw/Room.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires emp;"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures room(this);"
        },
        {
          "limitHit": false,
          "lineNumber": 26,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires room(this) \u0026*\u0026 nick != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures room(this);"
        },
        {
          "limitHit": false,
          "lineNumber": 58,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires room(this) \u0026*\u0026 message != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 59,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures room(this);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Node {\r\n    int head;\r\n    Node next;\r\n}\r\n\r\n/*@\r\n\r\npredicate List(Node n; list\u003cint\u003e elems) =\r\n    n == null ?\r\n        elems == nil\r\n    :\r\n        n.head |-\u003e ?head \u0026*\u0026\r\n        n.next |-\u003e ?next \u0026*\u0026\r\n        List(next, ?tail) \u0026*\u0026\r\n        elems == cons(head, tail);\r\n\r\npredicate Lseg(Node f, Node l; list\u003cint\u003e elems) =\r\n    f == l ?\r\n        elems == nil\r\n    :\r\n        f.head |-\u003e ?head \u0026*\u0026\r\n        f.next |-\u003e ?next \u0026*\u0026\r\n        Lseg(next, l, ?elems0) \u0026*\u0026\r\n        elems == cons(head, elems0);\r\n\r\nlemma void Lseg_add(Node ll)\r\n    requires Lseg(ll, ?jj, ?elems0) \u0026*\u0026 jj.head |-\u003e ?head \u0026*\u0026 jj.next |-\u003e ?next \u0026*\u0026 List(next, ?elems1);\r\n    ensures Lseg(ll, next, append(elems0, cons(head, nil))) \u0026*\u0026 List(next, elems1);\r\n{\r\n    open Lseg(ll, jj, elems0);\r\n    if (ll == jj) {\r\n        open List(next, elems1);\r\n    } else {\r\n        open List(next, elems1);\r\n        Lseg_add(ll.next);\r\n    }\r\n}\r\n\r\nfixpoint int find\u003ct\u003e(t x, list\u003ct\u003e xs) {\r\n    switch (xs) {\r\n        case nil: return 0;\r\n        case cons(x0, xs0): return x0 == x ? 0 : 1 + find(x, xs0);\r\n    }\r\n}\r\n\r\nlemma void Lseg_to_List(Node ll)\r\n    requires Lseg(ll, ?jj, ?elems0) \u0026*\u0026 List(jj, ?elems1);\r\n    ensures List(ll, append(elems0, elems1));\r\n{\r\n    open Lseg(ll, jj, elems0);\r\n    if (ll != jj) {\r\n        Lseg_to_List(ll.next);\r\n    }\r\n}\r\n\r\n@*/\r\n\r\nclass Problem3 {\r\n\r\n    public static int findFirstZero(Node ll)\r\n        //@ requires List(ll, ?elems);\r\n        //@ ensures List(ll, elems) \u0026*\u0026 result == find(0, elems);\r\n    {\r\n        Node jj = ll;\r\n        int i = 0;\r\n        while (jj != null \u0026\u0026 jj.head != 0)\r\n            /*@\r\n            invariant\r\n                Lseg(ll, jj, ?elems0) \u0026*\u0026 List(jj, ?elems1) \u0026*\u0026 elems == append(elems0, elems1) \u0026*\u0026\r\n                find(0, elems) == i + find(0, elems1);\r\n            @*/\r\n        {\r\n            //@ append_assoc(elems0, cons(jj.head, nil), tail(elems1));\r\n            jj = jj.next;\r\n            i++;\r\n            //@ Lseg_add(ll);\r\n        }\r\n        //@ open List(null, _);\r\n        //@ Lseg_to_List(ll);\r\n        return i;\r\n    }\r\n}",
        "name": "problem3.java",
        "path": "examples/vstte2010/problem3.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/vstte2010/problem3.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 60,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List(ll, ?elems);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 61,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(ll, elems) \u0026*\u0026 result == find(0, elems);\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "/*@\r\n\r\nlemma_auto void length_append_auto\u003ct\u003e(list\u003ct\u003e xs, list\u003ct\u003e ys)\r\n    requires true;\r\n    ensures length(append(xs, ys)) == length(xs) + length(ys);\r\n{\r\n    length_append(xs, ys);\r\n}\r\n\r\nfixpoint boolean consistent(list\u003cint\u003e vs, nat i, int pos) {\r\n  switch(i) {\r\n    case zero: return true;\r\n    case succ(j): return nth(int_of_nat(j), vs) != nth(pos, vs) \u0026\u0026\r\n                  pos - int_of_nat(j) != ((int)nth(pos, vs)) - ((int) nth(int_of_nat(j), vs)) \u0026\u0026\r\n                  pos - int_of_nat(j) != ((int) nth(int_of_nat(j), vs)) - nth(pos, vs) \u0026\u0026\r\n                  consistent(vs, j, pos);\r\n  }\r\n}\r\n\r\nfixpoint boolean allconsistent(list\u003cint\u003e vs, nat n) {\r\n  switch(n) {\r\n    case zero: return true;\r\n    case succ(n0): return consistent(vs, n0, int_of_nat(n0)) \u0026\u0026 allconsistent(vs, n0);\r\n  }\r\n}\r\n\r\nlemma void take_consistent(list\u003cint\u003e vs, nat i, int pos) \r\n  requires  0 \u003c= int_of_nat(i) \u0026*\u0026 int_of_nat(i) \u003c= pos \u0026*\u0026 pos \u003c length(vs);\r\n  ensures consistent(vs, i, pos) == consistent(take(pos + 1, vs), i, pos);\r\n{\r\n  switch(i) {\r\n    case zero:\r\n    case succ(i0):\r\n       nth_take(int_of_nat(i0), pos + 1, vs);\r\n       nth_take(pos, pos + 1, vs);\r\n       take_consistent(vs, i0, pos); \r\n  }\r\n}\r\n\r\nlemma void nth_append\u003ct\u003e(list\u003ct\u003e vs1, list\u003ct\u003e vs2, int n) \r\n  requires 0\u003c=n \u0026*\u0026 n \u003c length(append(vs1, vs2));\r\n  ensures nth(n, append(vs1, vs2)) == (n \u003c length(vs1) ? nth(n, vs1) : nth(n - length(vs1), vs2));\r\n{ \r\n  switch(vs1) {\r\n    case nil:\r\n    case cons(h, t):\r\n      if(n == 0) {\r\n      } else {\r\n        nth_append\u003ct\u003e(t, vs2, n - 1);\r\n      }\r\n  }  \r\n}\r\n\r\nlemma void append_consistent(list\u003cint\u003e vs, nat n, int pos, list\u003cint\u003e vs2)\r\n  requires int_of_nat(n) \u003c length(vs) \u0026\u0026 0\u003c= pos \u0026*\u0026 pos \u003c length(vs);\r\n  ensures consistent(vs, n, pos) == consistent(append(vs, vs2), n, pos);\r\n{\r\n  switch(n) {\r\n    case zero:\r\n    case succ(n0): \r\n      nth_append(vs, vs2, int_of_nat(n0));\r\n      nth_append(vs, vs2, pos);\r\n      append_consistent(vs, n0, pos, vs2);\r\n  }\r\n}\r\n\r\nlemma void append_allconsistent(list\u003cint\u003e vs, nat n, list\u003cint\u003e vs2)\r\n  requires allconsistent(vs, n) == true \u0026*\u0026 int_of_nat(n) \u003c= length(vs);\r\n  ensures allconsistent(append(vs, vs2), n) == true;\r\n{\r\n  switch(n) {\r\n    case zero:\r\n    case succ(n0):\r\n      append_consistent(vs, n0, int_of_nat(n0), vs2);\r\n      append_allconsistent(vs, n0, vs2);\r\n  }\r\n}\r\n\r\nlemma void take_one_extra\u003ct\u003e(list\u003ct\u003e vs, int n) \r\n  requires 0\u003c=n \u0026*\u0026 n \u003c length(vs);\r\n  ensures take(n + 1, vs) == append(take(n, vs), cons(nth(n, vs), nil));\r\n{\r\n  switch(vs) {\r\n    case nil:\r\n    case cons(h, t):\r\n      if(n == 0) {\r\n      } else  {\r\n        take_one_extra(t, n - 1);\r\n      }\r\n  }\r\n}\r\n\r\nlemma void take_allconsistent(list\u003cint\u003e vs, nat n) \r\n  requires allconsistent(vs, n) == true \u0026*\u0026 int_of_nat(n) \u003c= length(vs);\r\n  ensures allconsistent(take(int_of_nat(n), vs), n) == true;\r\n{\r\n  switch(n) {\r\n    case zero:\r\n    case succ(n0):\r\n      take_consistent(vs, n0, int_of_nat(n0));\r\n      take_allconsistent(vs, n0);\r\n      succ_int(int_of_nat(n0));\r\n      append_allconsistent(take(int_of_nat(n0), vs), n0, cons(nth(int_of_nat(n0), vs), nil));\r\n      take_one_extra(vs, int_of_nat(n0)); \r\n  }\r\n}\r\n\r\nlemma void take_append\u003ct\u003e(list\u003ct\u003e vs1, list\u003ct\u003e vs2, int n)\r\n  requires 0 \u003c= n \u0026*\u0026 n \u003c= length(append(vs1, vs2)) \u0026*\u0026 n \u003c= length(vs1);\r\n  ensures take(n, append(vs1, vs2)) == (n \u003c= length(vs1) ? take(n, vs1) : append(vs1, take(n - length(vs1), vs2)));\r\n{\r\n  switch(vs1) {\r\n    case nil:\r\n    case cons(h, t): \r\n      if(n == 0) {\r\n      } else {\r\n        take_append(t, vs2, n- 1);\r\n      }\r\n  }\r\n}\r\n\r\nlemma void not_consistent_monotonic(list\u003cint\u003e vs, int pos, nat m)\r\n  requires ! consistent(vs, nat_of_int(pos - int_of_nat(m)), pos) \u0026*\u0026 0 \u003c= int_of_nat(m) \u0026*\u0026 int_of_nat(m) \u003c= pos;\r\n  ensures ! consistent(vs, nat_of_int(pos), pos);\r\n{\r\n  switch(m) {\r\n    case zero:\r\n    case succ(m0):\r\n      minuslemma(int_of_nat(m), pos);\r\n      not_consistent_monotonic(vs, pos, m0);\r\n  }\r\n}\r\n\r\nlemma void take_oke(list\u003cint\u003e vs1, list\u003cint\u003e vs2, int i)\r\n  requires 0 \u003c= i \u0026*\u0026 i \u003c length(vs1) \u0026*\u0026 length(vs2) == length(vs1) \u0026*\u0026 take(i + 1, vs1) == take(i + 1, vs2);\r\n  ensures take(i, vs1) == take(i, vs2);\r\n{\r\n  switch(vs1) {\r\n    case nil:\r\n    case cons(h1, t1):\r\n      switch(vs2) {\r\n        case nil:\r\n        case cons(h2, t2):\r\n          if(h1 != h2) {\r\n          } else {\r\n            if(i == 0) {\r\n            } else {\r\n              take_oke(t1, t2, i - 1);\r\n            }\r\n          }\r\n      }\r\n  }\r\n}\r\n\r\nfixpoint list\u003ct\u003e update2\u003ct\u003e(unit u, list\u003ct\u003e vs, t v, int pos) {\r\n  switch(u) {\r\n    case unit: return append(take(pos, vs), append(cons(v, nil), tail(drop(pos, vs))));\r\n  }\r\n}\r\n\r\nlemma_auto(update(pos, v, vs)) void update_eq_update2\u003ct\u003e(list\u003ct\u003e vs, t v, int pos)\r\n  requires 0 \u003c= pos \u0026\u0026 pos \u003c length(vs);\r\n  ensures update(pos, v, vs) == update2(unit, vs, v, pos);\r\n{\r\n  switch(vs) {\r\n    case nil:\r\n    case cons(h, t):\r\n      if(pos == 0) {\r\n      } else {\r\n        update_eq_update2(t, v, pos - 1);\r\n      }\r\n  }\r\n}\r\n\r\nlemma void update_nth\u003ct\u003e(list\u003ct\u003e vs, t v, int pos) \r\n  requires nth(pos, vs) == v \u0026\u0026 0 \u003c= pos \u0026\u0026 pos \u003c length(vs);\r\n  ensures update2(unit, vs, v, pos) == vs;\r\n{\r\n  switch(vs) {\r\n    case nil:\r\n    case cons(h, t):\r\n      if(pos == 0 ){\r\n      } else {\r\n        update_nth(t, v, pos - 1);\r\n      }\r\n  }\r\n}\r\n\r\nlemma void update_append\u003ct\u003e(list\u003ct\u003e vs, t v, int pos, list\u003ct\u003e vs2) \r\n  requires 0 \u003c= pos \u0026*\u0026 pos \u003c length(vs);\r\n  ensures append(update2(unit, vs, v, pos), vs2) == update2(unit, append(vs, vs2), v, pos);\r\n{\r\n  switch(vs) {\r\n    case nil:\r\n    case cons(h, t):\r\n      if(pos == 0 ){\r\n      } else {\r\n        update_append\u003ct\u003e(t, v, pos - 1, vs2);\r\n      }\r\n  }\r\n}\r\n\r\npredicate inconsistent(list\u003cint\u003e vs, nat i, int pos) =\r\n  (switch(i) { \r\n    case zero: return true; \r\n    case succ(i0): \r\n    return pos \u003c length(vs) \u0026*\u0026 inconsistent(vs, i0, pos) \u0026*\u0026 \r\n    (consistent(update2(unit, vs, int_of_nat(i0), pos), nat_of_int(pos), pos) == true ? \r\n      inconsistent(update2(unit, vs, int_of_nat(i0), pos), nat_of_int(length(vs)), pos + 1) : true); }) ;\r\n\r\nlemma void duplicate_inconsistent(list\u003cint\u003e vs, nat i, int pos) \r\n  requires inconsistent(vs, i, pos);\r\n  ensures inconsistent(vs, i, pos) \u0026*\u0026 inconsistent(vs, i, pos);\r\n{\r\n  open inconsistent(vs, i, pos);\r\n  switch(i) {\r\n    case zero: close inconsistent(vs, zero, pos); close inconsistent(vs, zero, pos);\r\n    case succ(i0):\r\n      duplicate_inconsistent(vs,  i0, pos);      \r\n      if(consistent(update2(unit, vs, int_of_nat(i0), pos), nat_of_int(pos), pos)) {\r\n        duplicate_inconsistent(update2(unit, vs, int_of_nat(i0), pos), nat_of_int(length(vs)), pos + 1);\r\n        close inconsistent(vs, i, pos);\r\n        close inconsistent(vs, i, pos);\r\n      } else {\r\n        close inconsistent(vs, i, pos);\r\n        close inconsistent(vs, i, pos);\r\n      }\r\n  }\r\n}\r\n\r\nlemma_auto(take(j, update(i, v, vs))) void take_update2\u003ct\u003e(list\u003ct\u003e vs, t v, int i, int j)\r\n  requires 0 \u003c= i \u0026\u0026 i \u003c length(vs) \u0026\u0026 0 \u003c= j \u0026\u0026 j \u003c= i;\r\n  ensures take(j, vs) == take(j, update(i, v, vs));\r\n{\r\n  switch(vs) {\r\n    case nil:\r\n    case cons(h, t):\r\n      if(j == 0) {\r\n      } else {\r\n        take_update2(t, v, i - 1, j - 1);\r\n      }\r\n  }\r\n}\r\n\r\nlemma void length_update2\u003ct\u003e(list\u003ct\u003e vs, t v, int pos)\r\n  requires 0 \u003c= pos \u0026\u0026 pos \u003c length(vs);\r\n  ensures length(update2(unit, vs, v, pos)) == length(vs);\r\n{\r\n  switch(vs) {\r\n    case nil: \r\n    case cons(h, t):\r\n      if(pos == 0) {\r\n      } else {\r\n        length_update2(t, v, pos - 1);\r\n      }\r\n  } \r\n}\r\n\r\nlemma void update_same(list\u003cint\u003e vs, list\u003cint\u003e vs2, int pos, int v)\r\n  requires length(vs) == length(vs2) \u0026\u0026 take(pos, vs) == take(pos, vs2) \u0026*\u0026 0 \u003c= pos \u0026*\u0026 pos \u003c length(vs);\r\n  ensures take(pos + 1, update2(unit, vs, v, pos)) == take(pos + 1, update2(unit, vs2, v, pos));\r\n{\r\n  take_append(take(pos, vs), append(cons(v, nil), tail(drop(pos, vs))), pos);\r\n  take_append(take(pos, vs2), append(cons(v, nil), tail(drop(pos, vs2))), pos);\r\n  nth_append(take(pos, vs2), append(cons(v, nil), tail(drop(pos, vs2))), pos);\r\n  nth_append(take(pos, vs), append(cons(v, nil), tail(drop(pos, vs))), pos);\r\n  take_one_extra(update2(unit, vs, v, pos), pos);\r\n  take_one_extra(update2(unit, vs2, v, pos), pos);\r\n}\r\n\r\nlemma void inconsistent_preserved(list\u003cint\u003e vs, int pos, list\u003cint\u003e vs2)\r\n  requires ! consistent(vs, nat_of_int(pos), pos) \u0026*\u0026 length(vs2) == length(vs) \u0026\u0026 take(pos + 1, vs) == take(pos + 1, vs2) \u0026*\u0026 0 \u003c= pos \u0026*\u0026 pos \u003c length(vs);\r\n  ensures ! consistent(vs2, nat_of_int(pos), pos);\r\n{\r\n  take_consistent(vs, nat_of_int(pos), pos);\r\n  take_consistent(vs2, nat_of_int(pos), pos);\r\n}\r\n\r\nlemma void inconsistent_take_core(list\u003cint\u003e vs, nat i, int pos, list\u003cint\u003e vs2)\r\n  requires inconsistent(vs, i, pos) \u0026*\u0026 length(vs) == length(vs2) \u0026*\u0026 take(pos, vs) == take(pos, vs2) \u0026*\u0026 0 \u003c= pos;\r\n  ensures inconsistent(vs2, i, pos);\r\n{\r\n  open inconsistent(vs, i, pos);\r\n  switch(i) {\r\n    case zero: close inconsistent(vs2, i, pos);\r\n    case succ(i0):\r\n      inconsistent_take_core(vs, i0, pos, vs2);\r\n      length_update2(vs, int_of_nat(i0), pos);\r\n      length_update2(vs2, int_of_nat(i0), pos);\r\n      update_same(vs, vs2, pos, int_of_nat(i0));\r\n      if(consistent(update2(unit, vs, int_of_nat(i0), pos), nat_of_int(pos), pos)) {\r\n        inconsistent_take_core(update2(unit, vs, int_of_nat(i0), pos), nat_of_int(length(vs)), pos + 1, update2(unit, vs2, int_of_nat(i0), pos));\r\n        close inconsistent(vs2, i, pos);\r\n      } else {\r\n        inconsistent_preserved(update2(unit, vs, int_of_nat(i0), pos), pos, update2(unit, vs2, int_of_nat(i0), pos));\r\n        close inconsistent(vs2, i, pos);\r\n      }\r\n  }\r\n}\r\n\r\n\r\n  \r\n\r\nlemma void inconsistent_take(list\u003cint\u003e vs, nat i, int pos, list\u003cint\u003e vs2)\r\n  requires length(vs) == length(vs2) \u0026*\u0026 take(pos, vs) == take(pos, vs2) \u0026*\u0026 inconsistent(vs, i, pos) \u0026*\u0026 0 \u003c= pos;\r\n  ensures inconsistent(vs, i, pos) \u0026*\u0026 inconsistent(vs2, i, pos);\r\n{\r\n  duplicate_inconsistent(vs,  i, pos);\r\n  inconsistent_take_core(vs, i, pos, vs2);\r\n}\r\n\r\nfixpoint boolean inrange(list\u003cint\u003e vs, int max) {\r\n  switch(vs) {\r\n    case nil: return true;\r\n    case cons(h, t): return 0 \u003c= h \u0026\u0026 h \u003c max \u0026\u0026 inrange(t, max);\r\n  }\r\n}\r\n\r\nlemma void inrange_update_array(list\u003cint\u003e vs, int max, int v, int pos)\r\n  requires 0 \u003c= pos \u0026\u0026 pos \u003c length(vs) \u0026\u0026 0 \u003c= v \u0026\u0026 v \u003c max \u0026\u0026 inrange(vs, max);\r\n  ensures inrange(update(pos, v, vs), max) == true; \r\n{\r\n  switch(vs) {\r\n    case nil:\r\n    case cons(h, t):\r\n      if(pos == 0) {\r\n      } else {\r\n        inrange_update_array(t, max, v, pos - 1);\r\n      }\r\n  }\r\n}\r\n\r\nlemma void inrange_update(list\u003cint\u003e vs, int max, int v, int pos)\r\n  requires 0 \u003c= pos \u0026\u0026 pos \u003c length(vs) \u0026\u0026 0 \u003c= v \u0026\u0026 v \u003c max \u0026\u0026 inrange(vs, max);\r\n  ensures inrange(update2(unit, vs, v, pos), max) == true; \r\n{\r\n  switch(vs) {\r\n    case nil:\r\n    case cons(h, t):\r\n      if(pos == 0) {\r\n      } else {\r\n        inrange_update(t, max, v, pos - 1);\r\n      }\r\n  }\r\n}\r\n\r\nlemma void inrange_all_eq(list\u003cint\u003e vs, int max, int i)\r\n  requires 0 \u003c max \u0026\u0026 0 \u003c= i \u0026\u0026 i \u003c max \u0026\u0026 all_eq(vs, i);\r\n  ensures inrange(vs, max) == true; \r\n{\r\n  switch(vs) {\r\n    case nil:\r\n    case cons(h, t):\r\n      inrange_all_eq(t, max, i);\r\n  }\r\n}\r\n@*/\r\n\r\nclass NQueens {\r\n  static boolean isConsistent(int[] board, int pos) \r\n    //@ requires board != null \u0026*\u0026 array_slice(board, 0, board.length, ?vs) \u0026*\u0026 0 \u003c= pos \u0026\u0026 pos \u003c board.length;\r\n    //@ ensures array_slice(board, 0, board.length, vs) \u0026*\u0026 result == consistent(vs, nat_of_int(pos), pos);\r\n  {\r\n    int bp = board[pos];\r\n    for(int i = 0; i \u003c pos; i++) \r\n      //@ invariant 0 \u003c= i \u0026*\u0026 i \u003c= pos \u0026*\u0026 array_slice(board, 0, board.length, vs) \u0026*\u0026 consistent(vs, nat_of_int(i), pos) == true;\r\n    {\r\n      int bi = board[i];\r\n      //@ succ_int(i);\r\n      if(bi == bp || pos - i == bp - bi || pos - i == bi - bp) {\r\n        //@ not_consistent_monotonic(vs, pos, nat_of_int(pos - i - 1));\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  static int[] search(int[] board, int pos)\r\n    //@ requires board != null \u0026*\u0026 array_slice(board, 0, board.length, ?vs) \u0026*\u0026 inrange(vs, board.length) == true \u0026*\u0026 0 \u003c= pos \u0026\u0026 pos \u003c= board.length \u0026*\u0026 allconsistent(vs, nat_of_int(pos)) == true;\r\n    /*@ ensures array_slice(board, 0, board.length, ?vs2) \u0026*\u0026 inrange(vs2, board.length) == true \u0026*\u0026 result == null  ? \r\n                  take(pos, vs) == take(pos, vs2) \u0026*\u0026\r\n                  allconsistent(vs2, nat_of_int(pos)) == true \u0026*\u0026\r\n                  inconsistent(vs2, nat_of_int(board.length), pos): \r\n                  result == board \u0026*\u0026 allconsistent(vs2, nat_of_int(length(vs2))) == true; @*/\r\n  {\r\n    if(pos == board.length) {\r\n      return board;\r\n    } else {\r\n      //@ close inconsistent(vs, zero, pos);\r\n      for(int i = 0; i \u003c board.length; i++) \r\n        //@ invariant 0 \u003c= i \u0026*\u0026 i \u003c= board.length \u0026*\u0026 array_slice(board, 0, board.length, ?vs2) \u0026*\u0026 inrange(vs2, board.length) == true \u0026*\u0026 take(pos, vs) == take(pos, vs2) \u0026*\u0026 allconsistent(vs2, nat_of_int(pos)) == true \u0026*\u0026 inconsistent(vs2, nat_of_int(i), pos);\r\n      {\r\n        board[pos] = i;\r\n        //@ assert array_slice(board, 0, board.length, ?vs3);\r\n        //@ take_append(take(pos, vs2), append(cons(i, nil), take(length(vs2) - pos - 1, tail(drop(pos, vs2)))), pos);\r\n        //@ take_allconsistent(vs2, nat_of_int(pos));\r\n        //@ append_allconsistent(take(pos, vs2), nat_of_int(pos), append(cons(i, nil), take(length(vs2) - pos - 1, tail(drop(pos, vs2)))));\r\n        //@ inconsistent_take(vs2, nat_of_int(i), pos, vs3);\r\n        //@ inrange_update(vs2, board.length, i, pos);\r\n        //@ inrange_update_array(vs2, board.length, i, pos);        \r\n        if(isConsistent(board, pos)) {\r\n          //@ succ_int(pos);\r\n          int[] s = search(board, pos + 1);\r\n          if(s != null) {\r\n            return s;\r\n          }\r\n          //@ assert array_slice(board, 0, board.length, ?vs4);\r\n          //@ take_oke(vs3, vs4, pos);\r\n          //@ inconsistent_take(vs2, nat_of_int(i), pos, vs3);\r\n          //@ inconsistent_take(vs3, nat_of_int(i), pos, vs4);\r\n          //@ succ_int(i);\r\n          //@ nth_take(pos, pos + 1, vs4); \r\n          //@ update_nth(vs4, i, pos);\r\n          //@ close inconsistent(vs4, (nat_of_int(i + 1)), pos);\r\n        } else {\r\n          //@ succ_int(i);\r\n          //@ close inconsistent(vs3, (nat_of_int(i + 1)), pos);\r\n        }\r\n      }\r\n      return null;\r\n    }\r\n  }\r\n  \r\n  static int[] startsearch(int[] board) \r\n    //@ requires board != null \u0026*\u0026 array_slice(board, 0, board.length, ?vs) \u0026*\u0026 inrange(vs, board.length) == true;\r\n    //@ ensures array_slice(board, 0, board.length, ?vs2) \u0026*\u0026 inrange(vs2, board.length) == true \u0026*\u0026 result == null ? inconsistent(vs2, nat_of_int(board.length), 0) : result == board \u0026*\u0026 allconsistent(vs2, nat_of_int(length(vs2))) == true;\r\n  {\r\n    return search(board, 0);\r\n  }\r\n  \r\n  public static void main(String[] args) \r\n    //@ requires true;\r\n    //@ ensures true;\r\n  {\r\n    int[] board = new int[2];\r\n    //@ int length = board.length;\r\n    //@ assert array_slice(board, 0, board.length, ?vs);\r\n    //@ inrange_all_eq(vs, 2, 0);\r\n    int[] res = startsearch(board);\r\n      //@ assert array_slice(board, 0, length, ?vs2);\r\n    if(res == null) {\r\n      // we can prove from startsearch's postcondition that any board of size 2 is inconsistent\r\n      int[] myboard = new int[2];\r\n      myboard[0] = 0;\r\n      myboard[1] = 1;\r\n      //@ assert array_slice(board, 0, board.length, ?myvs);\r\n      //@ inconsistent_take(vs2, nat_of_int(board.length), 0, myvs);\r\n      //@ assert inconsistent(myvs, nat_of_int(myboard.length), 0);\r\n    } else {\r\n      //@ assert vs2 == cons(?p0, cons(?p1, nil));\r\n      //@ succ_int(1);\r\n      //@ succ_int(0);\r\n      //@ assert nat_of_int(length(vs2)) == succ(succ(zero));\r\n      /*@\r\n      if (p0 \u003c 1) {\r\n          assert p0 == 0;\r\n      } else {\r\n          assert p0 == 1;\r\n      }\r\n      @*/\r\n      /*@\r\n      if (p1 \u003c 1) {} else {}\r\n      @*/\r\n      assert false; // not reachable\r\n    }\r\n  }\r\n}\r\n",
        "name": "problem4.java",
        "path": "examples/vstte2010/problem4.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/vstte2010/problem4.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 360,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires board != null \u0026*\u0026 array_slice(board, 0, board.length, ?vs) \u0026*\u0026 0 \u003c= pos \u0026\u0026 pos \u003c board.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 361,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures array_slice(board, 0, board.length, vs) \u0026*\u0026 result == consistent(vs, nat_of_int(pos), pos);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 378,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires board != null \u0026*\u0026 array_slice(board, 0, board.length, ?vs) \u0026*\u0026 inrange(vs, board.length) == true \u0026*\u0026 0 \u003c= pos \u0026\u0026 pos \u003c= board.length \u0026*\u0026 allconsistent(vs, nat_of_int(pos)) == true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 424,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires board != null \u0026*\u0026 array_slice(board, 0, board.length, ?vs) \u0026*\u0026 inrange(vs, board.length) == true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 425,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures array_slice(board, 0, board.length, ?vs2) \u0026*\u0026 inrange(vs2, board.length) == true \u0026*\u0026 result == null ? inconsistent(vs2, nat_of_int(board.length), 0) : result == board \u0026*\u0026 allconsistent(vs2, nat_of_int(length(vs2))) == true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 431,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 432,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Program {\n\n    public static boolean getRandomBool()\n        //@ requires true;\n        //@ ensures true;\n    {\n        return Math.random() \u003c 0.5;\n    }\n\n}\n",
        "name": "FloatingPoint.java",
        "path": "examples/java/FloatingPoint.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/FloatingPoint.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Program {\r\n    static short abs(short x)\r\n        //@ requires true;\r\n        //@ ensures true; //0 \u003c= result \u0026*\u0026 result == x || result == -x;\r\n    {\r\n        if (x \u003c 0) {\r\n            x = /*@truncating@*/(short)-x;\r\n            return x;\r\n        } else {\r\n            return x;\r\n        }\r\n    }\r\n}\r\n",
        "name": "abs_trunc.java",
        "path": "javacard_tutorial/abs_trunc.java",
        "url": "/github.com/verifast/verifast/-/blob/javacard_tutorial/abs_trunc.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 2,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true; //0 \u003c= result \u0026*\u0026 result == x || result == -x;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import verifast.*;\r\n\r\nclass Cell\r\n{\r\n    Monitor monitor;\r\n    //@ int min;\r\n    int value;\r\n}\r\n\r\n//@ predicate_ctor Cell(Cell c)() = [1/2]c.min |-\u003e ?min \u0026*\u0026 c.value |-\u003e ?v \u0026*\u0026 0 \u003c= min \u0026*\u0026 min \u003c= v;\r\n\r\nclass IncrementorCriticalSection implements CriticalSection {\r\n\r\n    Cell cell;\r\n    int increment;\r\n    \r\n    //@ predicate pre(predicate() payload) = cell |-\u003e ?c \u0026*\u0026 increment |-\u003e ?i \u0026*\u0026 0 \u003c= i \u0026*\u0026 payload == Cell(c);\r\n    //@ predicate post() = cell |-\u003e ?c \u0026*\u0026 increment |-\u003e _;\r\n    \r\n    public void run()\r\n        //@ requires pre(?payload) \u0026*\u0026 payload();\r\n        //@ ensures post() \u0026*\u0026 payload();\r\n    {\r\n        //@ open pre(_);\r\n        //@ open Cell(cell)();\r\n        cell.value += increment;\r\n        //@ close Cell(cell)();\r\n        //@ close post();\r\n    }\r\n    \r\n}\r\n\r\nclass IncrementorThread implements Runnable {\r\n\r\n    Cell cell;\r\n    \r\n    IncrementorThread(Cell c)\r\n        //@ requires true;\r\n        //@ ensures cell |-\u003e c;\r\n    { cell = c; }\r\n    \r\n    int pickIncrement()\r\n        //@ requires true;\r\n        //@ ensures 0 \u003c= result;\r\n    {\r\n        return 1;\r\n    }\r\n    \r\n    //@ predicate pre() = cell |-\u003e ?c \u0026*\u0026 [_]c.monitor |-\u003e ?m \u0026*\u0026 [_]m.Monitor(Cell(c));\r\n    //@ predicate post() = cell |-\u003e ?c \u0026*\u0026 [_]c.monitor |-\u003e ?m \u0026*\u0026 [_]m.Monitor(Cell(c));\r\n    \r\n    public void run()\r\n        //@ requires pre();\r\n        //@ ensures post();\r\n    {\r\n        for (;;)\r\n            //@ invariant cell |-\u003e ?c \u0026*\u0026 [_]c.monitor |-\u003e ?m \u0026*\u0026 [_]m.Monitor(Cell(c));\r\n        {\r\n            IncrementorCriticalSection s = new IncrementorCriticalSection();\r\n            s.cell = cell;\r\n            s.increment = pickIncrement();\r\n            cell.monitor.sync(s);\r\n        }\r\n    }\r\n    \r\n}\r\n\r\nclass ReaderCriticalSection implements CriticalSection {\r\n    \r\n    Cell cell;\r\n    int lastValue;\r\n    \r\n    //@ predicate pre(predicate() payload) = [1/2]cell |-\u003e ?c \u0026*\u0026 lastValue |-\u003e ?v \u0026*\u0026 [1/2]c.min |-\u003e ?min \u0026*\u0026 v \u003c= min \u0026*\u0026 payload == Cell(c);\r\n    //@ predicate post() = [1/2]cell |-\u003e ?c \u0026*\u0026 lastValue |-\u003e ?v \u0026*\u0026 [1/2]c.min |-\u003e v;\r\n    \r\n    public void run()\r\n        //@ requires pre(?payload) \u0026*\u0026 payload();\r\n        //@ ensures post() \u0026*\u0026 payload();\r\n    {\r\n        //@ open pre(_);\r\n        //@ open Cell(cell)();\r\n        if (cell.value \u003c lastValue)\r\n            assert false;\r\n        lastValue = cell.value;\r\n        //@ cell.min = lastValue;\r\n        //@ close Cell(cell)();\r\n        //@ close post();\r\n    }\r\n    \r\n}\r\n\r\nclass ReaderThread implements Runnable {\r\n\r\n    Cell cell;\r\n    \r\n    //@ predicate pre() = cell |-\u003e ?c \u0026*\u0026 [_]c.monitor |-\u003e ?m \u0026*\u0026 [_]m.Monitor(Cell(c)) \u0026*\u0026 [1/2]c.min |-\u003e ?min \u0026*\u0026 0 \u003c= min;\r\n    //@ predicate post() = true;\r\n    \r\n    ReaderThread(Cell c)\r\n        //@ requires true;\r\n        //@ ensures cell |-\u003e c;\r\n    { cell = c; }\r\n    \r\n    public void run()\r\n        //@ requires pre();\r\n        //@ ensures post();\r\n    {\r\n        //@ open pre();\r\n        ReaderCriticalSection s = new ReaderCriticalSection();\r\n        s.cell = cell;\r\n        s.lastValue = Integer.MIN_VALUE;\r\n        \r\n        for (;;)\r\n            //@ invariant cell |-\u003e ?c \u0026*\u0026 [_]c.monitor |-\u003e ?m \u0026*\u0026 [_]m.Monitor(Cell(c)) \u0026*\u0026 s.cell |-\u003e c \u0026*\u0026 s.lastValue |-\u003e ?v \u0026*\u0026 [1/2]c.min |-\u003e ?min \u0026*\u0026 v \u003c= min;\r\n        {\r\n            //@ close s.pre(Cell(c));\r\n            cell.monitor.sync(s);\r\n            //@ open s.post();\r\n        }\r\n        //@ close post();\r\n    }\r\n    \r\n}\r\n\r\npublic class MonitorExample {\r\n    \r\n    public static void main(String[] args)\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        Cell cell = new Cell();\r\n        //@ close exists(Cell(cell));\r\n        //@ close Cell(cell)();\r\n        cell.monitor = new Monitor();\r\n        //@ leak cell.monitor |-\u003e ?m \u0026*\u0026 m.Monitor(_);\r\n        new Thread(new ReaderThread(cell)).start();\r\n        new Thread(new IncrementorThread(cell)).start();\r\n    }\r\n    \r\n}",
        "name": "MonitorExample.java",
        "path": "examples/java/MonitorExample.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/MonitorExample.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre(?payload) \u0026*\u0026 payload();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post() \u0026*\u0026 payload();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 37,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures cell |-\u003e c;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 42,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 43,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures 0 \u003c= result;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 52,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 53,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 76,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre(?payload) \u0026*\u0026 payload();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 77,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post() \u0026*\u0026 payload();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 99,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 100,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures cell |-\u003e c;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 104,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 105,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 127,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 128,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "/*@\r\npredicate linkedlist(LinkedList l, list\u003cint\u003e vs) =\r\n  l != null \u0026*\u0026\r\n  [_]l.head |-\u003e ?head \u0026*\u0026\r\n  [_]l.tail |-\u003e ?tail \u0026*\u0026\r\n  [_]l.length |-\u003e ?length \u0026*\u0026\r\n  (tail == null ? vs == nil :\r\n  linkedlist(tail, ?vs2) \u0026*\u0026 vs == cons(head, vs2)) \u0026*\u0026\r\n  length(vs) == length;\r\n  \r\nlemma void copy(LinkedList l)\r\n  requires linkedlist(l, ?vs);\r\n  ensures linkedlist(l, vs) \u0026*\u0026 linkedlist(l, vs);\r\n{\r\n  open linkedlist(l, vs);\r\n  if(l.tail == null) {\r\n\r\n  } else {\r\n    copy(l.tail);\r\n  }\r\n  close linkedlist(l, vs);\r\n  close linkedlist(l, vs);\r\n}\r\n@*/\r\n\r\nclass LinkedList {\r\n  int head;\r\n  LinkedList tail;\r\n  int length;\r\n  \r\n  public LinkedList() \r\n    //@ requires true;\r\n    //@ ensures this.head |-\u003e 0 \u0026*\u0026 this.tail |-\u003e null \u0026*\u0026 this.length |-\u003e 0;\r\n  {\r\n    \r\n  }\r\n  \r\n  public static LinkedList New()\r\n    //@ requires true;\r\n    //@ ensures result != null \u0026*\u0026 linkedlist(result, nil);\r\n  {\r\n    LinkedList l = new LinkedList();\r\n    //@ leak l.head |-\u003e _;\r\n    //@ leak l.tail |-\u003e null;\r\n    //@ leak l.length |-\u003e 0;\r\n    //@ close linkedlist(l, nil);\r\n    return l;\r\n  }\r\n  \r\n  public LinkedList Cons(int d)\r    //@ requires linkedlist(this, ?vs);\r\n    //@ ensures result != null \u0026*\u0026 linkedlist(this, vs) \u0026*\u0026 linkedlist(result, cons(d, vs));\r\n  {\r\n    //@ copy(this);\r\n    //@ open linkedlist(this, vs);\r\n    LinkedList r = new LinkedList();\r\n    r.head = d;\r\n    r.tail = this;\r\n    r.length = length+1;\r\n    //@ close linkedlist(this, vs);\r\n    //@ leak r.head |-\u003e d;\r\n    //@ leak r.tail |-\u003e _;\r\n    //@ leak r.length |-\u003e _;\r\n    //@ close linkedlist(r, cons(d, vs));\r\n    return r;\r\n  }\r\n  \r\n  public LinkedList Concat(LinkedList end)\r\n    //@ requires linkedlist(this, ?vs) \u0026*\u0026 linkedlist(end, ?vs2);\r\n    //@ ensures result != null \u0026*\u0026 linkedlist(this, vs) \u0026*\u0026 linkedlist(end, vs2) \u0026*\u0026 linkedlist(result, append(vs, vs2));\r\n  {\r\n    //@ open linkedlist(this,vs);\r\n    if(length == 0) {\r\n      //@ copy(end);\r\n      //@ open linkedlist(end, vs2);\r\n      //@ close linkedlist(end, vs2);\r\n      return end;\r\n      //@ close linkedlist(this,vs);\r\n    } else {\r\n      LinkedList c = tail.Concat(end);\r\n      LinkedList r = c.Cons(head);\r\n      //@ close linkedlist(this,vs);\r\n      return r;\r\n    }\r\n  }\r\n  \r\n  public LinkedList reverse()\r\n    //@ requires linkedlist(this, ?vs);\r\n    //@ ensures result != null \u0026*\u0026 linkedlist(this, vs) \u0026*\u0026 linkedlist(result, reverse(vs));\r\n  {\r\n    //@ open linkedlist(this, vs);\r\n    LinkedList r;\r\n    if(length == 0) {\r\n      r = New();\r\n    } else {\r\n      r = tail.reverse();\r\n      LinkedList e = New();\r\n      e = e.Cons(head);\r\n      r = r.Concat(e);\r\n    }\r\n    //@ close linkedlist(this, vs);\r\n    return r;\r\n  }\r\n}\r\n\r\n/*@\r\npredicate queue(AmortizedQueue q, list\u003cint\u003e vs) =\r\n  q != null \u0026*\u0026 q.front |-\u003e ?front \u0026*\u0026 q.rear |-\u003e ?rear \u0026*\u0026 linkedlist(front, ?vs1) \u0026*\u0026 linkedlist(rear, ?vs2) \u0026*\u0026 vs == append(vs1, reverse(vs2)) \u0026*\u0026 length(vs2) \u003c= length(vs1);\r\n@*/\r\n\r\nclass AmortizedQueue {\n  LinkedList front;\n  LinkedList rear;\n  \n  AmortizedQueue() \n    //@ requires true;\n    //@ ensures queue(this, nil);\n  {\n    front = LinkedList.New();\n    rear = LinkedList.New();\n    //@ close queue(this, nil);\n  }\n  \n  AmortizedQueue(LinkedList front, LinkedList rear) \n    //@ requires linkedlist(front, ?vs1) \u0026*\u0026 linkedlist(rear, ?vs2);\n    //@ ensures queue(this, append(vs1, reverse(vs2))) \u0026*\u0026 linkedlist(front, vs1) \u0026*\u0026 linkedlist(rear, vs2);\n  {\n    //@ copy(front);\n    //@ copy(rear);\n    //@ open linkedlist(front, vs1);\n    //@ open linkedlist(rear, vs2);\n    if(rear.length \u003c= front.length) {\n      this.front = front;\n      this.rear = rear;\n    } else {\n      LinkedList f = rear.reverse();\n      this.front = front.Concat(f);\n      this.rear = LinkedList.New();\n    }\n    //@ close linkedlist(front, vs1);\n    //@ close linkedlist(rear, vs2);\n    //@ close queue(this, append(vs1, reverse(vs2)));\n  }\n\n  int front()\n    //@ requires queue(this, ?vs) \u0026*\u0026 vs != nil;\n    //@ ensures queue(this, vs) \u0026*\u0026 result == head(vs);\n  {\n    //@ open queue(this, vs);\n    //@ LinkedList front = this.front;\n    //@ LinkedList rear = this.rear;\n    //@ open linkedlist(front, ?vs1);\n    //@ open linkedlist(rear, ?vs2);\n    int r = this.front.head;\n    //@ close linkedlist(front, vs1);\n    //@ close linkedlist(rear, vs2);\n    //@ close queue(this, vs);\n    return r;\n  }\n  \n  AmortizedQueue tail() \n    //@ requires queue(this, ?vs) \u0026*\u0026 vs != nil;\n    //@ ensures queue(this, vs) \u0026*\u0026 queue(result, tail(vs));\n  {\n    //@ open queue(this, vs);\n    //@ LinkedList front = this.front;\n    //@ LinkedList rear = this.rear;\n    //@ open linkedlist(front, ?vs1);\n    //@ open linkedlist(rear, ?vs2);\n    //@ close linkedlist(rear, vs2);\n    AmortizedQueue r = new AmortizedQueue(this.front.tail, this.rear);\n    //@ close linkedlist(front, vs1);\n    //@ close queue(this, vs);\n    return r;\n  }\n  \n  AmortizedQueue enqueue(int item)\n    //@ requires queue(this, ?vs);\n    //@ ensures result != null \u0026*\u0026 queue(this, vs) \u0026*\u0026 queue(result, append(vs, cons(item, nil)));\n  {\n    //@ open queue(this, vs);\n    //@ LinkedList rear2 = this.rear;\n    //@ open linkedlist(rear2, ?vs2);\n    //@ close linkedlist(rear2, vs2);\n    //@ LinkedList front = this.front;\n    //@ open linkedlist(front, ?vs1);\n    //@ close linkedlist(front, vs1);\n    LinkedList r = rear.Cons(item);\n    AmortizedQueue q = new AmortizedQueue(this.front, r);\n    //@ append_assoc(vs1, reverse(vs2), cons(item, nil));\n    //@ close queue(this, vs);\n    return q;\n  }\n}\n\nclass Program {\n  public static void main(String[] args) \n    //@ requires true;\n    //@ ensures true;\n  {\n    AmortizedQueue q1 = new AmortizedQueue();\n    AmortizedQueue q2 = q1.enqueue(5);\n    AmortizedQueue q3 = q1.enqueue(6);\n    int res1 = q2.front();\n    int res2 = q3.front();\n    assert(res1 == 5);\n    assert(res2 == 6);\n  }\n}",
        "name": "AmortizedQueue.java",
        "path": "examples/java/AmortizedQueue.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/AmortizedQueue.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 32,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures this.head |-\u003e 0 \u0026*\u0026 this.tail |-\u003e null \u0026*\u0026 this.length |-\u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 39,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result != null \u0026*\u0026 linkedlist(result, nil);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 49,
          "offsetAndLengths": [
            [
              36,
              13
            ]
          ],
          "preview": "  public LinkedList Cons(int d)\r    //@ requires linkedlist(this, ?vs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 50,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result != null \u0026*\u0026 linkedlist(this, vs) \u0026*\u0026 linkedlist(result, cons(d, vs));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 67,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires linkedlist(this, ?vs) \u0026*\u0026 linkedlist(end, ?vs2);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 68,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result != null \u0026*\u0026 linkedlist(this, vs) \u0026*\u0026 linkedlist(end, vs2) \u0026*\u0026 linkedlist(result, append(vs, vs2));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 86,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires linkedlist(this, ?vs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 87,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result != null \u0026*\u0026 linkedlist(this, vs) \u0026*\u0026 linkedlist(result, reverse(vs));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 114,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 115,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures queue(this, nil);"
        },
        {
          "limitHit": false,
          "lineNumber": 123,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires linkedlist(front, ?vs1) \u0026*\u0026 linkedlist(rear, ?vs2);"
        },
        {
          "limitHit": false,
          "lineNumber": 124,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures queue(this, append(vs1, reverse(vs2))) \u0026*\u0026 linkedlist(front, vs1) \u0026*\u0026 linkedlist(rear, vs2);"
        },
        {
          "limitHit": false,
          "lineNumber": 144,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires queue(this, ?vs) \u0026*\u0026 vs != nil;"
        },
        {
          "limitHit": false,
          "lineNumber": 145,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures queue(this, vs) \u0026*\u0026 result == head(vs);"
        },
        {
          "limitHit": false,
          "lineNumber": 160,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires queue(this, ?vs) \u0026*\u0026 vs != nil;"
        },
        {
          "limitHit": false,
          "lineNumber": 161,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures queue(this, vs) \u0026*\u0026 queue(result, tail(vs));"
        },
        {
          "limitHit": false,
          "lineNumber": 176,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires queue(this, ?vs);"
        },
        {
          "limitHit": false,
          "lineNumber": 177,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result != null \u0026*\u0026 queue(this, vs) \u0026*\u0026 queue(result, append(vs, cons(item, nil)));"
        },
        {
          "limitHit": false,
          "lineNumber": 196,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 197,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "/*@\r\nfixpoint int sum(list\u003cint\u003e vs) {\r\n  switch(vs) {\r\n    case nil: return 0;\r\n    case cons(h, t): return h + sum(t);\r\n  }\r\n}\r\n\r\nlemma_auto(sum(append(xs, ys))) void sum_append(list\u003cint\u003e xs, list\u003cint\u003e ys) \r\n  requires true;\r\n  ensures sum(append(xs, ys)) == sum(xs) + sum(ys);\r\n{\r\n  switch(xs) {\r\n    case nil: \r\n    case cons(h, t): sum_append(t, ys);\r\n  }\r\n}\r\n\r\nlemma void take_one_more2\u003ct\u003e(list\u003ct\u003e vs, int i)\r\n  requires 0 \u003c= i \u0026\u0026 i \u003c length(vs);\r\n  ensures append(take(i, vs), cons(head(drop(i, vs)), nil)) == take(i + 1, vs);\r\n{\r\n  switch(vs) {\r\n    case nil:\r\n    case cons(h, t):\r\n      if(i == 0) \r\n      {\r\n      } else {\r\n        take_one_more2(t, i - 1);\r\n      }\r\n  }\r\n}\r\n\r\nfixpoint boolean le(int x, int y) { return x \u003c= y; }\r\n\r\nfixpoint boolean forall_le(list\u003cint\u003e vs, int v) {\r\n    return forall(vs, (le)(v));\r\n}\r\n\r\nlemma void forall_le_mono(list\u003cint\u003e vs, int v1, int v2)\r\n  requires forall_le(vs, v1) \u0026\u0026 v2 \u003c= v1;\r\n  ensures forall_le(vs, v2) == true;\r\n{\r\n  switch (vs) {\r\n    case nil:\r\n    case cons(v0, vs0):\r\n      forall_le_mono(vs0, v1, v2);\r\n  }\r\n}\r\n\r\nlemma void store_take_drop\u003ct\u003e(list\u003ct\u003e xs, int index, t v)\r\n  requires 0 \u003c= index \u0026\u0026 index \u003c length(xs);\r\n  ensures update(index, v, xs) == append(take(index, xs), cons(v, drop(index + 1, xs)));\r\n{\r\n  switch(xs) {\r\n    case nil: \r\n    case cons(h, t): \r\n      if(index == 0) {\r\n      } else { \r\n        store_take_drop(t, index - 1, v);\r\n      }\r\n  }\r\n}\r\n\r\nlemma void drop_one_more\u003ct\u003e(list\u003ct\u003e xs, int index)\r\n  requires 0 \u003c= index \u0026\u0026 index \u003c length(xs);\r\n  ensures drop(index, xs) == cons(nth(index, xs), drop(index + 1, xs));\r\n{\r\n  switch(xs) {\r\n    case nil: \r\n    case cons(h, t): \r\n      if(index == 0) {\r\n      } else { \r\n        drop_one_more(t, index - 1);\r\n      }\r\n  }\r\n}\r\n\r\nfixpoint list\u003cint\u003e insert_sorted(list\u003cint\u003e vs, int v) {\r\n  switch(vs) {\r\n    case nil: return cons(v, nil);\r\n    case cons(h, t): return v \u003c h ? cons(v, cons(h, t)) : cons(h, insert_sorted(t, v));\r\n  }\r\n}\r\n\r\nfixpoint list\u003cint\u003e sort(list\u003cint\u003e vs) {\r\n switch(vs) {\r\n   case nil: return nil;\r\n   case cons(h, t): return insert_sorted(sort(t), h);\r\n }\r\n}\r\n\r\nfixpoint boolean is_sorted(list\u003cint\u003e vs) {\r\n  switch(vs) {\r\n    case nil: return true;\r\n    case cons(h, t):\r\n      return switch(t) { \r\n        case nil: return true; \r\n        case cons(h0, t0): return h \u003c= h0 \u0026\u0026 is_sorted(t);\r\n      };\r\n  }\r\n}\r\n\r\nlemma void insert_sorted_preserves_is_sorted(list\u003cint\u003e vs, int v)\r\n  requires is_sorted(vs) == true;\r\n  ensures is_sorted(insert_sorted(vs, v)) == true;\r\n{\r\n  switch(vs) {\r\n    case nil:\r\n    case cons(h, t):\r\n      if(v \u003c h) {\r\n      } else {\r\n        switch(t) { case nil: case cons(h0, t0): };\r\n        insert_sorted_preserves_is_sorted(t, v);\r\n      }\r\n  }\r\n}\r\n\r\nlemma_auto(is_sorted(sort(vs))) void sort_sorts(list\u003cint\u003e vs) \r\n  requires true;\r\n  ensures is_sorted(sort(vs)) == true;\r\n{\r\n  switch(vs) {\r\n    case nil:\r\n    case cons(h, t): \r\n      switch(t) {\r\n        case nil: \r\n        case cons(h0, t0):\r\n          sort_sorts(t);\r\n          insert_sorted_preserves_is_sorted(sort(t), h);\r\n      }\r\n  }\r\n}\r\n\r\nfixpoint boolean is_perm(list\u003cint\u003e xs, list\u003cint\u003e ys)\r\n{\r\n  switch(xs) {\r\n    case nil: return ys == nil;\r\n    case cons(h, t):\r\n      return mem(h, ys) \u0026\u0026 is_perm(t, remove(h, ys));\r\n  }\r\n}\r\n\r\nlemma_auto void is_perm_reflexive(list\u003cint\u003e xs) \r\n  requires true;\r\n  ensures is_perm(xs, xs) == true;\r\n{\r\n  switch(xs) {\r\n    case nil: \r\n    case cons(h, t): \r\n      switch(t) {\r\n        case nil:\r\n        case cons(h0, t0):\r\n          is_perm_reflexive(t);\r\n      }\r\n  }\r\n}\r\n\r\nfixpoint int count\u003ct\u003e(list\u003ct\u003e xs, t x) {\r\n  switch(xs) {\r\n    case nil: return 0;\r\n    case cons(h, t): return h == x ? 1 + count(t, x) : count(t, x);\r\n  }\r\n}\r\n\r\nlemma void remove_mem(list\u003cint\u003e xs, int x, int y)\r\n  requires x != y \u0026*\u0026 mem(x, xs) == true;\r\n  ensures mem(x, remove(y, xs)) == true;\r\n{\r\n  switch(xs) {\r\n    case nil:\r\n    case cons(h, t):\r\n     if(h == x) {\r\n     } else {\r\n       assert mem(x, t) == true;\r\n       remove_mem(t, x, y);\r\n     }\r\n  }\r\n}\r\n\r\nlemma void mem_remove(list\u003cint\u003e xs, int x, int y)\r\n  requires mem(x, remove(y, xs)) == true;\r\n  ensures mem(x, xs) == true;\r\n{\r\n  switch(xs) {\r\n    case nil:\r\n    case cons(h, t):\r\n     if(h == x) {\r\n     } else {\r\n      if(h == y) {\r\n      } else {\r\n        mem_remove(t, x, y);\r\n      }\r\n     }\r\n  }\r\n}\r\n\r\nlemma void remove_comm(list\u003cint\u003e xs, int x, int y) \r\n  requires true;\r\n  ensures remove(x, remove(y, xs)) == remove(y, remove(x, xs));\r\n{\r\n  switch(xs) {\r\n    case nil: \r\n    case cons(h, t):\r\n      if(h == x) {\r\n      } else {\r\n        if(h == y) {\r\n        } else {\r\n          remove_comm(t, x, y);\r\n        }\r\n      }\r\n  }\r\n}\r\n\r\nfixpoint boolean subset(list\u003cint\u003e xs, list\u003cint\u003e ys) {\r\n  switch(xs) {\r\n    case nil: return true;\r\n    case cons(h, t): return mem(h, ys) \u0026\u0026 subset(t, ys);\r\n  }\r\n}\r\n\r\nlemma void is_perm_mem(list\u003cint\u003e xs, list\u003cint\u003e ys, int x) \r\n  requires is_perm(xs, ys) == true \u0026*\u0026 mem(x, xs) == true;\r\n  ensures mem(x, ys) == true;\r\n{\r\n  switch(xs) {\r\n    case nil:\r\n    case cons(h, t):\r\n      if(h == x) {\r\n      } else {\r\n         switch(ys) {\r\n           case nil:\r\n           case cons(h0, t0):\r\n             if(h0 == x) {\r\n             } else {\r\n               is_perm_mem(t, remove(h, ys), x);\r\n               mem_remove(ys, x, h);\r\n             }\r\n         }\r\n      }\r\n  }\r\n}\r\n\r\nlemma void is_perm_remove(list\u003cint\u003e xs, list\u003cint\u003e ys, int x)\r\n  requires is_perm(xs, ys) == true;\r\n  ensures is_perm(remove(x, xs), remove(x, ys)) == true;\r\n{\r\n  switch(xs) {\r\n    case nil:\r\n    case cons(h, t):\r\n      if(x == h) {\r\n      } else {\r\n        remove_mem(ys, h, x); \r\n        remove_comm(ys, h, x);\r\n        is_perm_remove(t, remove(h, ys), x);  \r\n      }\r\n  }\r\n}\r\n\r\n\r\nlemma void is_perm_transitive(list\u003cint\u003e xs, list\u003cint\u003e ys, list\u003cint\u003e zs)\r\n  requires is_perm(xs, ys) == true \u0026*\u0026 is_perm(ys, zs)== true;\r\n  ensures is_perm(xs, zs) == true;\r\n{\r\n  switch(xs) {\r\n    case nil:\r\n    case cons(h, t):\r\n      is_perm_mem(ys, zs, h);\r\n      is_perm_remove(ys, zs, h);\r\n      is_perm_transitive(t, remove(h, ys), remove(h, zs));\r\n  }\r\n}\r\n\r\nlemma void insert_sorted_is_perm(list\u003cint\u003e xs, int v)\r\n  requires true;\r\n  ensures is_perm(insert_sorted(xs, v), cons(v, xs)) == true;\r\n{\r\n  switch(xs) {\r\n    case nil:\r\n    case cons(h, t):\r\n      if(v \u003c h) {\r\n      } else {\r\n        insert_sorted_is_perm(t, v);\r\n      }\r\n  }\r\n}\r\n\r\nlemma_auto void sort_is_perm(list\u003cint\u003e xs)\r\n  requires true;\r\n  ensures is_perm(sort(xs), xs) == true;\r\n{\r\n  switch(xs) {\r\n   case nil:\r\n   case cons(h, t):\r\n     switch(t) {\r\n       case nil:\r\n       case cons(h0, t0):\r\n         sort_is_perm(t);\r\n         insert_sorted_is_perm(sort(t), h);\r\n         is_perm_transitive(insert_sorted(sort(t), h),  cons(h, sort(t)), xs);        \r\n     }\r\n  }\r\n}\r\n@*/\r\n\r\nclass Comprehensions {\r\n  public static int array_sum(int[] a)\r\n    //@ requires array_slice(a, 0, a.length, ?vs);\r\n    //@ ensures array_slice(a, 0, a.length, vs) \u0026*\u0026 result == sum(vs);\r\n  {\r\n    int total = 0;\r\n    int i = 0;\r\n    while(i \u003c a.length) \r\n      //@ invariant 0 \u003c= i \u0026*\u0026 i \u003c= a.length \u0026*\u0026 array_slice(a, 0, a.length, vs) \u0026*\u0026 total == sum(take(i, vs));\r\n    {\r\n      int tmp = a[i];\r\n      total = total + tmp;\r\n      //@ length_drop(i, vs);\r\n      //@ take_one_more2(vs, i);\r\n      i++;\r\n    }\r\n    return total;\r\n  }\r\n  \r\n  public static int get(int[] a, int index)\r\n    //@ requires array_slice(a, 0, a.length, ?vs) \u0026*\u0026 0 \u003c= index \u0026*\u0026 index \u003c a.length;\r\n    //@ ensures array_slice(a, 0, a.length, vs) \u0026*\u0026 result == nth(index, vs);\r\n  {\r\n    int tmp = a[index];\r\n    //@ length_drop(index, vs);\r\n    //@ nth_drop(vs, index);\r\n    return tmp;\r\n  }\r\n  \r\n  public static void set(int[] a, int index, int v)\r\n    //@ requires array_slice(a, 0, a.length, ?vs) \u0026*\u0026 0 \u003c= index \u0026*\u0026 index \u003c a.length;\r\n    //@ ensures array_slice(a, 0, a.length, update(index, v, vs));\r\n  {\r\n    a[index] = v;\r\n  }\r\n\r\n  \r\n  public static int min(int[] a) \r\n    //@ requires array_slice(a, 0, a.length, ?vs) \u0026*\u0026 vs != nil;\r\n    //@ ensures array_slice(a, 0, a.length, vs) \u0026*\u0026 mem(result, vs) == true \u0026\u0026 forall_le(vs, result);\r\n  { \r\n    //@ switch(vs) { case nil:  case cons(h, t): }\r\n    int tmp = indexOfMin(a, 0);\r\n    //@ length_drop(tmp, vs);\r\n    //@ nth_drop(vs, tmp);\r\n    //@ mem_nth(tmp, vs);\r\n    return a[tmp];\r\n  }\r\n  \r\n  public static int indexOfMin(int[] a, int start) \r\n    //@ requires array_slice(a, start, a.length, ?vs) \u0026*\u0026 vs != nil \u0026*\u0026 length(vs) != 0;\r\n    //@ ensures array_slice(a, start, a.length, vs) \u0026*\u0026 start \u003c= result \u0026*\u0026 result \u003c a.length \u0026*\u0026 forall_le(vs, nth(result - start, vs)) == true;\r\n  {\r\n    int min = start;\r\n    int j = start;\r\n    while(j \u003c a.length)\r\n      //@ invariant start \u003c= min \u0026*\u0026 min \u003c a.length \u0026\u0026 min \u003c= j \u0026*\u0026 j \u003c= a.length \u0026*\u0026 array_slice(a, start, a.length, vs) \u0026*\u0026 forall_le(take(j - start, vs), nth(min - start, vs)) == true;\r\n    {\r\n      int tmp = a[j];\r\n      int abc = 0;\r\n      //@ length_drop(j - start, vs);\r\n      int tmp2 = a[min];\r\n      //@ length_drop(min - start, vs);\r\n      //@ int old_min = min;\r\n      if(tmp \u003c tmp2) {\r\n        min = j;\r\n      }\r\n      //@ take_one_more(j - start, vs);\r\n      //@ drop_one_more(vs, j - start);\r\n      //@ forall_append(take(j - start, vs), {nth(j - start, vs)}, (le)(nth(min - start, vs)));\r\n      //@ forall_le_mono(take(j - start, vs), nth(old_min - start, vs), nth(min - start, vs));\r\n      j++;\r\n    }\r\n    return min;\r\n  }\r\n  \r\n    \r\n  public static void insert_sorted(int[] a, int start)\r\n    //@ requires array_slice(a, start, a.length, ?vs) \u0026*\u0026 start \u003c a.length;\r\n    //@ ensures array_slice(a, start, a.length, insert_sorted(tail(vs), head(vs)));\r\n  {\r\n    if(start == a.length - 1) {\r\n      //@ switch(vs) { case nil: case cons(h, t): }\r\n      //@ switch(tail(vs)) { case nil: case cons(h, t): }\r\n    } else {\r\n      int tmp = a[start];\r\n      int tmp2 = a[start + 1];\r\n      //@ switch(vs) { case nil: case cons(h, t): }\r\n      //@ switch(tail(vs)) { case nil: case cons(h, t): }\r\n      if(tmp \u003c tmp2) {\r\n      } else {\r\n        a[start + 1] = tmp;\r\n        insert_sorted(a, start + 1);\r\n        a[start] = tmp2;\r\n      }\r\n    }\r\n  }\r\n  \r\n  public static void my_sort(int[] a, int start)\r\n    //@ requires array_slice(a, start, a.length, ?vs);\r\n    //@ ensures array_slice(a, start, a.length, sort(vs));\r\n  {\r\n    if(start == a.length) {\r\n      //@ switch(vs) { case nil: case cons(h, t): }\r\n    } else {\r\n      //@ switch(vs) { case nil: case cons(h, t): }\r\n      my_sort(a, start + 1);\r\n      insert_sorted(a, start);\r\n    }\r\n  }\r\n  \r\n  public static void sort(int[] a) \r\n    //@ requires array_slice(a, 0, a.length, ?vs);\r\n    //@ ensures array_slice(a, 0, a.length, ?vs2) \u0026*\u0026 is_sorted(vs2) == true \u0026*\u0026 is_perm(vs2, vs) == true;\r\n  {\r\n    my_sort(a, 0);\r\n  }\r\n}",
        "name": "Comprehensions.java",
        "path": "examples/java/Comprehensions.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Comprehensions.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 307,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires array_slice(a, 0, a.length, ?vs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 308,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures array_slice(a, 0, a.length, vs) \u0026*\u0026 result == sum(vs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 325,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires array_slice(a, 0, a.length, ?vs) \u0026*\u0026 0 \u003c= index \u0026*\u0026 index \u003c a.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 326,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures array_slice(a, 0, a.length, vs) \u0026*\u0026 result == nth(index, vs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 335,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires array_slice(a, 0, a.length, ?vs) \u0026*\u0026 0 \u003c= index \u0026*\u0026 index \u003c a.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 336,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures array_slice(a, 0, a.length, update(index, v, vs));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 343,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires array_slice(a, 0, a.length, ?vs) \u0026*\u0026 vs != nil;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 344,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures array_slice(a, 0, a.length, vs) \u0026*\u0026 mem(result, vs) == true \u0026\u0026 forall_le(vs, result);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 355,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires array_slice(a, start, a.length, ?vs) \u0026*\u0026 vs != nil \u0026*\u0026 length(vs) != 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 356,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures array_slice(a, start, a.length, vs) \u0026*\u0026 start \u003c= result \u0026*\u0026 result \u003c a.length \u0026*\u0026 forall_le(vs, nth(result - start, vs)) == true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 383,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires array_slice(a, start, a.length, ?vs) \u0026*\u0026 start \u003c a.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 384,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures array_slice(a, start, a.length, insert_sorted(tail(vs), head(vs)));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 404,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires array_slice(a, start, a.length, ?vs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 405,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures array_slice(a, start, a.length, sort(vs));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 417,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires array_slice(a, 0, a.length, ?vs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 418,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures array_slice(a, 0, a.length, ?vs2) \u0026*\u0026 is_sorted(vs2) == true \u0026*\u0026 is_perm(vs2, vs) == true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package echo;\n\nimport javacard.framework.*;\n\n/**\n *\n * @author Jeroen Bastijns\n */\npublic class Echo extends Applet {\n    \n    //@ predicate valid() = true;\n    \n    //codes of CLA byte in the command APDU's\n    private static final byte Echo_CLA = (byte) 0xB0;\n    private static final byte Echo_INS = (byte) 0x01;\n    \n    \n    public static void install(byte[] bArray, short bOffset, byte bLength) \n    //@ requires system();\n    //@ ensures true;\n    {\n        Echo echo = new Echo();\n        //@ close echo.valid();\n        echo.register();\n    }\n    \n    public void process(APDU apdu) \n    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, ?buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _);\n    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _);\n    {\n        //retrieve the APDU buffer\n        byte[] buffer = apdu.getBuffer();\n        \n        if(selectingApplet())\n            return;\n        \n        if(buffer[ISO7816.OFFSET_CLA] != Echo_CLA)\n            ISOException.throwIt(ISO7816.SW_CLA_NOT_SUPPORTED);\n        if(buffer[ISO7816.OFFSET_INS] != Echo_INS)\n            ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);\n        else\n            echo(apdu);\n    }\n    \n    private void echo(APDU apdu)\n    //@ requires APDU(apdu, ?buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _);\n    //@ ensures APDU(apdu, buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _);\n    {\n        byte[] buffer = apdu.getBuffer();\n        \n        apdu.setOutgoing();\n        \n        apdu.setOutgoingLength(buffer[ISO7816.OFFSET_LC]);\n        \n        apdu.sendBytes((short)buffer[ISO7816.OFFSET_CDATA], (short)(buffer[ISO7816.OFFSET_CDATA] + buffer[ISO7816.OFFSET_LC]));\n    }\n    \n}\n",
        "name": "Echo.java",
        "path": "examples/java/Java Card/Echo.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/Echo.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 18,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires system();"
        },
        {
          "limitHit": false,
          "lineNumber": 19,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, ?buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _);"
        },
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _);"
        },
        {
          "limitHit": false,
          "lineNumber": 45,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires APDU(apdu, ?buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _);"
        },
        {
          "limitHit": false,
          "lineNumber": 46,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures APDU(apdu, buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "//@ predicate charsInString(String s, list\u003cchar\u003e cs) = cs == charsOfString(s);\r\n\r\npublic class StringLiterals\r\n{\r\n  public static void main(String[] args)\r\n    //@ requires true;\r\n    //@ ensures true;\r\n  {\r\n    String foo = \"Foo\";\r\n    String bar = \"Bar\";\r\n    \r\n    method(foo);\r\n    method(bar);\r\n    \r\n    methodFoo(foo);\r\n    int i = 0;\r\n    //@ assert i == 0;\r\n    i = methodBar(foo);\r\n    //@ assert i == -1;\r\n    i = methodBar(bar);\r\n    //@ assert i == 1;\r\n  }\r\n  \r\n  static public void method(String s)\r\n    //@ requires true;\r\n    //@ ensures  charsInString(s, charsOfString(s));\r\n  {\r\n    //@ close charsInString(s, charsOfString(s));\r\n  }\r\n  \r\n  static public void methodFoo(String s)\r\n    //@ requires charsOfString(s) == \"Foo\";\r\n    //@ ensures  true;\r\n  {\r\n  }\r\n  \r\n  static int methodBar(String s)\r\n    //@ requires s != null;\r\n    //@ ensures  result == (charsOfString(s) == \"Bar\" ? 1 : -1);\r\n  {\r\n    if (s.equals(\"Bar\"))\r\n      return 1;\r\n    else\r\n      return -1;\r\n  }\r\n}\r\n ",
        "name": "StringLiterals.java",
        "path": "examples/java/StringLiterals.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/StringLiterals.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 24,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires charsOfString(s) == \"Foo\";\r"
        },
        {
          "limitHit": false,
          "lineNumber": 37,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires s != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 25,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  charsInString(s, charsOfString(s));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 32,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  result == (charsOfString(s) == \"Bar\" ? 1 : -1);\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Program {\r\n    static short abs(short x)\r\n        //@ requires x != -32768;\r\n        //@ ensures 0 \u003c= result \u0026*\u0026 result == x || result == -x;\r\n    {\r\n        if (x \u003c 0) {\r\n            x = (short)-x;\r\n            return x;\r\n        } else {\r\n            return x;\r\n        }\r\n    }\r\n}\r\n",
        "name": "abs_static.java",
        "path": "javacard_tutorial/abs_static.java",
        "url": "/github.com/verifast/verifast/-/blob/javacard_tutorial/abs_static.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 2,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires x != -32768;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures 0 \u003c= result \u0026*\u0026 result == x || result == -x;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import javacard.framework.*;\r\n\r\nclass Program {\r\n    static short abs(short x)\r\n        //@ requires true;\r\n        //@ ensures 0 \u003c= result \u0026*\u0026 result == x || result == -x;\r\n    {\r\n        if (x == -32768)\r\n            ISOException.throwIt(ISO7816.SW_UNKNOWN);\r\n        if (x \u003c 0) {\r\n            x = (short)-x;\r\n            return x;\r\n        } else {\r\n            return x;\r\n        }\r\n    }\r\n}\r\n",
        "name": "abs_except.java",
        "path": "javacard_tutorial/abs_except.java",
        "url": "/github.com/verifast/verifast/-/blob/javacard_tutorial/abs_except.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures 0 \u003c= result \u0026*\u0026 result == x || result == -x;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "interface Set {\n    //@ predicate valid(list\u003cClass\u003e level);\n    /*@\n    lemma void getClass_le_level();\n        requires [_]valid(?level);\n        ensures level_le({this.getClass()}, level) == true;\n    @*/\n    boolean contains(int x);\n        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\n        //@ ensures true;\n        //@ terminates;\n    boolean intersects(Set other);\n        //@ requires [_]valid(?level) \u0026*\u0026 [_]Set(other, ?otherLevel) \u0026*\u0026 call_perm(currentThread, append(level, otherLevel));\n        //@ ensures true;\n        //@ terminates;\n}\n\n/*@\npredicate Set(Set set, list\u003cClass\u003e level;) = set.valid(?level0) \u0026*\u0026 level_le(level0, level) == true;\n@*/\n\nclass SetHelper {\n    static boolean contains(Set set, int x)\n        //@ requires [_]Set(set, ?level) \u0026*\u0026 [2]call_perm(currentThread, level);\n        //@ ensures true;\n        //@ terminates;\n    {\n        //@ open [_]Set(set, level);\n        //@ assert [_]set.valid(?level0);\n        //@ call_perm_weaken(2, level0);\n        //@ set.getClass_le_level();\n        //@ consume_call_perm_for(set.getClass());\n        return set.contains(x);\n    }\n\n    static boolean intersects(Set set, Set other)\n        //@ requires [_]Set(set, ?level) \u0026*\u0026 [_]Set(other, ?otherLevel) \u0026*\u0026 [2]call_perm(currentThread, append(level, otherLevel));\n        //@ ensures true;\n        //@ terminates;\n    {\n        //@ open [_]Set(set, level);\n        //@ assert [_]set.valid(?level0);\n        //@ level_append_mono_l(level0, level, otherLevel);\n        //@ call_perm_weaken(2, append(level0, otherLevel));\n        //@ set.getClass_le_level();\n        //@ level_le_append_l(level0, otherLevel);\n        //@ level_le_trans({set.getClass()}, level0, append(level0, otherLevel));\n        //@ consume_call_perm_for(set.getClass());\n        return set.intersects(other);\n    }\n}\n\nfinal class Empty implements Set {\n    //@ predicate valid(list\u003cClass\u003e level) = level == {Empty.class};\n    /*@\n    lemma void getClass_le_level()\n        requires [_]valid(?level);\n        ensures level_le({this.getClass()}, level) == true;\n    {\n        open [_]valid(_);\n    }\n    @*/\n    Empty()\n        //@ requires true;\n        //@ ensures valid({Empty.class});\n        //@ terminates;\n    {\n        //@ close valid({Empty.class});\n    }\n    public boolean contains(int x)\n        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\n        //@ ensures true;\n        //@ terminates;\n    {\n        return false;\n    }\n    public boolean intersects(Set other)\n        //@ requires [_]valid(?level) \u0026*\u0026 [_]Set(other, ?otherLevel) \u0026*\u0026 call_perm(currentThread, append(level, otherLevel));\n        //@ ensures true;\n        //@ terminates;\n    {\n        return false;\n    }\n    public static Set create()\n        //@ requires true;\n        //@ ensures [_]Set(result, {Empty.class});\n        //@ terminates;\n    {\n        return new Empty();\n    }\n}\n\nfinal class Insert implements Set {\n    int elem;\n    Set set;\n    //@ list\u003cClass\u003e setLevel;\n    //@ predicate valid(list\u003cClass\u003e level) = elem |-\u003e _ \u0026*\u0026 set |-\u003e ?set \u0026*\u0026 setLevel |-\u003e ?setLevel \u0026*\u0026 [_]Set(set, setLevel) \u0026*\u0026 level == cons(Insert.class, setLevel);\n    /*@\n    lemma void getClass_le_level()\n        requires [_]valid(?level);\n        ensures level_le({this.getClass()}, level) == true;\n    {\n        open [_]valid(_);\n    }\n    @*/\n    public Insert(int elem, Set set)\n        //@ requires [_]Set(set, ?setLevel);\n        //@ ensures valid(cons(Insert.class, setLevel));\n        //@ terminates;\n    {\n        this.elem = elem;\n        this.set = set;\n        //@ this.setLevel = setLevel;\n    }\n    public boolean contains(int x)\n        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\n        //@ ensures true;\n        //@ terminates;\n    {\n        //@ open [_]valid(_);\n        //@ call_perm_weaken_and_dup(2);\n        return x == elem || SetHelper.contains(set, x);\n    }\n    public boolean intersects(Set other)\n        //@ requires [_]valid(?level) \u0026*\u0026 [_]Set(other, ?otherLevel) \u0026*\u0026 call_perm(currentThread, append(level, otherLevel));\n        //@ ensures true;\n        //@ terminates;\n    {\n        //@ open [_]valid(_);\n        Set set = this.set;\n        //@ assert [_]Set(set, ?setLevel);\n        //@ call_perm_weaken_and_dup(4);\n        //@ level_le_append_r(setLevel, otherLevel);\n        //@ call_perm_weaken(2, otherLevel);\n        return SetHelper.contains(other, elem) || SetHelper.intersects(set, other);\n    }\n    public static Set create(int elem, Set set)\n        //@ requires [_]Set(set, ?setLevel) \u0026*\u0026 call_perm(currentThread, cons(Insert.class, setLevel));\n        //@ ensures [_]Set(result, cons(Insert.class, setLevel));\n        //@ terminates;\n    {\n        return new Insert(elem, set);\n    }\n}\n\nclass Util {\n    public static boolean intersects(Set s1, Set s2)\n        //@ requires [_]Set(s1, ?s1Level) \u0026*\u0026 [_]Set(s2, ?s2Level) \u0026*\u0026 call_perm(currentThread, cons(Util.class, append(s1Level, s2Level)));\n        //@ ensures true;\n        //@ terminates;\n    {\n        //@ call_perm_weaken_and_dup(2);\n        return SetHelper.intersects(s1, s2);\n    }\n}\n\nclass Main {\n    public static void main()\n        //@ requires true;\n        //@ ensures true;\n        //@ terminates;\n    {\n        //@ produce_call_below_perm_();\n        //@ call_below_perm__elim(2, {Util.class, Insert.class, Empty.class, Insert.class, Empty.class});\n        Set s1 = Empty.create();\n        //@ call_perm_weaken(1, {Insert.class, Empty.class});\n        Set s2 = Insert.create(42, s1);\n        Util.intersects(s2, s2);\n    }\n}",
        "name": "Set.java",
        "path": "examples/java/termination/Set.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/termination/Set.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);"
        },
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?level) \u0026*\u0026 [_]Set(other, ?otherLevel) \u0026*\u0026 call_perm(currentThread, append(level, otherLevel));"
        },
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 23,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]Set(set, ?level) \u0026*\u0026 [2]call_perm(currentThread, level);"
        },
        {
          "limitHit": false,
          "lineNumber": 24,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 36,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]Set(set, ?level) \u0026*\u0026 [_]Set(other, ?otherLevel) \u0026*\u0026 [2]call_perm(currentThread, append(level, otherLevel));"
        },
        {
          "limitHit": false,
          "lineNumber": 37,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 63,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 64,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid({Empty.class});"
        },
        {
          "limitHit": false,
          "lineNumber": 70,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);"
        },
        {
          "limitHit": false,
          "lineNumber": 71,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 77,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?level) \u0026*\u0026 [_]Set(other, ?otherLevel) \u0026*\u0026 call_perm(currentThread, append(level, otherLevel));"
        },
        {
          "limitHit": false,
          "lineNumber": 78,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 84,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 85,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [_]Set(result, {Empty.class});"
        },
        {
          "limitHit": false,
          "lineNumber": 106,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]Set(set, ?setLevel);"
        },
        {
          "limitHit": false,
          "lineNumber": 107,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(cons(Insert.class, setLevel));"
        },
        {
          "limitHit": false,
          "lineNumber": 115,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);"
        },
        {
          "limitHit": false,
          "lineNumber": 116,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 124,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?level) \u0026*\u0026 [_]Set(other, ?otherLevel) \u0026*\u0026 call_perm(currentThread, append(level, otherLevel));"
        },
        {
          "limitHit": false,
          "lineNumber": 125,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 137,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]Set(set, ?setLevel) \u0026*\u0026 call_perm(currentThread, cons(Insert.class, setLevel));"
        },
        {
          "limitHit": false,
          "lineNumber": 138,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [_]Set(result, cons(Insert.class, setLevel));"
        },
        {
          "limitHit": false,
          "lineNumber": 147,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]Set(s1, ?s1Level) \u0026*\u0026 [_]Set(s2, ?s2Level) \u0026*\u0026 call_perm(currentThread, cons(Util.class, append(s1Level, s2Level)));"
        },
        {
          "limitHit": false,
          "lineNumber": 148,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 158,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 159,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "// Work done in collaboration with Sybren Roede and Ruurd Kuiper\r\n\r\nimport java.util.concurrent.*;\r\nimport verifast.*;\r\n\r\n/*@\r\n\r\nfixpoint boolean non_null(Object o) { return o != null; }\r\n\r\npredicate_ctor client_inv(ArrayBlockingQueue queue)() =\r\n    queue.state(?items, ?qms) \u0026*\u0026 forall(items, non_null) == true \u0026*\u0026\r\n    [1/2]Program_sendMaxCount(?smc) \u0026*\u0026 0 \u003c smc \u0026*\u0026\r\n    [1/2]Program_receiveMaxCount(?rmc) \u0026*\u0026 0 \u003c rmc \u0026*\u0026\r\n    [_]Program_producers(?s) \u0026*\u0026\r\n    [_]Program_producersCount(?sc) \u0026*\u0026\r\n    [1/3]array_slice_deep(s, 0, sc, producerWorkerInv, unit, _, ?lstSc)  \u0026*\u0026\r\n    [_]Program_consumers(?r) \u0026*\u0026\r\n    [_]Program_consumersCount(?rc) \u0026*\u0026\r\n    [1/3]array_slice_deep(r, 0, rc, consumerWorkerInv, unit, _, ?lstRc) \u0026*\u0026\r\n    length(items) == sum(lstSc) - sum(lstRc) \u0026*\u0026\r\n    sum(lstRc) \u003c= sum(lstSc);\r\n\r\npredicate producerWorkerInv(unit u, ProducerThread sw; int producerCount) =\r\n    [3/2]sw.producerSendCount |-\u003e producerCount;\r\n\r\npredicate consumerWorkerInv(unit u, ConsumerThread rw; int consumerCount) =\r\n    [3/2]rw.consumerReceiveCount |-\u003e consumerCount;\r\n\r\nfixpoint int sum(list\u003cint\u003e vs) {\r\n    switch(vs) {\r\n      case nil: return 0;\r\n      case cons(h, t): return h + sum(t);\r\n    }\r\n}\r\n\r\nlemma_auto void sum_all_eq(list\u003cint\u003e vs)\r\n    requires all_eq(vs, 0) == true;\r\n    ensures sum(vs) == 0;\r\n{\r\n    switch(vs) {\r\n        case nil :\r\n        case cons (x0, xs0): sum_all_eq(xs0);\r\n    }\r\n}\r\n\r\nlemma void sum_take_cons_drop(int k, list\u003cint\u003e xs, int x)\r\n    requires 0 \u003c= k \u0026*\u0026 k \u003c length(xs);\r\n    ensures sum(xs) == sum(append(take(k, xs), cons(x, drop(k + 1, xs)))) - x + head(take(1, drop(k, xs)));\r\n{\r\n    switch (xs) {\r\n        case nil:\r\n        case cons(x0, xs0):\r\n            if (k == 0) {\r\n            } else {\r\n                sum_take_cons_drop(k - 1, xs0, x);\r\n            }\r\n    }\r\n}\r\n\r\npredicate my_sep_pred() = true;\r\n\r\npredicate_ctor my_unsep_pred(ArrayBlockingQueue queue)(list\u003cObject\u003e items, int qms) =\r\n    forall(items, non_null) == true \u0026*\u0026\r\n    [1/2]Program_sendMaxCount(?smc) \u0026*\u0026  0 \u003c smc \u0026*\u0026\r\n    [1/2]Program_receiveMaxCount(?rmc) \u0026*\u0026 0 \u003c rmc \u0026*\u0026\r\n    [_]Program_producers(?s) \u0026*\u0026\r\n    [_]Program_producersCount(?sc) \u0026*\u0026\r\n    [1/3]array_slice_deep(s, 0, sc, producerWorkerInv, unit, _, ?lstSc)  \u0026*\u0026\r\n    [_]Program_consumers(?r) \u0026*\u0026\r\n    [_]Program_consumersCount(?rc) \u0026*\u0026\r\n    [1/3]array_slice_deep(r, 0, rc, consumerWorkerInv, unit, _, ?lstRc) \u0026*\u0026\r\n    length(items) == sum(lstSc) - sum(lstRc) \u0026*\u0026\r\n    sum(lstRc) \u003c= sum(lstSc);\r\n\r\nlemma void my_sep()\r\n    requires exists\u003cArrayBlockingQueue\u003e(?queue) \u0026*\u0026 my_sep_pred() \u0026*\u0026 client_inv(queue)();\r\n    ensures queue.state(?items, ?qms) \u0026*\u0026 my_unsep_pred(queue)(items, qms);\r\n{\r\n    open client_inv(queue)();\r\n    assert queue.state(?items, ?qms);\r\n    close my_unsep_pred(queue)(items, qms);\r\n}\r\n\r\nlemma void my_unsep()\r\n    requires exists\u003cArrayBlockingQueue\u003e(?queue) \u0026*\u0026 my_unsep_pred(queue)(?items, ?qms) \u0026*\u0026 queue.state(items, qms);\r\n    ensures my_sep_pred() \u0026*\u0026 client_inv(queue)();\r\n{\r\n    open my_unsep_pred(queue)(_, _);\r\n    close client_inv(queue)();\r\n    close my_sep_pred();\r\n}\r\n\r\npredicate foreach_i\u003ct\u003e(int i, list\u003ct\u003e xs, predicate(int, t) p) =\r\n    switch (xs) {\r\n        case nil: return true;\r\n        case cons(x0, xs0): return p(i, x0) \u0026*\u0026 foreach_i(i + 1, xs0, p);\r\n    };\r\n\r\nlemma void foreach_i_append\u003ct\u003e(int i, list\u003ct\u003e xs, list\u003ct\u003e ys)\r\n    requires foreach_i(i, xs, ?p) \u0026*\u0026 foreach_i(i + length(xs), ys, p);\r\n    ensures foreach_i(i, append(xs, ys), p);\r\n{\r\n    switch (xs) {\r\n        case nil:\r\n        case cons(x0, xs0):\r\n            open foreach_i(i, xs, p);\r\n            foreach_i_append(i + 1, xs0, ys);\r\n            close foreach_i(i, append(xs, ys), p);\r\n    }\r\n}\r\n\r\n@*/\r\n\r\n/*@\r\n\r\npredicate producerWorker(unit u, ProducerThread ProducerWorker; unit u2) =\r\n    [3]ProducerWorker.thread |-\u003e ?t \u0026*\u0026  [3]ProducerWorker.joinable |-\u003e ?j \u0026*\u0026\r\n    [3]t.Thread(j, true) \u0026*\u0026 [3]j.JoinableRunnable(ProducerWorker, true) \u0026*\u0026 ProducerWorker.getClass() == ProducerThread.class \u0026*\u0026\r\n    u2 == unit;\r\n\r\npredicate producerWorkerNull(unit u, ProducerThread ProducerWorker; unit u2) =\r\n    [3/2]ProducerWorker.thread |-\u003e _ \u0026*\u0026  [3/2]ProducerWorker.joinable |-\u003e _ \u0026*\u0026\r\n    [3/2]ProducerWorker.myIndex |-\u003e _ \u0026*\u0026\r\n    ProducerWorker.getClass() == ProducerThread.class \u0026*\u0026 [3/4]ProducerWorker.producerSendCount |-\u003e 0 \u0026*\u0026\r\n    u2 == unit;\r\n\r\npredicate producerWorkerIndex(int i, ProducerThread t) =\r\n    [_]t.myIndex |-\u003e i;\r\n\r\n@*/\r\n\r\nclass ProducerThread implements Runnable {\r\n    \r\n    //@ int producerSendCount;\r\n    //@ int myIndex;\r\n    Thread thread;\r\n    JoinableRunnable joinable;\r\n    \r\n    /*@\r\n    \r\n    predicate pre()  =\r\n        [_]Program_queue(?queue) \u0026*\u0026 [_]queue.ArrayBlockingQueue() \u0026*\u0026 [_]atomic_space(client_inv(queue)) \u0026*\u0026\r\n        [_]Program_sendMaxCount(?smc) \u0026*\u0026 0 \u003c smc \u0026*\u0026\r\n        [_]Program_producers(?s) \u0026*\u0026 [_]this.myIndex |-\u003e ?myIndex \u0026*\u0026\r\n        [_]Program_producersCount(?sc) \u0026*\u0026 myIndex \u003c sc  \u0026*\u0026\r\n        [1/3]array_slice_deep(s, myIndex, myIndex + 1, producerWorkerInv, unit, cons(this, nil), cons(0, nil));\r\n    \r\n    predicate post() =\r\n        [_]Program_queue(?queue) \u0026*\u0026 [_]queue.ArrayBlockingQueue() \u0026*\u0026 [_]atomic_space(client_inv(queue)) \u0026*\u0026\r\n        [_]Program_sendMaxCount(?smc) \u0026*\u0026\r\n        [_]Program_producers(?s) \u0026*\u0026 [_]this.myIndex |-\u003e ?myIndex \u0026*\u0026\r\n        [_]Program_producersCount(?sc) \u0026*\u0026 myIndex \u003c sc  \u0026*\u0026\r\n        [1/3]array_slice_deep(s, myIndex, myIndex + 1, producerWorkerInv, unit, cons(this, nil), cons(smc, nil));\r\n    \r\n    @*/\r\n    \r\n    public void run()\r\n        //@ requires pre();\r\n        //@ ensures post();\r\n    {\r\n        String m = \"Hello\";\r\n        int i;\r\n        for(i = 0; i \u003c Program.sendMaxCount; i++)\r\n            /*@\r\n            invariant\r\n                [_]Program_queue(?queue) \u0026*\u0026 [_]queue.ArrayBlockingQueue() \u0026*\u0026 [_]atomic_space(client_inv(queue)) \u0026*\u0026\r\n                [_]Program_sendMaxCount(?smc) \u0026*\u0026 i \u003c= smc \u0026*\u0026\r\n                [_]Program_producers(?s) \u0026*\u0026 [_]this.myIndex |-\u003e ?myIndex \u0026*\u0026\r\n                [_]Program_producersCount(?sc) \u0026*\u0026 myIndex \u003c sc \u0026*\u0026\r\n                [1/3]array_slice_deep(s, myIndex, myIndex + 1, producerWorkerInv, unit, cons(this, nil), cons(i, nil));\r\n            @*/\r\n        {\r\n            /*@\r\n            predicate P() =\r\n                [_]Program_sendMaxCount(smc) \u0026*\u0026\r\n                [_]Program_producers(s) \u0026*\u0026 [_]this.myIndex |-\u003e myIndex \u0026*\u0026\r\n                [_]Program_producersCount(sc) \u0026*\u0026 myIndex \u003c sc \u0026*\u0026\r\n                [1/3]array_slice_deep(s, myIndex, myIndex + 1, producerWorkerInv, unit, cons(this, nil), cons(i, nil));\r\n            predicate Q() =\r\n                [_]Program_sendMaxCount(smc) \u0026*\u0026\r\n                [_]Program_producers(s) \u0026*\u0026 [_]this.myIndex |-\u003e myIndex \u0026*\u0026\r\n                [_]Program_producersCount(sc) \u0026*\u0026 myIndex \u003c sc \u0026*\u0026\r\n                [1/3]array_slice_deep(s, myIndex, myIndex + 1, producerWorkerInv, unit, cons(this, nil), cons(i + 1, nil));\r\n            \r\n            lemma void my_put()\r\n                requires i \u003c smc \u0026*\u0026 P() \u0026*\u0026 my_unsep_pred(queue)(?items, ?qms) \u0026*\u0026 length(items) \u003c qms;\r\n                ensures Q() \u0026*\u0026 my_unsep_pred(queue)(append(items, cons(m, nil)), qms);\r\n            {\r\n                open P();\r\n                open my_unsep_pred(queue)(items, qms);\r\n                ProducerThread[] producers = Program.producers;\r\n                int producersCount = Program.producersCount;\r\n                int k = myIndex;\r\n                assert [1/3]array_slice_deep(producers, 0, producersCount, producerWorkerInv, unit, _, ?oldProducerCounts);\r\n                array_slice_deep_split(Program.producers, 0, myIndex);\r\n                array_slice_deep_split_precise(1/3, Program.producers, myIndex, Program.producersCount, producerWorkerInv, unit, myIndex + 1);\r\n                array_slice_deep_open_precise(2/3, Program.producers, myIndex);\r\n                int myOldSendCount = producerSendCount;\r\n                producerSendCount++;\r\n                int myNewSendCount = producerSendCount;\r\n                array_slice_deep_close(Program.producers, myIndex, producerWorkerInv, unit);\r\n                array_slice_deep_join_precise(1/3, Program.producers, myIndex, myIndex + 1, producerWorkerInv, unit, Program.producersCount);\r\n                array_slice_deep_join_precise(1/3, Program.producers, 0, myIndex, producerWorkerInv, unit, Program.producersCount);\r\n                \r\n                forall_append(items, cons(m, nil), non_null);\r\n                length_append(items, cons(m, nil));\r\n                assert [1/3]array_slice_deep(producers, 0, producersCount, producerWorkerInv, unit, _, ?newProducerCounts);\r\n                assert newProducerCounts == append(take(k, oldProducerCounts), cons(myNewSendCount, drop(1, drop(k, oldProducerCounts))));\r\n                assert length(oldProducerCounts) == producersCount;\r\n                assert 0 \u003c= 1 \u0026*\u0026 0 \u003c= k \u0026*\u0026 1 + k \u003c= length(oldProducerCounts);\r\n                drop_drop(1, k, oldProducerCounts);\r\n                assert newProducerCounts == append(take(k, oldProducerCounts), cons(myNewSendCount, drop(k + 1, oldProducerCounts)));\r\n                sum_take_cons_drop(k, oldProducerCounts, myNewSendCount);\r\n                assert sum(newProducerCounts) == sum(oldProducerCounts) + myNewSendCount - myOldSendCount;\r\n                close my_unsep_pred(queue)(append(items, cons(m, nil)), qms);\r\n                close Q();\r\n            }\r\n            @*/\r\n            //@ produce_lemma_function_pointer_chunk(my_sep) : ArrayBlockingQueue_sep(client_inv(queue), queue, my_sep_pred, my_unsep_pred(queue))() { close exists(queue); call(); };\r\n            //@ produce_lemma_function_pointer_chunk(my_unsep) : ArrayBlockingQueue_unsep(client_inv(queue), queue, my_sep_pred, my_unsep_pred(queue))() { close exists(queue); call(); };\r\n            //@ close my_sep_pred();\r\n            //@ produce_lemma_function_pointer_chunk(my_put) : ArrayBlockingQueue_put(client_inv(queue), queue, my_unsep_pred(queue), m, P, Q)() { call(); };\r\n            //@ close P();\r\n            Program.queue.put(m);\r\n            //@ open Q();\r\n        }\r\n        //@ assert i == Program.sendMaxCount;\r\n        //@ close post();\r\n    }\r\n}\r\n\r\n/*@\r\n\r\npredicate consumerWorker(unit u, ConsumerThread ConsumerWorker; unit u2) =\r\n    [3]ConsumerWorker.thread |-\u003e ?t \u0026*\u0026 [3]ConsumerWorker.joinable |-\u003e ?j \u0026*\u0026\r\n    [3]t.Thread(j, true) \u0026*\u0026 [3]j.JoinableRunnable(ConsumerWorker, true) \u0026*\u0026 ConsumerWorker.getClass() == ConsumerThread.class \u0026*\u0026\r\n    u2 == unit;\r\n\r\npredicate consumerWorkerNull(unit u, ConsumerThread ConsumerWorker; unit u2) =\r\n    [3/2]ConsumerWorker.thread |-\u003e _ \u0026*\u0026  [3/2]ConsumerWorker.joinable |-\u003e _ \u0026*\u0026\r\n    [3/2]ConsumerWorker.myIndex |-\u003e _ \u0026*\u0026\r\n    ConsumerWorker.getClass() == ConsumerThread.class \u0026*\u0026 [3/4]ConsumerWorker.consumerReceiveCount |-\u003e 0 \u0026*\u0026\r\n    u2 == unit;\r\n\r\npredicate consumerWorkerIndex(int i, ConsumerThread t) =\r\n    [_]t.myIndex |-\u003e i;\r\n\r\n@*/\r\n\r\nclass ConsumerThread implements Runnable {\r\n    //@ int consumerReceiveCount;\r\n    //@ int myIndex;\r\n    Thread thread;\r\n    JoinableRunnable joinable;\r\n    \r\n    /*@\r\n    \r\n    predicate pre() =\r\n        [_]Program_queue(?queue) \u0026*\u0026 [_]queue.ArrayBlockingQueue() \u0026*\u0026 [_]atomic_space(client_inv(queue)) \u0026*\u0026\r\n        [_]Program_receiveMaxCount(?rmc) \u0026*\u0026 0 \u003c rmc \u0026*\u0026\r\n        [_]Program_consumers(?s) \u0026*\u0026 [_]this.myIndex |-\u003e ?myIndex \u0026*\u0026\r\n        [_]Program_consumersCount(?rc) \u0026*\u0026 myIndex \u003c rc  \u0026*\u0026\r\n        [1/3]array_slice_deep(s, myIndex, myIndex + 1, consumerWorkerInv, unit, cons(this, nil), cons(0, nil));\r\n    \r\n    predicate post() =\r\n        [_]Program_queue(?queue) \u0026*\u0026 [_]queue.ArrayBlockingQueue() \u0026*\u0026 [_]atomic_space(client_inv(queue)) \u0026*\u0026\r\n        [_]Program_receiveMaxCount(?rmc) \u0026*\u0026\r\n        [_]Program_consumers(?s) \u0026*\u0026 [_]this.myIndex |-\u003e ?myIndex \u0026*\u0026\r\n        [_]Program_consumersCount(?rc) \u0026*\u0026 myIndex \u003c rc  \u0026*\u0026\r\n        [1/3]array_slice_deep(s, myIndex, myIndex + 1, consumerWorkerInv, unit, cons(this, nil), cons(rmc, nil));\r\n    \r\n    @*/\r\n    \r\n    public void run()\r\n        //@ requires pre();\r\n        //@ ensures post();\r\n    {\r\n        int i;\r\n        for (i=0; i \u003c Program.receiveMaxCount; i++)\r\n            /*@\r\n            invariant\r\n                [_]Program_queue(?queue) \u0026*\u0026 [_]queue.ArrayBlockingQueue() \u0026*\u0026 [_]atomic_space(client_inv(queue)) \u0026*\u0026\r\n                [_]Program_receiveMaxCount(?rmc) \u0026*\u0026 i \u003c= rmc \u0026*\u0026\r\n                [_]Program_consumers(?r) \u0026*\u0026 [_]this.myIndex |-\u003e ?myIndex \u0026*\u0026\r\n                [_]Program_consumersCount(?rc) \u0026*\u0026 myIndex \u003c rc \u0026*\u0026\r\n                [1/3]array_slice_deep(r, myIndex, myIndex + 1, consumerWorkerInv, unit, cons(this, nil), cons(i, nil));\r\n            @*/\r\n        {\r\n            /*@\r\n            predicate P() =  \r\n                [_]Program_receiveMaxCount(rmc) \u0026*\u0026\r\n                [_]Program_consumers(r) \u0026*\u0026 [_]this.myIndex |-\u003e myIndex \u0026*\u0026\r\n                [_]Program_consumersCount(rc) \u0026*\u0026 myIndex \u003c rc \u0026*\u0026\r\n                [1/3]array_slice_deep(r, myIndex, myIndex + 1, consumerWorkerInv, unit, cons(this, nil), cons(i, nil));\r\n            predicate Q(Object result) = \r\n                [_]Program_receiveMaxCount(rmc) \u0026*\u0026 \r\n                [_]Program_consumers(r) \u0026*\u0026 [_]this.myIndex |-\u003e myIndex \u0026*\u0026 \r\n                [_]Program_consumersCount(rc) \u0026*\u0026 myIndex \u003c rc \u0026*\u0026\r\n                [1/3]array_slice_deep(r, myIndex, myIndex + 1, consumerWorkerInv, unit, cons(this, nil), cons(i + 1, nil));\r\n            \r\n            lemma void my_ArrayBlockingQueue_take()\r\n                requires i \u003c rmc \u0026*\u0026 P() \u0026*\u0026 my_unsep_pred(queue)(?items, ?qms) \u0026*\u0026 items != nil;\r\n                ensures Q(head(items)) \u0026*\u0026 my_unsep_pred(queue)(tail(items), qms);\r\n            {\r\n                open P();\r\n                open my_unsep_pred(queue)(items, qms);\r\n                ConsumerThread[] consumers = Program.consumers;\r\n                int consumersCount = Program.consumersCount;\r\n                int k = myIndex;\r\n                assert [1/3]array_slice_deep(consumers, 0, consumersCount, consumerWorkerInv, unit, _, ?oldConsumerCounts);\r\n                array_slice_deep_split(Program.consumers, 0, myIndex);\r\n                array_slice_deep_split_precise(1/3, Program.consumers, myIndex, Program.consumersCount, consumerWorkerInv, unit, myIndex + 1);\r\n                array_slice_deep_open_precise(2/3, Program.consumers, myIndex);\r\n                int myOldReceiveCount = consumerReceiveCount;\r\n                switch (items) {\r\n                case nil:\r\n                case cons(head, tail):\r\n                    consumerReceiveCount++;\r\n                }\r\n                int myNewConsumerCount = consumerReceiveCount;\r\n                array_slice_deep_close(Program.consumers, myIndex, consumerWorkerInv, unit);\r\n                array_slice_deep_join_precise(1/3, Program.consumers, myIndex, myIndex + 1, consumerWorkerInv, unit, Program.consumersCount);\r\n                array_slice_deep_join_precise(1/3, Program.consumers, 0, myIndex, consumerWorkerInv, unit, Program.consumersCount);\r\n                \r\n                assert [1/3]array_slice_deep(consumers, 0, consumersCount, consumerWorkerInv, unit, _, ?newConsumerCounts);\r\n                assert newConsumerCounts == append(take(k, oldConsumerCounts), cons(myNewConsumerCount, drop(1, drop(k, oldConsumerCounts))));\r\n                assert length(oldConsumerCounts) == consumersCount;\r\n                assert 0 \u003c= 1 \u0026*\u0026 0 \u003c= k \u0026*\u0026 1 + k \u003c= length(oldConsumerCounts);\r\n                drop_drop(1, k, oldConsumerCounts);\r\n                assert newConsumerCounts == append(take(k, oldConsumerCounts), cons(myNewConsumerCount, drop(k + 1, oldConsumerCounts)));\r\n                sum_take_cons_drop(k, oldConsumerCounts, myNewConsumerCount);\r\n                assert sum(newConsumerCounts) == sum(oldConsumerCounts) + myNewConsumerCount - myOldReceiveCount;\r\n                \r\n                switch (items) {\r\n                case nil:\r\n                case cons(head, tail):\r\n                    close my_unsep_pred(queue)(tail, qms);\r\n                    close Q(head);\r\n                }\r\n            }\r\n            @*/\r\n            //@ produce_lemma_function_pointer_chunk(my_sep) : ArrayBlockingQueue_sep(client_inv(queue), queue, my_sep_pred, my_unsep_pred(queue))() { close exists(queue); call(); };\r\n            //@ produce_lemma_function_pointer_chunk(my_unsep) : ArrayBlockingQueue_unsep(client_inv(queue), queue, my_sep_pred, my_unsep_pred(queue))() { close exists(queue); call(); };\r\n            //@ close my_sep_pred();\r\n            //@ produce_lemma_function_pointer_chunk(my_ArrayBlockingQueue_take) : ArrayBlockingQueue_take(client_inv(queue), queue, my_unsep_pred(queue), P, Q)() { call(); };\r\n            //@ close P();\r\n            String m = (String)Program.queue.take();\r\n            //@ open Q(m);\r\n        }\r\n        //@ close post();\r\n    }\r\n}\r\n\r\nclass Program {\r\n    \r\n    //@ static int sendCount;\r\n    //@ static int receiveCount;\r\n    \r\n    public static int sendMaxCount;\r\n    public static int receiveMaxCount;\r\n    public static ArrayBlockingQueue queue;\r\n    public static int producersCount;\r\n    public static int consumersCount;\r\n    public static ProducerThread[] producers;\r\n    public static ConsumerThread[] consumers;\r\n    \r\n    public static void main(String[] args)\r\n        //@ requires class_init_token(Program.class);\r\n        //@ ensures true;\r\n    {\r\n        //@ init_class();\r\n        Program.producersCount = 1000;\r\n        Program.consumersCount = 1000;\r\n        Program.sendMaxCount = 2000;\r\n        Program.receiveMaxCount = 2000;\r\n        Program.work();\r\n        //@assert Program.sendCount == 2000000;\r\n        //@assert Program.receiveCount == 2000000;\r\n    }\r\n    \r\n    public static void work()\r\n        /*@\r\n        requires\r\n            Program_queue(_) \u0026*\u0026\r\n            Program_producers(_) \u0026*\u0026 Program_consumers(_) \u0026*\u0026\r\n            [_]Program_producersCount(?producersCount) \u0026*\u0026 [_]Program_consumersCount(?consumersCount) \u0026*\u0026\r\n            0 \u003c producersCount \u0026*\u0026 0 \u003c consumersCount \u0026*\u0026\r\n            Program_sendCount(?psc) \u0026*\u0026 Program_receiveCount(?prc) \u0026*\u0026 psc==0 \u0026*\u0026 prc==0 \u0026*\u0026\r\n            Program_sendMaxCount(?smc) \u0026*\u0026 0 \u003c smc  \u0026*\u0026 Program_receiveMaxCount(?rmc) \u0026*\u0026 0 \u003c rmc;\r\n        @*/\r\n        //@ ensures Program_sendCount(smc * producersCount) \u0026*\u0026 Program_receiveCount(rmc * consumersCount);\r\n     {\r\n        Program.producers = new ProducerThread[Program.producersCount];\r\n        //@ ProducerThread[] s = Program.producers;\r\n        //@ leak Program_producers(s);\r\n        //@ array_slice_deep_empty_close(s, 0, producerWorker, unit);\r\n        for (int i = 0; i \u003c Program.producersCount; i++)\r\n            /*@\r\n            invariant\r\n                0 \u003c= i \u0026*\u0026 i \u003c= producersCount \u0026*\u0026\r\n                [_]Program_producers(s) \u0026*\u0026 [_]Program_producersCount(producersCount) \u0026*\u0026\r\n                [1/3]Program_sendMaxCount(smc) \u0026*\u0026 0 \u003c smc \u0026*\u0026\r\n                array_slice(s, i, producersCount, ?elems) \u0026*\u0026 all_eq(elems, null) == true \u0026*\u0026\r\n                [1/3]array_slice_deep(s, 0, i, producerWorkerInv, unit, _, ?v) \u0026*\u0026 all_eq(v, 0) == true \u0026*\u0026\r\n                [2/3]array_slice_deep(s, 0, i, producerWorkerNull, unit, _, _);\r\n            @*/\r\n        {\r\n            Program.producers[i] = new ProducerThread();\r\n            //@ Program.producers[i].myIndex = i;\r\n            //@ array_slice_split(producers, i, i + 1);\r\n            //@ close [2/3]producerWorkerNull(unit, producers[i], unit);\r\n            //@ close [1/3]producerWorkerInv(unit, producers[i], _);\r\n            //@ array_slice_deep_close_precise(2/3, producers, i, producerWorkerNull, unit);\r\n            //@ array_slice_deep_close_precise(1/3, producers, i, producerWorkerInv, unit);\r\n            \r\n        }\r\n        \r\n        Program.consumers = new ConsumerThread[Program.consumersCount];\r\n        //@ ConsumerThread[] r = Program.consumers;\r\n        //@ leak Program_consumers(r);\r\n        //@ array_slice_deep_empty_close(r, 0, consumerWorker, unit);\r\n        for (int i = 0; i \u003c Program.consumersCount; i++)\r\n            /*@\r\n            invariant\r\n                0 \u003c= i \u0026*\u0026 i \u003c= consumersCount \u0026*\u0026\r\n                [_]Program_consumers(r) \u0026*\u0026 [_]Program_consumersCount(consumersCount) \u0026*\u0026\r\n                [1/3]Program_receiveMaxCount(rmc) \u0026*\u0026 0 \u003c rmc \u0026*\u0026\r\n                array_slice(r, i, consumersCount, ?elems) \u0026*\u0026 all_eq(elems, null) == true \u0026*\u0026\r\n                [1/3]array_slice_deep(r, 0, i, consumerWorkerInv, unit, _, ?v) \u0026*\u0026 all_eq(v, 0) == true \u0026*\u0026\r\n                [2/3]array_slice_deep(r, 0, i, consumerWorkerNull, unit, _, _);\r\n            @*/\r\n        {\r\n            consumers[i] = new ConsumerThread();\r\n            //@ Program.consumers[i].myIndex = i;\r\n            //@ array_slice_split(consumers, i, i + 1);\r\n            //@ close [2/3]consumerWorkerNull(unit, consumers[i], unit);\r\n            //@ close [1/3]consumerWorkerInv(unit, consumers[i], _);\r\n            //@ array_slice_deep_close_precise(2/3, consumers, i, consumerWorkerNull, unit);\r\n            //@ array_slice_deep_close_precise(1/3, consumers, i, consumerWorkerInv, unit);\r\n        }\r\n        Program.queue = new ArrayBlockingQueue(2);\r\n        \r\n        //@ close client_inv(Program.queue)();\r\n        //@ create_atomic_space(client_inv(Program.queue));\r\n        //@ close foreach_i(0, nil, producerWorkerIndex);\r\n        \r\n        for (int i = 0; i \u003c Program.producersCount; i++)\r\n            /*@\r\n            invariant\r\n                0 \u003c= i \u0026*\u0026 i \u003c= producersCount \u0026*\u0026\r\n                [_]Program_producersCount(producersCount) \u0026*\u0026 [_]Program_producers(s) \u0026*\u0026\r\n                [_]Program_queue(?queue) \u0026*\u0026 [_]queue.ArrayBlockingQueue() \u0026*\u0026 [_]atomic_space(client_inv(queue)) \u0026*\u0026 [_]Program_sendMaxCount(smc) \u0026*\u0026 0 \u003c smc \u0026*\u0026\r\n                [2/3]array_slice_deep(s, i, producersCount, producerWorkerNull, unit, _, _) \u0026*\u0026\r\n                [1/3]array_slice_deep(s, 0, i, producerWorker, unit, ?elements, _) \u0026*\u0026 foreach_i(0, elements, producerWorkerIndex);\r\n            @*/\r\n        {\r\n            //@ array_slice_deep_split(s, i, i + 1);\r\n            //@ array_slice_deep_open_precise(2/3, s, i);\r\n            ProducerThread producer = producers[i];\r\n            //@ close [1/3]producerWorkerInv(unit, producer, _);\r\n            //@ array_slice_deep_close_precise(1/3, s, i, producerWorkerInv, unit);\r\n            JoinableRunnable j = ThreadingHelper.createJoinableRunnable(producer);\r\n            //@ producer.myIndex = i;\r\n            //@ leak producer.myIndex |-\u003e i;\r\n            //@ close producer.pre();\r\n            //@ j.closeIt();\r\n            Thread t = new Thread(j);\r\n            t.start();\r\n            \r\n            producer.thread = t;\r\n            producer.joinable = j;\r\n            //@ close [1/3]producerWorker(unit, producer, unit);\r\n            //@ array_slice_deep_close_precise(1/3, producers, i, producerWorker, unit);\r\n            \r\n            //@ close foreach_i(i + 1, nil, producerWorkerIndex);\r\n            //@ close producerWorkerIndex(i, producer);\r\n            //@ close foreach_i(i, cons(producer, nil), producerWorkerIndex);\r\n            //@ foreach_i_append(0, elements, cons(producer, nil));\r\n        }\r\n        //@ close foreach_i(0, nil, consumerWorkerIndex);\r\n        for (int i = 0; i \u003c Program.consumersCount; i++)\r\n            /*@\r\n            invariant\r\n                0 \u003c= i \u0026*\u0026 i \u003c= consumersCount \u0026*\u0026\r\n                [_]Program_consumersCount(consumersCount) \u0026*\u0026 [_]Program_consumers(r) \u0026*\u0026\r\n                [_]Program_queue(?queue) \u0026*\u0026 [_]queue.ArrayBlockingQueue() \u0026*\u0026 [_]atomic_space(client_inv(queue)) \u0026*\u0026 [_]Program_receiveMaxCount(rmc) \u0026*\u0026 0 \u003c rmc \u0026*\u0026\r\n                [2/3]array_slice_deep(r, i, consumersCount, consumerWorkerNull, unit, _, _) \u0026*\u0026\r\n                [1/3]array_slice_deep(r, 0, i, consumerWorker, unit, ?elements, _) \u0026*\u0026 foreach_i(0, elements, consumerWorkerIndex);\r\n            @*/\r\n        {\r\n            //@ array_slice_deep_split(r, i, i + 1);\r\n            //@ array_slice_deep_open_precise(2/3, r, i);\r\n            ConsumerThread consumer = consumers[i];\r\n            //@ close [1/3]consumerWorkerInv(unit, consumer, _);\r\n            //@ array_slice_deep_close_precise(1/3, r, i, consumerWorkerInv, unit);\r\n            JoinableRunnable j = ThreadingHelper.createJoinableRunnable(consumer);\r\n            //@ consumer.myIndex = i;\r\n            //@ leak consumer.myIndex |-\u003e i;\r\n            //@ close consumer.pre();\r\n            //@ j.closeIt();\r\n            Thread t = new Thread(j);\r\n            t.start();\r\n            \r\n            consumer.thread = t;\r\n            consumer.joinable = j;\r\n            //@ close [1/3]consumerWorker(unit, consumer, unit);\r\n            //@ array_slice_deep_close_precise(1/3, consumers, i, consumerWorker, unit);\r\n            \r\n            //@ close foreach_i(i + 1, nil, consumerWorkerIndex);\r\n            //@ close consumerWorkerIndex(i, consumer);\r\n            //@ close foreach_i(i, cons(consumer, nil), consumerWorkerIndex);\r\n            //@ foreach_i_append(0, elements, cons(consumer, nil));\r\n        }\r\n        \r\n        int j;\r\n        for (j = 0; j \u003c Program.producersCount; j++)\r\n            /*@\r\n            invariant\r\n                0 \u003c= j \u0026*\u0026 j \u003c= producersCount \u0026*\u0026\r\n                [_]Program_producersCount(producersCount) \u0026*\u0026 [_]Program_producers(s) \u0026*\u0026\r\n                [_]Program_queue(?queue) \u0026*\u0026 [_]queue.ArrayBlockingQueue() \u0026*\u0026 [_]atomic_space(client_inv(queue)) \u0026*\u0026\r\n                Program_sendCount(j * smc) \u0026*\u0026 [_]Program_sendMaxCount(smc) \u0026*\u0026\r\n                [1/3]array_slice_deep(s, j, producersCount, producerWorker, unit, ?elements, _) \u0026*\u0026 foreach_i(j, elements, producerWorkerIndex);\r\n            @*/\r\n        {\r\n            ProducerThread sw = producers[j];\r\n            ThreadingHelper.join(sw.thread, sw.joinable);\r\n            //@ open sw.post();\r\n            //@ open foreach_i(j, elements, producerWorkerIndex);\r\n            //@ open producerWorkerIndex(j, sw);\r\n            //@ int jj = sw.myIndex;\r\n            //@ assert j == jj;\r\n            //@ array_slice_deep_open_precise(1/3, s, j);\r\n            //@ open producerWorkerInv(unit, sw, _);\r\n            //@ Program.sendCount += sw.producerSendCount;\r\n        }\r\n        //@ assert Program.sendCount == Program.sendMaxCount * j;\r\n        //@ assert j == producersCount;\r\n        //@ assert Program.sendCount == Program.sendMaxCount * producersCount;\r\n        for (j = 0; j \u003c Program.consumersCount; j++)\r\n            /*@\r\n            invariant\r\n                0 \u003c= j \u0026*\u0026 j \u003c= consumersCount \u0026*\u0026\r\n                [_]Program_consumersCount(consumersCount) \u0026*\u0026 [_]Program_consumers(r) \u0026*\u0026\r\n                [_]Program_queue(?queue) \u0026*\u0026 [_]queue.ArrayBlockingQueue() \u0026*\u0026 [_]atomic_space(client_inv(queue)) \u0026*\u0026\r\n                Program_receiveCount(j * rmc) \u0026*\u0026 [_]Program_receiveMaxCount(rmc) \u0026*\u0026\r\n                [1/3]array_slice_deep(r, j, consumersCount, consumerWorker, unit, ?elements, _) \u0026*\u0026 foreach_i(j, elements, consumerWorkerIndex);\r\n            @*/\r\n        {\r\n            ConsumerThread rw = consumers[j];\r\n            ThreadingHelper.join(rw.thread, rw.joinable);\r\n            //@ open rw.post();\r\n            //@ open foreach_i(j, elements, consumerWorkerIndex);\r\n            //@ open consumerWorkerIndex(j, rw);\r\n            //@ int jj = rw.myIndex;\r\n            //@ assert j == jj;\r\n            //@ array_slice_deep_open_precise(1/3, r, j);\r\n            //@ open consumerWorkerInv(unit, rw, _);\r\n            //@ Program.receiveCount += rw.consumerReceiveCount;\r\n        }\r\n        //@ assert Program.receiveCount == Program.receiveMaxCount * j;\r\n        //@ assert j == consumersCount;\r\n        //@ assert Program.receiveCount == Program.receiveMaxCount * consumersCount;\r\n    }\r\n    \r\n}\r\n",
        "name": "client.java",
        "path": "examples/java/prodcons/client.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/prodcons/client.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 157,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 158,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 274,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 275,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 367,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires class_init_token(Program.class);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 368,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 390,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Program_sendCount(smc * producersCount) \u0026*\u0026 Program_receiveCount(rmc * consumersCount);\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "// Work done in collaboration with Sybren Roede and Ruurd Kuiper\r\n\r\nimport channels.*;\r\nimport verifast.*;\r\n\r\n/*@\r\n\r\nfixpoint boolean non_null(Object o) { return o != null; }\r\n\r\npredicate_ctor client_inv(Channel c)() =\r\n    c.ChannelState(?items, ?qms) \u0026*\u0026 forall(items, non_null) == true \u0026*\u0026\r\n    [1/2]Program_sendMaxCount(?smc) \u0026*\u0026 0 \u003c smc \u0026*\u0026\r\n    [1/2]Program_receiveMaxCount(?rmc) \u0026*\u0026 0 \u003c rmc \u0026*\u0026\r\n    [_]Program_senders(?s) \u0026*\u0026\r\n    [_]Program_sendersCount(?sc) \u0026*\u0026\r\n    [1/3]array_slice_deep(s, 0, sc, senderWorkerInv, unit, _, ?lstSc)  \u0026*\u0026\r\n    [_]Program_receivers(?r) \u0026*\u0026\r\n    [_]Program_receiversCount(?rc) \u0026*\u0026\r\n    [1/3]array_slice_deep(r, 0, rc, receiverWorkerInv, unit, _, ?lstRc) \u0026*\u0026\r\n    length(items) == sum(lstSc) - sum(lstRc) \u0026*\u0026\r\n    sum(lstRc) \u003c= sum(lstSc);\r\n\r\npredicate senderWorkerInv(unit u, SenderThread sw; int senderCount) =\r\n    [3/2]sw.senderSendCount |-\u003e senderCount;\r\n\r\npredicate receiverWorkerInv(unit u, ReceiverThread rw; int receiverCount) =\r\n    [3/2]rw.receiverReceiveCount |-\u003e receiverCount;\r\n\r\nfixpoint int sum(list\u003cint\u003e vs) {\r\n    switch(vs) {\r\n      case nil: return 0;\r\n      case cons(h, t): return h + sum(t);\r\n    }\r\n}\r\n\r\nlemma_auto void sum_all_eq(list\u003cint\u003e vs)\r\n    requires all_eq(vs, 0) == true;\r\n    ensures sum(vs) == 0;\r\n{\r\n    switch(vs) {\r\n        case nil :\r\n        case cons (x0, xs0): sum_all_eq(xs0);\r\n    }\r\n}\r\n\r\nlemma void sum_take_cons_drop(int k, list\u003cint\u003e xs, int x)\r\n    requires 0 \u003c= k \u0026*\u0026 k \u003c length(xs);\r\n    ensures sum(xs) == sum(append(take(k, xs), cons(x, drop(k + 1, xs)))) - x + head(take(1, drop(k, xs)));\r\n{\r\n    switch (xs) {\r\n        case nil:\r\n        case cons(x0, xs0):\r\n            if (k == 0) {\r\n            } else {\r\n                sum_take_cons_drop(k - 1, xs0, x);\r\n            }\r\n    }\r\n}\r\n\r\npredicate my_sep_pred() = true;\r\n\r\npredicate_ctor my_unsep_pred(Channel c)(list\u003cObject\u003e items, int qms) =\r\n    forall(items, non_null) == true \u0026*\u0026\r\n    [1/2]Program_sendMaxCount(?smc) \u0026*\u0026  0 \u003c smc \u0026*\u0026\r\n    [1/2]Program_receiveMaxCount(?rmc) \u0026*\u0026 0 \u003c rmc \u0026*\u0026\r\n    [_]Program_senders(?s) \u0026*\u0026\r\n    [_]Program_sendersCount(?sc) \u0026*\u0026\r\n    [1/3]array_slice_deep(s, 0, sc, senderWorkerInv, unit, _, ?lstSc)  \u0026*\u0026\r\n    [_]Program_receivers(?r) \u0026*\u0026\r\n    [_]Program_receiversCount(?rc) \u0026*\u0026\r\n    [1/3]array_slice_deep(r, 0, rc, receiverWorkerInv, unit, _, ?lstRc) \u0026*\u0026\r\n    length(items) == sum(lstSc) - sum(lstRc) \u0026*\u0026\r\n    sum(lstRc) \u003c= sum(lstSc);\r\n\r\nlemma void my_sep()\r\n    requires exists\u003cChannel\u003e(?c) \u0026*\u0026 my_sep_pred() \u0026*\u0026 client_inv(c)();\r\n    ensures c.ChannelState(?items, ?qms) \u0026*\u0026 my_unsep_pred(c)(items, qms);\r\n{\r\n    open client_inv(c)();\r\n    assert c.ChannelState(?items, ?qms);\r\n    close my_unsep_pred(c)(items, qms);\r\n}\r\n\r\nlemma void my_unsep()\r\n    requires exists\u003cChannel\u003e(?c) \u0026*\u0026 my_unsep_pred(c)(?items, ?qms) \u0026*\u0026 c.ChannelState(items, qms);\r\n    ensures my_sep_pred() \u0026*\u0026 client_inv(c)();\r\n{\r\n    open my_unsep_pred(c)(_, _);\r\n    close client_inv(c)();\r\n    close my_sep_pred();\r\n}\r\n\r\npredicate foreach_i\u003ct\u003e(int i, list\u003ct\u003e xs, predicate(int, t) p) =\r\n    switch (xs) {\r\n        case nil: return true;\r\n        case cons(x0, xs0): return p(i, x0) \u0026*\u0026 foreach_i(i + 1, xs0, p);\r\n    };\r\n\r\nlemma void foreach_i_append\u003ct\u003e(int i, list\u003ct\u003e xs, list\u003ct\u003e ys)\r\n    requires foreach_i(i, xs, ?p) \u0026*\u0026 foreach_i(i + length(xs), ys, p);\r\n    ensures foreach_i(i, append(xs, ys), p);\r\n{\r\n    switch (xs) {\r\n        case nil:\r\n        case cons(x0, xs0):\r\n            open foreach_i(i, xs, p);\r\n            foreach_i_append(i + 1, xs0, ys);\r\n            close foreach_i(i, append(xs, ys), p);\r\n    }\r\n}\r\n\r\n@*/\r\n\r\n/*@\r\n\r\npredicate senderWorker(unit u, SenderThread SenderWorker; unit u2) =\r\n    [3]SenderWorker.thread |-\u003e ?t \u0026*\u0026  [3]SenderWorker.joinable |-\u003e ?j \u0026*\u0026\r\n    [3]t.Thread(j, true) \u0026*\u0026 [3]j.JoinableRunnable(SenderWorker, true) \u0026*\u0026 SenderWorker.getClass() == SenderThread.class \u0026*\u0026\r\n    u2 == unit;\r\n\r\npredicate senderWorkerNull(unit u, SenderThread SenderWorker; unit u2) =\r\n    [3/2]SenderWorker.thread |-\u003e _ \u0026*\u0026  [3/2]SenderWorker.joinable |-\u003e _ \u0026*\u0026\r\n    [3/2]SenderWorker.myIndex |-\u003e _ \u0026*\u0026\r\n    SenderWorker.getClass() == SenderThread.class \u0026*\u0026 [3/4]SenderWorker.senderSendCount |-\u003e 0 \u0026*\u0026\r\n    u2 == unit;\r\n\r\npredicate senderWorkerIndex(int i, SenderThread t) =\r\n    [_]t.myIndex |-\u003e i;\r\n\r\n@*/\r\n\r\npublic class SenderThread implements Runnable {\r\n    \r\n    //@ int senderSendCount;\r\n    //@ int myIndex;\r\n    Thread thread;\r\n    JoinableRunnable joinable;\r\n    \r\n    /*@\r\n    \r\n    predicate pre()  =\r\n        [_]Program_channel(?c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026\r\n        [_]Program_sendMaxCount(?smc) \u0026*\u0026 0 \u003c smc \u0026*\u0026\r\n        [_]Program_senders(?s) \u0026*\u0026 [_]this.myIndex |-\u003e ?myIndex \u0026*\u0026\r\n        [_]Program_sendersCount(?sc) \u0026*\u0026 myIndex \u003c sc  \u0026*\u0026\r\n        [1/3]array_slice_deep(s, myIndex, myIndex + 1, senderWorkerInv, unit, cons(this, nil), cons(0, nil));\r\n    \r\n    predicate post() =\r\n        [_]Program_channel(?c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026\r\n        [_]Program_sendMaxCount(?smc) \u0026*\u0026\r\n        [_]Program_senders(?s) \u0026*\u0026 [_]this.myIndex |-\u003e ?myIndex \u0026*\u0026\r\n        [_]Program_sendersCount(?sc) \u0026*\u0026 myIndex \u003c sc  \u0026*\u0026\r\n        [1/3]array_slice_deep(s, myIndex, myIndex + 1, senderWorkerInv, unit, cons(this, nil), cons(smc, nil));\r\n    \r\n    @*/\r\n    \r\n    public void run()\r\n        //@ requires pre();\r\n        //@ ensures post();\r\n    {\r\n        String m = \"Hello\";\r\n        int i;\r\n        for(i = 0; i \u003c Program.sendMaxCount; i++)\r\n            /*@\r\n            invariant\r\n                [_]Program_channel(?c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026\r\n                [_]Program_sendMaxCount(?smc) \u0026*\u0026 i \u003c= smc \u0026*\u0026\r\n                [_]Program_senders(?s) \u0026*\u0026 [_]this.myIndex |-\u003e ?myIndex \u0026*\u0026\r\n                [_]Program_sendersCount(?sc) \u0026*\u0026 myIndex \u003c sc \u0026*\u0026\r\n                [1/3]array_slice_deep(s, myIndex, myIndex + 1, senderWorkerInv, unit, cons(this, nil), cons(i, nil));\r\n            @*/\r\n        {\r\n            for (;;)\r\n                /*@\r\n                invariant\r\n                    [_]Program_channel(c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026\r\n                    [_]Program_sendMaxCount(smc) \u0026*\u0026 i \u003c smc \u0026*\u0026\r\n                    [_]Program_senders(s) \u0026*\u0026 [_]this.myIndex |-\u003e myIndex \u0026*\u0026\r\n                    [_]Program_sendersCount(sc) \u0026*\u0026 myIndex \u003c sc \u0026*\u0026\r\n                    [1/3]array_slice_deep(s, myIndex, myIndex + 1, senderWorkerInv, unit, cons(this, nil), cons(i, nil));\r\n                @*/\r\n            {\r\n                \r\n                /*@\r\n                predicate P() =\r\n                    [_]Program_sendMaxCount(smc) \u0026*\u0026\r\n                    [_]Program_senders(s) \u0026*\u0026 [_]this.myIndex |-\u003e myIndex \u0026*\u0026\r\n                    [_]Program_sendersCount(sc) \u0026*\u0026 myIndex \u003c sc \u0026*\u0026\r\n                    [1/3]array_slice_deep(s, myIndex, myIndex + 1, senderWorkerInv, unit, cons(this, nil), cons(i, nil));\r\n                predicate Q(boolean r) =\r\n                    [_]Program_sendMaxCount(smc) \u0026*\u0026\r\n                    [_]Program_senders(s) \u0026*\u0026 [_]this.myIndex |-\u003e myIndex \u0026*\u0026\r\n                    [_]Program_sendersCount(sc) \u0026*\u0026 myIndex \u003c sc \u0026*\u0026\r\n                    [1/3]array_slice_deep(s, myIndex, myIndex + 1, senderWorkerInv, unit, cons(this, nil), (r ? cons(i+1, nil) : cons(i, nil)));\r\n                \r\n                lemma void my_send(boolean r)\r\n                    requires i \u003c smc \u0026*\u0026 P() \u0026*\u0026 my_unsep_pred(c)(?items, ?qms);\r\n                    ensures Q(r) \u0026*\u0026 my_unsep_pred(c)(r ? append(items, cons(m, nil)) : items, qms);\r\n                {\r\n                    open P();\r\n                    open my_unsep_pred(c)(items, qms);\r\n                    SenderThread[] senders = Program.senders;\r\n                    int sendersCount = Program.sendersCount;\r\n                    int k = myIndex;\r\n                    assert [1/3]array_slice_deep(senders, 0, sendersCount, senderWorkerInv, unit, _, ?oldSenderCounts);\r\n                    array_slice_deep_split(Program.senders, 0, myIndex);\r\n                    array_slice_deep_split_precise(1/3, Program.senders, myIndex, Program.sendersCount, senderWorkerInv, unit, myIndex + 1);\r\n                    array_slice_deep_open_precise(2/3, Program.senders, myIndex);\r\n                    int myOldSendCount = senderSendCount;\r\n                    if (r) {\r\n                        senderSendCount++;\r\n                    }\r\n                    int myNewSendCount = senderSendCount;\r\n                    array_slice_deep_close(Program.senders, myIndex, senderWorkerInv, unit);\r\n                    array_slice_deep_join_precise(1/3, Program.senders, myIndex, myIndex + 1, senderWorkerInv, unit, Program.sendersCount);\r\n                    array_slice_deep_join_precise(1/3, Program.senders, 0, myIndex, senderWorkerInv, unit, Program.sendersCount);\r\n                    \r\n                    forall_append(items, cons(m, nil), non_null);\r\n                    length_append(items, cons(m, nil));\r\n                    assert [1/3]array_slice_deep(senders, 0, sendersCount, senderWorkerInv, unit, _, ?newSenderCounts);\r\n                    assert newSenderCounts == append(take(k, oldSenderCounts), cons(myNewSendCount, drop(1, drop(k, oldSenderCounts))));\r\n                    assert length(oldSenderCounts) == sendersCount;\r\n                    assert 0 \u003c= 1 \u0026*\u0026 0 \u003c= k \u0026*\u0026 1 + k \u003c= length(oldSenderCounts);\r\n                    drop_drop(1, k, oldSenderCounts);\r\n                    assert newSenderCounts == append(take(k, oldSenderCounts), cons(myNewSendCount, drop(k + 1, oldSenderCounts)));\r\n                    sum_take_cons_drop(k, oldSenderCounts, myNewSendCount);\r\n                    assert sum(newSenderCounts) == sum(oldSenderCounts) + myNewSendCount - myOldSendCount;\r\n                    close my_unsep_pred(c)(r ? append(items, cons(m, nil)) : items, qms);\r\n                    close Q(r);\r\n                }\r\n                @*/\r\n                //@ produce_lemma_function_pointer_chunk(my_sep) : channel_sep(client_inv(c), c, my_sep_pred, my_unsep_pred(c))() { close exists(c); call(); };\r\n                //@ produce_lemma_function_pointer_chunk(my_unsep) : channel_unsep(client_inv(c), c, my_sep_pred, my_unsep_pred(c))() { close exists(c); call(); };\r\n                //@ close my_sep_pred();\r\n                //@ produce_lemma_function_pointer_chunk(my_send) : channel_send(client_inv(c), c, my_unsep_pred(c), m, P, Q)(r) { call(); };\r\n                //@ close P();\r\n                boolean success = Program.channel.send(m);\r\n                //@ open Q(success);\r\n                if (success) break;\r\n            }\r\n        }\r\n        //@ assert i == Program.sendMaxCount;\r\n        //@ close post();\r\n    }\r\n}\r\n\r\n/*@\r\n\r\npredicate receiverWorker(unit u, ReceiverThread ReceiverWorker; unit u2) =\r\n    [3]ReceiverWorker.thread |-\u003e ?t \u0026*\u0026 [3]ReceiverWorker.joinable |-\u003e ?j \u0026*\u0026\r\n    [3]t.Thread(j, true) \u0026*\u0026 [3]j.JoinableRunnable(ReceiverWorker, true) \u0026*\u0026 ReceiverWorker.getClass() == ReceiverThread.class \u0026*\u0026\r\n    u2 == unit;\r\n\r\npredicate receiverWorkerNull(unit u, ReceiverThread ReceiverWorker; unit u2) =\r\n    [3/2]ReceiverWorker.thread |-\u003e _ \u0026*\u0026  [3/2]ReceiverWorker.joinable |-\u003e _ \u0026*\u0026\r\n    [3/2]ReceiverWorker.myIndex |-\u003e _ \u0026*\u0026\r\n    ReceiverWorker.getClass() == ReceiverThread.class \u0026*\u0026 [3/4]ReceiverWorker.receiverReceiveCount |-\u003e 0 \u0026*\u0026\r\n    u2 == unit;\r\n\r\npredicate receiverWorkerIndex(int i, ReceiverThread t) =\r\n    [_]t.myIndex |-\u003e i;\r\n\r\n@*/\r\n\r\nclass ReceiverThread implements Runnable {\r\n    //@ int receiverReceiveCount;\r\n    //@ int myIndex;\r\n    Thread thread;\r\n    JoinableRunnable joinable;\r\n    \r\n    /*@\r\n    \r\n    predicate pre() =\r\n        [_]Program_channel(?c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026\r\n        [_]Program_receiveMaxCount(?rmc) \u0026*\u0026 0 \u003c rmc \u0026*\u0026\r\n        [_]Program_receivers(?s) \u0026*\u0026 [_]this.myIndex |-\u003e ?myIndex \u0026*\u0026\r\n        [_]Program_receiversCount(?rc) \u0026*\u0026 myIndex \u003c rc  \u0026*\u0026\r\n        [1/3]array_slice_deep(s, myIndex, myIndex + 1, receiverWorkerInv, unit, cons(this, nil), cons(0, nil));\r\n    \r\n    predicate post() =\r\n        [_]Program_channel(?c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026\r\n        [_]Program_receiveMaxCount(?rmc) \u0026*\u0026\r\n        [_]Program_receivers(?s) \u0026*\u0026 [_]this.myIndex |-\u003e ?myIndex \u0026*\u0026\r\n        [_]Program_receiversCount(?rc) \u0026*\u0026 myIndex \u003c rc  \u0026*\u0026\r\n        [1/3]array_slice_deep(s, myIndex, myIndex + 1, receiverWorkerInv, unit, cons(this, nil), cons(rmc, nil));\r\n    \r\n    @*/\r\n    \r\n    public void run()\r\n        //@ requires pre();\r\n        //@ ensures post();\r\n    {\r\n        int i;\r\n        for (i=0; i \u003c Program.receiveMaxCount; i++)\r\n            /*@\r\n            invariant\r\n                [_]Program_channel(?c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026\r\n                [_]Program_receiveMaxCount(?rmc) \u0026*\u0026 i \u003c= rmc \u0026*\u0026\r\n                [_]Program_receivers(?r) \u0026*\u0026 [_]this.myIndex |-\u003e ?myIndex \u0026*\u0026\r\n                [_]Program_receiversCount(?rc) \u0026*\u0026 myIndex \u003c rc \u0026*\u0026\r\n                [1/3]array_slice_deep(r, myIndex, myIndex + 1, receiverWorkerInv, unit, cons(this, nil), cons(i, nil));\r\n            @*/\r\n        {\r\n            for (;;)\r\n                /*@\r\n                invariant\r\n                    [_]Program_channel(c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026\r\n                    [_]Program_receiveMaxCount(rmc) \u0026*\u0026 i \u003c rmc \u0026*\u0026\r\n                    [_]Program_receivers(r) \u0026*\u0026 [_]this.myIndex |-\u003e myIndex \u0026*\u0026\r\n                    [_]Program_receiversCount(rc) \u0026*\u0026 myIndex \u003c rc \u0026*\u0026\r\n                    [1/3]array_slice_deep(r, myIndex, myIndex + 1, receiverWorkerInv, unit, cons(this, nil), cons(i, nil));\r\n                @*/\r\n            {\r\n                /*@\r\n                predicate P() =  \r\n                    [_]Program_receiveMaxCount(rmc) \u0026*\u0026\r\n                    [_]Program_receivers(r) \u0026*\u0026 [_]this.myIndex |-\u003e myIndex \u0026*\u0026\r\n                    [_]Program_receiversCount(rc) \u0026*\u0026 myIndex \u003c rc \u0026*\u0026\r\n                    [1/3]array_slice_deep(r, myIndex, myIndex + 1, receiverWorkerInv, unit, cons(this, nil), cons(i, nil));\r\n                predicate Q(Object result) = \r\n                    [_]Program_receiveMaxCount(rmc) \u0026*\u0026 \r\n                    [_]Program_receivers(r) \u0026*\u0026 [_]this.myIndex |-\u003e myIndex \u0026*\u0026 \r\n                    [_]Program_receiversCount(rc) \u0026*\u0026 myIndex \u003c rc \u0026*\u0026\r\n                    [1/3]array_slice_deep(r, myIndex, myIndex + 1, receiverWorkerInv, unit, cons(this, nil), (result != null ? cons(i + 1, nil) : cons(i , nil)));\r\n                \r\n                lemma void my_channel_receive()\r\n                    requires i \u003c rmc \u0026*\u0026 P() \u0026*\u0026 my_unsep_pred(c)(?items, ?qms);\r\n                    ensures Q(items != nil ? head(items) : null) \u0026*\u0026 my_unsep_pred(c)(tail(items), qms);\r\n                {\r\n                    open P();\r\n                    open my_unsep_pred(c)(items, qms);\r\n                    ReceiverThread[] receivers = Program.receivers;\r\n                    int receiversCount = Program.receiversCount;\r\n                    int k = myIndex;\r\n                    assert [1/3]array_slice_deep(receivers, 0, receiversCount, receiverWorkerInv, unit, _, ?oldReceiverCounts);\r\n                    array_slice_deep_split(Program.receivers, 0, myIndex);\r\n                    array_slice_deep_split_precise(1/3, Program.receivers, myIndex, Program.receiversCount, receiverWorkerInv, unit, myIndex + 1);\r\n                    array_slice_deep_open_precise(2/3, Program.receivers, myIndex);\r\n                    int myOldReceiveCount = receiverReceiveCount;\r\n                    switch (items) {\r\n                    case nil:\r\n                    case cons(head, tail):\r\n                        receiverReceiveCount++;\r\n                    }\r\n                    int myNewReceiverCount = receiverReceiveCount;\r\n                    array_slice_deep_close(Program.receivers, myIndex, receiverWorkerInv, unit);\r\n                    array_slice_deep_join_precise(1/3, Program.receivers, myIndex, myIndex + 1, receiverWorkerInv, unit, Program.receiversCount);\r\n                    array_slice_deep_join_precise(1/3, Program.receivers, 0, myIndex, receiverWorkerInv, unit, Program.receiversCount);\r\n                    \r\n                    assert [1/3]array_slice_deep(receivers, 0, receiversCount, receiverWorkerInv, unit, _, ?newReceiverCounts);\r\n                    assert newReceiverCounts == append(take(k, oldReceiverCounts), cons(myNewReceiverCount, drop(1, drop(k, oldReceiverCounts))));\r\n                    assert length(oldReceiverCounts) == receiversCount;\r\n                    assert 0 \u003c= 1 \u0026*\u0026 0 \u003c= k \u0026*\u0026 1 + k \u003c= length(oldReceiverCounts);\r\n                    drop_drop(1, k, oldReceiverCounts);\r\n                    assert newReceiverCounts == append(take(k, oldReceiverCounts), cons(myNewReceiverCount, drop(k + 1, oldReceiverCounts)));\r\n                    sum_take_cons_drop(k, oldReceiverCounts, myNewReceiverCount);\r\n                    assert sum(newReceiverCounts) == sum(oldReceiverCounts) + myNewReceiverCount - myOldReceiveCount;\r\n                    \r\n                    switch (items) {\r\n                    case nil:\r\n                        close my_unsep_pred(c)(items, qms);\r\n                        close Q(null);\r\n                    case cons(head, tail):\r\n                        close my_unsep_pred(c)(tail, qms);\r\n                        close Q(head);\r\n                    }\r\n                }\r\n                @*/\r\n                //@ produce_lemma_function_pointer_chunk(my_sep) : channel_sep(client_inv(c), c, my_sep_pred, my_unsep_pred(c))() { close exists(c); call(); };\r\n                //@ produce_lemma_function_pointer_chunk(my_unsep) : channel_unsep(client_inv(c), c, my_sep_pred, my_unsep_pred(c))() { close exists(c); call(); };\r\n                //@ close my_sep_pred();\r\n                //@ produce_lemma_function_pointer_chunk(my_channel_receive) : channel_receive(client_inv(c), c, my_unsep_pred(c), P, Q)() { call(); };\r\n                //@ close P();\r\n                String m = Program.channel.receive();\r\n                //@ open Q(m);\r\n                if (m != null) break;\r\n            }\r\n        }\r\n        //@ close post();\r\n    }\r\n}\r\n\r\npublic class Program {\r\n    \r\n    //@ static int sendCount;\r\n    //@ static int receiveCount;\r\n    \r\n    public static int sendMaxCount;\r\n    public static int receiveMaxCount;\r\n    public static Channel channel;\r\n    public static int sendersCount;\r\n    public static int receiversCount;\r\n    public static SenderThread[] senders;\r\n    public static ReceiverThread[] receivers;\r\n    \r\n    public static void main(String[] args)\r\n        //@ requires class_init_token(Program.class);\r\n        //@ ensures true;\r\n    {\r\n        //@ init_class();\r\n        Program.sendersCount = 1000;\r\n        Program.receiversCount = 1000;\r\n        Program.sendMaxCount = 2000;\r\n        Program.receiveMaxCount = 2000;\r\n        Program.work();\r\n        //@assert Program.sendCount == 2000000;\r\n        //@assert Program.receiveCount == 2000000;\r\n    }\r\n    \r\n    public static void work()\r\n        /*@\r\n        requires\r\n            Program_channel(?channel) \u0026*\u0026\r\n            Program_senders(_) \u0026*\u0026 Program_receivers(_) \u0026*\u0026\r\n            [_]Program_sendersCount(?sendersCount) \u0026*\u0026 [_]Program_receiversCount(?receiversCount) \u0026*\u0026\r\n            0 \u003c sendersCount \u0026*\u0026 0 \u003c receiversCount \u0026*\u0026\r\n            Program_sendCount(?psc) \u0026*\u0026 Program_receiveCount(?prc) \u0026*\u0026 psc==0 \u0026*\u0026 prc==0 \u0026*\u0026\r\n            Program_sendMaxCount(?smc) \u0026*\u0026 0 \u003c smc  \u0026*\u0026 Program_receiveMaxCount(?rmc) \u0026*\u0026 0 \u003c rmc;\r\n        @*/\r\n        //@ ensures Program_sendCount(smc * sendersCount) \u0026*\u0026 Program_receiveCount(rmc * receiversCount);\r\n     {\r\n        Program.senders = new SenderThread[Program.sendersCount];\r\n        //@ SenderThread[] s = Program.senders;\r\n        //@ leak Program_senders(s);\r\n        //@ array_slice_deep_empty_close(s, 0, senderWorker, unit);\r\n        for (int i = 0; i \u003c Program.sendersCount; i++)\r\n            /*@\r\n            invariant\r\n                0 \u003c= i \u0026*\u0026 i \u003c= sendersCount \u0026*\u0026\r\n                [_]Program_senders(s) \u0026*\u0026 [_]Program_sendersCount(sendersCount) \u0026*\u0026\r\n                [1/3]Program_sendMaxCount(smc) \u0026*\u0026 0 \u003c smc \u0026*\u0026\r\n                array_slice(s, i, sendersCount, ?elems) \u0026*\u0026 all_eq(elems, null) == true \u0026*\u0026\r\n                [1/3]array_slice_deep(s, 0, i, senderWorkerInv, unit, _, ?v) \u0026*\u0026 all_eq(v, 0) == true \u0026*\u0026\r\n                [2/3]array_slice_deep(s, 0, i, senderWorkerNull, unit, _, _);\r\n            @*/\r\n        {\r\n            Program.senders[i] = new SenderThread();\r\n            //@ Program.senders[i].myIndex = i;\r\n            //@ array_slice_split(senders, i, i + 1);\r\n            //@ close [2/3]senderWorkerNull(unit, senders[i], unit);\r\n            //@ close [1/3]senderWorkerInv(unit, senders[i], _);\r\n            //@ array_slice_deep_close_precise(2/3, senders, i, senderWorkerNull, unit);\r\n            //@ array_slice_deep_close_precise(1/3, senders, i, senderWorkerInv, unit);\r\n            \r\n        }\r\n        \r\n        Program.receivers = new ReceiverThread[Program.receiversCount];\r\n        //@ ReceiverThread[] r = Program.receivers;\r\n        //@ leak Program_receivers(r);\r\n        //@ array_slice_deep_empty_close(r, 0, receiverWorker, unit);\r\n        for (int i = 0; i \u003c Program.receiversCount; i++)\r\n            /*@\r\n            invariant\r\n                0 \u003c= i \u0026*\u0026 i \u003c= receiversCount \u0026*\u0026\r\n                [_]Program_receivers(r) \u0026*\u0026 [_]Program_receiversCount(receiversCount) \u0026*\u0026\r\n                [1/3]Program_receiveMaxCount(rmc) \u0026*\u0026 0 \u003c rmc \u0026*\u0026\r\n                array_slice(r, i, receiversCount, ?elems) \u0026*\u0026 all_eq(elems, null) == true \u0026*\u0026\r\n                [1/3]array_slice_deep(r, 0, i, receiverWorkerInv, unit, _, ?v) \u0026*\u0026 all_eq(v, 0) == true \u0026*\u0026\r\n                [2/3]array_slice_deep(r, 0, i, receiverWorkerNull, unit, _, _);\r\n            @*/\r\n        {\r\n            receivers[i] = new ReceiverThread();\r\n            //@ Program.receivers[i].myIndex = i;\r\n            //@ array_slice_split(receivers, i, i + 1);\r\n            //@ close [2/3]receiverWorkerNull(unit, receivers[i], unit);\r\n            //@ close [1/3]receiverWorkerInv(unit, receivers[i], _);\r\n            //@ array_slice_deep_close_precise(2/3, receivers, i, receiverWorkerNull, unit);\r\n            //@ array_slice_deep_close_precise(1/3, receivers, i, receiverWorkerInv, unit);\r\n        }\r\n        Program.channel = new Channel(2);\r\n        \r\n        //@ close client_inv(Program.channel)();\r\n        //@ create_atomic_space(client_inv(Program.channel));\r\n        //@ close foreach_i(0, nil, senderWorkerIndex);\r\n        \r\n        for (int i = 0; i \u003c Program.sendersCount; i++)\r\n            /*@\r\n            invariant\r\n                0 \u003c= i \u0026*\u0026 i \u003c= sendersCount \u0026*\u0026\r\n                [_]Program_sendersCount(sendersCount) \u0026*\u0026 [_]Program_senders(s) \u0026*\u0026\r\n                [_]Program_channel(?c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026 [_]Program_sendMaxCount(smc) \u0026*\u0026 0 \u003c smc \u0026*\u0026\r\n                [2/3]array_slice_deep(s, i, sendersCount, senderWorkerNull, unit, _, _) \u0026*\u0026\r\n                [1/3]array_slice_deep(s, 0, i, senderWorker, unit, ?elements, _) \u0026*\u0026 foreach_i(0, elements, senderWorkerIndex);\r\n            @*/\r\n        {\r\n            //@ array_slice_deep_split(s, i, i + 1);\r\n            //@ array_slice_deep_open_precise(2/3, s, i);\r\n            SenderThread sender = senders[i];\r\n            //@ close [1/3]senderWorkerInv(unit, sender, _);\r\n            //@ array_slice_deep_close_precise(1/3, s, i, senderWorkerInv, unit);\r\n            JoinableRunnable j = ThreadingHelper.createJoinableRunnable(sender);\r\n            //@ sender.myIndex = i;\r\n            //@ leak sender.myIndex |-\u003e i;\r\n            //@ close sender.pre();\r\n            //@ j.closeIt();\r\n            Thread t = new Thread(j);\r\n            t.start();\r\n            \r\n            sender.thread = t;\r\n            sender.joinable = j;\r\n            //@ close [1/3]senderWorker(unit, sender, unit);\r\n            //@ array_slice_deep_close_precise(1/3, senders, i, senderWorker, unit);\r\n            \r\n            //@ close foreach_i(i + 1, nil, senderWorkerIndex);\r\n            //@ close senderWorkerIndex(i, sender);\r\n            //@ close foreach_i(i, cons(sender, nil), senderWorkerIndex);\r\n            //@ foreach_i_append(0, elements, cons(sender, nil));\r\n        }\r\n        //@ close foreach_i(0, nil, receiverWorkerIndex);\r\n        for (int i = 0; i \u003c Program.receiversCount; i++)\r\n            /*@\r\n            invariant\r\n                0 \u003c= i \u0026*\u0026 i \u003c= receiversCount \u0026*\u0026\r\n                [_]Program_receiversCount(receiversCount) \u0026*\u0026 [_]Program_receivers(r) \u0026*\u0026\r\n                [_]Program_channel(?c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026 [_]Program_receiveMaxCount(rmc) \u0026*\u0026 0 \u003c rmc \u0026*\u0026\r\n                [2/3]array_slice_deep(r, i, receiversCount, receiverWorkerNull, unit, _, _) \u0026*\u0026\r\n                [1/3]array_slice_deep(r, 0, i, receiverWorker, unit, ?elements, _) \u0026*\u0026 foreach_i(0, elements, receiverWorkerIndex);\r\n            @*/\r\n        {\r\n            //@ array_slice_deep_split(r, i, i + 1);\r\n            //@ array_slice_deep_open_precise(2/3, r, i);\r\n            ReceiverThread receiver = receivers[i];\r\n            //@ close [1/3]receiverWorkerInv(unit, receiver, _);\r\n            //@ array_slice_deep_close_precise(1/3, r, i, receiverWorkerInv, unit);\r\n            JoinableRunnable j = ThreadingHelper.createJoinableRunnable(receiver);\r\n            //@ receiver.myIndex = i;\r\n            //@ leak receiver.myIndex |-\u003e i;\r\n            //@ close receiver.pre();\r\n            //@ j.closeIt();\r\n            Thread t = new Thread(j);\r\n            t.start();\r\n            \r\n            receiver.thread = t;\r\n            receiver.joinable = j;\r\n            //@ close [1/3]receiverWorker(unit, receiver, unit);\r\n            //@ array_slice_deep_close_precise(1/3, receivers, i, receiverWorker, unit);\r\n            \r\n            //@ close foreach_i(i + 1, nil, receiverWorkerIndex);\r\n            //@ close receiverWorkerIndex(i, receiver);\r\n            //@ close foreach_i(i, cons(receiver, nil), receiverWorkerIndex);\r\n            //@ foreach_i_append(0, elements, cons(receiver, nil));\r\n        }\r\n        \r\n        int j;\r\n        for (j = 0; j \u003c Program.sendersCount; j++)\r\n            /*@\r\n            invariant\r\n                0 \u003c= j \u0026*\u0026 j \u003c= sendersCount \u0026*\u0026\r\n                [_]Program_sendersCount(sendersCount) \u0026*\u0026 [_]Program_senders(s) \u0026*\u0026\r\n                [_]Program_channel(?c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026\r\n                Program_sendCount(j * smc) \u0026*\u0026 [_]Program_sendMaxCount(smc) \u0026*\u0026\r\n                [1/3]array_slice_deep(s, j, sendersCount, senderWorker, unit, ?elements, _) \u0026*\u0026 foreach_i(j, elements, senderWorkerIndex);\r\n            @*/\r\n        {\r\n            SenderThread sw = senders[j];\r\n            ThreadingHelper.join(sw.thread, sw.joinable);\r\n            //@ open sw.post();\r\n            //@ open foreach_i(j, elements, senderWorkerIndex);\r\n            //@ open senderWorkerIndex(j, sw);\r\n            //@ int jj = sw.myIndex;\r\n            //@ assert j == jj;\r\n            //@ array_slice_deep_open_precise(1/3, s, j);\r\n            //@ open senderWorkerInv(unit, sw, _);\r\n            //@ Program.sendCount += sw.senderSendCount;\r\n        }\r\n        //@ assert Program.sendCount == Program.sendMaxCount * j;\r\n        //@ assert j == sendersCount;\r\n        //@ assert Program.sendCount == Program.sendMaxCount * sendersCount;\r\n        for (j = 0; j \u003c Program.receiversCount; j++)\r\n            /*@\r\n            invariant\r\n                0 \u003c= j \u0026*\u0026 j \u003c= receiversCount \u0026*\u0026\r\n                [_]Program_receiversCount(receiversCount) \u0026*\u0026 [_]Program_receivers(r) \u0026*\u0026\r\n                [_]Program_channel(?c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026\r\n                Program_receiveCount(j * rmc) \u0026*\u0026 [_]Program_receiveMaxCount(rmc) \u0026*\u0026\r\n                [1/3]array_slice_deep(r, j, receiversCount, receiverWorker, unit, ?elements, _) \u0026*\u0026 foreach_i(j, elements, receiverWorkerIndex);\r\n            @*/\r\n        {\r\n            ReceiverThread rw = receivers[j];\r\n            ThreadingHelper.join(rw.thread, rw.joinable);\r\n            //@ open rw.post();\r\n            //@ open foreach_i(j, elements, receiverWorkerIndex);\r\n            //@ open receiverWorkerIndex(j, rw);\r\n            //@ int jj = rw.myIndex;\r\n            //@ assert j == jj;\r\n            //@ array_slice_deep_open_precise(1/3, r, j);\r\n            //@ open receiverWorkerInv(unit, rw, _);\r\n            //@ Program.receiveCount += rw.receiverReceiveCount;\r\n        }\r\n        //@ assert Program.receiveCount == Program.receiveMaxCount * j;\r\n        //@ assert j == receiversCount;\r\n        //@ assert Program.receiveCount == Program.receiveMaxCount * receiversCount;\r\n    }\r\n    \r\n}\r\n",
        "name": "client.java",
        "path": "examples/java/channels/client.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/channels/client.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 157,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 158,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 289,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 290,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 396,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires class_init_token(Program.class);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 397,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 419,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Program_sendCount(smc * sendersCount) \u0026*\u0026 Program_receiveCount(rmc * receiversCount);\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "interface Counter {\r\n    /*@\r\n\r\n    predicate Counter(int value);\r\n\r\n    lemma void inv();\r\n        requires [?f]Counter(?value);\r\n        ensures [f]Counter(value) \u0026*\u0026 0 \u003c= value;\r\n\r\n    @*/\r\n\r\n    public int get();\r\n        //@ requires [?f]Counter(?value);\r\n        //@ ensures [f]Counter(value) \u0026*\u0026 result == value;\r\n\r\n    public void set(int value);\r\n        //@ requires Counter(_) \u0026*\u0026 0 \u003c= value;\r\n        //@ ensures Counter(value);\r\n}\r\n\r\nclass MyCounter implements Counter {\r\n    int count;\r\n\r\n    /*@\r\n\r\n    predicate Counter(int value) = count |-\u003e value \u0026*\u0026 0 \u003c= value;\r\n\r\n    lemma void inv()\r\n        requires [?f]Counter(?value);\r\n        ensures [f]Counter(value) \u0026*\u0026 0 \u003c= value;\r\n    {\r\n        open Counter(value);\r\n        close [f]Counter(value);\r\n    }\r\n\r\n    @*/\r\n\r\n    MyCounter()\r\n        //@ requires true;\r\n        //@ ensures Counter(0);\r\n    {\r\n        //@ close Counter(0);\r\n    }\r\n\r\n    public int get()\r\n        //@ requires [?f]Counter(?value);\r\n        //@ ensures [f]Counter(value) \u0026*\u0026 result == value;\r\n    {\r\n        //@ open Counter(value);\r\n        return count;\r\n        //@ close [f]Counter(value);\r\n    }\r\n\r\n    public void set(int value)\r\n        //@ requires Counter(_) \u0026*\u0026 0 \u003c= value;\r\n        //@ ensures Counter(value);\r\n    {\r\n        //@ open Counter(_);\r\n        count = value;\r\n        //@ close Counter(value);\r\n    }\r\n}\r\n\r\nclass Program {\r\n    public static void test(Counter c)\r\n        //@ requires [?f]c.Counter(?value_);\r\n        //@ ensures [f]c.Counter(value_);\r\n    {\r\n        int value = c.get();\r\n        //@ c.inv();\r\n        assert 0 \u003c= value;\r\n    }\r\n\r\n    public static void main(String[] args)\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        Counter c = new MyCounter();\r\n        c.set(42);\r\n        test(c);\r\n    }\r\n}",
        "name": "InterfaceLemmas.java",
        "path": "examples/java/InterfaceLemmas.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/InterfaceLemmas.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [?f]Counter(?value);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [f]Counter(value) \u0026*\u0026 result == value;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires Counter(_) \u0026*\u0026 0 \u003c= value;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Counter(value);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 39,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Counter(0);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 45,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [?f]Counter(?value);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 46,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [f]Counter(value) \u0026*\u0026 result == value;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 54,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires Counter(_) \u0026*\u0026 0 \u003c= value;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 55,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Counter(value);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 65,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [?f]c.Counter(?value_);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 66,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [f]c.Counter(value_);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 74,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 75,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package Store;\n\nimport javacard.framework.*;\n\npublic final class Store extends Applet {\n    \n    //CLA byte\n    private static final byte Store_CLA = (byte) 0xB0;\n    //Instruction (ins) bytes\n    private static final byte SET = (byte) 0x10;\n    private static final byte GET = (byte) 0x20;\n    \n    //byte array to store data\n    private static byte value[];\n    \n    /*@\n    predicate valid() = value |-\u003e ?array \u0026*\u0026 array != null \u0026*\u0026 array_slice(array, 0, array.length, _) \u0026*\u0026 array.length == 5;\n    @*/\n    \n    public static void install(byte[] bArray, short bOffset, byte bLength)\n        //@ requires class_init_token(Store.class) \u0026*\u0026 system();\n        //@ ensures true;\n    {\n        //@ init_class();\n        Store store = new Store();\n        store.register();\n    }\n    \n    protected Store()\n        //@ requires value |-\u003e _;\n        //@ ensures valid();\n    {\n        value = new byte[5];\n        //@ close valid();\n    }\n    \n    public void process(APDU apdu)\n        //@ requires [1/2]this.valid() \u0026*\u0026 current_applet(this) \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\n        //@ ensures [1/2]this.valid() \u0026*\u0026 current_applet(this) \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\n    {\n        byte[] abuffer = apdu.getBuffer();\n        \n        if(selectingApplet())\n            return;\n        \n        if(abuffer[ISO7816.OFFSET_CLA] != Store_CLA)\n            ISOException.throwIt(ISO7816.SW_CLA_NOT_SUPPORTED);\n        \n        switch(abuffer[ISO7816.OFFSET_INS]) {\n            case GET: get(apdu); return;\n            case SET: set(apdu); return;\n            default: ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);\n        }\n    }\n    \n    private final void set(APDU apdu)\n        //@ requires APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();\n        //@ ensures APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();\n    {\n        byte[] abuffer = apdu.getBuffer();\n        \n        //Data received \u003e 5 bytes (length value array) -\u003e exception\n        if((abuffer[ISO7816.OFFSET_LC] \u0026 0xff) \u003e 5)\n            ISOException.throwIt(ISO7816.SW_DATA_INVALID);\n\n        JCSystem.beginTransaction();\n        //@ open valid();\n        //Copy received data into value array\n        Util.arrayCopy(abuffer, (short)ISO7816.OFFSET_CDATA, value, (short)0, (short)(abuffer[ISO7816.OFFSET_LC] \u0026 0xff));\n        //@ close valid();\n        JCSystem.commitTransaction();\n    }\n    \n    private void get(APDU apdu)\n    //@ requires APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();\n    //@ ensures APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();\n    {\n        byte[] abuffer = apdu.getBuffer();\n        \n        apdu.setOutgoing();\n        apdu.setOutgoingLength(abuffer[ISO7816.OFFSET_LC]);\n        \n        //@ open [1/2]valid();\n        //Send data in value array\n        apdu.sendBytesLong(value, (short)0, (short)value.length);\n        //@ close [1/2]valid();\n    }\n    \n}\n",
        "name": "Store.java",
        "path": "examples/java/Java Card/Store.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/Store.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires class_init_token(Store.class) \u0026*\u0026 system();"
        },
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 29,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires value |-\u003e _;"
        },
        {
          "limitHit": false,
          "lineNumber": 30,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 37,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [1/2]this.valid() \u0026*\u0026 current_applet(this) \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);"
        },
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [1/2]this.valid() \u0026*\u0026 current_applet(this) \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);"
        },
        {
          "limitHit": false,
          "lineNumber": 56,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 57,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 74,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 75,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "abstract class A {\n  //@ predicate valid() = true;\n\n  public abstract void m();\n    //@ requires valid();\n    //@ ensures valid();\n}\n\nclass B extends A {\n  int x;\n  \n  //@ predicate valid() = x |-\u003e ?v;\n\n  public void m()\n    //@ requires valid();\n    //@ ensures valid();\n  {\n    //@ open valid();\n    x = 0;\n    //@ close valid();\n  }\n}\n\nabstract class B2 extends A {\n}\n\nclass Program {\n  public void test(A a) \n    //@ requires a != null \u0026*\u0026 a.valid();\n    //@ ensures true;\n  {\n    a.m();\n  }\n}",
        "name": "AbstractClasses.java",
        "path": "examples/java/AbstractClasses.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/AbstractClasses.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires a != null \u0026*\u0026 a.valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 29,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import javacard.framework.*;\r\n\r\npublic final class MyApplet extends Applet {\r\n    int tokensLeft, tokensUsed;\r\n    \r\n    //@ predicate valid() = tokensLeft |-\u003e ?m \u0026*\u0026 0 \u003c= m \u0026*\u0026 tokensUsed |-\u003e ?n \u0026*\u0026 m + n == 10;\r\n    \r\n    MyApplet()\r\n        //@ requires true;\r\n        //@ ensures valid();\r\n    {\r\n        tokensLeft = 10;\r\n    }\r\n    \r\n    public static void install(byte[] array, short offset, byte length) \r\n        //@ requires system();\r\n        //@ ensures true;\r\n    {\r\n        MyApplet applet = new MyApplet();\r\n        applet.register();\r\n    }\r\n    \r\n    public void process(APDU apdu)\r\n        //@ requires current_applet(this) \u0026*\u0026 [1/2]valid();\r\n        //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid();\r\n    {\r\n        //@ { int x = tokensLeft + tokensUsed; assert x == 10; }\r\n        if (tokensLeft == 0)\r\n            ISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);\r\n        JCSystem.beginTransaction();\r\n        //@ open valid();\r\n        tokensLeft--;\r\n        tokensUsed++;\r\n        JCSystem.commitTransaction();\r\n    }\r\n}",
        "name": "transaction.java",
        "path": "javacard_tutorial/transaction.java",
        "url": "/github.com/verifast/verifast/-/blob/javacard_tutorial/transaction.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires system();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 23,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires current_applet(this) \u0026*\u0026 [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 24,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid();\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package chat;\n\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\n\n/*@\n\npredicate member(Member member) =\n    member.nick |-\u003e ?nick \u0026*\u0026 [1/2]member.writer |-\u003e ?writer \u0026*\u0026 writer != null \u0026*\u0026 writer.Writer();\n\nlemma void member_distinct(Member m1,Member m2)\n    requires member(m1) \u0026*\u0026 member(m2);\n    ensures member(m1) \u0026*\u0026 member(m2) \u0026*\u0026 m1 != m2;\n{\n    open member(m1);\n    open member(m2);\n    close member(m2);\n    close member(m1);\n}\n\nlemma void foreach_member_not_contains(list\u003cMember\u003e members, Member member)\n    requires foreach(members, @member) \u0026*\u0026 member(member);\n    ensures foreach(members, @member) \u0026*\u0026 member(member) \u0026*\u0026 !mem\u003cObject\u003e(member, members);\n{\n    switch (members) {\n        case nil:\n        case cons(m, ms):\n            open foreach(members, @member);\n            member_distinct(m, member);\n            foreach_member_not_contains(ms, member);\n            close foreach(members, @member);\n    }\n}\n\n@*/\n\nclass Member {\n    String nick;\n    Writer writer;\n    \n    public Member(String nick, Writer writer)\n        //@ requires writer != null \u0026*\u0026 writer.Writer();\n        //@ ensures member(this) \u0026*\u0026 [1/2]this.writer |-\u003e writer;\n    {\n        this.nick = nick;\n        this.writer = writer;\n        //@ close member(this);\n    }\n}\n",
        "name": "Member.java",
        "path": "examples/java/chat_raw/Member.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/chat_raw/Member.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 42,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires writer != null \u0026*\u0026 writer.Writer();"
        },
        {
          "limitHit": false,
          "lineNumber": 43,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures member(this) \u0026*\u0026 [1/2]this.writer |-\u003e writer;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package chat;\n\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.concurrent.*;\n\nclass ListUtil {\n    \n    static void remove(List l, Object o) // Like l.remove(o), except uses identity comparison instead of .equals().\n        //@ requires l.List(?es);\n        //@ ensures l.List(remove(o, es));\n    {\n        for (int i = 0; i \u003c l.size(); i++)\n            //@ invariant l.List(es) \u0026*\u0026 0 \u003c= i \u0026*\u0026 i \u003c= index_of(o, es);\n        {\n            if (l.get(i) == o) {\n                l.remove(i);\n                //@ remove_remove_nth(o, es);\n                //@ index_of_nth(i, es);\n                break;\n            }\n            //@ if (index_of(o, es) == i) { nth_index_of(o, es); }\n        }\n        //@ if (mem(o, es)) { mem_index_of(o, es); } else { mem_remove_eq(o, es); }\n    }\n    \n}\n\n/*@\n\npredicate_ctor room_ctor(Room room)() = room(room);\n\npredicate session(Session session;) =\n    session.room |-\u003e ?room \u0026*\u0026 session.room_lock |-\u003e ?roomLock \u0026*\u0026 session.socket |-\u003e ?socket \u0026*\u0026 socket != null \u0026*\u0026 socket.Socket(?i, ?o)\n    \u0026*\u0026 roomLock != null \u0026*\u0026 [_]roomLock.Semaphore(room_ctor(room)) \u0026*\u0026 i.InputStream() \u0026*\u0026 o.OutputStream();\n\n@*/\n\npublic final class Session implements Runnable {\n    Room room;\n    Semaphore room_lock;\n    Socket socket;\n    \n    //@ predicate pre() = session(this);\n    //@ predicate post() = true;\n    \n    public Session(Room room, Semaphore roomLock, Socket socket)\n        /*@\n        requires\n            roomLock != null \u0026*\u0026 [_]roomLock.Semaphore(room_ctor(room)) \u0026*\u0026\n            socket != null \u0026*\u0026 socket.Socket(?i, ?o) \u0026*\u0026 i.InputStream() \u0026*\u0026 o.OutputStream();\n        @*/\n        //@ ensures session(this);\n    {\n        this.room = room;\n        this.room_lock = roomLock;\n        this.socket = socket;\n        //@ close session(this);\n    }\n    \n    public void run_with_nick(Room room, Semaphore roomLock, BufferedReader reader, Writer writer, String nick) throws InterruptedException /*@ ensures true; @*/, IOException /*@ ensures true; @*/\n        /*@\n        requires\n            roomLock != null \u0026*\u0026 [_]roomLock.Semaphore(room_ctor(room)) \u0026*\u0026 room != null \u0026*\u0026 room(room) \u0026*\u0026\n            reader != null \u0026*\u0026 reader.Reader() \u0026*\u0026\n            writer != null \u0026*\u0026 writer.Writer();\n        @*/\n        //@ ensures [_]roomLock.Semaphore(room_ctor(room)) \u0026*\u0026 reader.Reader() \u0026*\u0026 writer.Writer();\n    {\n        Member member = null;\n        String joinMessage = nick + \" has joined the room.\";\n        room.broadcast_message(joinMessage);\n        {\n            //@ open room(room);\n            member = new Member(nick, writer);\n            List list = room.members;\n            list.add(member);\n            //@ open foreach\u003cMember\u003e(?members, @member);\n            //@ close foreach(members, @member);\n            //@ foreach_member_not_contains(members, member);\n            //@ close foreach\u003cMember\u003e(nil, @member);\n            //@ close foreach\u003cMember\u003e(cons\u003cMember\u003e(member, nil), @member);\n            //@ foreach_append\u003cMember\u003e(members, cons\u003cMember\u003e(member, nil));\n            //@ close room(room);\n        }\n        //@ close room_ctor(room)();\n        //@ roomLock.makeHandle();\n        roomLock.release();\n        \n        {\n            String message = reader.readLine();\n            while (message != null)\n                //@ invariant reader.Reader() \u0026*\u0026 [_]roomLock.Semaphore(room_ctor(room));\n            {\n                //@ roomLock.makeHandle();\n                roomLock.acquire();\n                //@ open room_ctor(room)();\n                room.broadcast_message(nick + \" says: \" + message);\n                //@ close room_ctor(room)();\n                roomLock.release();\n                message = reader.readLine();\n            }\n        }\n        \n        roomLock.acquire();\n        //@ open room_ctor(room)();\n        //@ open room(room);\n        {\n            List membersList = room.members;\n            //@ assert foreach\u003cMember\u003e(?members, @member);\n            //@ assume(mem\u003cMember\u003e(member, members)); // TODO: Eliminate using a ghost list.\n            ListUtil.remove(membersList, member);\n            //@ foreach_remove\u003cMember\u003e(member, members);\n        }\n        //@ close room(room);\n        {\n            room.broadcast_message(nick + \" left the room.\");\n        }\n        //@ close room_ctor(room)();\n        roomLock.release();\n        \n        //@ open member(member);\n    }\n    \n    public void run()\n        //@ requires pre();\n        //@ ensures post();\n    {\n        try {\n            this.runCore();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    \n    public void runCore() throws InterruptedException /*@ ensures true; @*/, IOException /*@ ensures true; @*/\n        //@ requires pre();\n        //@ ensures post();\n    {\n        //@ open pre();\n        //@ open session(this);\n        Room room = this.room;\n        Semaphore roomLock = this.room_lock;\n        Socket socket = this.socket;\n        InputStream in = socket.getInputStream();\n        InputStreamReader reader0 = new InputStreamReader(in);\n        BufferedReader reader = new BufferedReader(reader0);\n        OutputStream out = socket.getOutputStream();\n        OutputStreamWriter writer0 = new OutputStreamWriter(out);\n        BufferedWriter writer1 = new BufferedWriter(writer0);\n        Writer writer = writer1;\n        \n        writer.write(\"Welcome to the chat room.\\r\\n\");\n        writer.write(\"The following members are present: \");\n        \n        //@ roomLock.makeHandle();\n        roomLock.acquire();\n        //@ open room_ctor(room)();\n        //@ open room(room);\n        {\n            List membersList = room.members;\n            //@ assert foreach\u003cMember\u003e(?members, @member);\n            //@ membersList.listToIterable();\n            Iterator iter = membersList.iterator();\n            boolean hasNext = iter.hasNext();\n            while (hasNext)\n                /*@\n                invariant\n                    writer.Writer() \u0026*\u0026\n                    iter.Iterator((seq_of_list)(members), _, ?i) \u0026*\u0026 Iterable_iterating(membersList.getClass())(membersList, members, 1, iter)\n                    \u0026*\u0026 foreach(members, @member) \u0026*\u0026 hasNext == (i \u003c length(members)) \u0026*\u0026 0 \u003c= i \u0026*\u0026 i \u003c= length(members);\n                @*/\n            {\n                Member member = (Member) iter.next();\n                //@ foreach_remove\u003cMember\u003e(member, members);\n                //@ open member(member);\n                writer.write(member.nick);\n                writer.write(\"  \");\n                //@ close member(member);\n                //@ foreach_unremove\u003cMember\u003e(member, members);\n                hasNext = iter.hasNext();\n            }\n            writer.write(\"\\r\\n\");\n            writer.flush();\n            //@ membersList.destroyIterator();\n            //@ membersList.iterableToList();\n        }\n        \n        //@ close room(room);\n        //@ close room_ctor(room)();\n        roomLock.release();\n\n        {\n            boolean done = false;\n            while (!done)\n                //@ invariant writer.Writer() \u0026*\u0026 reader.Reader() \u0026*\u0026 [_]roomLock.Semaphore(room_ctor(room));\n            {\n                writer.write(\"Please enter your nick: \\r\\n\");\n                writer.flush();\n                {\n                    String nick = reader.readLine();\n                    if (nick == null) {\n                        done = true;\n                    } else {\n                        //@ roomLock.makeHandle();\n                        roomLock.acquire();\n                        //@ open room_ctor(room)();\n                        {\n                            if (room.has_member(nick)) {\n                                //@ close room_ctor(room)();\n                                roomLock.release();\n                                writer.write(\"Error: This nick is already in use.\\r\\n\");\n                                writer.flush();\n                            } else {\n                                this.run_with_nick(room, roomLock, reader, writer, nick);\n                                done = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        //@ reader.destroy();\n        //@ reader0.destroy();\n        //@ writer1.destroy();\n        //@ writer0.destroy();\n        socket.close();\n        //@ close post();\n    }\n}",
        "name": "Session.java",
        "path": "examples/java/chat_raw/Session.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/chat_raw/Session.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires l.List(?es);"
        },
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures l.List(remove(o, es));"
        },
        {
          "limitHit": false,
          "lineNumber": 53,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures session(this);"
        },
        {
          "limitHit": false,
          "lineNumber": 68,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [_]roomLock.Semaphore(room_ctor(room)) \u0026*\u0026 reader.Reader() \u0026*\u0026 writer.Writer();"
        },
        {
          "limitHit": false,
          "lineNumber": 126,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre();"
        },
        {
          "limitHit": false,
          "lineNumber": 127,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post();"
        },
        {
          "limitHit": false,
          "lineNumber": 139,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre();"
        },
        {
          "limitHit": false,
          "lineNumber": 140,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post();"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "// Work done in collaboration with Sybren Roede and Ruurd Kuiper\r\n\r\npackage channels;\r\n\r\nimport java.util.concurrent.*;\r\nimport java.util.*;\r\n\r\n/*@\r\n\r\npredicate_ctor channel_sema_inv(Channel channel)() =\r\n    channel.itemList |-\u003e ?itemList \u0026*\u0026 itemList.List(?items) \u0026*\u0026 [1/2]channel.items_ |-\u003e items \u0026*\u0026\r\n    [1/2]channel.queueMaxSize |-\u003e ?qms \u0026*\u0026 length(items) \u003c= qms;\r\n\r\n@*/\r\n\r\npublic final class Channel {\r\n\r\n    //@ list\u003cObject\u003e items_;\r\n    List\u003cString\u003e itemList;\r\n    Semaphore sema;\r\n    int queueMaxSize;\r\n    \r\n    //@ predicate Channel() = sema |-\u003e ?sema \u0026*\u0026 [_]sema.Semaphore(channel_sema_inv(this));\r\n    //@ predicate ChannelState(list\u003cObject\u003e items, int qms) = [1/2]items_ |-\u003e items \u0026*\u0026 [1/2]queueMaxSize |-\u003e qms;\r\n    \r\n    public Channel(int queueMaxSize)\r\n        //@ requires 0 \u003c= queueMaxSize;\r\n        //@ ensures Channel() \u0026*\u0026 ChannelState(nil, queueMaxSize);\r\n    {\r\n        itemList = new ArrayList\u003cString\u003e();\r\n        this.queueMaxSize = queueMaxSize;\r\n        //@ items_ = nil;\r\n        //@ close channel_sema_inv(this)();\r\n        //@ one_time(channel_sema_inv(this));\r\n        sema = new Semaphore(1);\r\n        //@ sema.leakHandle();\r\n        //@ close Channel();\r\n        //@ close ChannelState(nil, queueMaxSize);\r\n    }\r\n    \r\n    boolean send(String msg)\r\n        /*@\r\n        requires \r\n            [?fc]Channel() \u0026*\u0026\r\n            [?fa]atomic_space(?inv) \u0026*\u0026\r\n            is_channel_sep(?sep, inv, this, ?sepPred, ?unsepPred) \u0026*\u0026\r\n            is_channel_unsep(?unsep, inv, this, sepPred, unsepPred) \u0026*\u0026\r\n            sepPred() \u0026*\u0026\r\n            is_channel_send(?send_, inv, this, unsepPred, msg, ?pre, ?post) \u0026*\u0026 pre();\r\n        @*/\r\n        /*@\r\n        ensures\r\n            [fc]Channel() \u0026*\u0026\r\n            [fa]atomic_space(inv) \u0026*\u0026\r\n            sepPred() \u0026*\u0026\r\n            post(result);\r\n        @*/\r\n    {\r\n        //@ open [fc]Channel();\r\n        //@ sema.makeHandle();\r\n        sema.acquire();\r\n        //@ open channel_sema_inv(this)();\r\n        //@ assert itemList |-\u003e ?l \u0026*\u0026 l.List(?items);\r\n        //@ assert [1/2]queueMaxSize |-\u003e ?qms;\r\n\r\n        boolean result;\r\n        if (itemList.size() \u003c queueMaxSize) {\r\n            itemList.add(msg);\r\n            result = true;\r\n        } else {\r\n            result = false;\r\n        }\r\n        \r\n        {\r\n            /*@\r\n            predicate P() =\r\n                is_channel_sep(sep, inv, this, sepPred, unsepPred) \u0026*\u0026\r\n                is_channel_unsep(unsep, inv, this, sepPred, unsepPred) \u0026*\u0026\r\n                is_channel_send(send_, inv, this, unsepPred, msg, pre, post) \u0026*\u0026\r\n                sepPred() \u0026*\u0026 pre() \u0026*\u0026\r\n                [1/2]items_ |-\u003e items;\r\n            predicate Q() =\r\n                [1/2]items_ |-\u003e (length(items) \u003c qms ? append\u003cObject\u003e(items, cons(msg, nil)) : items) \u0026*\u0026\r\n                sepPred() \u0026*\u0026\r\n                post(length(items) \u003c qms);\r\n            \r\n            lemma void my_ghost_op()\r\n                requires P() \u0026*\u0026 inv();\r\n                ensures Q() \u0026*\u0026 inv();\r\n            {\r\n                open P();\r\n                sep();\r\n                open ChannelState(_, _);\r\n                if (length(items) \u003c qms)\r\n                {\r\n                  items_ = append\u003cObject\u003e(items, cons(msg, nil));\r\n                  close ChannelState(append\u003cObject\u003e(items, cons(msg, nil)), _);\r\n                  send_(true);\r\n                }\r\n                else\r\n                {\r\n                  items_ = items;\r\n                  close ChannelState(items, _);\r\n                  send_(false);\r\n                }\r\n\r\n                unsep();\r\n                close Q();\r\n            }\r\n            @*/\r\n            //@ close P();\r\n            //@ produce_lemma_function_pointer_chunk(my_ghost_op) : atomic_space_ghost_operation(inv, P, Q)() { call(); };\r\n            //@ perform_atomic_space_ghost_operation();\r\n            //@ open Q();\r\n        }\r\n        //@ length_append\u003cObject\u003e(items, cons(msg, nil));\r\n        //@ close channel_sema_inv(this)();\r\n        sema.release();\r\n        //@ close [fc]Channel();\r\n        return result;\r\n    }\r\n    \r\n    String receive()\r\n        /*@\r\n        requires\r\n            [?fc]Channel() \u0026*\u0026\r\n            [?fa]atomic_space(?inv) \u0026*\u0026\r\n            is_channel_sep(?sep, inv, this, ?sepPred, ?unsepPred) \u0026*\u0026\r\n            is_channel_unsep(?unsep, inv, this, sepPred, unsepPred) \u0026*\u0026\r\n            is_channel_receive(?receive_, inv, this, unsepPred, ?pre, ?post) \u0026*\u0026\r\n            sepPred() \u0026*\u0026 pre();\r\n        @*/\r\n        /*@\r\n        ensures\r\n            [fc]Channel() \u0026*\u0026\r\n            [fa]atomic_space(inv) \u0026*\u0026\r\n            sepPred() \u0026*\u0026\r\n            post(result);\r\n        @*/\r\n    {\r\n        //@ sema.makeHandle();\r\n        sema.acquire();\r\n        //@ open channel_sema_inv(this)();\r\n        String result;\r\n        if (itemList.size() == 0) {\r\n            result = null;\r\n        } else {\r\n            result = (String)itemList.remove(0);\r\n        }\r\n        //@ list\u003cObject\u003e items = items_;\r\n        {\r\n            /*@\r\n            predicate P() =\r\n                is_channel_sep(sep, inv, this, sepPred, unsepPred) \u0026*\u0026\r\n                is_channel_unsep(unsep, inv, this, sepPred, unsepPred) \u0026*\u0026\r\n                is_channel_receive(receive_, inv, this, unsepPred, pre, post) \u0026*\u0026\r\n                sepPred() \u0026*\u0026 pre() \u0026*\u0026\r\n                [1/2]items_ |-\u003e items;\r\n            predicate Q() =\r\n                [1/2]items_ |-\u003e tail(items) \u0026*\u0026\r\n                sepPred() \u0026*\u0026\r\n                post(items != nil ? head(items) : null);\r\n            \r\n            lemma void my_ghost_op()\r\n                requires P() \u0026*\u0026 inv();\r\n                ensures Q() \u0026*\u0026 inv();\r\n            {\r\n                open P();\r\n                sep();\r\n                open ChannelState(_, _);\r\n                items_ = tail(items);\r\n                close ChannelState(tail(items), _);\r\n                receive_();\r\n                unsep();\r\n                close Q();\r\n            }\r\n            @*/\r\n            //@ close P();\r\n            //@ produce_lemma_function_pointer_chunk(my_ghost_op) : atomic_space_ghost_operation(inv, P, Q)() { call(); };\r\n            //@ perform_atomic_space_ghost_operation();\r\n            //@ open Q();\r\n        }\r\n        //@ switch (items) { case nil: case cons(i0, is0): }\r\n        //@ close channel_sema_inv(this)();\r\n        sema.release();\r\n        return result;\r\n    }\r\n    \r\n}\r\n",
        "name": "Channel.java",
        "path": "examples/java/channels/Channel.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/channels/Channel.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 26,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires 0 \u003c= queueMaxSize;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Channel() \u0026*\u0026 ChannelState(nil, queueMaxSize);\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "//@ predicate IO(int n);\n\nclass OS {\n\n    static void beep()\n        //@ requires IO(?n);\n        //@ ensures 0 \u003c n \u0026*\u0026 IO(n - 1);\n        //@ terminates;\n    {\n        throw new RuntimeException();\n    }\n\n}\n\nclass Beeper {\n\n    static void beepForever()\n        //@ requires IO(?n) \u0026*\u0026 call_perm_rec(currentThread, {Beeper.class}, int_lt, n);\n        //@ ensures false;\n        //@ terminates;\n    {\n        OS.beep();\n        //@ call_perm_rec_weaken(2, n - 1);\n        //@ call_perm_rec_elim(1);\n        //@ consume_call_perm_for(Beeper.class);\n        beepForever();\n    }\n\n}\n\nclass Main {\n\n    static void main()\n        //@ requires IO(?n);\n        //@ ensures false;\n        //@ terminates;\n    {\n        //@ produce_call_below_perm_();\n        //@ is_wf_int_lt();\n        //@ call_below_perm__elim_rec(1, {Beeper.class}, int_lt, n);\n        Beeper.beepForever();\n    }\n\n}\n",
        "name": "Beep.java",
        "path": "examples/java/termination/Beep.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/termination/Beep.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires IO(?n);"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures 0 \u003c n \u0026*\u0026 IO(n - 1);"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires IO(?n) \u0026*\u0026 call_perm_rec(currentThread, {Beeper.class}, int_lt, n);"
        },
        {
          "limitHit": false,
          "lineNumber": 18,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures false;"
        },
        {
          "limitHit": false,
          "lineNumber": 33,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires IO(?n);"
        },
        {
          "limitHit": false,
          "lineNumber": 34,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures false;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package program;\r\n\r\nimport iterator.it.*;\r\nimport iterator.itutil.*;\r\nimport iterator.singleton.*;\r\n\r\npublic class Program {\r\n\r\n    public static void main(String[] args)\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        Object o = new Object();\r\n        Iterator i = new SingletonIterator(o);\r\n        boolean before = i.hasNext();\r\n        assert before;\r\n\r\n        Object last = IteratorUtil.getLast(i);\r\n        assert last == o;\r\n      \r\n        boolean after = i.hasNext();\r\n        assert !after;\r\n    }\r\n\r\n}\r\n",
        "name": "Program.java",
        "path": "examples/java/Iterator/Program.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Iterator/Program.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package chat;\n\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic class Program {\n    public static void main(String[] args) throws IOException /*@ ensures true; @*/\n        //@ requires true;\n        //@ ensures true;\n    {\n        Room room = new Room();\n        //@ close room_ctor(room)();\n        //@ one_time(room_ctor(room));\n        Semaphore roomLock = new Semaphore(1);\n        //@ roomLock.leakHandle();\n        ServerSocket serverSocket = new ServerSocket(12345);\n\n        while (true)\n            //@ invariant [_]roomLock.Semaphore(room_ctor(room)) \u0026*\u0026 serverSocket.ServerSocket();\n        {\n            Socket socket = serverSocket.accept();\n            Session session = new Session(room, roomLock, socket);\n            //@ close session.pre();\n            Thread t = new Thread(session);\n            t.start();\n        }\n    }\n}",
        "name": "Program.java",
        "path": "examples/java/chat_raw/Program.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/chat_raw/Program.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class DivisionOverflow {\n  int division_test_fail_overflow(int nom, int denom)\n    //@ requires denom != 0;\n    //@ ensures result == nom / denom;\n  {\n    int tmp = nom / denom; //~ should_fail\n    return tmp; //~allow_dead_code\n  }\n}",
        "name": "DivisionOverflow.java",
        "path": "examples/java/DivisionOverflow.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/DivisionOverflow.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 2,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires denom != 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == nom / denom;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "/*@\n\npredicate vector(int[] X, int m; list\u003cint\u003e values) = X[..] |-\u003e values \u0026*\u0026 X.length == m;\n\npredicate vectors(int[][] XsArray, list\u003cint[]\u003e Xs, int m; list\u003clist\u003cint\u003e \u003e vss) =\n    switch (Xs) {\n        case nil: return vss == nil;\n        case cons(X, Xs0): return vector(X, m, ?vs) \u0026*\u0026 vectors(XsArray, Xs0, m, ?vss0) \u0026*\u0026 vss == cons(vs, vss0);\n    };\n\npredicate matrix(int[][] X, int n, int m; list\u003clist\u003cint\u003e \u003e rows) =\n    X[..] |-\u003e ?rowArrays \u0026*\u0026 n == X.length \u0026*\u0026\n    vectors(X, rowArrays, m, rows);\n\nfixpoint int matrix_elem(list\u003clist\u003cint\u003e \u003e rows, int i, int j) { return nth(j, nth(i, rows)); }\n\nfixpoint nat len\u003ct\u003e(list\u003ct\u003e xs) {\n    switch (xs) {\n        case nil: return zero;\n        case cons(x, xs0): return succ(len(xs0));\n    }\n}\n\nlemma_auto void len_eq_nat_of_int_length\u003ct\u003e(list\u003ct\u003e xs)\n    requires true;\n    ensures len(xs) == nat_of_int(length(xs));\n{\n    switch (xs) {\n        case nil:\n        case cons(x0, xs0):\n            len_eq_nat_of_int_length(xs0);\n    }\n}\n\nfixpoint int matrix_multiply_elem(list\u003cint\u003e Arow, int j, list\u003clist\u003cint\u003e \u003e Brows) {\n    switch (Arow) {\n        case nil: return 0;\n        case cons(vA, Arow0): return vA * nth(j, head(Brows)) + matrix_multiply_elem(Arow0, j, tail(Brows));\n    }\n}\n\nfixpoint list\u003cint\u003e matrix_multiply_row(nat fuel, list\u003cint\u003e row, int j, list\u003clist\u003cint\u003e \u003e B) {\n    switch (fuel) {\n        case zero: return nil;\n        case succ(fuel0): return cons(matrix_multiply_elem(row, j, B), matrix_multiply_row(fuel0, row, j + 1, B));\n    }\n}\n\nfixpoint list\u003clist\u003cint\u003e \u003e matrix_multiply(list\u003clist\u003cint\u003e \u003e A, list\u003clist\u003cint\u003e \u003e B) {\n    switch (A) {\n        case nil: return nil;\n        case cons(row, rows0): return cons(matrix_multiply_row(len(row), row, 0, B), matrix_multiply(rows0, B));\n    }\n}\n\n@*/\n\nclass Math {\n\n    static void matrixMultiply(int[][] A, int[][] B, int[][] C)\n    //@ requires [_]matrix(A, ?N, N, ?Arows) \u0026*\u0026 [_]matrix(B, N, N, ?Brows) \u0026*\u0026 matrix(C, N, N, _);\n    //@ ensures matrix(C, N, N, matrix_multiply(Arows, Brows));\n    {\n        //@ open matrix(A, _, _, _);\n        //@ open matrix(C, _, _, _);\n        int n = A.length;\n        //@ assert C[..] |-\u003e ?CrowArrays;\n        //@ assert [_]A[..] |-\u003e ?ArowArrays;\n        \n        for (int i = 0; ; )\n            /*@\n            requires\n                C[i..] |-\u003e drop(i, CrowArrays) \u0026*\u0026 vectors(C, drop(i, CrowArrays), N, _) \u0026*\u0026 [_]matrix(B, N, N, Brows) \u0026*\u0026\n                [_]A[i..] |-\u003e drop(i, ArowArrays) \u0026*\u0026 [_]vectors(A, drop(i, ArowArrays), N, ?Arows1) \u0026*\u0026 length(CrowArrays) == length(ArowArrays);\n            @*/\n            //@ ensures C[old_i..] |-\u003e drop(old_i, CrowArrays) \u0026*\u0026 vectors(C, drop(old_i, CrowArrays), N, matrix_multiply(Arows1, Brows));\n        {\n            if (i \u003e= n) {\n                //@ open vectors(C, nil, N, _);\n                //@ open vectors(A, nil, N, _);\n                break;\n            }\n            //@ drop_n_plus_one(i, CrowArrays);\n            //@ drop_n_plus_one(i, ArowArrays);\n            int[] ArowArray = A[i];\n            int[] CrowArray = C[i];\n            //@ open [_]vectors(A, drop(i, ArowArrays), _, _);\n            //@ assert [_]vectors(A, drop(i + 1, ArowArrays), N, tail(Arows1));\n            //@ assert [_]ArowArray[..] |-\u003e ?Arow;\n            //@ open vectors(C, drop(i, CrowArrays), _, _);\n            //@ assert CrowArray[..] |-\u003e ?Crow;\n            //@ assert len(Arow) == len(Crow);\n            for (int j = 0; ; )\n                //@ requires [_]ArowArray[..] |-\u003e Arow \u0026*\u0026 [_]matrix(B, N, N, Brows) \u0026*\u0026 CrowArray[j..] |-\u003e ?xs \u0026*\u0026 0 \u003c= j;\n                //@ ensures CrowArray[old_j..] |-\u003e matrix_multiply_row(len(xs), Arow, old_j, Brows);\n            {\n                //@ switch (xs) { case nil: case cons(h, t): }\n                if (j \u003e= n) {\n                    break;\n                }\n                CrowArray[j] = 0;\n                //@ open [_]matrix(B, _, _, _);\n                //@ assert [_]B[..] |-\u003e ?BrowArrays;\n                for (int k = 0; k \u003c n; k++)\n                    //@ requires CrowArray[j] |-\u003e ?x \u0026*\u0026 [_]ArowArray[k..] |-\u003e drop(k, Arow) \u0026*\u0026 [_]B[k..] |-\u003e drop(k, BrowArrays) \u0026*\u0026 [_]vectors(B, drop(k, BrowArrays), N, ?Brows1) \u0026*\u0026 0 \u003c= k;\n                    //@ ensures CrowArray[j] |-\u003e x + matrix_multiply_elem(drop(old_k, Arow), j, Brows1);\n                {\n                    //@ drop_n_plus_one(k, Arow);\n                    //@ drop_n_plus_one(k, BrowArrays);\n                    //@ open [_]vectors(B, drop(k, BrowArrays), _, _);\n                    int[] BrowArray = B[k];\n                    //@ open [_]vector(BrowArray, _, _);\n                    //@ assert [_]BrowArray[..] |-\u003e ?Brow \u0026*\u0026 BrowArray.length == N;\n                    CrowArray[j] += ArowArray[k] * BrowArray[j];\n                }\n                //@ assert CrowArray[j] |-\u003e matrix_multiply_elem(Arow, j, Brows);\n                j++;\n                //@ recursive_call();\n                \n            }\n            i++;\n            //@ recursive_call();\n            \n            //@ assert [_]vectors(A, drop(old_i + 1, ArowArrays), N, tail(Arows1));\n            //@ assert vectors(C, drop(old_i + 1, CrowArrays), N, matrix_multiply(tail(Arows1), Brows));\n            //@ assert CrowArray[..] |-\u003e matrix_multiply_row(len(head(Arows1)), head(Arows1), 0, Brows);\n            //@ close vectors(C, drop(old_i, CrowArrays), N, matrix_multiply(Arows1, Brows));\n            \n        }\n        //@ close matrix(C, N, N, _);\n    }\n}",
        "name": "matmul.java",
        "path": "examples/verifythis2016/matmul.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/verifythis2016/matmul.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 60,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires [_]matrix(A, ?N, N, ?Arows) \u0026*\u0026 [_]matrix(B, N, N, ?Brows) \u0026*\u0026 matrix(C, N, N, _);"
        },
        {
          "limitHit": false,
          "lineNumber": 61,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures matrix(C, N, N, matrix_multiply(Arows, Brows));"
        },
        {
          "limitHit": false,
          "lineNumber": 75,
          "offsetAndLengths": [
            [
              12,
              12
            ]
          ],
          "preview": "            //@ ensures C[old_i..] |-\u003e drop(old_i, CrowArrays) \u0026*\u0026 vectors(C, drop(old_i, CrowArrays), N, matrix_multiply(Arows1, Brows));"
        },
        {
          "limitHit": false,
          "lineNumber": 93,
          "offsetAndLengths": [
            [
              16,
              13
            ]
          ],
          "preview": "                //@ requires [_]ArowArray[..] |-\u003e Arow \u0026*\u0026 [_]matrix(B, N, N, Brows) \u0026*\u0026 CrowArray[j..] |-\u003e ?xs \u0026*\u0026 0 \u003c= j;"
        },
        {
          "limitHit": false,
          "lineNumber": 94,
          "offsetAndLengths": [
            [
              16,
              12
            ]
          ],
          "preview": "                //@ ensures CrowArray[old_j..] |-\u003e matrix_multiply_row(len(xs), Arow, old_j, Brows);"
        },
        {
          "limitHit": false,
          "lineNumber": 104,
          "offsetAndLengths": [
            [
              20,
              13
            ]
          ],
          "preview": "                    //@ requires CrowArray[j] |-\u003e ?x \u0026*\u0026 [_]ArowArray[k..] |-\u003e drop(k, Arow) \u0026*\u0026 [_]B[k..] |-\u003e drop(k, BrowArrays) \u0026*\u0026 [_]vectors(B, drop(k, BrowArrays), N, ?Brows1) \u0026*\u0026 0 \u003c= k;"
        },
        {
          "limitHit": false,
          "lineNumber": 105,
          "offsetAndLengths": [
            [
              20,
              12
            ]
          ],
          "preview": "                    //@ ensures CrowArray[j] |-\u003e x + matrix_multiply_elem(drop(old_k, Arow), j, Brows1);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Node {\n\n    Object value;\n    Node next;\n\n    Node(Object value, Node next)\n        //@ requires true;\n        //@ ensures this.value |-\u003e value \u0026*\u0026 [_]this.next |-\u003e next;\n        //@ terminates;\n    {\n        this.value = value;\n        this.next = next;\n        //@ leak this.next |-\u003e _;\n    }\n\n}\n\nclass StackHelper {\n\n    static void pushIter(Stack stack, Object value)\n        //@ requires [_]stack.valid(call_perm_scope_of(currentThread)) \u0026*\u0026 call_perms_omega(currentThread, {StackHelper.class});\n        //@ ensures true;\n        //@ terminates;\n    {\n        //@ int scope = call_perm_scope_of(currentThread);\n        Node head;\n        {\n            /*@\n            predicate pre() = true;\n            predicate post(Object result) = [_]stack.readers |-\u003e ?readers \u0026*\u0026 GhostBagHandle(readers, result);\n            lemma void get()\n                requires Stack_spaceInv(scope, stack)(?o) \u0026*\u0026 pre();\n                ensures Stack_spaceInv(scope, stack)(o) \u0026*\u0026 post(o);\n            {\n                open Stack_spaceInv(scope, stack)(o);\n                open pre();\n                \n                GhostBag_add(stack.readers, o);\n                \n                close Stack_spaceInv(scope, stack)(o);\n                close post(o);\n            }\n            @*/\n            //@ produce_lemma_function_pointer_chunk(get) : AtomicReference_get(Stack_spaceInv(scope, stack), pre, post)() { call(); };\n            //@ close pre();\n            head = (Node)stack.head.get();\n            //@ open post(head);\n        }\n        Node n = new Node(value, head);\n        boolean casResult;\n        //@ int pushThread = currentThread;\n        {\n            /*@\n            predicate pre() = [_]stack.readers |-\u003e ?readers \u0026*\u0026 GhostBagHandle(readers, head) \u0026*\u0026 call_perms_omega(pushThread, {StackHelper.class}) \u0026*\u0026 n.value |-\u003e value \u0026*\u0026 [_]n.next |-\u003e head;\n            predicate post(boolean result) = result ? true : call_perm(pushThread, {StackHelper.class}) \u0026*\u0026 call_perms_omega(pushThread, {StackHelper.class});\n            lemma void compareAndSet()\n                requires Stack_spaceInv(scope, stack)(?o) \u0026*\u0026 pre();\n                ensures Stack_spaceInv(scope, stack)(o != head ? o : n) \u0026*\u0026 post(o == head);\n            {\n                open Stack_spaceInv(scope, stack)(o);\n                open pre();\n                \n                assert GhostBag(_, ?oldRs);\n                GhostBag_remove(stack.readers, head);\n                assert GhostBag(_, ?newRs);\n                \n                if (o == head) {\n                    open call_perms_omega(_, _);\n                    call_perm_rec_weaken(1, pair(0, count_neq\u003cObject\u003e(n, newRs)));\n                    close call_perms(pushThread, count_neq\u003cObject\u003e(n, newRs), {StackHelper.class});\n                    close nodes(n);\n                } else {\n                    count_neq_remove(o, head, oldRs);\n                    count_neq_nonnegative(o, newRs);\n                    assert count_neq(o, newRs) == count_neq(o, oldRs) - 1;\n                    open call_perms(?thread, count_neq(o, oldRs), {StackHelper.class});\n                    call_perm_rec_weaken(2, pair(0, count_neq(o, newRs)));\n                    close call_perms(thread, count_neq(o, newRs), {StackHelper.class});\n                    call_perm_rec_elim(1);\n                    call_perm_transfer(pushThread);\n                }\n                \n                close post(o == head);\n                close Stack_spaceInv(scope, stack)(o != head ? o : n);\n            }\n            @*/\n            //@ close pre();\n            //@ produce_lemma_function_pointer_chunk(compareAndSet) : AtomicReference_compareAndSet(head, n, Stack_spaceInv(scope, stack), pre, post)() { call(); };\n            casResult = stack.head.compareAndSet(head, n);\n            //@ open post(casResult);\n        }\n        if (!casResult) {\n            //@ consume_call_perm_for(StackHelper.class);\n            pushIter(stack, value);\n        }\n    }\n\n    static Object popIter(Stack stack)\n        //@ requires [_]stack.valid(call_perm_scope_of(currentThread)) \u0026*\u0026 call_perms_omega(currentThread, {StackHelper.class});\n        //@ ensures true;\n        //@ terminates;\n    {\n        //@ int scope = call_perm_scope_of(currentThread);\n        Node head;\n        {\n            /*@\n            predicate pre() = true;\n            predicate post(Object result) = [_]stack.readers |-\u003e ?readers \u0026*\u0026 GhostBagHandle(readers, result) \u0026*\u0026 result == null ? true : [_]Node_next(^result, _);\n            lemma void get()\n                requires Stack_spaceInv(scope, stack)(?o) \u0026*\u0026 pre();\n                ensures Stack_spaceInv(scope, stack)(o) \u0026*\u0026 post(o);\n            {\n                open Stack_spaceInv(scope, stack)(o);\n                open pre();\n                \n                GhostBag_add(stack.readers, o);\n                assert nodes(?h);\n                open nodes(h);\n                close nodes(h);\n                \n                close Stack_spaceInv(scope, stack)(o);\n                close post(o);\n            }\n            @*/\n            //@ produce_lemma_function_pointer_chunk(get) : AtomicReference_get(Stack_spaceInv(scope, stack), pre, post)() { call(); };\n            //@ close pre();\n            head = (Node)stack.head.get();\n            //@ open post(head);\n        }\n        if (head == null)\n            return null;\n        Node next = head.next;\n        boolean casResult;\n        //@ int popThread = currentThread;\n        {\n            /*@\n            predicate pre() = [_]stack.readers |-\u003e ?readers \u0026*\u0026 GhostBagHandle(readers, head) \u0026*\u0026 call_perms_omega(popThread, {StackHelper.class}) \u0026*\u0026 [_]head.next |-\u003e next;\n            predicate post(boolean result) = result ? head.value |-\u003e _ : call_perm(popThread, {StackHelper.class}) \u0026*\u0026 call_perms_omega(popThread, {StackHelper.class});\n            lemma void compareAndSet()\n                requires Stack_spaceInv(scope, stack)(?o) \u0026*\u0026 pre();\n                ensures Stack_spaceInv(scope, stack)(o != head ? o : next) \u0026*\u0026 post(o == head);\n            {\n                open Stack_spaceInv(scope, stack)(o);\n                open pre();\n                \n                assert GhostBag(_, ?oldRs);\n                GhostBag_remove(stack.readers, head);\n                assert GhostBag(_, ?newRs);\n                \n                if (o == head) {\n                    open call_perms_omega(_, _);\n                    call_perm_rec_weaken(1, pair(0, count_neq\u003cObject\u003e(next, newRs)));\n                    close call_perms(popThread, count_neq\u003cObject\u003e(next, newRs), {StackHelper.class});\n                    open nodes(head);\n                } else {\n                    count_neq_remove(o, head, oldRs);\n                    count_neq_nonnegative(o, newRs);\n                    assert count_neq(o, newRs) == count_neq(o, oldRs) - 1;\n                    open call_perms(?thread, count_neq(o, oldRs), {StackHelper.class});\n                    call_perm_rec_weaken(2, pair(0, count_neq(o, newRs)));\n                    close call_perms(thread, count_neq(o, newRs), {StackHelper.class});\n                    call_perm_rec_elim(1);\n                    call_perm_transfer(popThread);\n                }\n                \n                close post(o == head);\n                close Stack_spaceInv(scope, stack)(o != head ? o : next);\n            }\n            @*/\n            //@ close pre();\n            //@ produce_lemma_function_pointer_chunk(compareAndSet) : AtomicReference_compareAndSet(head, next, Stack_spaceInv(scope, stack), pre, post)() { call(); };\n            casResult = stack.head.compareAndSet(head, head.next);\n            //@ open post(casResult);\n        }\n        if (!casResult) {\n            //@ consume_call_perm_for(StackHelper.class);\n            return popIter(stack);\n        }\n        return head.value;\n    }\n\n}\n\n/*@\n\npredicate nodes(Node n;) =\n    n == null ?\n        true\n    :\n        n.value |-\u003e _ \u0026*\u0026 [_]n.next |-\u003e ?next \u0026*\u0026 nodes(next);\n\nfixpoint int count_neq\u003ct\u003e(t x, list\u003ct\u003e xs) {\n    switch (xs) {\n        case nil: return 0;\n        case cons(x0, xs0): return (x0 != x ? 1 : 0) + count_neq(x, xs0);\n    }\n}\n\nlemma_auto void count_neq_nonnegative\u003ct\u003e(t x, list\u003ct\u003e xs)\n    requires true;\n    ensures 0 \u003c= count_neq(x, xs);\n{\n    switch (xs) {\n        case nil:\n        case cons(x0, xs0):\n            if (x0 == x) {} else {}\n            count_neq_nonnegative(x, xs0);\n    }\n}\n\nlemma void count_neq_remove\u003ct\u003e(t y, t x, list\u003ct\u003e xs)\n    requires mem(x, xs) == true \u0026*\u0026 y != x;\n    ensures count_neq(y, remove(x, xs)) + 1 == count_neq(y, xs);\n{\n    switch (xs) {\n        case nil:\n        case cons(x0, xs0):\n            if (x0 == x) {} else {\n                count_neq_remove(y, x, xs0);\n            }\n    }\n}\n\npredicate call_perms(int thread, int count, list\u003cClass\u003e level) = call_perm_rec(thread, level, (pair_lt)(int_lt, int_lt), pair(0, count));\npredicate call_perms_omega(int thread, list\u003cClass\u003e level) = call_perm_rec(thread, level, (pair_lt)(int_lt, int_lt), pair(1, 0));\n\npredicate_ctor Stack_spaceInv(int scope, Stack stack)(Object value) =\n    nodes(^value) \u0026*\u0026 [_]stack.readers |-\u003e ?readers \u0026*\u0026 GhostBag(readers, ?rs) \u0026*\u0026\n    call_perms(?thread, count_neq(value, rs), {StackHelper.class}) \u0026*\u0026 call_perm_scope_of(thread) == scope;\n\n@*/\n\nfinal class Stack {\n\n    //@ int callPermScope;\n    AtomicReference head;\n    //@ int readers;\n    \n    //@ predicate valid(int callPermScope) = this.callPermScope |-\u003e callPermScope \u0026*\u0026 head |-\u003e ?head \u0026*\u0026 [_]head.valid(Stack_spaceInv(callPermScope, this));\n\n    Stack()\n        //@ requires true;\n        //@ ensures [_]valid(call_perm_scope_of(currentThread));\n        //@ terminates;\n    {\n        //@ callPermScope = call_perm_scope_of(currentThread);\n        //@ readers = GhostBag_create();\n        //@ close nodes(null);\n        //@ produce_call_below_perm_();\n        //@ is_wf_int_lt();\n        //@ is_wf_pair_lt(int_lt, int_lt);\n        //@ call_below_perm__elim_rec(1, {StackHelper.class}, (pair_lt)(int_lt, int_lt), pair(0, 0));\n        //@ close call_perms(currentThread, 0, {StackHelper.class});\n        //@ close Stack_spaceInv(call_perm_scope_of(currentThread), this)(null);\n        //@ close exists(Stack_spaceInv(call_perm_scope_of(currentThread), this));\n        head = new AtomicReference(null);\n    }\n\n    void push(Object value)\n        //@ requires [_]valid(call_perm_scope_of(currentThread));\n        //@ ensures true;\n        //@ terminates;\n    {\n        //@ produce_call_below_perm_();\n        //@ is_wf_int_lt();\n        //@ is_wf_pair_lt(int_lt, int_lt);\n        //@ call_below_perm__elim_rec(1, {StackHelper.class}, (pair_lt)(int_lt, int_lt), pair(1, 0));\n        //@ close call_perms_omega(currentThread, {StackHelper.class});\n        StackHelper.pushIter(this, value);\n    }\n\n    Object pop()\n        //@ requires [_]valid(call_perm_scope_of(currentThread));\n        //@ ensures true;\n        //@ terminates;\n    {\n        //@ produce_call_below_perm_();\n        //@ is_wf_int_lt();\n        //@ is_wf_pair_lt(int_lt, int_lt);\n        //@ call_below_perm__elim_rec(1, {StackHelper.class}, (pair_lt)(int_lt, int_lt), pair(1, 0));\n        //@ close call_perms_omega(currentThread, {StackHelper.class});\n        return StackHelper.popIter(this);\n    }\n\n}\n\nfinal class Pusher implements JoinableForkee {\n\n    static void push(Stack stack)\n        //@ requires [_]stack.valid(call_perm_scope_of(currentThread));\n        //@ ensures true;\n        //@ terminates;\n    {\n        for (int i = 0; i \u003c 10; i++)\n            //@ invariant [_]stack.valid(call_perm_scope_of(currentThread));\n            //@ decreases 10 - i;\n        {\n            stack.push((Object)Integer.valueOf(i));\n        }\n    }\n\n    //@ int callPermScope;\n    Stack stack;\n    \n    //@ predicate pre(int callPermScope, pair\u003clist\u003cClass\u003e, real\u003e waitLevel, list\u003cObject\u003e O) = this.callPermScope |-\u003e callPermScope \u0026*\u0026 O == nil \u0026*\u0026 waitLevel == pair({Pusher.class}, 0r) \u0026*\u0026 stack |-\u003e ?stack \u0026*\u0026 [_]stack.valid(callPermScope);\n    //@ predicate post() = true;\n    \n    Pusher(Stack stack)\n        //@ requires true;\n        //@ ensures this.callPermScope |-\u003e call_perm_scope_of(currentThread) \u0026*\u0026 this.stack |-\u003e stack;\n        //@ terminates;\n    {\n        //@ this.callPermScope = call_perm_scope_of(currentThread);\n        this.stack = stack;\n    }\n    \n    void run()\n        //@ requires obs(cons(?thisThread, ?O)) \u0026*\u0026 pre(call_perm_scope_of(currentThread), wait_level_of(thisThread), O);\n        //@ ensures obs({thisThread}) \u0026*\u0026 post();\n        //@ terminates;\n    {\n        push(stack);\n        //@ close post();\n    }\n    \n}\n\nfinal class Popper implements JoinableForkee {\n\n    static void pop(Stack stack)\n        //@ requires [_]stack.valid(call_perm_scope_of(currentThread));\n        //@ ensures true;\n        //@ terminates;\n    {\n        for (int i = 0; i \u003c 10; i++)\n            //@ invariant [_]stack.valid(call_perm_scope_of(currentThread));\n            //@ decreases 10 - i;\n        {\n            stack.pop();\n        }\n    }\n    \n    //@ int callPermScope;\n    Stack stack;\n    \n    //@ predicate pre(int callPermScope, pair\u003clist\u003cClass\u003e, real\u003e waitLevel, list\u003cObject\u003e O) = this.callPermScope |-\u003e callPermScope \u0026*\u0026 O == nil \u0026*\u0026 waitLevel == pair({Popper.class}, 0r) \u0026*\u0026 stack |-\u003e ?stack \u0026*\u0026 [_]stack.valid(callPermScope);\n    //@ predicate post() = true;\n    \n    Popper(Stack stack)\n        //@ requires true;\n        //@ ensures this.callPermScope |-\u003e call_perm_scope_of(currentThread) \u0026*\u0026 this.stack |-\u003e stack;\n        //@ terminates;\n    {\n        //@ this.callPermScope = call_perm_scope_of(currentThread);\n        this.stack = stack;\n    }\n    \n    void run()\n        //@ requires obs(cons(?thisThread, ?O)) \u0026*\u0026 pre(call_perm_scope_of(currentThread), wait_level_of(thisThread), O);\n        //@ ensures obs({thisThread}) \u0026*\u0026 post();\n        //@ terminates;\n    {\n        pop(stack);\n        //@ close post();\n    }\n    \n}\n\nclass Main {\n\n    static void main()\n        //@ requires obs(nil); // For clarity, unlike examples SqrtCached and ThreadPool, this example does not apply the modular obligations specification approach.\n        //@ ensures obs(nil);\n        //@ terminates;\n    {\n        Stack stack = new Stack();\n        \n        //@ produce_call_below_perm_();\n        //@ call_below_perm__elim(2, {Pusher.class, Popper.class});\n        \n        //@ close exists(nil);\n        //@ call_perm_weaken(1, {Pusher.class});\n        Thread pusherThread = ThreadUtil.forkJoinable(new Pusher(stack));\n        Pusher.push(stack);\n        pusherThread.join();\n        \n        //@ close exists(nil);\n        //@ call_perm_weaken(1, {Popper.class});\n        Thread popperThread = ThreadUtil.forkJoinable(new Popper(stack));\n        Popper.pop(stack);\n        popperThread.join();\n    }\n    \n}",
        "name": "Stack.java",
        "path": "examples/java/termination/Stack.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/termination/Stack.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures this.value |-\u003e value \u0026*\u0026 [_]this.next |-\u003e next;"
        },
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]stack.valid(call_perm_scope_of(currentThread)) \u0026*\u0026 call_perms_omega(currentThread, {StackHelper.class});"
        },
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 98,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]stack.valid(call_perm_scope_of(currentThread)) \u0026*\u0026 call_perms_omega(currentThread, {StackHelper.class});"
        },
        {
          "limitHit": false,
          "lineNumber": 99,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 241,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 242,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [_]valid(call_perm_scope_of(currentThread));"
        },
        {
          "limitHit": false,
          "lineNumber": 259,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(call_perm_scope_of(currentThread));"
        },
        {
          "limitHit": false,
          "lineNumber": 260,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 272,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(call_perm_scope_of(currentThread));"
        },
        {
          "limitHit": false,
          "lineNumber": 273,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 289,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]stack.valid(call_perm_scope_of(currentThread));"
        },
        {
          "limitHit": false,
          "lineNumber": 290,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 308,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 309,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures this.callPermScope |-\u003e call_perm_scope_of(currentThread) \u0026*\u0026 this.stack |-\u003e stack;"
        },
        {
          "limitHit": false,
          "lineNumber": 317,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obs(cons(?thisThread, ?O)) \u0026*\u0026 pre(call_perm_scope_of(currentThread), wait_level_of(thisThread), O);"
        },
        {
          "limitHit": false,
          "lineNumber": 318,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs({thisThread}) \u0026*\u0026 post();"
        },
        {
          "limitHit": false,
          "lineNumber": 330,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]stack.valid(call_perm_scope_of(currentThread));"
        },
        {
          "limitHit": false,
          "lineNumber": 331,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 349,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 350,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures this.callPermScope |-\u003e call_perm_scope_of(currentThread) \u0026*\u0026 this.stack |-\u003e stack;"
        },
        {
          "limitHit": false,
          "lineNumber": 358,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obs(cons(?thisThread, ?O)) \u0026*\u0026 pre(call_perm_scope_of(currentThread), wait_level_of(thisThread), O);"
        },
        {
          "limitHit": false,
          "lineNumber": 359,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs({thisThread}) \u0026*\u0026 post();"
        },
        {
          "limitHit": false,
          "lineNumber": 371,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obs(nil); // For clarity, unlike examples SqrtCached and ThreadPool, this example does not apply the modular obligations specification approach."
        },
        {
          "limitHit": false,
          "lineNumber": 372,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs(nil);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class C {\r\n  static int id(int x)\r\n    //@ requires true;\r\n    //@ ensures result == x;\r\n  {\r\n    return x;\r\n  }\r\n}\r\n\r\nclass A {\r\n  int a = 1, b = 2;\r\n  \r\n  A() \r\n   //@ requires true;\r\n   //@ ensures this.a |-\u003e 1 \u0026*\u0026 this.b |-\u003e  2;\r\n  {\r\n   \r\n  }\r\n  \r\n  int getA() \r\n    //@ requires this.a |-\u003e ?v;\r\n    //@ ensures this.a |-\u003e v \u0026*\u0026 result == v;\r\n  {\r\n    return this.a;\r\n  }\r\n}\r\n\r\nclass B extends A {\r\n\r\n  int c = getA(), d = this.c + C.id(10);\r\n  \r\n  B() \r\n    //@ requires true;\r\n    //@ ensures this.a |-\u003e 1 \u0026*\u0026 this.b |-\u003e 2 \u0026*\u0026 this.c |-\u003e 1 \u0026*\u0026 this.d |-\u003e 11;\r\n  {\r\n    super();\r\n  }\r\n  \r\n}\r\n",
        "name": "FieldInitializers.java",
        "path": "examples/java/FieldInitializers.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/FieldInitializers.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 2,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == x;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              3,
              13
            ]
          ],
          "preview": "   //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              3,
              12
            ]
          ],
          "preview": "   //@ ensures this.a |-\u003e 1 \u0026*\u0026 this.b |-\u003e  2;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires this.a |-\u003e ?v;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures this.a |-\u003e v \u0026*\u0026 result == v;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 32,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 33,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures this.a |-\u003e 1 \u0026*\u0026 this.b |-\u003e 2 \u0026*\u0026 this.c |-\u003e 1 \u0026*\u0026 this.d |-\u003e 11;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package iterator.it;\r\n\r\npublic interface Iterator {\r\n\r\n    //@ predicate valid(list\u003cObject\u003e elements);\r\n    \r\n    boolean hasNext();\r\n        //@ requires valid(?xs);\r\n        //@ ensures valid(xs) \u0026*\u0026 result == (xs != nil);\r\n        \r\n    Object next();\r\n        //@ requires valid(?xs) \u0026*\u0026 xs!=nil;\r\n        //@ ensures valid(tail(xs)) \u0026*\u0026 result == head(xs) \u0026*\u0026 result != null;\r\n\r\n}\r\n",
        "name": "Iterator.java",
        "path": "examples/java/Iterator/Iterator.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Iterator/Iterator.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?xs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(xs) \u0026*\u0026 result == (xs != nil);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?xs) \u0026*\u0026 xs!=nil;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(tail(xs)) \u0026*\u0026 result == head(xs) \u0026*\u0026 result != null;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Counter {\n    int n;\n    Lock lock;\n\n    Counter()\n        //@ requires exists\u003creal\u003e(?w);\n        //@ ensures Counter(this, pair(nil, w));\n        //@ terminates;\n    {\n        //@ close Counter_inv(this)();\n        //@ close exists\u003cpredicate()\u003e(Counter_inv(this));\n        //@ close exists\u003cpair\u003clist\u003cClass\u003e, real\u003e \u003e(pair(nil, w));\n        lock = new Lock();\n    }\n}\n\n/*@\n\npredicate_ctor Counter_inv(Counter c)(;) = c.n |-\u003e _;\n\npredicate Counter(Counter c; pair\u003clist\u003cClass\u003e, real\u003e waitLevel) =\n    c.lock |-\u003e ?lock \u0026*\u0026 lock.lock(Counter_inv(c)) \u0026*\u0026 waitLevel == wait_level_of(lock);\n\n@*/\n\nclass Philosopher implements JoinableForkee {\n    //@ int callPermScope;\n    final Counter first, second;\n\n    /*@\n    predicate pre(int callPermScope, pair\u003clist\u003cClass\u003e, real\u003e waitLevel, list\u003cObject\u003e O) =\n        [_]this.callPermScope |-\u003e callPermScope \u0026*\u0026\n        waitLevel == pair(nil, 4r) \u0026*\u0026\n        [_]first |-\u003e ?first \u0026*\u0026 [1/2]Counter(first, ?wFirst) \u0026*\u0026\n        [_]second |-\u003e ?second \u0026*\u0026 [1/2]Counter(second, ?wSecond) \u0026*\u0026\n        O == nil \u0026*\u0026\n        wait_level_lt(wFirst, waitLevel) \u0026\u0026 wait_level_lt(wSecond, wFirst);\n    \n    predicate post() =\n        [_]first |-\u003e ?first \u0026*\u0026 [1/2]Counter(first, ?wFirst) \u0026*\u0026\n        [_]second |-\u003e ?second \u0026*\u0026 [1/2]Counter(second, ?wSecond);\n    @*/\n    \n    Philosopher(Counter first, Counter second)\n        //@ requires true;\n        //@ ensures [_]this.callPermScope |-\u003e call_perm_scope_of(currentThread) \u0026*\u0026 [_]this.first |-\u003e first \u0026*\u0026 [_]this.second |-\u003e second;\n        //@ terminates;\n    {\n        //@ this.callPermScope = call_perm_scope_of(currentThread);\n        this.first = first;\n        this.second = second;\n    }\n    \n    void run()\n        //@ requires obs(cons(?thisThread, ?O)) \u0026*\u0026 pre(call_perm_scope_of(currentThread), wait_level_of(thisThread), O);\n        //@ ensures obs({thisThread}) \u0026*\u0026 post();\n        //@ terminates;\n    {\n        first.lock.acquire();\n        //@ Lock firstLock = first.lock;\n        //@ open Counter_inv(first)();\n        first.n++;\n        //@ wait_level_lt_trans(wait_level_of(second.lock), wait_level_of(first.lock), wait_level_of(thisThread));\n        second.lock.acquire();\n        //@ open Counter_inv(second)();\n        second.n++;\n        //@ close Counter_inv(second)();\n        second.lock.release();\n        //@ close Counter_inv(first)();\n        first.lock.release();\n    }\n}\n\nclass Dining {\n    static void main()\n        //@ requires obs(nil);\n        //@ ensures obs(nil);\n        //@ terminates;\n    {\n        //@ produce_call_below_perm_();\n        //@ call_below_perm__elim(3, {Philosopher.class});\n        \n        //@ close exists(1r);\n        Counter c1 = new Counter();\n        //@ close exists(2r);\n        Counter c2 = new Counter();\n        //@ close exists(3r);\n        Counter c3 = new Counter();\n\n        //@ close exists(nil);\n        Philosopher philo1 = new Philosopher(c2, c1);\n        Thread thread1 = ThreadUtil.forkJoinable(philo1);\n        //@ close exists(nil);\n        Philosopher philo2 = new Philosopher(c3, c2);\n        Thread thread2 = ThreadUtil.forkJoinable(philo2);\n        //@ close exists(nil);\n        Philosopher philo3 = new Philosopher(c3, c1);\n        Thread thread3 = ThreadUtil.forkJoinable(philo3);\n\n        thread1.join();\n        thread2.join();\n        thread3.join();\n        \n        //@ open philo1.post();\n        //@ open philo2.post();\n        //@ open philo3.post();\n        \n        //@ c1.lock.destroy();\n        //@ c2.lock.destroy();\n        //@ c3.lock.destroy();\n        int total = c1.n + c2.n + c3.n;\n    }\n}\n",
        "name": "Dining.java",
        "path": "examples/java/termination/Dining.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/termination/Dining.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires exists\u003creal\u003e(?w);"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Counter(this, pair(nil, w));"
        },
        {
          "limitHit": false,
          "lineNumber": 44,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 45,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [_]this.callPermScope |-\u003e call_perm_scope_of(currentThread) \u0026*\u0026 [_]this.first |-\u003e first \u0026*\u0026 [_]this.second |-\u003e second;"
        },
        {
          "limitHit": false,
          "lineNumber": 54,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obs(cons(?thisThread, ?O)) \u0026*\u0026 pre(call_perm_scope_of(currentThread), wait_level_of(thisThread), O);"
        },
        {
          "limitHit": false,
          "lineNumber": 55,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs({thisThread}) \u0026*\u0026 post();"
        },
        {
          "limitHit": false,
          "lineNumber": 75,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obs(nil);"
        },
        {
          "limitHit": false,
          "lineNumber": 76,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs(nil);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import javacard.framework.*;\r\n\r\n/*@\r\n\r\npredicate length_value_record(list\u003cbyte\u003e values, int start; int end) =\r\n    start \u003c length(values) \u0026*\u0026\r\n    0 \u003c= nth(start, values) \u0026*\u0026\r\n    start + 1 + nth(start, values) \u003c= length(values) \u0026*\u0026\r\n    end == start + 1 + nth(start, values);\r\n\r\npredicate element(list\u003cbyte\u003e values, int offset; byte value) =\r\n    offset \u003c length(values) \u0026*\u0026\r\n    value == nth(offset, values);\r\n\r\n@*/\r\n\r\npublic final class MyApplet extends Applet {\r\n    static byte someByteArray[];\r\n    \r\n    /*@\r\n    \r\n    predicate valid() =\r\n        someByteArray |-\u003e ?array \u0026*\u0026\r\n        array_slice(array, 0, array.length, _) \u0026*\u0026 20 \u003c= array.length;\r\n    \r\n    @*/\r\n    \r\n    // Example init data:\r\n    // 5,1,2,3,4,5,  // AID\r\n    // 0,  // info\r\n    // 1,20 // applet data\r\n    public static void install(byte[] array, short offset, byte length)\r\n        /*@\r\n        requires\r\n            class_init_token(MyApplet.class) \u0026*\u0026\r\n            array_slice(array, offset, offset + length, ?values) \u0026*\u0026\r\n            length_value_record(values, 0, ?oInfo) \u0026*\u0026\r\n            length_value_record(values, oInfo, ?oAppData) \u0026*\u0026\r\n            element(values, oAppData, _) \u0026*\u0026\r\n            element(values, oAppData + 1, ?bufferSize) \u0026*\u0026\r\n            20 \u003c= bufferSize \u0026*\u0026\r\n            offset + length \u003c= 32767 \u0026*\u0026\r\n            system();\r\n        @*/\r\n        //@ ensures true;\r\n    {\r\n        //@ init_class(MyApplet.class);\r\n        \r\n        // make all my allocations here, so I do not run\r\n        // out of memory later\r\n        MyApplet theApplet = new MyApplet();\r\n        \r\n        // check incoming parameter data\r\n        //@ open length_value_record(values, 0, oInfo);\r\n        byte iLen = array[offset]; // aid length\r\n        offset = (short)(offset + iLen + 1);\r\n        //@ open length_value_record(values, oInfo, oAppData);\r\n        byte cLen = array[offset]; // info length\r\n        offset = (short)(offset + cLen + 1);\r\n        //@ open element(values, oAppData, _);\r\n        byte aLen = array[offset]; // applet data length\r\n        //@ open element(values, oAppData + 1, _);\r\n        // read first applet data byte\r\n        byte bLen = array[(short)(offset + 1)];\r\n        //@ assert 20 \u003c= bLen;\r\n        if (bLen != 0) {\r\n            someByteArray = new byte[bLen];\r\n            //@ close theApplet.valid();\r\n            theApplet.register();\r\n            return;\r\n        } else\r\n            ISOException.throwIt(ISO7816.SW_FUNC_NOT_SUPPORTED); //~allow_dead_code\r\n    }\r\n    \r\n    public boolean select()\r\n        //@ requires current_applet(this) \u0026*\u0026 [1/2]this.valid();\r\n        //@ ensures current_applet(this) \u0026*\u0026 [1/2]this.valid();\r\n    {\r\n        // selection initialization\r\n        JCSystem.beginTransaction();\r\n        //@ open valid();\r\n        someByteArray[17] = 42; // set selection state\r\n        //@ close valid();\r\n        JCSystem.commitTransaction();\r\n        return true;\r\n    }\r\n    \r\n    public void process(APDU apdu)\r\n        //@ requires current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, ?buffer0) \u0026*\u0026 array_slice(buffer0, 0, buffer0.length, _);\r\n        //@ ensures current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, buffer0) \u0026*\u0026 array_slice(buffer0, 0, buffer0.length, _);\r\n    {\r\n        byte[] buffer = apdu.getBuffer();\r\n        // .. process the incoming data and reply\r\n        if (buffer[ISO7816.OFFSET_CLA] == (byte)0) {\r\n            switch (buffer[ISO7816.OFFSET_INS]) {\r\n                case ISO7816.INS_SELECT:\r\n                    // ...\r\n                    // send response data to select command\r\n                    short length = apdu.setOutgoing();\r\n                    byte[] replyData = new byte[10];\r\n                    // assume data containing response bytes in replyData[] array.\r\n                    if (length \u003c 20) ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n                    apdu.setOutgoingLength((short)replyData.length);\r\n                    apdu.sendBytesLong(replyData, (short)0, (short)replyData.length);\r\n                    break;\r\n                //case ...\r\n            }\r\n        }\r\n    }\r\n}\r\n",
        "name": "JavaCard.java",
        "path": "examples/java/Java Card/JavaCard.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/JavaCard.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 44,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 75,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires current_applet(this) \u0026*\u0026 [1/2]this.valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 76,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures current_applet(this) \u0026*\u0026 [1/2]this.valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 88,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, ?buffer0) \u0026*\u0026 array_slice(buffer0, 0, buffer0.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 89,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, buffer0) \u0026*\u0026 array_slice(buffer0, 0, buffer0.length, _);\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "interface Func {\r\n    //@ predicate valid(list\u003cClass\u003e level);\r\n    /*@\r\n    lemma void getClass_le_level();\r\n        requires [_]valid(?level);\r\n        ensures level_le({this.getClass()}, level) == true;\r\n    @*/\r\n    int apply(int x);\r\n        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\r\n        //@ ensures true;\r\n        //@ terminates;\r\n}\r\n\r\n//@ predicate Func(Func f, list\u003cClass\u003e level;) = f.valid(?level0) \u0026*\u0026 level_le(level0, level) == true;\r\n\r\nclass Util {\r\n    static int apply(Func f, int x)\r\n        //@ requires [_]Func(f, ?level) \u0026*\u0026 [2]call_perm(currentThread, level);\r\n        //@ ensures true;\r\n        //@ terminates;\r\n    {\r\n        //@ open Func(_, _);\r\n        //@ assert [_]f.valid(?level0);\r\n        //@ call_perm_weaken(2, level0);\r\n        //@ f.getClass_le_level();\r\n        //@ consume_call_perm_for(f.getClass());\r\n        return f.apply(x);\r\n    }\r\n    \r\n    static int deriv(Func f, int x)\r\n        //@ requires [_]Func(f, ?level) \u0026*\u0026 call_perm(currentThread, cons(Util.class, level));\r\n        //@ ensures true;\r\n        //@ terminates;\r\n    {\r\n        //@ call_perm_weaken_and_dup(4);\r\n        return apply(f, x + 1) - apply(f, x);\r\n    }\r\n    \r\n    static int sum(Func f1, Func f2, int x)\r\n        //@ requires [_]Func(f1, ?f1Level) \u0026*\u0026 [_]Func(f2, ?f2Level) \u0026*\u0026 call_perm(currentThread, cons(Util.class, level_max(f1Level, f2Level)));\r\n        //@ ensures true;\r\n        //@ terminates;\r\n    {\r\n        //@ call_perm_weaken_and_dup(4);\r\n        //@ call_perm_weaken(2, f1Level);\r\n        int y1 = apply(f1, x);\r\n        //@ call_perm_weaken(2, f2Level);\r\n        int y2 = apply(f2, x);\r\n        return y1 + y2;\r\n    }\r\n    \r\n    static int double_(Func f, int x)\r\n        //@ requires [_]Func(f, ?fLevel) \u0026*\u0026 call_perm(currentThread, cons(Util.class, fLevel));\r\n        //@ ensures true;\r\n        //@ terminates;\r\n    {\r\n        return sum(f, f, x);\r\n    }\r\n}\r\n\r\nfinal class ZeroFunc implements Func {\r\n    //@ predicate valid(list\u003cClass\u003e level) = level == {ZeroFunc.class};\r\n    /*@\r\n    lemma void getClass_le_level()\r\n        requires [_]valid(?level);\r\n        ensures level_le({this.getClass()}, level) == true;\r\n    {\r\n        open valid(_);\r\n    }\r\n    @*/\r\n    ZeroFunc()\r\n        //@ requires true;\r\n        //@ ensures valid({ZeroFunc.class});\r\n        //@ terminates;\r\n    {\r\n        //@ close valid({ZeroFunc.class});\r\n    }\r\n    public int apply(int x)\r\n        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\r\n        //@ ensures true;\r\n        //@ terminates;\r\n    {\r\n        return 0;\r\n    }\r\n    public static Func create()\r\n        //@ requires true;\r\n        //@ ensures Func(result, {ZeroFunc.class});\r\n        //@ terminates;\r\n    {\r\n        Func f = new ZeroFunc();\r\n        //@ close Func(f, {ZeroFunc.class});\r\n        return f;\r\n    }\r\n}\r\n\r\nfinal class PlusOneFunc implements Func {\r\n    Func f;\r\n    //@ list\u003cClass\u003e fLevel;\r\n    //@ predicate valid(list\u003cClass\u003e level) = f |-\u003e ?f \u0026*\u0026 fLevel |-\u003e ?fLevel \u0026*\u0026 [_]Func(f, fLevel) \u0026*\u0026 level == cons(PlusOneFunc.class, fLevel);\r\n    /*@\r\n    lemma void getClass_le_level()\r\n        requires [_]valid(?level);\r\n        ensures level_le({this.getClass()}, level) == true;\r\n    {\r\n        open valid(_);\r\n    }\r\n    @*/\r\n    PlusOneFunc(Func f)\r\n        //@ requires [_]Func(f, ?fLevel);\r\n        //@ ensures valid(cons(PlusOneFunc.class, fLevel));\r\n        //@ terminates;\r\n    {\r\n        this.f = f;\r\n        //@ this.fLevel = fLevel;\r\n    }\r\n    public int apply(int x)\r\n        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\r\n        //@ ensures true;\r\n        //@ terminates;\r\n    {\r\n        //@ open valid(_);\r\n        //@ call_perm_weaken_and_dup(2);\r\n        return Util.apply(f, x) + 1;\r\n    }\r\n    public static Func create(Func f)\r\n        //@ requires [_]Func(f, ?fLevel) \u0026*\u0026 call_perm(currentThread, cons(PlusOneFunc.class, fLevel));\r\n        //@ ensures Func(result, cons(PlusOneFunc.class, fLevel));\r\n        //@ terminates;\r\n    {\r\n        return new PlusOneFunc(f);\r\n    }\r\n}\r\n\r\nfinal class SumFunc implements Func {\r\n    Func f1;\r\n    //@ list\u003cClass\u003e f1Level;\r\n    Func f2;\r\n    //@ list\u003cClass\u003e f2Level;\r\n    \r\n    /*@\r\n    predicate valid(list\u003cClass\u003e level) =\r\n        f1 |-\u003e ?f1 \u0026*\u0026 f1Level |-\u003e ?f1Level \u0026*\u0026 [_]Func(f1, f1Level) \u0026*\u0026\r\n        f2 |-\u003e ?f2 \u0026*\u0026 f2Level |-\u003e ?f2Level \u0026*\u0026 [_]Func(f2, f2Level) \u0026*\u0026\r\n        level == cons(SumFunc.class, level_max(f1Level, f2Level));\r\n    @*/\r\n    \r\n    /*@\r\n    lemma void getClass_le_level()\r\n        requires [_]valid(?level);\r\n        ensures level_le({this.getClass()}, level) == true;\r\n    {\r\n        open [_]valid(_);\r\n    }\r\n    @*/\r\n    \r\n    SumFunc(Func f1, Func f2)\r\n        //@ requires [_]Func(f1, ?f1Level) \u0026*\u0026 [_]Func(f2, ?f2Level);\r\n        //@ ensures valid(cons(SumFunc.class, level_max(f1Level, f2Level)));\r\n        //@ terminates;\r\n    {\r\n        this.f1 = f1;\r\n        //@ this.f1Level = f1Level;\r\n        this.f2 = f2;\r\n        //@ this.f2Level = f2Level;\r\n    }\r\n    \r\n    public int apply(int x)\r\n        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\r\n        //@ ensures true;\r\n        //@ terminates;\r\n    {\r\n        //@ open [_]valid(_);\r\n        //@ level_cons_mono_l(Util.class, SumFunc.class, level_max(f1Level, f2Level));\r\n        //@ call_perm_weaken(1, cons(Util.class, level_max(f1Level, f2Level)));\r\n        return Util.sum(f1, f2, x);\r\n    }\r\n    \r\n    public static Func create(Func f1, Func f2)\r\n        //@ requires [_]Func(f1, ?f1Level) \u0026*\u0026 [_]Func(f2, ?f2Level) \u0026*\u0026 call_perm(currentThread, cons(SumFunc.class, level_max(f1Level, f2Level)));\r\n        //@ ensures Func(result, cons(SumFunc.class, level_max(f1Level, f2Level)));\r\n        //@ terminates;\r\n    {\r\n        return new SumFunc(f1, f2);\r\n    }\r\n}\r\n\r\nclass Main {\r\n    public static void main(String[] args)\r\n        //@ requires true;\r\n        //@ ensures true;\r\n        //@ terminates;\r\n    {\r\n        //@ produce_call_below_perm_();\r\n        //@ list\u003cClass\u003e level = {Util.class, SumFunc.class, PlusOneFunc.class, ZeroFunc.class};\r\n        //@ call_below_perm__elim(3, level);\r\n        Func f1 = ZeroFunc.create();\r\n        //@ leak Func(f1, _);\r\n        //@ call_perm_weaken(1, {PlusOneFunc.class, ZeroFunc.class});\r\n        Func f2 = PlusOneFunc.create(f1);\r\n        //@ level_max_def({ZeroFunc.class}, {PlusOneFunc.class, ZeroFunc.class});\r\n        //@ call_perm_weaken(1, cons(SumFunc.class, level_max({ZeroFunc.class}, {PlusOneFunc.class, ZeroFunc.class})));\r\n        Func f3 = SumFunc.create(f1, f2);\r\n        Util.deriv(f3, 0);\r\n    }\r\n}\r\n",
        "name": "SumFunc.java",
        "path": "examples/java/termination/SumFunc.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/termination/SumFunc.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]Func(f, ?level) \u0026*\u0026 [2]call_perm(currentThread, level);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 18,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 30,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]Func(f, ?level) \u0026*\u0026 call_perm(currentThread, cons(Util.class, level));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 39,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]Func(f1, ?f1Level) \u0026*\u0026 [_]Func(f2, ?f2Level) \u0026*\u0026 call_perm(currentThread, cons(Util.class, level_max(f1Level, f2Level)));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 40,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 52,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]Func(f, ?fLevel) \u0026*\u0026 call_perm(currentThread, cons(Util.class, fLevel));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 53,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 71,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 72,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid({ZeroFunc.class});\r"
        },
        {
          "limitHit": false,
          "lineNumber": 78,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 79,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 85,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 86,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Func(result, {ZeroFunc.class});\r"
        },
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]Func(f, ?fLevel);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 109,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(cons(PlusOneFunc.class, fLevel));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 116,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 117,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 125,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]Func(f, ?fLevel) \u0026*\u0026 call_perm(currentThread, cons(PlusOneFunc.class, fLevel));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 126,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Func(result, cons(PlusOneFunc.class, fLevel));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 156,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]Func(f1, ?f1Level) \u0026*\u0026 [_]Func(f2, ?f2Level);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 157,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(cons(SumFunc.class, level_max(f1Level, f2Level)));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 167,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 168,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 178,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]Func(f1, ?f1Level) \u0026*\u0026 [_]Func(f2, ?f2Level) \u0026*\u0026 call_perm(currentThread, cons(SumFunc.class, level_max(f1Level, f2Level)));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 179,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Func(result, cons(SumFunc.class, level_max(f1Level, f2Level)));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 188,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 189,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "// Work done in collaboration with Sybren Roede and Ruurd Kuiper\n\nimport channels.*;\nimport verifast.*;\n\n/*@\n\nfixpoint boolean non_null(Object o) { return o != null; }\n\npredicate_ctor client_inv(Channel c)() =\n    c.ChannelState(?items, ?qms) \u0026*\u0026 forall(items, non_null) == true \u0026*\u0026\n    [1/2]Program_sendMaxCount(?smc) \u0026*\u0026 0 \u003c smc \u0026*\u0026\n    [1/2]Program_receiveMaxCount(?rmc) \u0026*\u0026 0 \u003c rmc \u0026*\u0026\n    [_]Program_senders(?s) \u0026*\u0026\n    [_]Program_sendersCount(?sc) \u0026*\u0026\n    [1/3]array_slice_deep(s, 0, sc, senderWorkerInv, unit, _, ?lstSc)  \u0026*\u0026\n    [_]Program_receivers(?r) \u0026*\u0026\n    [_]Program_receiversCount(?rc) \u0026*\u0026\n    [1/3]array_slice_deep(r, 0, rc, receiverWorkerInv, unit, _, ?lstRc) \u0026*\u0026\n    length(items) == sum(lstSc) - sum(lstRc) \u0026*\u0026\n    sum(lstRc) \u003c= sum(lstSc);\n\npredicate senderWorkerInv(unit u, SenderThread sw; int senderCount) =\n    [3/2]sw.senderSendCount |-\u003e senderCount;\n\npredicate receiverWorkerInv(unit u, ReceiverThread rw; int receiverCount) =\n    [3/2]rw.receiverReceiveCount |-\u003e receiverCount;\n\nfixpoint int sum(list\u003cint\u003e vs) {\n    switch(vs) {\n      case nil: return 0;\n      case cons(h, t): return h + sum(t);\n    }\n}\n\nlemma_auto void sum_all_eq(list\u003cint\u003e vs)\n    requires all_eq(vs, 0) == true;\n    ensures sum(vs) == 0;\n{\n    switch(vs) {\n        case nil :\n        case cons (x0, xs0): sum_all_eq(xs0);\n    }\n}\n\nlemma void sum_take_cons_drop(int k, list\u003cint\u003e xs, int x)\n    requires 0 \u003c= k \u0026*\u0026 k \u003c length(xs);\n    ensures sum(xs) == sum(append(take(k, xs), cons(x, drop(k + 1, xs)))) - x + head(take(1, drop(k, xs)));\n{\n    switch (xs) {\n        case nil:\n        case cons(x0, xs0):\n            if (k == 0) {\n            } else {\n                sum_take_cons_drop(k - 1, xs0, x);\n            }\n    }\n}\n\npredicate my_sep_pred() = true;\n\npredicate_ctor my_unsep_pred(Channel c)(list\u003cObject\u003e items, int qms) =\n    forall(items, non_null) == true \u0026*\u0026\n    [1/2]Program_sendMaxCount(?smc) \u0026*\u0026  0 \u003c smc \u0026*\u0026\n    [1/2]Program_receiveMaxCount(?rmc) \u0026*\u0026 0 \u003c rmc \u0026*\u0026\n    [_]Program_senders(?s) \u0026*\u0026\n    [_]Program_sendersCount(?sc) \u0026*\u0026\n    [1/3]array_slice_deep(s, 0, sc, senderWorkerInv, unit, _, ?lstSc)  \u0026*\u0026\n    [_]Program_receivers(?r) \u0026*\u0026\n    [_]Program_receiversCount(?rc) \u0026*\u0026\n    [1/3]array_slice_deep(r, 0, rc, receiverWorkerInv, unit, _, ?lstRc) \u0026*\u0026\n    length(items) == sum(lstSc) - sum(lstRc) \u0026*\u0026\n    sum(lstRc) \u003c= sum(lstSc);\n\nlemma void my_sep()\n    requires exists\u003cChannel\u003e(?c) \u0026*\u0026 my_sep_pred() \u0026*\u0026 client_inv(c)();\n    ensures c.ChannelState(?items, ?qms) \u0026*\u0026 my_unsep_pred(c)(items, qms);\n{\n    open client_inv(c)();\n    assert c.ChannelState(?items, ?qms);\n    close my_unsep_pred(c)(items, qms);\n}\n\nlemma void my_unsep()\n    requires exists\u003cChannel\u003e(?c) \u0026*\u0026 my_unsep_pred(c)(?items, ?qms) \u0026*\u0026 c.ChannelState(items, qms);\n    ensures my_sep_pred() \u0026*\u0026 client_inv(c)();\n{\n    open my_unsep_pred(c)(_, _);\n    close client_inv(c)();\n    close my_sep_pred();\n}\n\npredicate foreach_i\u003ct\u003e(int i, list\u003ct\u003e xs, predicate(int, t) p) =\n    switch (xs) {\n        case nil: return true;\n        case cons(x0, xs0): return p(i, x0) \u0026*\u0026 foreach_i(i + 1, xs0, p);\n    };\n\nlemma void foreach_i_append\u003ct\u003e(int i, list\u003ct\u003e xs, list\u003ct\u003e ys)\n    requires foreach_i(i, xs, ?p) \u0026*\u0026 foreach_i(i + length(xs), ys, p);\n    ensures foreach_i(i, append(xs, ys), p);\n{\n    switch (xs) {\n        case nil:\n        case cons(x0, xs0):\n            open foreach_i(i, xs, p);\n            foreach_i_append(i + 1, xs0, ys);\n            close foreach_i(i, append(xs, ys), p);\n    }\n}\n\n@*/\n\n/*@\n\npredicate senderWorker(unit u, SenderThread SenderWorker; unit u2) =\n    [3]SenderWorker.thread |-\u003e ?t \u0026*\u0026  [3]SenderWorker.joinable |-\u003e ?j \u0026*\u0026\n    [3]t.Thread(j, true) \u0026*\u0026 [3]j.JoinableRunnable(SenderWorker, true) \u0026*\u0026 SenderWorker.getClass() == SenderThread.class \u0026*\u0026\n    u2 == unit;\n\npredicate senderWorkerNull(unit u, SenderThread SenderWorker; unit u2) =\n    [3/2]SenderWorker.thread |-\u003e _ \u0026*\u0026  [3/2]SenderWorker.joinable |-\u003e _ \u0026*\u0026\n    [3/2]SenderWorker.myIndex |-\u003e _ \u0026*\u0026\n    SenderWorker.getClass() == SenderThread.class \u0026*\u0026 [3/4]SenderWorker.senderSendCount |-\u003e 0 \u0026*\u0026\n    u2 == unit;\n\npredicate senderWorkerIndex(int i, SenderThread t) =\n    [_]t.myIndex |-\u003e i;\n\n@*/\n\npublic class SenderThread implements Runnable {\n    \n    //@ int senderSendCount;\n    //@ int myIndex;\n    Thread thread;\n    JoinableRunnable joinable;\n    \n    /*@\n    \n    predicate pre()  =\n        [_]Program_channel(?c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026\n        [_]Program_sendMaxCount(?smc) \u0026*\u0026 0 \u003c smc \u0026*\u0026\n        [_]Program_senders(?s) \u0026*\u0026 [_]this.myIndex |-\u003e ?myIndex \u0026*\u0026\n        [_]Program_sendersCount(?sc) \u0026*\u0026 myIndex \u003c sc  \u0026*\u0026\n        [1/3]array_slice_deep(s, myIndex, myIndex + 1, senderWorkerInv, unit, cons(this, nil), cons(0, nil));\n    \n    predicate post() =\n        [_]Program_channel(?c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026\n        [_]Program_sendMaxCount(?smc) \u0026*\u0026\n        [_]Program_senders(?s) \u0026*\u0026 [_]this.myIndex |-\u003e ?myIndex \u0026*\u0026\n        [_]Program_sendersCount(?sc) \u0026*\u0026 myIndex \u003c sc  \u0026*\u0026\n        [1/3]array_slice_deep(s, myIndex, myIndex + 1, senderWorkerInv, unit, cons(this, nil), cons(smc, nil));\n    \n    @*/\n    \n    public void run()\n        //@ requires pre();\n        //@ ensures post();\n    {\n        String m = \"Hello\";\n        int i;\n        for(i = 0; i \u003c Program.sendMaxCount; i++)\n            /*@\n            invariant\n                [_]Program_channel(?c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026\n                [_]Program_sendMaxCount(?smc) \u0026*\u0026 i \u003c= smc \u0026*\u0026\n                [_]Program_senders(?s) \u0026*\u0026 [_]this.myIndex |-\u003e ?myIndex \u0026*\u0026\n                [_]Program_sendersCount(?sc) \u0026*\u0026 myIndex \u003c sc \u0026*\u0026\n                [1/3]array_slice_deep(s, myIndex, myIndex + 1, senderWorkerInv, unit, cons(this, nil), cons(i, nil));\n            @*/\n        {\n            for (;;)\n                /*@\n                invariant\n                    [_]Program_channel(c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026\n                    [_]Program_sendMaxCount(smc) \u0026*\u0026 i \u003c smc \u0026*\u0026\n                    [_]Program_senders(s) \u0026*\u0026 [_]this.myIndex |-\u003e myIndex \u0026*\u0026\n                    [_]Program_sendersCount(sc) \u0026*\u0026 myIndex \u003c sc \u0026*\u0026\n                    [1/3]array_slice_deep(s, myIndex, myIndex + 1, senderWorkerInv, unit, cons(this, nil), cons(i, nil));\n                @*/\n            {\n                \n                /*@\n                predicate P() =\n                    [_]Program_sendMaxCount(smc) \u0026*\u0026\n                    [_]Program_senders(s) \u0026*\u0026 [_]this.myIndex |-\u003e myIndex \u0026*\u0026\n                    [_]Program_sendersCount(sc) \u0026*\u0026 myIndex \u003c sc \u0026*\u0026\n                    [1/3]array_slice_deep(s, myIndex, myIndex + 1, senderWorkerInv, unit, cons(this, nil), cons(i, nil));\n                predicate Q(boolean r) =\n                    [_]Program_sendMaxCount(smc) \u0026*\u0026\n                    [_]Program_senders(s) \u0026*\u0026 [_]this.myIndex |-\u003e myIndex \u0026*\u0026\n                    [_]Program_sendersCount(sc) \u0026*\u0026 myIndex \u003c sc \u0026*\u0026\n                    [1/3]array_slice_deep(s, myIndex, myIndex + 1, senderWorkerInv, unit, cons(this, nil), (r ? cons(i+1, nil) : cons(i, nil)));\n                \n                lemma void my_send(boolean r)\n                    requires i \u003c smc \u0026*\u0026 P() \u0026*\u0026 my_unsep_pred(c)(?items, ?qms);\n                    ensures Q(r) \u0026*\u0026 my_unsep_pred(c)(r ? append(items, cons(m, nil)) : items, qms);\n                {\n                    open P();\n                    open my_unsep_pred(c)(items, qms);\n                    SenderThread[] senders = Program.senders;\n                    int sendersCount = Program.sendersCount;\n                    int k = myIndex;\n                    assert [1/3]array_slice_deep(senders, 0, sendersCount, senderWorkerInv, unit, _, ?oldSenderCounts);\n                    array_slice_deep_split(Program.senders, 0, myIndex);\n                    array_slice_deep_split_precise(1/3, Program.senders, myIndex, Program.sendersCount, senderWorkerInv, unit, myIndex + 1);\n                    array_slice_deep_open_precise(2/3, Program.senders, myIndex);\n                    int myOldSendCount = senderSendCount;\n                    if (r) {\n                        senderSendCount++;\n                    }\n                    int myNewSendCount = senderSendCount;\n                    array_slice_deep_close(Program.senders, myIndex, senderWorkerInv, unit);\n                    array_slice_deep_join_precise(1/3, Program.senders, myIndex, myIndex + 1, senderWorkerInv, unit, Program.sendersCount);\n                    array_slice_deep_join_precise(1/3, Program.senders, 0, myIndex, senderWorkerInv, unit, Program.sendersCount);\n                    \n                    forall_append(items, cons(m, nil), non_null);\n                    length_append(items, cons(m, nil));\n                    assert [1/3]array_slice_deep(senders, 0, sendersCount, senderWorkerInv, unit, _, ?newSenderCounts);\n                    assert newSenderCounts == append(take(k, oldSenderCounts), cons(myNewSendCount, drop(1, drop(k, oldSenderCounts))));\n                    assert length(oldSenderCounts) == sendersCount;\n                    assert 0 \u003c= 1 \u0026*\u0026 0 \u003c= k \u0026*\u0026 1 + k \u003c= length(oldSenderCounts);\n                    drop_drop(1, k, oldSenderCounts);\n                    assert newSenderCounts == append(take(k, oldSenderCounts), cons(myNewSendCount, drop(k + 1, oldSenderCounts)));\n                    sum_take_cons_drop(k, oldSenderCounts, myNewSendCount);\n                    assert sum(newSenderCounts) == sum(oldSenderCounts) + myNewSendCount - myOldSendCount;\n                    close my_unsep_pred(c)(r ? append(items, cons(m, nil)) : items, qms);\n                    close Q(r);\n                }\n                @*/\n                //@ produce_lemma_function_pointer_chunk(my_sep) : channel_sep(client_inv(c), c, my_sep_pred, my_unsep_pred(c))() { close exists(c); call(); };\n                //@ produce_lemma_function_pointer_chunk(my_unsep) : channel_unsep(client_inv(c), c, my_sep_pred, my_unsep_pred(c))() { close exists(c); call(); };\n                //@ close my_sep_pred();\n                //@ produce_lemma_function_pointer_chunk(my_send) : channel_send(client_inv(c), c, my_unsep_pred(c), m, P, Q)(r) { call(); };\n                //@ close P();\n                boolean success = Program.channel.send(m);\n                //@ open Q(success);\n                if (success) break;\n            }\n        }\n        //@ assert i == Program.sendMaxCount;\n        //@ close post();\n    }\n}\n\n/*@\n\npredicate receiverWorker(unit u, ReceiverThread ReceiverWorker; unit u2) =\n    [3]ReceiverWorker.thread |-\u003e ?t \u0026*\u0026 [3]ReceiverWorker.joinable |-\u003e ?j \u0026*\u0026\n    [3]t.Thread(j, true) \u0026*\u0026 [3]j.JoinableRunnable(ReceiverWorker, true) \u0026*\u0026 ReceiverWorker.getClass() == ReceiverThread.class \u0026*\u0026\n    u2 == unit;\n\npredicate receiverWorkerNull(unit u, ReceiverThread ReceiverWorker; unit u2) =\n    [3/2]ReceiverWorker.thread |-\u003e _ \u0026*\u0026  [3/2]ReceiverWorker.joinable |-\u003e _ \u0026*\u0026\n    [3/2]ReceiverWorker.myIndex |-\u003e _ \u0026*\u0026\n    ReceiverWorker.getClass() == ReceiverThread.class \u0026*\u0026 [3/4]ReceiverWorker.receiverReceiveCount |-\u003e 0 \u0026*\u0026\n    u2 == unit;\n\npredicate receiverWorkerIndex(int i, ReceiverThread t) =\n    [_]t.myIndex |-\u003e i;\n\n@*/\n\nclass ReceiverThread implements Runnable {\n    //@ int receiverReceiveCount;\n    //@ int myIndex;\n    Thread thread;\n    JoinableRunnable joinable;\n    \n    /*@\n    \n    predicate pre() =\n        [_]Program_channel(?c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026\n        [_]Program_receiveMaxCount(?rmc) \u0026*\u0026 0 \u003c rmc \u0026*\u0026\n        [_]Program_receivers(?s) \u0026*\u0026 [_]this.myIndex |-\u003e ?myIndex \u0026*\u0026\n        [_]Program_receiversCount(?rc) \u0026*\u0026 myIndex \u003c rc  \u0026*\u0026\n        [1/3]array_slice_deep(s, myIndex, myIndex + 1, receiverWorkerInv, unit, cons(this, nil), cons(0, nil));\n    \n    predicate post() =\n        [_]Program_channel(?c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026\n        [_]Program_receiveMaxCount(?rmc) \u0026*\u0026\n        [_]Program_receivers(?s) \u0026*\u0026 [_]this.myIndex |-\u003e ?myIndex \u0026*\u0026\n        [_]Program_receiversCount(?rc) \u0026*\u0026 myIndex \u003c rc  \u0026*\u0026\n        [1/3]array_slice_deep(s, myIndex, myIndex + 1, receiverWorkerInv, unit, cons(this, nil), cons(rmc, nil));\n    \n    @*/\n    \n    public void run()\n        //@ requires pre();\n        //@ ensures post();\n    {\n        int i;\n        for (i=0; i \u003c Program.receiveMaxCount; i++)\n            /*@\n            invariant\n                [_]Program_channel(?c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026\n                [_]Program_receiveMaxCount(?rmc) \u0026*\u0026 i \u003c= rmc \u0026*\u0026\n                [_]Program_receivers(?r) \u0026*\u0026 [_]this.myIndex |-\u003e ?myIndex \u0026*\u0026\n                [_]Program_receiversCount(?rc) \u0026*\u0026 myIndex \u003c rc \u0026*\u0026\n                [1/3]array_slice_deep(r, myIndex, myIndex + 1, receiverWorkerInv, unit, cons(this, nil), cons(i, nil));\n            @*/\n        {\n            for (;;)\n                /*@\n                invariant\n                    [_]Program_channel(c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026\n                    [_]Program_receiveMaxCount(rmc) \u0026*\u0026 i \u003c rmc \u0026*\u0026\n                    [_]Program_receivers(r) \u0026*\u0026 [_]this.myIndex |-\u003e myIndex \u0026*\u0026\n                    [_]Program_receiversCount(rc) \u0026*\u0026 myIndex \u003c rc \u0026*\u0026\n                    [1/3]array_slice_deep(r, myIndex, myIndex + 1, receiverWorkerInv, unit, cons(this, nil), cons(i, nil));\n                @*/\n            {\n                /*@\n                predicate P() =  \n                    [_]Program_receiveMaxCount(rmc) \u0026*\u0026\n                    [_]Program_receivers(r) \u0026*\u0026 [_]this.myIndex |-\u003e myIndex \u0026*\u0026\n                    [_]Program_receiversCount(rc) \u0026*\u0026 myIndex \u003c rc \u0026*\u0026\n                    [1/3]array_slice_deep(r, myIndex, myIndex + 1, receiverWorkerInv, unit, cons(this, nil), cons(i, nil));\n                predicate Q(Object result) = \n                    [_]Program_receiveMaxCount(rmc) \u0026*\u0026 \n                    [_]Program_receivers(r) \u0026*\u0026 [_]this.myIndex |-\u003e myIndex \u0026*\u0026 \n                    [_]Program_receiversCount(rc) \u0026*\u0026 myIndex \u003c rc \u0026*\u0026\n                    [1/3]array_slice_deep(r, myIndex, myIndex + 1, receiverWorkerInv, unit, cons(this, nil), (result != null ? cons(i + 1, nil) : cons(i , nil)));\n                \n                lemma void my_channel_receive()\n                    requires i \u003c rmc \u0026*\u0026 P() \u0026*\u0026 my_unsep_pred(c)(?items, ?qms);\n                    ensures Q(items != nil ? head(items) : null) \u0026*\u0026 my_unsep_pred(c)(tail(items), qms);\n                {\n                    open P();\n                    open my_unsep_pred(c)(items, qms);\n                    ReceiverThread[] receivers = Program.receivers;\n                    int receiversCount = Program.receiversCount;\n                    int k = myIndex;\n                    assert [1/3]array_slice_deep(receivers, 0, receiversCount, receiverWorkerInv, unit, _, ?oldReceiverCounts);\n                    array_slice_deep_split(Program.receivers, 0, myIndex);\n                    array_slice_deep_split_precise(1/3, Program.receivers, myIndex, Program.receiversCount, receiverWorkerInv, unit, myIndex + 1);\n                    array_slice_deep_open_precise(2/3, Program.receivers, myIndex);\n                    int myOldReceiveCount = receiverReceiveCount;\n                    switch (items) {\n                    case nil:\n                    case cons(head, tail):\n                        receiverReceiveCount++;\n                    }\n                    int myNewReceiverCount = receiverReceiveCount;\n                    array_slice_deep_close(Program.receivers, myIndex, receiverWorkerInv, unit);\n                    array_slice_deep_join_precise(1/3, Program.receivers, myIndex, myIndex + 1, receiverWorkerInv, unit, Program.receiversCount);\n                    array_slice_deep_join_precise(1/3, Program.receivers, 0, myIndex, receiverWorkerInv, unit, Program.receiversCount);\n                    \n                    assert [1/3]array_slice_deep(receivers, 0, receiversCount, receiverWorkerInv, unit, _, ?newReceiverCounts);\n                    assert newReceiverCounts == append(take(k, oldReceiverCounts), cons(myNewReceiverCount, drop(1, drop(k, oldReceiverCounts))));\n                    assert length(oldReceiverCounts) == receiversCount;\n                    assert 0 \u003c= 1 \u0026*\u0026 0 \u003c= k \u0026*\u0026 1 + k \u003c= length(oldReceiverCounts);\n                    drop_drop(1, k, oldReceiverCounts);\n                    assert newReceiverCounts == append(take(k, oldReceiverCounts), cons(myNewReceiverCount, drop(k + 1, oldReceiverCounts)));\n                    sum_take_cons_drop(k, oldReceiverCounts, myNewReceiverCount);\n                    assert sum(newReceiverCounts) == sum(oldReceiverCounts) + myNewReceiverCount - myOldReceiveCount;\n                    \n                    switch (items) {\n                    case nil:\n                        close my_unsep_pred(c)(items, qms);\n                        close Q(null);\n                    case cons(head, tail):\n                        close my_unsep_pred(c)(tail, qms);\n                        close Q(head);\n                    }\n                }\n                @*/\n                //@ produce_lemma_function_pointer_chunk(my_sep) : channel_sep(client_inv(c), c, my_sep_pred, my_unsep_pred(c))() { close exists(c); call(); };\n                //@ produce_lemma_function_pointer_chunk(my_unsep) : channel_unsep(client_inv(c), c, my_sep_pred, my_unsep_pred(c))() { close exists(c); call(); };\n                //@ close my_sep_pred();\n                //@ produce_lemma_function_pointer_chunk(my_channel_receive) : channel_receive(client_inv(c), c, my_unsep_pred(c), P, Q)() { call(); };\n                //@ close P();\n                String m = Program.channel.receive();\n                //@ open Q(m);\n                if (m != null) break;\n            }\n        }\n        //@ close post();\n    }\n}\n\npublic class Program {\n    \n    //@ static int sendCount;\n    //@ static int receiveCount;\n    \n    public static int sendMaxCount;\n    public static int receiveMaxCount;\n    public static Channel channel;\n    public static int sendersCount;\n    public static int receiversCount;\n    public static SenderThread[] senders;\n    public static ReceiverThread[] receivers;\n    \n    public static void main(String[] args)\n        //@ requires class_init_token(Program.class);\n        //@ ensures true;\n    {\n        //@ init_class();\n        Program.sendersCount = 1000;\n        Program.receiversCount = 1000;\n        Program.sendMaxCount = 2000;\n        Program.receiveMaxCount = 2000;\n        Program.work();\n        //@assert Program.sendCount == 2000000;\n        //@assert Program.receiveCount == 2000000;\n    }\n    \n    public static void work()\n        /*@\n        requires\n            Program_channel(?channel) \u0026*\u0026\n            Program_senders(_) \u0026*\u0026 Program_receivers(_) \u0026*\u0026\n            [_]Program_sendersCount(?sendersCount) \u0026*\u0026 [_]Program_receiversCount(?receiversCount) \u0026*\u0026\n            0 \u003c sendersCount \u0026*\u0026 0 \u003c receiversCount \u0026*\u0026\n            Program_sendCount(?psc) \u0026*\u0026 Program_receiveCount(?prc) \u0026*\u0026 psc==0 \u0026*\u0026 prc==0 \u0026*\u0026\n            Program_sendMaxCount(?smc) \u0026*\u0026 0 \u003c smc  \u0026*\u0026 Program_receiveMaxCount(?rmc) \u0026*\u0026 0 \u003c rmc;\n        @*/\n        //@ ensures Program_sendCount(smc * sendersCount) \u0026*\u0026 Program_receiveCount(rmc * receiversCount);\n     {\n        Program.senders = new SenderThread[Program.sendersCount];\n        //@ SenderThread[] s = Program.senders;\n        //@ leak Program_senders(s);\n        //@ array_slice_deep_empty_close(s, 0, senderWorker, unit);\n        for (int i = 0; i \u003c Program.sendersCount; i++)\n            /*@\n            invariant\n                0 \u003c= i \u0026*\u0026 i \u003c= sendersCount \u0026*\u0026\n                [_]Program_senders(s) \u0026*\u0026 [_]Program_sendersCount(sendersCount) \u0026*\u0026\n                [1/3]Program_sendMaxCount(smc) \u0026*\u0026 0 \u003c smc \u0026*\u0026\n                array_slice(s, i, sendersCount, ?elems) \u0026*\u0026 all_eq(elems, null) == true \u0026*\u0026\n                [1/3]array_slice_deep(s, 0, i, senderWorkerInv, unit, _, ?v) \u0026*\u0026 all_eq(v, 0) == true \u0026*\u0026\n                [2/3]array_slice_deep(s, 0, i, senderWorkerNull, unit, _, _);\n            @*/\n        {\n            Program.senders[i] = new SenderThread();\n            //@ Program.senders[i].myIndex = i;\n            //@ array_slice_split(senders, i, i + 1);\n            //@ close [2/3]senderWorkerNull(unit, senders[i], unit);\n            //@ close [1/3]senderWorkerInv(unit, senders[i], _);\n            //@ array_slice_deep_close_precise(2/3, senders, i, senderWorkerNull, unit);\n            //@ array_slice_deep_close_precise(1/3, senders, i, senderWorkerInv, unit);\n            \n        }\n        \n        Program.receivers = new ReceiverThread[Program.receiversCount];\n        //@ ReceiverThread[] r = Program.receivers;\n        //@ leak Program_receivers(r);\n        //@ array_slice_deep_empty_close(r, 0, receiverWorker, unit);\n        for (int i = 0; i \u003c Program.receiversCount; i++)\n            /*@\n            invariant\n                0 \u003c= i \u0026*\u0026 i \u003c= receiversCount \u0026*\u0026\n                [_]Program_receivers(r) \u0026*\u0026 [_]Program_receiversCount(receiversCount) \u0026*\u0026\n                [1/3]Program_receiveMaxCount(rmc) \u0026*\u0026 0 \u003c rmc \u0026*\u0026\n                array_slice(r, i, receiversCount, ?elems) \u0026*\u0026 all_eq(elems, null) == true \u0026*\u0026\n                [1/3]array_slice_deep(r, 0, i, receiverWorkerInv, unit, _, ?v) \u0026*\u0026 all_eq(v, 0) == true \u0026*\u0026\n                [2/3]array_slice_deep(r, 0, i, receiverWorkerNull, unit, _, _);\n            @*/\n        {\n            receivers[i] = new ReceiverThread();\n            //@ Program.receivers[i].myIndex = i;\n            //@ array_slice_split(receivers, i, i + 1);\n            //@ close [2/3]receiverWorkerNull(unit, receivers[i], unit);\n            //@ close [1/3]receiverWorkerInv(unit, receivers[i], _);\n            //@ array_slice_deep_close_precise(2/3, receivers, i, receiverWorkerNull, unit);\n            //@ array_slice_deep_close_precise(1/3, receivers, i, receiverWorkerInv, unit);\n        }\n        Program.channel = new Channel(2);\n        \n        //@ close client_inv(Program.channel)();\n        //@ create_atomic_space(client_inv(Program.channel));\n        //@ close foreach_i(0, nil, senderWorkerIndex);\n        \n        for (int i = 0; i \u003c Program.sendersCount; i++)\n            /*@\n            invariant\n                0 \u003c= i \u0026*\u0026 i \u003c= sendersCount \u0026*\u0026\n                [_]Program_sendersCount(sendersCount) \u0026*\u0026 [_]Program_senders(s) \u0026*\u0026\n                [_]Program_channel(?c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026 [_]Program_sendMaxCount(smc) \u0026*\u0026 0 \u003c smc \u0026*\u0026\n                [2/3]array_slice_deep(s, i, sendersCount, senderWorkerNull, unit, _, _) \u0026*\u0026\n                [1/3]array_slice_deep(s, 0, i, senderWorker, unit, ?elements, _) \u0026*\u0026 foreach_i(0, elements, senderWorkerIndex);\n            @*/\n        {\n            //@ array_slice_deep_split(s, i, i + 1);\n            //@ array_slice_deep_open_precise(2/3, s, i);\n            SenderThread sender = senders[i];\n            //@ close [1/3]senderWorkerInv(unit, sender, _);\n            //@ array_slice_deep_close_precise(1/3, s, i, senderWorkerInv, unit);\n            JoinableRunnable j = ThreadingHelper.createJoinableRunnable(sender);\n            //@ sender.myIndex = i;\n            //@ leak sender.myIndex |-\u003e i;\n            //@ close sender.pre();\n            //@ j.closeIt();\n            Thread t = new Thread(j);\n            t.start();\n            \n            sender.thread = t;\n            sender.joinable = j;\n            //@ close [1/3]senderWorker(unit, sender, unit);\n            //@ array_slice_deep_close_precise(1/3, senders, i, senderWorker, unit);\n            \n            //@ close foreach_i(i + 1, nil, senderWorkerIndex);\n            //@ close senderWorkerIndex(i, sender);\n            //@ close foreach_i(i, cons(sender, nil), senderWorkerIndex);\n            //@ foreach_i_append(0, elements, cons(sender, nil));\n        }\n        //@ close foreach_i(0, nil, receiverWorkerIndex);\n        for (int i = 0; i \u003c Program.receiversCount; i++)\n            /*@\n            invariant\n                0 \u003c= i \u0026*\u0026 i \u003c= receiversCount \u0026*\u0026\n                [_]Program_receiversCount(receiversCount) \u0026*\u0026 [_]Program_receivers(r) \u0026*\u0026\n                [_]Program_channel(?c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026 [_]Program_receiveMaxCount(rmc) \u0026*\u0026 0 \u003c rmc \u0026*\u0026\n                [2/3]array_slice_deep(r, i, receiversCount, receiverWorkerNull, unit, _, _) \u0026*\u0026\n                [1/3]array_slice_deep(r, 0, i, receiverWorker, unit, ?elements, _) \u0026*\u0026 foreach_i(0, elements, receiverWorkerIndex);\n            @*/\n        {\n            //@ array_slice_deep_split(r, i, i + 1);\n            //@ array_slice_deep_open_precise(2/3, r, i);\n            ReceiverThread receiver = receivers[i];\n            //@ close [1/3]receiverWorkerInv(unit, receiver, _);\n            //@ array_slice_deep_close_precise(1/3, r, i, receiverWorkerInv, unit);\n            JoinableRunnable j = ThreadingHelper.createJoinableRunnable(receiver);\n            //@ receiver.myIndex = i;\n            //@ leak receiver.myIndex |-\u003e i;\n            //@ close receiver.pre();\n            //@ j.closeIt();\n            Thread t = new Thread(j);\n            t.start();\n            \n            receiver.thread = t;\n            receiver.joinable = j;\n            //@ close [1/3]receiverWorker(unit, receiver, unit);\n            //@ array_slice_deep_close_precise(1/3, receivers, i, receiverWorker, unit);\n            \n            //@ close foreach_i(i + 1, nil, receiverWorkerIndex);\n            //@ close receiverWorkerIndex(i, receiver);\n            //@ close foreach_i(i, cons(receiver, nil), receiverWorkerIndex);\n            //@ foreach_i_append(0, elements, cons(receiver, nil));\n        }\n        \n        int j;\n        for (j = 0; j \u003c Program.sendersCount; j++)\n            /*@\n            invariant\n                0 \u003c= j \u0026*\u0026 j \u003c= sendersCount \u0026*\u0026\n                [_]Program_sendersCount(sendersCount) \u0026*\u0026 [_]Program_senders(s) \u0026*\u0026\n                [_]Program_channel(?c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026\n                Program_sendCount(j * smc) \u0026*\u0026 [_]Program_sendMaxCount(smc) \u0026*\u0026\n                [1/3]array_slice_deep(s, j, sendersCount, senderWorker, unit, ?elements, _) \u0026*\u0026 foreach_i(j, elements, senderWorkerIndex);\n            @*/\n        {\n            SenderThread sw = senders[j];\n            ThreadingHelper.join(sw.thread, sw.joinable);\n            //@ open sw.post();\n            //@ open foreach_i(j, elements, senderWorkerIndex);\n            //@ open senderWorkerIndex(j, sw);\n            //@ int jj = sw.myIndex;\n            //@ assert j == jj;\n            //@ array_slice_deep_open_precise(1/3, s, j);\n            //@ open senderWorkerInv(unit, sw, _);\n            //@ Program.sendCount += sw.senderSendCount;\n        }\n        //@ assert Program.sendCount == Program.sendMaxCount * j;\n        //@ assert j == sendersCount;\n        //@ assert Program.sendCount == Program.sendMaxCount * sendersCount;\n        for (j = 0; j \u003c Program.receiversCount; j++)\n            /*@\n            invariant\n                0 \u003c= j \u0026*\u0026 j \u003c= receiversCount \u0026*\u0026\n                [_]Program_receiversCount(receiversCount) \u0026*\u0026 [_]Program_receivers(r) \u0026*\u0026\n                [_]Program_channel(?c) \u0026*\u0026 [_]c.Channel() \u0026*\u0026 [_]atomic_space(client_inv(c)) \u0026*\u0026\n                Program_receiveCount(j * rmc) \u0026*\u0026 [_]Program_receiveMaxCount(rmc) \u0026*\u0026\n                [1/3]array_slice_deep(r, j, receiversCount, receiverWorker, unit, ?elements, _) \u0026*\u0026 foreach_i(j, elements, receiverWorkerIndex);\n            @*/\n        {\n            ReceiverThread rw = receivers[j];\n            ThreadingHelper.join(rw.thread, rw.joinable);\n            //@ open rw.post();\n            //@ open foreach_i(j, elements, receiverWorkerIndex);\n            //@ open receiverWorkerIndex(j, rw);\n            //@ int jj = rw.myIndex;\n            //@ assert j == jj;\n            //@ array_slice_deep_open_precise(1/3, r, j);\n            //@ open receiverWorkerInv(unit, rw, _);\n            //@ Program.receiveCount += rw.receiverReceiveCount;\n        }\n        //@ assert Program.receiveCount == Program.receiveMaxCount * j;\n        //@ assert j == receiversCount;\n        //@ assert Program.receiveCount == Program.receiveMaxCount * receiversCount;\n    }\n    \n}\n",
        "name": "client.java",
        "path": "examples/java/channels_raw/client.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/channels_raw/client.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 157,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre();"
        },
        {
          "limitHit": false,
          "lineNumber": 158,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post();"
        },
        {
          "limitHit": false,
          "lineNumber": 289,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre();"
        },
        {
          "limitHit": false,
          "lineNumber": 290,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post();"
        },
        {
          "limitHit": false,
          "lineNumber": 396,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires class_init_token(Program.class);"
        },
        {
          "limitHit": false,
          "lineNumber": 397,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 419,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Program_sendCount(smc * sendersCount) \u0026*\u0026 Program_receiveCount(rmc * receiversCount);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "/*@\n\npredicate List(List l, list\u003cint\u003e elems, list\u003cClass\u003e level;) =\n    l.valid(elems, ?level0) \u0026*\u0026 elems == cons(_, _) \u0026*\u0026\n    level_le({l.getClass()}, level0) == true \u0026*\u0026 level_le(level0, level) == true;\n\nlemma_auto void List_inv()\n    requires List(?l, ?elems, ?level);\n    ensures List(l, elems, level) \u0026*\u0026 l != null \u0026*\u0026 elems != nil;\n{\n    open List(_, _, _);\n    close List(l, elems, level);\n}\n\nlemma void List_weaken(List l, list\u003cClass\u003e level)\n    requires [?f]List(l, ?elems, ?level0) \u0026*\u0026 level_le(level0, level) == true;\n    ensures [f]List(l, elems, level);\n{\n    open List(l, elems, level0);\n    assert [f]l.valid(elems, ?level00);\n    level_le_trans(level00, level0, level);\n    close [f]List(l, elems, level);\n}\n\npredicate List_opt(List l, list\u003cint\u003e elems, list\u003cClass\u003e level;) =\n    l == null ?\n        elems == nil\n    :\n        List(l, elems, level);\n\nlemma void List_opt_weaken(List l, list\u003cClass\u003e level)\n    requires [?f]List_opt(l, ?elems, ?level0) \u0026*\u0026 level_le(level0, level) == true;\n    ensures [f]List_opt(l, elems, level);\n{\n    open List_opt(l, elems, level0);\n    if (l != null)\n        List_weaken(l, level);\n    close [f]List_opt(l, elems, level);\n}\n\n@*/\n\ninterface List {\n    //@ predicate valid(list\u003cint\u003e elems, list\u003cClass\u003e level);\n    int getHead();\n        //@ requires [?f]valid(cons(?h, ?t), ?level) \u0026*\u0026 call_perm(currentThread, level);\n        //@ ensures [f]valid(cons(h, t), level) \u0026*\u0026 result == h;\n        //@ terminates;\n    List getTail();\n        //@ requires [?f]valid(cons(?h, ?t), ?level) \u0026*\u0026 call_perm(currentThread, level);\n        //@ ensures [f]List_opt(result, t, level);\n        //@ terminates;\n    List reverseAppend(List other);\n        //@ requires valid(?elems, ?level) \u0026*\u0026 List_opt(other, ?otherElems, ?otherLevel) \u0026*\u0026 call_perm(currentThread, level);\n        //@ ensures List(result, append(reverse(elems), otherElems), append(level, otherLevel));\n        //@ terminates;\n}\n\nclass ListUtil {\n    static List reverseAppend(List l, List other)\n        //@ requires List(l, ?elems, ?level) \u0026*\u0026 List_opt(other, ?otherElems, ?otherLevel) \u0026*\u0026 [2]call_perm(currentThread, level);\n        //@ ensures List(result, append(reverse(elems), otherElems), append(level, otherLevel));\n        //@ terminates;\n    {\n        //@ open List(l, _, _);\n        //@ assert l.valid(_, ?level0);\n        //@ call_perm_weaken(2, level0);\n        //@ consume_call_perm_for(l.getClass());\n        List result = l.reverseAppend(other);\n        //@ level_append_mono_l(level0, level, otherLevel);\n        //@ List_weaken(result, append(level, otherLevel));\n        return result;\n    }\n    static List reverseAppend_opt(List l, List other)\n        //@ requires List_opt(l, ?elems, ?level) \u0026*\u0026 List_opt(other, ?otherElems, ?otherLevel) \u0026*\u0026 call_perm(currentThread, cons(ListUtil.class, level));\n        //@ ensures List_opt(result, append(reverse(elems), otherElems), append(level, otherLevel));\n        //@ terminates;\n    {\n        //@ open List_opt(l, elems, level);\n        if (l == null) {\n            //@ level_le_append_r(level, otherLevel);\n            //@ List_opt_weaken(other, append(level, otherLevel));\n            return other;\n        } else {\n            //@ call_perm_weaken_and_dup(2);\n            List result = reverseAppend(l, other);\n            //@ close List_opt(result, append(reverse(elems), otherElems), append(level, otherLevel));\n            return result;\n        }\n    }\n    static List reverse_(List l)\n        //@ requires List_opt(l, ?elems, ?level) \u0026*\u0026 call_perm(currentThread, cons(ListUtil.class, level));\n        //@ ensures List_opt(result, reverse(elems), level);\n        //@ terminates;\n    {\n        //@ close List_opt(null, nil, nil);\n        return reverseAppend_opt(l, null);\n    }\n}\n\nfinal class Cons implements List {\n    int value;\n    List tail;\n    //@ list\u003cint\u003e tailElems;\n    //@ list\u003cClass\u003e tailLevel;\n    /*@\n    predicate valid(list\u003cint\u003e elems, list\u003cClass\u003e level) =\n        value |-\u003e ?value \u0026*\u0026 tail |-\u003e ?tail \u0026*\u0026 tailElems |-\u003e ?tailElems \u0026*\u0026 tailLevel |-\u003e ?tailLevel \u0026*\u0026\n        List_opt(tail, tailElems, tailLevel) \u0026*\u0026 elems == cons(value, tailElems) \u0026*\u0026 level == cons(Cons.class, tailLevel);\n    @*/\n    Cons(int value, List tail)\n        //@ requires List_opt(tail, ?tailElems, ?tailLevel);\n        //@ ensures List(this, cons(value, tailElems), cons(Cons.class, tailLevel));\n        //@ terminates;\n    {\n        this.value = value;\n        this.tail = tail;\n        //@ this.tailElems = tailElems;\n        //@ this.tailLevel = tailLevel;\n    }\n    List reverseAppend(List other)\n        //@ requires valid(?elems, ?level) \u0026*\u0026 List_opt(other, ?otherElems, ?otherLevel) \u0026*\u0026 call_perm(currentThread, level);\n        //@ ensures List(result, append(reverse(elems), otherElems), append(level, otherLevel));\n        //@ terminates;\n    {\n        //@ int v = value;\n        List t = tail;\n        //@ list\u003cint\u003e tElems = tailElems;\n        //@ list\u003cClass\u003e tLevel = tailLevel;\n        tail = other;\n        //@ tailElems = otherElems;\n        //@ tailLevel = otherLevel;\n        //@ close List_opt(this, cons(v, otherElems), cons(Cons.class, otherLevel));\n        //@ level_cons_mono_l(ListUtil.class, Cons.class, tLevel);\n        //@ call_perm_weaken(1, cons(ListUtil.class, tLevel));\n        List result = ListUtil.reverseAppend_opt(t, this);\n        //@ length_append(reverse(tElems), cons(v, otherElems));\n        //@ open List_opt(result, _, _);\n        //@ append_assoc(reverse(tElems), {v}, otherElems);\n        //@ level_le_append_flip(tLevel, {Cons.class});\n        //@ append_assoc(tLevel, {Cons.class}, otherLevel);\n        //@ level_append_mono_l(append(tLevel, {Cons.class}), level, otherLevel);\n        //@ List_weaken(result, append(level, otherLevel));\n        return result;\n    }\n    int getHead()\n        //@ requires [?f]valid(cons(?h, ?t), ?level) \u0026*\u0026 call_perm(currentThread, level);\n        //@ ensures [f]valid(cons(h, t), level) \u0026*\u0026 result == h;\n        //@ terminates;\n    {\n        return value;\n    }\n    List getTail()\n        //@ requires [?f]valid(cons(?h, ?t), ?level) \u0026*\u0026 call_perm(currentThread, level);\n        //@ ensures [f]List_opt(result, t, level);\n        //@ terminates;\n    {\n        //@ open [_]valid(_, _);\n        //@ assert [f]List_opt(_, t, ?tailLevel);\n        //@ level_lt_cons(Cons.class, tailLevel);\n        //@ List_opt_weaken(tail, level);\n        return tail;\n    }\n}\n\nclass Main {\n    static void main()\n        //@ requires true;\n        //@ ensures true;\n        //@ terminates;\n    {\n        //@ produce_call_below_perm_();\n        //@ call_below_perm__elim(1, {ListUtil.class, Cons.class, Cons.class, Cons.class});\n        //@ close List_opt(null, nil, nil);\n        Cons c3 = new Cons(3, null);\n        //@ close List_opt(c3, _, _);\n        Cons c2 = new Cons(2, c3);\n        //@ close List_opt(c2, _, _);\n        Cons c1 = new Cons(1, c2);\n        //@ close List_opt(c1, _, _);\n        List rev = ListUtil.reverse_(c1);\n        //@ assert List_opt(rev, {3, 2, 1}, _);\n    }\n}\n",
        "name": "Reverse.java",
        "path": "examples/java/termination/Reverse.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/termination/Reverse.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 45,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [?f]valid(cons(?h, ?t), ?level) \u0026*\u0026 call_perm(currentThread, level);"
        },
        {
          "limitHit": false,
          "lineNumber": 46,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [f]valid(cons(h, t), level) \u0026*\u0026 result == h;"
        },
        {
          "limitHit": false,
          "lineNumber": 49,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [?f]valid(cons(?h, ?t), ?level) \u0026*\u0026 call_perm(currentThread, level);"
        },
        {
          "limitHit": false,
          "lineNumber": 50,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [f]List_opt(result, t, level);"
        },
        {
          "limitHit": false,
          "lineNumber": 53,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?elems, ?level) \u0026*\u0026 List_opt(other, ?otherElems, ?otherLevel) \u0026*\u0026 call_perm(currentThread, level);"
        },
        {
          "limitHit": false,
          "lineNumber": 54,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(result, append(reverse(elems), otherElems), append(level, otherLevel));"
        },
        {
          "limitHit": false,
          "lineNumber": 60,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List(l, ?elems, ?level) \u0026*\u0026 List_opt(other, ?otherElems, ?otherLevel) \u0026*\u0026 [2]call_perm(currentThread, level);"
        },
        {
          "limitHit": false,
          "lineNumber": 61,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(result, append(reverse(elems), otherElems), append(level, otherLevel));"
        },
        {
          "limitHit": false,
          "lineNumber": 74,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List_opt(l, ?elems, ?level) \u0026*\u0026 List_opt(other, ?otherElems, ?otherLevel) \u0026*\u0026 call_perm(currentThread, cons(ListUtil.class, level));"
        },
        {
          "limitHit": false,
          "lineNumber": 75,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List_opt(result, append(reverse(elems), otherElems), append(level, otherLevel));"
        },
        {
          "limitHit": false,
          "lineNumber": 91,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List_opt(l, ?elems, ?level) \u0026*\u0026 call_perm(currentThread, cons(ListUtil.class, level));"
        },
        {
          "limitHit": false,
          "lineNumber": 92,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List_opt(result, reverse(elems), level);"
        },
        {
          "limitHit": false,
          "lineNumber": 111,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires List_opt(tail, ?tailElems, ?tailLevel);"
        },
        {
          "limitHit": false,
          "lineNumber": 112,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(this, cons(value, tailElems), cons(Cons.class, tailLevel));"
        },
        {
          "limitHit": false,
          "lineNumber": 121,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?elems, ?level) \u0026*\u0026 List_opt(other, ?otherElems, ?otherLevel) \u0026*\u0026 call_perm(currentThread, level);"
        },
        {
          "limitHit": false,
          "lineNumber": 122,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures List(result, append(reverse(elems), otherElems), append(level, otherLevel));"
        },
        {
          "limitHit": false,
          "lineNumber": 146,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [?f]valid(cons(?h, ?t), ?level) \u0026*\u0026 call_perm(currentThread, level);"
        },
        {
          "limitHit": false,
          "lineNumber": 147,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [f]valid(cons(h, t), level) \u0026*\u0026 result == h;"
        },
        {
          "limitHit": false,
          "lineNumber": 153,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [?f]valid(cons(?h, ?t), ?level) \u0026*\u0026 call_perm(currentThread, level);"
        },
        {
          "limitHit": false,
          "lineNumber": 154,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [f]List_opt(result, t, level);"
        },
        {
          "limitHit": false,
          "lineNumber": 167,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 168,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class CompoundAssignments {\r\n  int f;\r\n  \r\n  void test1() \r\n    //@ requires true;\r\n    //@ ensures true;\r\n  {\r\n    int x = 0;\r\n    x += (++x) + (++x) + (x+=1);\r\n    //@ assert x == 6;\r\n    int y = 0;\r\n    int z = 0;\r\n    int t = (x = 2) + (y = 3) + (z = 4);\r\n    assert t == 9 \u0026\u0026 x == 2 \u0026\u0026 y == 3 \u0026\u0026 z == 4;\r\n  }\r\n  \r\n  void test2() \r\n    //@ requires this.f |-\u003e 1;\r\n    //@ ensures this.f |-\u003e 3;\r\n  {\r\n    this.f += ++this.f;\r\n  }\r\n  \r\n  int consumef() \r\n    //@ requires this.f |-\u003e _;\r\n    //@ ensures result ==  0;\r\n  {\r\n   return 0;\r\n  }\r\n    \r\n  void test3() \r\n    //@ requires this.f |-\u003e 0;\r\n    //@ ensures true;\r\n  {\r\n    this.f += consumef(); //~ should_fail\r\n  }\r\n}",
        "name": "CompoundAssignments.java",
        "path": "examples/java/CompoundAssignments.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/CompoundAssignments.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires this.f |-\u003e 1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 18,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures this.f |-\u003e 3;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 24,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires this.f |-\u003e _;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 25,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result ==  0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires this.f |-\u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 32,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class C {\r\n  final static int f = 10;\r\n  \r\n  void m()\r\n    //@ requires true;\r\n    //@ ensures true;\r\n  {\r\n    short x = 20 + f;\r\n    //@ assert x == 30;\r\n  }\r\n}",
        "name": "ConstantExpressions.java",
        "path": "examples/java/ConstantExpressions.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/ConstantExpressions.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "// Work done in collaboration with Sybren Roede and Ruurd Kuiper\n\npackage channels;\n\nimport java.util.concurrent.*;\nimport java.util.*;\n\n/*@\n\npredicate_ctor channel_sema_inv(Channel channel)() =\n    channel.itemList |-\u003e ?itemList \u0026*\u0026 itemList.List(?items) \n    \u0026*\u0026 [1/2]channel.items_ |-\u003e items \u0026*\u0026\n    [1/2]channel.queueMaxSize |-\u003e ?qms \u0026*\u0026 length(items) \u003c= qms;\n\n@*/\n\npublic final class Channel {\n\n    //@ list\u003cObject\u003e items_;\n    List itemList;\n    Semaphore sema;\n    int queueMaxSize;\n    \n    //@ predicate Channel() = sema |-\u003e ?sema \u0026*\u0026 [_]sema.Semaphore(channel_sema_inv(this));\n    //@ predicate ChannelState(list\u003cObject\u003e items, int qms) = [1/2]items_ |-\u003e items \u0026*\u0026 [1/2]queueMaxSize |-\u003e qms;\n    \n    public Channel(int queueMaxSize)\n        //@ requires 0 \u003c= queueMaxSize;\n        //@ ensures Channel() \u0026*\u0026 ChannelState(nil, queueMaxSize);\n    {\n        itemList = new ArrayList();\n        this.queueMaxSize = queueMaxSize;\n        //@ items_ = nil;\n        //@ close channel_sema_inv(this)();\n        //@ one_time(channel_sema_inv(this));\n        sema = new Semaphore(1);\n        //@ sema.leakHandle();\n        //@ close Channel();\n        //@ close ChannelState(nil, queueMaxSize);\n    }\n    \n    boolean send(String msg)\n        /*@\n        requires \n            [?fc]Channel() \u0026*\u0026\n            [?fa]atomic_space(?inv) \u0026*\u0026\n            is_channel_sep(?sep, inv, this, ?sepPred, ?unsepPred) \u0026*\u0026\n            is_channel_unsep(?unsep, inv, this, sepPred, unsepPred) \u0026*\u0026\n            sepPred() \u0026*\u0026\n            is_channel_send(?send_, inv, this, unsepPred, msg, ?pre, ?post) \u0026*\u0026 pre();\n        @*/\n        /*@\n        ensures\n            [fc]Channel() \u0026*\u0026\n            [fa]atomic_space(inv) \u0026*\u0026\n            sepPred() \u0026*\u0026\n            post(result);\n        @*/\n    {\n        //@ open [fc]Channel();\n        //@ sema.makeHandle();\n        sema.acquire();\n        //@ open channel_sema_inv(this)();\n        //@ assert itemList |-\u003e ?l \u0026*\u0026 l.List(?items);\n        //@ assert [1/2]queueMaxSize |-\u003e ?qms;\n\n        boolean result;\n        if (itemList.size() \u003c queueMaxSize) {\n            itemList.add(msg);\n            result = true;\n        } else {\n            result = false;\n        }\n        \n        {\n            /*@\n            predicate P() =\n                is_channel_sep(sep, inv, this, sepPred, unsepPred) \u0026*\u0026\n                is_channel_unsep(unsep, inv, this, sepPred, unsepPred) \u0026*\u0026\n                is_channel_send(send_, inv, this, unsepPred, msg, pre, post) \u0026*\u0026\n                sepPred() \u0026*\u0026 pre() \u0026*\u0026\n                [1/2]items_ |-\u003e items;\n            predicate Q() =\n                [1/2]items_ |-\u003e (length(items) \u003c qms ? append\u003cObject\u003e(items, cons(msg, nil)) : items) \u0026*\u0026\n                sepPred() \u0026*\u0026\n                post(length(items) \u003c qms);\n            \n            lemma void my_ghost_op()\n                requires P() \u0026*\u0026 inv();\n                ensures Q() \u0026*\u0026 inv();\n            {\n                open P();\n                sep();\n                open ChannelState(_, _);\n                if (length(items) \u003c qms)\n                {\n                  items_ = append\u003cObject\u003e(items, cons(msg, nil));\n                  close ChannelState(append\u003cObject\u003e(items, cons(msg, nil)), _);\n                  send_(true);\n                }\n                else\n                {\n                  items_ = items;\n                  close ChannelState(items, _);\n                  send_(false);\n                }\n\n                unsep();\n                close Q();\n            }\n            @*/\n            //@ close P();\n            //@ produce_lemma_function_pointer_chunk(my_ghost_op) : atomic_space_ghost_operation(inv, P, Q)() { call(); };\n            //@ perform_atomic_space_ghost_operation();\n            //@ open Q();\n        }\n        //@ length_append\u003cObject\u003e(items, cons(msg, nil));\n        //@ close channel_sema_inv(this)();\n        sema.release();\n        //@ close [fc]Channel();\n        return result;\n    }\n    \n    String receive()\n        /*@\n        requires\n            [?fc]Channel() \u0026*\u0026\n            [?fa]atomic_space(?inv) \u0026*\u0026\n            is_channel_sep(?sep, inv, this, ?sepPred, ?unsepPred) \u0026*\u0026\n            is_channel_unsep(?unsep, inv, this, sepPred, unsepPred) \u0026*\u0026\n            is_channel_receive(?receive_, inv, this, unsepPred, ?pre, ?post) \u0026*\u0026\n            sepPred() \u0026*\u0026 pre();\n        @*/\n        /*@\n        ensures\n            [fc]Channel() \u0026*\u0026\n            [fa]atomic_space(inv) \u0026*\u0026\n            sepPred() \u0026*\u0026\n            post(result);\n        @*/\n    {\n        //@ sema.makeHandle();\n        sema.acquire();\n        //@ open channel_sema_inv(this)();\n        String result;\n        if (itemList.size() == 0) {\n            result = null;\n        } else {\n            result = (String)itemList.remove(0);\n        }\n        //@ list\u003cObject\u003e items = items_;\n        {\n            /*@\n            predicate P() =\n                is_channel_sep(sep, inv, this, sepPred, unsepPred) \u0026*\u0026\n                is_channel_unsep(unsep, inv, this, sepPred, unsepPred) \u0026*\u0026\n                is_channel_receive(receive_, inv, this, unsepPred, pre, post) \u0026*\u0026\n                sepPred() \u0026*\u0026 pre() \u0026*\u0026\n                [1/2]items_ |-\u003e items;\n            predicate Q() =\n                [1/2]items_ |-\u003e tail(items) \u0026*\u0026\n                sepPred() \u0026*\u0026\n                post(items != nil ? head(items) : null);\n            \n            lemma void my_ghost_op()\n                requires P() \u0026*\u0026 inv();\n                ensures Q() \u0026*\u0026 inv();\n            {\n                open P();\n                sep();\n                open ChannelState(_, _);\n                items_ = tail(items);\n                close ChannelState(tail(items), _);\n                receive_();\n                unsep();\n                close Q();\n            }\n            @*/\n            //@ close P();\n            //@ produce_lemma_function_pointer_chunk(my_ghost_op) : atomic_space_ghost_operation(inv, P, Q)() { call(); };\n            //@ perform_atomic_space_ghost_operation();\n            //@ open Q();\n        }\n        //@ switch (items) { case nil: case cons(i0, is0): }\n        //@ close channel_sema_inv(this)();\n        sema.release();\n        return result;\n    }\n    \n}\n",
        "name": "Channel.java",
        "path": "examples/java/channels_raw/Channel.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/channels_raw/Channel.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires 0 \u003c= queueMaxSize;"
        },
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Channel() \u0026*\u0026 ChannelState(nil, queueMaxSize);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class A {\r\n  int x1;\r    \r\n  public A(int v) \r\n    //@ requires true;\r\n    //@ ensures this.x1 |-\u003e v;\r\n  {\r\n    super();\r\n    x1 = v;\r\n  }\r\n}\r\n\r\nclass B extends A\r\n{ \r  int x2;\r\n  \r\n  public B(int v1, int v2) \r\n    //@ requires true;\r\n    //@ ensures this.x1 |-\u003e v1 \u0026*\u0026 this.x2 |-\u003e v2;\r\n  {\r\n    super(v1);\r\n    this.x2 = v2;\r\n  }\r\n}\r\n\r\n",
        "name": "SuperConstructorCall.java",
        "path": "examples/java/SuperConstructorCall.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/SuperConstructorCall.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures this.x1 |-\u003e v;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures this.x1 |-\u003e v1 \u0026*\u0026 this.x2 |-\u003e v2;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "//@ predicate True(Object element) = true;\n\nclass Consumer implements Forkee {\n    //@ int callPermScope;\n    Channel c;\n    \n    //@ predicate pre(int callPermScope, list\u003cObject\u003e O) = this.callPermScope |-\u003e callPermScope \u0026*\u0026 c |-\u003e ?c \u0026*\u0026 [_]c.channel(True) \u0026*\u0026 credits(c, 10) \u0026*\u0026 O == nil;\n    \n    void run()\n        //@ requires obs(?O) \u0026*\u0026 pre(call_perm_scope_of(currentThread), O);\n        //@ ensures obs(nil);\n        //@ terminates;\n    {\n        //@ open pre(_, O);\n        Channel c = c;\n        for (int i = 0; i \u003c 10; i++)\n            //@ invariant obs(nil) \u0026*\u0026 [_]c.channel(True) \u0026*\u0026 credits(c, 10 - i);\n            //@ decreases 10 - i;\n        {\n            c.receive();\n        }\n    }\n\n}\n\nclass ProdCons {\n    static void main()\n        //@ requires obs(nil);\n        //@ ensures obs(nil);\n        //@ terminates;\n    {\n        //@ produce_call_below_perm_();\n        //@ call_below_perm__elim(1, {Consumer.class});\n        \n        //@ close exists(pair(True, pair({ProdCons.class}, 0r)));\n        Channel c = new Channel();\n        //@ c.create_obs(10);\n        //@ assert obs(?O0);\n        Consumer cons = new Consumer();\n        //@ cons.callPermScope = call_perm_scope_of(currentThread);\n        cons.c = c;\n        //@ close cons.pre(_, nil);\n        //@ close exists(O0);\n        ThreadUtil.fork(cons);\n\n        for (int i = 0; i \u003c 10; i++)\n            //@ invariant repeat\u003cObject\u003e(c, 10 - i, ?O) \u0026*\u0026 obs(O) \u0026*\u0026 [_]c.channel(True);\n            //@ decreases 10 - i;\n        {\n            //@ close True(null);\n            c.send(null);\n            //@ open repeat(_, _, _);\n            //@ c.destroy_ob();\n        }\n        //@ open repeat(_, _, _);\n    }\n}\n",
        "name": "ProdCons.java",
        "path": "examples/java/termination/ProdCons.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/termination/ProdCons.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obs(?O) \u0026*\u0026 pre(call_perm_scope_of(currentThread), O);"
        },
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs(nil);"
        },
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obs(nil);"
        },
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs(nil);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "// Note: on this program, VeriFast/Redux is 10x faster than VeriFast/Z3. To use Redux:\n//    vfide -prover redux Addressbook.java\n//    verifast -c -prover redux Addressbook.java\n\npackage Addressbook;\n\nimport javacard.framework.*;\n\n//@ predicate filter_index(short element) = 0 \u003c= element \u0026*\u0026 element \u003c 20;\n//@ predicate groupnbs_element(byte info, byte element; byte value) = 0 \u003c= element \u0026*\u0026 element \u003c= 20 \u0026*\u0026 value == element;\n\npublic final class Addressbook extends Applet {\n\n    //CLA byte\n    private static final byte Store_CLA = (byte) 0xB0;\n\n    //Instruction (ins) bytes\n    private static final byte ADD = (byte) 0x10;\n    private static final byte DELETE = (byte) 0x20;\n    private static final byte SEARCH = (byte) 0x30;\n    private static final byte ADDGROUP = (byte) 0x40;\n    private static final byte DELETEGROUP = (byte) 0x50;\n    private static final byte ADDCONTACTTOGROUP = (byte) 0x41;\n    private static final byte REMOVECONTACTFROMGROUP = (byte) 0x42;\n    private static final byte SEARCHINGROUP = (byte) 0x43;\n    private static final byte FILTERCONTACTS = (byte) 0x61;\n\n    //Error bytes\n    private static final byte SW_ADDRESSBOOK_FULL = (byte) 0x5300;\n    private static final byte SW_PERSON_NOT_FOUND = (byte) 0x2100;\n    private static final byte SW_GROUP_NOT_FOUND = (byte) 0x6100;\n    private static final byte SW_GROUPBOOK_FULL = (byte) 0x6200;\n    private static final byte SW_GROUP_FULL = (byte) 0x6300;\n    private static final byte SW_NO_PERSON_FOUND = (byte) 0x4000;\n\n    //Number of bytes for nr,name,record,groupname and groupnumbers\n    private static final short NR_LENGTH = 5;\n    private static final short NAME_LENGTH = 15;\n    private static final short RECORD_LENGTH = 20;\n    private static final short GROUPNAME_LENGTH = 10;\n    private static final short GROUPNUMBERS_LENGTH = 10;\n\n    //Array Declarations\n    private static byte[] zeros;\n    private static byte[] phoneNbs;\n    private static short[] emptyPhoneNbs;//Marks empty places in the phonebook(PhoneNbs)\n    private static byte[] groupnames;\n    private static byte[] groupnbs;//Contains for each group the contactnbs (index of contact in phoneNbs) that belong to the group\n    private static short[] emptyGroups;//Marks empty groups in groupnames.\n    private static byte[] filteredNames;\n\n     /*@\n    predicate valid() = emptyPhoneNbs |-\u003e ?e_array \u0026*\u0026 e_array != null \u0026*\u0026 array_slice(e_array,0,e_array.length,_) \u0026*\u0026 e_array.length == 20\n    \t\t\t\u0026*\u0026 phoneNbs |-\u003e ?t_array \u0026*\u0026 t_array != null \u0026*\u0026 array_slice(t_array,0,t_array.length,_) \u0026*\u0026 t_array.length == 400\n    \t\t\t\u0026*\u0026 zeros |-\u003e ?z_array \u0026*\u0026 z_array != null \u0026*\u0026 array_slice(z_array,0,z_array.length,_) \u0026*\u0026 z_array.length == 20\n    \t\t\t\u0026*\u0026 groupnames |-\u003e ?g_array \u0026*\u0026 g_array != null \u0026*\u0026 array_slice(g_array,0,g_array.length,_) \u0026*\u0026 g_array.length == 100\n      \t                \u0026*\u0026 groupnbs |-\u003e ?nb_array \u0026*\u0026 nb_array != null \u0026*\u0026 array_slice_deep(nb_array, 0, nb_array.length, groupnbs_element, 0, _,_) \u0026*\u0026 nb_array.length == 100\n    \t\t\t\u0026*\u0026 emptyGroups |-\u003e ?ge_array \u0026*\u0026 ge_array != null \u0026*\u0026 array_slice(ge_array,0,ge_array.length,_) \u0026*\u0026 ge_array.length == 10\n    \t\t\t\u0026*\u0026 filteredNames |-\u003e ?f_array \u0026*\u0026 f_array != null \u0026*\u0026 array_slice(f_array,0,f_array.length,_) \u0026*\u0026 f_array.length == 400;\n    @*/ \n\n    public static void install(byte[] bArray, short bOffset, byte bLength)\n    //@ requires class_init_token(Addressbook.class) \u0026*\u0026 system();\n    //@ ensures true;\n    {\n        Addressbook addressbook = new Addressbook();\n        addressbook.register();\n    }\n\n    protected Addressbook()\n    //@ requires class_init_token(Addressbook.class);\n    //@ ensures valid();\n    {\n        //@ init_class();\n        phoneNbs = new byte[400];\n        emptyPhoneNbs = new short[20];\n        zeros = new byte[20];\n        groupnames = new byte[100];\n        groupnbs = new byte[100];\n        emptyGroups = new short[10];\n        filteredNames = new byte[400];\n\n        //Initialize the groupnbs array\n        for(short i =0; i\u003c 100; i++)\n        //@ invariant 0 \u003c= i \u0026*\u0026 groupnbs |-\u003e ?gn_array \u0026*\u0026 array_slice_deep(gn_array,0,i,groupnbs_element,0,?ielems,_) \u0026*\u0026 array_slice(gn_array,i,gn_array.length,?elems) \u0026*\u0026 gn_array.length == 100;\n        {\n        \tgroupnbs[i] = (byte)0;\n        \t//@ close groupnbs_element(0,0,0);\n        \t//@ array_slice_deep_close(gn_array,i,groupnbs_element,0);\n\n        }\n        //@ close valid();\n    }\n\n    public void process(APDU apdu)\n     /*@\n      requires\n        current_applet(this) \u0026*\u0026\n        [1/2]valid() \u0026*\u0026\n        apdu != null \u0026*\u0026\n        APDU(apdu, ?buffer) \u0026*\u0026\n        array_slice(buffer, 0, buffer.length, _);\n      @*/\n      /*@\n      ensures\n        current_applet(this) \u0026*\u0026\n        [1/2]valid() \u0026*\u0026\n        apdu != null \u0026*\u0026\n        APDU(apdu, buffer) \u0026*\u0026\n        array_slice(buffer, 0, buffer.length, _);\n      @*/\n    {\n        byte[] abuffer = apdu.getBuffer();\n\n        if(selectingApplet())\n            return;\n\n        if(abuffer[ISO7816.OFFSET_CLA] != Store_CLA)\n          ISOException.throwIt(ISO7816.SW_CLA_NOT_SUPPORTED);\n\n        switch(abuffer[ISO7816.OFFSET_INS]){\n            case ADD: add(apdu);return;\n            case DELETE: delete(apdu);return;\n            case SEARCH: search(apdu);return;\n            case ADDGROUP: addGroup(apdu);return;\n            case DELETEGROUP: deleteGroup(apdu);return;\n            case ADDCONTACTTOGROUP: addContactToGroup(apdu);return;\n            case REMOVECONTACTFROMGROUP: removeContactFromGroup(apdu);return;\n            case SEARCHINGROUP: searchInGroup(apdu);return;\n            case FILTERCONTACTS: filterContacts(apdu);return;\n            default: ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);\n        }\n    }\n\n    private void add(APDU apdu)\n    //@requires APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();\n    //@ensures APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();\n    {\n        byte[] abuffer = apdu.getBuffer();\n\n        if((short)abuffer[ISO7816.OFFSET_LC] != RECORD_LENGTH)\n            ISOException.throwIt(ISO7816.SW_DATA_INVALID);\n\n        //@open [1/2]valid();\n        short length = (short) emptyPhoneNbs.length;\n        //@close [1/2]valid();\n\n        boolean added = false;\n\n        //Search empty space in phoneNbs by inspecting emptyPhoneNbs\n        //if empty space found, store contact in that space\n        for(short i=0;i\u003clength;i++)\n        //@ invariant APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 i \u003e= 0;\n        {\n            //@ open [1/2]valid();\n            short item = emptyPhoneNbs[i];\n            //@close [1/2]valid();\n\n            if(item == 0 \u0026\u0026 added==false){\n                JCSystem.beginTransaction();\n                added = true;\n                //@open valid();\n                //Mark space used\n                emptyPhoneNbs[i] = 1;\n                //Copy contactdata in empty space phoneNbs\n                Util.arrayCopy(abuffer,(short)ISO7816.OFFSET_CDATA,phoneNbs,(short)(i * RECORD_LENGTH),(short) RECORD_LENGTH);\n                //@close valid();\n                JCSystem.commitTransaction();\n            }\n        }\n\n        if(!added)\n            ISOException.throwIt(SW_ADDRESSBOOK_FULL);\n    }\n\n    private void delete(APDU apdu)\n    //@requires APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();\n    //@ensures APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();\n    {\n        byte[] abuffer = apdu.getBuffer();\n\n        if((short)abuffer[ISO7816.OFFSET_LC] != NAME_LENGTH)\n            ISOException.throwIt(ISO7816.SW_DATA_INVALID);\n\n        //@open [1/2]valid();\n        short length = (short) emptyPhoneNbs.length;\n        //@close [1/2]valid();\n\n        //Search each record of phoneNbs\n        for(short i=0;i\u003clength;i++)\n        //@ invariant APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 i \u003e= 0;\n        {\n            //@ open [1/2]valid();\n            short item = emptyPhoneNbs[i];\n            //@close [1/2]valid();\n\n            //If there exists a record in phoneNbs on index\n            if(item == 1){\n                //@ open [1/2]valid();\n                //Match names of record in phoneNbs and in incoming apdu\n                short equal = (short)Util.arrayCompare(abuffer, (short)ISO7816.OFFSET_CDATA, phoneNbs, (short)(i * RECORD_LENGTH), NAME_LENGTH);\n                //@ close [1/2]valid();\n\n                if(equal == 0){\n                    JCSystem.beginTransaction();\n                    //@ open valid();\n                    //Set recordplace on empty\n                    emptyPhoneNbs[i] = 0;\n                    //Overwrite record with zeros\n                    Util.arrayCopy(zeros,(short)0,phoneNbs,(short)(i * RECORD_LENGTH),(short) RECORD_LENGTH);\n                    //@ close valid();\n                    JCSystem.commitTransaction();\n                }\n            }\n        }\n    }\n\n    private void search(APDU apdu)\n    //@ requires APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();\n    //@ ensures APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();\n    {\n        byte[] abuffer = apdu.getBuffer();\n\n        if((short)abuffer[ISO7816.OFFSET_LC] != NAME_LENGTH)\n            ISOException.throwIt(ISO7816.SW_DATA_INVALID);\n\n        //@open [1/2]valid();\n        short length = (short) emptyPhoneNbs.length;\n        //@close [1/2]valid();\n        boolean found = false;\n        //Search each record of phoneNbs\n        for(short i=0;i\u003clength;i++)\n        //@ invariant APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 i \u003e= 0;\n        {\n            //@ open [1/2]valid();\n            short item = emptyPhoneNbs[i];\n            //@close [1/2]valid();\n            //If there exists a record on index \u0026 record not found\n            if(item == 1 \u0026\u0026 found == false){\n            \t//@ open [1/2]valid();\n                //If names of the record in phoneNbs and incoming apdu match\n                if(Util.arrayCompare(abuffer, (short)ISO7816.OFFSET_CDATA, phoneNbs, (short)(i * RECORD_LENGTH), NAME_LENGTH) == 0){\n                    found = true;\n                    apdu.setOutgoing();\n                    apdu.setOutgoingLength(NR_LENGTH);\n                    apdu.sendBytesLong(phoneNbs, (short)((i * RECORD_LENGTH)+NAME_LENGTH), NR_LENGTH);\n                }\n                //@ close [1/2]valid();\n            }\n        }\n        \n        if(found == false){\n            ISOException.throwIt(SW_PERSON_NOT_FOUND);\n        }\n    }\n\n    private void addGroup (APDU apdu)\n    //@ requires APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]this.valid();\n    //@ ensures APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]this.valid();\n    {\n        byte[] abuffer = apdu.getBuffer();\n\n        if((short)abuffer[ISO7816.OFFSET_LC] != GROUPNAME_LENGTH)\n            ISOException.throwIt(ISO7816.SW_DATA_INVALID);\n\n        //@open [1/2]valid();\n        short length = (short) emptyGroups.length;\n        //@close [1/2]valid();\n\n        boolean added = false;\n        //Search empty space in groupnames\n        for(short i=0;i\u003clength;i++)\n        //@ invariant APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 0 \u003c= i;\n        {\n            //@ open [1/2]valid();\n            short item = emptyGroups[i];\n            //@close [1/2]valid();\n            //If groupname space empty and groupname not stored\n            if(item == 0 \u0026\u0026 added==false){\n                JCSystem.beginTransaction();\n                added = true;\n\n  \t\t//@open valid();\n                //Mark space used\n                emptyGroups[i] = 1;\n                //Copy groupname date in empty space groupnames\n                Util.arrayCopy(abuffer,(short)ISO7816.OFFSET_CDATA,groupnames,(short)(i * GROUPNAME_LENGTH),(short) GROUPNAME_LENGTH);\n                //@close valid();\n                JCSystem.commitTransaction();\n            }\n        }\n       \n        if(added == false){\n            ISOException.throwIt(SW_GROUPBOOK_FULL);\n        }\n    }\n\n    private void addContactToGroup (APDU apdu)\n    //@ requires APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();\n    //@ ensures APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();\n    {\n        byte[] abuffer = apdu.getBuffer();\n\n        if((short)abuffer[ISO7816.OFFSET_LC] != (NAME_LENGTH + GROUPNAME_LENGTH))\n            ISOException.throwIt(ISO7816.SW_DATA_INVALID);\n\n        //@open [1/2]valid();\n        short length = (short) emptyPhoneNbs.length;\n        //@close [1/2]valid();\n\n        boolean found = false;\n        byte contactnb = 0;\n        //Search each record in phoneNbs\n        for(short i=0;i\u003clength;i++)\n        //@ invariant APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 i \u003e= 0 \u0026*\u0026 0 \u003c= contactnb \u0026*\u0026 contactnb \u003c= 20;\n        {\n            //@ open [1/2]valid();\n            //Match contact name from phoneNbs and incoming apdu\n            short equal = Util.arrayCompare(abuffer, (short)ISO7816.OFFSET_CDATA, phoneNbs, (short)(i * RECORD_LENGTH), NAME_LENGTH);\n            //@ close [1/2]valid();\n            //If contact not yet found \u0026 record name equals\n            if(found==false \u0026\u0026 equal == 0 ){\n                found = true;\n                //Store index of contactrecord\n                contactnb = (byte)(short)(i+1);\n            }\n        }\n\n        if(found == false)\n            ISOException.throwIt(SW_PERSON_NOT_FOUND);\n\n        //@open [1/2]valid();\n        short g_length = (short) emptyGroups.length;\n        //@close [1/2]valid();\n\n        boolean g_found = false;\n        boolean added = false;\n\n        //Search for group in groupnames\n        for(short i=0;i\u003cg_length;i++)\n        //@ invariant APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 i \u003e= 0;\n        {\n            //@ open [1/2]valid();\n            //Match groupname of groupnames and incoming apdu\n            short equal = Util.arrayCompare(abuffer, (short)(ISO7816.OFFSET_CDATA + NAME_LENGTH), groupnames, (short)(i * GROUPNAME_LENGTH), GROUPNAME_LENGTH);\n            //@ close [1/2]valid();\n            //If group not found \u0026 groupname equals\n            if(g_found==false \u0026\u0026 equal == 0 ){\n                g_found = true;\n\n                //begin and end of nbs in groupnbs for searched group\n                short begin = (short)(i * GROUPNUMBERS_LENGTH);\n                short end = (short)(begin + GROUPNUMBERS_LENGTH);\n\n                //Search empty contactnb-space in space of groupname in groupnbs\n                for(short a=begin;a\u003cend;a++)\n                //@ invariant APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 a \u003e= 0;\n                {\n                    //@ open [1/2]valid();\n                    byte openplace = groupnbs[a];\n                    //@ close groupnbs_element(0,openplace,openplace);\n                    //@ array_slice_deep_close(groupnbs,a,groupnbs_element,0);\n                    //@ close [1/2]valid();\n                    //If contact not yet added \u0026 empty space found\n                    if(added == false \u0026\u0026 openplace == 0){\n                        JCSystem.beginTransaction();\n                        added = true;\n                        //@ open valid();\n                        //Write contactnb in empty space\n                        groupnbs[a] = contactnb;\n                        //@ close groupnbs_element(0,contactnb,contactnb);\n                        //@ close valid();\n                        JCSystem.commitTransaction();\n                    }\n                }\n            }\n        }\n\n        if(g_found == false)\n            ISOException.throwIt(SW_GROUP_NOT_FOUND);\n        if(added == false)\n            ISOException.throwIt(SW_GROUP_FULL);\n    }\n\n    private void removeContactFromGroup (APDU apdu)\n    //@ requires APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();\n    //@ ensures APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();\n    {\n        byte[] abuffer = apdu.getBuffer();\n\n        if((short)abuffer[ISO7816.OFFSET_LC] != (NAME_LENGTH + GROUPNAME_LENGTH))\n            ISOException.throwIt(ISO7816.SW_DATA_INVALID);\n\n        //@open [1/2]valid();\n        short length = (short) emptyPhoneNbs.length;\n        //@close [1/2]valid();\n\n        boolean found = false;\n        byte contactnb = 0;\n        //Search each record in phoneNbs\n        for(short i=0;i\u003clength;i++)\n        //@ invariant APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 i \u003e= 0;\n        {\n            //@ open [1/2]valid();\n            //Match contact name in phoneNbs and incoming apdu\n            short equal = Util.arrayCompare(abuffer, (short)ISO7816.OFFSET_CDATA, phoneNbs, (short)(i * RECORD_LENGTH), NAME_LENGTH);\n            //@ close [1/2]valid();\n            //If record not yet found \u0026 contact name equals\n            if(found==false \u0026\u0026 equal == 0 ){\n                found = true;\n                //Store index nb of contact in phoneNbs into contactnb\n                contactnb = (byte)(short)(i+1);\n            }\n        }\n\n        if(found == false)\n            ISOException.throwIt(SW_PERSON_NOT_FOUND);\n\n        //@open [1/2]valid();\n        short g_length = (short) emptyGroups.length;\n        //@close [1/2]valid();\n\n        boolean g_found = false;\n\n        //Search for group in groupnames\n        for(short i=0;i\u003cg_length;i++)\n        //@ invariant APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 i \u003e= 0;\n        {\n            //@ open [1/2]valid();\n            //Match groupname in groupnames and incoming apdu\n            short equal = Util.arrayCompare(abuffer, (short)(ISO7816.OFFSET_CDATA + NAME_LENGTH), groupnames, (short)(i * GROUPNAME_LENGTH), GROUPNAME_LENGTH);\n            //@ close [1/2]valid();\n            //If group not yet found \u0026 groupname equals\n            if(g_found==false \u0026\u0026 equal == 0 ){\n                g_found = true;\n\n                //begin and end of nbs in groupnbs of searched group\n                short begin = (short)(i * GROUPNUMBERS_LENGTH);\n                short end = (short)(begin + GROUPNUMBERS_LENGTH);\n\n                //Search contactnb in space of groupname in groupnbs\n                for(short a=begin;a\u003cend;a++)\n                //@ invariant APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 a \u003e= 0;\n                {\n                    //@ open [1/2]valid();\n                    byte contactequal = groupnbs[a];\n                    //@ close groupnbs_element(0,contactequal,contactequal);\n                    //@ array_slice_deep_close(groupnbs,a,groupnbs_element,0);\n                    //@ close [1/2]valid();\n                    //If calculated contactnb en contactnb in groupnbs match\n                    if(contactequal == contactnb){\n                        JCSystem.beginTransaction();\n                        //@ open valid();\n                        //Erase contactnb\n                        groupnbs[a] = (byte)0;\n                        //@ close groupnbs_element(0,0,0);\n                        //@ array_slice_deep_close(groupnbs,a,groupnbs_element,0);\n                        //@ close valid();\n                        JCSystem.commitTransaction();\n                    }\n                }\n            }\n        }\n\n        if(g_found == false)\n            ISOException.throwIt(SW_GROUP_NOT_FOUND);\n    }\n\n    private void deleteGroup (APDU apdu)\n    //@ requires APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();\n    //@ ensures APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();\n    {\n         byte[] abuffer = apdu.getBuffer();\n\n        if((short)abuffer[ISO7816.OFFSET_LC] != GROUPNAME_LENGTH)\n            ISOException.throwIt(ISO7816.SW_DATA_INVALID);\n\n\t//@open [1/2]valid();\n        short length = (short) emptyGroups.length;\n        //@close [1/2]valid();\n\n        //Search for group in groupnames\n        for(short i=0;i\u003clength;i++)\n        //@ invariant APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 0 \u003c= i;\n        {\n            //@ open [1/2]valid();\n            short item = emptyGroups[i];\n            //@close [1/2]valid();\n            //If groupname stored on index\n            if(item == 1){\n                //@ open [1/2]valid();\n                //Match groupname in groupnames and incoming apdu\n                short equal = (short)Util.arrayCompare(abuffer, (short)ISO7816.OFFSET_CDATA, groupnames, (short)(i * GROUPNAME_LENGTH), GROUPNAME_LENGTH);\n                //@ close [1/2]valid();\n                //If groupname matches\n                if(equal == 0){\n                    JCSystem.beginTransaction();\n                    //@ open valid();\n                    //Mark space in groupnames empty\n                    emptyGroups[i] = 0;\n                    //Erase groupname in groupnames\n                    Util.arrayCopy(zeros,(short)0,groupnames,(short)(i * GROUPNAME_LENGTH),(short) GROUPNAME_LENGTH);\n                    //@ close valid();\n                    short begin = (short)(i * GROUPNUMBERS_LENGTH);\n                    short end = (short)(begin + GROUPNUMBERS_LENGTH);\n                    //Erase contactnbs in contactnb-space in space of groupname in groupnbs\n                    for(short a = begin; a \u003c end; a++)\n                    //@ invariant begin \u003c= a \u0026*\u0026 valid();\n                    {\n                        //@ open valid();\n                        groupnbs[a] = (byte)0;\n                        //@ close groupnbs_element(0,0,0);\n                        //@ array_slice_deep_close(groupnbs,a,groupnbs_element,0);\n                        //@ close valid();\n                    }\n                    JCSystem.commitTransaction();\n                }\n            }\n        }\n    }\n\n    private void searchInGroup (APDU apdu)\n    //@ requires APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();\n    //@ ensures APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();\n    {\n        byte[] abuffer = apdu.getBuffer();\n\n        if(abuffer[ISO7816.OFFSET_LC] != GROUPNAME_LENGTH + NAME_LENGTH)\n            ISOException.throwIt(ISO7816.SW_DATA_INVALID);\n\n        //@open [1/2]valid();\n        short length = (short) emptyGroups.length;\n        //@close [1/2]valid();\n\n        boolean found = false;\n        //Search group in groupnames\n        for(short i=0;i\u003clength;i++)\n        //@ invariant APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 i \u003e= 0;\n        {\n            //@ open [1/2]valid();\n            short item = emptyGroups[i];\n            //@close [1/2]valid();\n            //If index in groupnames not empty\n            if(item == 1){\n                //@ open [1/2]valid();\n                //Match groupname in groupnames and incoming apdu\n                short equal = (short)Util.arrayCompare(abuffer, (short)ISO7816.OFFSET_CDATA, groupnames, (short)(i * GROUPNAME_LENGTH), GROUPNAME_LENGTH);\n                //@ close [1/2]valid();\n                //If groupname matches\n                if(equal == 0){\n\n                    //begin and end of nbs in groupnbs of searched group\n                    short begin = (short)(i * GROUPNUMBERS_LENGTH);\n                    short end = (short)(begin + GROUPNUMBERS_LENGTH);\n                    //Search contact in space of groupname in groupnbs\n                    for(short a=begin;a\u003cend;a++)\n                    //@ invariant APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 a \u003e= 0;\n                    {\n                        //@ open [1/2]valid();\n                        byte contactnb = groupnbs[a];\n                        //@ close groupnbs_element(0,contactnb,contactnb);\n                        //@ array_slice_deep_close(groupnbs,a,groupnbs_element,0);\n                        //@ close [1/2]valid();\n                        //If contactnb on index of groupnbs contains contactnb en contact not found\n                        if(contactnb \u003e (byte)0 \u0026\u0026 found == false){\n                            //@ open [1/2]valid();\n                            //Match contactname in phoneNbs and incoming apdu\n                            //contact in phoneNbs can be found by contactnb (contactnb = index contact in phoneNbs)\n                            short same_name = (short)Util.arrayCompare(abuffer, (short)(ISO7816.OFFSET_CDATA + GROUPNAME_LENGTH), phoneNbs, (short)((contactnb-1) * RECORD_LENGTH), NAME_LENGTH);\n                            //@ close [1/2]valid();\n                            //If contactname matches send contact phone nb\n                            if(same_name == 0){\n                                found = true;\n                                apdu.setOutgoing();\n                                apdu.setOutgoingLength(NR_LENGTH);\n                                //@ open [1/2]valid();\n                                apdu.sendBytesLong(phoneNbs, (short)(((contactnb-1) * RECORD_LENGTH) + NAME_LENGTH), NR_LENGTH);\n                                //@ close [1/2]valid();\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if(found == false)\n            ISOException.throwIt(SW_PERSON_NOT_FOUND);\n    }\n\n    private void filterContacts(APDU apdu)\n    //@ requires APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();\n    //@ ensures APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();\n    {\n        byte[] abuffer = apdu.getBuffer();\n\n        short filterlength = (short)(abuffer[ISO7816.OFFSET_LC] \u0026 0xff);\n        if(filterlength \u003e NAME_LENGTH)\n            ISOException.throwIt(ISO7816.SW_DATA_INVALID);\n\n        //@open [1/2]valid();\n        short length = (short) emptyPhoneNbs.length;\n        //@close [1/2]valid();\n        boolean found = false;\n\n        //index of filteredNames\n        short index = (short)0;\n        //@ close filter_index(index);\n        //Loop to fetch all filtered names\n        //match every record in phoneNbs\n        for(short i=0;i\u003clength;i++)\n        //@ invariant APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 i \u003e= 0 \u0026*\u0026 filter_index(index);\n        {\n            //@ open [1/2]valid();\n            short item = emptyPhoneNbs[i];\n            //@close [1/2]valid();\n            //If phoneNbs record not empty\n            if(item == 1){\n            \t//@ open [1/2]valid();\n                //Match contactname with filter on filterlength\n            \tshort compare = Util.arrayCompare(abuffer, (short)ISO7816.OFFSET_CDATA, phoneNbs, (short)(i * RECORD_LENGTH), filterlength);\n            \t//@ close [1/2]valid();\n                //If filter matches\n                if(compare == 0){\n                    found = true;\n                    JCSystem.beginTransaction();\n                    //@ open valid();\n                    //@ open filter_index(index);\n                    if(i \u003e 0 \u0026\u0026 index \u003c 19){\n                    \tindex++;\n                    }\n                    //Store contact in filteredNames\n                    Util.arrayCopy(phoneNbs, (short)(i*RECORD_LENGTH), filteredNames,(short)(index * NAME_LENGTH), NAME_LENGTH);\n                    //@ close filter_index(index);\n                    //@ close valid();\n                    JCSystem.commitTransaction();\n                }\n            }\n        }\n\n        if(found == false){\n            ISOException.throwIt(SW_NO_PERSON_FOUND);\n        }\n\n        apdu.setOutgoing();\n        //@ open [1/2]filter_index(index);\n        apdu.setOutgoingLength((short)((index + 1)*NAME_LENGTH));\n        //@ close [1/2]filter_index(index);\n        //Loop for sending filtered names\n        for(short i=0;i\u003c=index;i++)\n        //@ invariant APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 i \u003e= 0;\n        {\n            //@ open [1/2]valid();\n            apdu.sendBytesLong(filteredNames, (short)(i*NAME_LENGTH), NAME_LENGTH);\n            //@ close [1/2]valid();\n        }\n\n    }\n}",
        "name": "Addressbook.java",
        "path": "examples/java/Java Card/Addressbook.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/Addressbook.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 62,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires class_init_token(Addressbook.class) \u0026*\u0026 system();"
        },
        {
          "limitHit": false,
          "lineNumber": 63,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 70,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires class_init_token(Addressbook.class);"
        },
        {
          "limitHit": false,
          "lineNumber": 71,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 218,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 219,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 257,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]this.valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 258,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]this.valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 298,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 299,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 385,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 386,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 469,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 470,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 522,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 523,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 589,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 590,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 current_applet(this) \u0026*\u0026 [1/2]valid();"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "// Provably live exception handling with failboxes\r\n\r\n//@ inductive level = level(real r);\r\n//@ fixpoint boolean level_below_all(level l, list\u003clevel\u003e ls) { return ls == nil; }\r\n\r\n//@ fixpoint boolean subbag\u003ct\u003e(list\u003ct\u003e xs, list\u003ct\u003e ys) { return length(remove_all(xs, ys)) + length(xs) == length(ys); }\r\n\r\n//@ predicate obligations(int threadId, list\u003clevel\u003e outerObligations, Failbox failbox, list\u003clevel\u003e obligations);\r\n\r\ninterface FailboxedBlock {\r\n    //@ predicate pre(int thread, list\u003clevel\u003e outerObligations, Failbox failbox);\r\n    //@ predicate post();\r\n    void run();\r\n        //@ requires pre(currentThread, ?obs, ?failbox) \u0026*\u0026 obligations(currentThread, obs, failbox, nil);\r\n        //@ ensures post() \u0026*\u0026 obligations(currentThread, obs, failbox, nil);\r\n}\r\n\r\nclass Failbox {\r\n    public Failbox()\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n    }\r\n    public void enter(FailboxedBlock block)\r\n        //@ requires obligations(currentThread, ?outerObs, ?outerFailbox, ?obs) \u0026*\u0026 block.pre(currentThread, append(outerObs, obs), this);\r\n        //@ ensures obligations(currentThread, outerObs, outerFailbox, obs) \u0026*\u0026 block.post();\r\n    {\r\n        //@ assume(false);\r\n    }\r\n}\r\n\r\nclass LinkedBlockingQueue {\r\n    //@ predicate LinkedBlockingQueue(Failbox failbox, level level, predicate(Object) inv);\r\n    //@ predicate credit();\r\n    //@ predicate debit();\r\n    public LinkedBlockingQueue()\r\n        //@ requires exists\u003cFailbox\u003e(?failbox) \u0026*\u0026 exists\u003clevel\u003e(?level) \u0026*\u0026 exists\u003cpredicate(Object)\u003e(?inv);\r\n        //@ ensures [_]LinkedBlockingQueue(failbox, level, inv);\r\n    {\r\n        //@ assume(false);\r\n    }\r\n    public void put(Object element) throws InterruptedException /*@ ensures true; @*/\r\n        //@ requires [_]LinkedBlockingQueue(?failbox, ?level, ?inv) \u0026*\u0026 inv(element);\r\n        //@ ensures credit();\r\n    {\r\n        //@ assume(false);\r\n    }\r\n    public Object take() throws InterruptedException /*@ ensures true; @*/\r\n        //@ requires obligations(currentThread, ?outerObs, ?failbox, ?obs) \u0026*\u0026 [_]LinkedBlockingQueue(failbox, ?level, ?inv) \u0026*\u0026 credit() \u0026*\u0026 level_below_all(level, append(outerObs, obs)) == true;\r\n        //@ ensures obligations(currentThread, outerObs, failbox, obs) \u0026*\u0026 inv(result);\r\n    {\r\n        //@ assume(false);\r\n    }\r\n    /*@\r\n    lemma void createDebit()\r\n        requires [_]LinkedBlockingQueue(?failbox, ?level, ?inv) \u0026*\u0026 obligations(currentThread, ?outerObs, failbox, ?obs);\r\n        ensures obligations(currentThread, outerObs, failbox, cons(level, obs)) \u0026*\u0026 credit() \u0026*\u0026 debit();\r\n    {\r\n        assume(false);\r\n    }\r\n    lemma void destroyDebit()\r\n        requires\r\n            [_]LinkedBlockingQueue(?failbox, ?level, ?inv) \u0026*\u0026\r\n            obligations(currentThread, ?outerObs, failbox, ?obs) \u0026*\u0026 mem(level, obs) == true \u0026*\u0026\r\n            debit() \u0026*\u0026 credit();\r\n        ensures obligations(currentThread, outerObs, failbox, remove(level, obs));\r\n    {\r\n        assume(false);\r\n    }\r\n    @*/\r\n}\r\n\r\n/*\r\n\r\nWe assume that if a failbox fb fails, eventually all threads running in fb either have their interrupted flag set, or they are propagating an exception.\r\n(TODO: It seems that this assumption holds only if we do not allow user code to call Thread.interrupted() or to catch InterruptedException. (Note: it is fine to\r\ncatch exceptions provided code then forgets that it is inside a failbox. Or, perhaps easier to achieve: disallow try-catch statements when currentFailbox != null.\r\nInstead, enterCatch calls have to be used in that case.))\r\nIt follows that blocking calls inside fb will throw an InterruptedException.\r\n\r\n*/\r\n\r\ninterface FailboxedRunnable {\r\n    //@ predicate pre(Failbox failbox, list\u003clevel\u003e obligations);\r\n    void run();\r\n        //@ requires pre(?failbox, ?obs) \u0026*\u0026 obligations(currentThread, nil, failbox, obs);\r\n        //@ ensures obligations(currentThread, nil, failbox, nil);\r\n}\r\n\r\nclass FailboxedThread {\r\n    //@ predicate FailboxedThread(Failbox failbox, list\u003clevel\u003e obligations);\r\n    public FailboxedThread(FailboxedRunnable runnable)\r\n        //@ requires obligations(currentThread, ?outerObs, ?failbox, ?obs) \u0026*\u0026 runnable.pre(failbox, ?rObs);\r\n        //@ ensures obligations(currentThread, outerObs, failbox, obs) \u0026*\u0026 FailboxedThread(failbox, rObs);\r\n    {\r\n        //@ assume(false);\r\n    }\r\n    public void start()\r\n        /*@\r\n        requires\r\n            FailboxedThread(?failbox, ?thisObs) \u0026*\u0026\r\n            obligations(currentThread, ?outerObs, failbox, ?obs) \u0026*\u0026 subbag(thisObs, obs) == true;\r\n        @*/\r\n        //@ ensures obligations(currentThread, outerObs, failbox, remove_all(thisObs, obs));\r\n    {\r\n        //@ assume(false);\r\n    }\r\n}\r\n\r\n//@ predicate queue_inv(Object o) = true;\r\n\r\nclass MyFailboxedRunnable implements FailboxedRunnable {\r\n    LinkedBlockingQueue queue;\r\n    //@ predicate pre(Failbox fb, list\u003clevel\u003e obs) = this.queue |-\u003e ?queue \u0026*\u0026 [_]queue.LinkedBlockingQueue(?failbox, ?level, queue_inv) \u0026*\u0026 fb == failbox \u0026*\u0026 obs == {level} \u0026*\u0026 queue.debit();\r\n    MyFailboxedRunnable(LinkedBlockingQueue queue)\r\n        //@ requires [_]queue.LinkedBlockingQueue(?failbox, ?level, queue_inv) \u0026*\u0026 queue.debit();\r\n        //@ ensures pre(failbox, {level});\r\n    {\r\n        this.queue = queue;\r\n    }\r\n    public void run()\r\n        //@ requires pre(?failbox, ?obs) \u0026*\u0026 obligations(currentThread, nil, failbox, obs);\r\n        //@ ensures obligations(currentThread, nil, failbox, nil);\r\n    {\r\n        try {\r\n            String hello = \"hello\";\r\n            //@ close queue_inv(hello);\r\n            queue.put(hello);\r\n        } catch (InterruptedException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n        //@ queue.destroyDebit();\r\n    }\r\n}\r\n\r\nclass MyFailboxedBlock implements FailboxedBlock {\r\n    //@ int threadId;\r\n    //@ Failbox failbox;\r\n    //@ predicate pre(int threadId, list\u003clevel\u003e outerObs, Failbox fb) = outerObs == nil \u0026*\u0026 this.threadId |-\u003e threadId \u0026*\u0026 this.failbox |-\u003e fb;\r\n    //@ predicate post() = true;\r\n    MyFailboxedBlock()\r\n        //@ requires exists\u003cFailbox\u003e(?failbox);\r\n        //@ ensures pre(currentThread, nil, failbox);\r\n    {\r\n        //@ this.threadId = currentThread;\r\n        //@ this.failbox = failbox;\r\n    }\r\n    public void run()\r\n        //@ requires pre(currentThread, ?obs, ?failbox) \u0026*\u0026 obligations(currentThread, obs, failbox, nil);\r\n        //@ ensures post() \u0026*\u0026 obligations(currentThread, obs, failbox, nil);\r\n    {\r\n        //@ open pre(_, _, _);\r\n        //@ close exists\u003cFailbox\u003e(failbox);\r\n        //@ level level = level(0);\r\n        //@ close exists\u003clevel\u003e(level);\r\n        //@ close exists\u003cpredicate(Object)\u003e(queue_inv);\r\n        LinkedBlockingQueue queue = new LinkedBlockingQueue();\r\n        //@ queue.createDebit();\r\n        new FailboxedThread(new MyFailboxedRunnable(queue)).start();\r\n        try {\r\n            queue.take();\r\n        } catch (InterruptedException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n        //@ close post();\r\n    }\r\n}\r\n\r\nclass QueueExample {\r\n    public static void main(String[] args)\r\n        //@ requires obligations(currentThread, nil, null, nil);\r\n        //@ ensures obligations(currentThread, nil, null, nil);\r\n    {\r\n        Failbox failbox = new Failbox();\r\n        //@ close exists(failbox);\r\n        failbox.enter(new MyFailboxedBlock());\r\n    }\r\n}\r\n",
        "name": "FailboxedQueueExample.java",
        "path": "examples/java/FailboxedQueueExample.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/FailboxedQueueExample.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre(currentThread, ?obs, ?failbox) \u0026*\u0026 obligations(currentThread, obs, failbox, nil);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post() \u0026*\u0026 obligations(currentThread, obs, failbox, nil);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 19,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 24,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obligations(currentThread, ?outerObs, ?outerFailbox, ?obs) \u0026*\u0026 block.pre(currentThread, append(outerObs, obs), this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 25,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obligations(currentThread, outerObs, outerFailbox, obs) \u0026*\u0026 block.post();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 36,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires exists\u003cFailbox\u003e(?failbox) \u0026*\u0026 exists\u003clevel\u003e(?level) \u0026*\u0026 exists\u003cpredicate(Object)\u003e(?inv);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 37,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [_]LinkedBlockingQueue(failbox, level, inv);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 42,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]LinkedBlockingQueue(?failbox, ?level, ?inv) \u0026*\u0026 inv(element);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 43,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures credit();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 48,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obligations(currentThread, ?outerObs, ?failbox, ?obs) \u0026*\u0026 [_]LinkedBlockingQueue(failbox, ?level, ?inv) \u0026*\u0026 credit() \u0026*\u0026 level_below_all(level, append(outerObs, obs)) == true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 49,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obligations(currentThread, outerObs, failbox, obs) \u0026*\u0026 inv(result);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 85,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre(?failbox, ?obs) \u0026*\u0026 obligations(currentThread, nil, failbox, obs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 86,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obligations(currentThread, nil, failbox, nil);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 92,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obligations(currentThread, ?outerObs, ?failbox, ?obs) \u0026*\u0026 runnable.pre(failbox, ?rObs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 93,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obligations(currentThread, outerObs, failbox, obs) \u0026*\u0026 FailboxedThread(failbox, rObs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 103,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obligations(currentThread, outerObs, failbox, remove_all(thisObs, obs));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 115,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]queue.LinkedBlockingQueue(?failbox, ?level, queue_inv) \u0026*\u0026 queue.debit();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 116,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures pre(failbox, {level});\r"
        },
        {
          "limitHit": false,
          "lineNumber": 121,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre(?failbox, ?obs) \u0026*\u0026 obligations(currentThread, nil, failbox, obs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 122,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obligations(currentThread, nil, failbox, nil);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 141,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires exists\u003cFailbox\u003e(?failbox);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 142,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures pre(currentThread, nil, failbox);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 148,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre(currentThread, ?obs, ?failbox) \u0026*\u0026 obligations(currentThread, obs, failbox, nil);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 149,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post() \u0026*\u0026 obligations(currentThread, obs, failbox, nil);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 170,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obligations(currentThread, nil, null, nil);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 171,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obligations(currentThread, nil, null, nil);\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "final class DoubleMap {\n    //@ predicate valid();\n    \n    DoubleMap()\n        //@ requires obs(?O) \u0026*\u0026 wait_level_below_obs(pair({DoubleMap.class}, 0r), O) == true;\n        //@ ensures obs(O) \u0026*\u0026 valid();\n        //@ terminates;\n    { throw new RuntimeException(); }\n\n    boolean containsKey(double key)\n        //@ requires valid() \u0026*\u0026 obs(?O) \u0026*\u0026 wait_level_below_obs(pair({DoubleMap.class}, 0r), O) == true;\n        //@ ensures valid() \u0026*\u0026 obs(O);\n        //@ terminates;\n    { throw new RuntimeException(); }\n\n    double get(double key)\n        //@ requires valid() \u0026*\u0026 obs(?O) \u0026*\u0026 wait_level_below_obs(pair({DoubleMap.class}, 0r), O) == true;\n        //@ ensures valid() \u0026*\u0026 obs(O);\n        //@ terminates;\n    { throw new RuntimeException(); }\n\n    void put(double key, double value)\n        //@ requires valid() \u0026*\u0026 obs(?O) \u0026*\u0026 wait_level_below_obs(pair({DoubleMap.class}, 0r), O) == true;\n        //@ ensures valid() \u0026*\u0026 obs(O);\n        //@ terminates;\n    { throw new RuntimeException(); }\n}\n\n//@ predicate_ctor Math_inv(Math math)() = math.sqrtCache |-\u003e ?sqrtCache \u0026*\u0026 sqrtCache.valid();\n\nfinal class Math {\n    DoubleMap sqrtCache;\n    Lock sqrtCacheLock;\n\n    /*@\n    predicate valid() =\n        sqrtCacheLock |-\u003e ?lock \u0026*\u0026 lock.lock(Math_inv(this))\n        \u0026*\u0026 wait_level_of(lock) == pair({Math.class}, 0r);\n    @*/\n    \n    Math()\n        //@ requires obs(?O) \u0026*\u0026 wait_level_below_obs(pair({Math.class}, 0r), O) == true;\n        //@ ensures obs(O) \u0026*\u0026 [_]valid();\n        //@ terminates;\n    {\n        //@ wait_level_lt_below_obs(pair({DoubleMap.class}, 0r), pair({Math.class}, 0r), O);\n        sqrtCache = new DoubleMap();\n        //@ close Math_inv(this)();\n        //@ close exists(Math_inv(this));\n        //@ close exists(pair({Math.class}, 0r));\n        sqrtCacheLock = new Lock();\n    }\n    \n    private static double sqrt_(double x)\n        //@ requires true;\n        //@ ensures true;\n        //@ terminates;\n    {\n        throw new RuntimeException();\n    }\n\n    double sqrt(double x)\n        //@ requires [_]valid() \u0026*\u0026 obs(?O) \u0026*\u0026 wait_level_below_obs(pair({Math.class}, 0r), O) == true;\n        //@ ensures obs(O);\n        //@ terminates;\n    {\n        return sqrt_(x);\n    }\n\n    double sqrtCached(double x)\n        //@ requires [_]valid() \u0026*\u0026 obs(?O) \u0026*\u0026 wait_level_below_obs(pair({Math.class}, 0r), O) == true;\n        //@ ensures obs(O);\n        //@ terminates;\n    {\n        //@ wait_level_lt_below_obs(pair({DoubleMap.class}, 0r), pair({Math.class}, 0r), O);\n        sqrtCacheLock.acquire();\n        //@ open Math_inv(this)();\n        if (!sqrtCache.containsKey(x))\n            sqrtCache.put(x, sqrt_(x));\n        double result = sqrtCache.get(x);\n        //@ close Math_inv(this)();\n        sqrtCacheLock.release();\n        return result;\n    }\n}\n\nclass Main {\n    static void main(double x)\n        //@ requires obs(?O) \u0026*\u0026 wait_level_below_obs(pair({Main.class}, 0r), O) == true;\n        //@ ensures obs(O);\n        //@ terminates;\n    {\n        //@ wait_level_lt_below_obs(pair({Math.class}, 0r), pair({Main.class}, 0r), O);\n        Math math = new Math();\n        math.sqrtCached(x);\n    }\n}\n",
        "name": "SqrtCache.java",
        "path": "examples/java/termination/SqrtCache.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/termination/SqrtCache.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obs(?O) \u0026*\u0026 wait_level_below_obs(pair({DoubleMap.class}, 0r), O) == true;"
        },
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs(O) \u0026*\u0026 valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid() \u0026*\u0026 obs(?O) \u0026*\u0026 wait_level_below_obs(pair({DoubleMap.class}, 0r), O) == true;"
        },
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid() \u0026*\u0026 obs(O);"
        },
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid() \u0026*\u0026 obs(?O) \u0026*\u0026 wait_level_below_obs(pair({DoubleMap.class}, 0r), O) == true;"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid() \u0026*\u0026 obs(O);"
        },
        {
          "limitHit": false,
          "lineNumber": 22,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid() \u0026*\u0026 obs(?O) \u0026*\u0026 wait_level_below_obs(pair({DoubleMap.class}, 0r), O) == true;"
        },
        {
          "limitHit": false,
          "lineNumber": 23,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid() \u0026*\u0026 obs(O);"
        },
        {
          "limitHit": false,
          "lineNumber": 41,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obs(?O) \u0026*\u0026 wait_level_below_obs(pair({Math.class}, 0r), O) == true;"
        },
        {
          "limitHit": false,
          "lineNumber": 42,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs(O) \u0026*\u0026 [_]valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 54,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 55,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 62,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid() \u0026*\u0026 obs(?O) \u0026*\u0026 wait_level_below_obs(pair({Math.class}, 0r), O) == true;"
        },
        {
          "limitHit": false,
          "lineNumber": 63,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs(O);"
        },
        {
          "limitHit": false,
          "lineNumber": 70,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid() \u0026*\u0026 obs(?O) \u0026*\u0026 wait_level_below_obs(pair({Math.class}, 0r), O) == true;"
        },
        {
          "limitHit": false,
          "lineNumber": 71,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs(O);"
        },
        {
          "limitHit": false,
          "lineNumber": 88,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obs(?O) \u0026*\u0026 wait_level_below_obs(pair({Main.class}, 0r), O) == true;"
        },
        {
          "limitHit": false,
          "lineNumber": 89,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs(O);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class MathImpl {\n    static int ackermannIter(int m, int n)\n        //@ requires 0 \u003c= m \u0026*\u0026 0 \u003c= n \u0026*\u0026 call_perm_rec(currentThread, {MathImpl.class}, (pair_lt)(int_lt, int_lt), pair(m, n));\n        //@ ensures 0 \u003c= result;\n        //@ terminates;\n    {\n        if (m == 0)\n            return n + 1;\n        if (n == 0) {\n            //@ call_perm_rec_weaken(2, pair(m - 1, 1));\n            //@ call_perm_rec_elim(1);\n            //@ consume_call_perm_for(MathImpl.class);\n            return ackermannIter(m - 1, 1);\n        }\n        //@ call_perm_rec_weaken(3, pair(m, n - 1));\n        //@ call_perm_rec_elim(1);\n        //@ consume_call_perm_for(MathImpl.class);\n        int n1 = ackermannIter(m, n - 1);\n        //@ call_perm_rec_weaken(2, pair(m - 1, n1));\n        //@ call_perm_rec_elim(1);\n        //@ consume_call_perm_for(MathImpl.class);\n        return ackermannIter(m - 1, n1);\n    }\n}\n\npublic class Math {\n    public static int ackermann(int m, int n)\n        //@ requires 0 \u003c= m \u0026*\u0026 0 \u003c= n;\n        //@ ensures true;\n        //@ terminates;\n    {\n        //@ produce_call_below_perm_();\n        //@ is_wf_int_lt();\n        //@ is_wf_pair_lt(int_lt, int_lt);\n        //@ call_below_perm__elim_rec(1, {MathImpl.class}, (pair_lt)(int_lt, int_lt), pair(m, n));\n        return MathImpl.ackermannIter(m, n);\n    }\n}\n",
        "name": "Ackermann.java",
        "path": "examples/java/termination/Ackermann.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/termination/Ackermann.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 2,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires 0 \u003c= m \u0026*\u0026 0 \u003c= n \u0026*\u0026 call_perm_rec(currentThread, {MathImpl.class}, (pair_lt)(int_lt, int_lt), pair(m, n));"
        },
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures 0 \u003c= result;"
        },
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires 0 \u003c= m \u0026*\u0026 0 \u003c= n;"
        },
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package iterator.itutil;\r\n\r\nimport iterator.it.*;\r\n\r\npublic class IteratorUtil {\r\n\r\n    public static Object getLast(Iterator iterator)\r\n        //@ requires iterator != null \u0026*\u0026 iterator.valid(?xs);\r\n        //@ ensures iterator.valid(nil) \u0026*\u0026 result == objects_last(xs);\r\n    {\r\n        Object value = null;\r\n        boolean more = iterator.hasNext();\r\n        while (more)\r\n            //@ invariant iterator.valid(?ys) \u0026*\u0026 more == (ys != nil) \u0026*\u0026 objects_last(cons(value,ys)) == objects_last(xs);\r\n        {\r\n            value = iterator.next();\r\n            more = iterator.hasNext();\r\n            //@ switch (ys) { case nil: case cons(y, ys0): }\r\n        }\r\n        return value;\r\n    }\r\n\r\n}\r\n",
        "name": "IteratorUtil.java",
        "path": "examples/java/Iterator/IteratorUtil.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Iterator/IteratorUtil.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires iterator != null \u0026*\u0026 iterator.valid(?xs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures iterator.valid(nil) \u0026*\u0026 result == objects_last(xs);\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "//@ predicate Task(Task task, list\u003cClass\u003e level;) = task.valid(?level0) \u0026*\u0026 level_le({task.getClass()}, level0) \u0026\u0026 level_le(level0, level);\n\ninterface Task {\n\n    //@ predicate valid(list\u003cClass\u003e level);\n    \n    void run();\n        //@ requires obs(?O) \u0026*\u0026 valid(?level) \u0026*\u0026 call_perm(currentThread, level) \u0026*\u0026 wait_level_below_obs(pair(level, 0r), O) == true;\n        //@ ensures obs(O);\n        //@ terminates;\n    \n}\n\n//@ predicate Item(Item item, int scope) = item.validItem(scope) \u0026*\u0026 level_le({item.getClass()}, {ShutdownItem.class}) == true;\n\ninterface Item {\n\n    //@ predicate validItem(int scope);\n    \n    void run();\n        //@ requires obs(nil) \u0026*\u0026 validItem(call_perm_scope_of(currentThread));\n        //@ ensures obs(nil);\n        //@ terminates;\n    \n}\n\nclass ThreadPoolHelper {\n\n    static void work(ThreadPool pool)\n        //@ requires obs(nil) \u0026*\u0026 [_]pool.valid(call_perm_scope_of(currentThread), _) \u0026*\u0026 [_]pool.channel |-\u003e ?channel \u0026*\u0026 channel.credit() \u0026*\u0026 call_perm(currentThread, {ShutdownItem.class});\n        //@ ensures obs(nil);\n        //@ terminates;\n    {\n        //@ open [_]pool.valid(_, ?O);\n        Item item = (Item)pool.channel.receive();\n        //@ open ThreadPool_inv(call_perm_scope_of(currentThread))(item);\n        //@ open Item(item, call_perm_scope_of(currentThread));\n        //@ consume_call_perm_for(item.getClass());\n        item.run();\n    }\n    \n}\n\nfinal class TaskItem implements Item {\n\n    //@ int thread;\n    ThreadPool pool;\n    Task task;\n    //@ list\u003cClass\u003e taskLevel;\n    \n    //@ predicate validItem(int scope) = this.thread |-\u003e ?thread \u0026*\u0026 pool |-\u003e ?pool \u0026*\u0026 [_]pool.valid(scope, _) \u0026*\u0026 [_]pool.channel |-\u003e ?channel \u0026*\u0026 channel.credit() \u0026*\u0026 task |-\u003e ?task \u0026*\u0026 taskLevel |-\u003e ?taskLevel \u0026*\u0026 Task(task, taskLevel) \u0026*\u0026 call_perm(thread, append({TaskItem.class, ShutdownItem.class}, taskLevel)) \u0026*\u0026 call_perm_scope_of(thread) == scope;\n\n    TaskItem(ThreadPool pool, Task task)\n        //@ requires true;\n        //@ ensures this.thread |-\u003e _ \u0026*\u0026 this.pool |-\u003e pool \u0026*\u0026 this.task |-\u003e task \u0026*\u0026 this.taskLevel |-\u003e _;\n        //@ terminates;\n    {\n        this.pool = pool;\n        this.task = task;\n    }\n    \n    void run()\n        //@ requires obs(nil) \u0026*\u0026 validItem(call_perm_scope_of(currentThread));\n        //@ ensures obs(nil);\n        //@ terminates;\n    {\n        //@ open validItem(_);\n        //@ call_perm_transfer(currentThread);\n        //@ call_perm_weaken_and_dup(3);\n        //@ open Task(_, _);\n        Task task = task;\n        //@ assert task.valid(?taskLevel0);\n        //@ level_le_trans({task.getClass()}, taskLevel0, taskLevel);\n        //@ level_lt_cons(ShutdownItem.class, taskLevel);\n        //@ level_le_trans({task.getClass()}, taskLevel, cons(ShutdownItem.class, taskLevel));\n        //@ consume_call_perm_for(task.getClass());\n        //@ call_perm_weaken_and_dup(1);\n        //@ call_perm_weaken(1, taskLevel0);\n        task.run();\n        //@ call_perm_weaken(1, {ShutdownItem.class});\n        ThreadPoolHelper.work(pool);\n    }\n    \n}\n\nfinal class ShutdownItem implements Item {\n\n    //@ int scope;\n    //@ predicate validItem(int scope) = this.scope |-\u003e scope;\n    \n    void run()\n        //@ requires obs(nil) \u0026*\u0026 validItem(_);\n        //@ ensures obs(nil);\n        //@ terminates;\n    {\n    }\n    \n}\n\nfinal class ThreadPoolWorker implements Forkee {\n\n    ThreadPool pool;\n\n    //@ predicate pre(int scope, list\u003cObject\u003e O) = O == nil \u0026*\u0026 pool |-\u003e ?pool \u0026*\u0026 [_]pool.valid(scope, _) \u0026*\u0026 [_]pool.channel |-\u003e ?channel \u0026*\u0026 channel.credit();\n    \n    ThreadPoolWorker(ThreadPool pool)\n        //@ requires true;\n        //@ ensures this.pool |-\u003e pool;\n        //@ terminates;\n    {\n        this.pool = pool;\n    }\n    \n    void run()\n        //@ requires pre(call_perm_scope_of(currentThread), ?O) \u0026*\u0026 obs(O);\n        //@ ensures obs(nil);\n        //@ terminates;\n    {\n        //@ produce_call_below_perm_();\n        //@ call_below_perm__elim(1, {ShutdownItem.class});\n        ThreadPoolHelper.work(pool);\n    }\n    \n}\n\n//@ predicate wait_level_range(list\u003cClass\u003e termLevel, real a, real b) = a \u003c b;\n\n//@ predicate_ctor ThreadPool_inv(int scope)(Object object) = Item(^object, scope);\n\n//@ fixpoint boolean object_wait_level_within_range(list\u003cClass\u003e termLevel, real a, real b, Object object) { return fst(wait_level_of(object)) == termLevel \u0026\u0026 a \u003c snd(wait_level_of(object)) \u0026\u0026 snd(wait_level_of(object)) \u003c b; }\n\n//@ fixpoint boolean object_wait_levels_within_range(list\u003cClass\u003e termLevel, real a, real b, list\u003cObject\u003e O) { return forall(O, (object_wait_level_within_range)(termLevel, a, b)); }\n\n/*@\n\nlemma void wait_level_below_object_wait_levels_within_range(list\u003cClass\u003e termLevel, real a, real b, list\u003cObject\u003e O)\n    requires object_wait_levels_within_range(termLevel, a, b, O) == true;\n    ensures wait_level_below_obs(pair(termLevel, a), O) == true;\n{\n    if (!wait_level_below_obs(pair(termLevel, a), O)) {\n        Object o = not_forall(O, (wait_level_below_object)(pair(termLevel, a)));\n        forall_elim(O, (object_wait_level_within_range)(termLevel, a, b), o);\n        assert false;\n    }\n}\n\n@*/\n\nfinal class ThreadPool {\n\n    //@ int callPermScope;\n    Channel channel;\n\n    //@ predicate valid(int callPermScope, list\u003cObject\u003e O) = [_]this.callPermScope |-\u003e callPermScope \u0026*\u0026 channel |-\u003e ?channel \u0026*\u0026 [_]channel.channel(ThreadPool_inv(callPermScope)) \u0026*\u0026 O == {channel};\n    \n    public ThreadPool()\n        //@ requires obs(?O) \u0026*\u0026 wait_level_below_obs(pair({ThreadPool.class}, 0r), O) == true \u0026*\u0026 wait_level_range(?termLevel, ?a, ?b) \u0026*\u0026 level_lt({ThreadPool.class}, termLevel) == true;\n        //@ ensures [_]valid(call_perm_scope_of(currentThread), ?Or) \u0026*\u0026 obs(append(Or, O)) \u0026*\u0026 object_wait_levels_within_range(termLevel, a, b, Or) == true;\n        //@ terminates;\n    {\n        //@ open wait_level_range(_, _, _);\n        //@ close exists(pair(ThreadPool_inv(call_perm_scope_of(currentThread)), pair(termLevel, (a + b) / 2)));\n        channel = new Channel();\n        //@ leak channel |-\u003e _;\n        //@ channel.create_obs(1);\n        //@ produce_call_below_perm_();\n        ThreadPoolWorker worker = new ThreadPoolWorker(this);\n        //@ callPermScope = call_perm_scope_of(currentThread);\n        //@ close worker.pre(call_perm_scope_of(currentThread), nil);\n        //@ open repeat(_, _, _);\n        //@ open repeat(_, _, _);\n        //@ close exists(cons\u003cObject\u003e(channel, O));\n        //@ produce_call_below_perm_();\n        //@ call_below_perm__elim(1, {ThreadPoolWorker.class});\n        ThreadUtil.fork(worker);\n    }\n\n    public void addTask(Task task)\n        //@ requires obs(?O) \u0026*\u0026 [_]valid(?scope, ?Op) \u0026*\u0026 Task(task, ?taskLevel) \u0026*\u0026 call_perm(?thread, cons(ThreadPool.class, taskLevel)) \u0026*\u0026 wait_level_below_obs(pair({ThreadPool.class}, 0r), O) == true \u0026*\u0026 call_perm_scope_of(thread) == scope;\n        //@ ensures obs(O);\n        //@ terminates;\n    {\n        TaskItem item = new TaskItem(this, task);\n        //@ item.thread = thread;\n        //@ item.taskLevel = taskLevel;\n        //@ channel.create_obs(1);\n        //@ level_append_mono_l({TaskItem.class, ShutdownItem.class}, {ThreadPool.class}, taskLevel);\n        //@ call_perm_weaken(1, append({TaskItem.class, ShutdownItem.class}, taskLevel));\n        //@ call_perm_transfer(thread);\n        //@ close item.validItem(scope);\n        //@ close Item(item, scope);\n        //@ close ThreadPool_inv(scope)(item);\n        channel.send(item);\n        //@ open repeat(_, _, _);\n        //@ open repeat(_, _, _);\n        //@ channel.destroy_ob();\n    }\n\n    public void shutDown()\n        //@ requires [_]valid(?scope, ?Op) \u0026*\u0026 exists\u003clist\u003cObject\u003e \u003e(?O) \u0026*\u0026 obs(append(Op, O)) \u0026*\u0026 wait_level_below_obs(pair({ThreadPool.class}, 0r), append(Op, O)) == true;\n        //@ ensures obs(O);\n        //@ terminates;\n    {\n        ShutdownItem item = new ShutdownItem();\n        //@ item.scope = scope;\n        //@ close item.validItem(scope);\n        //@ close Item(item, scope);\n        //@ close ThreadPool_inv(scope)(item);\n        channel.send(item);\n        //@ channel.destroy_ob();\n    }\n    \n}\n\nfinal class MyTask implements Task {\n\n    //@ predicate valid(list\u003cClass\u003e level) = level == {MyTask.class};\n    \n    MyTask()\n        //@ requires true;\n        //@ ensures Task(this, {MyTask.class});\n        //@ terminates;\n    {\n        //@ close valid({MyTask.class});\n        //@ close Task(this, {MyTask.class});\n    }\n    \n    void run()\n        //@ requires obs(?O) \u0026*\u0026 valid(?level) \u0026*\u0026 call_perm(currentThread, level) \u0026*\u0026 wait_level_below_obs(pair(level, 0r), O) == true;\n        //@ ensures obs(O);\n        //@ terminates;\n    {\n    }\n    \n}\n\nclass MyModule {\n\n    static void doWork(ThreadPool pool)\n        //@ requires obs(?O) \u0026*\u0026 [_]pool.valid(call_perm_scope_of(currentThread), _) \u0026*\u0026 wait_level_below_obs(pair({MyModule.class}, 0r), O) == true;\n        //@ ensures obs(O);\n        //@ terminates;\n    {\n        //@ produce_call_below_perm_();\n        //@ call_below_perm__elim(2, {ThreadPool.class, MyTask.class});\n        //@ wait_level_lt_below_obs(pair({ThreadPool.class}, 0r), pair({MyModule.class}, 0r), O);\n        pool.addTask(new MyTask());\n        pool.addTask(new MyTask());\n    }\n    \n}\n\nclass Main {\n\n    static void main()\n        //@ requires obs(?O) \u0026*\u0026 wait_level_below_obs(pair({Main.class}, 0r), O) == true;\n        //@ ensures obs(O);\n        //@ terminates;\n    {\n        //@ wait_level_lt_below_obs(pair({ThreadPool.class}, 0r), pair({Main.class}, 0r), O);\n        //@ close wait_level_range({Main.class}, -1, 0);\n        ThreadPool pool = new ThreadPool();\n        //@ assert [_]pool.valid(call_perm_scope_of(currentThread), ?Op);\n        //@ wait_level_lt_below_obs(pair({MyModule.class}, 0r), pair({Main.class}, 0r), O);\n        //@ wait_level_below_object_wait_levels_within_range({Main.class}, -1, 0, Op);\n        //@ wait_level_lt_below_obs(pair({MyModule.class}, 0r), pair({Main.class}, -1r), Op);\n        //@ forall_append(Op, O, (wait_level_below_object)(pair({MyModule.class}, 0r)));\n        MyModule.doWork(pool);\n        //@ close exists(O);\n        //@ wait_level_lt_below_obs(pair({ThreadPool.class}, 0r), pair({Main.class}, -1r), Op);\n        //@ forall_append(Op, O, (wait_level_below_object)(pair({ThreadPool.class}, 0r)));\n        pool.shutDown();\n    }\n    \n}\n",
        "name": "ThreadPool.java",
        "path": "examples/java/termination/ThreadPool.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/termination/ThreadPool.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obs(?O) \u0026*\u0026 valid(?level) \u0026*\u0026 call_perm(currentThread, level) \u0026*\u0026 wait_level_below_obs(pair(level, 0r), O) == true;"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs(O);"
        },
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obs(nil) \u0026*\u0026 validItem(call_perm_scope_of(currentThread));"
        },
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs(nil);"
        },
        {
          "limitHit": false,
          "lineNumber": 29,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obs(nil) \u0026*\u0026 [_]pool.valid(call_perm_scope_of(currentThread), _) \u0026*\u0026 [_]pool.channel |-\u003e ?channel \u0026*\u0026 channel.credit() \u0026*\u0026 call_perm(currentThread, {ShutdownItem.class});"
        },
        {
          "limitHit": false,
          "lineNumber": 30,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs(nil);"
        },
        {
          "limitHit": false,
          "lineNumber": 53,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 54,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures this.thread |-\u003e _ \u0026*\u0026 this.pool |-\u003e pool \u0026*\u0026 this.task |-\u003e task \u0026*\u0026 this.taskLevel |-\u003e _;"
        },
        {
          "limitHit": false,
          "lineNumber": 62,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obs(nil) \u0026*\u0026 validItem(call_perm_scope_of(currentThread));"
        },
        {
          "limitHit": false,
          "lineNumber": 63,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs(nil);"
        },
        {
          "limitHit": false,
          "lineNumber": 91,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obs(nil) \u0026*\u0026 validItem(_);"
        },
        {
          "limitHit": false,
          "lineNumber": 92,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs(nil);"
        },
        {
          "limitHit": false,
          "lineNumber": 106,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 107,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures this.pool |-\u003e pool;"
        },
        {
          "limitHit": false,
          "lineNumber": 114,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires pre(call_perm_scope_of(currentThread), ?O) \u0026*\u0026 obs(O);"
        },
        {
          "limitHit": false,
          "lineNumber": 115,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs(nil);"
        },
        {
          "limitHit": false,
          "lineNumber": 156,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obs(?O) \u0026*\u0026 wait_level_below_obs(pair({ThreadPool.class}, 0r), O) == true \u0026*\u0026 wait_level_range(?termLevel, ?a, ?b) \u0026*\u0026 level_lt({ThreadPool.class}, termLevel) == true;"
        },
        {
          "limitHit": false,
          "lineNumber": 157,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [_]valid(call_perm_scope_of(currentThread), ?Or) \u0026*\u0026 obs(append(Or, O)) \u0026*\u0026 object_wait_levels_within_range(termLevel, a, b, Or) == true;"
        },
        {
          "limitHit": false,
          "lineNumber": 178,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obs(?O) \u0026*\u0026 [_]valid(?scope, ?Op) \u0026*\u0026 Task(task, ?taskLevel) \u0026*\u0026 call_perm(?thread, cons(ThreadPool.class, taskLevel)) \u0026*\u0026 wait_level_below_obs(pair({ThreadPool.class}, 0r), O) == true \u0026*\u0026 call_perm_scope_of(thread) == scope;"
        },
        {
          "limitHit": false,
          "lineNumber": 179,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs(O);"
        },
        {
          "limitHit": false,
          "lineNumber": 199,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?scope, ?Op) \u0026*\u0026 exists\u003clist\u003cObject\u003e \u003e(?O) \u0026*\u0026 obs(append(Op, O)) \u0026*\u0026 wait_level_below_obs(pair({ThreadPool.class}, 0r), append(Op, O)) == true;"
        },
        {
          "limitHit": false,
          "lineNumber": 200,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs(O);"
        },
        {
          "limitHit": false,
          "lineNumber": 219,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 220,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Task(this, {MyTask.class});"
        },
        {
          "limitHit": false,
          "lineNumber": 228,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obs(?O) \u0026*\u0026 valid(?level) \u0026*\u0026 call_perm(currentThread, level) \u0026*\u0026 wait_level_below_obs(pair(level, 0r), O) == true;"
        },
        {
          "limitHit": false,
          "lineNumber": 229,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs(O);"
        },
        {
          "limitHit": false,
          "lineNumber": 239,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obs(?O) \u0026*\u0026 [_]pool.valid(call_perm_scope_of(currentThread), _) \u0026*\u0026 wait_level_below_obs(pair({MyModule.class}, 0r), O) == true;"
        },
        {
          "limitHit": false,
          "lineNumber": 240,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs(O);"
        },
        {
          "limitHit": false,
          "lineNumber": 255,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires obs(?O) \u0026*\u0026 wait_level_below_obs(pair({Main.class}, 0r), O) == true;"
        },
        {
          "limitHit": false,
          "lineNumber": 256,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures obs(O);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "/*\r\nThe specification below proves 2.1, 2.2 and 2.3 (see comments below for more details).\r\n*/\r\n\r\n\r\n/*=== lemmas/methods related to 2.1 start here ===*/\r\n\r\n/* key idea: \r\n  - fixpoint \"step\" represents one step (returns none if no further reduction is possible)\r\n  - \"nsteps\" represents n steps\r\n  - if reduction terminates, then (a) there exists a number n such that the resulting term can be reached in n steps from the initial term t\r\n    and (b) the resulting term cannot be reduced any further\r\n*/\r\n\r\n/*@\r\ninductive term = K | S | apply(term, term);\r\n\r\nfixpoint option\u003cterm\u003e step(term t) {\r\n  switch(t) {\r\n    case K: return none; // value\r\n    case S: return none; // value\r\n    case apply(left, right):\r\n      return switch(left) {\r\n        case K: return switch(step(right)) {\r\n          case none: return none; // value\r\n          case some(reduced): return some(apply(K, reduced)); // rec\r\n        };\r\n        case S: return switch(step(right)) {\r\n          case none: return none; // value\r\n          case some(reduced): return some(apply(S, reduced)); // rec\r\n        };\r\n        case apply(leftleft, leftright):\r\n          return switch(leftleft) {\r\n            case K: \r\n              return switch(step(leftright)) {\r\n                case none: return switch(step(right)) { \r\n                  case none: return some(leftright); // step\r\n                  case some(reduced): return some(apply(apply(K, leftright), reduced)); // rec\r\n                };\r\n                case some(reduced): return some(apply(apply(K, reduced), right)); // rec\r\n              };\r\n            case S: return switch(step(leftright)) {\r\n                case none: return switch(step(right)) { \r\n                  case none: return none; // value\r\n                  case some(reduced): return some(apply(apply(S, leftright), reduced)); // rec\r\n                };\r\n                case some(reduced): return some(apply(apply(S, reduced), right)); // rec\r\n              };\r\n            case apply(leftleftleft, leftleftright):\r\n              return switch(leftleftleft) {\r\n                case K: return switch(step(left)) {\r\n                      case none: return switch(step(right)) {\r\n                        case none: return none;\r\n                        case some(reduced): return some(apply(left, reduced));\r\n                      };\r\n                      case some(reduced): return some(apply(reduced, right));\r\n                    };\r\n                case S: return switch(step(leftleftright)) {\r\n                  case none: return switch(step(leftright)) {\r\n                    case none: return switch(step(right)) {\r\n                      case none: return some(apply(apply(leftleftright, right), apply(leftright, right))); // step\r\n                      case some(reduced): return some(apply(apply(apply(S, leftleftright), leftright), reduced)); // rec\r\n                    };\r\n                    case some(reduced): return some(apply(apply(apply(S, leftleftright), reduced), right)); // rec\r\n                  };\r\n                  case some(reduced): return some(apply(apply(apply(S, reduced), leftright), right)); // rec\r\n                };\r\n                case apply(leftleftleftleft, leftleftleftright): //((((llll, lllr), llr), lr), r)\r\n                  return switch(step(left)) {\r\n                      case none: return switch(step(right)) {\r\n                        case none: return none;\r\n                        case some(reduced): return some(apply(left, reduced));\r\n                      };\r\n                      case some(reduced): return some(apply(reduced, right));\r\n                    };\r\n                  };\r\n              };\r\n          };\r\n  }\r\n}\r\n\r\nfixpoint term nsteps(nat n, term t) {\r\n  switch(n) {\r\n    case zero: return t;\r\n    case succ(n0): return switch(step(nsteps(n0, t))) {\r\n      case none: return nsteps(n0, t);\r\n      case some(reduced): return reduced;\r\n    };\r\n  }\r\n}\r\n@*/\r\n\r\n/*@ \r\npredicate term(Term t; term state) =\r\n  t != null \u0026*\u0026 [_]t.type |-\u003e ?type \u0026*\u0026 type == Term.K_TERM || type == Term.S_TERM || type == Term.APPLY_TERM \u0026*\u0026\r\n  type == Term.K_TERM ? \r\n    state == K \r\n    :\r\n    (type == Term.S_TERM ? \r\n      state == S\r\n      :\r\n      (t.left |-\u003e ?first \u0026*\u0026 t.right |-\u003e ?second \u0026*\u0026 first != null \u0026*\u0026 second != null \u0026*\u0026 [_]term(first, ?state1) \u0026*\u0026 [_]term(second, ?state2) \u0026*\u0026 state == apply(state1, state2)));\r\n@*/\r\n\r\nclass Term {\r\n  private static final int K_TERM = 1;\r\n  private static final int S_TERM = 2;\r\n  private static final int APPLY_TERM = 3;\r\n  \r\n  int type; // 1: K, 2: S, 3: apply\r\n  Term left;\r\n  Term right;\r\n  \r\n  Term(int type, Term left, Term right)\r\n    //@ requires true;\r\n    //@ ensures this.type |-\u003e type \u0026*\u0026 this.left |-\u003e left \u0026*\u0026 this.right |-\u003e right;\r\n  {\r\n    this.type = type;\r\n    this.left = left;\r\n    this.right = right;\r\n  }\r\n  \r\n  static Term createK()\r\n    //@ requires true;\r\n    //@ ensures result != null \u0026*\u0026 term(result, K);\r\n  {\r\n    Term res = new Term(1, null, null);\r\n    //@ close term(res, K);\r\n    return res;\r\n  }\r\n  \r\n  static Term createS()\r\n    //@ requires true;\r\n    //@ ensures result != null \u0026*\u0026 term(result, S);\r\n  {\r\n    Term res = new Term(2, null, null);\r\n    //@ close term(res, S);\r\n    return res;\r\n  }\r\n  \r\n  static Term createApply(Term left, Term right)\r\n    //@ requires [_]term(left, ?state1) \u0026*\u0026 [_]term(right, ?state2);\r\n    //@ ensures result != null \u0026*\u0026 [_]term(result, apply(state1, state2));\r\n  {\r\n    //@ open [?f1]term(left, state1);\r\n    //@ close [f1]term(left, state1);\r\n    //@ open [?f2]term(right, state2);\r\n    //@ close [f2]term(right, state2);\r\n    Term res = new Term(3, left, right);\r\n    //@ close [1]term(res, apply(state1, state2));\r\n    return res;\r\n  }\r\n  \r\n  static Term do_step(Term t)\r\n    //@ requires [_]term(t, ?state);\r\n    //@ ensures result == null ? step(state) == none : [_]term(result, ?state2) \u0026*\u0026 step(state) == some(state2);\r\n  {\r\n    if(t.type == K_TERM) {\r\n      return null;\r\n    } else if(t.type == S_TERM) {\r\n      return null;\r\n    } else { // (_, _)\r\n      if(t.left.type == K_TERM || t.left.type == S_TERM) {\r\n        Term reduced = do_step(t.right);\r\n        if(reduced == null) {\r\n          return null;\r\n        } else {\r\n          return createApply(t.left, reduced);\r\n        }\r\n      } else { // ((_, _), _)\r\n        if(t.left.left.type == K_TERM) {\r\n          Term reduced = do_step(t.left.right);\r\n          if(reduced == null) {\r\n            reduced = do_step(t.right);\r\n            if(reduced == null) {\r\n              return t.left.right;\r\n            } else {\r\n              return createApply(t.left, reduced);\r\n            }\r\n          } else {\r\n            return createApply(createApply(t.left.left, reduced), t.right);\r\n          }\r\n        } else if(t.left.left.type == S_TERM) {\r\n          Term reduced = do_step(t.left.right);\r\n          if(reduced == null) {\r\n            reduced = do_step(t.right);\r\n            if(reduced == null) {\r\n              return null;\r\n            } else {\r\n              return createApply(createApply(t.left.left, t.left.right), reduced);\r\n            }\r\n          } else {\r\n            return createApply(createApply(t.left.left, reduced), t.right);\r\n          }\r\n        } else { // (((_, _), _), _)\r\n          if(t.left.left.left.type == K_TERM) {\r\n            Term reduced = do_step(t.left);\r\n            if(reduced == null) {\r\n               reduced = do_step(t.right);\r\n               if(reduced == null) {\r\n                 return null;\r\n               } else {\r\n                 return createApply(t.left, reduced);\r\n               }\r\n            } else {\r\n              return createApply(reduced, t.right);\r\n            }\r\n          } else if(t.left.left.left.type == S_TERM) {\r\n             Term reduced = do_step(t.left.left.right);\r\n             if(reduced == null) {\r\n               reduced = do_step(t.left.right);\r\n               if(reduced == null) {\r\n                 reduced = do_step(t.right);\r\n                 if(reduced == null) {\r\n                   return createApply(createApply(t.left.left.right, t.right), createApply(t.left.right, t.right));\r\n                 } else {\r\n                   return createApply(t.left, reduced);\r\n                 }\r\n               } else {\r\n                  return createApply(createApply(createApply(t.left.left.left, t.left.left.right), reduced), t.right);\r\n               }\r\n             } else {\r\n               return createApply(createApply(createApply(t.left.left.left, reduced), t.left.right), t.right);\r\n             }\r\n          } else { // ((((_, _), _), _))\r\n            Term reduced = do_step(t.left);\r\n            if(reduced == null) {\r\n               reduced = do_step(t.right);\r\n               if(reduced == null) {\r\n                 return null;\r\n               } else {\r\n                 return createApply(t.left, reduced);\r\n               }\r\n            } else {\r\n              return createApply(reduced, t.right);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  static Term reduction(Term t)\r\n    //@ requires [_]term(t, ?state);\r\n    //@ ensures [_]term(result, ?state2) \u0026*\u0026 exists(?n) \u0026*\u0026 nsteps(n, state) == state2 \u0026*\u0026 step(state2) == none;\r\n  {\r\n    //@ nat count = zero;\r\n    Term curr = t;\r\n    while(true) \r\n      //@ invariant [_]term(curr, ?state2) \u0026*\u0026 nsteps(count, state) == state2;\r\n    {\r\n      Term newCur = do_step(curr);\r\n      if(newCur == null) { \r\n        return curr;\r\n        //@ close exists(count);\r\n      }\r\n      //@ count = succ(count); \r\n      curr = newCur;\r\n    }\r\n  }\r\n}\r\n\r\n/*=== lemmas/methods related to 2.2 start here ===*/\r\n/* key idea: \r\n  - if a term does not contain S, then step decreases the size of the term \r\n  - expressed as loop decreases clause in reduction_terminating\r\n*/\r\n\r\n/*@\r\nfixpoint int size(term t) {\r\n  switch(t) {\r\n    case K: return 1;\r\n    case S: return 1;\r\n    case apply(left, right): return size(left) + size(right) + 1;\r\n  }\r\n}\r\n\r\nfixpoint boolean noS(term t) {\r\n  switch(t) {\r\n    case K: return true;\r\n    case S: return false;\r\n    case apply(left, right): return noS(left) \u0026\u0026 noS(right);\r\n  }\r\n}\r\n\r\nlemma_auto(size(t)) void size_positive(term t) \r\n  requires true;\r\n  ensures 0 \u003c size(t);\r\n{\r\n  switch(t) {\r\n    case K: \r\n    case S:\r\n    case apply(t1, t2): size_positive(t1); size_positive(t2);\r\n  }\r\n}\r\n\r\nlemma void step_preserves_noS(term t)\r\n  requires noS(t) == true;\r\n  ensures switch(step(t)) { case none: return true; case some(reduced): return noS(reduced) == true; };\r\n{\r\n  switch(t) {\r\n    case K: \r\n    case S: \r\n    case apply(left, right):\r\n      switch(left) {\r\n        case K: switch(step(right)) {\r\n          case none: \r\n          case some(reduced): step_preserves_noS(right); // rec\r\n        };\r\n        case S: \r\n        case apply(leftleft, leftright):\r\n          switch(leftleft) {\r\n            case K: \r\n              switch(step(leftright)) {\r\n                case none: switch(step(right)) { \r\n                  case none: \r\n                  case some(reduced): step_preserves_noS(right); // rec\r\n                };\r\n                case some(reduced): step_preserves_noS(leftright); // rec\r\n              };\r\n            case S:\r\n            case apply(leftleftleft, leftleftright):\r\n              switch(leftleftleft) {\r\n                case K: switch(step(leftleftright)) {\r\n                    case none: switch(step(leftright)) {\r\n                      case none: switch(step(right)) {\r\n                        case none: \r\n                        case some(reduced): step_preserves_noS(right); \r\n                      };\r\n                      case some(reduced): step_preserves_noS(leftright); // rec\r\n                    };\r\n                    case some(reduced): step_preserves_noS(leftleftright); // rec\r\n                  };\r\n                case S:\r\n                case apply(leftleftleftleft, leftleftleftright): \r\n                  switch(step(left)) {\r\n                    case none: switch(step(right)) {\r\n                      case none: \r\n                      case some(reduced): step_preserves_noS(right); // rec\r\n                      };\r\n                    case some(reduced): step_preserves_noS(left);\r\n                  };\r\n              };\r\n          };\r\n      };\r\n  }\r\n}\r\n\r\nlemma void step_with_noS_decreases_size(term t)\r\n  requires noS(t) == true;\r\n  ensures switch(step(t)) { case none: return true; case some(reduced): return size(reduced) \u003c size(t); };\r\n{\r\n    switch(t) {\r\n    case K: \r\n    case S: \r\n    case apply(left, right):\r\n      switch(left) {\r\n        case K: \r\n          switch(step(right)) {\r\n            case none: \r\n            case some(reduced): step_with_noS_decreases_size(right);\r\n          };\r\n        case S: \r\n        case apply(leftleft, leftright):\r\n          switch(leftleft) {\r\n            case K: \r\n              switch(step(leftright)) {\r\n                case none: switch(step(right)) { \r\n                  case none: some(leftright);\r\n                  case some(reduced): step_with_noS_decreases_size(right);\r\n                };\r\n                case some(reduced): step_with_noS_decreases_size(leftright);\r\n              };\r\n            case S:\r\n            case apply(leftleftleft, leftleftright):\r\n              switch(leftleftleft) {\r\n                case K: switch(step(leftleftright)) {\r\n                    case none: switch(step(leftright)) {\r\n                      case none: switch(step(right)) {\r\n                        case none:                         \r\n                        case some(reduced): step_with_noS_decreases_size(right);\r\n                      };\r\n                      case some(reduced): step_with_noS_decreases_size(leftright);\r\n                    };\r\n                    case some(reduced): step_with_noS_decreases_size(leftleftright);\r\n                  };\r\n                case S: \r\n                case apply(leftleftleftleft, leftleftleftright): \r\n                switch(step(left)) {\r\n                    case none: switch(step(right)) {\r\n                      case none: \r\n                      case some(reduced): step_with_noS_decreases_size(right); // rec\r\n                      };\r\n                    case some(reduced): step_with_noS_decreases_size(left);\r\n                  };\r\n              };\r\n          };\r\n      };\r\n  }\r\n}\r\n\r\n@*/\r\n\r\nclass TerminatingReduction {\r\n  static Term reduction_terminating(Term t)\r\n    //@ requires [_]term(t, ?state) \u0026*\u0026 noS(state) == true;\r\n    //@ ensures [_]term(result, ?state2) \u0026*\u0026 exists(?n) \u0026*\u0026 nsteps(n, state) == state2 \u0026*\u0026 step(state2) == none;\r\n  {\r\n    //@ nat count = zero;\r\n    Term curr = t;\r\n    while(true) \r\n      //@ invariant [_]term(curr, ?state2) \u0026*\u0026 noS(state2) == true \u0026*\u0026 nsteps(count, state) == state2;\r\n      //@ decreases size(state2);\r\n    {\r\n      Term newCur = Term.do_step(curr);\r\n      if(newCur == null) { \r\n        return curr;\r\n        //@ close exists(count);\r\n      }\r\n      //@ count = succ(count); \r\n      curr = newCur;\r\n      //@ step_preserves_noS(state2);\r\n      //@ step_with_noS_decreases_size(state2);\r\n    }\r\n  }\r\n}\r\n\r\n/*=== lemmas/methods related to 2.3 start here ===*/\r\n\r\n/* key idea: \r\n  - reduction does not depend on context (lemmas step_ignore_context and nsteps_ignore_context)\r\n  - prove parity lemma (even -\u003e K, odd -\u003e KK) by induction on N (lemma ks_step_parity)\r\n  - test_parity is an test program where the lemma is used\r\n*/\r\n\r\n/*@\r\nfixpoint term ks(nat n) {\r\n  switch(n) {\r\n    case zero: return K;\r\n    case succ(n0): return apply(ks(n0), K);\r\n  }\r\n}\r\n\r\nlemma void nat_le_reflexive(nat n)\r\n  requires true;\r\n  ensures nat_le(n, n) == true;\r\n{\r\n  switch(n) {\r\n    case zero:\r\n    case succ(n0): nat_le_reflexive(n0);\r\n  }\r\n}\r\n\r\nlemma void nat_le_succ(nat n)\r\n  requires true;\r\n  ensures nat_le(n, succ(n)) == true;\r\n{\r\n  switch(n) {\r\n    case zero:\r\n    case succ(n0): nat_le_succ(n0);\r\n  }\r\n}\r\n\r\n\r\nlemma void nat_le_either(nat n, nat m) \r\n  requires true;\r\n  ensures nat_le(n, m) || nat_le(m, n);\r\n{\r\n  switch(n) {\r\n    case zero:\r\n    case succ(n0):\r\n      switch(m) {\r\n        case zero:\r\n        case succ(m0):\r\n          nat_le_either(n0, m0);\r\n      }\r\n  }\r\n}\r\n\r\nlemma void nat_le_both(nat n1, nat n2)\r\n  requires nat_le(n1, n2) \u0026\u0026 nat_le(n2, n1);\r\n  ensures (n1 == n2);\r\n{\r\n  switch(n1) {\r\n    case zero: switch(n2) {\r\n      case zero:\r\n      case succ(n2_):\r\n    }\r\n    case succ(n1_):\r\n    switch(n2) {\r\n      case zero:\r\n      case succ(n2_):\r\n        nat_le_both(n1_, n2_);\r\n    }\r\n  }\r\n}\r\n\r\nlemma void nat_le_not_eq(nat x, nat y)\r\n  requires nat_le(x, y) == true \u0026*\u0026 x != y;\r\n  ensures nat_le(x, prev(y)) == true;\r\n{\r\n  switch (x) {\r\n    case zero:\r\n    case succ(x0):\r\n      switch (y) {\r\n        case zero:\r\n        case succ(y0):\r\n          switch (y0) {\r\n            case zero:\r\n              nat_le_both(x, y);\r\n            case succ(y00):\r\n          }\r\n          nat_le_not_eq(x0, y0);\r\n          \r\n      }\r\n  }\r\n}\r\n\r\n\r\nlemma void nsteps_id(nat m, nat n, term t)\r\n  requires step(nsteps(m, t)) == none \u0026*\u0026 nat_le(m, n) == true;\r\n  ensures nsteps(m, t) == nsteps(n, t);\r\n{\r\n  switch(n) {\r\n    case zero:\r\n      switch(m) {\r\n        case zero:\r\n        case succ(m0):\r\n      }\r\n    case succ(n0):\r\n      switch(m) {\r\n        case zero:\r\n          nsteps_id(m, n0, t);\r\n        case succ(m0):\r\n          if(m0 != n0) {\r\n            nat_le_not_eq(m, n);\r\n            nsteps_id(m, n0, t);\r\n          }\r\n      }\r\n  }\r\n}\r\n\r\nfixpoint boolean nat_le(nat n1, nat n2) {\r\n  switch(n1) {\r\n    case zero: return true;\r\n    case succ(prev1):return \r\n    switch(n2) {\r\n      case zero: return false;\r\n      case succ(prev2): return nat_le(prev1, prev2);\r\n    };\r\n  }\r\n}\r\n\r\nlemma void nsteps_converges(nat n)\r\n  requires exists\u003cnat\u003e(?m1) \u0026*\u0026 exists\u003cnat\u003e(?m2) \u0026*\u0026 step(nsteps(m1, ks(n))) == none \u0026*\u0026 step(nsteps(m2, ks(n))) == none;\r\n  ensures nsteps(m1, ks(n)) == nsteps(m2, ks(n));\r\n{\r\n  boolean le = nat_le(m1, m2);\r\n  if(le) {\r\n    nsteps_id(m1, m2, ks(n));\r\n  } else {\r\n    nat_le_either(m1, m2);\r\n    nsteps_id(m2, m1, ks(n));\r\n  }\r\n}\r\n\r\nlemma void step_ignore_context(term t, term t2)\r\n  requires step(t2) == none;\r\n  ensures switch(step(t)) { case none: return true; case some(treduced): return switch(step(apply(t, t2))) { case none: return false; case some(reduced): return reduced == apply(treduced, t2); }; };\r\n{\r\n  switch(t) {\r\n    case K: \r\n    case S: \r\n    case apply(left, right):\r\n      switch(left) {\r\n        case K: switch(step(right)) {\r\n          case none: \r\n          case some(reduced):\r\n        };\r\n        case S: switch(step(right)) {\r\n          case none: \r\n          case some(reduced): \r\n        };\r\n        case apply(leftleft, leftright):\r\n          switch(leftleft) {\r\n            case K: \r\n              switch(step(leftright)) {\r\n                case none: switch(step(right)) { \r\n                  case none: \r\n                  case some(reduced):\r\n                };\r\n                case some(reduced):\r\n              };\r\n            case S: switch(step(leftright)) {\r\n                case none: switch(step(right)) { \r\n                  case none: \r\n                  case some(reduced): \r\n                };\r\n                case some(reduced): \r\n              };\r\n            case apply(leftleftleft, leftleftright): // (((lll, llr), lr), r)\r\n              switch(leftleftleft) {\r\n                case K: switch(step(leftleftright)) {\r\n                    case none: switch(step(leftright)) {\r\n                      case none: \r\n                      case some(reduced): some(apply(apply(apply(K, leftleftright), reduced), right)); // rec\r\n                    };\r\n                    case some(reduced): some(apply(apply(apply(K, reduced), leftright), right)); // rec\r\n                  };\r\n                case S: switch(step(leftleftright)) {\r\n                  case none: switch(step(leftright)) {\r\n                    case none: switch(step(right)) {\r\n                      case none:\r\n                      case some(reduced):\r\n                    };\r\n                    case some(reduced):\r\n                  };\r\n                  case some(reduced):\r\n                };\r\n                case apply(leftleftleftleft, leftleftleftright): // ((((_, _), _), _), _)\r\n              };\r\n          };\r\n      };\r\n  }\r\n}\r\n\r\nlemma void nsteps_ignore_context_core(nat m, term t, term reduced, term t2)\r\n  requires exists\u003cnat\u003e(m) \u0026*\u0026 nsteps(m, t) == reduced \u0026*\u0026 step(t2) == none;\r\n  ensures exists\u003cnat\u003e(?m2) \u0026*\u0026 nsteps(m2, apply(t, t2)) == apply(reduced, t2);\r\n{\r\n  switch(m) {\r\n    case zero:\r\n    case succ(m0): switch(step(nsteps(m0, t))) {\r\n      case none:\r\n        open exists\u003cnat\u003e(m);\r\n        close exists\u003cnat\u003e(m0);\r\n        nsteps_ignore_context_core(m0, t, reduced, t2);\r\n      case some(reduced0): \r\n        open exists\u003cnat\u003e(m);\r\n        close exists\u003cnat\u003e(m0);\r\n        nsteps_ignore_context_core(m0, t, nsteps(m0, t), t2);\r\n        step_ignore_context(nsteps(m0, t), t2);\r\n        open exists(?newm);\r\n        close exists(succ(newm));\r\n    }\r\n  }\r\n}\r\n\r\nlemma void nsteps_ignore_context(term t, term reduced, term t2)\r\n  requires exists\u003cnat\u003e(?m) \u0026*\u0026 nsteps(m, t) == reduced \u0026*\u0026 step(t2) == none;\r\n  ensures exists\u003cnat\u003e(?m2) \u0026*\u0026 nsteps(m2, apply(t, t2)) == apply(reduced, t2);\r\n{\r\n  nsteps_ignore_context_core(m, t, reduced, t2);\r\n}\r\n\r\nlemma void ks_step_parity(nat n)\r\n  requires true;\r\n  ensures is_even(n) ? exists\u003cnat\u003e(?m) \u0026*\u0026 nsteps(m, ks(n)) == K : exists(?m) \u0026*\u0026 nsteps(m, ks(n)) == apply(K, K);\r\n{\r\n  switch(n) {\r\n    case zero: \r\n      close exists(zero);\r\n    case succ(n0):\r\n      if(is_even(n)) {\r\n        ks_step_parity(n0);\r\n        nsteps_ignore_context(ks(n0), apply(K, K), K); \r\n        open exists(?m0);\r\n        close exists(succ(m0));\r\n      } else {\r\n        ks_step_parity(n0);\r\n        nsteps_ignore_context(ks(n0), K, K); \r\n        open exists(?m0);\r\n        close exists(succ(m0));\r\n      }\r\n  }\r\n}\r\n@*/\r\n\r\nclass ParityTest {\r\n  static void test_parity(Term t) \r\n    //@ requires exists\u003cnat\u003e(?n) \u0026*\u0026 term(t, ks(n));\r\n    //@ ensures true;\r\n  {\r\n    Term reduced = Term.reduction(t);\r\n    //@ assert [_]term(reduced, ?reducedstate);\r\n    //@ ks_step_parity(n);\r\n    //@ nsteps_converges(n);\r\n    /*@\r\n    if(is_even(n)) {\r\n      assert reducedstate == K;\r\n    } else {\r\n      assert reducedstate == apply(K, K);\r\n    }\r\n    @*/\r\n  }\r\n}",
        "name": "problem2.java",
        "path": "examples/vstte2012/problem2/problem2.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/vstte2012/problem2/problem2.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 114,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 115,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures this.type |-\u003e type \u0026*\u0026 this.left |-\u003e left \u0026*\u0026 this.right |-\u003e right;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 123,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 124,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result != null \u0026*\u0026 term(result, K);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 132,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 133,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result != null \u0026*\u0026 term(result, S);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 141,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires [_]term(left, ?state1) \u0026*\u0026 [_]term(right, ?state2);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 142,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result != null \u0026*\u0026 [_]term(result, apply(state1, state2));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 154,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires [_]term(t, ?state);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 155,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == null ? step(state) == none : [_]term(result, ?state2) \u0026*\u0026 step(state) == some(state2);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 243,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires [_]term(t, ?state);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 244,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures [_]term(result, ?state2) \u0026*\u0026 exists(?n) \u0026*\u0026 nsteps(n, state) == state2 \u0026*\u0026 step(state2) == none;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 405,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires [_]term(t, ?state) \u0026*\u0026 noS(state) == true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 406,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures [_]term(result, ?state2) \u0026*\u0026 exists(?n) \u0026*\u0026 nsteps(n, state) == state2 \u0026*\u0026 step(state2) == none;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 680,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires exists\u003cnat\u003e(?n) \u0026*\u0026 term(t, ks(n));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 681,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "interface IsEvenFunc {\n    //@ predicate valid(list\u003cClass\u003e level);\n    /*@\n    lemma void getClass_le_level();\n        requires [_]valid(?level);\n        ensures level_le({this.getClass()}, level) == true;\n    @*/\n    boolean isEven(IsOddFunc f, int n);\n        //@ requires [_]valid(?level) \u0026*\u0026 [_]f.valid(?fLevel) \u0026*\u0026 0 \u003c= n \u0026*\u0026 call_perm_rec(currentThread, level_max(level, fLevel), int_lt, n);\n        //@ ensures true;\n        //@ terminates;\n}\n\ninterface IsOddFunc {\n    //@ predicate valid(list\u003cClass\u003e level);\n    /*@\n    lemma void getClass_le_level();\n        requires [_]valid(?level);\n        ensures level_le({this.getClass()}, level) == true;\n    @*/\n    boolean isOdd(IsEvenFunc f, int n);\n        //@ requires [_]valid(?level) \u0026*\u0026 [_]f.valid(?fLevel) \u0026*\u0026 0 \u003c= n \u0026*\u0026 call_perm_rec(currentThread, level_max(fLevel, level), int_lt, n);\n        //@ ensures true;\n        //@ terminates;\n}\n\nclass Util {\n    static boolean isEven(IsEvenFunc e, IsOddFunc o, int n)\n        //@ requires [_]e.valid(?eLevel) \u0026*\u0026 [_]o.valid(?oLevel) \u0026*\u0026 0 \u003c= n \u0026*\u0026 call_perm(currentThread, cons(Util.class, level_max(eLevel, oLevel)));\n        //@ ensures true;\n        //@ terminates;\n    {\n        //@ is_wf_int_lt();\n        //@ create_call_perm_rec(2, level_max(eLevel, oLevel), int_lt, n);\n        //@ call_perm_rec_elim(1);\n        //@ e.getClass_le_level();\n        //@ level_le_append_l(eLevel, oLevel);\n        //@ level_le_trans({e.getClass()}, eLevel, level_max(eLevel, oLevel));\n        //@ consume_call_perm_for(e.getClass());\n        return e.isEven(o, n);\n    }\n}\n\nfinal class MyIsEvenFunc implements IsEvenFunc {\n    //@ predicate valid(list\u003cClass\u003e level) = level == {MyIsEvenFunc.class};\n    /*@\n    lemma void getClass_le_level()\n        requires [_]valid(?level);\n        ensures level_le({this.getClass()}, level) == true;\n    {\n        open [_]valid(_);\n    }\n    @*/\n    MyIsEvenFunc()\n        //@ requires true;\n        //@ ensures valid({MyIsEvenFunc.class});\n        //@ terminates;\n    {\n        //@ close valid({MyIsEvenFunc.class});\n    }\n    boolean isEven(IsOddFunc f, int n)\n        //@ requires [_]valid(?level) \u0026*\u0026 [_]f.valid(?fLevel) \u0026*\u0026 0 \u003c= n \u0026*\u0026 call_perm_rec(currentThread, level_max(level, fLevel), int_lt, n);\n        //@ ensures true;\n        //@ terminates;\n    {\n        /*@\n        if (0 \u003c n) {\n            call_perm_rec_weaken(2, n - 1);\n            call_perm_rec_elim(1);\n            f.getClass_le_level();\n            level_le_append_r(level, fLevel);\n            level_le_trans({f.getClass()}, fLevel, level_max(level, fLevel));\n            consume_call_perm_for(f.getClass());\n        }\n        @*/\n        return n == 0 || f.isOdd(this, n - 1);\n    }\n}\n\nfinal class MyIsOddFunc implements IsOddFunc {\n    //@ predicate valid(list\u003cClass\u003e level) = level == {MyIsOddFunc.class};\n    /*@\n    lemma void getClass_le_level()\n        requires [_]valid(?level);\n        ensures level_le({this.getClass()}, level) == true;\n    {\n        open [_]valid(_);\n    }\n    @*/\n    MyIsOddFunc()\n        //@ requires true;\n        //@ ensures valid({MyIsOddFunc.class});\n        //@ terminates;\n    {\n        //@ close valid({MyIsOddFunc.class});\n    }\n    boolean isOdd(IsEvenFunc f, int n)\n        //@ requires [_]valid(?level) \u0026*\u0026 [_]f.valid(?fLevel) \u0026*\u0026 0 \u003c= n \u0026*\u0026 call_perm_rec(currentThread, level_max(fLevel, level), int_lt, n);\n        //@ ensures true;\n        //@ terminates;\n    {\n        /*@\n        if (0 \u003c n) {\n            call_perm_rec_weaken(2, n - 1);\n            call_perm_rec_elim(1);\n            f.getClass_le_level();\n            level_le_append_l(fLevel, level);\n            level_le_trans({f.getClass()}, fLevel, level_max(fLevel, level));\n            consume_call_perm_for(f.getClass());\n        }\n        @*/\n        return n != 0 \u0026\u0026 f.isEven(this, n - 1);\n    }\n}\n\nclass Main {\n    static void main()\n        //@ requires true;\n        //@ ensures true;\n        //@ terminates;\n    {\n        IsEvenFunc e = new MyIsEvenFunc();\n        IsOddFunc o = new MyIsOddFunc();\n        //@ produce_call_below_perm_();\n        //@ level_max_def({MyIsEvenFunc.class}, {MyIsOddFunc.class});\n        //@ call_below_perm__elim(1, {Util.class, MyIsOddFunc.class});\n        Util.isEven(e, o, 42);\n    }\n}\n",
        "name": "IsEvenFunc.java",
        "path": "examples/java/termination/IsEvenFunc.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/termination/IsEvenFunc.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?level) \u0026*\u0026 [_]f.valid(?fLevel) \u0026*\u0026 0 \u003c= n \u0026*\u0026 call_perm_rec(currentThread, level_max(level, fLevel), int_lt, n);"
        },
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?level) \u0026*\u0026 [_]f.valid(?fLevel) \u0026*\u0026 0 \u003c= n \u0026*\u0026 call_perm_rec(currentThread, level_max(fLevel, level), int_lt, n);"
        },
        {
          "limitHit": false,
          "lineNumber": 22,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]e.valid(?eLevel) \u0026*\u0026 [_]o.valid(?oLevel) \u0026*\u0026 0 \u003c= n \u0026*\u0026 call_perm(currentThread, cons(Util.class, level_max(eLevel, oLevel)));"
        },
        {
          "limitHit": false,
          "lineNumber": 29,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 54,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 55,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid({MyIsEvenFunc.class});"
        },
        {
          "limitHit": false,
          "lineNumber": 61,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?level) \u0026*\u0026 [_]f.valid(?fLevel) \u0026*\u0026 0 \u003c= n \u0026*\u0026 call_perm_rec(currentThread, level_max(level, fLevel), int_lt, n);"
        },
        {
          "limitHit": false,
          "lineNumber": 62,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 90,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 91,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid({MyIsOddFunc.class});"
        },
        {
          "limitHit": false,
          "lineNumber": 97,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?level) \u0026*\u0026 [_]f.valid(?fLevel) \u0026*\u0026 0 \u003c= n \u0026*\u0026 call_perm_rec(currentThread, level_max(fLevel, level), int_lt, n);"
        },
        {
          "limitHit": false,
          "lineNumber": 98,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 117,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 118,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "/*@\n\ntypedef lemma void get_op(predicate(boolean) inv, predicate() pre, predicate(boolean) post)();\n    requires inv(?value) \u0026*\u0026 pre();\n    ensures inv(value) \u0026*\u0026 post(value);\n\ntypedef lemma void set_op(predicate(boolean) inv, boolean value, predicate() pre, predicate() post)();\n    requires inv(?value0) \u0026*\u0026 pre();\n    ensures inv(value) \u0026*\u0026 post();\n\n@*/\n\nclass AtomicBoolean {\n    //@ predicate valid(predicate(boolean) inv);\n    AtomicBoolean()\n        //@ requires exists\u003cpredicate(boolean)\u003e(?inv) \u0026*\u0026 inv(false);\n        //@ ensures valid(inv);\n    {\n        throw new RuntimeException();\n    }\n    boolean get()\n        //@ requires [_]valid(?inv) \u0026*\u0026 is_get_op(?op, inv, ?pre, ?post) \u0026*\u0026 pre();\n        //@ ensures post(result);\n    {\n        throw new RuntimeException();\n    }\n    void set(boolean value)\n        //@ requires [_]valid(?inv) \u0026*\u0026 is_set_op(?op, inv, value, ?pre, ?post) \u0026*\u0026 pre();\n        //@ ensures post();\n    {\n        throw new RuntimeException();\n    }\n}\n\n/*@\n\ninductive tree = empty | tree(Node node, tree left, tree right);\n\npredicate tree(Node node, Node parent; tree tree) =\n    node == null ?\n        tree == empty\n    :\n        tree1(node, parent, tree);\n\npredicate tree1(Node node; Node parent, tree tree) =\n    [_]node.sense |-\u003e ?sense \u0026*\u0026 [_]sense.valid(Node_inv(node)) \u0026*\u0026\n    [_]node.left |-\u003e ?left \u0026*\u0026\n    [_]node.parent |-\u003e parent \u0026*\u0026\n    [_]node.leftTree |-\u003e ?leftTree \u0026*\u0026 [_]tree(left, node, leftTree) \u0026*\u0026\n    [_]node.right |-\u003e ?right \u0026*\u0026\n    [_]node.rightTree |-\u003e ?rightTree \u0026*\u0026 [_]tree(right, node, rightTree) \u0026*\u0026\n    tree == tree(node, leftTree, rightTree);\n\npredicate senseValuesTrue(tree tree;) =\n    switch (tree) {\n        case empty: return true;\n        case tree(node, left, right): return [1/2]node.senseValue |-\u003e true \u0026*\u0026 [1/2]senseValuesTrue0(tree);\n    };\n    \npredicate senseValuesTrue0(tree tree;) =\n    switch (tree) {\n        case empty: return true;\n        case tree(node, left, right): return senseValuesTrue(left) \u0026*\u0026 senseValuesTrue(right);\n    };\n    \npredicate_ctor Node_inv(Node node)(boolean value) =\n    [_]tree1(node, ?parent, ?tree) \u0026*\u0026\n    [1/2]node.senseValue |-\u003e value \u0026*\u0026\n    value ?\n        [1/2]senseValuesTrue0(tree) \u0026*\u0026\n        [1/2]node.grabbed |-\u003e ?grabbed \u0026*\u0026\n        [1/2]node.takenBack |-\u003e false \u0026*\u0026\n        grabbed ?\n            parent != null\n        :\n            (parent == null ? true : senseValuesTrue(tree))\n    :\n        [1/2]node.grabbed |-\u003e false \u0026*\u0026\n        [1/2]node.takenBack |-\u003e ?takenBack \u0026*\u0026\n        takenBack ?\n            true\n        :\n            [1/2]node.senseValue |-\u003e false \u0026*\u0026 senseValuesTrue0(tree);\n\npredicate child(Node parent, Node child;) =\n    parent != null \u0026*\u0026\n    child == null ?\n        true\n    :\n        [_]tree1(child, parent, _) \u0026*\u0026\n        [1/2]child.grabbed |-\u003e false;\n\npredicate child_grabbed(Node parent, Node child;) =\n    parent != null \u0026*\u0026\n    child == null ?\n        true\n    :\n        [1/2]child.grabbed |-\u003e true \u0026*\u0026\n        [_]tree1(child, parent, ?childTree) \u0026*\u0026\n        senseValuesTrue(childTree);\n\npredicate child_grabbed0(Node parent, Node child;) =\n    parent != null \u0026*\u0026\n    child == null ?\n        true\n    :\n        [1/2]child.grabbed |-\u003e true;\n\n@*/\n\nclass Node {\n\tfinal Node left, right;\n\t//@ tree leftTree;\n\t//@ tree rightTree;\n\t//@ boolean senseValue;\n\t//@ boolean grabbed;\n\t//@ boolean takenBack;\n\t\n\tfinal Node parent;\n\n\tAtomicBoolean sense;\n\t\n\t/*@\n\t\n\tpredicate valid() =\n\t    [_]tree1(this, ?parent, ?thisTree) \u0026*\u0026\n\t    [1/2]this.senseValue |-\u003e false \u0026*\u0026\n\t    [1/2]this.takenBack |-\u003e true \u0026*\u0026\n\t    (parent == null ? [1/2]this.grabbed |-\u003e false : true) \u0026*\u0026\n\t    [_]this.left |-\u003e ?left \u0026*\u0026 child(this, left) \u0026*\u0026\n\t    [_]this.right |-\u003e ?right \u0026*\u0026 child(this, right);\n\t\n\t@*/\n\t\n\tstatic void grab(Node child)\n\t    //@ requires child(?parent, child);\n\t    //@ ensures child_grabbed(parent, child);\n\t{\n\t\tif(child != null)\n\t  \t    for (;;)\n\t  \t        //@ invariant child(parent, child);\n\t  \t    {\n\t  \t        /*@\n\t  \t        predicate pre() = child(parent, child);\n\t  \t        predicate post(boolean value) = value ? child_grabbed(parent, child) : child(parent, child); \n\t  \t        lemma void get_op()\n\t  \t            requires Node_inv(child)(?value) \u0026*\u0026 pre();\n\t  \t            ensures Node_inv(child)(value) \u0026*\u0026 post(value);\n\t  \t        {\n\t  \t            open pre();\n\t  \t            open Node_inv(child)(value);\n\t  \t            if (value) child.grabbed = true;\n\t  \t            close Node_inv(child)(value);\n\t  \t            close post(value);\n\t  \t        }\n\t  \t        @*/\n\t  \t        //@ open [_]tree1(child, _, _);\n\t  \t        //@ produce_lemma_function_pointer_chunk(get_op) : get_op(Node_inv(child), pre, post)() { call(); };\n\t  \t        //@ close pre();\n\t  \t        boolean result = child.sense.get();\n\t  \t        //@ open post(result);\n\t  \t        if (result) break;\n\t  \t    }\n\t\t\n\t\t//@ if (child == null) { open child(parent, child); }\n\t}\n\t\n\tvoid ungrab(Node child)\n\t    //@ requires child_grabbed(?parent, child);\n\t    //@ ensures child(parent, child);\n\t{\n\t    if (child != null) {\n\t        \n\t            /*@\n\t            predicate pre() = [_]child.parent |-\u003e parent \u0026*\u0026 child_grabbed(parent, child) \u0026*\u0026 child != null;\n\t            predicate post() = child(parent, child);\n\t            lemma void set_op()\n\t                requires Node_inv(child)(?value) \u0026*\u0026 pre();\n\t                ensures Node_inv(child)(false) \u0026*\u0026 post();\n\t            {\n\t                open Node_inv(child)(value);\n\t                open pre();\n\t                child.grabbed = false;\n\t                open tree1(child, _, _);\n\t                open senseValuesTrue(_);\n\t                child.senseValue = false;\n\t                close post();\n\t                close Node_inv(child)(false);\n\t            }\n\t            @*/\n\t            //@ produce_lemma_function_pointer_chunk(set_op) : set_op(Node_inv(child), false, pre, post)() { call(); };\n\t            //@ close pre();\n\t            child.sense.set(false);\n\t            //@ open post();\n\t        \n\t    }\n\t    //@ if (child == null) { open child_grabbed(parent, child); }\n\t}\n\n\tvoid barrier()\n\t\t//@ requires valid();\n\t\t//@ ensures  valid();\n\t{\n\t\t// synchronization phase\n\t\tgrab(left);\n\t\tgrab(right);\n\t\t\n\t\t{\n\t\t    /*@\n\t\t    predicate pre() =\n\t\t        [1/2]this.senseValue |-\u003e false \u0026*\u0026\n\t\t        [1/2]this.takenBack |-\u003e true \u0026*\u0026\n\t\t        [_]tree1(this, _, _) \u0026*\u0026\n\t\t        [_]this.left |-\u003e ?left \u0026*\u0026 child_grabbed(this, left) \u0026*\u0026\n\t\t        [_]this.right |-\u003e ?right \u0026*\u0026 child_grabbed(this, right);\n\t\t    predicate post() =\n\t\t        [1/2]takenBack |-\u003e false \u0026*\u0026\n\t\t        [_]this.left |-\u003e ?left \u0026*\u0026 child_grabbed0(this, left) \u0026*\u0026\n\t\t        [_]this.right |-\u003e ?right \u0026*\u0026 child_grabbed0(this, right) \u0026*\u0026\n\t\t        [_]tree1(this, ?parent, ?thisTree) \u0026*\u0026 parent == null ? senseValuesTrue(thisTree) : true;\n\t\t    lemma void set_op()\n\t\t        requires Node_inv(this)(?value0) \u0026*\u0026 pre();\n\t\t        ensures Node_inv(this)(true) \u0026*\u0026 post();\n\t\t    {\n\t\t        open Node_inv(this)(_);\n\t\t        open pre();\n\t\t        open child_grabbed(this, left);\n\t\t        open child_grabbed(this, right);\n\t\t        assert [_]tree1(this, _, ?thisTree);\n\t\t        open tree1(this, _, thisTree);\n\t\t        open tree(this.left, _, _);\n\t\t        open tree(this.right, _, _);\n\t\t        this.senseValue = true;\n\t\t        close senseValuesTrue0(thisTree);\n\t\t        close senseValuesTrue(thisTree);\n\t\t        \n\t\t        assert senseValuesTrue(thisTree); /// \u003c\u003c--- property requested established here.\n\t\t        takenBack = false;\n\t\t        close Node_inv(this)(true);\n\t\t        close post();\n\t\t    }\n\t\t    @*/\n\t\t    //@ produce_lemma_function_pointer_chunk(set_op) : set_op(Node_inv(this), true, pre, post)() { call(); };\n\t\t    //@ close pre();\n\t\t    sense.set(true);\n\t\t    //@ open post();\n\t\t}\n\t\t\n\t\t//@ assert [_]parent |-\u003e ?p \u0026*\u0026 p == null ? [_]tree1(this, null, ?thisTree) \u0026*\u0026 senseValuesTrue(thisTree) : true;\n\n\t\t// wake-up phase\n\t\tif(parent == null) {\n\t\t    /*@\n\t\t    predicate pre() =\n\t\t        [1/2]takenBack |-\u003e false \u0026*\u0026\n\t\t        [_]this.left |-\u003e ?left \u0026*\u0026 child_grabbed0(this, left) \u0026*\u0026\n\t\t        [_]this.right |-\u003e ?right \u0026*\u0026 child_grabbed0(this, right) \u0026*\u0026\n\t\t        [_]tree1(this, null, ?thisTree) \u0026*\u0026 senseValuesTrue(thisTree);\n\t\t    predicate post() =\n\t\t        [1/2]takenBack |-\u003e true \u0026*\u0026\n\t\t        [1/2]senseValue |-\u003e false \u0026*\u0026\n\t\t        [_]this.left |-\u003e ?left \u0026*\u0026 child_grabbed(this, left) \u0026*\u0026\n\t\t        [_]this.right |-\u003e ?right \u0026*\u0026 child_grabbed(this, right);\n\t\t    lemma void set_op()\n\t\t        requires Node_inv(this)(?value0) \u0026*\u0026 pre();\n\t\t        ensures Node_inv(this)(false) \u0026*\u0026 post();\n\t\t    {\n\t\t        open Node_inv(this)(value0);\n\t\t        open pre();\n\t\t        open tree1(this, null, ?thisTree);\n\t\t        open senseValuesTrue(thisTree);\n\t\t        senseValue = false;\n\t\t        open senseValuesTrue0(thisTree);\n\t\t        close child_grabbed(this, left);\n\t\t        close child_grabbed(this, right);\n\t\t        takenBack = true;\n\t\t        close post();\n\t\t        close Node_inv(this)(false);\n\t\t    }\n\t\t    @*/\n\t\t    //@ produce_lemma_function_pointer_chunk(set_op) : set_op(Node_inv(this), false, pre, post)() { call(); };\n\t\t    //@ close pre();\n\t  \t    sense.set(false);\n\t  \t    //@ open post();\n\t  \t} else {\n\t  \t\n\t  \t//@ assert [_]tree1(this, ?parent, ?thisTree);\n\n\t\tfor (;;)\n\t\t    //@ requires [_]tree1(this, parent, thisTree) \u0026*\u0026 [1/2]takenBack |-\u003e false;\n\t\t    //@ ensures [1/2]takenBack |-\u003e true \u0026*\u0026 [1/2]this.senseValue |-\u003e false \u0026*\u0026 senseValuesTrue0(thisTree);\n\t\t{\n\t\t    {\n\t\t    /*@\n\t\t    predicate pre() = [_]tree1(this, parent, thisTree) \u0026*\u0026 [1/2]takenBack |-\u003e false;\n\t\t    predicate post(boolean value) =\n\t\t        [1/2]takenBack |-\u003e !value \u0026*\u0026\n\t\t        value ? true :\n\t\t            [1/2]this.senseValue |-\u003e false \u0026*\u0026 senseValuesTrue0(thisTree);\n\t\t    lemma void get_op()\n\t\t        requires Node_inv(this)(?value) \u0026*\u0026 pre();\n\t\t        ensures Node_inv(this)(value) \u0026*\u0026 post(value);\n\t\t    {\n\t\t        open Node_inv(this)(value);\n\t\t        open pre();\n\t\t        if (value) {\n\t\t        } else {\n\t\t            takenBack = true;\n\t\t        }\n\t\t        close post(value);\n\t\t        close Node_inv(this)(value);\n\t\t    }\n\t\t    @*/\n\t\t    //@ produce_lemma_function_pointer_chunk(get_op) : get_op(Node_inv(this), pre, post)() { call(); };\n\t\t    //@ close pre();\n\t\t    boolean result = sense.get();\n\t\t    //@ open post(result);\n\t\t    if (!result)\n\t\t        break;\n\t\t    }\n\t\t}\n\t\t\n\t\t//@ open [_]tree1(this, parent, thisTree);\n\t\t//@ open senseValuesTrue0(thisTree);\n\t\t//@ close child_grabbed(this, left);\n\t\t//@ close child_grabbed(this, right);\n\t\t\n\t\t}\n\t\t\n\t\tungrab(left);\n\t\tungrab(right);\n\t}\n}\n",
        "name": "tree_barrier.java",
        "path": "examples/verifythis2016/tree_barrier.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/verifythis2016/tree_barrier.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires exists\u003cpredicate(boolean)\u003e(?inv) \u0026*\u0026 inv(false);"
        },
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(inv);"
        },
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?inv) \u0026*\u0026 is_get_op(?op, inv, ?pre, ?post) \u0026*\u0026 pre();"
        },
        {
          "limitHit": false,
          "lineNumber": 22,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post(result);"
        },
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?inv) \u0026*\u0026 is_set_op(?op, inv, value, ?pre, ?post) \u0026*\u0026 pre();"
        },
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures post();"
        },
        {
          "limitHit": false,
          "lineNumber": 135,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires child(?parent, child);"
        },
        {
          "limitHit": false,
          "lineNumber": 136,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures child_grabbed(parent, child);"
        },
        {
          "limitHit": false,
          "lineNumber": 168,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires child_grabbed(?parent, child);"
        },
        {
          "limitHit": false,
          "lineNumber": 169,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures child(parent, child);"
        },
        {
          "limitHit": false,
          "lineNumber": 289,
          "offsetAndLengths": [
            [
              6,
              13
            ]
          ],
          "preview": "\t\t    //@ requires [_]tree1(this, parent, thisTree) \u0026*\u0026 [1/2]takenBack |-\u003e false;"
        },
        {
          "limitHit": false,
          "lineNumber": 290,
          "offsetAndLengths": [
            [
              6,
              12
            ]
          ],
          "preview": "\t\t    //@ ensures [1/2]takenBack |-\u003e true \u0026*\u0026 [1/2]this.senseValue |-\u003e false \u0026*\u0026 senseValuesTrue0(thisTree);"
        },
        {
          "limitHit": false,
          "lineNumber": 200,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 201,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures  valid();"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "/*\r\nThe specification below proves:\r\n  1. safety (no array indexing errors)\r\n  2. termination (via loop decreases: j - i + 1)\r\n  3. behavior \r\n    (a) the resulting array is sorted (postcondition: is_sorted(vs2))\r\n    (b) the resulting array is a permutation of the original array (postcondition: is_perm(vs, vs2))\r\n*/\r\n\r\n/*@\r\n\r\nlemma_auto void length_append_auto\u003ct\u003e(list\u003ct\u003e xs, list\u003ct\u003e ys)\r\n    requires true;\r\n    ensures length(append(xs, ys)) == length(xs) + length(ys);\r\n{\r\n    length_append(xs, ys);\r\n}\r\n\r\nlemma_auto void length_take_n_auto\u003ct\u003e(int n, list\u003ct\u003e xs)\r\n    requires 0 \u003c= n \u0026\u0026 n \u003c= length(xs);\r\n    ensures length(take(n, xs)) == n;\r\n{\r\n    length_take_n(n, xs);\r\n}\r\n\r\nfixpoint boolean is_sorted(list\u003cboolean\u003e vs) {\r\n  switch(vs) {\r\n    case nil: return true;\r\n    case cons(h, t):\r\n      return switch(t) { \r\n        case nil: return true; \r\n        case cons(h0, t0): return (h == false || h0 == true) \u0026\u0026 is_sorted(t);\r\n      };\r\n  }\r\n}\r\n\r\nlemma void is_sorted_lemma(list\u003cboolean\u003e vs, int i)\r\n  requires 0 \u003c= i \u0026\u0026 i \u003c= length(vs) \u0026*\u0026 all_eq(take(i, vs), false) == true \u0026*\u0026 all_eq(drop(i, vs), true) == true;\r\n  ensures is_sorted(vs) == true;\r\n{\r\n  switch(vs) {\r\n    case nil:\r\n    case cons(h, t):\r\n      switch(t) {\r\n        case nil:\r\n        case cons(h0, t0):\r\n          if(i == 0) {\r\n            is_sorted_lemma(t, 0);\r\n          } else {\r\n            is_sorted_lemma(t, i -1);\r\n          }\r\n      }\r\n  }\r\n}\r\n\r\nlemma void update_drop\u003ct\u003e(list\u003ct\u003e xs, int i, t v, int j)\r\n  requires 0 \u003c= i \u0026\u0026 i \u003c length(xs) \u0026*\u0026 0 \u003c= j \u0026*\u0026 i \u003c j;\r\n  ensures drop(j, update(i, v, xs)) == drop(j, xs);\r\n{\r\n  switch(xs) {\r\n    case nil:\r\n    case cons(h, t):\r\n      if(i == 0) {\r\n      } else {\r\n        update_drop(t, i - 1, v, j - 1);\r\n      }\r\n  }\r\n}\r\n\r\nfixpoint list\u003ct\u003e execute_swaps\u003ct\u003e(list\u003cpair\u003cint, int\u003e \u003e swaps, list\u003ct\u003e xs) {\r\n  switch(swaps) {\r\n    case nil: return xs;\r\n    case cons(h, t):\r\n      return switch(h) {\r\n        case pair(i, j): return update(j, nth(i, execute_swaps(t, xs)), update(i, nth(j,  execute_swaps(t, xs)), execute_swaps(t, xs)));\r\n      };\r\n  }\r\n}\r\n\r\npredicate is_perm\u003ct\u003e(list\u003ct\u003e xs, list\u003ct\u003e ys) =\r\n  exists\u003clist\u003cpair\u003cint, int\u003e \u003e \u003e(?swaps) \u0026*\u0026 execute_swaps(swaps, xs) == ys;\r\n@*/\r\n\r\nclass Problem1 {\r\n  static void swap(boolean[] a, int i, int j) \r\n    //@ requires array_slice(a, 0, a.length, ?vs) \u0026*\u0026 0 \u003c= i \u0026*\u0026 i \u003c a.length \u0026*\u0026 0 \u003c= j \u0026*\u0026 j \u003c a.length;\r\n    //@ ensures array_slice(a, 0, a.length, update(j, nth(i, vs), update(i, nth(j, vs), vs)));\r\n  {\r\n    boolean tmp = a[i];\r\n    a[i] = a[j];\r\n    a[j] = tmp;\r\n  }\r\n  \r\n  static void two_way_sort(boolean[] a) \r\n    //@ requires array_slice(a, 0, a.length, ?vs);\r\n    //@ ensures array_slice(a, 0, a.length, ?vs2) \u0026*\u0026 is_sorted(vs2) == true \u0026*\u0026 is_perm(vs, vs2);\r\n  {\r\n    int i = 0;\r\n    int j = a.length - 1;\r\n    //@ close exists(nil);\r\n    //@ close is_perm(vs, vs);\r\n    while(i \u003c= j) \r\n      /*@ invariant 0 \u003c= i \u0026\u0026 i \u003c= a.length \u0026*\u0026 -1 \u003c= j \u0026*\u0026 j \u003c a.length \u0026*\u0026 j - i \u003e= -1 \u0026*\u0026\r\n          array_slice(a, 0, a.length, ?xs) \u0026*\u0026 \r\n          all_eq(take(i, xs), false) == true \u0026*\u0026\r\n          all_eq(drop(j + 1, xs), true) == true \u0026*\u0026\r\n          is_perm(vs, xs); \r\n          @*/\r\n      //@ decreases j - i + 1;\r\n    {\r\n      if(! a[i]) {\r\n        //@ take_one_more(i, xs);\r\n        i++;\r\n      } else if (a[j]) {\r\n        //@ drop_n_plus_one(j, xs);\r\n        j--;\r\n      } else {\r\n        swap(a, i, j);\r\n        //@ assert array_slice(a, 0, a.length, ?ys);\r\n        //@ open is_perm(vs, xs);\r\n        //@ open exists(?swaps);\r\n        //@ close exists(cons(pair(i, j), swaps));\r\n        //@ close is_perm(vs, ys);\r\n        //@ take_one_more(i, ys);\r\n        //@ drop_n_plus_one(j, ys);\r\n        //@ update_drop(xs, i, nth(j, xs), j+1);\r\n        i++;       \r\n        j--;\r\n      }\r\n    }\r\n    //@ is_sorted_lemma(xs, i);\r\n  }\r\n}",
        "name": "problem1.java",
        "path": "examples/vstte2012/problem1/problem1.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/vstte2012/problem1/problem1.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 85,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires array_slice(a, 0, a.length, ?vs) \u0026*\u0026 0 \u003c= i \u0026*\u0026 i \u003c a.length \u0026*\u0026 0 \u003c= j \u0026*\u0026 j \u003c a.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 86,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures array_slice(a, 0, a.length, update(j, nth(i, vs), update(i, nth(j, vs), vs)));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 94,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires array_slice(a, 0, a.length, ?vs);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 95,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures array_slice(a, 0, a.length, ?vs2) \u0026*\u0026 is_sorted(vs2) == true \u0026*\u0026 is_perm(vs, vs2);\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class Assert\n{\n  public static void main(String[] args)\n    //@ requires true;\n    //@ ensures  true;\n  {\n    int i = 99;\n    assert (i \u003e 0);\n    assert i \u003e 0;\n    char c = 'a';\n    assert (c + 4 == 'e');\n    assert c + 4 == 'e' : \"foobar\";\n  }\n}",
        "name": "Assert.java",
        "path": "examples/java/frontend/assert/Assert.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/assert/Assert.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class Assign\n{\n  public static void main(String[] args)\n    //@ requires true;\n    //@ ensures true;\n  {\n    int i = 0;\n    //@ assert i == 0;\n    i = i + 100;\n    //@ assert i == 100;\n    i += 100;\n    //@ assert i == 200;\n    i -= 1;\n    //@ assert i == 199;\n    i %= 99;\n    //@ assert i == 1;\n  }\n}",
        "name": "Assign.java",
        "path": "examples/java/frontend/assign/Assign.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/assign/Assign.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import java.util.*;\n\npublic class Boxing\n{\n  public static void main(String[] args)\n    //@ requires true;\n    //@ ensures true;\n  {\n    //Integers\n    Integer i1 = 5;\n    int i2 = i1;\n    Integer i3 = i2;\n    \n    //Booleans\n    Boolean bool1 = true;\n    boolean bool2 = bool1;\n    Boolean bool3 = bool2;\n  }\n}\n",
        "name": "Boxing.java",
        "path": "examples/java/frontend/boxing/Boxing.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/boxing/Boxing.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class Switch\n{\n  public static void main(String[] args) \n    //@ requires true;\n    //@ ensures  true;\n  {\n    int day = 4;\n    \n    int i = 0;\n    switch (day) \n    {\n      case 1:  i = 1;\n               break;\n      case 2:  i = 10;\n               break;\n      case 3:  i = 100;\n               break;\n      case 4:  i = 1000;\n               break;\n      default: i = 0;\n               break;\n    }\n    \n    //@ assert i == 1000;\n  }\n}\n",
        "name": "Switch.java",
        "path": "examples/java/frontend/switch/Switch.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/switch/Switch.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "interface Func {\r\n    //@ predicate valid(list\u003cClass\u003e level);\r\n    /*@\r\n    lemma void getClass_le_level();\r\n        requires [_]valid(?level);\r\n        ensures level_le({this.getClass()}, level) == true;\r\n    @*/\r\n    int apply(int x);\r\n        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\r\n        //@ ensures true;\r\n        //@ terminates;\r\n}\r\n\r\nclass Util {\r\n    static int deriv(Func f, int x)\r\n        //@ requires [_]f.valid(?level) \u0026*\u0026 call_perm(currentThread, cons(Util.class, level));\r\n        //@ ensures true;\r\n        //@ terminates;\r\n    {\r\n        //@ call_perm_weaken_and_dup(4);\r\n        //@ f.getClass_le_level();\r\n        //@ consume_call_perm_for(f.getClass());\r\n        //@ consume_call_perm_for(f.getClass());\r\n        return f.apply(x + 1) - f.apply(x);\r\n    }\r\n}\r\n\r\nfinal class ZeroFunc implements Func {\r\n    //@ predicate valid(list\u003cClass\u003e level) = level == {ZeroFunc.class};\r\n    /*@\r\n    lemma void getClass_le_level()\r\n        requires [_]valid(?level);\r\n        ensures level_le({this.getClass()}, level) == true;\r\n    {\r\n        open valid(_);\r\n    }\r\n    @*/\r\n    ZeroFunc()\r\n        //@ requires true;\r\n        //@ ensures valid({ZeroFunc.class});\r\n        //@ terminates;\r\n    {\r\n        //@ close valid({ZeroFunc.class});\r\n    }\r\n    public int apply(int x)\r\n        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\r\n        //@ ensures true;\r\n        //@ terminates;\r\n    {\r\n        return 0;\r\n    }\r\n}\r\n\r\nfinal class PlusOneFunc implements Func {\r\n    Func f;\r\n    //@ predicate valid(list\u003cClass\u003e level) = f |-\u003e ?f \u0026*\u0026 [_]f.valid(?fLevel) \u0026*\u0026 level == cons(PlusOneFunc.class, fLevel);\r\n    /*@\r\n    lemma void getClass_le_level()\r\n        requires [_]valid(?level);\r\n        ensures level_le({this.getClass()}, level) == true;\r\n    {\r\n        open valid(_);\r\n    }\r\n    @*/\r\n    PlusOneFunc(Func f)\r\n        //@ requires [_]f.valid(?fLevel);\r\n        //@ ensures valid(cons(PlusOneFunc.class, fLevel));\r\n        //@ terminates;\r\n    {\r\n        this.f = f;\r\n    }\r\n    public int apply(int x)\r\n        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\r\n        //@ ensures true;\r\n        //@ terminates;\r\n    {\r\n        //@ open valid(_);\r\n        //@ call_perm_weaken_and_dup(2);\r\n        //@ f.getClass_le_level();\r\n        //@ consume_call_perm_for(f.getClass());\r\n        return f.apply(x) + 1;\r\n    }\r\n}\r\n\r\nclass Main {\r\n    public static void main(String[] args)\r\n        //@ requires true;\r\n        //@ ensures true;\r\n        //@ terminates;\r\n    {\r\n        Func f1 = new ZeroFunc();\r\n        Func f2 = new PlusOneFunc(f1);\r\n        Func f3 = new PlusOneFunc(f2);\r\n        //@ produce_call_below_perm_();\r\n        //@ call_below_perm__elim(1, {Util.class, PlusOneFunc.class, PlusOneFunc.class, ZeroFunc.class});\r\n        Util.deriv(f3, 0);\r\n    }\r\n}\r\n",
        "name": "PlusOneFunc.java",
        "path": "examples/java/termination/PlusOneFunc.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/termination/PlusOneFunc.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]f.valid(?level) \u0026*\u0026 call_perm(currentThread, cons(Util.class, level));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 39,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid({ZeroFunc.class});\r"
        },
        {
          "limitHit": false,
          "lineNumber": 45,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 46,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 65,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]f.valid(?fLevel);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 66,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(cons(PlusOneFunc.class, fLevel));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 72,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 73,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 86,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 87,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "interface iX {\n}\n\ninterface iA extends iX {\n}\n\nabstract class A implements iA {\n  public int intRep(){\n    return 10;\n  }\n  \n  public String StringRep(){\n    return \"A\";\n  }\n}\n\nclass B extends A {}\n\nclass C extends A {}\n\nclass E extends C {}\n\nfinal class F extends A {}\n\nclass main{\n  public static void test(A x, A y)\n    //@ requires x != null \u0026*\u0026 y != null;\n    //@ ensures true;\n  {\n    A tst = null;\n    if (x instanceof C){\n      if(x instanceof B){\n        //@ assert false;\n        //tst.StringRep();\n      }\n    }\n    if (x instanceof E){\n      if (!(x instanceof C)){\n        //@ assert false;\n        //tst.StringRep();\n      }\n      if (!(x instanceof iA)){\n        //@ assert false;\n        //tst.StringRep();\n      }\n    }\n    B u = new B();\n    if (!(u instanceof iX)){\n       //@ assert false;\n       //u.intRep();\n    }\n    //@produce_instanceof(x);\n    if(!(x instanceof iA)){\n      //@ assert false;\n      //x.intRep();\n    }\n    //@ A w = y;\n    //@produce_instanceof(w);\n    /*@\n    if(!(w instanceof iA)){\n      assert false;\n      //y.intRep();\n    } @*/\n  }\n}\n\n/*@\nlemma void instance_of_final__get_class (A x)\nrequires x instanceof F;\nensures x.getClass() == F.class;\n{\n}\n@*/\n",
        "name": "instanceof_1.java",
        "path": "examples/java/instanceof/instanceof_1.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/instanceof/instanceof_1.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 26,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires x != null \u0026*\u0026 y != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "abstract class A {public String toString(){return \"A\";} }\n\nclass B extends A {}\n\nclass C extends A {}\n\ninterface iA {public String toString(); }\n\ninterface iB extends iA {}\n\ninterface iC extends iA {}\n\nclass main_fail{\n  public static void test_fail1(A x)\n    //@ requires true;\n    //@ ensures true;\n  {\n    iA tst = null;\n    if (x instanceof iC){\n      if(x instanceof iB){\n        tst.toString(); //~\n      }\n    }\n  }\n}",
        "name": "instanceof_3.java",
        "path": "examples/java/instanceof/instanceof_3.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/instanceof/instanceof_3.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "abstract class A {public String toString(){return \"A\";} }\n\nclass B extends A {}\n\nclass C extends A {}\n\ninterface iA {public String toString(); }\n\ninterface iB extends iA {}\n\nclass main_fail{\n  public static void test_fail2(A x)\n    //@ requires true;\n    //@ ensures true;\n  {\n    iA tst = null;\n    if (x instanceof C){\n      if(x instanceof iB){\n        tst.toString(); //~\n      }\n    }\n  }\n}",
        "name": "instanceof_4.java",
        "path": "examples/java/instanceof/instanceof_4.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/instanceof/instanceof_4.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "/*@\n\ninductive tree = empty(Tree node) | nonempty(Tree node, tree left, tree right);\n\nfixpoint int node_count(tree tree) {\n    switch (tree) {\n        case empty(node): return 1;\n        case nonempty(node, left, right): return 1 + node_count(left) + node_count(right);\n    }\n}\n\nlemma_auto void node_count_positive(tree tree)\n    requires true;\n    ensures node_count(tree) \u003e= 1;\n{\n    switch (tree) {\n        case empty(node):\n        case nonempty(node, left, right):\n            node_count_positive(left);\n            node_count_positive(right);\n    }\n}\n\npredicate tree(Tree node, boolean marked; Tree parent, tree shape) =\n    node.left |-\u003e ?left \u0026*\u0026\n    node.right |-\u003e ?right \u0026*\u0026\n    node.mark |-\u003e ?mark \u0026*\u0026 (marked ? mark == true : true) \u0026*\u0026\n    node.parent |-\u003e parent \u0026*\u0026\n    left == null ?\n        right == null \u0026*\u0026\n        shape == empty(node)\n    :\n        right != null \u0026*\u0026\n        tree(left, marked, node, ?leftShape) \u0026*\u0026\n        tree(right, marked, node, ?rightShape) \u0026*\u0026\n        shape == nonempty(node, leftShape, rightShape);\n\npredicate stack(Tree parent, Tree current, tree cShape, Tree root, tree rootShape, int stepsLeft) =\n    current != null \u0026*\u0026\n    parent == null ?\n        root == current \u0026*\u0026 rootShape == cShape \u0026*\u0026 stepsLeft == 0\n    :\n        parent.left |-\u003e ?left \u0026*\u0026\n        parent.right |-\u003e ?right \u0026*\u0026\n        parent.mark |-\u003e true \u0026*\u0026\n        parent.parent |-\u003e current \u0026*\u0026\n        exists\u003cboolean\u003e(?currentIsLeftChild) \u0026*\u0026\n        currentIsLeftChild ?\n            tree(left, false, parent, ?rightShape) \u0026*\u0026 left != null \u0026*\u0026\n            stack(right, parent, nonempty(parent, cShape, rightShape), root, rootShape, ?stepsLeft1) \u0026*\u0026 stepsLeft1 \u003e= 0 \u0026*\u0026\n            stepsLeft == node_count(rightShape) * 2 + 1 + stepsLeft1\n        :\n            tree(right, true, parent, ?leftShape) \u0026*\u0026 right != null \u0026*\u0026\n            stack(left, parent, nonempty(parent, leftShape, cShape), root, rootShape, ?stepsLeft1) \u0026*\u0026 stepsLeft1 \u003e= 0 \u0026*\u0026\n            stepsLeft == 1 + stepsLeft1;\n\nlemma void tree_nonnull(Tree t)\n    requires tree(t, ?marked, ?parent, ?shape);\n    ensures tree(t, marked, parent, shape) \u0026*\u0026 t != null;\n{\n    open tree(t, marked, parent, shape);\n    close tree(t, marked, parent, shape);\n}\n\npredicate inv(boolean xIsNew, Tree x, Tree root, tree rootShape, int stepsLeft) =\n        xIsNew ?\n            tree(x, false, ?parent, ?xShape) \u0026*\u0026 stack(parent, x, xShape, root, rootShape, ?stepsLeft1) \u0026*\u0026\n            stepsLeft1 \u003e= 0 \u0026*\u0026 stepsLeft == node_count(xShape) * 2 - 1 + stepsLeft1\n        :\n            stack(x, ?child, ?childShape, root, rootShape, stepsLeft) \u0026*\u0026 stepsLeft \u003e= 0 \u0026*\u0026\n            tree(child, true, x, childShape);\n    \n\n@*/\n\nclass Tree {\n\tTree left, right, parent;\n\tboolean mark;\n\t\n\tstatic void markTree(Tree root)\n\t    //@ requires tree(root, false, null, ?rootShape);\n\t    //@ ensures tree(root, true, null, rootShape);\n\t{\n\t\tTree x, y;\n\t\tx = root;\n\t\t//@ tree_nonnull(x);\n\t\t//@ close stack(null, root, rootShape, root, rootShape, 0);\n\t\t//@ close inv(true, x, root, rootShape, _);\n\t\tdo\n\t\t    //@ invariant inv(?xIsNew, x, root, rootShape, ?stepsLeft) \u0026*\u0026 x != null;\n\t\t    //@ decreases stepsLeft;\n\t\t{\n\t\t\t//@ open inv(_, _, _, _, _);\n\t\t\t//@ if (!xIsNew) open stack(x, _, _, _, _, _);\n\t  \t\tx.mark = true;\n\t  \t\tif (x.left == null \u0026\u0026 x.right == null) {\n\t    \t\t  \ty = x.parent;\n\t    \t\t  \t//@ close inv(false, y, root, rootShape, _);\n\t  \t\t} else {\n\t    \t\t\ty = x.left;\n\t    \t\t\tx.left = x.right;\n\t    \t\t\tx.right = x.parent;\n\t    \t\t\tx.parent = y;\n\t    \t\t\t/*@\n\t    \t\t\tif (xIsNew) {\n\t    \t\t\t    assert tree(y, false, x, ?leftShape);\n\t    \t\t\t    close exists(true);\n\t    \t\t\t    close stack(x, y, leftShape, root, rootShape, _);\n\t    \t\t\t    close inv(true, y, root, rootShape, _);\n\t    \t\t\t} else {\n\t    \t\t\t    open exists(?markedLeftSubtree);\n\t    \t\t\t    if (markedLeftSubtree) {\n\t    \t\t\t        close exists(false);\n\t    \t\t\t        assert tree(y, false, x, ?rightShape);\n\t    \t\t\t        tree_nonnull(x.right);\n\t    \t\t\t        close stack(x, y, rightShape, root, rootShape, _);\n\t    \t\t\t        close inv(true, y, root, rootShape, _);\n\t    \t\t\t    } else {\n\t    \t\t\t        close inv(false, y, root, rootShape, _);\n\t    \t\t\t    }\n\t    \t\t\t}\n\t    \t\t\t@*/\n\t  \t\t}\n\t\t \tx = y;\n\t\t} while (x != null);\n\t\t//@ open inv(_, _, _, _, _);\n\t\t//@ open stack(null, _, _, _, _, _);\n\t}\n}\n\n",
        "name": "tree_traversal.java",
        "path": "examples/verifythis2016/tree_traversal.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/verifythis2016/tree_traversal.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 80,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires tree(root, false, null, ?rootShape);"
        },
        {
          "limitHit": false,
          "lineNumber": 81,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures tree(root, true, null, rootShape);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import java.util.*;\n\npublic class Varargs\n{\n  public static void addAll(List\u003cObject\u003e l, Object ... xs)\n    //@ requires l.List(?l_es) \u0026*\u0026 [?f]xs[..] |-\u003e ?l_xs; \n    //@ ensures l.List(append(l_es, l_xs)) \u0026*\u0026 [f]xs[..] |-\u003e l_xs; \n  {\n    List\u003cObject\u003e temp = Arrays.asList(xs);\n    //@ close listIsCollection(temp, temp);\n    l.addAll(temp);\n  }\n\n  public static void main(String... args)\n    //@ requires true;\n    //@ ensures true;\n  {\n    List\u003cObject\u003e l = new ArrayList\u003cObject\u003e();\n    addAll(l, new Object(), new Object(), new Object());\n  }\n}\n",
        "name": "Varargs.java",
        "path": "examples/java/frontend/varargs/Varargs.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/varargs/Varargs.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires l.List(?l_es) \u0026*\u0026 [?f]xs[..] |-\u003e ?l_xs; "
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures l.List(append(l_es, l_xs)) \u0026*\u0026 [f]xs[..] |-\u003e l_xs; "
        },
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import subpackage1.*;\nimport subpackage2.*;\nimport subpackage3.*;\n\npublic class Main \n{\n  public static void main(String[] args) \n    //@ requires true;\n    //@ ensures true; \n  {\n    int add1 = Add1.add();\n    int add2 = Add2.add();\n    int add3 = Add3.add();\n    int add  = add1 + add2 + add3;\n    //@ assert add == 11 + 21 + 22 + 31 + 32 + 33;\n    \n    int mul1 = Multiply1.multiply();\n    int mul2 = Multiply2.multiply();\n    int mul3 = Multiply3.multiply();\n    int mul  = mul1 * mul2 * mul3;\n    //@ assert mul == 11 * 21 * 22 * 31 * 32 * 33;\n  }\n}\n",
        "name": "Main.java",
        "path": "examples/java/frontend/many_files/Main.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/many_files/Main.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true; "
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import java.util.*;\n\npublic class Foreach\n{\n  public static void main(String[] args)\n    //@ requires true;\n    //@ ensures true;\n  {\n    List\u003cInteger\u003e ints = new ArrayList\u003cInteger\u003e();\n    Integer i1 = new Integer(1);\n    Integer i2 = new Integer(2);\n    Integer i3 = new Integer(3);\n    Integer i4 = new Integer(4);\n    ints.add(i1); ints.add(i2); ints.add(i3); ints.add(i4);\n\n    //@ assert ints.List(?es);\n    int result = 0;\n    //@ ints.listToIterable();\n    for (Integer x : ints)\n      //@ requires i$.Iterator((seq_of_list)(es), _, ?n) \u0026*\u0026 n \u003e= 0 \u0026*\u0026 n \u003c= length(es);\n      //@ ensures  i$.Iterator((seq_of_list)(es), _, length(es));\n    {\n      result += x.intValue();\n    }\n  }\n}\n\n\n",
        "name": "Foreach.java",
        "path": "examples/java/frontend/foreach/Foreach.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/foreach/Foreach.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 19,
          "offsetAndLengths": [
            [
              6,
              13
            ]
          ],
          "preview": "      //@ requires i$.Iterator((seq_of_list)(es), _, ?n) \u0026*\u0026 n \u003e= 0 \u0026*\u0026 n \u003c= length(es);"
        },
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              6,
              12
            ]
          ],
          "preview": "      //@ ensures  i$.Iterator((seq_of_list)(es), _, length(es));"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package be.fedict.neweidapplet;\r\n\r\n/*@\r\n\r\ninductive triple\u003ca, b, c\u003e = triple(a, b, c);\r\n\r\ninductive quad\u003ca, b, c, d\u003e = quad(a, b, c, d);\r\n\r\n@*/\r\n\r\npublic abstract class File {\r\n\t/*@ predicate File(short theFileID, boolean activeState, any info) = \r\n\t \t[_]this.fileID |-\u003e theFileID \u0026*\u0026 this.active |-\u003e activeState\r\n\t \t\u0026*\u0026 info == unit; @*/\r\n\r\n\t// file identifier\r\n\tpublic short fileID;\r\n\tprotected boolean active;\r\n\t\r\n\tpublic File(short fid) \r\n  \t    //@ requires true;\r\n      \t    //@ ensures File(fid, true, _) \u0026*\u0026 valid_id(this);\r\n    \t{\r\n\t\tfileID = fid;\r\n\t\tactive = true;\r\n\t\t//@ leak File_fileID(this, _);\r\n\t\t//@ close valid_id(this);\r\n\t\t//@ close File(fid, true, _);\r\n\t}\r\n\tpublic short getFileID() \r\n\t    //@ requires [?f]valid_id(this);\r\n\t    //@ ensures [f]valid_id(this);\r\n\t{\r\n\t\t//@ open [f]valid_id(this);\r\n\t\treturn fileID;\r\n\t\t//@ close [f]valid_id(this);\r\n\t}\r\n\t\r\n\tpublic void setActive(boolean b)\r\n\t    //@ requires File(?fid, _, ?info);\r\n\t    //@ ensures File(fid, b, info);\r\n\t{\r\n\t\t//@ open File(fid, _, info);\r\n\t\tactive = b;\r\n\t\t//@ close File(fid, b, info);\r\n\t}\r\n\t\r\n\t/*VF* added because VeriFast can't access protected variables */\r\n\tpublic boolean isActive() \r\n\t    //@ requires [?f]File(?fid, ?state, ?info);\r\n\t    //@ ensures [f]File(fid, state, info) \u0026*\u0026 result == state;\r\n\t{\r\n\t\t//@ open [f]File(fid, state, info);\r\n\t\treturn active;\r\n\t\t//@ close [f]File(fid, state, info);\r\n\t}\r\n}\r\n",
        "name": "File.java",
        "path": "examples/java/Java Card/NewEidCard/File.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/NewEidCard/File.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures File(fid, true, _) \u0026*\u0026 valid_id(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 30,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires [?f]valid_id(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures [f]valid_id(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 39,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires File(?fid, _, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 40,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures File(fid, b, info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 49,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires [?f]File(?fid, ?state, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 50,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures [f]File(fid, state, info) \u0026*\u0026 result == state;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package iterator.singleton;\r\n\r\nimport iterator.it.*;\r\n\r\npublic class SingletonIterator implements Iterator {\r\n\r\n    Object value;\r\n    boolean done;\r\n    \r\n    /*@\r\n    \r\n    predicate valid(list\u003cObject\u003e elements) =\r\n        value |-\u003e ?v \u0026*\u0026 v != null \u0026*\u0026 done |-\u003e ?d \u0026*\u0026\r\n        d ? elements == nil : elements == cons(v, nil);\r\n    \r\n    @*/\r\n\r\n    public SingletonIterator(Object value)\r\n        //@ requires value != null;\r\n        //@ ensures valid(cons(value, nil));\r\n    {\r\n        this.value = value;\r\n        this.done = false;\r\n        //@ close valid(cons(value, nil));\r\n    }\r\n    \r\n    public boolean hasNext()\r\n        //@ requires valid(?ys);\r\n        //@ ensures valid(ys) \u0026*\u0026 result == (ys != nil);\r\n    {\r\n        //@ open valid(ys);\r\n        boolean result = !this.done;\r\n        //@ close valid(ys);\r\n        return result;\r\n    }\r\n    \r\n    public Object next()\r\n        //@ requires valid(?ys) \u0026*\u0026 ys != nil;\r\n        //@ ensures valid(tail(ys)) \u0026*\u0026 result == head(ys) \u0026*\u0026 result != null;\r\n    {\r\n        //@ open valid(ys);\r\n        this.done = true;\r\n        Object result = this.value;\r\n        //@ close valid(nil);\r\n        return result;\r\n    }\r\n\r\n}\r\n",
        "name": "SingletonIterator.java",
        "path": "examples/java/Iterator/SingletonIterator.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Iterator/SingletonIterator.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 18,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires value != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 19,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(cons(value, nil));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?ys);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(ys) \u0026*\u0026 result == (ys != nil);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 37,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid(?ys) \u0026*\u0026 ys != nil;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(tail(ys)) \u0026*\u0026 result == head(ys) \u0026*\u0026 result != null;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "// Note: VeriFast/Redux is much faster than VeriFast/Z3 on this applet. Use vfide -prover redux MyApplet.java or verifast -c -allow_assume -prover redux MyApplet.java\r\n\r\n// The assume statements in this file represent assumptions that the applet makes about the input.\r\n// What we are proving here is that in any execution of the applet where the input satisfies these assumptions, the applet does not dereference null pointers,\r\n// access arrays with indices that are out of bounds, divide by zero, perform arithmetic overflow, violate API contracts, or violate the assertions specified in the code.\r\n\r\npackage mypackage;\r\n\r\nimport javacard.framework.*;\r\nimport visa.openplatform.*;\r\n\r\n/*@\r\n\r\nlemma_auto void length_append_auto\u003ct\u003e(list\u003ct\u003e xs, list\u003ct\u003e ys)\r\n    requires true;\r\n    ensures length(append(xs, ys)) == length(xs) + length(ys);\r\n{\r\n    length_append(xs, ys);\r\n}\r\n\r\npredicate length_value_record(list\u003cbyte\u003e values, int start; int end) =\r\n    start \u003c length(values) \u0026*\u0026\r\n    0 \u003c= nth(start, values) \u0026*\u0026\r\n    start + 1 + nth(start, values) \u003c= length(values) \u0026*\u0026\r\n    end == start + 1 + nth(start, values);\r\n\r\npredicate element(list\u003cbyte\u003e values, int offset; byte value) =\r\n    offset \u003c length(values) \u0026*\u0026\r\n    value == nth(offset, values);\r\n\r\npredicate optional_data_records(byte[] array, int start, int count;) =\r\n    count == 0 ?\r\n        true\r\n    :\r\n        0 \u003c count \u0026*\u0026\r\n        array_slice(array, start, start + 2, _) \u0026*\u0026\r\n        array[start + 2] |-\u003e ?length \u0026*\u0026 0 \u003c= length \u0026*\u0026 length \u003c= MyApplet.MAX_LEN_OPTIONAL_DATA \u0026*\u0026\r\n        array_slice(array, start + 3, start + 3 + MyApplet.MAX_LEN_OPTIONAL_DATA, _) \u0026*\u0026\r\n        optional_data_records(array, start + 3 + MyApplet.MAX_LEN_OPTIONAL_DATA, count - 1);\r\n\r\nlemma void optional_data_records_split(byte[] array, int start, int offset)\r\n    requires [?f]optional_data_records(array, start, ?count) \u0026*\u0026 0 \u003c= offset \u0026*\u0026 offset \u003c= count;\r\n    ensures [f]optional_data_records(array, start, offset) \u0026*\u0026 [f]optional_data_records(array, start + offset * 13, count - offset);\r\n{\r\n    if (offset == 0) {\r\n        close [f]optional_data_records(array, start, 0);\r\n    } else {\r\n        open optional_data_records(array, start, count);\r\n        optional_data_records_split(array, start + 13, offset - 1);\r\n        close [f]optional_data_records(array, start, offset);\r\n    }\r\n}\r\n\r\nlemma void optional_data_records_merge(byte[] array, int start)\r\n    requires [?f]optional_data_records(array, start, ?count1) \u0026*\u0026 [f]optional_data_records(array, start + count1 * 13, ?count2);\r\n    ensures [f]optional_data_records(array, start, count1 + count2) \u0026*\u0026 0 \u003c= count1 + count2;\r\n{\r\n    open optional_data_records(array, start, count1);\r\n    if (count1 == 0) {\r\n        open optional_data_records(array, start, count2);\r\n        close [f]optional_data_records(array, start, count2);\r\n    } else {\r\n        optional_data_records_merge(array, start + 13);\r\n        close [f]optional_data_records(array, start, count1 + count2);\r\n    }\r\n}\r\n\r\npredicate record(int maxSizeRecord, byte[] record; unit info) =\r\n  record != null \u0026*\u0026\r\n  true == ((record).length == maxSizeRecord + MyApplet.LEN_RECORD_LEN_BYTE) \u0026*\u0026\r\n  array_element(record, 0, ?recordLength) \u0026*\u0026 0 \u003c= recordLength \u0026*\u0026 0 + recordLength \u003c= maxSizeRecord \u0026*\u0026\r\n  array_slice(record, 1, 6, _) \u0026*\u0026\r\n  array_element(record, 6, ?adfLength) \u0026*\u0026 0 \u003c= adfLength \u0026*\u0026 6 + adfLength \u003c= maxSizeRecord \u0026*\u0026\r\n  array_slice(record, 7, 1 + maxSizeRecord, _) \u0026*\u0026\r\n  info == unit;\r\n\r\npredicate my_record(int maxSizeRecord, Object record; unit info) =\r\n  record(maxSizeRecord, ^record, unit) \u0026*\u0026 info == unit;\r\n\r\npredicate MyApplet_(MyApplet applet; char nbRecords, byte maxSizeRecord) =\r\n  MyApplet_bya_FCI(?fci) \u0026*\u0026 array_slice(fci, 0, 23, _) \u0026*\u0026 fci.length == 23 \u0026*\u0026\r\n  applet.by_NbRecords |-\u003e nbRecords \u0026*\u0026 0 \u003c= nbRecords \u0026*\u0026\r\n  applet.by_MaxNbRecord |-\u003e ?maxNbRecord \u0026*\u0026 nbRecords \u003c= maxNbRecord \u0026*\u0026\r\n  applet.by_MaxSizeRecord |-\u003e maxSizeRecord \u0026*\u0026 maxSizeRecord \u003e= MyApplet.OFF_DATA_IN_RECORD + 5 \u0026*\u0026\r\n  applet.bya_OptionalData |-\u003e ?optionalData \u0026*\u0026 optionalData != null \u0026*\u0026 optionalData.length == MyApplet.SIZE_OPTIONAL_DATA_BUFFER \u0026*\u0026\r\n  optional_data_records(optionalData, 0, 3) \u0026*\u0026\r\n  applet.o_Records |-\u003e ?records \u0026*\u0026 records != null \u0026*\u0026 records.length == maxNbRecord \u0026*\u0026\r\n  array_slice_deep(records, 0, nbRecords, my_record, maxSizeRecord, _, _) \u0026*\u0026\r\n  array_slice(records, nbRecords, maxNbRecord, ?elems) \u0026*\u0026 all_eq(elems, null) == true;\r\n\r\n@*/\r\n\r\npublic final class MyApplet extends Applet {\r\n\r\n  static final boolean B_MODE_DEBUG = false;\r\n\r\n  static final byte DEF_MAX_ENTRIES = (byte) 5;\r\n  static final byte DEF_MAX_ENTRY_SIZE = (byte) 50;\r\n\r\n  static final byte  LEN_RECORD_LEN_BYTE = (byte) 01;\r\n  static final short OFF_DATA_IN_RECORD = (short) 01;\r\n\r\n  static final byte ADF_LEN_OFFSET = (byte) 10;\r\n  static final byte ADF_OFFSET = (byte) 11;\r\n\r\n  static final short MAX_LEN_OPTIONAL_DATA = (short) 10;\r\n  static final short MAX_LEN_OPTIONAL_DATA_AND_HEADER = (short)(MAX_LEN_OPTIONAL_DATA + 3);\r\n  static final short SIZE_OPTIONAL_DATA_BUFFER = (short)(3 * MAX_LEN_OPTIONAL_DATA_AND_HEADER);\r\n  static final short TAG_LANGUAGE_PREFERENCE = (short) 0x1234 ;\r\n  static final short TAG_ISSUER_CODE_TABLE_INDEX = (short) 0x1234 ;\r\n  static final short TAG_FCI_ISSUER_DISCRETIONARY_DATA = (short) 0x1234 ;\r\n\r\n  byte by_NbRecords;\r\n  byte by_MaxNbRecord;\r\n\r\n  byte by_MaxSizeRecord;\r\n\r\n  byte[] bya_OptionalData;\r\n\r\n  Object[] o_Records;\r\n\r\n  static final byte bya_FCI[] =\r\n  {\r\n    (byte)0x12, (byte)21,\r\n    (byte)0x12, (byte)14,\r\n    (byte)'X',  (byte)'X', (byte)'X', (byte)'X', (byte)'X',\r\n    (byte)'X',  (byte)'X', (byte)'X', (byte)'X',\r\n    (byte)'X',  (byte)'X', (byte)'X', (byte)'X', (byte)'X',\r\n    (byte)0x12, (byte)3,\r\n    (byte)0x12, (byte)1,  (byte)1\r\n  };\r\n\r\n    //@ predicate valid() = MyApplet_(this, _, _);\r\n\r\n  private MyApplet(byte[] byaBuffer, short shOffset, byte byLength, byte byMaxNbRecord, byte byMaxSizeRecord)\r\n    //@ requires system() \u0026*\u0026 0 \u003c= byMaxNbRecord \u0026*\u0026 6 \u003c= byMaxSizeRecord \u0026*\u0026 bya_FCI |-\u003e ?fci \u0026*\u0026 array_slice(fci, 0, 23, _) \u0026*\u0026 fci.length == 23 \u0026*\u0026 array_slice(byaBuffer, shOffset, shOffset + byLength, _);\r\n    //@ ensures true;\r\n  {\r\n    by_MaxNbRecord   = byMaxNbRecord;\r\n    by_MaxSizeRecord = byMaxSizeRecord;\r\n\r\n    bya_OptionalData = new byte[SIZE_OPTIONAL_DATA_BUFFER];\r\n    //@ close optional_data_records(bya_OptionalData, 3 * MAX_LEN_OPTIONAL_DATA_AND_HEADER, 0);\r\n    //@ close optional_data_records(bya_OptionalData, 2 * MAX_LEN_OPTIONAL_DATA_AND_HEADER, 1);\r\n    //@ close optional_data_records(bya_OptionalData, 1 * MAX_LEN_OPTIONAL_DATA_AND_HEADER, 2);\r\n    //@ close optional_data_records(bya_OptionalData, 0 * MAX_LEN_OPTIONAL_DATA_AND_HEADER, 3);\r\n\r\n    o_Records = new Object[by_MaxNbRecord];\r\n\r\n    ////@ close valid(); // auto\r\n    if( byLength == 0 )\r\n    {\r\n      register();\r\n    }\r\n    else\r\n    {\r\n      register(byaBuffer, shOffset, byLength);\r\n    }\r\n  }\r\n\r\n  public static void install(byte[] byaBuffer, short shOffset, byte byLength) throws ISOException /*@ ensures true; @*/\r\n    /*@\r\n    requires\r\n      system() \u0026*\u0026 class_init_token(MyApplet.class) \u0026*\u0026\r\n      byaBuffer != null \u0026*\u0026\r\n      shOffset \u003e= 0 \u0026*\u0026\r\n      array_slice(byaBuffer, shOffset, shOffset + byLength, ?values) \u0026*\u0026\r\n      length_value_record(values, 0, ?privilegesStart) \u0026*\u0026\r\n      length_value_record(values, privilegesStart, ?paramsStart) \u0026*\u0026\r\n      element(values, paramsStart + 1, ?paramsLength) \u0026*\u0026\r\n      element(values, paramsStart + 2, ?maxNbRecord) \u0026*\u0026 maxNbRecord \u003e= 0 \u0026*\u0026\r\n      element(values, paramsStart + 3, ?maxSizeRecord) \u0026*\u0026 maxSizeRecord \u003e= 6 \u0026*\u0026\r\n      shOffset + paramsStart + 3 \u003c= 32767;\r\n    @*/\r\n    //@ ensures true;\r\n  {\r\n    //@ init_class();\r\n    short shIndex = shOffset;\r\n    byte byMaxNbRecord   = DEF_MAX_ENTRIES ;\r\n    byte byMaxSizeRecord = DEF_MAX_ENTRY_SIZE;\r\n\r\n    //@ open length_value_record(values, 0, privilegesStart);\r\n    //@ open length_value_record(values, privilegesStart, _);\r\n    shIndex += (byaBuffer[shIndex]+1);\r\n    shIndex += (byaBuffer[shIndex]+1);\r\n\r\n    ++shIndex;\r\n    // BUG: byte byOffRecParam = (byte)shIndex ; The Java Card spec does not guarantee that the offset fits in a byte.\r\n    short byOffRecParam = shIndex ;\r\n    //@ open element(values, shIndex - shOffset, _);\r\n    //@ open element(values, shIndex + 1 - shOffset, _);\r\n    //@ open element(values, shIndex + 2 - shOffset, _);\r\n    byte byLenRecParam = byaBuffer[shIndex] ;\r\n    //\r\n    if (byLenRecParam != 0)\r\n    {\r\n      ++byOffRecParam;\r\n      byMaxNbRecord    = (byaBuffer[byOffRecParam] != 0) ? byaBuffer[byOffRecParam] : DEF_MAX_ENTRIES;\r\n      ++byOffRecParam;\r\n      byMaxSizeRecord  = (byaBuffer[byOffRecParam] != 0) ? byaBuffer[byOffRecParam] : DEF_MAX_ENTRY_SIZE;\r\n    }\r\n\r\n    new MyApplet(byaBuffer, (short)(shOffset+1), byaBuffer[shOffset], byMaxNbRecord, byMaxSizeRecord);\r\n  }\r\n\r\n  public void process(APDU oApdu)\r\n    /*@\r\n    requires\r\n      current_applet(this) \u0026*\u0026\r\n      [1/2]valid() \u0026*\u0026\r\n      oApdu != null \u0026*\u0026\r\n      APDU(oApdu, ?buffer) \u0026*\u0026\r\n      array_slice(buffer, 0, buffer.length, _);\r\n    @*/\r\n    /*@\r\n    ensures\r\n      current_applet(this) \u0026*\u0026\r\n      [1/2]valid() \u0026*\u0026\r\n      oApdu != null \u0026*\u0026\r\n      APDU(oApdu, buffer) \u0026*\u0026\r\n      array_slice(buffer, 0, buffer.length, _);\r\n    @*/\r\n  {\r\n    byte[] byaApdu = oApdu.getBuffer();\r\n\r\n    switch(sh(byaApdu[ISO7816.OFFSET_CLA]))\r\n    {\r\n    case 0x00:\r\n      switch(sh(byaApdu[ISO7816.OFFSET_INS]))\r\n      {\r\n      case 0xa4:\r\n        processSelectCmd(oApdu);\r\n        return;\r\n      case 0xb2:\r\n        processReadRecord(oApdu);\r\n        return;\r\n      case 0xe4:\r\n        processDeleteRecord(oApdu);\r\n        return;\r\n      case 0xc0:\r\n        return;\r\n      case 0xcb:\r\n        if (B_MODE_DEBUG)\r\n        {\r\n          /*\r\n          if(Util.getShort(byaApdu, (short)2) == (short)0x9f01)\r\n          {\r\n            byaApdu[4] = by_MaxNbRecord ;\r\n            byaApdu[5] = by_MaxSizeRecord ;\r\n            oApdu.setOutgoingAndSend((short)2, (short)4) ;\r\n            return;\r\n          }\r\n          */\r\n        }\r\n      default:\r\n        ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);\r\n      }\r\n    case 0x80 :\r\n      switch(sh(byaApdu[ISO7816.OFFSET_INS]))\r\n      {\r\n      case 0xda:\r\n        processPutData(oApdu);\r\n        return;\r\n      case 0xe2:\r\n        processAppendRecord(oApdu);\r\n        return;\r\n      default:\r\n        ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);\r\n      }\r\n    default:\r\n      ISOException.throwIt(ISO7816.SW_CLA_NOT_SUPPORTED);\r\n    }\r\n  }\r\n\r\n  private void processSelectCmd(APDU oApdu)\r\n    //@ requires [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    //@ ensures [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n  {\r\n    if ( !selectingApplet() )\r\n      ISOException.throwIt(ISO7816.SW_FILE_NOT_FOUND);\r\n    byte[] byaApdu = checkIncomingData(oApdu, true, false);\r\n    short shCurrentOffset = 0;\r\n    if (sh(byaApdu[ISO7816.OFFSET_LC]) == (short)0)\r\n      ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n    if((byaApdu[ISO7816.OFFSET_P1]) != 0x04)\r\n      ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n    ////@ open valid(); // auto\r\n    ////@ open MyApplet_(this, _, _); // auto\r\n    byte[] byaOptionalData = bya_OptionalData;\r\n    shCurrentOffset = Util.arrayCopyNonAtomic( bya_FCI, shCurrentOffset, byaApdu, (short)0, (short)bya_FCI.length );\r\n    byte k,j;\r\n    //@ int i = 2;\r\n    //@ optional_data_records_split(byaOptionalData, 0, i);\r\n\r\n\r\n    for(k=26,j=28 ; k\u003e=0 ; k-=13,j-=13)\r\n      /*@\r\n      invariant\r\n          -13 \u003c= k \u0026*\u0026 k \u003c= 26 \u0026*\u0026 j == k + 2 \u0026*\u0026 k == 13 * i \u0026*\u0026\r\n          array_slice(byaApdu, 0, byaApdu.length, _) \u0026*\u0026\r\n          23 \u003c= shCurrentOffset \u0026*\u0026\r\n          shCurrentOffset \u003c= 23 + 13 * (2 - i) \u0026*\u0026\r\n          k \u003c 0 ?\r\n              [1/2]optional_data_records(byaOptionalData, 0, 3)\r\n          :\r\n              [1/2]optional_data_records(byaOptionalData, 0, i) \u0026*\u0026 [1/2]optional_data_records(byaOptionalData, k, 3 - i);\r\n      @*/\r\n    {\r\n      //@ open optional_data_records(byaOptionalData, k, _); // auto\r\n      shCurrentOffset = Util.arrayCopyNonAtomic( byaOptionalData, k,\r\n          byaApdu, shCurrentOffset,\r\n          (byaOptionalData[j] != 0)? (short)(byaOptionalData[j] + 3): (short)0);\r\n      //@ close [1/2]optional_data_records(byaOptionalData, k, 3 - i);\r\n      //@ i--;\r\n      /*@\r\n      if (0 \u003c= i) {\r\n          optional_data_records_split(byaOptionalData, 0, i);\r\n          open optional_data_records(byaOptionalData, k - 13, _);\r\n          close [1/2]optional_data_records(byaOptionalData, k - 13, 3 - i);\r\n      }\r\n      @*/\r\n    }\r\n    shCurrentOffset -= /**/bya_FCI.length;\r\n    //@ assume(bya_FCI[3] == 14);\r\n    byaApdu[bya_FCI[3]+5] = (byte)(shCurrentOffset + 3);\r\n    byaApdu[1] = (byte)(shCurrentOffset + 3+2 + bya_FCI[3]+2);\r\n    oApdu.setOutgoingAndSend((short)0, (short)(sh(byaApdu[1]) + (short)2));\r\n    ////@ close [1/2]MyApplet_(this, _, _); // auto\r\n    ////@ close [1/2]valid(); // auto\r\n  }\r\n\r\n  private byte[] checkIncomingData(APDU oApdu, boolean bReceive, boolean bCheckPersoState)\r\n    //@ requires oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _);\r\n    //@ ensures APDU(oApdu, buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _) \u0026*\u0026 result == buffer_;\r\n  {\r\n    if (bCheckPersoState \u0026\u0026 OPSystem.getCardContentState() != OPSystem.APPLET_PERSONALIZED )\r\n      ISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);\r\n    if (bReceive) oApdu.setIncomingAndReceive();\r\n    return oApdu.getBuffer();\r\n  }\r\n\r\n  private void processPutData(APDU oApdu)\r\n    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n  {\r\n    byte[] byaApdu = checkIncomingData(oApdu, true, true); // true =\u003e personalization must have previously been done\r\n    short shLC = sh(byaApdu[ISO7816.OFFSET_LC]) ;\r\n\r\n    if (shLC \u003e MAX_LEN_OPTIONAL_DATA)\r\n      ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n\r\n    byte byIndex = getOptionalDataIndex(Util.getShort( byaApdu, ISO7816.OFFSET_P1 ));\r\n\r\n    JCSystem.beginTransaction(); // Inserted for VeriFast\r\n    ////@ open valid(); // auto\r\n    ////@ open MyApplet_(this, _, _); // auto\r\n    byte[] byaOptionalData = bya_OptionalData;\r\n    //@ optional_data_records_split(byaOptionalData, 0, byIndex);\r\n    //@ open optional_data_records(byaOptionalData, byIndex * MAX_LEN_OPTIONAL_DATA_AND_HEADER, 3 - byIndex);\r\n    Util.arrayCopy( byaApdu, ISO7816.OFFSET_P1,\r\n        byaOptionalData,\r\n        (short) (byIndex * MAX_LEN_OPTIONAL_DATA_AND_HEADER),\r\n        (short) (shLC + (short)3));\r\n    //@ assert byaOptionalData[byIndex * 13 + 2] |-\u003e ?length;\r\n    //@ assume(0 \u003c= length \u0026\u0026 length \u003c= MyApplet.MAX_LEN_OPTIONAL_DATA);\r\n    //@ close optional_data_records(byaOptionalData, byIndex * MAX_LEN_OPTIONAL_DATA_AND_HEADER, 3 - byIndex);\r\n    //@ optional_data_records_merge(byaOptionalData, 0);\r\n    ////@ close MyApplet_(this, _, _); // auto\r\n    ////@ close valid(); // auto\r\n    JCSystem.commitTransaction(); // Inserted for VeriFast\r\n  }\r\n\r\n  private byte getOptionalDataIndex(short tag)\r\n    //@ requires true;\r\n    //@ ensures 0 \u003c= result \u0026*\u0026 result \u003c= 2;\r\n  {\r\n    switch (tag)\r\n    {\r\n    case TAG_FCI_ISSUER_DISCRETIONARY_DATA : return 0 ;\r\n    case TAG_ISSUER_CODE_TABLE_INDEX : return 1;\r\n    case TAG_LANGUAGE_PREFERENCE : return 2;\r\n    default :\r\n      ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n    }\r\n  }\r\n\r\n  private void processAppendRecord(APDU oApdu)\r\n    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n  {\r\n    ////@ open valid(); // auto\r\n    ////@ open MyApplet_(this, _, _); // auto\r\n    byte[] byaApdu = checkIncomingData(oApdu, true, false);\r\n    short shLC = sh(byaApdu[ISO7816.OFFSET_LC]) ;\r\n    if((byaApdu[ISO7816.OFFSET_P1] != 0)\r\n        || (byaApdu[ISO7816.OFFSET_P2]\u00260x07) != 0)\r\n      ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n    if((byaApdu[ISO7816.OFFSET_P2]\u003e\u003e3) != 1)\r\n      ISOException.throwIt(ISO7816.SW_FILE_NOT_FOUND);\r\n     if ( shLC \u003e sh(by_MaxSizeRecord) )\r\n      ISOException.throwIt( ISO7816.SW_FILE_FULL );\r\n     //@ byte maxSizeRecord = by_MaxSizeRecord;\r\n    //@ assert 0 \u003c= shLC \u0026*\u0026 shLC \u003c= maxSizeRecord;\r\n\r\n    if (byaApdu[ISO7816.OFFSET_CDATA] != (byte)0x70)\r\n      ISOException.throwIt( ISO7816.SW_CONDITIONS_NOT_SATISFIED );\r\n\r\n    //@ assume(0 \u003c= byaApdu[ADF_LEN_OFFSET] \u0026\u0026 byaApdu[ADF_LEN_OFFSET] \u003c= 133 - ADF_OFFSET);\r\n    if (JCSystem.lookupAID( byaApdu, ADF_OFFSET, byaApdu[ADF_LEN_OFFSET] )== null)\r\n      ISOException.throwIt( ISO7816.SW_CONDITIONS_NOT_SATISFIED );\r\n\r\n    byte byFreeRecord = (byte)0x7F ;\r\n    byte [] byaRecordData ;\r\n\r\n    ////@ close [1/2]MyApplet_(this, _, _); // auto\r\n    for (byte i = 0; i \u003c by_NbRecords; i++)\r\n      /*@\r\n      invariant\r\n        [1/2]MyApplet_(this, ?nbRecords, maxSizeRecord) \u0026*\u0026\r\n        array_slice(byaApdu, 0, byaApdu.length, _) \u0026*\u0026 133 \u003c= byaApdu.length \u0026*\u0026\r\n        0 \u003c= i \u0026*\u0026 i \u003c= nbRecords \u0026*\u0026\r\n        (byFreeRecord != 0x7F ? 0 \u003c= byFreeRecord \u0026*\u0026 byFreeRecord \u003c i : true);\r\n      @*/\r\n    {\r\n      byaRecordData = (byte[]) (o_Records[i]);\r\n      //@ assume(0 \u003c= byaApdu[ADF_LEN_OFFSET] \u0026\u0026 byaApdu[ADF_LEN_OFFSET] \u003c= 133 - ADF_OFFSET \u0026\u0026 byaApdu[ADF_LEN_OFFSET] \u003c= byaRecordData.length - ADF_OFFSET);\r\n      if ((byaRecordData[0] != 0x00)\r\n          \u0026\u0026 Util.arrayCompare(byaApdu, ADF_OFFSET, byaRecordData, (short)(OFF_DATA_IN_RECORD+6), byaApdu[ADF_LEN_OFFSET]) == 0)\r\n        ISOException.throwIt( ISO7816.SW_CONDITIONS_NOT_SATISFIED );\r\n      if (byaRecordData[0] == 0x00)\r\n      {\r\n        byFreeRecord = i ;\r\n      }\r\n      //@ close [1/2]record(by_MaxSizeRecord, byaRecordData, unit);\r\n      ////@ close [1/2]MyApplet_(this, _, _); // auto\r\n    }\r\n    //@ assume(11 \u003c= shLC);\r\n\r\n    if (byFreeRecord != 0x7F)\r\n    {\r\n      //@ close [1/2]MyApplet_(this, _, _); // todo\r\n      JCSystem.beginTransaction();\r\n      //@ open valid(); // todo\r\n\r\n      byaRecordData = (byte[])o_Records[byFreeRecord];\r\n      //@ open record(by_MaxSizeRecord, byaRecordData, _);\r\n      Util.arrayCopy(byaApdu, ISO7816.OFFSET_CDATA, byaRecordData, OFF_DATA_IN_RECORD, shLC);\r\n      //@ assume(0 \u003c= byaRecordData[6] \u0026\u0026 byaRecordData[6] \u003c= by_MaxSizeRecord - 6);\r\n      byaRecordData[0] = (byte)shLC ;\r\n      //@ close record(by_MaxSizeRecord, byaRecordData, _);\r\n      ////@ close MyApplet_(this, _, _); // auto\r\n      ////@ close valid(); // auto\r\n      JCSystem.commitTransaction();\r\n    }\r\n    else\r\n    {\r\n\r\n      ////@ close [1/2]MyApplet_(this, _, _); // auto\r\n      JCSystem.beginTransaction();\r\n      //@ open valid();\r\n      //@ open MyApplet_(this, _, _);\r\n      if (by_NbRecords \u003e= by_MaxNbRecord)\r\n        ISOException.throwIt( ISO7816.SW_FILE_FULL );\r\n      o_Records[by_NbRecords] = new byte[by_MaxSizeRecord + LEN_RECORD_LEN_BYTE];\r\n      byaRecordData = (byte[])(o_Records[by_NbRecords]);\r\n      by_NbRecords++ ;\r\n\r\n      Util.arrayCopy(byaApdu, ISO7816.OFFSET_CDATA, byaRecordData, OFF_DATA_IN_RECORD, shLC);\r\n      //@ assume(0 \u003c= byaRecordData[6] \u0026\u0026 byaRecordData[6] \u003c= by_MaxSizeRecord - 6);\r\n      byaRecordData[0] = (byte)shLC ;\r\n      //@ close record(by_MaxSizeRecord, byaRecordData, unit);\r\n      ////@ close my_record(by_MaxSizeRecord, byaRecordData, unit); // auto\r\n      //@ array_slice_deep_close(o_Records, by_NbRecords - 1, my_record, maxSizeRecord);\r\n      ////@ close MyApplet_(this, _, _); // auto\r\n      ////@ close valid(); // auto\r\n      JCSystem.commitTransaction();\r\n    }\r\n    ////@ open valid(); // auto\r\n    ////@ open MyApplet_(this, _, _); // auto\r\n    if ((byFreeRecord == (byte)0x7F) \u0026\u0026 (by_NbRecords == 1))\r\n      OPSystem.setCardContentState( OPSystem.APPLET_PERSONALIZED );\r\n    ////@ close [1/2]MyApplet_(this, _, _); // auto\r\n    ////@ close [1/2]valid(); // auto\r\n  }\r\n\r\n  private static final byte MODE_DELETE_UNSET      = 0 ;\r\n  private static final byte MODE_DELETE_BY_NUMBER  = 1 ;\r\n  private static final byte MODE_DELETE_BY_AID     = 2 ;\r\n  private static final byte MODE_DELETE_BY_REFRESH = 3 ;\r\n\r\n  private void processDeleteRecord(APDU oApdu)\r\n    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n  {\r\n    byte[] byaApdu = checkIncomingData(oApdu, true, false);\r\n\r\n    byte byMode = MODE_DELETE_UNSET ;\r\n    switch(byaApdu[ISO7816.OFFSET_P2]\u00260x07)\r\n    {\r\n    case 0x00:\r\n      switch(byaApdu[ISO7816.OFFSET_P1])\r\n      {\r\n      case 0x00 :\r\n        byMode = MODE_DELETE_BY_AID ;\r\n        break ;\r\n      case 0x01 :\r\n        byMode = MODE_DELETE_BY_REFRESH ;\r\n        break ;\r\n      default:\r\n        ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n      }\r\n      break ;\r\n    case 0x04:\r\n      byMode = MODE_DELETE_BY_NUMBER ;\r\n      break ;\r\n    default:\r\n      ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n    }\r\n\r\n    if((byaApdu[ISO7816.OFFSET_P2]\u003e\u003e3) != 1)\r\n      ISOException.throwIt(ISO7816.SW_FILE_NOT_FOUND);\r\n    byte [] byaRecordData = null ;\r\n    if (byMode == MODE_DELETE_BY_NUMBER)\r\n    {\r\n\r\n      byte byRecordToDelete = /*@ truncating @*/ (byte)(byaApdu[ISO7816.OFFSET_P1]-1) ;\r\n      JCSystem.beginTransaction();\r\n      ////@ open valid(); // auto\r\n      ////@ open MyApplet_(this, _, _); // auto\r\n      if ((byRecordToDelete \u003c by_NbRecords) \u0026\u0026 (byRecordToDelete \u003e= 0))\r\n        byaRecordData = (byte[])(o_Records[byRecordToDelete]) ;\r\n      //\r\n      if (byaRecordData == null\r\n          || byaRecordData[0] == (byte)0)\r\n        ISOException.throwIt(ISO7816.SW_RECORD_NOT_FOUND);\r\n      //\r\n      byaRecordData[0] = (byte)0 ;\r\n      //@ close record(by_MaxSizeRecord, byaRecordData, unit); // auto\r\n      ////@ close MyApplet_(this, _, _); // auto\r\n      ////@ close valid(); // auto\r\n      JCSystem.commitTransaction();\r\n\r\n    }\r\n    else if (byMode == MODE_DELETE_BY_AID)\r\n    {\r\n\r\n            JCSystem.beginTransaction(); // Inserted for VeriFast\r\n            ////@ open valid(); // auto\r\n            //@ open MyApplet_(this, _, _);\r\n            ////@ close MyApplet_(this, _, _); // auto\r\n      for(byte i=0 ; i\u003cby_NbRecords ; i++)\r\n        /*@\r\n        invariant\r\n          MyApplet_(this, ?nbRecords, _) \u0026*\u0026\r\n          array_slice(byaApdu, 0, byaApdu.length, _) \u0026*\u0026 133 \u003c= byaApdu.length \u0026*\u0026\r\n          0 \u003c= i \u0026*\u0026 i \u003c= nbRecords;\r\n        @*/\r\n      {\r\n        byaRecordData = (byte[])(o_Records[i]) ;\r\n\r\n        if (Util.arrayCompare(byaApdu, ISO7816.OFFSET_CDATA,\r\n            byaRecordData, (short)(OFF_DATA_IN_RECORD+6), byaRecordData[OFF_DATA_IN_RECORD+5]) == 0)\r\n        {\r\n          byaRecordData[0] = (byte)0 ;\r\n          //@ close record(by_MaxSizeRecord, byaRecordData, unit);\r\n          ////@ close MyApplet_(this, _, _);  // auto\r\n          break;\r\n        }\r\n        //@ close record(by_MaxSizeRecord, byaRecordData, unit);\r\n      }\r\n      ////@ close valid();  // auto\r\n      JCSystem.commitTransaction(); // Inserted for VeriFast. TODO: Move closer to update.\r\n    }\r\n    else if (byMode == MODE_DELETE_BY_REFRESH)\r\n    {\r\n      JCSystem.beginTransaction(); // Inserted for VeriFast\r\n      ////@ open valid();  // auto\r\n      ////@ open MyApplet_(this, _, _);  // auto\r\n      //@ close MyApplet_(this, _, _);\r\n      for(short i=0 ; i\u003cby_NbRecords ; i++)\r\n        /*@\r\n        invariant\r\n          MyApplet_(this, ?nbRecords, _) \u0026*\u0026\r\n          array_slice(byaApdu, 0, byaApdu.length, _) \u0026*\u0026 133 \u003c= byaApdu.length \u0026*\u0026\r\n          0 \u003c= i \u0026*\u0026 i \u003c= nbRecords;\r\n        @*/\r\n      {\r\n        byaRecordData = (byte[])(o_Records[i]) ;\r\n          if (JCSystem.lookupAID( byaRecordData, (byte)(OFF_DATA_IN_RECORD+6), byaRecordData[OFF_DATA_IN_RECORD+5] )== null)\r\n        {\r\n          byaRecordData[0] = (byte)0;\r\n        }\r\n        //@ close record(by_MaxSizeRecord, byaRecordData, unit);\r\n      }\r\n      ////@ close valid();  // auto\r\n      JCSystem.commitTransaction();\r\n    }\r\n  }\r\n\r\n  private void processReadRecord(APDU oApdu)\r\n    //@ requires [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    //@ ensures [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n  {\r\n    ////@ open valid();  // auto\r\n    byte[] byaApdu = checkIncomingData(oApdu, false, true);\r\n    short shIndexRecord = (short)(sh(byaApdu[ISO7816.OFFSET_P1]) - (short)1);\r\n\r\n    if ((shIndexRecord \u003c (short)0) || (shIndexRecord \u003e= by_NbRecords))\r\n      ISOException.throwIt(ISO7816.SW_RECORD_NOT_FOUND);\r\n    if((byaApdu[ISO7816.OFFSET_P2]\u00260x07) != 4)\r\n      ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n\r\n    if((byaApdu[ISO7816.OFFSET_P2]\u003e\u003e3) != 1)\r\n      ISOException.throwIt(ISO7816.SW_FILE_NOT_FOUND);\r\n\r\n    byte [] byaRecordData = (byte[])(o_Records[shIndexRecord]) ;\r\n    short shLenRecord = sh(byaRecordData[0]);\r\n\r\n    if (shLenRecord == (short)0)\r\n      ISOException.throwIt(ISO7816.SW_RECORD_NOT_FOUND);\r\n\r\n    Util.arrayCopyNonAtomic(byaRecordData, OFF_DATA_IN_RECORD, byaApdu, ISO7816.OFFSET_CDATA, shLenRecord);\r\n\r\n    short shLE = oApdu.setOutgoing() ;\r\n\r\n    if (shLE == (short)0 || shLE \u003e shLenRecord) shLE = shLenRecord ;\r\n\r\n    oApdu.setOutgoingLength(shLE);\r\n    oApdu.sendBytes((short)0, (short)shLE);\r\n    //@ close [1/2]record(by_MaxSizeRecord, byaRecordData, unit);\r\n    ////@ close [1/2]MyApplet_(this, _, _); // auto\r\n    ////@ close [1/2]valid(); // auto\r\n  }\r\n\r\n  private short sh(byte byByte)\r\n    //@ requires true;\r\n    //@ ensures is_short_of_byte(result, byByte) == true \u0026*\u0026 0 \u003c= result \u0026*\u0026 result \u003c= 255;\r\n  {\r\n    short res = (short) (byByte \u0026 0xFF);\r\n    return res;\r\n    //@ assume (byByte \u003c 0 ? res == 256 + byByte : res == byByte);\r\n  }\r\n}\r\n//@ fixpoint boolean is_short_of_byte(short s, byte b) { return b \u003c 0 ? s == 256 + b : s == b; }\r\n",
        "name": "MyApplet-with-auto.java",
        "path": "examples/java/Java Card/MyApplet-with-auto.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/MyApplet-with-auto.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 135,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires system() \u0026*\u0026 0 \u003c= byMaxNbRecord \u0026*\u0026 6 \u003c= byMaxSizeRecord \u0026*\u0026 bya_FCI |-\u003e ?fci \u0026*\u0026 array_slice(fci, 0, 23, _) \u0026*\u0026 fci.length == 23 \u0026*\u0026 array_slice(byaBuffer, shOffset, shOffset + byLength, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 136,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 174,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 275,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 276,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 332,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 333,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures APDU(oApdu, buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _) \u0026*\u0026 result == buffer_;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 342,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 343,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 373,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 374,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures 0 \u003c= result \u0026*\u0026 result \u003c= 2;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 387,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 388,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 491,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 492,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 600,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 601,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 635,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 636,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures is_short_of_byte(result, byByte) == true \u0026*\u0026 0 \u003c= result \u0026*\u0026 result \u003c= 255;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "/**\n * This example shows how I/O style contracts can be used for\n * programs that do not perform I/O.\n *\n * In this example, we verify an implementation of the template pattern.\n * In the template pattern, a skeleton of an algorithm is implemented\n * in a method which we call the template methode. The\n * template method delegates some operations to subclasses by calling\n * methods that are overridden by the subclass.\n *\n * We want to define full functional behaviour, i.e. we want to prove\n * that calculations are correct, not only that they do not crash.\n * What are the specifications of the template method? It should state\n * that what the subclass does, is done. How can one specify this, since\n * it is unknown which subclasses there will be?\n *\n * In this example, the template method has an I/O style contract that states\n * that an I/O operation will be executed. The I/O operation is specific\n * to the subclass. This way, the template method's contract is an \n * easy I/O style contract.\n *\n * In this example, the I/O stye contract of the template method (which \n * is only written once: in the superclassis) is:\n *  requires this.token(?t1)\n *     \u0026*\u0026 m1_io(this.getClass())(t1, ?t2) // This is the calculation that the subclass will perform.\n *     \u0026*\u0026 m1_io(this.getClass())(t2, ?t3)\n *     \u0026*\u0026 m2_io(this.getClass())(t3, ?t4);\n *  ensures this.token(t4);\n *\n * This expresses: first the behaviour of the method m1 will\n * be performed, then the behaviour of m1 again, and then the behaviour of m2.\n * Multiple subclasses can define different behaviour of their implementation of m1 and m2.\n *\n * Subclasses can choose their own internal data representation.\n */\n\n/*@\n// t1 should not be precise, hence we cannot just use a predicate inside a class.\npredicate_family m1_io(Class c)(any t1; any t2);\npredicate_family m2_io(Class c)(any t1; any t2);\n@*/\n\n/**\n * Class that does a \"complex\" (here simplified since it's an example) calculation,\n * but delegates some steps to the subclass.\n */\npublic abstract class ComplexCalculation {\n  // predicate body is unused - subclasses can choose whatever representation they want.\n  //@ predicate token(any x) = x == default_value\u003cany\u003e \u0026*\u0026 false;\n\n  /**\n   * The template method from the Template Method Design Pattern.\n   * \n   * Does a \"complex\" calculation, delegating some parts to subclasses.\n   */\n  public void template()\n    /*@ requires this.token(?t1)\n      \u0026*\u0026 m1_io(this.getClass())(t1, ?t2) // This is the calculation that the subclass will perform.\n      \u0026*\u0026 m1_io(this.getClass())(t2, ?t3)\n      \u0026*\u0026 m2_io(this.getClass())(t3, ?t4);\n    @*/\n    //@ ensures this.token(t4);\n  {\n    // We delegate some steps to subclasses:\n    m1();\n    m1();\n    m2();\n  }\n\n  /**\n   * Method implemented by subclasses. It does a part of the \"complex\" calculation.\n   */\n  public abstract void m1();\n    //@ requires token(?t1) \u0026*\u0026 m1_io(this.getClass())(t1, ?t2);\n    //@ ensures token(t2);\n  \n  public abstract void m2();\n    //@ requires token(?t1) \u0026*\u0026 m2_io(this.getClass())(t1, ?t2);\n    //@ ensures token(t2);\n}\n\n\n/*@\npredicate_family_instance m1_io(Adder)(adder_place t1, adder_place t2) =\n  t1 == adder_place(?value)\n  \u0026*\u0026 value == Short.MAX_VALUE ?\n    t2 == t1\n  :\n    t2 == adder_place(value + 1)\n;\npredicate_family_instance m2_io(Adder)(adder_place t1, adder_place t2) =\n  t1 == adder_place(?value)\n  \u0026*\u0026 value \u003e Short.MAX_VALUE - 20 ?\n    t2 == t1\n  :\n    t2 == adder_place(value + 20)\n;\ninductive adder_place = adder_place(int value);\n@*/\n/**\n * Class that does a calculation, by adding a number.\n */\npublic class Adder extends ComplexCalculation {\n  short x = 0;\n  //@ predicate token(any t1) = this.x |-\u003e ?x \u0026*\u0026 t1 == adder_place(x);\n\n  public Adder()\n    //@ requires true;\n    //@ ensures token(adder_place(0));\n  {\n  }\n\n  public void m1()\n    //@ requires token(?t1) \u0026*\u0026 m1_io(Adder.class)(t1, ?t2);\n    //@ ensures token(t2);\n  {\n    //@ open token(t1);\n    //@ open m1_io(Adder.class)(_, _);\n    if (x != Short.MAX_VALUE){\n      x = (short)(x + 1);\n    }\n    //@ close token(t2);\n  }\n  \n  public void m2()\n    //@ requires token(?t1) \u0026*\u0026 m2_io(Adder.class )(t1, ?t2);\n    //@ ensures token(t2);\n  {\n    //@ open token(t1);\n    //@ open m2_io(Adder.class)(_, _);\n    if (x \u003c= Short.MAX_VALUE - 20){\n      x = (short)(x + 20);\n    }\n    //@ close token(t2);\n  }\n  \n  public int getValue()\n    //@ requires token(?t) \u0026*\u0026 exists\u003cint\u003e(?v) \u0026*\u0026 t == adder_place(v);\n    //@ ensures token(t) \u0026*\u0026 result == v;\n  {\n    return x;\n  }\n}\n\n/*@\npredicate_family_instance m1_io(Multiplier)(multiplier_place t1, multiplier_place t2) =\n  t1 == multiplier_place(?x)\n  \u0026*\u0026 x * 2 \u003e Integer.MAX_VALUE ? // Would cause integer overflow\n    t2 == t1\n  :\n    t2 == multiplier_place(x * 2)\n;\npredicate_family_instance m2_io(Multiplier)(multiplier_place t1, multiplier_place t2) = \n  t1 == multiplier_place(?x)\n  \u0026*\u0026 x * 3 \u003e Integer.MAX_VALUE ? // Would cause integer overflow\n    t2 == t1\n  :\n    t2 == multiplier_place(x * 3)\n;\n\ninductive multiplier_place = multiplier_place(int x);\n@*/\n\n\n/**\n * Class that does a calculation, by multiplying a number.\n */\npublic class Multiplier extends ComplexCalculation {\n  int value = 1; // It is possible to have a different representation.\n  /*@\n  predicate token(any t) =\n    this.value |-\u003e ?value\n    \u0026*\u0026 value \u003e= 0\n    \u0026*\u0026 t == multiplier_place(value);\n  @*/\n  \n  public Multiplier()\n  //@ requires true;\n  //@ ensures token(multiplier_place(1));\n  {\n  }\n\n  public void m1()\n    //@ requires token(?t1) \u0026*\u0026 m1_io(Multiplier.class)(t1, ?t2);\n    //@ ensures token(t2);\n  {\n    //@ open token(t1);\n    //@ open m1_io(Multiplier.class)(_, _);\n    if (value \u003c= Integer.MAX_VALUE / 2){\n      value = value * 2;\n    }\n    //@ close token(t2);\n  } \n  \n  public void m2()\n    //@ requires token(?t1) \u0026*\u0026 m2_io(Multiplier.class)(t1, ?t2);\n    //@ ensures token(t2);\n  {\n    //@ open token(t1);\n    //@ open m2_io(Multiplier.class)(_, _);\n    if (value \u003c= Integer.MAX_VALUE / 3){\n      value = value * 3;\n    }\n    //@ close token(t2);\n  } \n  \n  public int getValue()\n    //@ requires token(?t);\n    //@ ensures token(t) \u0026*\u0026 exists\u003cint\u003e(?x) \u0026*\u0026 t == multiplier_place(x) \u0026*\u0026 result == x;\n  {\n    return value;\n    //@ close exists(value);\n  }\n}\n\npublic class Test {\n  public static void main(String[] args)\n  //@ requires true;\n  //@ ensures true;\n  {\n    Adder calc1 = new Adder();\n    //@ close m1_io(Adder.class)(adder_place(0), ?t2);\n    //@ close m1_io(Adder.class)(t2, ?t3);\n    //@ close m2_io(Adder.class)(t3, ?t4);\n    calc1.template();\n    //@ close exists(22);\n    int should_be_22 = calc1.getValue();\n     assert should_be_22 == 22;\n    // Or a ghost assert: (both are statically checked by VeriFast)\n    //@ assert should_be_22 == 22;\n    \n    Multiplier calc2 = new Multiplier();\n    //@ assert calc2.token(?calc2_t1);\n    //@ close m1_io(Multiplier.class)(multiplier_place(1), ?calc2_t2);\n    //@ close m1_io(Multiplier.class)(calc2_t2, ?calc2_t3);\n    //@ close m2_io(Multiplier.class)(calc2_t3, ?calc2_t4);\n    calc2.template();\n    int should_be_12 = calc2.getValue();\n    assert should_be_12 == 12;\n    \n  }\n}\n\n\n\n",
        "name": "TemplateMethod.java",
        "path": "examples/io/template_method/TemplateMethod.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/io/template_method/TemplateMethod.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 61,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures this.token(t4);"
        },
        {
          "limitHit": false,
          "lineNumber": 73,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires token(?t1) \u0026*\u0026 m1_io(this.getClass())(t1, ?t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 74,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures token(t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 77,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires token(?t1) \u0026*\u0026 m2_io(this.getClass())(t1, ?t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 78,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures token(t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 107,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures token(adder_place(0));"
        },
        {
          "limitHit": false,
          "lineNumber": 113,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires token(?t1) \u0026*\u0026 m1_io(Adder.class)(t1, ?t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 114,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures token(t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 125,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires token(?t1) \u0026*\u0026 m2_io(Adder.class )(t1, ?t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 126,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures token(t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 137,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires token(?t) \u0026*\u0026 exists\u003cint\u003e(?v) \u0026*\u0026 t == adder_place(v);"
        },
        {
          "limitHit": false,
          "lineNumber": 138,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures token(t) \u0026*\u0026 result == v;"
        },
        {
          "limitHit": false,
          "lineNumber": 177,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 178,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures token(multiplier_place(1));"
        },
        {
          "limitHit": false,
          "lineNumber": 183,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires token(?t1) \u0026*\u0026 m1_io(Multiplier.class)(t1, ?t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 184,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures token(t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 195,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires token(?t1) \u0026*\u0026 m2_io(Multiplier.class)(t1, ?t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 196,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures token(t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 207,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires token(?t);"
        },
        {
          "limitHit": false,
          "lineNumber": 208,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures token(t) \u0026*\u0026 exists\u003cint\u003e(?x) \u0026*\u0026 t == multiplier_place(x) \u0026*\u0026 result == x;"
        },
        {
          "limitHit": false,
          "lineNumber": 217,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 218,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import subpackage.Multiply;\n\npublic class Main \n{\n  public static void main(String[] args) \n    //@ requires true;\n    //@ ensures true; \n  {\n    Multiply mul = new Multiply();\n    int i = mul.multiply();\n    //@ assert i == 30;\n  }\n}\n",
        "name": "Main.java",
        "path": "examples/java/frontend/multiple_files/Main.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/multiple_files/Main.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true; "
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class MyException extends Exception \n{\n}\n\npublic class Exceptions\n{  \n  private static void test(boolean throw_or_not) throws MyException /*@ ensures throw_or_not == true; @*/ \n    //@ requires true;\n    //@ ensures throw_or_not == false;\n  {\n    int i;\n    \n    if (throw_or_not)\n      throw new MyException();\n  }\n  \n  public static void main(String[] args)\n    //@ requires true;\n    //@ ensures true;\n  {\n    //@ int branch = 0;\n    \n    //Unchecked\n    Object i = null;\n    try\n    {\n      if (i == null)\n        throw new NullPointerException();\n      \n      //@ branch = 1;\n    }\n    catch (NullPointerException e)\n    {\n      //@ branch = 2;\n    }    \n    //@ assert (branch == 2);\n    \n    //Checked\n    //@ branch = 0;\n    try\n    {\n      test(false);\n      //@ branch = 1;\n    }\n    catch (MyException e)\n    {\n      //@ branch = 2;\n    }\n    //@ assert (branch == 1);\n    \n    //@ branch = 0;\n    try\n    {\n      test(true);\n      //@ branch = 1;\n    }\n    catch (MyException e)\n    {\n      //@ branch = 2;\n    }\n    //@ assert (branch == 2);\n  }\n}\n\n\n",
        "name": "Exceptions.java",
        "path": "examples/java/frontend/exceptions/Exceptions.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/exceptions/Exceptions.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures throw_or_not == false;"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 18,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "// Note: on this program, VeriFast/Redux is much faster than VeriFast/Z3! (2s versus 70s). To use Redux, use:\r\n//   vfide -prover redux NewEidCard.java\r\n//   verifast -c -prover redux NewEidCard.java\r\n\r\n/*\r\n                           \r\n                                         @@@@                                \r\n                                     @@@@@@@@@@@                             \r\n                                @@@@@@@@@@@@@@@@@@@@@                        \r\n                          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  \r\n                @@@@@@@@@@@@@@@@@@@@@@@@.....@@@@@@@@@@@@@@@@@@@@@@@@@       \r\n                @@@@@@@@@@@@@@@@@@@@.............@@@@@@@@@@@@@@@@@@@@@       \r\n                @@@@@@@@@@@@@@.........................@@@@@@@@@@@@@@@       \r\n                @@@@@............................................@@@@@       \r\n                @@@@@............................................@@@@        \r\n                @@@@@............................................@@@@        \r\n                 @@@@............................................@@@@        \r\n                 @@@@......::::.................::::::::::::.....@@@@        \r\n                 @@@@......'@@@,...............'@@@@@@@@@@@@,...@@@@@        \r\n                  @@@@......#@@@..............:@@@,.............@@@@         \r\n                  @@@@.......@@@#.............@@@'..............@@@@         \r\n                  @@@@.......,@@@;...........#@@#..............@@@@@         \r\n                   @@@@.......;@@@..........'@@@@@@@@@+........@@@@          \r\n                   @@@@........+@@@........:@@@''''''';........@@@@          \r\n                    @@@@........@@@+.......@@@:...............@@@@           \r\n                    @@@@.........@@@,.....#@@'................@@@@           \r\n                     @@@@........,@@@....'@@#................@@@@            \r\n                      @@@@........'@@#..,@@@................@@@@             \r\n                      @@@@.........#@@;.@@@................@@@@              \r\n                       @@@@.........@@@+@@:...............@@@@@              \r\n                        @@@@........,@@@@+...............@@@@@               \r\n                         @@@@@..........................@@@@@                \r\n                          @@@@@........................@@@@@                 \r\n                           @@@@@......................@@@@                   \r\n                             @@@@@..................@@@@@                    \r\n                              @@@@@@..............@@@@@@                     \r\n                                @@@@@@..........@@@@@@                       \r\n                                 @@@@@@@......@@@@@@                         \r\n                                   @@@@@@@@@@@@@@@                           \r\n                                      @@@@@@@@@@\r\n                                      \r\n                                Powered by VeriFast (c)\r\n*/\r\n\r\n\r\n/*\r\n * Quick-Key Toolset Project.\r\n * Copyright (C) 2010 FedICT.\r\n *\r\n * This is free software; you can redistribute it and/or modify it\r\n * under the terms of the GNU Lesser General Public License version\r\n * 3.0 as published by the Free Software Foundation.\r\n *\r\n * This software is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this software; if not, see \r\n * http://www.gnu.org/licenses/.\r\n */\r\npackage be.fedict.neweidapplet;\r\n\r\nimport javacard.security.KeyPair;\r\nimport javacard.security.RSAPrivateKey;\r\nimport javacard.security.RSAPrivateCrtKey;\r\nimport javacard.security.RSAPublicKey;\r\nimport javacard.security.RandomData;\r\nimport javacardx.crypto.Cipher;\r\nimport org.globalplatform.GPSystem;\r\n\r\nimport newepurse.IEPurseServicesCredit;\r\n\r\n/*VF*ADDED FOLLOWING IMPORTS*/\r\nimport javacard.framework.*;\r\nimport javacard.security.PrivateKey;\r\nimport javacard.security.PublicKey;\r\n/*VF*ADDED FOLLOWING CLASSES*/\r\n\r\n\r\n/*VF*DONE ADDING CLASSES*/\r\n\r\n/*@\r\n  predicate array_pointer(byte[] buffer, short length) =\r\n    buffer == null ?\r\n      true\r\n    :\r\n      array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer.length == length;\r\n\r\n  predicate transient_array_pointer(byte[] buffer, short length) =\r\n    buffer == null ?\r\n      true\r\n    :\r\n      array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer.length == length \u0026*\u0026 is_transient_byte_array(buffer) == true;\r\n\r\n  predicate selected_file_types(File theSelectedFile, MasterFile theMasterFile, DedicatedFile theBelpicDirectory, DedicatedFile theIdDirectory, ElementaryFile theIdentityFile, ElementaryFile theIdentityFileSignature, ElementaryFile theAddressFile, ElementaryFile theAddressFileSignature, ElementaryFile thePhotoFile, \r\n      ElementaryFile thecaRoleIDFile, ElementaryFile theDirFile, ElementaryFile theTokenInfo, ElementaryFile theObjectDirectoryFile, ElementaryFile theAuthenticationObjectDirectoryFile, ElementaryFile thePrivateKeyDirectoryFile, ElementaryFile theCaCertificate, ElementaryFile theCertificateDirectoryFile, ElementaryFile theRrnCertificate, ElementaryFile theRootCaCertificate, ElementaryFile theAuthenticationCertificate, ElementaryFile theNonRepudationCertificate, ElementaryFile thePreferencesFile; ElementaryFile theSelectedFile2) = \r\n        theSelectedFile == theMasterFile || theSelectedFile == theBelpicDirectory || theSelectedFile == theIdDirectory ? theSelectedFile2 == null : \r\n          theSelectedFile == theIdentityFile ? theSelectedFile2 == theIdentityFile : \r\n            theSelectedFile == theIdentityFileSignature ? theSelectedFile2 == theIdentityFileSignature : \r\n              theSelectedFile == theAddressFile ? theSelectedFile2 == theAddressFile : \r\n                theSelectedFile == theAddressFileSignature ? theSelectedFile2 == theAddressFileSignature : \r\n                  theSelectedFile == thePhotoFile ? theSelectedFile2 == thePhotoFile : \r\n                    theSelectedFile == thecaRoleIDFile ? theSelectedFile2 == thecaRoleIDFile : \r\n                      theSelectedFile == theDirFile ? theSelectedFile2 == theDirFile : \r\n                        theSelectedFile == theTokenInfo ? theSelectedFile2 == theTokenInfo : \r\n                          theSelectedFile == theObjectDirectoryFile ? theSelectedFile2 == theObjectDirectoryFile : \r\n                            theSelectedFile == theAuthenticationObjectDirectoryFile ? theSelectedFile2 == theAuthenticationObjectDirectoryFile : \r\n                               theSelectedFile == thePrivateKeyDirectoryFile ? theSelectedFile2 == thePrivateKeyDirectoryFile : \r\n                                    theSelectedFile == theCaCertificate ? theSelectedFile2 == theCaCertificate :\r\n                                      theSelectedFile == theRrnCertificate ? theSelectedFile2 == theRrnCertificate :\r\n                                        theSelectedFile == theRootCaCertificate ? theSelectedFile2 == theRootCaCertificate :\r\n                                          theSelectedFile == theAuthenticationCertificate ? theSelectedFile2 == theAuthenticationCertificate :\r\n                                            theSelectedFile == theNonRepudationCertificate ? theSelectedFile2 == theNonRepudationCertificate :\r\n                                              theSelectedFile == thePreferencesFile ? theSelectedFile2 == thePreferencesFile :\r\n                                                (theSelectedFile == theCertificateDirectoryFile \u0026*\u0026 theSelectedFile2 == theCertificateDirectoryFile);\r\n\r\n@*/\r\n\r\n//@ predicate eq\u003cT\u003e(T t1; T t2) = t2 == t1;\r\n\r\n//@ predicate selected_file_class(File theSelectedFile;) = (theSelectedFile.getClass() == ElementaryFile.class || theSelectedFile.getClass() == MasterFile.class || theSelectedFile.getClass() == DedicatedFile.class);\r\n\r\npublic final class NewEidCard extends Applet {\r\n    /*@\r\n    \r\n          predicate valid() =\r\n            randomBuffer |-\u003e ?theRandomBuffer \u0026*\u0026 theRandomBuffer != null \u0026*\u0026 array_slice(theRandomBuffer, 0, theRandomBuffer.length, _) \u0026*\u0026 theRandomBuffer.length == 256 \u0026*\u0026\r\n            responseBuffer |-\u003e ?theResponseBuffer \u0026*\u0026 theResponseBuffer != null \u0026*\u0026 array_slice(theResponseBuffer, 0, theResponseBuffer.length, _) \u0026*\u0026 theResponseBuffer.length == 128 \u0026*\u0026\r\n            randomData |-\u003e ?theRandomData \u0026*\u0026 theRandomData != null \u0026*\u0026\r\n            cipher |-\u003e ?theCipher \u0026*\u0026 theCipher != null \u0026*\u0026\r\n            messageBuffer |-\u003e ?theMessageBuffer \u0026*\u0026 theMessageBuffer != null \u0026*\u0026 theMessageBuffer.length == 128 \u0026*\u0026 is_transient_byte_array(theMessageBuffer) == true \u0026*\u0026\r\n            previousApduType |-\u003e ?thePreviousApduType \u0026*\u0026 thePreviousApduType != null \u0026*\u0026 thePreviousApduType.length == 1 \u0026*\u0026 is_transient_byte_array(thePreviousApduType) == true \u0026*\u0026\r\n            signatureType |-\u003e ?theSignatureType \u0026*\u0026 theSignatureType != null \u0026*\u0026 theSignatureType.length == 1 \u0026*\u0026 is_transient_byte_array(theSignatureType) == true \u0026*\u0026\r\n            masterFile |-\u003e ?theMasterFile \u0026*\u0026 theMasterFile.MasterFile(0x3F00, null, _, ?masterSibs, _) \u0026*\u0026 theMasterFile != null \u0026*\u0026 theMasterFile.getClass() == MasterFile.class \u0026*\u0026\r\n            cardholderPin |-\u003e ?theCardholderPin \u0026*\u0026 OwnerPIN(theCardholderPin, _, _) \u0026*\u0026 theCardholderPin != null \u0026*\u0026 \r\n            resetPin |-\u003e ?theResetPin \u0026*\u0026 OwnerPIN(theResetPin, _, _) \u0026*\u0026 theResetPin != null \u0026*\u0026\r\n            unblockPin |-\u003e ?theUnblockPin \u0026*\u0026 OwnerPIN(theUnblockPin, _, _) \u0026*\u0026 theUnblockPin != null \u0026*\u0026\r\n            activationPin |-\u003e ?theActivationPin \u0026*\u0026 OwnerPIN(theActivationPin, _, _) \u0026*\u0026 theActivationPin != null \u0026*\u0026\r\n            identityFile |-\u003e ?theIdentityFile \u0026*\u0026 theIdentityFile.ElementaryFile(_, _, ?identityData, _, _, _) \u0026*\u0026 theIdentityFile != null \u0026*\u0026 identityData != null \u0026*\u0026 identityData.length == 0xD0 \u0026*\u0026 theIdentityFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n            identityFileSignature |-\u003e ?theIdentityFileSignature \u0026*\u0026 theIdentityFileSignature.ElementaryFile(_, _, ?theIdentityFileSignatureData, _, _, _) \u0026*\u0026 theIdentityFileSignature != null \u0026*\u0026 theIdentityFileSignatureData != null \u0026*\u0026 theIdentityFileSignatureData.length == 0x80 \u0026*\u0026 theIdentityFileSignature.getClass() == ElementaryFile.class \u0026*\u0026\r\n            addressFile |-\u003e ?theAddressFile \u0026*\u0026 theAddressFile.ElementaryFile(_, _, ?theAddressFileData, _, _, _) \u0026*\u0026 theAddressFile != null \u0026*\u0026 theAddressFileData != null \u0026*\u0026 theAddressFileData.length == 117 \u0026*\u0026 theAddressFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n            addressFileSignature |-\u003e ?theAddressFileSignature \u0026*\u0026 theAddressFileSignature.ElementaryFile(_, _, ?theAddressFileSignatureData, _, _, _) \u0026*\u0026 theAddressFileSignature != null \u0026*\u0026 theAddressFileSignatureData != null \u0026*\u0026 theAddressFileSignatureData.length == 128 \u0026*\u0026 theAddressFileSignature.getClass() == ElementaryFile.class \u0026*\u0026\r\n            photoFile |-\u003e ?thePhotoFile \u0026*\u0026 thePhotoFile.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 thePhotoFile != null \u0026*\u0026 thePhotoFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n            caRoleIDFile |-\u003e ?thecaRoleIDFile \u0026*\u0026 thecaRoleIDFile.ElementaryFile(_, _, ?theCaRoleIDFileData, _, _, _) \u0026*\u0026 thecaRoleIDFile != null \u0026*\u0026 theCaRoleIDFileData != null \u0026*\u0026 theCaRoleIDFileData.length == 0x20 \u0026*\u0026 thecaRoleIDFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n            dirFile |-\u003e ?theDirFile \u0026*\u0026 theDirFile.ElementaryFile(_, _, ?theDirFileData, _, _, _) \u0026*\u0026 theDirFile != null \u0026*\u0026 theDirFileData != null \u0026*\u0026 theDirFileData.length ==  0x25 \u0026*\u0026 theDirFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n            tokenInfo |-\u003e ?theTokenInfo \u0026*\u0026 theTokenInfo.ElementaryFile(_, _, ?theTokenInfoData, _, _, _) \u0026*\u0026 theTokenInfo != null \u0026*\u0026 theTokenInfoData != null \u0026*\u0026 theTokenInfoData.length == 0x30 \u0026*\u0026 theTokenInfo.getClass() == ElementaryFile.class \u0026*\u0026\r\n            objectDirectoryFile |-\u003e ?theObjectDirectoryFile \u0026*\u0026 theObjectDirectoryFile.ElementaryFile(_, _, ?theObjectDirectoryFileData, _, _, _) \u0026*\u0026 theObjectDirectoryFile != null \u0026*\u0026 theObjectDirectoryFileData != null \u0026*\u0026 theObjectDirectoryFileData.length == 40 \u0026*\u0026 theObjectDirectoryFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n            authenticationObjectDirectoryFile |-\u003e ?theAuthenticationObjectDirectoryFile \u0026*\u0026 theAuthenticationObjectDirectoryFile.ElementaryFile(_, _, ?theAuthenticationObjectDirectoryFileData, _, _, _) \u0026*\u0026 theAuthenticationObjectDirectoryFile != null \u0026*\u0026 theAuthenticationObjectDirectoryFileData != null \u0026*\u0026 theAuthenticationObjectDirectoryFileData.length == 0x40 \u0026*\u0026  theAuthenticationObjectDirectoryFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n            privateKeyDirectoryFile |-\u003e ?thePrivateKeyDirectoryFile \u0026*\u0026 thePrivateKeyDirectoryFile.ElementaryFile(_, _, ?thePrivateKeyDirectoryFileData, _, _, _) \u0026*\u0026 thePrivateKeyDirectoryFile != null \u0026*\u0026 thePrivateKeyDirectoryFileData != null \u0026*\u0026 thePrivateKeyDirectoryFileData.length == 0xB0 \u0026*\u0026 thePrivateKeyDirectoryFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n            certificateDirectoryFile |-\u003e ?theCertificateDirectoryFile \u0026*\u0026 theCertificateDirectoryFile.ElementaryFile(_, _, ?theCertificateDirectoryFileData, _, _, _) \u0026*\u0026 theCertificateDirectoryFile != null \u0026*\u0026 theCertificateDirectoryFileData != null \u0026*\u0026 theCertificateDirectoryFileData.length == 0xB0 \u0026*\u0026 theCertificateDirectoryFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n            belpicDirectory |-\u003e ?theBelpicDirectory \u0026*\u0026 theBelpicDirectory.DedicatedFile(_, _, _, ?belpicSibs, _) \u0026*\u0026 theBelpicDirectory != null \u0026*\u0026 theBelpicDirectory.getClass() == DedicatedFile.class \u0026*\u0026\r\n            idDirectory |-\u003e ?theIdDirectory \u0026*\u0026 theIdDirectory.DedicatedFile(_, _, _, ?idSibs, _) \u0026*\u0026 theIdDirectory != null \u0026*\u0026 theIdDirectory.getClass() == DedicatedFile.class \u0026*\u0026\r\n            caCertificate |-\u003e ?theCaCertificate \u0026*\u0026 theCaCertificate.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 theCaCertificate.getClass() == ElementaryFile.class \u0026*\u0026\r\n        selectedFile |-\u003e ?theSelectedFile \u0026*\u0026 theSelectedFile != null \u0026*\u0026\r\n        masterSibs == cons\u003cFile\u003e(theDirFile, cons(theBelpicDirectory, cons(theIdDirectory, nil))) \u0026*\u0026\r\n        rootCaCertificate |-\u003e ?theRootCaCertificate \u0026*\u0026 theRootCaCertificate.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 theRootCaCertificate.getClass() == ElementaryFile.class \u0026*\u0026\r\n        rrnCertificate |-\u003e ?theRrnCertificate \u0026*\u0026 theRrnCertificate.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 theRrnCertificate.getClass() == ElementaryFile.class \u0026*\u0026\r\n        authenticationCertificate |-\u003e ?theAuthenticationCertificate \u0026*\u0026 theAuthenticationCertificate.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 theAuthenticationCertificate.getClass() == ElementaryFile.class \u0026*\u0026\r\n        nonRepudiationCertificate |-\u003e ?theNonRepudiationCertificate \u0026*\u0026 theNonRepudiationCertificate.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 theNonRepudiationCertificate.getClass() == ElementaryFile.class \u0026*\u0026\r\n        preferencesFile |-\u003e ?thePreferencesFile \u0026*\u0026 thePreferencesFile != theCaCertificate \u0026*\u0026 thePreferencesFile != theRrnCertificate \u0026*\u0026 thePreferencesFile.ElementaryFile(_, _, ?thePreferencesFileData, _, _, _) \u0026*\u0026 thePreferencesFile != null \u0026*\u0026 thePreferencesFileData != null \u0026*\u0026 thePreferencesFileData.length == 100 \u0026*\u0026 thePreferencesFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n        belpicSibs == cons\u003cFile\u003e(theTokenInfo, cons(theObjectDirectoryFile, cons(theAuthenticationObjectDirectoryFile, cons(thePrivateKeyDirectoryFile, cons(theCertificateDirectoryFile, cons(theCaCertificate, cons(theRrnCertificate, cons(theRootCaCertificate, cons(theAuthenticationCertificate, cons(theNonRepudiationCertificate, nil)))))))))) \u0026*\u0026\r\n        idSibs == cons\u003cFile\u003e(theIdentityFile, cons(theIdentityFileSignature, cons(theAddressFile, cons(theAddressFileSignature, cons(thecaRoleIDFile, cons(thePreferencesFile, cons(thePhotoFile, nil))))))) \u0026*\u0026\r\n        selected_file_types(theSelectedFile, theMasterFile, theBelpicDirectory, theIdDirectory, theIdentityFile, theIdentityFileSignature, theAddressFile, theAddressFileSignature, thePhotoFile, thecaRoleIDFile, theDirFile, theTokenInfo, theObjectDirectoryFile, theAuthenticationObjectDirectoryFile, thePrivateKeyDirectoryFile, theCaCertificate, theCertificateDirectoryFile, theRrnCertificate, theRootCaCertificate, theAuthenticationCertificate, theNonRepudiationCertificate, thePreferencesFile, _) \u0026*\u0026\r\n            selected_file_class(theSelectedFile) \u0026*\u0026\r\n        signatureAlgorithm |-\u003e ?theSignatureAlgorithm \u0026*\u0026\r\n        nonRepKeyPair |-\u003e ?theNonRepKeyPair \u0026*\u0026 theNonRepKeyPair != null \u0026*\u0026\r\n        authKeyPair |-\u003e ?theAuthKeyPair \u0026*\u0026 theAuthKeyPair != null \u0026*\u0026\r\n        basicKeyPair |-\u003e ?theBasicKeyPair \u0026*\u0026\r\n        PKCS1_HEADER |-\u003e ?thePKCS1HEADER \u0026*\u0026 thePKCS1HEADER != null \u0026*\u0026 array_slice(thePKCS1HEADER, 0, thePKCS1HEADER.length, _) \u0026*\u0026 thePKCS1HEADER.length == 1 \u0026*\u0026\r\n        PKCS1_SHA1_HEADER |-\u003e ?thePKCS1SHA1HEADER \u0026*\u0026 thePKCS1SHA1HEADER != null \u0026*\u0026 array_slice(thePKCS1SHA1HEADER, 0, thePKCS1SHA1HEADER.length, _) \u0026*\u0026 thePKCS1SHA1HEADER.length == 16 \u0026*\u0026\r\n        PKCS1_MD5_HEADER |-\u003e ?thePKCS1MD5HEADER \u0026*\u0026 thePKCS1MD5HEADER != null \u0026*\u0026 array_slice(thePKCS1MD5HEADER, 0, thePKCS1MD5HEADER.length, _) \u0026*\u0026 thePKCS1MD5HEADER.length == 19 \u0026*\u0026\r\n        theDirFile != thePreferencesFile \u0026*\u0026 theTokenInfo != thePreferencesFile \u0026*\u0026 thePreferencesFile != theObjectDirectoryFile \u0026*\u0026 thePreferencesFile != theAuthenticationObjectDirectoryFile \u0026*\u0026 thePreferencesFile != thePrivateKeyDirectoryFile \u0026*\u0026\r\n        NewEidPointsObject |-\u003e ?pointsObject \u0026*\u0026 [_]pointsObject.applet |-\u003e this \u0026*\u0026\r\n        NewEPurseAID |-\u003e ?newEPurseAid \u0026*\u0026 array_slice(newEPurseAid, 0, newEPurseAid.length, _) \u0026*\u0026 newEPurseAid.length == 6 \u0026*\u0026\r\n        Points |-\u003e _;\r\n        @*/\r\n\r\n    /* APDU header related constants */\r\n    // codes of CLA byte in the command APDUs\r\n    private final static byte EIDCARD_CLA_2 = (byte) 0x80;\r\n    private final static byte EIDCARD_CLA_1 = (byte) 0x00;\r\n    // codes of INS byte in the command APDUs\r\n    private final static byte INS_GET_RESPONSE = (byte) 0xC0;\r\n    private final static byte INS_SELECT_FILE = (byte) 0xA4;\r\n    private final static byte INS_ACTIVATE_FILE = (byte) 0x44;\r\n    private final static byte INS_DEACTIVATE_FILE = (byte) 0x04;\r\n    private final static byte INS_READ_BINARY = (byte) 0xB0;\r\n    private final static byte INS_UPDATE_BINARY = (byte) 0xD6;\r\n    private final static byte INS_ERASE_BINARY = (byte) 0x0E;\r\n    private final static byte INS_VERIFY_PIN = (byte) 0x20;\r\n    private final static byte INS_CHANGE_PIN = (byte) 0x24;\r\n    private final static byte INS_UNBLOCK = (byte) 0x2C;\r\n    private final static byte INS_GET_CHALLENGE = (byte) 0x84;\r\n    private final static byte INS_INTERNAL_AUTHENTICATE = (byte) 0x88;\r\n\r\n    private final static byte INS_EXTERNAL_AUTHENTICATE = (byte) 0x82;\r\n\r\n    private final static byte INS_ENVELOPE = (byte) 0xC2;\r\n    private final static byte INS_PREPARE_SIGNATURE = (byte) 0x22;\r\n    private final static byte INS_GENERATE_SIGNATURE = (byte) 0x2A;\r\n    private final static byte INS_GENERATE_KEYPAIR = (byte) 0x46;\r\n    private final static byte INS_GET_KEY = (byte) 0xE2;\r\n    private final static byte INS_PUT_KEY = (byte) 0xF2;\r\n    private final static byte INS_ERASE_KEY = (byte) 0xF4;\r\n    private final static byte INS_ACTIVATE_KEY = (byte) 0xF6;\r\n    private final static byte INS_DEACTIVATE_KEY = (byte) 0xF8;\r\n    private final static byte INS_GET_CARD_DATA = (byte) 0xE4;\r\n    private final static byte INS_LOG_OFF = (byte) 0xE6;\r\n    private final static byte INS_BLOCK = (byte) 0xE8;\r\n    private byte[] previousApduType; // transient byte array with 1 element\r\n    // \"generate signature\" needs to know whether the previous APDU checked the\r\n    // cardholder PIN\r\n    private final static byte VERIFY_CARDHOLDER_PIN = (byte) 0x01;\r\n    // PIN Change needs to know whether the previous APDU checked the reset PIN\r\n    private final static byte VERIFY_RESET_PIN = (byte) 0x02;\r\n    private final static byte GENERATE_KEY_PAIR = (byte) 0x03;\r\n    private final static byte OTHER = (byte) 0x00;\r\n    /* applet specific status words */\r\n    // some are defined in ISO7816, but not by JavaCard\r\n\r\n    private final static short SW_CANCELLED = (short) 0xFFFF;\r\n    private final static short SW_ALGORITHM_NOT_SUPPORTED = (short) 0x9484;\r\n    // last nibble of SW2 needs to be overwritten by the counter value/number of\r\n    // PIN tries left\r\n    private final static short SW_WRONG_PIN_0_TRIES_LEFT = (short) 0x63C0;\r\n    private final static short SW_INCONSISTENT_P1P2 = (short) 0x6A87;\r\n    private final static short SW_REFERENCE_DATA_NOT_FOUND = (short) 0x6A88;\r\n    // wrong Le field; SW2 encodes the exact number of available data bytes\r\n    private final static short SW_WRONG_LENGTH_00 = (short) 0x6C00;\r\n    /* PIN related variables */\r\n    // offsets within PIN related APDUs\r\n    private final static byte OFFSET_PIN_HEADER = ISO7816.OFFSET_CDATA;\r\n    private final static byte OFFSET_PIN_DATA = ISO7816.OFFSET_CDATA + 1;\r\n    \r\n    private final static byte OFFSET_SECOND_PIN_HEADER = ISO7816.OFFSET_CDATA + 8;\r\n\r\n    private final static byte OFFSET_SECOND_PIN_DATA = ISO7816.OFFSET_CDATA + 9;\r\n\r\n    private final static byte OFFSET_SECOND_PIN_DATA_END = ISO7816.OFFSET_CDATA + 15;\r\n    // 4 different PIN codes\r\n    protected final static byte PIN_SIZE = 8;\r\n    protected final static byte CARDHOLDER_PIN = (byte) 0x01;\r\n    protected final static byte CARDHOLDER_PIN_TRY_LIMIT = 3;\r\n    protected final static byte RESET_PIN = (byte) 0x02;\r\n    protected final static byte RESET_PIN_TRY_LIMIT = 10;\r\n    protected final static byte UNBLOCK_PIN = (byte) 0x03;\r\n    protected final static byte UNBLOCK_PIN_TRY_LIMIT = 12;\r\n    protected final static byte ACTIVATE_PIN = (byte) 0x84;\r\n    protected final static byte ACTIVATE_PIN_TRY_LIMIT = 15;\r\n    protected OwnerPIN cardholderPin;\r\n    protected OwnerPIN resetPin;\r\n    protected OwnerPIN unblockPin;\r\n    protected OwnerPIN activationPin;\r\n    //protected OwnerPIN cardholderPin, resetPin, unblockPin, activationPin;\r\n    \r\n    \r\n    /* signature related variables */\r\n    private byte signatureAlgorithm;\r\n    private final static byte ALG_PKCS1 = (byte) 0x01;\r\n    private final static byte ALG_SHA1_PKCS1 = (byte) 0x02;\r\n    private final static byte ALG_MD5_PKCS1 = (byte) 0x04;\r\n    private final static byte[] PKCS1_HEADER = { (byte) 0x00 };\r\n    private final static byte[] PKCS1_SHA1_HEADER = { 0x00, (byte) 0x30, (byte) 0x21, (byte) 0x30, (byte) 0x09, (byte) 0x06, (byte) 0x05, (byte) 0x2b, (byte) 0x0e, (byte) 0x03, (byte) 0x02, (byte) 0x1a, (byte) 0x05, (byte) 0x00, (byte) 0x04,\r\n            (byte) 0x14 };\r\n    private final static byte[] PKCS1_MD5_HEADER = { (byte) 0x00, (byte) 0x30, (byte) 0x20, (byte) 0x30, (byte) 0x0c, (byte) 0x06, (byte) 0x08, (byte) 0x2a, (byte) 0x86, (byte) 0x48, (byte) 0x86, (byte) 0xf7, (byte) 0x0d, (byte) 0x02, (byte) 0x05,\r\n            (byte) 0x05, (byte) 0x00, (byte) 0x04, (byte) 0x10 };\r\n    private byte[] signatureType; // transient byte array with 1 element\r\n    private final static byte NO_SIGNATURE = (byte) 0x00;\r\n    private final static byte BASIC = (byte) 0x81;\r\n    private final static byte AUTHENTICATION = (byte) 0x82;\r\n    private final static byte NON_REPUDIATION = (byte) 0x83;\r\n    private final static byte CA_ROLE = (byte) 0x87;\r\n    \r\n    // make this static to save some memory\r\n    protected static KeyPair basicKeyPair;\r\n    protected static KeyPair authKeyPair;\r\n    protected static KeyPair nonRepKeyPair;\r\n    \r\n    \r\n    \r\n    // reuse these objects in all subclasses, otherwise we will use up all\r\n    // memory\r\n    private static Cipher cipher;\r\n    private static RandomData randomData;\r\n    // this buffer is used to correct PKCS#1 clear text message\r\n    private static byte[] messageBuffer;\r\n    /*\r\n     * \"file system\" related variables see Belgian Electronic Identity Card\r\n     * content\r\n     */\r\n    protected final static short MF = (short) 0x3F00;\r\n    protected final static short EF_DIR = (short) 0x2F00;\r\n    protected final static short DF_BELPIC = (short) 0xDF00;\r\n    protected final static short DF_ID = (short) 0xDF01;\r\n    protected MasterFile masterFile;\r\n    protected DedicatedFile belpicDirectory, idDirectory;\r\n    protected ElementaryFile dirFile;\r\n    // data under BELPIC directory\r\n    protected final static short ODF = (short) 0x5031;\r\n    protected final static short TOKENINFO = (short) 0x5032;\r\n    protected final static short AODF = (short) 0x5034;\r\n    protected final static short PRKDF = (short) 0x5035;\r\n    protected final static short CDF = (short) 0x5037;\r\n    protected final static short AUTH_CERTIFICATE = (short) 0x5038;\r\n    protected final static short NONREP_CERTIFICATE = (short) 0x5039;\r\n    protected final static short CA_CERTIFICATE = (short) 0x503A;\r\n    protected final static short ROOT_CA_CERTIFICATE = (short) 0x503B;\r\n    protected final static short RRN_CERTIFICATE = (short) 0x503C;\r\n    protected ElementaryFile objectDirectoryFile, tokenInfo, authenticationObjectDirectoryFile, privateKeyDirectoryFile, certificateDirectoryFile, authenticationCertificate, nonRepudiationCertificate, caCertificate, rootCaCertificate, rrnCertificate;\r\n    // data under ID directory\r\n    protected final static short IDENTITY = (short) 0x4031;\r\n    protected final static short SGN_IDENTITY = (short) 0x4032;\r\n    protected final static short ADDRESS = (short) 0x4033;\r\n    protected final static short SGN_ADDRESS = (short) 0x4034;\r\n    protected final static short PHOTO = (short) 0x4035;\r\n    protected final static short CA_ROLE_ID = (short) 0x4038;\r\n    protected final static short PREFERENCES = (short) 0x4039;\r\n    protected ElementaryFile identityFile, identityFileSignature, addressFile, addressFileSignature, photoFile, caRoleIDFile, preferencesFile;\r\n\r\n    /*\r\n     * different file operations see ISO 7816-4 table 17+18\r\n     */\r\n    // access mode byte for EFs\r\n    private final static byte READ_BINARY = (byte) 0x01;\r\n\r\n    private final static byte SEARCH_BINARY = (byte) 0x01;\r\n    private final static byte UPDATE_BINARY = (byte) 0x02;\r\n    private final static byte ERASE_BINARY = (byte) 0x02;\r\n\r\n    private final static byte WRITE_BINARY = (byte) 0x04;\r\n    // access mode byte for DFs\r\n\r\n    private final static byte DELETE_CHILD_FILE = (byte) 0x01;\r\n\r\n    private final static byte CREATE_EF = (byte) 0x02;\r\n\r\n    private final static byte CREATE_DF = (byte) 0x04;\r\n    // access mode byte common to DFs and EFs\r\n\r\n    private final static byte DEACTIVATE_FILE = (byte) 0x08;\r\n\r\n    private final static byte ACTIVATE_FILE = (byte) 0x10;\r\n\r\n    private final static byte TERMINATE_FILE = (byte) 0x20;\r\n\r\n    private final static byte DELETE_FILE = (byte) 0x40;\r\n    /* variables to pass information between different APDU commands */\r\n    // last generated random challenge will be stored in this buffer\r\n    private byte[] randomBuffer;\r\n    // last generated response (e.g. signature) will be stored in this buffer\r\n    private byte[] responseBuffer;\r\n    // file selected by SELECT FILE; defaults to the MF\r\n    private File selectedFile;\r\n    // only 5000 internal authenticates can be done and then the activation\r\n    // PIN needs to be checked again\r\n    private short internalAuthenticateCounter = 5000;\r\n    \r\n    \r\n    public static final byte INS_Credit = 0x02;\r\n    private byte[] NewEPurseAID = {0x01,0x02,0x03,0x04,0x05,0x00};\r\n    public static byte Points = 5;\r\n    NewEidPoints NewEidPointsObject;\r\n    \r\n    /**\r\n     * called by the JCRE to create an applet instance\r\n     */\r\n    public static void install(byte[] bArray, short bOffset, byte bLength) \r\n          //@ requires class_init_token(NewEidCard.class) \u0026*\u0026 system();\r\n              //@ ensures true;\r\n    {\r\n        // create a eID card applet instance\r\n        new NewEidCard();\r\n    }\r\n    \r\n    /**\r\n     * Initialise all files on the card as empty with max size\r\n     * \r\n     * see \"Belgian Electronic Identity Card content\" (version x)\r\n     * \r\n     * depending on the eid card version, the address is of different length\r\n     * (current: 117)\r\n     */\r\n    private void initializeFileSystem() \r\n          /*@ requires identityFile |-\u003e _ \u0026*\u0026 identityFileSignature |-\u003e _ \u0026*\u0026 addressFile |-\u003e _ \u0026*\u0026 addressFileSignature |-\u003e _\r\n              \u0026*\u0026 caRoleIDFile |-\u003e _ \u0026*\u0026 preferencesFile |-\u003e _ \u0026*\u0026 idDirectory |-\u003e _\r\n              \u0026*\u0026 certificateDirectoryFile |-\u003e _ \u0026*\u0026 privateKeyDirectoryFile |-\u003e _ \u0026*\u0026 authenticationObjectDirectoryFile |-\u003e _ \u0026*\u0026 objectDirectoryFile |-\u003e _\r\n              \u0026*\u0026 tokenInfo |-\u003e _ \u0026*\u0026 belpicDirectory |-\u003e _ \u0026*\u0026 dirFile |-\u003e _\r\n              \u0026*\u0026 masterFile |-\u003e _ \u0026*\u0026 selectedFile |-\u003e _;\r\n        @*/\r\n          /*@ ensures dirFile |-\u003e ?theDirFile \u0026*\u0026 theDirFile.ElementaryFile(_, _, ?dirFileData, _, _, _) \u0026*\u0026 theDirFile != null \r\n                        \u0026*\u0026 dirFileData != null \u0026*\u0026 dirFileData.length == 0x25\r\n             \u0026*\u0026 belpicDirectory |-\u003e ?theBelpicDirectory \u0026*\u0026 theBelpicDirectory.DedicatedFile(_, _, _, ?belpic_siblings, _) \u0026*\u0026 theBelpicDirectory != null\r\n             \u0026*\u0026 tokenInfo |-\u003e ?theTokenInfo \u0026*\u0026 theTokenInfo.ElementaryFile(_, _, ?tokenInfoData, _, _, _) \u0026*\u0026 theTokenInfo != null\r\n                  \u0026*\u0026 tokenInfoData != null \u0026*\u0026 tokenInfoData.length == 0x30\r\n             \u0026*\u0026 objectDirectoryFile |-\u003e ?theObjectDirectoryFile \u0026*\u0026 theObjectDirectoryFile.ElementaryFile(_, _, ?objectDirectoryFileData, _, _, _) \u0026*\u0026 theObjectDirectoryFile != null\r\n                  \u0026*\u0026 objectDirectoryFileData != null \u0026*\u0026 objectDirectoryFileData.length == 40\r\n             \u0026*\u0026 authenticationObjectDirectoryFile |-\u003e ?theAuthenticationObjectDirectoryFile \u0026*\u0026 theAuthenticationObjectDirectoryFile.ElementaryFile(_, _, ?authenticationObjectDirectoryFileData, _, _, _) \u0026*\u0026 theAuthenticationObjectDirectoryFile != null\r\n                  \u0026*\u0026 authenticationObjectDirectoryFileData != null \u0026*\u0026 authenticationObjectDirectoryFileData.length == 0x40\r\n             \u0026*\u0026 privateKeyDirectoryFile |-\u003e ?thePrivateKeyDirectoryFile \u0026*\u0026 thePrivateKeyDirectoryFile.ElementaryFile(_, _, ?privateKeyDirectoryFileData, _, _, _) \u0026*\u0026 thePrivateKeyDirectoryFile != null\r\n                  \u0026*\u0026 privateKeyDirectoryFileData != null \u0026*\u0026 privateKeyDirectoryFileData.length == 0xB0\r\n             \u0026*\u0026 certificateDirectoryFile |-\u003e ?theCertificateDirectoryFile \u0026*\u0026 theCertificateDirectoryFile.ElementaryFile(_, _, ?certificateDirectoryFileData, _, _, _) \u0026*\u0026 theCertificateDirectoryFile !=  null\r\n                  \u0026*\u0026 certificateDirectoryFileData != null \u0026*\u0026 certificateDirectoryFileData.length == 0xB0\r\n             \u0026*\u0026 idDirectory |-\u003e ?theIdDirectory \u0026*\u0026 theIdDirectory.DedicatedFile(_, _, _, ?idDirectory_siblings, _) \u0026*\u0026 theIdDirectory != null\r\n             \u0026*\u0026 identityFile |-\u003e ?theIdentityFile \u0026*\u0026 theIdentityFile.ElementaryFile(_, _, ?identityData, _, _, _) \u0026*\u0026 theIdentityFile != null\r\n                  \u0026*\u0026 identityData != null \u0026*\u0026 identityData.length == 0xD0\r\n             \u0026*\u0026 identityFileSignature |-\u003e ?theIdentityFileSignature \u0026*\u0026 theIdentityFileSignature.ElementaryFile(_, _, ?identitySignatureData, _, _, _) \u0026*\u0026 theIdentityFileSignature != null\r\n                  \u0026*\u0026 identitySignatureData != null \u0026*\u0026 identitySignatureData.length == 0x80\r\n             \u0026*\u0026 addressFile |-\u003e ?theAddressFile \u0026*\u0026 theAddressFile.ElementaryFile(_, _, ?addressFileData, _, _, _) \u0026*\u0026 theAddressFile != null\r\n                  \u0026*\u0026 addressFileData != null \u0026*\u0026 addressFileData.length == 117\r\n             \u0026*\u0026 addressFileSignature |-\u003e ?theAddressFileSignature \u0026*\u0026 theAddressFileSignature.ElementaryFile(_, _, ?addressFileSignatureData, _, _, _) \u0026*\u0026 theAddressFileSignature != null\r\n                  \u0026*\u0026 addressFileSignatureData != null \u0026*\u0026 addressFileSignatureData.length == 128\r\n             \u0026*\u0026 caRoleIDFile |-\u003e ?theCaRoleIDFile \u0026*\u0026 theCaRoleIDFile.ElementaryFile(_, _, ?caRoldIDFileData, _, _, _) \u0026*\u0026 theCaRoleIDFile != null\r\n                  \u0026*\u0026 caRoldIDFileData != null \u0026*\u0026 caRoldIDFileData.length == 0x20\r\n             \u0026*\u0026 preferencesFile |-\u003e ?thePreferencesFile \u0026*\u0026 thePreferencesFile.ElementaryFile(_, _, ?preferencesFileData, _, _, _) \u0026*\u0026 thePreferencesFile != null\r\n                  \u0026*\u0026 preferencesFileData != null \u0026*\u0026 preferencesFileData.length == 100\r\n             \u0026*\u0026 masterFile |-\u003e ?theMasterFile \u0026*\u0026 theMasterFile.MasterFile(0x3F00, null, _, ?master_siblings, _) \u0026*\u0026 theMasterFile != null\r\n             \u0026*\u0026 master_siblings == cons\u003cFile\u003e(theDirFile, cons(theBelpicDirectory, cons(theIdDirectory, nil)))\r\n             \u0026*\u0026 belpic_siblings == cons\u003cFile\u003e(theTokenInfo, cons(theObjectDirectoryFile, cons(theAuthenticationObjectDirectoryFile, cons(thePrivateKeyDirectoryFile, cons(theCertificateDirectoryFile,nil)))))\r\n             \u0026*\u0026 idDirectory_siblings == cons\u003cFile\u003e(theIdentityFile, cons(theIdentityFileSignature, cons(theAddressFile, cons(theAddressFileSignature, cons(theCaRoleIDFile, cons(thePreferencesFile, nil))))))\r\n             \u0026*\u0026 selectedFile |-\u003e theMasterFile \u0026*\u0026 theBelpicDirectory.getClass() == DedicatedFile.class \u0026*\u0026 theIdDirectory.getClass() == DedicatedFile.class;\r\n        @*/\r\n    {\r\n        masterFile = new MasterFile();\r\n        /*\r\n         * initialize PKCS#15 data structures see\r\n         * \"5. PKCS#15 information details\" for more info\r\n         */\r\n        \r\n        //@ masterFile.castMasterToDedicated();\r\n        \r\n        dirFile = new ElementaryFile(EF_DIR, masterFile, (short) 0x25);\r\n        belpicDirectory = new DedicatedFile(DF_BELPIC, masterFile);\r\n        tokenInfo = new ElementaryFile(TOKENINFO, belpicDirectory, (short) 0x30);\r\n        objectDirectoryFile = new ElementaryFile(ODF, belpicDirectory, (short) 40);\r\n        authenticationObjectDirectoryFile = new ElementaryFile(AODF, belpicDirectory, (short) 0x40);\r\n        privateKeyDirectoryFile = new ElementaryFile(PRKDF, belpicDirectory, (short) 0xB0);\r\n        certificateDirectoryFile = new ElementaryFile(CDF, belpicDirectory, (short) 0xB0);\r\n        idDirectory = new DedicatedFile(DF_ID, masterFile);\r\n        /*\r\n         * initialize all citizen data stored on the eID card copied from sample\r\n         * eID card 000-0000861-85\r\n         */\r\n        // initialize ID#RN EF\r\n        identityFile = new ElementaryFile(IDENTITY, idDirectory, (short) 0xD0);\r\n        // initialize SGN#RN EF\r\n        identityFileSignature = new ElementaryFile(SGN_IDENTITY, idDirectory, (short) 0x80);\r\n        // initialize ID#Address EF\r\n        // address is 117 bytes, and should be padded with zeros\r\n        addressFile = new ElementaryFile(ADDRESS, idDirectory, (short) 117);\r\n        // initialize SGN#Address EF\r\n        addressFileSignature = new ElementaryFile(SGN_ADDRESS, idDirectory, (short) 128);\r\n        // initialize PuK#7 ID (CA Role ID) EF\r\n        caRoleIDFile = new ElementaryFile(CA_ROLE_ID, idDirectory, (short) 0x20);\r\n        // initialize Preferences EF to 100 zero bytes\r\n        preferencesFile = new ElementaryFile(PREFERENCES, idDirectory, (short) 100);\r\n        \r\n        selectedFile = masterFile;\r\n        //@ masterFile.castDedicatedToMaster();\r\n    }\r\n    \r\n    /**\r\n     * erase data in file that was selected with SELECT FILE\r\n     */\r\n    private void eraseBinary(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        // check if access to this file is allowed\r\n        if (!fileAccessAllowed(ERASE_BINARY))\r\n            ISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n        // use P1 and P2 as offset\r\n        short offset = Util.makeShort(buffer[ISO7816.OFFSET_P1], buffer[ISO7816.OFFSET_P2]);\r\n        JCSystem.beginTransaction();\r\n        //@ open valid();\r\n        if (selectedFile == masterFile)\r\n            ISOException.throwIt(ISO7816.SW_FILE_INVALID); //~allow_dead_code\r\n        // impossible to start erasing from offset large than size of file\r\n        //@ open selected_file_types(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _);\r\n        short size = ((ElementaryFile)selectedFile).getCurrentSize();\r\n        if (offset \u003e size || offset \u003c 0)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n        ((ElementaryFile) selectedFile).eraseData(offset);\r\n        //@ close valid();\r\n        JCSystem.commitTransaction();\r\n    }\r\n    /**\r\n     * change data in a file that was selected with SELECT FILE\r\n     */\r\n    private void updateBinary(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        // check if access to this file is allowed\r\n        if (!fileAccessAllowed(UPDATE_BINARY))\r\n            ISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n        // use P1 and P2 as offset\r\n        short offset = Util.makeShort(buffer[ISO7816.OFFSET_P1], buffer[ISO7816.OFFSET_P2]);\r\n        // impossible to start updating from offset larger than max size of file\r\n        // this however does not imply that the file length can not change\r\n        JCSystem.beginTransaction();\r\n        //@ open valid();\r\n        if (selectedFile == masterFile)\r\n            ISOException.throwIt(ISO7816.SW_FILE_INVALID); //~allow_dead_code\r\n        //@ open selected_file_types(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _);\r\n        short size = ((ElementaryFile) selectedFile).getMaxSize();\r\n        if (offset \u003e size)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n        // number of bytes in file starting from offset\r\n        // short remaining = (short) (size - offset);\r\n        // get the new data\r\n        short byteRead = apdu.setIncomingAndReceive();\r\n        // check Lc\r\n        //@ positive_and(buffer[ISO7816.OFFSET_LC], 0x00FF);\r\n        short lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n        if ((lc == 0) || (byteRead == 0))\r\n            ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n        // update file\r\n        if (offset \u003c 0 || (short) (ISO7816.OFFSET_CDATA + lc) \u003e (short) (buffer.length) || (short) (offset + lc) \u003e size)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n        ((ElementaryFile) selectedFile).updateData(offset, buffer, ISO7816.OFFSET_CDATA, lc);\r\n        //@ close valid();\r\n        JCSystem.commitTransaction();\r\n    }\r\n    /**\r\n     * checks if a certain file operation is allowed on the currently selected\r\n     * file\r\n     * \r\n     * remark 1: a very dedicated (so not generic) implementation! a more\r\n     * elegant solution would be to put (parts of) access control in File\r\n     * objects\r\n     * \r\n     * remark 2: there is a huge hack to allow some write updates. this hack is\r\n     * harmless, as these write operations happen during the copying of a card,\r\n     * not during its use\r\n     */\r\n    private boolean fileAccessAllowed(byte mode) \r\n          //@ requires [?f]selectedFile |-\u003e ?theSelectedFile \u0026*\u0026 [f]this.preferencesFile |-\u003e ?thePreferencesFile \u0026*\u0026 [f]this.cardholderPin |-\u003e ?theCardHolderPin \u0026*\u0026 theCardHolderPin != null \u0026*\u0026 [f]OwnerPIN(theCardHolderPin, _, _);\r\n              //@ ensures [f]selectedFile |-\u003e theSelectedFile \u0026*\u0026 [f]this.preferencesFile |-\u003e thePreferencesFile \u0026*\u0026 [f]this.cardholderPin |-\u003e theCardHolderPin \u0026*\u0026 [f]OwnerPIN(theCardHolderPin, _, _) \u0026*\u0026 theSelectedFile instanceof ElementaryFile;\r\n    {\r\n            // if selected file is not an EF, throw \"no current EF\" exception\r\n        if (!(selectedFile instanceof ElementaryFile))\r\n            ISOException.throwIt(ISO7816.SW_COMMAND_NOT_ALLOWED);\r\n        // always allow READ BINARY\r\n        if (mode == READ_BINARY) {\r\n                return true;\r\n        }\r\n        // allow write access to the preference file if the cardholder pin was\r\n        // entered correctly\r\n        if ((selectedFile == preferencesFile) \u0026\u0026 cardholderPin.isValidated()) {\r\n                return true;\r\n        }\r\n        // we abuse the activation pin to update some of the large files (photo\r\n        // + certificates)\r\n        if (GPSystem.getCardContentState() == GPSystem.APPLICATION_SELECTABLE) {\r\n                return true;            \r\n        }\r\n            // default to false\r\n        return false;\r\n    }\r\n    /**\r\n     * Gives back information on this eID\r\n     * \r\n     * @param apdu\r\n     * @param buffer\r\n     */\r\n    private void getCardData(APDU apdu, byte[] buffer) \r\n          //@ requires [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        // check P1 and P2\r\n        if (buffer[ISO7816.OFFSET_P1] != (byte) 0x00 || buffer[ISO7816.OFFSET_P2] != (byte) 0x00)\r\n            ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n        // inform the JCRE that the applet has data to return\r\n        apdu.setOutgoing();\r\n        \r\n        //@ open [1/2]valid();\r\n                                \r\n        byte[] data = identityFile.getData(); \r\n        // Only the chip number is of importance: get this at tag position 2\r\n        short pos = 1;\r\n        //@ open [1/2]identityFile.ElementaryFile(_, _, ?identityFileData, _, _, ?info);\r\n        short dataLen = (short) data[pos];\r\n        pos = (short) (pos + 1 + dataLen + 1);\r\n        //@ close [1/2]identityFile.ElementaryFile(_, _, identityFileData, _, _, info);\r\n        if (dataLen \u003c= (short)0 || (short)(dataLen + pos + 2) \u003e= (short)(identityFile.getCurrentSize()))\r\n            ISOException.throwIt(ISO7816.SW_DATA_INVALID);\r\n        //@ open [1/2]identityFile.ElementaryFile(_, _, identityFileData, _, _, info);\r\n        dataLen = (short) data[pos];\r\n        pos = (short) (pos + 1);\r\n        //@ close [1/2]identityFile.ElementaryFile(_, _, identityFileData, _, _, info);\r\n        if (dataLen \u003c (short)0 || (short) (pos + dataLen) \u003e= (short) (identityFile.getCurrentSize()))\r\n            ISOException.throwIt(ISO7816.SW_DATA_INVALID);\r\n        //@ open [1/2]identityFile.ElementaryFile(_, _, identityFileData, _, _, info);\r\n        // check Le\r\n        // if (le != dataLen)\r\n        // ISOException.throwIt((short)(ISO7816.SW_WRONG_LENGTH));\r\n        /*VF*byte version[] = { (byte) 0xA5, (byte) 0x03, (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x11, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x01, (byte) 0x01, (byte) 0x0F };*/\r\n        byte version[] = new byte[] { (byte) 0xA5, (byte) 0x03, (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x11, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x01, (byte) 0x01, (byte) 0x0F };\r\n        byte chipNumber[] = new byte[(short) (dataLen + 12)];\r\n        Util.arrayCopy(data, pos, chipNumber, (short) 0, dataLen);\r\n        Util.arrayCopy(version, (short) 0, chipNumber, dataLen, (short) 12);\r\n        // //Set serial number\r\n        // Util.arrayCopy(tokenInfo.getData(), (short) 7, tempBuffer, (short) 0,\r\n        // (short) 16);\r\n        //        \r\n        // //Set component code: TODO\r\n        //        \r\n        //        \r\n        // //Set OS number: TODO\r\n        //        \r\n        //        \r\n        // //Set OS version: TODO\r\n        // JCSystem.getVersion();\r\n        //        \r\n        // //Set softmask number: TODO\r\n        //        \r\n        // //Set softmask version: TODO\r\n        //        \r\n        // //Set applet version: TODO : 4 bytes in file system\r\n        //        \r\n        //        \r\n        // //Set Interface version: TODO\r\n        //        \r\n        // //Set PKCS#15 version: TODO\r\n        //        \r\n        // //Set applet life cycle\r\n        // tempBuffer[(short)(le-1)] = GPSystem.getCardState();\r\n        // set the actual number of outgoing data bytes\r\n        apdu.setOutgoingLength((short) chipNumber.length);\r\n        // send content of buffer in apdu\r\n        apdu.sendBytesLong(chipNumber, (short) 0, (short) chipNumber.length);\r\n                                \r\n        //@ close [1/2]identityFile.ElementaryFile(_, _, identityFileData, _, _, info);\r\n        //@ close [1/2]valid();\r\n    }\r\n    \r\n    /**\r\n     * put file that was selected with SELECT FILE in a response APDU\r\n     */\r\n    private void readBinary(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        //@ open [1/2]valid();\r\n        // check if access to this file is allowed\r\n        if (!fileAccessAllowed(READ_BINARY))\r\n            ISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n        // use P1 and P2 as offset\r\n        short offset = Util.makeShort(buffer[ISO7816.OFFSET_P1], buffer[ISO7816.OFFSET_P2]);\r\n        if (offset \u003c 0)\r\n            ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n        // inform the JCRE that the applet has data to return\r\n        short le = apdu.setOutgoing();\r\n        // impossible to start reading from offset large than size of file                \r\n        if (selectedFile == masterFile)\r\n            ISOException.throwIt(ISO7816.SW_FILE_INVALID); //~allow_dead_code\r\n        //@ open selected_file_types(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _);\r\n        short size = ((ElementaryFile) selectedFile).getCurrentSize();\r\n        if (offset \u003e size)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n        // number of bytes in file starting from offset\r\n        short remaining = (short) (size - offset);\r\n        if (le == 0) {\r\n            if (remaining \u003c 256) {\r\n                // wrong Le field\r\n                // SW2 encodes the exact number of available data bytes\r\n                short sw = (short) (ISO7816.SW_CORRECT_LENGTH_00 | remaining);\r\n                ISOException.throwIt(sw);\r\n            } else\r\n                // Le = 0 is interpreted as 256 bytes\r\n                le = 256;\r\n        }\r\n        // only read out the remaining bytes\r\n        if (le \u003e remaining) {\r\n            le = remaining;\r\n        }\r\n        // set the actual number of outgoing data bytes\r\n        apdu.setOutgoingLength(le);\r\n        // write selected file in APDU\r\n        //VF bug; was   apdu.sendBytesLong(((ElementaryFile) selectedFile).getData(), offset, le);\r\n        //VF probleem: originele lijn was    apdu.sendBytesLong(ef.getData(), offset, le);\r\n        // het probleem hiermee is dat de getData()-methode een ElementaryFile nodig heeft, en dat\r\n        // sendBytesLong vereist dat het resultaat niet null is. De niet-null vereiste zit geencodeerd\r\n        // in ElementaryFile, dus als je dat predicaat opent, dan weet VF dat de data niet-null is, maar\r\n        // dan werkt de call op getData niet. Als je de ElementaryFile gesloten laat, dan lukt de call naar\r\n        // getData, maar weet je niet dat het niet-null is.\r\n        ElementaryFile ef = (ElementaryFile)selectedFile;\r\n        byte[] bf = ef.getData();\r\n        //@ open [1/2]ef.ElementaryFile(?d1, ?d2, ?d3, ?d4, ?d5, ?info);\r\n        apdu.sendBytesLong(bf, offset, le);\r\n        //@ close [1/2]ef.ElementaryFile(d1, d2, d3, d4, d5, info);\r\n        //@ close [1/2]valid();\r\n    }\r\n    \r\n    /**\r\n     * activate a file on the eID card security conditions depend on file to\r\n     * activate: see belgian eID content file\r\n     */\r\n    private void activateFile(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        // check P2\r\n        if (buffer[ISO7816.OFFSET_P2] != (byte) 0x0C)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n        // P1 determines the select method\r\n        switch (buffer[ISO7816.OFFSET_P1]) {\r\n        case (byte) 0x02:\r\n            selectByFileIdentifier(apdu, buffer);\r\n            break;\r\n        case (byte) 0x08:\r\n            selectByPath(apdu, buffer);\r\n            break;\r\n        default:\r\n            ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n            break; //~allow_dead_code\r\n        }\r\n        // check if activating this file is allowed\r\n        if (!fileAccessAllowed(UPDATE_BINARY))\r\n            ISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n        JCSystem.beginTransaction();\r\n        //@ open valid();\r\n        //@ open selected_file_types(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, ?sf2);\r\n        //@ sf2.castElementaryToFile();\r\n        selectedFile.setActive(true);\r\n        //@ sf2.castFileToElementary();\r\n        //@ close valid();\r\n        JCSystem.commitTransaction();\r\n    }    \r\n    \r\n    /*VF* COPIED FROM EmptyEidCard */\r\n    static byte[] dirData;\r\n    static byte[] tokenInfoData;\r\n    static byte[] odfData;\r\n    static byte[] aodfData;\r\n    static byte[] prkdfData;\r\n    static byte[] cdfData;\r\n    static byte[] citizenCaCert;\r\n    static byte[] rrnCert;\r\n    static byte[] rootCaCert;\r\n    static byte[] photoData;  // save some more memory by making the photo static as well\r\n    \r\n    /**\r\n     * perform any cleanup tasks and set default selectedFile\r\n     */\r\n    private void clear() \r\n            //@ requires current_applet(this) \u0026*\u0026 [1/2]valid();\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid();\r\n    {\r\n        JCSystem.beginTransaction();\r\n        \r\n        //@ open valid();\r\n\r\n        // clear signature and random data buffer\r\n        Util.arrayFillNonAtomic(randomBuffer, (short) 0, (short) 256, (byte) 0);\r\n        Util.arrayFillNonAtomic(responseBuffer, (short) 0, (short) 128, (byte) 0);\r\n        // no EF and DF selected yet; select MF by default\r\n        selectedFile = masterFile;\r\n        // invalidate cardholder PIN\r\n        cardholderPin.reset();\r\n        /*\r\n         * clear text message buffer, signature and previous ADPU type are\r\n         * transient so no need to reset these manually\r\n         */\r\n\r\n        // open selectedFile.File(?d1, ?d2);\r\n        //@ close valid();\r\n\r\n        JCSystem.commitTransaction();\r\n    }\r\n    /**\r\n     * initialize empty files that need to be filled latter using UPDATE BINARY\r\n     */\r\n    private void initializeEmptyLargeFiles() \r\n        /*@ requires belpicDirectory |-\u003e ?bpd \u0026*\u0026 bpd != null \u0026*\u0026 bpd.DedicatedFile(_, _, _, ?belpic_sibs, _) \u0026*\u0026 \r\n                 length(belpic_sibs) \u003c 6 \u0026*\u0026\r\n                idDirectory |-\u003e ?idd \u0026*\u0026 idd != null \u0026*\u0026 idd.DedicatedFile(_, _, _, ?iddir_sibs, _) \u0026*\u0026 \r\n                length(iddir_sibs) \u003c 7 \u0026*\u0026\r\n                caCertificate |-\u003e _ \u0026*\u0026 rrnCertificate |-\u003e _ \u0026*\u0026 rootCaCertificate |-\u003e _ \u0026*\u0026 \r\n                photoFile |-\u003e _ \u0026*\u0026 authenticationCertificate |-\u003e _ \u0026*\u0026 nonRepudiationCertificate |-\u003e _; @*/\r\n              /*@ ensures belpicDirectory |-\u003e bpd \u0026*\u0026 \r\n                idDirectory |-\u003e idd \u0026*\u0026\r\n                caCertificate |-\u003e ?cac \u0026*\u0026 cac.ElementaryFile(CA_CERTIFICATE, bpd, ?d1, true, 0, _) \u0026*\u0026 d1 != null \u0026*\u0026 d1.length == 1200 \u0026*\u0026\r\n                rrnCertificate |-\u003e ?rrnc \u0026*\u0026  rrnc.ElementaryFile(RRN_CERTIFICATE, bpd, ?d2, true, 0, _) \u0026*\u0026 d2 != null \u0026*\u0026 d2.length == 1200 \u0026*\u0026\r\n                rootCaCertificate |-\u003e ?rootcac \u0026*\u0026  rootcac.ElementaryFile(ROOT_CA_CERTIFICATE, bpd, ?d3, true, 0, _) \u0026*\u0026 d3 != null \u0026*\u0026 d3.length == 1200 \u0026*\u0026\r\n                photoFile |-\u003e ?pf \u0026*\u0026  pf.ElementaryFile(PHOTO, idd, ?d4, true, 0, _) \u0026*\u0026 d4 != null \u0026*\u0026 d4.length == 3584 \u0026*\u0026\r\n                authenticationCertificate |-\u003e ?ac \u0026*\u0026  ac.ElementaryFile(AUTH_CERTIFICATE, bpd, ?d5, true, 0, _) \u0026*\u0026 d5 != null \u0026*\u0026 d5.length == 1200 \u0026*\u0026\r\n                nonRepudiationCertificate |-\u003e ?nrc \u0026*\u0026  nrc.ElementaryFile(NONREP_CERTIFICATE, bpd, ?d6, true, 0, _) \u0026*\u0026 d6 != null \u0026*\u0026 d6.length == 1200 \u0026*\u0026\r\n                idd.DedicatedFile(_, _, _, append(iddir_sibs, cons(pf, nil)), _) \u0026*\u0026 \r\n                bpd.DedicatedFile(_, _, _, append(append(append(append(append(belpic_sibs, cons(cac, nil)), cons(rrnc, nil)), cons(rootcac, nil)), cons(ac, nil)), cons(nrc, nil)), _); @*/\r\n    {\r\n        /*\r\n         * these 3 certificates are the same for all sample eid card applets\r\n         * therefor they are made static and the data is allocated only once\r\n         */\r\n        caCertificate = new ElementaryFile(CA_CERTIFICATE, belpicDirectory, (short) 1200);\r\n        rrnCertificate = new ElementaryFile(RRN_CERTIFICATE, belpicDirectory, (short) 1200);\r\n        \r\n        rootCaCertificate = new ElementaryFile(ROOT_CA_CERTIFICATE, belpicDirectory, (short) 1200);\r\n        /*\r\n         * to save some memory we only support 1 photo for all subclasses\r\n         * ideally this should be applet specific and have max size 3584 (3.5K)\r\n         */\r\n        photoFile = new ElementaryFile(PHOTO, idDirectory, (short) 3584);\r\n        /*\r\n         * certificate #2 and #3 are applet specific allocate enough memory\r\n         */\r\n        authenticationCertificate = new ElementaryFile(AUTH_CERTIFICATE, belpicDirectory, (short) 1200);\r\n        nonRepudiationCertificate = new ElementaryFile(NONREP_CERTIFICATE, belpicDirectory, (short) 1200);\r\n    }\r\n    \r\n    /**\r\n     * initialize basic key pair\r\n     */\r\n    private void initializeKeyPairs() \r\n          //@ requires nonRepKeyPair |-\u003e _ \u0026*\u0026 authKeyPair |-\u003e _ \u0026*\u0026 basicKeyPair |-\u003e _;\r\n              /*@ ensures nonRepKeyPair |-\u003e ?theNonRepKeyPair \u0026*\u0026 theNonRepKeyPair != null \u0026*\u0026\r\n                  authKeyPair |-\u003e ?theAuthKeyPair \u0026*\u0026 theAuthKeyPair != null \u0026*\u0026\r\n                  basicKeyPair |-\u003e ?theBasicKeyPair \u0026*\u0026 theBasicKeyPair != null;\r\n        @*/\r\n    {\r\n        /*\r\n         * basicKeyPair is static (so same for all applets) so only allocate\r\n         * memory once\r\n         */\r\n        if (NewEidCard.basicKeyPair != null \u0026\u0026 authKeyPair != null \u0026\u0026 nonRepKeyPair != null) {\r\n            return;\r\n        }\r\n        \r\n        \r\n        basicKeyPair = new KeyPair(KeyPair.ALG_RSA_CRT, (short) 1024);\r\n        basicKeyPair.genKeyPair();\r\n        \r\n        authKeyPair = new KeyPair(KeyPair.ALG_RSA_CRT, (short) (1024));\r\n        authKeyPair.genKeyPair();\r\n        \r\n        \r\n    \r\n        //authPrivateKey = (RSAPrivateCrtKey) KeyBuilder.buildKey(KeyBuilder.TYPE_RSA_CRT_PRIVATE, KeyBuilder.LENGTH_RSA_1024, false);\r\n        \r\n\r\n        nonRepKeyPair = new KeyPair(KeyPair.ALG_RSA_CRT, (short) (1024));\r\n        nonRepKeyPair.genKeyPair();\r\n    \r\n        //nonRepPrivateKey = (RSAPrivateCrtKey) KeyBuilder.buildKey(KeyBuilder.TYPE_RSA_CRT_PRIVATE, KeyBuilder.LENGTH_RSA_1024, false);\r\n    }\r\n    /**\r\n     * select file under the current DF\r\n     */\r\n    private void selectByFileIdentifier(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        // receive the data to see which file needs to be selected\r\n        short byteRead = apdu.setIncomingAndReceive();\r\n        // check Lc\r\n        short lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n        if ((lc != 2) || (byteRead != 2))\r\n            ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n        // get the file identifier out of the APDU\r\n        short fid = Util.makeShort(buffer[ISO7816.OFFSET_CDATA], buffer[ISO7816.OFFSET_CDATA + 1]);\r\n        JCSystem.beginTransaction();\r\n        //@ open valid();\r\n        //@ assert selected_file_types(_, ?f1, ?f2, ?f3, ?f4, ?f5, ?f6, ?f7, ?f8, ?f9, ?f10, ?f11, ?f12, ?f13, ?f14, ?f15, ?f16, ?f17, ?f18, ?f19, ?f20, ?f21, _);\r\n        // if file identifier is the master file, select it immediately\r\n        if (fid == MF)\r\n            selectedFile = masterFile;        \r\n        else {\r\n            // check if the requested file exists under the current DF\r\n            ////@ close masterFile.DedicatedFile();\r\n            //@ MasterFile theMasterFile = masterFile;\r\n            //@ assert theMasterFile.MasterFile(16128, null, ?x1, ?x2, ?x3);\r\n            //@ close theMasterFile.DedicatedFile(16128, null, x1, x2, x3);\r\n            File s = ((DedicatedFile) masterFile).getSibling(fid);\r\n            //@ open theMasterFile.DedicatedFile(16128, null, x1, x2, x3);\r\n            //VF /bug\r\n            if (s != null) {\r\n                selectedFile = s;\r\n            //the fid is an elementary file:\r\n            } else {\r\n                s = belpicDirectory.getSibling(fid);\r\n                if (s != null) {\r\n                    selectedFile = s;\r\n                } else {\r\n                    s = idDirectory.getSibling(fid);\r\n                    if (s != null) {\r\n                        selectedFile = s;\r\n                        \r\n                    } else {\r\n                        ISOException.throwIt(ISO7816.SW_FILE_NOT_FOUND);\r\n                    }\r\n                }\r\n                \r\n            }\r\n            //@ close selected_file_types(s, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f20, f21, _);    \r\n        }    \r\n        \r\n        //@ close valid();\r\n        JCSystem.commitTransaction();\r\n    }\r\n    /**\r\n     * select file by path from the MF\r\n     */\r\n    private void selectByPath(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        // receive the path name\r\n        short byteRead = apdu.setIncomingAndReceive();\r\n        // check Lc\r\n        //@ masking_and(buffer[ISO7816.OFFSET_LC], 0x00FF);\r\n        short lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n        // it must be a multiple of 2\r\n        if (((lc \u0026 1) == 1) || ((byteRead \u0026 1) == 1))\r\n            ISOException.throwIt(SW_INCONSISTENT_P1P2);\r\n        if ((short) (buffer.length) \u003c (short) (ISO7816.OFFSET_CDATA + lc + 1))\r\n            ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n        //@ open [1/2]valid();\r\n        // use the path name in the APDU data to select a file\r\n        File f = masterFile;\r\n        //@ assert lc \u003c= 255;\r\n        ////@ assert [1/2]masterFile |-\u003e ?theMasterFile;\r\n        for (byte i = 0; i \u003c lc; i += 2) \r\n            /*@ invariant array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 i \u003e= 0 \u0026*\u0026 i \u003c (lc + 2) \u0026*\u0026 \r\n                        [1/2]randomBuffer |-\u003e ?theRandomBuffer \u0026*\u0026 theRandomBuffer != null \u0026*\u0026 [1/2]array_slice(theRandomBuffer, 0, theRandomBuffer.length, _) \u0026*\u0026 theRandomBuffer.length == 256 \u0026*\u0026\r\n                    [1/2]responseBuffer |-\u003e ?theResponseBuffer \u0026*\u0026 theResponseBuffer != null \u0026*\u0026 [1/2]array_slice(theResponseBuffer, 0, theResponseBuffer.length, _) \u0026*\u0026 theResponseBuffer.length == 128 \u0026*\u0026\r\n                    [1/2]randomData |-\u003e ?theRandomData \u0026*\u0026 theRandomData != null \u0026*\u0026\r\n                    [1/2]cipher |-\u003e ?theCipher \u0026*\u0026 theCipher != null \u0026*\u0026\r\n                    [1/2]messageBuffer |-\u003e ?theMessageBuffer \u0026*\u0026 theMessageBuffer != null \u0026*\u0026 theMessageBuffer.length == 128 \u0026*\u0026 is_transient_byte_array(theMessageBuffer) == true \u0026*\u0026\r\n                    [1/2]previousApduType |-\u003e ?thePreviousApduType \u0026*\u0026 thePreviousApduType != null \u0026*\u0026 thePreviousApduType.length == 1 \u0026*\u0026 is_transient_byte_array(thePreviousApduType) == true \u0026*\u0026\r\n                    [1/2]signatureType |-\u003e ?theSignatureType \u0026*\u0026 theSignatureType != null \u0026*\u0026 theSignatureType.length == 1 \u0026*\u0026 is_transient_byte_array(theSignatureType) == true \u0026*\u0026\r\n                    [1/2]masterFile |-\u003e ?theMasterFile \u0026*\u0026 [1/2]theMasterFile.MasterFile(0x3F00, null, _, ?masterSibs, _) \u0026*\u0026 theMasterFile != null \u0026*\u0026 theMasterFile.getClass() == MasterFile.class \u0026*\u0026\r\n                    [1/2]cardholderPin |-\u003e ?theCardholderPin \u0026*\u0026 [1/2]OwnerPIN(theCardholderPin, _, _) \u0026*\u0026 theCardholderPin != null \u0026*\u0026 \r\n                    [1/2]resetPin |-\u003e ?theResetPin \u0026*\u0026 [1/2]OwnerPIN(theResetPin, _, _) \u0026*\u0026 theResetPin != null \u0026*\u0026\r\n                    [1/2]unblockPin |-\u003e ?theUnblockPin \u0026*\u0026 [1/2]OwnerPIN(theUnblockPin, _, _) \u0026*\u0026 theUnblockPin != null \u0026*\u0026\r\n                    [1/2]activationPin |-\u003e ?theActivationPin \u0026*\u0026 [1/2]OwnerPIN(theActivationPin, _, _) \u0026*\u0026 theActivationPin != null \u0026*\u0026\r\n                    [1/2]identityFile |-\u003e ?theIdentityFile \u0026*\u0026 [1/2]theIdentityFile.ElementaryFile(_, _, ?identityData, _, _, _) \u0026*\u0026 theIdentityFile != null \u0026*\u0026 identityData != null \u0026*\u0026 identityData.length == 0xD0 \u0026*\u0026 theIdentityFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n                    [1/2]identityFileSignature |-\u003e ?theIdentityFileSignature \u0026*\u0026 [1/2]theIdentityFileSignature.ElementaryFile(_, _, ?theIdentityFileSignatureData, _, _, _) \u0026*\u0026 theIdentityFileSignature != null \u0026*\u0026 theIdentityFileSignatureData != null \u0026*\u0026 theIdentityFileSignatureData.length == 0x80 \u0026*\u0026 theIdentityFileSignature.getClass() == ElementaryFile.class \u0026*\u0026\r\n                    [1/2]addressFile |-\u003e ?theAddressFile \u0026*\u0026 [1/2]theAddressFile.ElementaryFile(_, _, ?theAddressFileData, _, _, _) \u0026*\u0026 theAddressFile != null \u0026*\u0026 theAddressFileData != null \u0026*\u0026 theAddressFileData.length == 117 \u0026*\u0026 theAddressFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n                    [1/2]addressFileSignature |-\u003e ?theAddressFileSignature \u0026*\u0026 [1/2]theAddressFileSignature.ElementaryFile(_, _, ?theAddressFileSignatureData, _, _, _) \u0026*\u0026 theAddressFileSignature != null \u0026*\u0026 theAddressFileSignatureData != null \u0026*\u0026 theAddressFileSignatureData.length == 128 \u0026*\u0026 theAddressFileSignature.getClass() == ElementaryFile.class \u0026*\u0026\r\n                    [1/2]photoFile |-\u003e ?thePhotoFile \u0026*\u0026 [1/2]thePhotoFile.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 thePhotoFile != null \u0026*\u0026 thePhotoFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n                    [1/2]caRoleIDFile |-\u003e ?thecaRoleIDFile \u0026*\u0026 [1/2]thecaRoleIDFile.ElementaryFile(_, _, ?theCaRoleIDFileData, _, _, _) \u0026*\u0026 thecaRoleIDFile != null \u0026*\u0026 theCaRoleIDFileData != null \u0026*\u0026 theCaRoleIDFileData.length == 0x20 \u0026*\u0026 thecaRoleIDFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n                    [1/2]dirFile |-\u003e ?theDirFile \u0026*\u0026 [1/2]theDirFile.ElementaryFile(_, _, ?theDirFileData, _, _, _) \u0026*\u0026 theDirFile != null \u0026*\u0026 theDirFileData != null \u0026*\u0026 theDirFileData.length ==  0x25 \u0026*\u0026 theDirFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n                    [1/2]tokenInfo |-\u003e ?theTokenInfo \u0026*\u0026 [1/2]theTokenInfo.ElementaryFile(_, _, ?theTokenInfoData, _, _, _) \u0026*\u0026 theTokenInfo != null \u0026*\u0026 theTokenInfoData != null \u0026*\u0026 theTokenInfoData.length == 0x30 \u0026*\u0026 theTokenInfo.getClass() == ElementaryFile.class \u0026*\u0026\r\n                    [1/2]objectDirectoryFile |-\u003e ?theObjectDirectoryFile \u0026*\u0026 [1/2]theObjectDirectoryFile.ElementaryFile(_, _, ?theObjectDirectoryFileData, _, _, _) \u0026*\u0026 theObjectDirectoryFile != null \u0026*\u0026 theObjectDirectoryFileData != null \u0026*\u0026 theObjectDirectoryFileData.length == 40 \u0026*\u0026 theObjectDirectoryFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n                    [1/2]authenticationObjectDirectoryFile |-\u003e ?theAuthenticationObjectDirectoryFile \u0026*\u0026 [1/2]theAuthenticationObjectDirectoryFile.ElementaryFile(_, _, ?theAuthenticationObjectDirectoryFileData, _, _, _) \u0026*\u0026 theAuthenticationObjectDirectoryFile != null \u0026*\u0026 theAuthenticationObjectDirectoryFileData != null \u0026*\u0026 theAuthenticationObjectDirectoryFileData.length == 0x40 \u0026*\u0026  theAuthenticationObjectDirectoryFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n                    [1/2]privateKeyDirectoryFile |-\u003e ?thePrivateKeyDirectoryFile \u0026*\u0026 [1/2]thePrivateKeyDirectoryFile.ElementaryFile(_, _, ?thePrivateKeyDirectoryFileData, _, _, _) \u0026*\u0026 thePrivateKeyDirectoryFile != null \u0026*\u0026 thePrivateKeyDirectoryFileData != null \u0026*\u0026 thePrivateKeyDirectoryFileData.length == 0xB0 \u0026*\u0026 thePrivateKeyDirectoryFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n                    [1/2]certificateDirectoryFile |-\u003e ?theCertificateDirectoryFile \u0026*\u0026 [1/2]theCertificateDirectoryFile.ElementaryFile(_, _, ?theCertificateDirectoryFileData, _, _, _) \u0026*\u0026 theCertificateDirectoryFile != null \u0026*\u0026 theCertificateDirectoryFileData != null \u0026*\u0026 theCertificateDirectoryFileData.length == 0xB0 \u0026*\u0026 theCertificateDirectoryFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n                    [1/2]belpicDirectory |-\u003e ?theBelpicDirectory \u0026*\u0026 [1/2]theBelpicDirectory.DedicatedFile(_, _, _, ?belpicSibs, _) \u0026*\u0026 theBelpicDirectory != null \u0026*\u0026 theBelpicDirectory.getClass() == DedicatedFile.class \u0026*\u0026\r\n                    [1/2]idDirectory |-\u003e ?theIdDirectory \u0026*\u0026 [1/2]theIdDirectory.DedicatedFile(_, _, _, ?idSibs, _) \u0026*\u0026 theIdDirectory != null \u0026*\u0026 theIdDirectory.getClass() == DedicatedFile.class \u0026*\u0026\r\n                    [1/2]caCertificate |-\u003e ?theCaCertificate \u0026*\u0026 [1/2]theCaCertificate.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 theCaCertificate.getClass() == ElementaryFile.class \u0026*\u0026\r\n                    [1/2]selectedFile |-\u003e ?theSelectedFile \u0026*\u0026 theSelectedFile != null \u0026*\u0026\r\n                    masterSibs == cons\u003cFile\u003e(theDirFile, cons(theBelpicDirectory, cons(theIdDirectory, nil))) \u0026*\u0026\r\n                    [1/2]rootCaCertificate |-\u003e ?theRootCaCertificate \u0026*\u0026 [1/2]theRootCaCertificate.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 theRootCaCertificate.getClass() == ElementaryFile.class \u0026*\u0026\r\n                    [1/2]rrnCertificate |-\u003e ?theRrnCertificate \u0026*\u0026 [1/2]theRrnCertificate.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 theRrnCertificate.getClass() == ElementaryFile.class \u0026*\u0026\r\n                    [1/2]authenticationCertificate |-\u003e ?theAuthenticationCertificate \u0026*\u0026 [1/2]theAuthenticationCertificate.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 theAuthenticationCertificate.getClass() == ElementaryFile.class \u0026*\u0026\r\n                    [1/2]nonRepudiationCertificate |-\u003e ?theNonRepudiationCertificate \u0026*\u0026 [1/2]theNonRepudiationCertificate.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 theNonRepudiationCertificate.getClass() == ElementaryFile.class \u0026*\u0026\r\n                    [1/2]preferencesFile |-\u003e ?thePreferencesFile \u0026*\u0026 thePreferencesFile != theCaCertificate \u0026*\u0026 thePreferencesFile != theRrnCertificate \u0026*\u0026 [1/2]thePreferencesFile.ElementaryFile(_, _, ?thePreferencesFileData, _, _, _) \u0026*\u0026 thePreferencesFile != null \u0026*\u0026 thePreferencesFileData != null \u0026*\u0026 thePreferencesFileData.length == 100 \u0026*\u0026 thePreferencesFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n                    belpicSibs == cons\u003cFile\u003e(theTokenInfo, cons(theObjectDirectoryFile, cons(theAuthenticationObjectDirectoryFile, cons(thePrivateKeyDirectoryFile, cons(theCertificateDirectoryFile, cons(theCaCertificate, cons(theRrnCertificate, cons(theRootCaCertificate, cons(theAuthenticationCertificate, cons(theNonRepudiationCertificate, nil)))))))))) \u0026*\u0026\r\n                    idSibs == cons\u003cFile\u003e(theIdentityFile, cons(theIdentityFileSignature, cons(theAddressFile, cons(theAddressFileSignature, cons(thecaRoleIDFile, cons(thePreferencesFile, cons(thePhotoFile, nil))))))) \u0026*\u0026\r\n                    [1/2]selected_file_types(theSelectedFile, theMasterFile, theBelpicDirectory, theIdDirectory, theIdentityFile, theIdentityFileSignature, theAddressFile, theAddressFileSignature, thePhotoFile, thecaRoleIDFile, theDirFile, theTokenInfo, theObjectDirectoryFile, theAuthenticationObjectDirectoryFile, thePrivateKeyDirectoryFile, theCaCertificate, theCertificateDirectoryFile, theRrnCertificate, theRootCaCertificate, theAuthenticationCertificate, theNonRepudiationCertificate, thePreferencesFile, _) \u0026*\u0026\r\n                        [1/2]selected_file_class(theSelectedFile) \u0026*\u0026\r\n                    [1/2]signatureAlgorithm |-\u003e ?theSignatureAlgorithm \u0026*\u0026\r\n                    [1/2]nonRepKeyPair |-\u003e ?theNonRepKeyPair \u0026*\u0026 theNonRepKeyPair != null \u0026*\u0026\r\n                    [1/2]authKeyPair |-\u003e ?theAuthKeyPair \u0026*\u0026 theAuthKeyPair != null \u0026*\u0026\r\n                    [1/2]basicKeyPair |-\u003e ?theBasicKeyPair \u0026*\u0026\r\n                    [1/2]PKCS1_HEADER |-\u003e ?thePKCS1HEADER \u0026*\u0026 thePKCS1HEADER != null \u0026*\u0026 [1/2]array_slice(thePKCS1HEADER, 0, thePKCS1HEADER.length, _) \u0026*\u0026 thePKCS1HEADER.length == 1 \u0026*\u0026\r\n                    [1/2]PKCS1_SHA1_HEADER |-\u003e ?thePKCS1SHA1HEADER \u0026*\u0026 thePKCS1SHA1HEADER != null \u0026*\u0026 [1/2]array_slice(thePKCS1SHA1HEADER, 0, thePKCS1SHA1HEADER.length, _) \u0026*\u0026 thePKCS1SHA1HEADER.length == 16 \u0026*\u0026\r\n                    [1/2]PKCS1_MD5_HEADER |-\u003e ?thePKCS1MD5HEADER \u0026*\u0026 thePKCS1MD5HEADER != null \u0026*\u0026 [1/2]array_slice(thePKCS1MD5HEADER, 0, thePKCS1MD5HEADER.length, _) \u0026*\u0026 thePKCS1MD5HEADER.length == 19 \u0026*\u0026\r\n                    theDirFile != thePreferencesFile \u0026*\u0026 theTokenInfo != thePreferencesFile \u0026*\u0026 thePreferencesFile != theObjectDirectoryFile \u0026*\u0026 thePreferencesFile != theAuthenticationObjectDirectoryFile \u0026*\u0026 thePreferencesFile != thePrivateKeyDirectoryFile \u0026*\u0026\r\n                    (f == null ? \r\n                      true \r\n                        : \r\n                      selected_file_types(f, theMasterFile, theBelpicDirectory, theIdDirectory, theIdentityFile, theIdentityFileSignature, theAddressFile, theAddressFileSignature, thePhotoFile, thecaRoleIDFile, theDirFile, theTokenInfo, theObjectDirectoryFile, theAuthenticationObjectDirectoryFile, thePrivateKeyDirectoryFile, theCaCertificate, theCertificateDirectoryFile, theRrnCertificate, theRootCaCertificate, theAuthenticationCertificate, theNonRepudiationCertificate, thePreferencesFile, _) \u0026*\u0026\r\n                      f.getClass() == ElementaryFile.class || f.getClass() == MasterFile.class || f.getClass() == DedicatedFile.class                             \r\n                    ) \u0026*\u0026\r\n                    (i == 0 ? \r\n                      f == theMasterFile \r\n                        :\r\n                      (i \u003c= 2 ?\r\n                        f == null || f == theMasterFile || mem(f, masterSibs) \r\n                          :\r\n                        (i \u003c= 4 ?\r\n                          f == null || mem(f, masterSibs) || mem(f, belpicSibs) || mem(f, idSibs)\r\n                        :\r\n                          (i \u003c= 6 ?\r\n                            f == null || mem(f, belpicSibs) || mem(f, idSibs)\r\n                              :\r\n                            false\r\n                          )\r\n                        )\r\n                      )\r\n                    ); @*/\r\n        {\r\n            short fid = Util.makeShort(buffer[(short) (ISO7816.OFFSET_CDATA + i)], buffer[(short) (ISO7816.OFFSET_CDATA + i + 1)]);\r\n            // MF can be explicitely or implicitely in the path name\r\n            if ((i == 0) \u0026\u0026 (fid == MF))\r\n                f = masterFile;\r\n            else {\r\n                    \r\n                if ((f instanceof ElementaryFile) || f == null)\r\n                    ISOException.throwIt(ISO7816.SW_FILE_NOT_FOUND);\r\n                //@ open selected_file_types(f, theMasterFile, theBelpicDirectory, theIdDirectory, theIdentityFile, theIdentityFileSignature, theAddressFile, theAddressFileSignature, thePhotoFile, thecaRoleIDFile, theDirFile, theTokenInfo, theObjectDirectoryFile, theAuthenticationObjectDirectoryFile, thePrivateKeyDirectoryFile, theCaCertificate, theCertificateDirectoryFile, theRrnCertificate, theRootCaCertificate, theAuthenticationCertificate, theNonRepudiationCertificate, thePreferencesFile, _);\r\n                //@ File oldf = f;\r\n                /*@ \r\n                if(f == masterFile) \r\n                {} else if (f == idDirectory) {} else {}\r\n                @*/\r\n                /*@\r\n                if(f == masterFile) {\r\n                  masterFile.castMasterToDedicated();\r\n                  }              \r\n                  @*/\r\n                f = ((DedicatedFile) f).getSibling(fid);\r\n                /*@ if(oldf == masterFile) {\r\n                        masterFile.castDedicatedToMaster();\r\n                        assert f == null || (f == idDirectory \u0026\u0026 f.getClass() == DedicatedFile.class) || (f == belpicDirectory \u0026\u0026 f.getClass() == DedicatedFile.class)|| (f == dirFile \u0026\u0026 f.getClass() == ElementaryFile.class);\r\n                    } \r\n                @*/\r\n                /*@\r\n                  if(f != null) {\r\n                    close selected_file_types(f, theMasterFile, theBelpicDirectory, theIdDirectory, theIdentityFile, theIdentityFileSignature, theAddressFile, theAddressFileSignature, thePhotoFile, thecaRoleIDFile, theDirFile, theTokenInfo, theObjectDirectoryFile, theAuthenticationObjectDirectoryFile, thePrivateKeyDirectoryFile, theCaCertificate, theCertificateDirectoryFile, theRrnCertificate, theRootCaCertificate, theAuthenticationCertificate, theNonRepudiationCertificate, thePreferencesFile, _);\r\n                  }\r\n                @*/\r\n                \r\n            }\r\n        }\r\n        if (f == null)\r\n            ISOException.throwIt(ISO7816.SW_FILE_NOT_FOUND);\r\n\r\n        JCSystem.beginTransaction();\r\n        //@ open [1/2]valid();\r\n        ////@ open selected_file_types(f, ?g1, ?g2, ?g3, ?g4, ?g5, ?g6, ?g7, ?g8, ?g9, ?g10, ?g11, ?g12, ?g13, ?g14, ?g15, ?g16, ?g17, ?g18, ?g19, ?g20, ?g21, _);\r\n        selectedFile = f;\r\n        ////@ close selected_file_types(f, g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11, g12, g13, g14, g15, g16, g17, g18, g19, g20, g21, _);\r\n        //@ close valid();\r\n        JCSystem.commitTransaction();\r\n    }\r\n\r\n    /*VF* END COPY */\r\n    \r\n\r\n    /**\r\n     * initialize all the PINs\r\n     * \r\n     * PINs are set to the same values as the sample eID card\r\n     */\r\n    private void initializePins() \r\n          /*@ requires this.cardholderPin |-\u003e _ \u0026*\u0026 this.resetPin |-\u003e _\r\n                      \u0026*\u0026 this.unblockPin |-\u003e _ \u0026*\u0026 this.activationPin |-\u003e _;\r\n          @*/\r\n              /*@ ensures this.cardholderPin |-\u003e ?theCardholderPin \u0026*\u0026 OwnerPIN(theCardholderPin, _, _) \u0026*\u0026 theCardholderPin != null \r\n            \u0026*\u0026 this.resetPin |-\u003e ?theResetPin \u0026*\u0026 OwnerPIN(theResetPin, _, _) \u0026*\u0026 theResetPin != null\r\n            \u0026*\u0026 this.unblockPin |-\u003e ?theUnblockPin \u0026*\u0026 OwnerPIN(theUnblockPin, _, _) \u0026*\u0026 theUnblockPin != null\r\n            \u0026*\u0026 this.activationPin |-\u003e ?theActivationPin \u0026*\u0026 OwnerPIN(theActivationPin, _, _) \u0026*\u0026 theActivationPin != null;\r\n              @*/\r\n              //this.cardholderPin |-\u003e ?theCardholderPin \u0026*\u0026 \r\n    {\r\n        /*\r\n         * initialize cardholder PIN (hardcoded to fixed value)\r\n         * \r\n         * PIN header is \"24\" (length of PIN = 4) PIN itself is \"1234\" (4\r\n         * digits) fill rest of PIN data with F\r\n         */\r\n        /*VF*byte[] cardhold = { (byte) 0x24, (byte) 0x12, (byte) 0x34, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }; */\r\n        byte cardhold[] = new byte[] { (byte) 0x24, (byte) 0x12, (byte) 0x34, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF };\r\n        cardholderPin = new OwnerPIN(CARDHOLDER_PIN_TRY_LIMIT, PIN_SIZE);\r\n        cardholderPin.update(cardhold, (short) 0, PIN_SIZE);\r\n        /*\r\n         * initialize unblock PUK (hardcoded to fixed value)\r\n         * \r\n         * PUK header is \"2c\" (length of PUK = 12) PUK itself consists of 2\r\n         * parts PUK2 is \"222222\" (6 digits) PUK1 is \"111111\" (6 digits) so in\r\n         * total the PUK is \"222222111111\" (12 digits) fill last bye of PUK data\r\n         * with \"FF\"\r\n         */\r\n        /*VF* byte[] unblock = { (byte) 0x2c, (byte) 0x22, (byte) 0x22, (byte) 0x22, (byte) 0x11, (byte) 0x11, (byte) 0x11, (byte) 0xFF }; */\r\n        byte unblock[] = new byte[] { (byte) 0x2c, (byte) 0x22, (byte) 0x22, (byte) 0x22, (byte) 0x11, (byte) 0x11, (byte) 0x11, (byte) 0xFF };\r\n        unblockPin = new OwnerPIN(UNBLOCK_PIN_TRY_LIMIT, PIN_SIZE);\r\n        unblockPin.update(unblock, (short) 0, PIN_SIZE);\r\n        /*\r\n         * activation PIN is same as PUK\r\n         */\r\n        activationPin = new OwnerPIN(ACTIVATE_PIN_TRY_LIMIT, PIN_SIZE);\r\n        activationPin.update(unblock, (short) 0, PIN_SIZE);\r\n        /*\r\n         * initialize reset PIN (hardcoded to fixed value)\r\n         * \r\n         * PUK header is \"2c\" (length of PUK = 12) PIN itself consists of 2\r\n         * parts PUK3 is \"333333\" (6 digits) PUK1 is \"111111\" (6 digits) so in\r\n         * total the PIN is \"333333111111\" (12 digits) fill last bye of PIN data\r\n         * with \"FF\"\r\n         */\r\n        /*VF* byte[] reset = { (byte) 0x2c, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x11, (byte) 0x11, (byte) 0x11, (byte) 0xFF }; */\r\n        byte reset[] = new byte[] { (byte) 0x2c, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x11, (byte) 0x11, (byte) 0x11, (byte) 0xFF };\r\n        resetPin = new OwnerPIN(RESET_PIN_TRY_LIMIT, PIN_SIZE);\r\n        resetPin.update(reset, (short) 0, PIN_SIZE);\r\n    }\r\n    \r\n    /**\r\n     * private constructor - called by the install method to instantiate a\r\n     * NewEidCard instance\r\n     * \r\n     * needs to be protected so that it can be invoked by subclasses\r\n     */\r\n    protected NewEidCard() \r\n        /*@ requires\r\n               class_init_token(NewEidCard.class) \u0026*\u0026 system(); @*/\r\n        //@ ensures true;\r\n    {\r\n        \r\n        NewEidPointsObject = new NewEidPoints();\r\n        //@ NewEidPointsObject.applet = this;\r\n        \r\n        //@ init_class();\r\n        //internalAuthenticateCounter = 5000;\r\n\r\n        randomBuffer = new byte[256];\r\n        responseBuffer = new byte[128];\r\n        // initialize these objects once for the superclass\r\n        // otherwise we have RAM problems when running multiple NewEidCard applets\r\n        if (NewEidCard.randomData == null)\r\n            NewEidCard.randomData = RandomData.getInstance(RandomData.ALG_SECURE_RANDOM);\r\n        if (NewEidCard.cipher == null)\r\n            NewEidCard.cipher = Cipher.getInstance(Cipher.ALG_RSA_NOPAD, false);\r\n        Cipher c =  Cipher.getInstance(Cipher.ALG_RSA_NOPAD, false);\r\n        if (NewEidCard.messageBuffer == null)\r\n            NewEidCard.messageBuffer = JCSystem.makeTransientByteArray((short) 128, JCSystem.CLEAR_ON_DESELECT);\r\n        // make these transient objects so that they are stored in RAM\r\n        previousApduType = JCSystem.makeTransientByteArray((short) 1, JCSystem.CLEAR_ON_DESELECT);\r\n        signatureType = JCSystem.makeTransientByteArray((short) 1, JCSystem.CLEAR_ON_DESELECT);\r\n        // register the applet instance with the JCRE\r\n\r\n        /*VF* COPIED FROM EmptyEidCard */\r\n        // initialize PINs to fixed value\r\n        initializePins();\r\n        // initialize file system\r\n        initializeFileSystem();\r\n        // initialize place holders for large files (certificates + photo)\r\n        initializeEmptyLargeFiles();\r\n        // initialize basic keys pair\r\n        initializeKeyPairs();\r\n        /*VF* END COPY */\r\n         //@ preferencesFile.neq(caCertificate);\r\n         //@ preferencesFile.neq(rrnCertificate);\r\n         //@ preferencesFile.neq(dirFile);\r\n         //@ preferencesFile.neq(tokenInfo);\r\n         //@ preferencesFile.neq(objectDirectoryFile);\r\n         //@ preferencesFile.neq(authenticationObjectDirectoryFile);\r\n         //@ preferencesFile.neq(privateKeyDirectoryFile);\r\n        //@ close valid();\r\n        register();\r\n    }\r\n    /**\r\n     * initialize the applet when it is selected\r\n     * \r\n     * select always has to happen after a reset\r\n     */\r\n    public boolean select() \r\n            //@ requires current_applet(this) \u0026*\u0026 [1/2]valid();\r\n            //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid();\r\n    {\r\n        // Clear data and set default selectedFile to masterFile\r\n        clear();\r\n        return true;\r\n    }\r\n    /**\r\n     * perform any cleanup and bookkeeping tasks before the applet is deselected\r\n     */\r\n    public void deselect() \r\n            //@ requires current_applet(this) \u0026*\u0026 [1/2]valid();\r\n            //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid();\r\n    {\r\n        clear();\r\n        return;\r\n    }\r\n    /**\r\n     * process APDUs\r\n     */\r\n    public void process(APDU apdu) \r\n            //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, ?buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _);\r\n            //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _);\r\n    {\r\n        byte[] buffer = apdu.getBuffer();\r\n        /*\r\n         * - non repudiation signatures can only be generated if the previous\r\n         * APDU verified the cardholder PIN - administrator PIN change is only\r\n         * possible if the previous APDU verified the reset PIN\r\n         * \r\n         * so only the \"generate signature\" and PIN Change APDU needs to check\r\n         * the previous APDU type; in all other cases overwrite the previous\r\n         * APDU type, because this information is not needed; we do this as\r\n         * early as possible to cope with exceptions being thrown during\r\n         * processing of APDU\r\n         * \r\n         * IMPORTANT : we have to set the previous APDU type in the processing\r\n         * of a PIN Verify APDU (because the type gets overwritten to a wrong\r\n         * value) and at the end of a \"generate signature\" and PIN Change APDU\r\n         */\r\n        JCSystem.beginTransaction();\r\n        //@ open valid();\r\n        if ((buffer[ISO7816.OFFSET_INS] != INS_GENERATE_SIGNATURE) \u0026\u0026 (buffer[ISO7816.OFFSET_INS] != INS_CHANGE_PIN) \u0026\u0026 (buffer[ISO7816.OFFSET_INS] != INS_GET_KEY))\r\n            setPreviousApduType(OTHER);\r\n        //@ close valid();\r\n        JCSystem.commitTransaction();\r\n        // return if the APDU is the applet SELECT command\r\n        if (selectingApplet()) {\r\n            return;\r\n        }\r\n        if (buffer[ISO7816.OFFSET_CLA] == EIDCARD_CLA_1)\r\n            // check the INS byte to decide which service method to call\r\n            switch (buffer[ISO7816.OFFSET_INS]) {\r\n            // case INS_CHANGE_ATR :\r\n            // changeATR(apdu);\r\n            // break;\r\n            case INS_VERIFY_PIN:\r\n                verifyPin(apdu, buffer);\r\n                break;\r\n            case INS_CHANGE_PIN:\r\n                changePin(apdu, buffer);\r\n                break;\r\n            case INS_UNBLOCK:\r\n                unblock(apdu, buffer);\r\n                break;\r\n            case INS_GET_CHALLENGE:\r\n                getChallenge(apdu, buffer);\r\n                break;\r\n            case INS_PREPARE_SIGNATURE:\r\n                prepareForSignature(apdu, buffer);\r\n                break;\r\n            case INS_GENERATE_SIGNATURE:\r\n                generateSignature(apdu, buffer);\r\n                break;\r\n            case INS_GENERATE_KEYPAIR:\r\n                generateKeyPair(apdu);\r\n                break;\r\n            case INS_INTERNAL_AUTHENTICATE:\r\n                internalAuthenticate(apdu, buffer);\r\n                break;\r\n            case INS_GET_RESPONSE:\r\n                // if only T=0 supported: remove\r\n                // not possible in case of T=0 protocol\r\n                if (APDU.getProtocol() == APDU.PROTOCOL_T1)\r\n                    getResponse(apdu, buffer);\r\n                else\r\n                    ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);\r\n                break;\r\n            case INS_SELECT_FILE:\r\n                selectFile(apdu, buffer);\r\n                break;\r\n            case INS_ACTIVATE_FILE:\r\n                activateFile(apdu, buffer);\r\n                break;\r\n            case INS_DEACTIVATE_FILE:\r\n                deactivateFile(apdu, buffer);\r\n                break;\r\n            case INS_READ_BINARY:\r\n                readBinary(apdu, buffer);\r\n                break;\r\n            case INS_UPDATE_BINARY:\r\n                updateBinary(apdu, buffer);\r\n                break;\r\n            case INS_ERASE_BINARY:\r\n                eraseBinary(apdu, buffer);\r\n                break;\r\n            case INS_Credit:\r\n                askForCharge();\r\n                break;\r\n            default:\r\n                ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);\r\n                break; //~allow_dead_code\r\n            }\r\n        else if (buffer[ISO7816.OFFSET_CLA] == EIDCARD_CLA_2)\r\n            switch (buffer[ISO7816.OFFSET_INS]) {\r\n            case INS_GET_KEY:\r\n                getPublicKey(apdu);\r\n                break;\r\n            case INS_PUT_KEY:\r\n                putPublicKey(apdu, buffer);\r\n                break;\r\n            case INS_ERASE_KEY:\r\n                eraseKey(apdu, buffer);\r\n                break;\r\n            case INS_ACTIVATE_KEY:\r\n                activateKey(apdu, buffer);\r\n                break;\r\n            case INS_DEACTIVATE_KEY:\r\n                deactivateKey(apdu, buffer);\r\n                break;\r\n            case INS_GET_CARD_DATA:\r\n                getCardData(apdu, buffer);\r\n                break;\r\n            case INS_LOG_OFF:\r\n                logOff(apdu, buffer);\r\n                break;\r\n            case INS_Credit:\r\n                askForCharge();\r\n                break;\r\n            // case INS_BLOCK :\r\n            // blockCard(apdu, buffer);\r\n            // break;\r\n            }\r\n        else\r\n            ISOException.throwIt(ISO7816.SW_CLA_NOT_SUPPORTED);\r\n    }\r\n    /**\r\n     * verify the PIN\r\n     */\r\n    private void verifyPin(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        \r\n        // check P1\r\n        if (buffer[ISO7816.OFFSET_P1] != (byte) 0x00)\r\n            ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n        // receive the PIN data for validation\r\n        apdu.setIncomingAndReceive();\r\n        // check PIN depending on value of P2\r\n        JCSystem.beginTransaction();\r\n        //@ open valid();\r\n        switch (buffer[ISO7816.OFFSET_P2]) {\r\n        case CARDHOLDER_PIN:\r\n            // overwrite previous APDU type\r\n            setPreviousApduType(VERIFY_CARDHOLDER_PIN);\r\n            // check the cardholder PIN\r\n            checkPin(cardholderPin, buffer);\r\n            break;\r\n        case ACTIVATE_PIN:\r\n            // check the activation PIN\r\n            checkPin(activationPin, buffer);\r\n            // if the activation PIN was entered correctly\r\n            if (GPSystem.getCardContentState() == GPSystem.APPLICATION_SELECTABLE)\r\n                // set the applet status to personalized\r\n                GPSystem.setCardContentState(GPSystem.CARD_SECURED);\r\n            // reset internal authenticate counter\r\n            //internalAuthenticateCounter = 5000;\r\n            break;\r\n        case RESET_PIN:\r\n            // overwrite previous APDU type\r\n            setPreviousApduType(VERIFY_RESET_PIN);\r\n            // check the reset PIN\r\n            checkPin(resetPin, buffer);\r\n            break;\r\n        case UNBLOCK_PIN:\r\n            // check the unblock PIN: after this, the pin will be 'activated'\r\n            checkPin(unblockPin, buffer);\r\n            break;\r\n        default:\r\n            ISOException.throwIt(SW_REFERENCE_DATA_NOT_FOUND);\r\n        }\r\n        //@ close valid();\r\n        JCSystem.commitTransaction();\r\n    }\r\n    /**\r\n     * check the PIN\r\n     */\r\n    private void checkPin(OwnerPIN pin, byte[] buffer) \r\n          //@ requires [1/2]cardholderPin |-\u003e ?theCardholderPin \u0026*\u0026 [1/2]OwnerPIN(pin, _, _) \u0026*\u0026 pin != null \u0026*\u0026 buffer != null \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer.length \u003e= 13;\r\n              //@ ensures [1/2]cardholderPin |-\u003e theCardholderPin \u0026*\u0026 [1/2]OwnerPIN(pin, _, _) \u0026*\u0026 pin != null \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer != null \u0026*\u0026 buffer.length \u003e= 13;\r\n    {\r\n        if (pin.check(buffer, OFFSET_PIN_HEADER, PIN_SIZE) == true)\r\n            return;\r\n        short tries = pin.getTriesRemaining();\r\n        // the eID card throws this exception, SW=0x63C0 would make more sense\r\n        if (tries == 0) {\r\n            // if the cardholder PIN is no longer valid (too many tries)\r\n            if (pin == cardholderPin)\r\n                // set the applet status to blocked\r\n                GPSystem.setCardContentState(GPSystem.CARD_LOCKED);\r\n            ISOException.throwIt(ISO7816.SW_FILE_INVALID);\r\n        }\r\n        /*\r\n         * create the correct exception the status word is of the form 0x63Cx\r\n         * with x the number of tries left\r\n         */\r\n//@          or_limits(SW_WRONG_PIN_0_TRIES_LEFT, tries, nat_of_pos(p1(p1(p1(p1_)))));\r\n        short sw = (short) (SW_WRONG_PIN_0_TRIES_LEFT | tries);\r\n        ISOException.throwIt(sw);\r\n    }\r\n    /**\r\n     * change the PIN\r\n     */\r\n    private void changePin(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        /*\r\n         * IMPORTANT: in all other APDUs the previous APDU type gets overwritten\r\n         * in process() function; this is not the case here because the\r\n         * information is needed when processing to verify the security\r\n         * condition for administrator PIN change\r\n         * \r\n         * the previous APDU type has to be overwritten in every possible exit\r\n         * path out of this function\r\n         */\r\n        JCSystem.beginTransaction();\r\n        //@ open valid();\r\n        // check P2\r\n        if (buffer[ISO7816.OFFSET_P2] != (byte) 0x01) {\r\n            setPreviousApduType(OTHER);\r\n            ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n        }\r\n        // P1 determines whether it is user or administrator PIN change\r\n        switch (buffer[ISO7816.OFFSET_P1]) {\r\n        case (byte) 0x00:\r\n            setPreviousApduType(OTHER);\r\n            //@ close valid();\r\n            JCSystem.commitTransaction();\r\n            userChangePin(apdu, buffer);\r\n            break;\r\n        case (byte) 0x01:\r\n            //@ close valid();\r\n            JCSystem.commitTransaction();\r\n            administratorChangePin(apdu, buffer);\r\n            break;\r\n        default:\r\n            setPreviousApduType(OTHER);\r\n            //@ close valid();\r\n            JCSystem.commitTransaction();\r\n            ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n            break; //~allow_dead_code\r\n        }\r\n        \r\n    }\r\n    /**\r\n     * user changes the PIN\r\n     */\r\n    private void userChangePin(APDU apdu, byte[] buffer) \r\n          //@ requires [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer.length \u003e OFFSET_SECOND_PIN_HEADER + PIN_SIZE;\r\n              //@ ensures [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer.length \u003e OFFSET_SECOND_PIN_HEADER + PIN_SIZE;\r\n    {\r\n        //@ open [1/2]valid();\r\n        // receive the PIN data\r\n        short byteRead = apdu.setIncomingAndReceive();\r\n        // check Lc\r\n        short lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n        if ((lc != 16) || (byteRead != 16))\r\n            ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n        // first check old cardholder PIN\r\n        checkPin(cardholderPin, buffer);\r\n        // do some checks on the new PIN header and data\r\n        if (!isNewPinFormattedCorrectly(buffer, OFFSET_SECOND_PIN_HEADER))\r\n            ISOException.throwIt(ISO7816.SW_WRONG_DATA);\r\n        // include header as well in PIN object\r\n        cardholderPin.update(buffer, OFFSET_SECOND_PIN_HEADER, PIN_SIZE);\r\n        // validate cardholder PIN immediately after change PIN\r\n        // so that cardholder access rights are immediately granted\r\n        cardholderPin.check(buffer, OFFSET_SECOND_PIN_HEADER, PIN_SIZE);\r\n        //@ close [1/2]valid();\r\n    }\r\n    /**\r\n     * administrator changes the PIN\r\n     */\r\n    private void administratorChangePin(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        // The previous getChallenge() should ask for at least the length of the\r\n        // new administrator pin. Otherwise exception is thrown\r\n        /*\r\n         * IMPORTANT: the previous APDU type has to be overwritten in every\r\n         * possible exit path out of this function; therefore we check the\r\n         * security conditions as early as possible\r\n         */\r\n        JCSystem.beginTransaction();\r\n        //@ open valid();\r\n        // previous APDU must have checked the reset PIN\r\n        if ((!resetPin.isValidated()) || (getPreviousApduType() != VERIFY_RESET_PIN)) {\r\n            setPreviousApduType(OTHER);\r\n            ISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n        }\r\n        // overwrite previous ADPU type as soon as possible\r\n        setPreviousApduType(OTHER);\r\n        // receive the PIN data\r\n        short byteRead = apdu.setIncomingAndReceive();\r\n        // check Lc\r\n        short lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n        if ((lc != 8) || (byteRead != 8))\r\n            ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n        // do some checks on the new PIN header and data\r\n        if (!isNewPinFormattedCorrectly(buffer, OFFSET_PIN_HEADER))\r\n            ISOException.throwIt(ISO7816.SW_WRONG_DATA);\r\n        // compare the new PIN with the last generated random challenge\r\n        if (!isNewPinCorrectValue(buffer))\r\n            ISOException.throwIt(ISO7816.SW_WRONG_DATA);\r\n        // include header as well in PIN object\r\n        cardholderPin.update(buffer, OFFSET_PIN_HEADER, PIN_SIZE);\r\n        //@ close valid();\r\n        JCSystem.commitTransaction();\r\n    }\r\n    /**\r\n     * check if new PIN conforms to internal format\r\n     * \r\n     * returns false if new PIN is not formatted correctly\r\n     */\r\n    private boolean isNewPinFormattedCorrectly(byte[] buffer, byte offset) \r\n          //@ requires buffer != null \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 offset \u003e= 0 \u0026*\u0026 offset \u003c buffer.length - PIN_SIZE \u0026*\u0026 offset + PIN_SIZE \u003c= Byte.MAX_VALUE;\r\n              //@ ensures array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        // 1st nibble of new PIN header should be 2\r\n        if ((buffer[offset] \u003e\u003e 4) != 2)\r\n            return false;\r\n        // 2nd nibble of new PIN header is the length (in digits)\r\n        //@ and_limits(buffer[offset], 0x0F, nat_of_pos(p1(p1(p1_))));\r\n        byte pinLength = (byte) (buffer[offset] \u0026 0x0F);\r\n        // the new PIN should be between 4 and 12 digits\r\n        if (pinLength \u003c 4 || pinLength \u003e 12)\r\n            return false;\r\n        // divide PIN length by 2 to get the length in bytes\r\n        //@ shr_limits(pinLength, 1, nat_of_pos(p1(p1(p1_))));\r\n        byte pinLengthInBytes = (byte) (pinLength \u003e\u003e 1);\r\n        \r\n        // check if PIN length is odd\r\n        if ((pinLength \u0026 (byte) 0x01) == (byte) 0x01)\r\n            pinLengthInBytes++;\r\n        // check if PIN data is padded with 0xFF\r\n        byte i = (byte) (offset + PIN_SIZE - 1);\r\n        for (; i \u003e offset + pinLengthInBytes; i--) \r\n            /*@ invariant array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 i \u003e= offset + pinLengthInBytes\r\n                \u0026*\u0026 i \u003c= offset + PIN_SIZE - 1;\r\n            @*/\r\n        {\r\n            if (buffer[i] != (byte) 0xFF)\r\n                return false;\r\n        }\r\n        // if PIN length is odd, check if last PIN data nibble is F\r\n        if ((pinLength \u0026 (byte) 0x01) == (byte) 0x01) {\r\n            if (/*@truncating@*/ (byte) (buffer[i] \u003c\u003c 4) != (byte) 0xF0)\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * check if new PIN is based on the last generated random challenge\r\n     */\r\n    private boolean isNewPinCorrectValue(byte[] buffer) \r\n          /*@ requires buffer != null \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer.length \u003e= OFFSET_PIN_DATA + 8\r\n                \u0026*\u0026 randomBuffer |-\u003e ?theRandomBuffer \u0026*\u0026 theRandomBuffer != null \u0026*\u0026 array_slice(theRandomBuffer, 0, theRandomBuffer.length, _) \u0026*\u0026 theRandomBuffer.length == 256;\r\n          @*/\r\n              //@ ensures array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 randomBuffer |-\u003e theRandomBuffer \u0026*\u0026 array_slice(theRandomBuffer, 0, theRandomBuffer.length, _);\r\n    {\r\n        // 2nd nibble of the PIN header is the length (in digits)\r\n        byte tmp = buffer[OFFSET_PIN_HEADER];\r\n        if(tmp \u003c 0) { // BUG\r\n          return false;\r\n        }\r\n        byte pinLength = (byte) (buffer[OFFSET_PIN_HEADER] \u0026 0x0F);\r\n        // check if PIN length is odd\r\n        byte oldLength = (byte) (pinLength \u0026 0x01);\r\n        // divide PIN length by 2 to get the length in bytes\r\n        byte pinLengthInBytes = (byte) (pinLength \u003e\u003e 1);\r\n        //@ assert 0 \u003c= pinLengthInBytes \u0026\u0026 pinLengthInBytes \u003c 8;\r\n        byte i;\r\n        for (i = 0; i \u003c pinLengthInBytes; i++) \r\n            /*@ invariant array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 i \u003e= 0 \u0026*\u0026 i \u003c= pinLengthInBytes \r\n                   \u0026*\u0026 randomBuffer |-\u003e ?theRandomBuffer2 \u0026*\u0026 theRandomBuffer == theRandomBuffer2 \u0026*\u0026 theRandomBuffer2 != null \u0026*\u0026 array_slice(theRandomBuffer2, 0, theRandomBuffer2.length, _) \u0026*\u0026 theRandomBuffer2.length \u003e= pinLengthInBytes;\r\n            @*/\r\n        {\r\n            if (buffer[OFFSET_PIN_DATA + i] != (randomBuffer[i] \u0026 0x77))\r\n                return false;\r\n        }\r\n        if (oldLength == (byte) 0x01) {\r\n            if ((buffer[OFFSET_PIN_DATA + pinLengthInBytes] \u003e\u003e 4) != ((randomBuffer[i] \u0026 0x7F) \u003e\u003e 4))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Discard current fulfilled access conditions\r\n     */\r\n    private void logOff(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        // check P1 and P2\r\n        if (buffer[ISO7816.OFFSET_P1] != (byte) 0x00 || buffer[ISO7816.OFFSET_P2] != (byte) 0x00)\r\n            ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n        // remove previous access conditions:\r\n        JCSystem.beginTransaction();\r\n        //@ open valid();\r\n        setPreviousApduType(OTHER);\r\n        setSignatureType(NO_SIGNATURE);\r\n        cardholderPin.reset();\r\n        resetPin.reset();\r\n        unblockPin.reset();\r\n        activationPin.reset();\r\n        //@ close valid();\r\n        JCSystem.commitTransaction();\r\n    }\r\n    /**\r\n     * unblock card\r\n     */\r\n    private void unblock(APDU apdu, byte[] buffer) \r\n          //@ requires [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        // check P1 and P2\r\n        if (buffer[ISO7816.OFFSET_P1] != (byte) 0x00 || buffer[ISO7816.OFFSET_P2] != (byte) 0x01)\r\n            ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n        // receive the PUK data for validation\r\n        apdu.setIncomingAndReceive();\r\n        // check PUK\r\n        //@ open valid();\r\n        checkPin(unblockPin, buffer);\r\n        // if PUK is correct, then unblock cardholder PINs\r\n        cardholderPin.resetAndUnblock();\r\n        // set the applet status back to personalized\r\n        GPSystem.setCardContentState(GPSystem.CARD_SECURED);\r\n        //@ close [1/2]valid();\r\n    }\r\n    /**\r\n     * prepare for authentication or non repudiation signature\r\n     */\r\n    private void prepareForSignature(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        // check P1 and P2\r\n        if (buffer[ISO7816.OFFSET_P1] != (byte) 0x41 || buffer[ISO7816.OFFSET_P2] != (byte) 0xB6)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n        // receive the data to see which kind of signature\r\n        short byteRead = apdu.setIncomingAndReceive();\r\n        // check Lc\r\n        short lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n        if ((lc != 5) || (byteRead != 5))\r\n            ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n        // the first 2 bytes of the data part should be 0x04 0x80\r\n        // the fourth byte should be 0x84\r\n        if ((buffer[ISO7816.OFFSET_CDATA] != (byte) 0x04) || (buffer[ISO7816.OFFSET_CDATA + 1] != (byte) 0x80) || (buffer[ISO7816.OFFSET_CDATA + 3] != (byte) 0x84))\r\n            ISOException.throwIt(ISO7816.SW_WRONG_DATA);\r\n        // initialize signature object depending on hash function type\r\n        \r\n        JCSystem.beginTransaction();\r\n        //@ open valid();\r\n        switch (buffer[ISO7816.OFFSET_CDATA + 2]) {\r\n        case ALG_SHA1_PKCS1:\r\n            signatureAlgorithm = ALG_SHA1_PKCS1;\r\n            break;\r\n        case ALG_MD5_PKCS1:\r\n            signatureAlgorithm = ALG_MD5_PKCS1;\r\n            break;\r\n        case ALG_PKCS1:\r\n            signatureAlgorithm = ALG_PKCS1;\r\n            break;\r\n        default: // algorithm not supported (SW=9484)\r\n            ISOException.throwIt(SW_ALGORITHM_NOT_SUPPORTED);\r\n            break; //~allow_dead_code\r\n        }\r\n        // signature type is determined by the the last byte\r\n        switch (buffer[ISO7816.OFFSET_CDATA + 4]) {\r\n        case BASIC:\r\n            setSignatureType(BASIC);\r\n            break;\r\n        case AUTHENTICATION: // use authentication private key\r\n            setSignatureType(AUTHENTICATION);\r\n            break;\r\n        case NON_REPUDIATION: // use non repudiation private key\r\n            setSignatureType(NON_REPUDIATION);\r\n            break;\r\n        case CA_ROLE:\r\n            setSignatureType(NO_SIGNATURE);\r\n            ISOException.throwIt(ISO7816.SW_WRONG_DATA);\r\n            break; //~allow_dead_code\r\n        default:\r\n            setSignatureType(NO_SIGNATURE);\r\n            ISOException.throwIt(SW_REFERENCE_DATA_NOT_FOUND);\r\n            break; //~allow_dead_code\r\n        }\r\n        //@ close valid();\r\n        JCSystem.commitTransaction();\r\n    }\r\n    /**\r\n     * generate (authentication or non repudiation) signature\r\n     */\r\n    private void generateSignature(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        /*\r\n         * IMPORTANT: in all other APDUs the previous APDU type gets overwritten\r\n         * in process() function; this is not the case here because the\r\n         * information is needed when processing to verify the security\r\n         * condition for non repudiation signature\r\n         * \r\n         * the previous APDU type has to be overwritten in every possible exit\r\n         * path out of this function; therefore we check the security conditions\r\n         * of the non repudiation signature as early as possible, but we have to\r\n         * overwrite the previous APDU type in the 2 possible exceptions before\r\n         */\r\n        JCSystem.beginTransaction();\r\n        //@ open valid();\r\n        // check P1 and P2        \r\n        if (buffer[ISO7816.OFFSET_P1] != (byte) 0x9E || buffer[ISO7816.OFFSET_P2] != (byte) 0x9A) {\r\n            setPreviousApduType(OTHER);\r\n            ISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n        }\r\n        // generate signature without prepare signature results:\r\n        // \"conditions of use not satisfied\"\r\n        if (getSignatureType() == NO_SIGNATURE) {\r\n            setPreviousApduType(OTHER);\r\n            ISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);\r\n        }\r\n        /*\r\n         * verify authentication information throw\r\n         * \"security condition not satisfied\" if something is wrong\r\n         */\r\n        // check if previous APDU did a cardholder PIN verification\r\n        if ((getSignatureType() == NON_REPUDIATION) \u0026\u0026 (getPreviousApduType() != VERIFY_CARDHOLDER_PIN)) {\r\n            setPreviousApduType(OTHER);\r\n            ISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n        }\r\n        // overwrite previous ADPU type as soon as possible\r\n        setPreviousApduType(OTHER);\r\n\r\n        // it is impossible to generate basic signatures with this command\r\n        if (getSignatureType() == BASIC)\r\n            ISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n        // check if cardholder PIN was entered correctly\r\n        if (!cardholderPin.isValidated())\r\n            ISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n        \r\n        //@ close valid();\r\n        JCSystem.commitTransaction();\r\n        //@ open [1/2]valid();\r\n        switch (signatureAlgorithm) {\r\n        case ALG_MD5_PKCS1:\r\n            //@ close [1/2]valid();\r\n            generatePkcs1Md5Signature(apdu, buffer);\r\n            //@ open [1/2]valid();\r\n            break;\r\n        case ALG_SHA1_PKCS1:\r\n            //@ close [1/2]valid();\r\n            generatePkcs1Sha1Signature(apdu, buffer);\r\n            //@ open [1/2]valid();\r\n            break;\r\n        case ALG_PKCS1:\r\n            //@ close [1/2]valid();\r\n            generatePkcs1Signature(apdu, buffer);\r\n            //@ open [1/2]valid();\r\n            break;\r\n        }\r\n        //@ close [1/2]valid();\r\n        // if T=1, store signature in sigBuffer so that it can latter be sent\r\n        if (APDU.getProtocol() == APDU.PROTOCOL_T1) {\r\n            JCSystem.beginTransaction();\r\n            //@ open valid();\r\n            Util.arrayCopy(buffer, (short) 0, responseBuffer, (short) 0, (short) 128);\r\n            //@ close valid();\r\n            JCSystem.commitTransaction();\r\n            \r\n            // in case T=0 protocol, send the signature immediately in a\r\n            // response APDU\r\n        } else {\r\n            // send first 128 bytes (= 1024 bit) of buffer\r\n            apdu.setOutgoingAndSend((short) 0, (short) 128);\r\n        }\r\n    }\r\n    /**\r\n     * generate PKCS#1 MD5 signature\r\n     */\r\n    private void generatePkcs1Md5Signature(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        // receive the data that needs to be signed\r\n        short byteRead = apdu.setIncomingAndReceive();\r\n        // check Lc\r\n        short lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n        if ((lc != 16) || (byteRead != 16))\r\n            ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n        // use the correct key\r\n        //@ open [1/2]valid();\r\n        \r\n        if (getSignatureType() == NON_REPUDIATION) {        \r\n            cipher.init((RSAPrivateCrtKey)nonRepKeyPair.getPrivate(), Cipher.MODE_ENCRYPT);\r\n        }\r\n        if (getSignatureType() == AUTHENTICATION) {\r\n            cipher.init((RSAPrivateCrtKey)authKeyPair.getPrivate(), Cipher.MODE_ENCRYPT);\r\n        }\r\n        //@ close [1/2]valid();\r\n        JCSystem.beginTransaction();\r\n        \r\n        //@ open valid();\r\n        \r\n        //@ transient_byte_arrays_mem(messageBuffer);\r\n        //@ assert transient_byte_arrays(?as);\r\n        //@ foreachp_remove(messageBuffer, as);\r\n        //@ open transient_byte_array(messageBuffer);\r\n        \r\n        // prepare the message buffer to the PKCS#1 (v1.5) structure\r\n        preparePkcs1ClearText(messageBuffer, ALG_MD5_PKCS1, lc);\r\n        // copy the MD5 hash from the APDU to the message buffer\r\n        Util.arrayCopy(buffer, (short) (ISO7816.OFFSET_CDATA), messageBuffer, (short) (128 - lc), lc);\r\n\r\n        //@ close transient_byte_array(messageBuffer);\r\n        //@ foreachp_unremove(messageBuffer, as);\r\n\r\n        //@ close valid();\r\n        JCSystem.commitTransaction();\r\n        //@ open [1/2]valid();\r\n        // generate signature\r\n        //@ transient_byte_arrays_mem(messageBuffer);\r\n        //@ assert transient_byte_arrays(?as1);\r\n        //@ foreachp_remove(messageBuffer, as1);\r\n        //@ open transient_byte_array(messageBuffer);\r\n        cipher.doFinal(messageBuffer, (short) 0, (short) 128, buffer, (short) 0);\r\n        //@ close transient_byte_array(messageBuffer);\r\n        //@ foreachp_unremove(messageBuffer, as1);\r\n\r\n        //@ close [1/2]valid();\r\n\r\n\r\n    }\r\n    /**\r\n     * generate PKCS#1 SHA1 signature\r\n     */\r\n    private void generatePkcs1Sha1Signature(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        // receive the data that needs to be signed\r\n        short byteRead = apdu.setIncomingAndReceive();\r\n        // check Lc\r\n        \r\n        \r\n        short lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n        if ((lc != 20) || (byteRead != 20))\r\n            ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n        \r\n        \r\n        //@ open [1/2]valid();\r\n        // use the correct key\r\n        if (getSignatureType() == NON_REPUDIATION) {\r\n            ////cipher.init(nonRepPrivateKey, Cipher.MODE_ENCRYPT); // stond al in comments\r\n            cipher.init((RSAPrivateCrtKey)nonRepKeyPair.getPrivate(), Cipher.MODE_ENCRYPT);\r\n        }\r\n        \r\n        if (getSignatureType() == AUTHENTICATION) {\r\n            cipher.init((RSAPrivateCrtKey)authKeyPair.getPrivate(), Cipher.MODE_ENCRYPT);\r\n        }\r\n        \r\n        //@ close [1/2]valid();\r\n        JCSystem.beginTransaction();\r\n        //@ open valid();\r\n        \r\n        //@ transient_byte_arrays_mem(messageBuffer);\r\n        //@ assert transient_byte_arrays(?as);\r\n        //@ foreachp_remove(messageBuffer, as);\r\n        //@ open transient_byte_array(messageBuffer);\r\n\r\n        // prepare the message buffer to the PKCS#1 (v1.5) structure\r\n        preparePkcs1ClearText(messageBuffer, ALG_SHA1_PKCS1, lc);\r\n        // copy the SHA1 hash from the APDU to the message buffer\r\n        Util.arrayCopy(buffer, (short) (ISO7816.OFFSET_CDATA), messageBuffer, (short) (128 - lc), lc);\r\n\r\n        //@ close transient_byte_array(messageBuffer);\r\n        //@ foreachp_unremove(messageBuffer, as);\r\n\r\n        //@ close valid();\r\n        JCSystem.commitTransaction();\r\n        //@ open [1/2]valid();\r\n        // generate signature\r\n        //@ transient_byte_arrays_mem(messageBuffer);\r\n        //@ assert transient_byte_arrays(?as1);\r\n        //@ foreachp_remove(messageBuffer, as1);\r\n        //@ open transient_byte_array(messageBuffer);\r\n        cipher.doFinal(messageBuffer, (short) 0, (short) 128, buffer, (short) 0);\r\n        //@ close transient_byte_array(messageBuffer);\r\n        //@ foreachp_unremove(messageBuffer, as1);\r\n        //@ close [1/2]valid();\r\n    }\r\n    /**\r\n     * generate PKCS#1 signature\r\n     */\r\n    private void generatePkcs1Signature(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        // receive the data that needs to be signed\r\n        short byteRead = apdu.setIncomingAndReceive();\r\n        // check Lc\r\n        //@ positive_and(buffer[ISO7816.OFFSET_LC], 0x00FF);\r\n        short lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n        if ((lc \u003e 117) || (byteRead \u003e 117))\r\n            ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n        // use the correct key\r\n        //@ open [1/2]valid();\r\n        if (getSignatureType() == NON_REPUDIATION) {\r\n            cipher.init((RSAPrivateCrtKey)nonRepKeyPair.getPrivate(), Cipher.MODE_ENCRYPT);\r\n        }\r\n        if (getSignatureType() == AUTHENTICATION) {\r\n            cipher.init((RSAPrivateCrtKey)authKeyPair.getPrivate(), Cipher.MODE_ENCRYPT);\r\n        }\r\n        //@ close [1/2]valid();\r\n        JCSystem.beginTransaction();\r\n        //@ open valid();\r\n\r\n        //@ transient_byte_arrays_mem(messageBuffer);\r\n        //@ assert transient_byte_arrays(?as);\r\n        //@ foreachp_remove(messageBuffer, as);\r\n        //@ open transient_byte_array(messageBuffer);\r\n\r\n        // prepare the message buffer to the PKCS#1 (v1.5) structure\r\n        preparePkcs1ClearText(messageBuffer, ALG_PKCS1, lc);\r\n        // copy the clear text from the APDU to the message buffer\r\n        Util.arrayCopy(buffer, (short) (ISO7816.OFFSET_CDATA), messageBuffer, (short) (128 - lc), lc);\r\n        //@ close transient_byte_array(messageBuffer);\r\n        //@ foreachp_unremove(messageBuffer, as);\r\n\r\n        //@ close valid();\r\n        JCSystem.commitTransaction();\r\n        //@ open [1/2]valid();\r\n        //@ transient_byte_arrays_mem(messageBuffer);\r\n        //@ assert transient_byte_arrays(?as1);\r\n        //@ foreachp_remove(messageBuffer, as1);\r\n        //@ open transient_byte_array(messageBuffer);\r\n        // generate signature\r\n        cipher.doFinal(messageBuffer, (short) 0, (short) 128, buffer, (short) 0);\r\n        //@ close transient_byte_array(messageBuffer);\r\n        //@ foreachp_unremove(messageBuffer, as1);\r\n        //@ close [1/2]valid();\r\n    }\r\n    /**\r\n     * prepare the clear text buffer with correct PKCS#1 encoding\r\n     */\r\n    private void preparePkcs1ClearText(byte[] clearText, short type, short messageLength) \r\n          /*@ requires clearText != null \u0026*\u0026 array_slice(clearText, 0, clearText.length, _) \u0026*\u0026 clearText.length \u003e= 128\r\n              \u0026*\u0026 PKCS1_HEADER |-\u003e ?thePKCS1HEADER \u0026*\u0026 PKCS1_SHA1_HEADER |-\u003e ?thePKCS1SHA1HEADER \u0026*\u0026 PKCS1_MD5_HEADER |-\u003e ?thePKCS1MD5HEADER\r\n              \u0026*\u0026 thePKCS1HEADER != null \u0026*\u0026 thePKCS1SHA1HEADER != null \u0026*\u0026 thePKCS1MD5HEADER != null\r\n              \u0026*\u0026 thePKCS1HEADER.length == 1 \u0026*\u0026 thePKCS1SHA1HEADER.length == 16 \u0026*\u0026 thePKCS1MD5HEADER.length == 19\r\n              \u0026*\u0026 array_slice(thePKCS1HEADER, 0, thePKCS1HEADER.length, _)\r\n              \u0026*\u0026 array_slice(thePKCS1SHA1HEADER, 0, thePKCS1SHA1HEADER.length, _)\r\n              \u0026*\u0026 array_slice(thePKCS1MD5HEADER, 0, thePKCS1MD5HEADER.length, _)\r\n              \u0026*\u0026 messageBuffer |-\u003e ?theMessageBuffer \u0026*\u0026 theMessageBuffer != null \r\n              \u0026*\u0026 messageLength \u003e= 0\r\n              \u0026*\u0026 type == ALG_SHA1_PKCS1 ? messageLength == 20 || messageLength == 22 : type == ALG_MD5_PKCS1 ? messageLength == 16 : messageLength \u003c 126; @*/\r\n              /*@ ensures array_slice(clearText, 0, clearText.length, _) \u0026*\u0026 PKCS1_HEADER |-\u003e thePKCS1HEADER \r\n                      \u0026*\u0026 PKCS1_SHA1_HEADER |-\u003e thePKCS1SHA1HEADER \u0026*\u0026 PKCS1_MD5_HEADER |-\u003e thePKCS1MD5HEADER\r\n              \u0026*\u0026 array_slice(thePKCS1HEADER, 0, thePKCS1HEADER.length, _)\r\n              \u0026*\u0026 array_slice(thePKCS1SHA1HEADER, 0, thePKCS1SHA1HEADER.length, _)\r\n              \u0026*\u0026 array_slice(thePKCS1MD5HEADER, 0, thePKCS1MD5HEADER.length, _)\r\n                      \u0026*\u0026 messageBuffer |-\u003e theMessageBuffer ; @*/\r\n    {\r\n        // first pad the whole clear text with 0xFF\r\n        Util.arrayFillNonAtomic(clearText, (short) 0, (short) 128, (byte) 0xff);\r\n        // first 2 bytes should be 0x00 and 0x01\r\n        Util.arrayFillNonAtomic(clearText, (short) 0, (short) 1, (byte) 0x00);\r\n        Util.arrayFillNonAtomic(clearText, (short) 1, (short) 1, (byte) 0x01);\r\n        // add the PKCS#1 header at the correct location\r\n        byte[] header = PKCS1_HEADER;\r\n        if (type == ALG_SHA1_PKCS1)\r\n            header = PKCS1_SHA1_HEADER;\r\n        if (type == ALG_MD5_PKCS1)\r\n            header = PKCS1_MD5_HEADER;\r\n        Util.arrayCopy(header, (short) 0, clearText, (short) (128 - messageLength - header.length), (short) header.length);\r\n    }\r\n    /**\r\n     * generate a key pair\r\n     * \r\n     * only the private key will be stored in the eid. the get public key method\r\n     * should be called directly after this method, otherwise the public key\r\n     * will be discarded security conditions depend on the key to generate the\r\n     * role R03 (see belgian eid card content) shall be verified for changing\r\n     * authentication or non repudiation keys.\r\n     */\r\n    private void generateKeyPair(APDU apdu) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, ?theBuffer) \u0026*\u0026 array_slice(theBuffer, 0, theBuffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, theBuffer) \u0026*\u0026 array_slice(theBuffer, 0, theBuffer.length, _);\r\n    {\r\n        apdu.setIncomingAndReceive();// If this was removed, function will not\r\n        // work: no data except for command will be read\r\n        byte[] buffer = apdu.getBuffer();\r\n        // check if access to this method is allowed\r\n        if (GPSystem.getCardContentState() != GPSystem.APPLICATION_SELECTABLE)\r\n            ISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n        // check P1 and P2\r\n        if (buffer[ISO7816.OFFSET_P1] != (byte) 0x00)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n        // check Lc\r\n        short lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n        if (lc != (short) 11)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n        byte offset = (ISO7816.OFFSET_CDATA + 0x01);\r\n        //byte offset = (byte)(ISO7816.OFFSET_CDATA + 0x01);\r\n        // create keypair using parameters given:\r\n        // short keyLength = Util.makeShort(buffer[ISO7816.OFFSET_CDATA],\r\n        // buffer[offset]);\r\n        if (buffer[offset] != (byte) 0x80)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n        \r\n        \r\n        \r\n        // This is commented out as changing exponent makes getting modulus\r\n        // impossible on some java cards\r\n        // ((RSAPublicKey)tempkp.getPublic()).setExponent(buffer, (short)(13),\r\n        // (short)3);\r\n        JCSystem.beginTransaction();\r\n        //@ open valid();\r\n        setPreviousApduType(GENERATE_KEY_PAIR);\r\n        switch (buffer[ISO7816.OFFSET_P2]) {\r\n        case BASIC:\r\n            basicKeyPair = new KeyPair(KeyPair.ALG_RSA_CRT, (short) (1024));\r\n            basicKeyPair.genKeyPair();\r\n            \r\n            break;\r\n        case AUTHENTICATION: // use authentication private key\r\n            authKeyPair = new KeyPair(KeyPair.ALG_RSA_CRT, (short) (1024));\r\n            authKeyPair.genKeyPair();\r\n            \r\n            break;\r\n        case NON_REPUDIATION: // use non repudiation private key\r\n            nonRepKeyPair = new KeyPair(KeyPair.ALG_RSA_CRT, (short) (1024));\r\n            nonRepKeyPair.genKeyPair();\r\n            \r\n            break;\r\n        default:\r\n            \r\n            ISOException.throwIt(SW_REFERENCE_DATA_NOT_FOUND);\r\n            break; //~allow_dead_code\r\n        }\r\n        //@ close valid();\r\n        JCSystem.commitTransaction();\r\n    }\r\n    /**\r\n     * get a public key. for the authentication and non-repudiation key, this\r\n     * method can only be called after the generateKeyPair method was called\r\n     * \r\n     */\r\n    private void getPublicKey(APDU apdu) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, ?theBuffer) \u0026*\u0026 array_slice(theBuffer, 0, theBuffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, theBuffer) \u0026*\u0026 array_slice(theBuffer, 0, theBuffer.length, _);\r\n    {\r\n        \r\n        \r\n        byte[] buffer = apdu.getBuffer();\r\n        // if this is thrown: problem accesses getPreviousapdu\r\n        // check P1\r\n        if (buffer[ISO7816.OFFSET_P1] != (byte) 0x00)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n        // inform the JCRE that the applet has data to return\r\n        short le = apdu.setOutgoing();\r\n        // Le = 0 is not allowed\r\n        if (le != (short) (5 + 8 + 128))\r\n            ISOException.throwIt((short) (SW_WRONG_LENGTH_00 + (5 + 8 + 128)));\r\n        byte[] tempBuffer = new byte[le];\r\n        tempBuffer[(short) 0] = (byte) 0x02;\r\n        tempBuffer[(short) 1] = (byte) 0x08;\r\n        tempBuffer[(short) 10] = (byte) 0x03;\r\n        tempBuffer[(short) 11] = (byte) 0x81;\r\n        tempBuffer[(short) 12] = (byte) 0x80;\r\n        //@ open [1/2]valid();\r\n        if (buffer[ISO7816.OFFSET_P2] == AUTHENTICATION){\r\n            if (getPreviousApduType() != GENERATE_KEY_PAIR) {\r\n                authKeyPair.getPublic().clearKey();\r\n                    //@ close [1/2]valid();\r\n                JCSystem.beginTransaction();\r\n                    //@ open valid();\r\n                setPreviousApduType(OTHER);\r\n                    //@ close valid();\r\n                JCSystem.commitTransaction();\r\n                    //@ open [1/2]valid();\r\n                ISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);\r\n            }\r\n            ((RSAPublicKey) authKeyPair.getPublic()).getExponent(tempBuffer, (short) 7);\r\n            ((RSAPublicKey) authKeyPair.getPublic()).getModulus(tempBuffer, (short) 13);\r\n        }else if (buffer[ISO7816.OFFSET_P2] == NON_REPUDIATION) { \r\n            if (getPreviousApduType() != GENERATE_KEY_PAIR) {\r\n                nonRepKeyPair.getPublic().clearKey();\r\n                    //@ close [1/2]valid();\r\n                JCSystem.beginTransaction();\r\n                    //@ open valid();\r\n                setPreviousApduType(OTHER);\r\n                //@ close valid();\r\n                JCSystem.commitTransaction();\r\n                //@ open [1/2]valid();\r\n                ISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);\r\n            }            \r\n            ((RSAPublicKey) nonRepKeyPair.getPublic()).getExponent(tempBuffer, (short) 7);\r\n            ((RSAPublicKey) nonRepKeyPair.getPublic()).getModulus(tempBuffer, (short) 13);\r\n        }else if (buffer[ISO7816.OFFSET_P2] == BASIC) {        \r\n            if (basicKeyPair == null)\r\n                ISOException.throwIt(SW_REFERENCE_DATA_NOT_FOUND);\r\n            ((RSAPublicKey) basicKeyPair.getPublic()).getExponent(tempBuffer, (short) 7);\r\n            ((RSAPublicKey) basicKeyPair.getPublic()).getModulus(tempBuffer, (short) 13);\r\n        } else {\r\n            ISOException.throwIt(SW_REFERENCE_DATA_NOT_FOUND);\r\n        }\r\n            //@ close [1/2]valid();\r\n        JCSystem.beginTransaction();\r\n            //@ open valid();\r\n        setPreviousApduType(OTHER);\r\n        //@ close valid();\r\n        JCSystem.commitTransaction();\r\n        //@ open [1/2]valid();\r\n        authKeyPair.getPublic().clearKey();\r\n        nonRepKeyPair.getPublic().clearKey();\r\n        // set the actual number of outgoing data bytes\r\n        apdu.setOutgoingLength(le);\r\n        // send content of buffer in apdu\r\n        apdu.sendBytesLong(tempBuffer, (short) 0, le);\r\n        //@ close [1/2]valid();\r\n    }\r\n    /**\r\n     * put a public key as commune or role key this is not supported anymore\r\n     */\r\n    private void putPublicKey(APDU apdu, byte[] buffer) \r\n          //@ requires [1/2]valid();\r\n              //@ ensures [1/2]valid();\r\n    {\r\n        ISOException.throwIt(SW_REFERENCE_DATA_NOT_FOUND);\r\n    }\r\n    /**\r\n     * erase a public key (basic, commune or role key) only basic supported\r\n     */\r\n    private void eraseKey(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        // check P1\r\n        if (buffer[ISO7816.OFFSET_P1] != (byte) 0x00)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n        switch (buffer[ISO7816.OFFSET_P2]) {\r\n        case BASIC:\r\n            JCSystem.beginTransaction();\r\n            //@ open valid();\r\n            basicKeyPair = null;\r\n            //@ close valid();\r\n            JCSystem.commitTransaction();\r\n            break;\r\n        default:\r\n            ISOException.throwIt(SW_REFERENCE_DATA_NOT_FOUND);\r\n            break; //~allow_dead_code\r\n        }\r\n    }\r\n    /**\r\n     * activate a public authentication or non repudiation key if deactivated\r\n     * keys in this applet are always active\r\n     */\r\n    private void activateKey(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        // check P1\r\n        if (buffer[ISO7816.OFFSET_P1] != (byte) 0x00)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n        switch (buffer[ISO7816.OFFSET_P2]) {\r\n        case AUTHENTICATION:\r\n            // activate key: key always active, do nothing\r\n            break;\r\n        case NON_REPUDIATION:\r\n            // activate key: key always active, do nothing\r\n            break;\r\n        default:\r\n            ISOException.throwIt(SW_REFERENCE_DATA_NOT_FOUND);\r\n            break; //~allow_dead_code\r\n        }\r\n    }\r\n    /**\r\n     * deactivate a public authentication or non repudiation key if activated as\r\n     * keys are always active, throw exception\r\n     */\r\n    private void deactivateKey(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        ISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);\r\n    }\r\n    /**\r\n     * internal authenticate generates a signature with the basic private key no\r\n     * security conditions needed if used for internal authentication only\r\n     * (Mutual authentication not supported)\r\n     */\r\n    private void internalAuthenticate(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        // check P1 and P2\r\n        if ((buffer[ISO7816.OFFSET_P1] != ALG_SHA1_PKCS1) || buffer[ISO7816.OFFSET_P2] != BASIC)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n        // receive the data that needs to be signed\r\n        short byteRead = apdu.setIncomingAndReceive();\r\n        // check Lc\r\n        short lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n        // we do not support Lc=0x97, only Lc=0x16\r\n        if ((lc == 0x97) || (byteRead == 0x97))\r\n            ISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n        if ((lc != 0x16) || (byteRead != 0x16))\r\n            ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n        // the first data byte must be \"94\" and the second byte is the length\r\n        // (20 bytes)\r\n        if ((buffer[ISO7816.OFFSET_CDATA] != (byte) 0x94) || (buffer[ISO7816.OFFSET_CDATA + 1] != (byte) 0x14))\r\n            ISOException.throwIt(ISO7816.SW_WRONG_DATA);\r\n        // use the basic private key\r\n        JCSystem.beginTransaction();\r\n        //@ open valid();\r\n        \r\n        //@ transient_byte_arrays_mem(messageBuffer);\r\n        //@ assert transient_byte_arrays(?as);\r\n        //@ foreachp_remove(messageBuffer, as);\r\n        //@ open transient_byte_array(messageBuffer);\r\n\r\n        if (basicKeyPair == null)\r\n            ISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);\r\n\r\n        //VF: bovenstaande is mogelijk bug in programma!\r\n        cipher.init(basicKeyPair.getPrivate(), Cipher.MODE_ENCRYPT);\r\n        // prepare the message buffer to the PKCS#1 (v1.5) structure\r\n        preparePkcs1ClearText(messageBuffer, ALG_SHA1_PKCS1, lc);\r\n        // copy the challenge (SHA1 hash) from the APDU to the message buffer\r\n        Util.arrayCopy(buffer, (short) (ISO7816.OFFSET_CDATA + 2), messageBuffer, (short) 108, (short) 20);\r\n        // generate signature\r\n        cipher.doFinal(messageBuffer, (short) 0, (short) 128, buffer, (short) 0);\r\n        // if T=0, store signature in sigBuffer so that it can latter be sent\r\n        if (APDU.getProtocol() == APDU.PROTOCOL_T1) {\r\n            Util.arrayCopy(buffer, (short) 0, responseBuffer, (short) 0, (short) 128);\r\n            // in case T=1 protocol, send the signature immediately in a\r\n            // response APDU\r\n        } else {\r\n            // send first 128 bytes (= 1024 bit) of buffer\r\n            apdu.setOutgoingAndSend((short) 0, (short) 128);\r\n        }\r\n        // decrement internal authenticate counter\r\n        //internalAuthenticateCounter--;\r\n        //@ close transient_byte_array(messageBuffer);\r\n        //@ foreachp_unremove(messageBuffer, as);\r\n        \r\n        //@ close valid();\r\n        JCSystem.commitTransaction();\r\n    }\r\n    /**\r\n     * return the generated signature in a response APDU Used in T=0 protocol\r\n     */\r\n    private void getResponse(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        //@ open [1/2]valid();\r\n        // use P1 and P2 as offset\r\n        short offset = Util.makeShort(buffer[ISO7816.OFFSET_P1], buffer[ISO7816.OFFSET_P2]);\r\n        if (offset \u003e responseBuffer.length)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n        // inform the JCRE that the applet has data to return\r\n        short le = apdu.setOutgoing();\r\n        // if Le = 0, then return the complete signature (128 bytes = 1024 bits)\r\n        // Le = 256 possible on real card\r\n        if ((le == 0) || (le == 256))\r\n            le = 128;\r\n        // set the actual number of outgoing data bytes\r\n        apdu.setOutgoingLength(le);\r\n        // send content of sigBuffer in apdu\r\n        if ((short) (offset + le) \u003e (short)128 || offset \u003c (short)0)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n        apdu.sendBytesLong(responseBuffer, offset, le);\r\n        //@ close [1/2]valid();\r\n    }\r\n    /**\r\n     * generate a random challenge\r\n     */\r\n    private void getChallenge(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        // check P1 and P2\r\n        if (buffer[ISO7816.OFFSET_P1] != (byte) 0x00 || buffer[ISO7816.OFFSET_P2] != (byte) 0x00)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n        // inform the JCRE that the applet has data to return\r\n        short le = apdu.setOutgoing();\r\n        // Le = 0 is not allowed\r\n        if (le == 0)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n        JCSystem.beginTransaction();\r\n        //@ open valid();\r\n        RandomData random = NewEidCard.randomData;\r\n        // generate random data and put it into buffer\r\n        random.generateData(randomBuffer, (short) 0, le);\r\n        // set the actual number of outgoing data bytes\r\n        apdu.setOutgoingLength(le);\r\n        // send content of buffer in apdu\r\n        apdu.sendBytesLong(randomBuffer, (short) 0, le);\r\n        //@ close valid();\r\n        JCSystem.commitTransaction();\r\n    }\r\n    /**\r\n     * select a file on the eID card\r\n     * \r\n     * this file can latter be read by a READ BINARY\r\n     */\r\n    private void selectFile(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        // check P2\r\n        if (buffer[ISO7816.OFFSET_P2] != (byte) 0x0C)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n        // P1 determines the select method\r\n        switch (buffer[ISO7816.OFFSET_P1]) {\r\n        case (byte) 0x02:\r\n            selectByFileIdentifier(apdu, buffer);\r\n            break;\r\n        case (byte) 0x08:\r\n            selectByPath(apdu, buffer);\r\n            break;\r\n        default:\r\n            ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n            break; //~allow_dead_code\r\n        }\r\n    }\r\n    /**\r\n     * set the previous APDU type to a certain value\r\n     */\r\n    private void setPreviousApduType(byte type) \r\n          //@ requires previousApduType |-\u003e ?thePreviousApduType \u0026*\u0026 thePreviousApduType != null \u0026*\u0026 thePreviousApduType.length == 1 \u0026*\u0026 is_transient_byte_array(thePreviousApduType) == true \u0026*\u0026 transient_byte_arrays(?ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r\n              //@ ensures previousApduType |-\u003e thePreviousApduType \u0026*\u0026 thePreviousApduType != null \u0026*\u0026 transient_byte_arrays(ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r\n    {\r\n        //@ transient_byte_arrays_mem(thePreviousApduType);\r\n        //@ foreachp_remove(thePreviousApduType, ta);\r\n        //@ open transient_byte_array(thePreviousApduType);\r\n        previousApduType[0] = type;\r\n        //@ close transient_byte_array(thePreviousApduType);\r\n        //@ foreachp_unremove(thePreviousApduType, ta);\r\n    }\r\n    /**\r\n     * return the previous APDU type\r\n     */\r\n    private byte getPreviousApduType() \r\n          //@ requires [?f]previousApduType |-\u003e ?thePreviousApduType \u0026*\u0026 thePreviousApduType != null \u0026*\u0026 thePreviousApduType.length == 1 \u0026*\u0026 is_transient_byte_array(thePreviousApduType) == true \u0026*\u0026 transient_byte_arrays(?ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r\n          //@ ensures [f]previousApduType |-\u003e thePreviousApduType \u0026*\u0026 transient_byte_arrays(ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r\n    {\r\n        //@ transient_byte_arrays_mem(thePreviousApduType);\r\n        //@ foreachp_remove(thePreviousApduType, ta);\r\n        //@ open transient_byte_array(thePreviousApduType);\r\n        return previousApduType[0];\r\n        //@ close transient_byte_array(thePreviousApduType);\r\n        //@ foreachp_unremove(thePreviousApduType, ta);\r\n    }\r\n    /**\r\n     * set the signature type to a certain value\r\n     */\r\n    private void setSignatureType(byte type) \r\n          //@ requires signatureType |-\u003e ?theSignatureType \u0026*\u0026 theSignatureType != null \u0026*\u0026 theSignatureType.length == 1 \u0026*\u0026 is_transient_byte_array(theSignatureType) == true \u0026*\u0026 transient_byte_arrays(?ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r\n              //@ ensures signatureType |-\u003e theSignatureType \u0026*\u0026 is_transient_byte_array(theSignatureType) == true \u0026*\u0026 transient_byte_arrays(ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r\n    {\r\n        //@ transient_byte_arrays_mem(theSignatureType);\r\n        //@ foreachp_remove(theSignatureType, ta);\r\n        //@ open transient_byte_array(theSignatureType);\r\n        signatureType[0] = type;\r\n        //@ close transient_byte_array(theSignatureType);\r\n        //@ foreachp_unremove(theSignatureType, ta);\r\n    }\r\n    /**\r\n     * return the signature type\r\n     */\r\n    private byte getSignatureType() \r\n          //@ requires [?f]signatureType |-\u003e ?theSignatureType \u0026*\u0026 theSignatureType != null \u0026*\u0026 theSignatureType.length == 1 \u0026*\u0026 is_transient_byte_array(theSignatureType) == true \u0026*\u0026 transient_byte_arrays(?ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r\n              //@ ensures [f]signatureType |-\u003e theSignatureType \u0026*\u0026 transient_byte_arrays(ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r\n    {\r\n        //@ transient_byte_arrays_mem(theSignatureType);\r\n        //@ foreachp_remove(theSignatureType, ta);\r\n        //@ open transient_byte_array(theSignatureType);\r\n        return signatureType[0];\r\n        //@ close transient_byte_array(theSignatureType);\r\n        //@ foreachp_unremove(theSignatureType, ta);\r\n    }\r\n    \r\n\r\n    /**\r\n     * deactivate a file on the eID card security conditions depend on file to\r\n     * activate: see belgian eID content file\r\n     */\r\n    private void deactivateFile(APDU apdu, byte[] buffer) \r\n          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        // check P2\r\n        if (buffer[ISO7816.OFFSET_P2] != (byte) 0x0C)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n        // P1 determines the select method\r\n        switch (buffer[ISO7816.OFFSET_P1]) {\r\n        case (byte) 0x02:\r\n            selectByFileIdentifier(apdu, buffer);\r\n            break;\r\n        case (byte) 0x08:\r\n            selectByPath(apdu, buffer);\r\n            break;\r\n        default:\r\n            ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n            break; //~allow_dead_code\r\n        }\r\n        // check if deactivating this file is allowed\r\n        if (!fileAccessAllowed(UPDATE_BINARY))\r\n            ISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n        JCSystem.beginTransaction();\r\n        //@ open valid();\r\n          //@ open selected_file_types(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, ?sf2);\r\n        //@ sf2.castElementaryToFile();\r\n        selectedFile.setActive(false);\r\n        //@ sf2.castFileToElementary();\r\n        //@ close valid();\r\n        JCSystem.commitTransaction();\r\n    }\r\n    \r\n    public Shareable getShareableInterfaceObject(AID oAid, byte bArg)\r\n        //@ requires [1/2]this.valid() \u0026*\u0026 registered_applets(?as) \u0026*\u0026 foreachp(remove\u003cApplet\u003e(this, as), semi_valid) \u0026*\u0026 mem\u003cApplet\u003e(this, as) == true \u0026*\u0026 AID(oAid);\r\n        //@ ensures [1/2]this.valid() \u0026*\u0026 registered_applets(as) \u0026*\u0026 foreachp(remove\u003cApplet\u003e(this, as), semi_valid) \u0026*\u0026 AID(oAid) \u0026*\u0026 result == null ? true : result.Shareable(?a) \u0026*\u0026 mem\u003cApplet\u003e(a, as) == true;\r\n    {\r\n        \r\n        //check if AID is allowed\r\n        //@ NewEidPointsObject.getShareable();\r\n        \r\n        if (bArg == (byte)0x0) // Based on argument, return\r\n                                                // object reference\r\n            return (Shareable) (NewEidPointsObject);\r\n\r\n            else \r\n                ISOException.throwIt(ISO7816.SW_WRONG_DATA);\r\n        \r\n        return null; //~allow_dead_code\r\n    }    \r\n    \r\n    private void askForCharge()\r\n        //@ requires current_applet(this) \u0026*\u0026 [1/2]valid();\r\n        //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid();\r\n    {\r\n                AID Purse_AID = JCSystem.lookupAID(NewEPurseAID,(short)0, (byte)NewEPurseAID.length);\r\n        \r\n        if (Purse_AID == null)\r\n            ISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);\r\n        \r\n        JCSystem.beginTransaction(); // Added for VeriFast\r\n        IEPurseServicesCredit NewEPurseCreditObject = (IEPurseServicesCredit)\r\n            (JCSystem.getAppletShareableInterfaceObject(Purse_AID, (byte)0x01));\r\n        short points = Points;\r\n        if (NewEPurseCreditObject != null) {\r\n\t    //@ Shareable epurseServiceSIO = NewEPurseCreditObject;\r\n\t    //@ assert epurseServiceSIO.Shareable(?epurseApplet);\r\n\t    //@ mem_registered_applets_is(this);\r\n\t    //@ assert registered_applets(?as1);\r\n\t    //@ foreachp_unremove\u003cApplet\u003e(this, as1);\r\n\t    //@ set_current_applet(epurseApplet);\r\n\t    //@ foreachp_remove(epurseApplet, as1);\r\n            NewEPurseCreditObject.charge(points);\r\n            //@ is_registered_applets_mem(this);\r\n            //@ assert registered_applets(?as2);\r\n            //@ foreachp_unremove(epurseApplet, as2);\r\n            //@ set_current_applet(this);\r\n            //@ foreachp_remove\u003cApplet\u003e(this, as2);\r\n        }\r\n        JCSystem.commitTransaction(); // Added for VeriFast\r\n        \r\n    }\r\n}\r\n",
        "name": "NewEidCard.java",
        "path": "examples/java/Java Card/NewEidCard/NewEidCard.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/NewEidCard/NewEidCard.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 369,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires class_init_token(NewEidCard.class) \u0026*\u0026 system();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 370,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 466,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 467,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 491,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 492,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 538,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires [?f]selectedFile |-\u003e ?theSelectedFile \u0026*\u0026 [f]this.preferencesFile |-\u003e ?thePreferencesFile \u0026*\u0026 [f]this.cardholderPin |-\u003e ?theCardHolderPin \u0026*\u0026 theCardHolderPin != null \u0026*\u0026 [f]OwnerPIN(theCardHolderPin, _, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 539,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures [f]selectedFile |-\u003e theSelectedFile \u0026*\u0026 [f]this.preferencesFile |-\u003e thePreferencesFile \u0026*\u0026 [f]this.cardholderPin |-\u003e theCardHolderPin \u0026*\u0026 [f]OwnerPIN(theCardHolderPin, _, _) \u0026*\u0026 theSelectedFile instanceof ElementaryFile;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 568,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 569,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 642,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 643,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 701,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 702,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 748,
          "offsetAndLengths": [
            [
              12,
              13
            ]
          ],
          "preview": "            //@ requires current_applet(this) \u0026*\u0026 [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 749,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 817,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires nonRepKeyPair |-\u003e _ \u0026*\u0026 authKeyPair |-\u003e _ \u0026*\u0026 basicKeyPair |-\u003e _;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 852,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 853,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 906,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 907,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1110,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1161,
          "offsetAndLengths": [
            [
              12,
              13
            ]
          ],
          "preview": "            //@ requires current_applet(this) \u0026*\u0026 [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1162,
          "offsetAndLengths": [
            [
              12,
              12
            ]
          ],
          "preview": "            //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1172,
          "offsetAndLengths": [
            [
              12,
              13
            ]
          ],
          "preview": "            //@ requires current_applet(this) \u0026*\u0026 [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1173,
          "offsetAndLengths": [
            [
              12,
              12
            ]
          ],
          "preview": "            //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1182,
          "offsetAndLengths": [
            [
              12,
              13
            ]
          ],
          "preview": "            //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, ?buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1183,
          "offsetAndLengths": [
            [
              12,
              12
            ]
          ],
          "preview": "            //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1311,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1312,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1360,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires [1/2]cardholderPin |-\u003e ?theCardholderPin \u0026*\u0026 [1/2]OwnerPIN(pin, _, _) \u0026*\u0026 pin != null \u0026*\u0026 buffer != null \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer.length \u003e= 13;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1361,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures [1/2]cardholderPin |-\u003e theCardholderPin \u0026*\u0026 [1/2]OwnerPIN(pin, _, _) \u0026*\u0026 pin != null \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer != null \u0026*\u0026 buffer.length \u003e= 13;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1386,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1387,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1431,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer.length \u003e OFFSET_SECOND_PIN_HEADER + PIN_SIZE;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1432,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer.length \u003e OFFSET_SECOND_PIN_HEADER + PIN_SIZE;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1457,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1458,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1499,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires buffer != null \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 offset \u003e= 0 \u0026*\u0026 offset \u003c buffer.length - PIN_SIZE \u0026*\u0026 offset + PIN_SIZE \u003c= Byte.MAX_VALUE;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1500,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1542,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 randomBuffer |-\u003e theRandomBuffer \u0026*\u0026 array_slice(theRandomBuffer, 0, theRandomBuffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1574,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1575,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1596,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1597,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1617,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1618,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1678,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1679,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1764,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1765,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1820,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1821,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1878,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1879,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1969,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, ?theBuffer) \u0026*\u0026 array_slice(theBuffer, 0, theBuffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1970,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, theBuffer) \u0026*\u0026 array_slice(theBuffer, 0, theBuffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2032,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, ?theBuffer) \u0026*\u0026 array_slice(theBuffer, 0, theBuffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2033,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, theBuffer) \u0026*\u0026 array_slice(theBuffer, 0, theBuffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2109,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2110,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2118,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2119,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2142,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2143,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2165,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2166,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2176,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2177,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2236,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2237,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2262,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2263,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2291,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2292,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2314,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires previousApduType |-\u003e ?thePreviousApduType \u0026*\u0026 thePreviousApduType != null \u0026*\u0026 thePreviousApduType.length == 1 \u0026*\u0026 is_transient_byte_array(thePreviousApduType) == true \u0026*\u0026 transient_byte_arrays(?ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2315,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures previousApduType |-\u003e thePreviousApduType \u0026*\u0026 thePreviousApduType != null \u0026*\u0026 transient_byte_arrays(ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2328,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires [?f]previousApduType |-\u003e ?thePreviousApduType \u0026*\u0026 thePreviousApduType != null \u0026*\u0026 thePreviousApduType.length == 1 \u0026*\u0026 is_transient_byte_array(thePreviousApduType) == true \u0026*\u0026 transient_byte_arrays(?ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2329,
          "offsetAndLengths": [
            [
              10,
              12
            ]
          ],
          "preview": "          //@ ensures [f]previousApduType |-\u003e thePreviousApduType \u0026*\u0026 transient_byte_arrays(ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2342,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires signatureType |-\u003e ?theSignatureType \u0026*\u0026 theSignatureType != null \u0026*\u0026 theSignatureType.length == 1 \u0026*\u0026 is_transient_byte_array(theSignatureType) == true \u0026*\u0026 transient_byte_arrays(?ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2343,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures signatureType |-\u003e theSignatureType \u0026*\u0026 is_transient_byte_array(theSignatureType) == true \u0026*\u0026 transient_byte_arrays(ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2356,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires [?f]signatureType |-\u003e ?theSignatureType \u0026*\u0026 theSignatureType != null \u0026*\u0026 theSignatureType.length == 1 \u0026*\u0026 is_transient_byte_array(theSignatureType) == true \u0026*\u0026 transient_byte_arrays(?ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2357,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures [f]signatureType |-\u003e theSignatureType \u0026*\u0026 transient_byte_arrays(ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2373,
          "offsetAndLengths": [
            [
              10,
              13
            ]
          ],
          "preview": "          //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2374,
          "offsetAndLengths": [
            [
              14,
              12
            ]
          ],
          "preview": "              //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2405,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [1/2]this.valid() \u0026*\u0026 registered_applets(?as) \u0026*\u0026 foreachp(remove\u003cApplet\u003e(this, as), semi_valid) \u0026*\u0026 mem\u003cApplet\u003e(this, as) == true \u0026*\u0026 AID(oAid);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2406,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [1/2]this.valid() \u0026*\u0026 registered_applets(as) \u0026*\u0026 foreachp(remove\u003cApplet\u003e(this, as), semi_valid) \u0026*\u0026 AID(oAid) \u0026*\u0026 result == null ? true : result.Shareable(?a) \u0026*\u0026 mem\u003cApplet\u003e(a, as) == true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2423,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires current_applet(this) \u0026*\u0026 [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2424,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid();\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package be.fedict.neweidapplet;\r\n\r\npublic /*VF*ADDED*/final class MasterFile extends DedicatedFile {\r\n\t//@ predicate File(short theFileID, boolean activeState, triple\u003cDedicatedFile, list\u003cFile\u003e, any\u003e info) = MasterFile(theFileID, ?dedFile, activeState, ?siblist, ?oinfo) \u0026*\u0026 info == triple(dedFile, siblist, oinfo);\r\n\t//@ predicate DedicatedFile(short fileID, DedicatedFile parentFile, boolean activeState, list\u003cFile\u003e siblist, any info) = MasterFile(fileID, parentFile, activeState, siblist, info);\r\n\t//@ predicate MasterFile(short fileID, DedicatedFile parentFile, boolean activeState, list\u003cFile\u003e siblist, any info) = this.DedicatedFile(DedicatedFile.class)(fileID, parentFile, activeState, siblist, _) \u0026*\u0026 fileID == 0x3F00 \u0026*\u0026 parentFile == null \u0026*\u0026 info == unit;\r\n\r\n\tprivate static final short MF_FID = 0x3F00;\r\n\tpublic MasterFile() \r\n  \t    //@ requires true;\r\n      \t    //@ ensures this.MasterFile(0x3F00, null, true, nil, _);\r\n\t{\r\n\t\tsuper(MF_FID);\r\n\t\t//@ close MasterFile(0x3F00, null, true, _, _);\r\n\t}\r\n\t\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic DedicatedFile getParent() \r\n\t    //@ requires DedicatedFile(?fid, ?parentfile, ?active, ?siblist, ?info);\r\n\t    //@ ensures DedicatedFile(fid, parentfile, active, siblist, info) \u0026*\u0026 result == parentfile;\r\n\t{\r\n\t\t//@ open DedicatedFile(fid, parentfile, active, siblist, info);\r\n\t\t//@ open MasterFile(fid, parentfile, active, siblist, ?info2);\r\n\t\t//@ open this.DedicatedFile(DedicatedFile.class)(fid, parentfile, active, siblist, ?info3);\r\n\t\treturn parentFile;\r\n\t\t//@ close this.DedicatedFile(DedicatedFile.class)(fid, parentfile, active, siblist, info3);\r\n\t\t//@ close MasterFile(fid, parentfile, active, siblist, info2);\r\n\t\t//@ close DedicatedFile(fid, parentfile, active, siblist, info);\r\n\t}\r\n\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic File getSibling(short fid) \r\n  \t    //@ requires [?f]DedicatedFile(?fileID, ?parentFile, ?activeState, ?siblist, ?info);\r\n      \t    //@ ensures [f]DedicatedFile(fileID, parentFile, activeState, siblist, info) \u0026*\u0026 result == null ? true : mem(result, siblist) == true;\r\n\t{\r\n\t\t//@ open [f]DedicatedFile(fileID, parentFile, activeState, siblist, info);\r\n\t\t//@ open [f]MasterFile(fileID, parentFile, activeState, siblist, info);\r\n\t\treturn super.getSibling(fid);\r\n\t\t//@ close [f]MasterFile(fileID, parentFile, activeState, siblist, info);\r\n\t\t//@ close [f]DedicatedFile(fileID, parentFile, activeState, siblist, info);\r\n\t}\r\n\t\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic short getFileID() \r\n\t    //@ requires [?f]valid_id(this);\r\n\t    //@ ensures [f]valid_id(this);\r\n\t{\r\n\t\t//@ open [f]valid_id(this);\r\n\t\treturn fileID;\r\n\t\t//@ close [f]valid_id(this);\r\n\t}\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic void setActive(boolean b)\r\n\t    //@ requires File(?fid, _, ?info);\r\n\t    //@ ensures File(fid, b, info);\r\n\t{\r\n\t\t//@ open File(fid, _, info);\r\n\t\t//@ open MasterFile(fid, ?d0, _, ?d1, ?info2);\r\n\t\t//@ open this.DedicatedFile(DedicatedFile.class)(fid, null, _, d1, ?info3);\r\n\t\t//@ open this.File(File.class)(fid, _, ?info4);\r\n\t\tactive = b;\r\n\t\t//@ close this.File(File.class)(fid, b, info4);\r\n\t\t//@ close this.DedicatedFile(DedicatedFile.class)(fid, null, b, d1, info3);\r\n\t\t//@ close MasterFile(fid, null, b, d1, info2);\r\n\t\t//@ close File(fid, b, info);\r\n\t}\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic boolean isActive() \r\n\t    //@ requires [?f]File(?fid, ?state, ?info);\r\n\t    //@ ensures [f]File(fid, state, info) \u0026*\u0026 result == state;\r\n\t{\r\n\t\t//@ open [f]File(fid, state, info);\r\n\t\t//@ open [f]MasterFile(fid, ?d0, state, ?d1, ?info2);\r\n\t\t//@ open [f]this.DedicatedFile(DedicatedFile.class)(fid, null, state, d1, ?info3);\r\n\t\t//@ open [f]this.File(File.class)(fid, state, ?info4);\r\n\t\treturn active;\r\n\t\t//@ close [f]this.File(File.class)(fid, state, info4);\r\n\t\t//@ close [f]this.DedicatedFile(DedicatedFile.class)(fid, null, state, d1, info3);\r\n\t\t//@ close [f]MasterFile(fid, null, state, d1, info2);\r\n\t\t//@ close [f]File(fid, state, info);\r\n\t}\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tprotected void addSibling(File s) \r\n  \t    //@ requires DedicatedFile(?fileID, ?parentFile, ?activeState, ?siblist, ?info) \u0026*\u0026 valid_id(s);\r\n  \t    /*@ ensures DedicatedFile(fileID, parentFile, activeState, ?newSibList, info)\r\n  \t    \t\t\u0026*\u0026 newSibList == (length(siblist) \u003c MAX_SIBLINGS ? append(siblist, cons(s, nil)) : siblist)\r\n  \t    \t\t\u0026*\u0026 length(siblist) \u003c MAX_SIBLINGS ? mem(s, newSibList) == true : true; @*/\r\n \t{\r\n\t\t\r\n\t\t//@ open DedicatedFile(fileID, parentFile, activeState, siblist, info);\r\n\t\t//@ open MasterFile(fileID, parentFile, activeState, siblist, ?info2);\r\n\t\tsuper.addSibling(s);\r\n\t\t//@ close MasterFile(fileID, parentFile, activeState, (length(siblist) \u003c MAX_SIBLINGS ? append(siblist, cons(s, nil)) : siblist), info2);\r\n\t\t//@ close DedicatedFile(fileID, parentFile, activeState, (length(siblist) \u003c MAX_SIBLINGS ? append(siblist, cons(s, nil)) : siblist), info);\r\n\t}\r\n\t\r\n\t/*@ lemma void castFileToMaster()\r\n            requires [?f]File(?fid, ?state, ?info);\r\n            ensures switch (info) { case triple(dedFile, siblist, oinfo): return [f]MasterFile(fid, dedFile, state, siblist, oinfo); } ;\r\n\t{\r\n\t    open [f]File(fid, state, _);\r\n    \t}\r\n\r\n\tlemma void castMasterToFile()\r\n            requires [?f]MasterFile(?fid, ?dedFile, ?state, ?siblist, ?oinfo);\r\n            ensures [f]File(fid, state, triple(dedFile, siblist, oinfo));\r\n\t{\r\n\t    close [f]File(fid, state, triple(dedFile, siblist, oinfo));\r\n    \t}\r\n\r\n\tlemma void castMasterToDedicated()\r\n            requires [?f]MasterFile(?fid, ?dedFile, ?state, ?siblist, ?oinfo);\r\n            ensures [f]DedicatedFile(fid, dedFile, state, siblist, oinfo);\r\n\t{\r\n\t    close [f]DedicatedFile(fid, dedFile, state, siblist, oinfo);\r\n    \t}\r\n\r\n\tlemma void castDedicatedToMaster()\r\n            requires [?f]DedicatedFile(?fid, ?dedFile, ?state, ?siblist, ?oinfo);\r\n            ensures [f]MasterFile(fid, dedFile, state, siblist, oinfo);\r\n\t{\r\n\t    open [f]DedicatedFile(fid, dedFile, state, siblist, oinfo);\r\n    \t}\r\n\r\n\tlemma void castFileToDedicated()\r\n            requires [?f]File(?fid, ?state, ?info);\r\n            ensures switch (info) { case triple(dedFile, siblist, oinfo): return [f]DedicatedFile(fid, dedFile, state, siblist, oinfo); } ;\r\n\t{\r\n\t    open [f]File(fid, state, _);\r\n\t    close [f]DedicatedFile(fid, _, _, _, _);\r\n    \t}\r\n\r\n\tlemma void castDedicatedToFile()\r\n            requires [?f]DedicatedFile(?fid, ?dedFile, ?state, ?siblist, ?oinfo);\r\n            ensures [f]File(fid, state, triple(dedFile, siblist, oinfo));\r\n\t{\r\n   \t    open [f]DedicatedFile(fid, _, _, _, _);\r\n\t    close [f]File(fid, state, triple(dedFile, siblist, oinfo));\r\n    \t}\r\n    \t@*/\r\n}\r\n",
        "name": "MasterFile.java",
        "path": "examples/java/Java Card/NewEidCard/MasterFile.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/NewEidCard/MasterFile.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures this.MasterFile(0x3F00, null, true, nil, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 18,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires DedicatedFile(?fid, ?parentfile, ?active, ?siblist, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 19,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures DedicatedFile(fid, parentfile, active, siblist, info) \u0026*\u0026 result == parentfile;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 32,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires [?f]DedicatedFile(?fileID, ?parentFile, ?activeState, ?siblist, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 33,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures [f]DedicatedFile(fileID, parentFile, activeState, siblist, info) \u0026*\u0026 result == null ? true : mem(result, siblist) == true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 44,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires [?f]valid_id(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 45,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures [f]valid_id(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 53,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires File(?fid, _, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 54,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures File(fid, b, info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 68,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires [?f]File(?fid, ?state, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 69,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures [f]File(fid, state, info) \u0026*\u0026 result == state;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 83,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires DedicatedFile(?fileID, ?parentFile, ?activeState, ?siblist, ?info) \u0026*\u0026 valid_id(s);\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class LocalClass\n{\n  public static void main(String[] args)\n    //@ requires true;\n    //@ ensures true; \n  {\n    class InnerClass\n    {\n      //@ predicate LocalClass$InnerClass(int x) = this.x |-\u003e x;\n      \n      int x = 1;\n      \n      InnerClass()\n      //@ requires true;\n      //@ ensures  LocalClass$InnerClass(1);\n      {\n        //@ close LocalClass$InnerClass(1);\n      }\n        \n      int getX()    \n        //@ requires LocalClass$InnerClass(?x);\n        //@ ensures LocalClass$InnerClass(x) \u0026*\u0026 result == x;\n      {\n        //@ open LocalClass$InnerClass(x);\n        return this.x;\n      }\n        \n      void setX(int i)    \n        //@ requires LocalClass$InnerClass(_);\n        //@ ensures LocalClass$InnerClass(i);\n      {\n        x = i;\n      }\n    }  \n  \n    InnerClass first = new InnerClass();\n    \n    //Non-static stuff\n    first.setX(111);\n    int i = first.getX();\n    //@ assert i == 111;\n }\n}",
        "name": "LocalClass.java",
        "path": "examples/java/frontend/inner_class/LocalClass.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/inner_class/LocalClass.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true; "
        },
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              6,
              13
            ]
          ],
          "preview": "      //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires LocalClass$InnerClass(?x);"
        },
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures LocalClass$InnerClass(x) \u0026*\u0026 result == x;"
        },
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires LocalClass$InnerClass(_);"
        },
        {
          "limitHit": false,
          "lineNumber": 29,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures LocalClass$InnerClass(i);"
        },
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              6,
              12
            ]
          ],
          "preview": "      //@ ensures  LocalClass$InnerClass(1);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "/*@\r\n\r\ninductive value = K0 | K1(value) | S0 | S1(value) | S2(value, value);\r\n\r\ninductive term = val(value) | app(term, term);\r\n\r\nfixpoint term apply(value f, value v) {\r\n    switch (f) {\r\n        case K0: return val(K1(v));\r\n        case K1(v0): return val(v0);\r\n        case S0: return val(S1(v));\r\n        case S1(v0): return val(S2(v0, v));\r\n        case S2(v0, v1): return app(app(val(v0), val(v)), app(val(v1), val(v)));\r\n    }\r\n}\r\n\r\nfixpoint term step(term t) {\r\n    switch (t) {\r\n        case val(v): return t;\r\n        case app(t1, t2): return switch (t1) {\r\n            case val(v1): return switch (t2) {\r\n                case val(v2): return apply(v1, v2);\r\n                default: return app(t1, step(t2));\r\n            };\r\n            default: return app(step(t1), t2);\r\n        };\r\n    }\r\n}\r\n\r\npredicate reduces_to(term t1, term t2) =\r\n    t1 == t2 ? true : [_]reduces_to(step(t1), t2);\r\n\r\nlemma void reduces_to_val(term t1, term t2)\r\n    requires [_]reduces_to(t1, t2);\r\n    ensures t1 == t2 ? true : t1 == app(_, _);\r\n{\r\n    open reduces_to(t1, t2);\r\n    if (t1 == t2) {\r\n    } else {\r\n        switch (t1) { case val(v): case app(t11, t12): }\r\n        reduces_to_val(step(t1), t2);\r\n    }\r\n}\r\n\r\n// Lemmas that enable a recursive implementation\r\n\r\nlemma void reduces_to_app_l(term t10, term t11, term t2)\r\n    requires [_]reduces_to(t10, t11);\r\n    ensures [_]reduces_to(app(t10, t2), app(t11, t2));\r\n{\r\n    open reduces_to(t10, t11);\r\n    if (t10 == t11) {\r\n    } else {\r\n        reduces_to_app_l(step(t10), t11, t2);\r\n        reduces_to_val(t10, t11);\r\n    }\r\n    close reduces_to(app(t10, t2), app(t11, t2));\r\n}\r\n\r\nlemma void reduces_to_app_r(value v, term t1, term t2)\r\n    requires [_]reduces_to(t1, t2);\r\n    ensures [_]reduces_to(app(val(v), t1), app(val(v), t2));\r\n{\r\n    open reduces_to(_, _);\r\n    if (t1 == t2) {\r\n    } else {\r\n        reduces_to_app_r(v, step(t1), t2);\r\n        reduces_to_val(t1, t2);\r\n    }\r\n    close reduces_to(app(val(v), t1), app(val(v), t2));\r\n}\r\n\r\nlemma void reduces_to_trans(term t1, term t2, term t3)\r\n    requires [_]reduces_to(t1, t2) \u0026*\u0026 [_]reduces_to(t2, t3);\r\n    ensures [_]reduces_to(t1, t3);\r\n{\r\n    open reduces_to(t1, t2);\r\n    if (t1 == t2) {\r\n    } else {\r\n        reduces_to_trans(step(t1), t2, t3);\r\n        close reduces_to(t1, t3);\r\n    }\r\n}\r\n\r\n@*/\r\n\r\nfinal class Term {\r\n    static final int tagAPP = 0;\r\n    static final int tagK0 = 1;\r\n    static final int tagK1 = 2;\r\n    static final int tagS0 = 3;\r\n    static final int tagS1 = 4;\r\n    static final int tagS2 = 5;\r\n    \r\n    int tag;\r\n    Term arg1;\r\n    Term arg2;\r\n    \r\n    /*@\r\n    \r\n    predicate Term(term t) =\r\n        [_]tag |-\u003e ?tag \u0026*\u0026 [_]arg1 |-\u003e ?arg1 \u0026*\u0026 [_]arg2 |-\u003e ?arg2 \u0026*\u0026\r\n        tag == tagAPP ?\r\n            [_]arg1.Term(?t1) \u0026*\u0026 [_]arg2.Term(?t2) \u0026*\u0026 t == app(t1, t2)\r\n        :\r\n            [_]this.Value(?v) \u0026*\u0026 t == val(v);\r\n    \r\n    predicate Value(value v) =\r\n        [_]tag |-\u003e ?tag \u0026*\u0026 [_]arg1 |-\u003e ?arg1 \u0026*\u0026 [_]arg2 |-\u003e ?arg2 \u0026*\u0026\r\n        tag == tagK0 ? v == K0 :\r\n        tag == tagK1 ? [_]arg1.Value(?v1) \u0026*\u0026 v == K1(v1) :\r\n        tag == tagS0 ? v == S0 :\r\n        tag == tagS1 ? [_]arg1.Value(?v1) \u0026*\u0026 v == S1(v1) :\r\n        tag == tagS2 \u0026*\u0026 [_]arg1.Value(?v1) \u0026*\u0026 [_]arg2.Value(?v2) \u0026*\u0026 v == S2(v1, v2);\r\n    \r\n    lemma void asTerm()\r\n        requires [_]Value(?v);\r\n        ensures [_]Term(val(v));\r\n    {\r\n    }\r\n    \r\n    @*/\r\n    \r\n    Term(int tag, Term arg1, Term arg2)\r\n        //@ requires true;\r\n        //@ ensures [_]this.tag |-\u003e tag \u0026*\u0026 [_]this.arg1 |-\u003e arg1 \u0026*\u0026 [_]this.arg2 |-\u003e arg2;\r\n    {\r\n        this.tag = tag;\r\n        this.arg1 = arg1;\r\n        this.arg2 = arg2;\r\n    }\r\n    \r\n    static Term mkApp(Term arg1, Term arg2)\r\n        //@ requires [_]arg1.Term(?t1) \u0026*\u0026 [_]arg2.Term(?t2);\r\n        //@ ensures [_]result.Term(app(t1, t2));\r\n    {\r\n        return new Term(tagAPP, arg1, arg2);\r\n    }\r\n    \r\n    static Term K0()\r\n        //@ requires true;\r\n        //@ ensures [_]result.Value(K0);\r\n    {\r\n        return new Term(tagK0, null, null);\r\n    }\r\n    \r\n    static Term mkK1(Term arg)\r\n        //@ requires [_]arg.Value(?v);\r\n        //@ ensures [_]result.Value(K1(v));\r\n    {\r\n        return new Term(tagK1, arg, null);\r\n    }\r\n    \r\n    static Term S0()\r\n        //@ requires true;\r\n        //@ ensures [_]result.Value(S0);\r\n    {\r\n        return new Term(tagS0, null, null);\r\n    }\r\n    \r\n    static Term S1(Term arg)\r\n        //@ requires [_]arg.Value(?v);\r\n        //@ ensures result.Value(S1(v));\r\n    {\r\n        return new Term(tagS1, arg, null);\r\n    }\r\n    \r\n    static Term S2(Term arg1, Term arg2)\r\n        //@ requires [_]arg1.Value(?v1) \u0026*\u0026 [_]arg2.Value(?v2);\r\n        //@ ensures [_]result.Value(S2(v1, v2));\r\n    {\r\n        return new Term(tagS2, arg1, arg2);\r\n    }\r\n    \r\n    Term apply_(Term v)\r\n        //@ requires [_]Value(?vf) \u0026*\u0026 [_]v.Value(?vv);\r\n        //@ ensures [_]result.Value(?vr) \u0026*\u0026 [_]reduces_to(apply(vf, vv), val(vr));\r\n    {\r\n        //@ close reduces_to(apply(vf, vv), apply(vf, vv));\r\n        switch (tag) {\r\n            case tagK0: return mkK1(v);\r\n            case tagK1: return arg1;\r\n            case tagS0: return S1(v);\r\n            case tagS1: return S2(arg1, v);\r\n            case tagS2:\r\n                /*@ { arg1.asTerm(); arg2.asTerm(); v.asTerm(); } @*/\r\n                return mkApp(mkApp(arg1, v), mkApp(arg2, v)).eval();\r\n            default:\r\n        }\r\n    }\r\n    \r\n    Term eval()\r\n        //@ requires [_]Term(?t);\r\n        //@ ensures [_]result.Value(?v) \u0026*\u0026 [_]reduces_to(t, val(v));\r\n    {\r\n        if (tag != tagAPP) {\r\n            //@ close reduces_to(t, t);\r\n            return this;\r\n        }\r\n        //@ assert [_]arg1 |-\u003e ?a1 \u0026*\u0026 [_]a1.Term(?t1) \u0026*\u0026 [_]arg2 |-\u003e ?a2 \u0026*\u0026 [_]a2.Term(?t2);\r\n        Term f = arg1.eval();\r\n        //@ assert [_]f.Value(?vf);\r\n        //@ reduces_to_app_l(t1, val(vf), t2);\r\n        Term v = arg2.eval();\r\n        //@ assert [_]v.Value(?vv);\r\n        //@ reduces_to_app_r(vf, t2, val(vv));\r\n        //@ reduces_to_trans(app(t1, t2), app(val(vf), t2), app(val(vf), val(vv)));\r\n        Term r = f.apply_(v);\r\n        //@ assert [_]r.Value(?vr);\r\n        //@ close reduces_to(app(val(vf), val(vv)), val(vr));\r\n        //@ reduces_to_trans(app(t1, t2), app(val(vf), val(vv)), val(vr));\r\n        return r;\r\n    }\r\n}\r\n",
        "name": "Combinators.java",
        "path": "examples/vstte2012/problem2/values/Combinators.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/vstte2012/problem2/values/Combinators.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 124,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 125,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [_]this.tag |-\u003e tag \u0026*\u0026 [_]this.arg1 |-\u003e arg1 \u0026*\u0026 [_]this.arg2 |-\u003e arg2;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 133,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]arg1.Term(?t1) \u0026*\u0026 [_]arg2.Term(?t2);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 134,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [_]result.Term(app(t1, t2));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 140,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 141,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [_]result.Value(K0);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 147,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]arg.Value(?v);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 148,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [_]result.Value(K1(v));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 154,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 155,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [_]result.Value(S0);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 161,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]arg.Value(?v);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 162,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures result.Value(S1(v));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 168,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]arg1.Value(?v1) \u0026*\u0026 [_]arg2.Value(?v2);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 169,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [_]result.Value(S2(v1, v2));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 175,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]Value(?vf) \u0026*\u0026 [_]v.Value(?vv);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 176,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [_]result.Value(?vr) \u0026*\u0026 [_]reduces_to(apply(vf, vv), val(vr));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 192,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]Term(?t);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 193,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [_]result.Value(?v) \u0026*\u0026 [_]reduces_to(t, val(v));\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class OuterClass\n{\n  class InnerClass\n  {\n    //@ predicate OuterClass$InnerClass(int x) = this.x |-\u003e x;\n    \n    int x = 1;\n    \n    InnerClass()\n    //@ requires true;\n    //@ ensures  OuterClass$InnerClass(1);\n    {\n      //@ close OuterClass$InnerClass(1);\n    }\n      \n    int getX()    \n      //@ requires OuterClass$InnerClass(?x);\n      //@ ensures OuterClass$InnerClass(x) \u0026*\u0026 result == x;\n    {\n      //@ open OuterClass$InnerClass(x);\n      return this.x;\n    }\n      \n    void setX(int i)    \n      //@ requires OuterClass$InnerClass(_);\n      //@ ensures OuterClass$InnerClass(i);\n    {\n      x = i;\n    }\n  }\n}\n\npublic class MemberClass\n{\n  public static void main(String[] args)\n    //@ requires class_init_token(OuterClass$InnerClass.class);\n    //@ ensures true; \n  {\n    //@ init_class(OuterClass$InnerClass.class);\n    \n    OuterClass first = new OuterClass();\n    OuterClass.InnerClass second = first.new InnerClass();\n    \n    //Non-static stuff\n    second.setX(111);\n    int i = second.getX();\n    //@ assert i == 111;\n }\n}\n",
        "name": "MemberClass.java",
        "path": "examples/java/frontend/inner_class/MemberClass.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/inner_class/MemberClass.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              6,
              13
            ]
          ],
          "preview": "      //@ requires OuterClass$InnerClass(?x);"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              6,
              12
            ]
          ],
          "preview": "      //@ ensures OuterClass$InnerClass(x) \u0026*\u0026 result == x;"
        },
        {
          "limitHit": false,
          "lineNumber": 24,
          "offsetAndLengths": [
            [
              6,
              13
            ]
          ],
          "preview": "      //@ requires OuterClass$InnerClass(_);"
        },
        {
          "limitHit": false,
          "lineNumber": 25,
          "offsetAndLengths": [
            [
              6,
              12
            ]
          ],
          "preview": "      //@ ensures OuterClass$InnerClass(i);"
        },
        {
          "limitHit": false,
          "lineNumber": 35,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires class_init_token(OuterClass$InnerClass.class);"
        },
        {
          "limitHit": false,
          "lineNumber": 36,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true; "
        },
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  OuterClass$InnerClass(1);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class Main\r\n{\r\n  public static void main(String[] args) \r\n    //@ requires true;\r\n    //@ ensures true; \r\n  {\r\n    int i = 0;\r\n    \r\n    Overloaded3 o3 = new Overloaded3();\r\n    Overloaded2 o2 = o3;\r\n    Overloaded1 o1 = o3;\r\n\r\n    i = method1(o1);\r\n    //@ assert i == 1;\r\n    i = method1(o2);\r\n    //@ assert i == 2;\r\n    i = method1(o3);\r\n    //@ assert i == 3;\r\n    \r\n    i = method2(o1, o1);\r\n    //@ assert i == 11;\r\n    i = method2(o1, o2);\r\n    //@ assert i == 12;\r\n    i = method2(o1, o3);\r\n    //@ assert i == 13;\r\n    \r\n    i = method2(o2, o1);\r\n    //@ assert i == 11;\r\n    i = method2(o2, o2);\r\n    //@ assert i == 12;\r\n    i = method2(o2, o3);\r\n    //@ assert i == 13;\r\n    \r\n    i = method2(o3, o1);\r\n    //@ assert i == 11;\r\n    i = method2(o3, o2);\r\n    //@ assert i == 12;\r\n    i = method2(o3, o3);\r\n    //@ assert i == 13;\r\n  }\r\n\r\n  static int method1(Overloaded1 x)\r\n    //@ requires true;\r\n    //@ ensures  result == 1;\r\n  {\r\n    return 1;\r\n  }\r\n  \r\n  static int method1(Overloaded2 x)\r\n    //@ requires true;\r\n    //@ ensures  result == 2;\r\n  {\r\n    return 2;\r\n  }\r\n  \r\n  static int method1(Overloaded3 x)\r\n    //@ requires true;\r\n    //@ ensures  result == 3;\r\n  {\r\n    return 3;\r\n  }\r\n  \r\n  static int method2(Overloaded1 x, Overloaded1 y)\r\n    //@ requires true;\r\n    //@ ensures  result == 11;\r\n  {\r\n    return 11;\r\n  }\r\n  \r\n  static int method2(Overloaded1 x, Overloaded2 y)\r\n    //@ requires true;\r\n    //@ ensures  result == 12;\r\n  {\r\n    return 12;\r\n  }\r\n  \r\n  static int method2(Overloaded1 x, Overloaded3 y)\r\n    //@ requires true;\r\n    //@ ensures  result == 13;\r\n  {\r\n    return 13;\r\n  }\r\n}\r\n",
        "name": "Main.java",
        "path": "examples/java/frontend/overloaded_methods/Main.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/overloaded_methods/Main.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true; \r"
        },
        {
          "limitHit": false,
          "lineNumber": 42,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 49,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 56,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 63,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 70,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 77,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 43,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  result == 1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 50,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  result == 2;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 57,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  result == 3;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 64,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  result == 11;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 71,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  result == 12;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 78,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  result == 13;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class ShouldFail1\r\n{\r\n  class Inner\r\n  {\r\n    String test() {return \"inner\";}\r\n  }\r\n  \r\n  public static void test()\r\n    //@ requires true;\r\n    //@ ensures true;\r\n  {\r\n    Inner o;\r\n    String foo = o.test(); //~\r\n  }\r\n}",
        "name": "ShouldFail1.java",
        "path": "examples/java/frontend/should_fail/ShouldFail1.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/should_fail/ShouldFail1.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class Sub extends Super\r\n{\r\n  public int increment(int i)\r\n    //@ requires i \u003c 100;\r\n    //@ ensures result == i + 1;\r\n  {\r\n    int j = i;\r\n    j++;\r\n    return j;\r\n  }\r\n\r\n  public int dummy(int i)\r\n    //@ requires true;\r\n    //@ ensures result == i;\r\n  {\r\n    return i;\r\n  }\r\n}\r\n",
        "name": "Sub.java",
        "path": "examples/java/out_of_order_jarsrc/in_order/Sub.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/out_of_order_jarsrc/in_order/Sub.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires i \u003c 100;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class ShouldFail2\r\n{\r\n  public static void test()\r\n    //@ requires true;\r\n    //@ ensures true;\r\n  {\r\n    int i = 0;\r\n    //@ assert i == 0;\r\n    i++;\r\n    /*@\r\n      {\r\n        assert i == 2; //~\r\n      }\r\n    @*/\r\n  }\r\n}",
        "name": "ShouldFail2.java",
        "path": "examples/java/frontend/should_fail/ShouldFail2.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/should_fail/ShouldFail2.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class Assert_desugared\n{\n  public static void main(String[] args)\n    //@ requires true;\n    //@ ensures  true;\n  {\n    int i = 99;\n    assert (i \u003e 0);\n    assert i \u003e 0;\n    char c = 'a';\n    assert (c + 4 == 'e');\n    assert c + 4 == 'e';\n  }\n}",
        "name": "Assert_desugared.java",
        "path": "examples/java/frontend/assert/Assert_desugared.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/assert/Assert_desugared.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import java.util.*;\n\npublic class Boxing_desugared\n{\n  public static void main(String[] args)\n    //@ requires true;\n    //@ ensures true;\n  {\n    //Integers\n    Integer i1 = Integer.valueOf(5);\n    int i2 = i1.intValue();\n    Integer i3 = Integer.valueOf(i2);\n    \n    //Booleans\n    Boolean bool1 = Boolean.valueOf(true);\n    boolean bool2 = bool1.booleanValue();\n    Boolean bool3 = Boolean.valueOf(bool2);\n  }\n}\n",
        "name": "Boxing_desugared.java",
        "path": "examples/java/frontend/boxing/Boxing_desugared.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/boxing/Boxing_desugared.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "// Note: VeriFast/Redux is much faster than VeriFast/Z3 on this applet. Use vfide -prover redux MyApplet.java or verifast -c -allow_assume -prover redux MyApplet.java\r\n\r\n// The assume statements in this file represent assumptions that the applet makes about the input.\r\n// What we are proving here is that in any execution of the applet where the input satisfies these assumptions, the applet does not dereference null pointers,\r\n// access arrays with indices that are out of bounds, divide by zero, perform arithmetic overflow, violate API contracts, or violate the assertions specified in the code.\r\n\r\npackage newmypackage;\r\n\r\nimport org.globalplatform.GPSystem;\r\n\r\nimport be.fedict.neweidapplet.INewEidPoints;\r\n\r\nimport newepurse.IEPurseServicesCredit;\r\nimport newepurse.IEPurseServicesDebit;\r\n\r\nimport javacard.framework.*;\r\n\r\n/*@\r\n\r\nlemma_auto void length_append_auto\u003ct\u003e(list\u003ct\u003e xs, list\u003ct\u003e ys)\r\n    requires true;\r\n    ensures length(append(xs, ys)) == length(xs) + length(ys);\r\n{\r\n    length_append(xs, ys);\r\n}\r\n\r\npredicate length_value_record(list\u003cbyte\u003e values, int start; int end) =\r\n    start \u003c length(values) \u0026*\u0026\r\n    0 \u003c= nth(start, values) \u0026*\u0026\r\n    start + 1 + nth(start, values) \u003c= length(values) \u0026*\u0026\r\n    end == start + 1 + nth(start, values);\r\n\r\npredicate element(list\u003cbyte\u003e values, int offset; byte value) =\r\n    offset \u003c length(values) \u0026*\u0026\r\n    value == nth(offset, values);\r\n\r\npredicate optional_data_records(byte[] array, int start, int count;) =\r\n    count == 0 ?\r\n        true\r\n    :\r\n        0 \u003c count \u0026*\u0026\r\n        array[start..start + 2] |-\u003e _ \u0026*\u0026\r\n        array[start + 2] |-\u003e ?length \u0026*\u0026 0 \u003c= length \u0026*\u0026 length \u003c= NewMyApplet.MAX_LEN_OPTIONAL_DATA \u0026*\u0026\r\n        array[start + 3..start + 3 + NewMyApplet.MAX_LEN_OPTIONAL_DATA] |-\u003e _ \u0026*\u0026\r\n        optional_data_records(array, start + 3 + NewMyApplet.MAX_LEN_OPTIONAL_DATA, count - 1);\r\n\r\nlemma void optional_data_records_split(byte[] array, int start, int offset)\r\n    requires [?f]optional_data_records(array, start, ?count) \u0026*\u0026 0 \u003c= offset \u0026*\u0026 offset \u003c= count;\r\n    ensures [f]optional_data_records(array, start, offset) \u0026*\u0026 [f]optional_data_records(array, start + offset * 13, count - offset);\r\n{\r\n    if (offset == 0) {\r\n        close [f]optional_data_records(array, start, 0);\r\n    } else {\r\n        open optional_data_records(array, start, count);\r\n        optional_data_records_split(array, start + 13, offset - 1);\r\n        close [f]optional_data_records(array, start, offset);\r\n    }\r\n}\r\n\r\nlemma void optional_data_records_merge(byte[] array, int start)\r\n    requires [?f]optional_data_records(array, start, ?count1) \u0026*\u0026 [f]optional_data_records(array, start + count1 * 13, ?count2);\r\n    ensures [f]optional_data_records(array, start, count1 + count2) \u0026*\u0026 0 \u003c= count1 + count2;\r\n{\r\n    open optional_data_records(array, start, count1);\r\n    if (count1 == 0) {\r\n        open optional_data_records(array, start, count2);\r\n        close [f]optional_data_records(array, start, count2);\r\n    } else {\r\n        optional_data_records_merge(array, start + 13);\r\n        close [f]optional_data_records(array, start, count1 + count2);\r\n    }\r\n}\r\n\r\npredicate record(int maxSizeRecord, byte[] record; unit info) =\r\n  record != null \u0026*\u0026\r\n  true == ((record).length == maxSizeRecord + NewMyApplet.LEN_RECORD_LEN_BYTE) \u0026*\u0026\r\n  array_element(record, 0, ?recordLength) \u0026*\u0026 0 \u003c= recordLength \u0026*\u0026 0 + recordLength \u003c= maxSizeRecord \u0026*\u0026\r\n  array_slice(record, 1, 6, _) \u0026*\u0026\r\n  array_element(record, 6, ?adfLength) \u0026*\u0026 0 \u003c= adfLength \u0026*\u0026 6 + adfLength \u003c= maxSizeRecord \u0026*\u0026\r\n  array_slice(record, 7, 1 + maxSizeRecord, _) \u0026*\u0026\r\n  info == unit;\r\n\r\npredicate my_record(int maxSizeRecord, Object record; unit info) =\r\n  record(maxSizeRecord, ^record, unit) \u0026*\u0026 info == unit;\r\n\r\npredicate MyApplet_(NewMyApplet applet; char nbRecords, byte maxSizeRecord) =\r\n  applet.NewEPurseAID |-\u003e ?newEPurseAid \u0026*\u0026 newEPurseAid[..] |-\u003e _ \u0026*\u0026 newEPurseAid.length == 6 \u0026*\u0026\r\n  applet.NewEidAID |-\u003e ?newEidAid \u0026*\u0026 newEidAid[..] |-\u003e _ \u0026*\u0026 newEidAid.length == 9 \u0026*\u0026\r\n  applet.NewEidPointsObject |-\u003e _ \u0026*\u0026\r\n  applet.NewEPurseDebitObject |-\u003e _ \u0026*\u0026\r\n  applet.NewEPurseCreditObject |-\u003e _ \u0026*\u0026\r\n  applet.NewMyAppletPointsObject |-\u003e ?pointsObject \u0026*\u0026 [_]pointsObject.applet |-\u003e applet \u0026*\u0026\r\n  NewMyApplet_Points(_) \u0026*\u0026\r\n  NewMyApplet_bya_FCI(?fci) \u0026*\u0026 fci[..] |-\u003e _ \u0026*\u0026 fci.length == 23 \u0026*\u0026\r\n  applet.by_NbRecords |-\u003e nbRecords \u0026*\u0026 0 \u003c= nbRecords \u0026*\u0026\r\n  applet.by_MaxNbRecord |-\u003e ?maxNbRecord \u0026*\u0026 nbRecords \u003c= maxNbRecord \u0026*\u0026\r\n  applet.by_MaxSizeRecord |-\u003e maxSizeRecord \u0026*\u0026 maxSizeRecord \u003e= NewMyApplet.OFF_DATA_IN_RECORD + 5 \u0026*\u0026\r\n  applet.bya_OptionalData |-\u003e ?optionalData \u0026*\u0026 optionalData != null \u0026*\u0026 optionalData.length == NewMyApplet.SIZE_OPTIONAL_DATA_BUFFER \u0026*\u0026\r\n  optional_data_records(optionalData, 0, 3) \u0026*\u0026\r\n  applet.o_Records |-\u003e ?records \u0026*\u0026 records != null \u0026*\u0026 records.length == maxNbRecord \u0026*\u0026\r\n  array_slice_deep(records, 0, nbRecords, my_record, maxSizeRecord, _, _) \u0026*\u0026\r\n  records[nbRecords..maxNbRecord] |-\u003e ?elems \u0026*\u0026 all_eq(elems, null) == true;\r\n\r\n@*/\r\n\r\npublic final class NewMyApplet extends Applet {\r\n\r\n  static final boolean B_MODE_DEBUG = false;\r\n\r\n  static final byte DEF_MAX_ENTRIES = (byte) 5;\r\n  static final byte DEF_MAX_ENTRY_SIZE = (byte) 50;\r\n\r\n  static final byte  LEN_RECORD_LEN_BYTE = (byte) 01;\r\n  static final short OFF_DATA_IN_RECORD = (short) 01;\r\n\r\n  static final byte ADF_LEN_OFFSET = (byte) 10;\r\n  static final byte ADF_OFFSET = (byte) 11;\r\n\r\n  static final short MAX_LEN_OPTIONAL_DATA = (short) 10;\r\n  static final short MAX_LEN_OPTIONAL_DATA_AND_HEADER = (short)(MAX_LEN_OPTIONAL_DATA + 3);\r\n  static final short SIZE_OPTIONAL_DATA_BUFFER = (short)(3 * MAX_LEN_OPTIONAL_DATA_AND_HEADER);\r\n  static final short TAG_LANGUAGE_PREFERENCE = (short) 0x1234 ;\r\n  static final short TAG_ISSUER_CODE_TABLE_INDEX = (short) 0x1235 ;\r\n  static final short TAG_FCI_ISSUER_DISCRETIONARY_DATA = (short) 0x1236 ;\r\n\r\n  byte by_NbRecords;\r\n  byte by_MaxNbRecord;\r\n\r\n  byte by_MaxSizeRecord;\r\n\r\n  byte[] bya_OptionalData;\r\n\r\n  Object[] o_Records;\r\n\r\n  static final byte bya_FCI[] =\r\n  {\r\n    (byte)0x12, (byte)21,\r\n    (byte)0x12, (byte)14,\r\n    (byte)'X',  (byte)'X', (byte)'X', (byte)'X', (byte)'X',\r\n    (byte)'X',  (byte)'X', (byte)'X', (byte)'X',\r\n    (byte)'X',  (byte)'X', (byte)'X', (byte)'X', (byte)'X',\r\n    (byte)0x12, (byte)3,\r\n    (byte)0x12, (byte)1,  (byte)1\r\n  };\r\n\r\n  \tpublic static final byte INS_Debit = 0x01;\r\n\tpublic static final byte INS_Eid_Points = 0x03;\r\n\tprivate byte[] NewEPurseAID = {0x01,0x02,0x03,0x04,0x05,0x00};\r\n\tprivate IEPurseServicesDebit NewEPurseDebitObject;\r\n\tprivate IEPurseServicesCredit NewEPurseCreditObject;\r\n\tprivate byte[] NewEidAID = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x00};\r\n\tprivate INewEidPoints NewEidPointsObject;\r\n\tpublic static byte Points = 5;\r\n\tNewMyAppletPoints NewMyAppletPointsObject;\r\n\r\n    //@ predicate valid() = MyApplet_(this, _, _);\r\n\r\n  private NewMyApplet(byte[] byaBuffer, short shOffset, byte byLength, byte byMaxNbRecord, byte byMaxSizeRecord)\r\n    //@ requires system() \u0026*\u0026 0 \u003c= byMaxNbRecord \u0026*\u0026 6 \u003c= byMaxSizeRecord \u0026*\u0026 Points |-\u003e _ \u0026*\u0026 bya_FCI |-\u003e ?fci \u0026*\u0026 array_slice(fci, 0, 23, _) \u0026*\u0026 fci.length == 23 \u0026*\u0026 array_slice(byaBuffer, shOffset, shOffset + byLength, _);\r\n    //@ ensures true;\r\n  {\r\n\tNewMyAppletPointsObject = new NewMyAppletPoints();\r\n\t//@ NewMyAppletPointsObject.applet = this;\r\n\t\t\r\n    by_MaxNbRecord   = byMaxNbRecord;\r\n    by_MaxSizeRecord = byMaxSizeRecord;\r\n\r\n    bya_OptionalData = new byte[SIZE_OPTIONAL_DATA_BUFFER];\r\n    //@ close optional_data_records(bya_OptionalData, 3 * MAX_LEN_OPTIONAL_DATA_AND_HEADER, 0);\r\n    //@ close optional_data_records(bya_OptionalData, 2 * MAX_LEN_OPTIONAL_DATA_AND_HEADER, 1);\r\n    //@ close optional_data_records(bya_OptionalData, 1 * MAX_LEN_OPTIONAL_DATA_AND_HEADER, 2);\r\n    //@ close optional_data_records(bya_OptionalData, 0 * MAX_LEN_OPTIONAL_DATA_AND_HEADER, 3);\r\n\r\n    o_Records = new Object[by_MaxNbRecord];\r\n\r\n    //@ close valid();\r\n    if( byLength == 0 )\r\n    {\r\n      register();\r\n    }\r\n    else\r\n    {\r\n      register(byaBuffer, shOffset, byLength);\r\n    }\r\n  }\r\n\r\n  public static void install(byte[] byaBuffer, short shOffset, byte byLength) throws ISOException /*@ ensures true; @*/\r\n    /*@\r\n    requires\r\n      system() \u0026*\u0026 class_init_token(NewMyApplet.class) \u0026*\u0026\r\n      byaBuffer != null \u0026*\u0026\r\n      shOffset \u003e= 0 \u0026*\u0026\r\n      array_slice(byaBuffer, shOffset, shOffset + byLength, ?values) \u0026*\u0026\r\n      length_value_record(values, 0, ?privilegesStart) \u0026*\u0026\r\n      length_value_record(values, privilegesStart, ?paramsStart) \u0026*\u0026\r\n      element(values, paramsStart + 1, ?paramsLength) \u0026*\u0026\r\n      element(values, paramsStart + 2, ?maxNbRecord) \u0026*\u0026 maxNbRecord \u003e= 0 \u0026*\u0026\r\n      element(values, paramsStart + 3, ?maxSizeRecord) \u0026*\u0026 maxSizeRecord \u003e= 6 \u0026*\u0026\r\n      shOffset + paramsStart + 3 \u003c= 32767;\r\n    @*/\r\n    //@ ensures true;\r\n  {\r\n    //@ init_class();\r\n    short shIndex = shOffset;\r\n    byte byMaxNbRecord   = DEF_MAX_ENTRIES ;\r\n    byte byMaxSizeRecord = DEF_MAX_ENTRY_SIZE;\r\n\r\n    //@ open length_value_record(values, 0, privilegesStart);\r\n    //@ open length_value_record(values, privilegesStart, _);\r\n    shIndex += (byaBuffer[shIndex]+1);\r\n    shIndex += (byaBuffer[shIndex]+1);\r\n\r\n    ++shIndex;\r\n    // BUG: byte byOffRecParam = (byte)shIndex ; The Java Card spec does not guarantee that the offset fits in a byte.\r\n    short byOffRecParam = shIndex ;\r\n    //@ open element(values, shIndex - shOffset, _);\r\n    //@ open element(values, shIndex + 1 - shOffset, _);\r\n    //@ open element(values, shIndex + 2 - shOffset, _);\r\n    byte byLenRecParam = byaBuffer[shIndex] ;\r\n    //\r\n    if (byLenRecParam != 0)\r\n    {\r\n      ++byOffRecParam;\r\n      byMaxNbRecord    = (byaBuffer[byOffRecParam] != 0) ? byaBuffer[byOffRecParam] : DEF_MAX_ENTRIES;\r\n      ++byOffRecParam;\r\n      byMaxSizeRecord  = (byaBuffer[byOffRecParam] != 0) ? byaBuffer[byOffRecParam] : DEF_MAX_ENTRY_SIZE;\r\n    }\r\n\r\n    new NewMyApplet(byaBuffer, (short)(shOffset+1), byaBuffer[shOffset], byMaxNbRecord, byMaxSizeRecord);\r\n  }\r\n\r\n  public void process(APDU oApdu)\r\n    /*@\r\n    requires\r\n      current_applet(this) \u0026*\u0026\r\n      [1/2]valid() \u0026*\u0026\r\n      oApdu != null \u0026*\u0026\r\n      APDU(oApdu, ?buffer) \u0026*\u0026\r\n      array_slice(buffer, 0, buffer.length, _);\r\n    @*/\r\n    /*@\r\n    ensures\r\n      current_applet(this) \u0026*\u0026\r\n      [1/2]valid() \u0026*\u0026\r\n      oApdu != null \u0026*\u0026\r\n      APDU(oApdu, buffer) \u0026*\u0026\r\n      array_slice(buffer, 0, buffer.length, _);\r\n    @*/\r\n  {\r\n    byte[] byaApdu = oApdu.getBuffer();\r\n\r\n    switch(sh(byaApdu[ISO7816.OFFSET_CLA]))\r\n    {\r\n    case 0x00:\r\n      switch(sh(byaApdu[ISO7816.OFFSET_INS]))\r\n      {\r\n      case 0xa4:\r\n        processSelectCmd(oApdu);\r\n        return;\r\n      case 0xb2:\r\n        processReadRecord(oApdu);\r\n        return;\r\n      case 0xe4:\r\n        processDeleteRecord(oApdu);\r\n        return;\r\n      case 0xc0:\r\n        return;\r\n      case 0xcb:\r\n        if (B_MODE_DEBUG)\r\n        {\r\n          /*\r\n          if(Util.getShort(byaApdu, (short)2) == (short)0x9f01)\r\n          {\r\n            byaApdu[4] = by_MaxNbRecord ;\r\n            byaApdu[5] = by_MaxSizeRecord ;\r\n            oApdu.setOutgoingAndSend((short)2, (short)4) ;\r\n            return;\r\n          }\r\n          */\r\n        }\r\n      case INS_Debit:\r\n\t\t\taskForPayment();\r\n\t\t\tbreak;\r\n      case INS_Eid_Points:\r\n\t\t   askForSharingPoints();\r\n\t\t   break;\r\n      default:\r\n        ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);\r\n      }\r\n    case 0x80 :\r\n      switch(sh(byaApdu[ISO7816.OFFSET_INS]))\r\n      {\r\n      case 0xda:\r\n        processPutData(oApdu);\r\n        return;\r\n      case 0xe2:\r\n        processAppendRecord(oApdu);\r\n        return;\r\n      case INS_Debit:\r\n\t\taskForPayment();\r\n\t\tbreak;\r\n      case INS_Eid_Points:\r\n\t    askForSharingPoints();\r\n\t    break;\r\n      default:\r\n        ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);\r\n      }\r\n    default:\r\n      ISOException.throwIt(ISO7816.SW_CLA_NOT_SUPPORTED);\r\n    }\r\n  }\r\n\r\n  private void processSelectCmd(APDU oApdu)\r\n    //@ requires [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    //@ ensures [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n  {\r\n    if ( !selectingApplet() )\r\n      ISOException.throwIt(ISO7816.SW_FILE_NOT_FOUND);\r\n    byte[] byaApdu = checkIncomingData(oApdu, true, false);\r\n    short shCurrentOffset = 0;\r\n    if (sh(byaApdu[ISO7816.OFFSET_LC]) == (short)0)\r\n      ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n    if((byaApdu[ISO7816.OFFSET_P1]) != 0x04)\r\n      ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n    //@ open valid();\r\n    //@ open MyApplet_(this, _, _);\r\n    byte[] byaOptionalData = bya_OptionalData;\r\n    shCurrentOffset = Util.arrayCopyNonAtomic( bya_FCI, shCurrentOffset, byaApdu, (short)0, (short)bya_FCI.length );\r\n    byte k,j;\r\n    //@ int i = 2;\r\n    //@ optional_data_records_split(byaOptionalData, 0, i);\r\n\r\n\r\n    for(k=26,j=28 ; k\u003e=0 ; k-=13,j-=13)\r\n      /*@\r\n      invariant\r\n          -13 \u003c= k \u0026*\u0026 k \u003c= 26 \u0026*\u0026 j == k + 2 \u0026*\u0026 k == 13 * i \u0026*\u0026\r\n          array_slice(byaApdu, 0, byaApdu.length, _) \u0026*\u0026\r\n          23 \u003c= shCurrentOffset \u0026*\u0026\r\n          shCurrentOffset \u003c= 23 + 13 * (2 - i) \u0026*\u0026\r\n          k \u003c 0 ?\r\n              [1/2]optional_data_records(byaOptionalData, 0, 3)\r\n          :\r\n              [1/2]optional_data_records(byaOptionalData, 0, i) \u0026*\u0026 [1/2]optional_data_records(byaOptionalData, k, 3 - i);\r\n      @*/\r\n    {\r\n        //@ open optional_data_records(byaOptionalData, k, _);\r\n      shCurrentOffset = Util.arrayCopyNonAtomic( byaOptionalData, k,\r\n          byaApdu, shCurrentOffset,\r\n          (byaOptionalData[j] != 0)? (short)(byaOptionalData[j] + 3): (short)0);\r\n      //@ close [1/2]optional_data_records(byaOptionalData, k, 3 - i);\r\n      //@ i--;\r\n      /*@\r\n      if (0 \u003c= i) {\r\n          optional_data_records_split(byaOptionalData, 0, i);\r\n          open optional_data_records(byaOptionalData, k - 13, _);\r\n          close [1/2]optional_data_records(byaOptionalData, k - 13, 3 - i);\r\n      }\r\n      @*/\r\n    }\r\n    shCurrentOffset -= /**/bya_FCI.length;\r\n    //@ assume(bya_FCI[3] == 14);\r\n    byaApdu[bya_FCI[3]+5] = (byte)(shCurrentOffset + 3);\r\n    byaApdu[1] = (byte)(shCurrentOffset + 3+2 + bya_FCI[3]+2);\r\n    oApdu.setOutgoingAndSend((short)0, (short)(sh(byaApdu[1]) + (short)2));\r\n    //@ close [1/2]MyApplet_(this, _, _);\r\n    //@ close [1/2]valid();\r\n  }\r\n\r\n  private byte[] checkIncomingData(APDU oApdu, boolean bReceive, boolean bCheckPersoState)\r\n    //@ requires oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _);\r\n    //@ ensures APDU(oApdu, buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _) \u0026*\u0026 result == buffer_;\r\n  {\r\n    if (bCheckPersoState \u0026\u0026 GPSystem.getCardContentState() != GPSystem.SECURITY_DOMAIN_PERSONALIZED )\r\n      ISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);\r\n    if (bReceive) oApdu.setIncomingAndReceive();\r\n    return oApdu.getBuffer();\r\n  }\r\n\r\n  private void processPutData(APDU oApdu)\r\n    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n  {\r\n    byte[] byaApdu = checkIncomingData(oApdu, true, true); // true =\u003e personalization must have previously been done\r\n    short shLC = sh(byaApdu[ISO7816.OFFSET_LC]) ;\r\n    //@ open is_short_of_byte(_, _);\r\n\r\n    if (shLC \u003e MAX_LEN_OPTIONAL_DATA)\r\n      ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n\r\n    byte byIndex = getOptionalDataIndex(Util.getShort( byaApdu, ISO7816.OFFSET_P1 ));\r\n\r\n    JCSystem.beginTransaction(); // Inserted for VeriFast\r\n    //@ open valid();\r\n    //@ open MyApplet_(this, _, _);\r\n    byte[] byaOptionalData = bya_OptionalData;\r\n    //@ optional_data_records_split(byaOptionalData, 0, byIndex);\r\n    //@ open optional_data_records(byaOptionalData, byIndex * MAX_LEN_OPTIONAL_DATA_AND_HEADER, 3 - byIndex);\r\n    Util.arrayCopy( byaApdu, ISO7816.OFFSET_P1,\r\n        byaOptionalData,\r\n        (short) (byIndex * MAX_LEN_OPTIONAL_DATA_AND_HEADER),\r\n        (short) (shLC + (short)3));\r\n    //@ assert byaOptionalData[byIndex * 13 + 2] |-\u003e ?length;\r\n    //@ assume(0 \u003c= length \u0026\u0026 length \u003c= NewMyApplet.MAX_LEN_OPTIONAL_DATA);\r\n    //@ close optional_data_records(byaOptionalData, byIndex * MAX_LEN_OPTIONAL_DATA_AND_HEADER, 3 - byIndex);\r\n    //@ optional_data_records_merge(byaOptionalData, 0);\r\n    //@ close MyApplet_(this, _, _);\r\n    //@ close valid();\r\n    JCSystem.commitTransaction(); // Inserted for VeriFast\r\n  }\r\n\r\n  private byte getOptionalDataIndex(short tag)\r\n    //@ requires true;\r\n    //@ ensures 0 \u003c= result \u0026*\u0026 result \u003c= 2;\r\n  {\r\n    switch (tag)\r\n    {\r\n    case TAG_FCI_ISSUER_DISCRETIONARY_DATA : return 0 ;\r\n    case TAG_ISSUER_CODE_TABLE_INDEX : return 1;\r\n    case TAG_LANGUAGE_PREFERENCE : return 2;\r\n    default :\r\n      ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n    }\r\n    return -1; //~allow_dead_code\r\n  }\r\n\r\n  private void processAppendRecord(APDU oApdu)\r\n    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n  {\r\n      //@ open valid();\r\n      //@ open MyApplet_(this, _, _);\r\n    byte[] byaApdu = checkIncomingData(oApdu, true, false);\r\n    short shLC = sh(byaApdu[ISO7816.OFFSET_LC]) ;\r\n    if((byaApdu[ISO7816.OFFSET_P1] != 0)\r\n        || (byaApdu[ISO7816.OFFSET_P2]\u00260x07) != 0)\r\n      ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n    if((byaApdu[ISO7816.OFFSET_P2]\u003e\u003e3) != 1)\r\n      ISOException.throwIt(ISO7816.SW_FILE_NOT_FOUND);\r\n    //@ open is_short_of_byte(_, _);\r\n    if ( shLC \u003e sh(by_MaxSizeRecord) )\r\n      ISOException.throwIt( ISO7816.SW_FILE_FULL );\r\n    //@ open is_short_of_byte(_, _);\r\n    //@ byte maxSizeRecord = by_MaxSizeRecord;\r\n    //@ assert 0 \u003c= shLC \u0026*\u0026 shLC \u003c= maxSizeRecord;\r\n\r\n    if (byaApdu[ISO7816.OFFSET_CDATA] != (byte)0x70)\r\n      ISOException.throwIt( ISO7816.SW_CONDITIONS_NOT_SATISFIED );\r\n\r\n    //@ assume(0 \u003c= byaApdu[ADF_LEN_OFFSET] \u0026\u0026 byaApdu[ADF_LEN_OFFSET] \u003c= 133 - ADF_OFFSET);\r\n    if (JCSystem.lookupAID( byaApdu, ADF_OFFSET, byaApdu[ADF_LEN_OFFSET] )== null)\r\n      ISOException.throwIt( ISO7816.SW_CONDITIONS_NOT_SATISFIED );\r\n\r\n    byte byFreeRecord = (byte)0x7F ;\r\n    byte [] byaRecordData ;\r\n\r\n    //@ close [1/2]MyApplet_(this, _, _);\r\n    for (byte i = 0; i \u003c by_NbRecords; i++)\r\n      /*@\r\n      invariant\r\n        [1/2]MyApplet_(this, ?nbRecords, maxSizeRecord) \u0026*\u0026\r\n        array_slice(byaApdu, 0, byaApdu.length, _) \u0026*\u0026 133 \u003c= byaApdu.length \u0026*\u0026\r\n        0 \u003c= i \u0026*\u0026 i \u003c= nbRecords \u0026*\u0026\r\n        (byFreeRecord != 0x7F ? 0 \u003c= byFreeRecord \u0026*\u0026 byFreeRecord \u003c i : true);\r\n      @*/\r\n    {\r\n      byaRecordData = (byte[]) (o_Records[i]);\r\n      //@ assume(0 \u003c= byaApdu[ADF_LEN_OFFSET] \u0026\u0026 byaApdu[ADF_LEN_OFFSET] \u003c= 133 - ADF_OFFSET \u0026\u0026 byaApdu[ADF_LEN_OFFSET] \u003c= byaRecordData.length - ADF_OFFSET);\r\n      if ((byaRecordData[0] != 0x00)\r\n          \u0026\u0026 Util.arrayCompare(byaApdu, ADF_OFFSET, byaRecordData, (short)(OFF_DATA_IN_RECORD+6), byaApdu[ADF_LEN_OFFSET]) == 0)\r\n        ISOException.throwIt( ISO7816.SW_CONDITIONS_NOT_SATISFIED );\r\n      if (byaRecordData[0] == 0x00)\r\n      {\r\n        byFreeRecord = i ;\r\n      }\r\n      //@ close [1/2]record(by_MaxSizeRecord, byaRecordData, unit);\r\n      //@ close [1/2]MyApplet_(this, _, _);\r\n    }\r\n    //@ assume(11 \u003c= shLC);\r\n\r\n    if (byFreeRecord != 0x7F)\r\n    {\r\n      //@ close [1/2]MyApplet_(this, _, _);\r\n      JCSystem.beginTransaction();\r\n      //@ open valid();\r\n\r\n      byaRecordData = (byte[])o_Records[byFreeRecord];\r\n      //@ open record(by_MaxSizeRecord, byaRecordData, _);\r\n      Util.arrayCopy(byaApdu, ISO7816.OFFSET_CDATA, byaRecordData, OFF_DATA_IN_RECORD, shLC);\r\n      //@ assume(0 \u003c= byaRecordData[6] \u0026\u0026 byaRecordData[6] \u003c= by_MaxSizeRecord - 6);\r\n      byaRecordData[0] = (byte)shLC ;\r\n      //@ close record(by_MaxSizeRecord, byaRecordData, _);\r\n      //@ close MyApplet_(this, _, _);\r\n      //@ close valid();\r\n      JCSystem.commitTransaction();\r\n    }\r\n    else\r\n    {\r\n\r\n      //@ close [1/2]MyApplet_(this, _, _);\r\n      JCSystem.beginTransaction();\r\n      //@ open valid();\r\n      //@ open MyApplet_(this, _, _);\r\n      if (by_NbRecords \u003e= by_MaxNbRecord)\r\n        ISOException.throwIt( ISO7816.SW_FILE_FULL );\r\n      o_Records[by_NbRecords] = new byte[by_MaxSizeRecord + LEN_RECORD_LEN_BYTE];\r\n      byaRecordData = (byte[])(o_Records[by_NbRecords]);\r\n      by_NbRecords++ ;\r\n\r\n      Util.arrayCopy(byaApdu, ISO7816.OFFSET_CDATA, byaRecordData, OFF_DATA_IN_RECORD, shLC);\r\n      //@ assume(0 \u003c= byaRecordData[6] \u0026\u0026 byaRecordData[6] \u003c= by_MaxSizeRecord - 6);\r\n      byaRecordData[0] = (byte)shLC ;\r\n      //@ close record(by_MaxSizeRecord, byaRecordData, unit);\r\n      //@ close my_record(by_MaxSizeRecord, byaRecordData, unit);\r\n      //@ array_slice_deep_close(o_Records, by_NbRecords - 1, my_record, maxSizeRecord);\r\n      //@ close MyApplet_(this, _, _);\r\n      //@ close valid();\r\n      JCSystem.commitTransaction();\r\n    }\r\n    //@ open valid();\r\n    //@ open MyApplet_(this, _, _);\r\n    if ((byFreeRecord == (byte)0x7F) \u0026\u0026 (by_NbRecords == 1))\r\n      GPSystem.setCardContentState( GPSystem.SECURITY_DOMAIN_PERSONALIZED );\r\n      //@ close [1/2]MyApplet_(this, _, _);\r\n      //@ close [1/2]valid();\r\n  }\r\n\r\n  private static final byte MODE_DELETE_UNSET      = 0 ;\r\n  private static final byte MODE_DELETE_BY_NUMBER  = 1 ;\r\n  private static final byte MODE_DELETE_BY_AID     = 2 ;\r\n  private static final byte MODE_DELETE_BY_REFRESH = 3 ;\r\n\r\n  private void processDeleteRecord(APDU oApdu)\r\n    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n  {\r\n    byte[] byaApdu = checkIncomingData(oApdu, true, false);\r\n\r\n    byte byMode = MODE_DELETE_UNSET ;\r\n    switch(byaApdu[ISO7816.OFFSET_P2]\u00260x07)\r\n    {\r\n    case 0x00:\r\n      switch(byaApdu[ISO7816.OFFSET_P1])\r\n      {\r\n      case 0x00 :\r\n        byMode = MODE_DELETE_BY_AID ;\r\n        break ;\r\n      case 0x01 :\r\n        byMode = MODE_DELETE_BY_REFRESH ;\r\n        break ;\r\n      default:\r\n        ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n      }\r\n      break ;\r\n    case 0x04:\r\n      byMode = MODE_DELETE_BY_NUMBER ;\r\n      break ;\r\n    default:\r\n      ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n    }\r\n\r\n    if((byaApdu[ISO7816.OFFSET_P2]\u003e\u003e3) != 1)\r\n      ISOException.throwIt(ISO7816.SW_FILE_NOT_FOUND);\r\n    byte [] byaRecordData = null ;\r\n    if (byMode == MODE_DELETE_BY_NUMBER)\r\n    {\r\n\r\n      byte byRecordToDelete = /*@ truncating @*/ (byte)(byaApdu[ISO7816.OFFSET_P1]-1) ;\r\n      JCSystem.beginTransaction();\r\n      //@ open valid();\r\n      //@ open MyApplet_(this, _, _);\r\n      if ((byRecordToDelete \u003c by_NbRecords) \u0026\u0026 (byRecordToDelete \u003e= 0))\r\n        byaRecordData = (byte[])(o_Records[byRecordToDelete]) ;\r\n      //\r\n      if (byaRecordData == null\r\n          || byaRecordData[0] == (byte)0)\r\n        ISOException.throwIt(ISO7816.SW_RECORD_NOT_FOUND);\r\n      //\r\n      byaRecordData[0] = (byte)0 ;\r\n      //@ close record(by_MaxSizeRecord, byaRecordData, unit);\r\n      //@ close MyApplet_(this, _, _);\r\n      //@ close valid();\r\n      JCSystem.commitTransaction();\r\n\r\n    }\r\n    else if (byMode == MODE_DELETE_BY_AID)\r\n    {\r\n\r\n            JCSystem.beginTransaction(); // Inserted for VeriFast\r\n            //@ open valid();\r\n            //@ open MyApplet_(this, _, _);\r\n            //@ close MyApplet_(this, _, _);\r\n      for(byte i=0 ; i\u003cby_NbRecords ; i++)\r\n        /*@\r\n        invariant\r\n          MyApplet_(this, ?nbRecords, _) \u0026*\u0026\r\n          array_slice(byaApdu, 0, byaApdu.length, _) \u0026*\u0026 133 \u003c= byaApdu.length \u0026*\u0026\r\n          0 \u003c= i \u0026*\u0026 i \u003c= nbRecords;\r\n        @*/\r\n      {\r\n        byaRecordData = (byte[])(o_Records[i]) ;\r\n\r\n        if (Util.arrayCompare(byaApdu, ISO7816.OFFSET_CDATA,\r\n            byaRecordData, (short)(OFF_DATA_IN_RECORD+6), byaRecordData[OFF_DATA_IN_RECORD+5]) == 0)\r\n        {\r\n          byaRecordData[0] = (byte)0 ;\r\n          //@ close record(by_MaxSizeRecord, byaRecordData, unit);\r\n          //@ close MyApplet_(this, _, _);\r\n          break;\r\n        }\r\n        //@ close record(by_MaxSizeRecord, byaRecordData, unit);\r\n      }\r\n      //@ close valid();\r\n      JCSystem.commitTransaction(); // Inserted for VeriFast. TODO: Move closer to update.\r\n    }\r\n    else if (byMode == MODE_DELETE_BY_REFRESH)\r\n    {\r\n      JCSystem.beginTransaction(); // Inserted for VeriFast\r\n      //@ open valid();\r\n      //@ open MyApplet_(this, _, _);\r\n      //@ close MyApplet_(this, _, _);\r\n      for(short i=0 ; i\u003cby_NbRecords ; i++)\r\n        /*@\r\n        invariant\r\n          MyApplet_(this, ?nbRecords, _) \u0026*\u0026\r\n          array_slice(byaApdu, 0, byaApdu.length, _) \u0026*\u0026 133 \u003c= byaApdu.length \u0026*\u0026\r\n          0 \u003c= i \u0026*\u0026 i \u003c= nbRecords;\r\n        @*/\r\n      {\r\n        byaRecordData = (byte[])(o_Records[i]) ;\r\n          if (JCSystem.lookupAID( byaRecordData, (byte)(OFF_DATA_IN_RECORD+6), byaRecordData[OFF_DATA_IN_RECORD+5] )== null)\r\n        {\r\n          byaRecordData[0] = (byte)0;\r\n        }\r\n        //@ close record(by_MaxSizeRecord, byaRecordData, unit);\r\n      }\r\n      //@ close valid();\r\n      JCSystem.commitTransaction();\r\n    }\r\n  }\r\n\r\n  private void processReadRecord(APDU oApdu)\r\n    //@ requires [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    //@ ensures [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n  {\r\n      //@ open valid();\r\n    byte[] byaApdu = checkIncomingData(oApdu, false, true);\r\n    short shIndexRecord = (short)(sh(byaApdu[ISO7816.OFFSET_P1]) - (short)1);\r\n\r\n    if ((shIndexRecord \u003c (short)0) || (shIndexRecord \u003e= by_NbRecords))\r\n      ISOException.throwIt(ISO7816.SW_RECORD_NOT_FOUND);\r\n    if((byaApdu[ISO7816.OFFSET_P2]\u00260x07) != 4)\r\n      ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n\r\n    if((byaApdu[ISO7816.OFFSET_P2]\u003e\u003e3) != 1)\r\n      ISOException.throwIt(ISO7816.SW_FILE_NOT_FOUND);\r\n\r\n    byte [] byaRecordData = (byte[])(o_Records[shIndexRecord]) ;\r\n    short shLenRecord = sh(byaRecordData[0]);\r\n\r\n    if (shLenRecord == (short)0)\r\n      ISOException.throwIt(ISO7816.SW_RECORD_NOT_FOUND);\r\n\r\n    //@ open is_short_of_byte(shLenRecord, _);\r\n    Util.arrayCopyNonAtomic(byaRecordData, OFF_DATA_IN_RECORD, byaApdu, ISO7816.OFFSET_CDATA, shLenRecord);\r\n\r\n    short shLE = oApdu.setOutgoing() ;\r\n\r\n    if (shLE == (short)0 || shLE \u003e shLenRecord) shLE = shLenRecord ;\r\n\r\n    oApdu.setOutgoingLength(shLE);\r\n    oApdu.sendBytes((short)0, (short)shLE);\r\n    //@ close [1/2]record(by_MaxSizeRecord, byaRecordData, unit);\r\n    //@ close [1/2]MyApplet_(this, _, _);\r\n    //@ close [1/2]valid();\r\n  }\r\n\r\n  private short sh(byte byByte)\r\n    //@ requires true;\r\n    //@ ensures is_short_of_byte(result, byByte) \u0026*\u0026 0 \u003c= result \u0026*\u0026 result \u003c= 255;\r\n  {\r\n    short res = (short) (byByte \u0026 0xFF);\r\n    return res;\r\n    //@ assume (byByte \u003c 0 ? res == 256 + byByte : res == byByte);\r\n    //@ close is_short_of_byte((short) (byByte \u0026 0xFF), byByte);\r\n  }\r\n  private void askForSharingPoints()\r\n    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid();\r\n    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid();\r\n  {\r\n\tAID NewEid_AID = JCSystem.lookupAID(NewEidAID,(short)0, (byte)NewEidAID.length);\r\n\t\t\r\n\tif (NewEid_AID == null)\r\n\t\tISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);\r\n\t\t\r\n\tJCSystem.beginTransaction(); // Added for VeriFast\r\n\tNewEidPointsObject = (INewEidPoints)\r\n\t\t(JCSystem.getAppletShareableInterfaceObject(NewEid_AID, (byte) 0x00));\r\n\t\t\r\n\tINewEidPoints newEidPoints = NewEidPointsObject;\r\n\tbyte points = Points;\r\n\t\r\n\tif (newEidPoints != null) {\r\n\t    points = newEidPoints.sharePoints(points);\r\n\t}\r\n\t\r\n\tPoints = points;\r\n\tJCSystem.commitTransaction(); // Added for VeriFast\r\n\t\t\r\n  }\r\n\r\n  private void askForPayment()\r\n    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid();\r\n    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid();\r\n  {\r\n\tAID NewEPurse_AID = JCSystem.lookupAID(NewEPurseAID,(short)0, (byte)NewEPurseAID.length);\r\n\t\t\r\n\tif (NewEPurse_AID == null)\r\n\t\tISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);\r\n\t\t\r\n\tJCSystem.beginTransaction(); // Added for VeriFast\r\n\tNewEPurseDebitObject = (IEPurseServicesDebit)\r\n\t\t(JCSystem.getAppletShareableInterfaceObject(NewEPurse_AID, (byte) 0x00));\r\n\tIEPurseServicesDebit newEPurseDebitObject = NewEPurseDebitObject;\r\n\tbyte points = Points;\r\n\t\t\r\n\tif (newEPurseDebitObject != null) {\r\n        //@ Shareable epurseServiceSIO = newEPurseDebitObject;\r\n        //@ assert epurseServiceSIO.Shareable(?epurseApplet1);\r\n        //@ mem_registered_applets_is(this);\r\n        //@ assert registered_applets(?as1);\r\n        //@ foreachp_unremove\u003cApplet\u003e(this, as1);\r\n        //@ set_current_applet(epurseApplet1);\r\n        //@ foreachp_remove(epurseApplet1, as1);\r\n\tnewEPurseDebitObject.debit(points);\r\n        //@ is_registered_applets_mem(this);\r\n        //@ assert registered_applets(?as2);\r\n        //@ foreachp_unremove(epurseApplet1, as2);\r\n        //@ set_current_applet(this);\r\n        //@ foreachp_remove\u003cApplet\u003e(this, as2);\r\n        }\r\n\t\r\n\tNewEPurseCreditObject = (IEPurseServicesCredit)\r\n\t(JCSystem.getAppletShareableInterfaceObject(NewEPurse_AID, (byte) 0x01));\r\n\tIEPurseServicesCredit newEPurseCreditObject = NewEPurseCreditObject;\r\n\t\r\n\tif (newEPurseCreditObject != null) {\r\n        //@ Shareable epurseServiceSIO = newEPurseCreditObject;\r\n        //@ assert epurseServiceSIO.Shareable(?epurseApplet2);\r\n        //@ mem_registered_applets_is(this);\r\n        //@ assert registered_applets(?as1);\r\n        //@ foreachp_unremove\u003cApplet\u003e(this, as1);\r\n        //@ set_current_applet(epurseApplet2);\r\n        //@ foreachp_remove(epurseApplet2, as1);\r\n\tnewEPurseCreditObject.transaction(points);\r\n        //@ is_registered_applets_mem(this);\r\n        //@ assert registered_applets(?as2);\r\n        //@ foreachp_unremove(epurseApplet2, as2);\r\n        //@ set_current_applet(this);\r\n        //@ foreachp_remove\u003cApplet\u003e(this, as2);\r\n        }\r\n\t\r\n\tJCSystem.commitTransaction(); // Added for VeriFast\r\n  }\r\n  \r\n  public Shareable getShareableInterfaceObject(AID oAid, byte bArg)\r\n        //@ requires [1/2]this.valid() \u0026*\u0026 registered_applets(?as) \u0026*\u0026 foreachp(remove\u003cApplet\u003e(this, as), semi_valid) \u0026*\u0026 mem\u003cApplet\u003e(this, as) == true \u0026*\u0026 AID(oAid);\r\n        //@ ensures [1/2]this.valid() \u0026*\u0026 registered_applets(as) \u0026*\u0026 foreachp(remove\u003cApplet\u003e(this, as), semi_valid) \u0026*\u0026 AID(oAid) \u0026*\u0026 result == null ? true : result.Shareable(?a) \u0026*\u0026 mem\u003cApplet\u003e(a, as) == true;\r\n  {\r\n\t\t\r\n\t\t//check if AID is allowed\r\n\t\t//@ NewMyAppletPointsObject.getShareable();\r\n\t\t\r\n\t\tif (bArg == (byte)0x0) // Based on argument, return\r\n\t\t\t\t\t\t\t\t\t\t\t\t// object reference\r\n\t\t\treturn (Shareable) (NewMyAppletPointsObject);\r\n\r\n          else \r\n\t\t\t    ISOException.throwIt(ISO7816.SW_WRONG_DATA);\r\n\t\t\r\n\t\treturn null; //~allow_dead_code\r\n\t}\r\n}\r\n\r\n//@ predicate is_short_of_byte(short s, byte b) = b \u003c 0 ? s == 256 + b : s == b;\r\n",
        "name": "NewMyApplet.java",
        "path": "examples/java/Java Card/NewMyApplet/NewMyApplet.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/NewMyApplet/NewMyApplet.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 158,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires system() \u0026*\u0026 0 \u003c= byMaxNbRecord \u0026*\u0026 6 \u003c= byMaxSizeRecord \u0026*\u0026 Points |-\u003e _ \u0026*\u0026 bya_FCI |-\u003e ?fci \u0026*\u0026 array_slice(fci, 0, 23, _) \u0026*\u0026 fci.length == 23 \u0026*\u0026 array_slice(byaBuffer, shOffset, shOffset + byLength, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 159,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 200,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 313,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 314,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 370,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 371,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures APDU(oApdu, buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _) \u0026*\u0026 result == buffer_;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 380,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 381,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 412,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 413,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures 0 \u003c= result \u0026*\u0026 result \u003c= 2;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 427,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 428,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 533,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 534,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 642,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 643,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures [1/2]valid() \u0026*\u0026 oApdu != null \u0026*\u0026 APDU(oApdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 678,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 679,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures is_short_of_byte(result, byByte) \u0026*\u0026 0 \u003c= result \u0026*\u0026 result \u003c= 255;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 687,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 688,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 712,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 713,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 766,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [1/2]this.valid() \u0026*\u0026 registered_applets(?as) \u0026*\u0026 foreachp(remove\u003cApplet\u003e(this, as), semi_valid) \u0026*\u0026 mem\u003cApplet\u003e(this, as) == true \u0026*\u0026 AID(oAid);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 767,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [1/2]this.valid() \u0026*\u0026 registered_applets(as) \u0026*\u0026 foreachp(remove\u003cApplet\u003e(this, as), semi_valid) \u0026*\u0026 AID(oAid) \u0026*\u0026 result == null ? true : result.Shareable(?a) \u0026*\u0026 mem\u003cApplet\u003e(a, as) == true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "/**\n * Like TemplateMethod.java, but the template method is implemented as\n * while (m1()) { m2() }.\n */\n\n/*@\n// t1 should not be precise, hence we cannot just use a predicate inside a class.\npredicate_family m1_io(Class c)(any t1; boolean result, any t2);\npredicate_family m2_io(Class c)(any t1; any t2);\n@*/\n\n/*@\npredicate template_io(any t1, Class c, any t2) =\n  m1_io(c)(t1, ?return_value, ?t_m1)\n  \u0026*\u0026 return_value ?\n    m2_io(c)(t_m1, ?t_m2)\n    \u0026*\u0026 template_io(t_m2, c, t2)\n  :\n    t2 == t_m1\n  ;\n@*/\n\npublic abstract class ComplexCalculation {\n  //@ predicate token(any x) = x == default_value\u003cany\u003e \u0026*\u0026 false;\n\n  public void template()\n    /*@ requires this.token(?t1)\n      \u0026*\u0026 template_io(t1, this.getClass(), ?t2);\n    @*/\n    //@ ensures this.token(t2);\n  {\n    //@ open template_io(_, _, _);\n    while (m1())\n        /*@ invariant\n            this.token(?t_cur)\n            \u0026*\u0026 m1_io(this.getClass())(t_cur, ?return_val, ?t_m1)\n            \u0026*\u0026 return_val ?\n              m2_io(this.getClass())(t_m1, ?t_m2)\n              \u0026*\u0026 template_io(t_m2, this.getClass(), t2)\n            :\n              t2 == t_m1;\n        @*/\n    {\n      m2();\n      //@ open template_io(_, this.getClass(), t2);\n    }\n  }\n  \n  // The paper formalization does only allow expressions as guard for while loops.\n  // This version of the template method is written as such.\n  public void template_guard_is_expression()\n    /*@ requires this.token(?t1)\n      \u0026*\u0026 template_io(t1, this.getClass(), ?t2);\n    @*/\n    //@ ensures this.token(t2);\n  {\n    //@ open template_io(_, _, ?t_open1);\n    boolean return_val = m1();\n    while (return_val)\n        /*@ invariant\n          this.token(?t_cur)\n          \u0026*\u0026 return_val ?\n            m2_io(this.getClass())(t_cur, ?t_m2)\n            \u0026*\u0026 template_io(t_m2, this.getClass(), t2)\n          : t2 == t_cur;\n        @*/\n    {\n      m2();\n      //@ open template_io(_, this.getClass(), t2);\n      return_val = m1();\n    }\n  }\n\n  public abstract boolean m1();\n    //@ requires token(?t1) \u0026*\u0026 m1_io(this.getClass())(t1, ?result_value, ?t2);\n    //@ ensures token(t2) \u0026*\u0026 result == result_value;\n  \n  public abstract void m2();\n    //@ requires token(?t1) \u0026*\u0026 m2_io(this.getClass())(t1, ?t2);\n    //@ ensures token(t2);\n}\n\n\n// The rest is the same as the TemplateMethod.java file, except that m1 now must\n// return a boolean such that it can be used as the while guard.\n\n/*@\npredicate_family_instance m1_io(Adder)(adder_place t1, boolean result, adder_place t2) =\n  t1 == adder_place(?value)\n  \u0026*\u0026 value == Short.MAX_VALUE ?\n    t2 == t1 \u0026*\u0026 result == false\n  :\n    t2 == adder_place(value + 1) \u0026*\u0026 result == true\n;\npredicate_family_instance m2_io(Adder)(adder_place t1, adder_place t2) =\n  t1 == adder_place(?value)\n  \u0026*\u0026 value \u003e Short.MAX_VALUE - 20 ?\n    t2 == t1\n  :\n    t2 == adder_place(value + 20)\n;\ninductive adder_place = adder_place(int value);\n@*/\n/**\n * Class that does a calculation, by adding a number.\n */\npublic class Adder extends ComplexCalculation {\n  short x = 0;\n  //@ predicate token(any t1) = this.x |-\u003e ?x \u0026*\u0026 t1 == adder_place(x);\n\n  public Adder()\n    //@ requires true;\n    //@ ensures token(adder_place(0));\n  {\n  }\n\n  public boolean m1()\n    //@ requires token(?t1) \u0026*\u0026 m1_io(Adder.class)(t1, ?return_value, ?t2);\n    //@ ensures token(t2) \u0026*\u0026 result == return_value;\n  {\n    //@ open token(t1);\n    //@ open m1_io(Adder.class)(_, _, _);\n    if (x != Short.MAX_VALUE){\n      x = (short)(x + 1);\n      return true;\n    }else{\n      return false;\n    }\n  }\n  \n  public void m2()\n    //@ requires token(?t1) \u0026*\u0026 m2_io(Adder.class )(t1, ?t2);\n    //@ ensures token(t2);\n  {\n    //@ open token(t1);\n    //@ open m2_io(Adder.class)(_, _);\n    if (x \u003c= Short.MAX_VALUE - 20){\n      x = (short)(x + 20);\n    }\n    //@ close token(t2);\n  }\n  \n  public int getValue()\n    //@ requires token(?t) \u0026*\u0026 exists\u003cint\u003e(?v) \u0026*\u0026 t == adder_place(v);\n    //@ ensures token(t) \u0026*\u0026 result == v;\n  {\n    return x;\n  }\n}\n\n/*@\npredicate_family_instance m1_io(Multiplier)(multiplier_place t1, boolean result, multiplier_place t2) =\n  t1 == multiplier_place(?x)\n  \u0026*\u0026 x * 2 \u003e Integer.MAX_VALUE ? // Would cause integer overflow\n    t2 == t1\n    \u0026*\u0026 result == false\n  :\n    t2 == multiplier_place(x * 2)\n    \u0026*\u0026 result == true\n;\npredicate_family_instance m2_io(Multiplier)(multiplier_place t1, multiplier_place t2) = \n  t1 == multiplier_place(?x)\n  \u0026*\u0026 x * 3 \u003e Integer.MAX_VALUE ? // Would cause integer overflow\n    t2 == t1\n  :\n    t2 == multiplier_place(x * 3)\n;\n\ninductive multiplier_place = multiplier_place(int x);\n@*/\n\n\n/**\n * Class that does a calculation, by multiplying a number.\n */\npublic class Multiplier extends ComplexCalculation {\n  int value = 1; // It is possible to have a different representation.\n  /*@\n  predicate token(any t) =\n    this.value |-\u003e ?value\n    \u0026*\u0026 value \u003e= 0\n    \u0026*\u0026 t == multiplier_place(value);\n  @*/\n  \n  public Multiplier()\n  //@ requires true;\n  //@ ensures token(multiplier_place(1));\n  {\n  }\n\n  public boolean m1()\n    //@ requires token(?t1) \u0026*\u0026 m1_io(Multiplier.class)(t1, ?return_value, ?t2);\n    //@ ensures token(t2) \u0026*\u0026 result == return_value;\n  {\n    //@ open token(t1);\n    //@ open m1_io(Multiplier.class)(_, _, _);\n    if (value \u003c= Integer.MAX_VALUE / 2){\n      value = value * 2;\n      return true;\n    }else{\n      return false;\n    }\n  } \n  \n  public void m2()\n    //@ requires token(?t1) \u0026*\u0026 m2_io(Multiplier.class)(t1, ?t2);\n    //@ ensures token(t2);\n  {\n    //@ open token(t1);\n    //@ open m2_io(Multiplier.class)(_, _);\n    if (value \u003c= Integer.MAX_VALUE / 3){\n      value = value * 3;\n    }\n    //@ close token(t2);\n  } \n  \n  public int getValue()\n    //@ requires token(?t);\n    //@ ensures token(t) \u0026*\u0026 exists\u003cint\u003e(?x) \u0026*\u0026 t == multiplier_place(x) \u0026*\u0026 result == x;\n  {\n    return value;\n    //@ close exists(value);\n  }\n}\n\n",
        "name": "TemplateMethodWhile.java",
        "path": "examples/io/template_method/TemplateMethodWhile.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/io/template_method/TemplateMethodWhile.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 29,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures this.token(t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 54,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures this.token(t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 74,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires token(?t1) \u0026*\u0026 m1_io(this.getClass())(t1, ?result_value, ?t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 75,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures token(t2) \u0026*\u0026 result == result_value;"
        },
        {
          "limitHit": false,
          "lineNumber": 78,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires token(?t1) \u0026*\u0026 m2_io(this.getClass())(t1, ?t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 79,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures token(t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 111,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 112,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures token(adder_place(0));"
        },
        {
          "limitHit": false,
          "lineNumber": 117,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires token(?t1) \u0026*\u0026 m1_io(Adder.class)(t1, ?return_value, ?t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 118,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures token(t2) \u0026*\u0026 result == return_value;"
        },
        {
          "limitHit": false,
          "lineNumber": 131,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires token(?t1) \u0026*\u0026 m2_io(Adder.class )(t1, ?t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 132,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures token(t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 143,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires token(?t) \u0026*\u0026 exists\u003cint\u003e(?v) \u0026*\u0026 t == adder_place(v);"
        },
        {
          "limitHit": false,
          "lineNumber": 144,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures token(t) \u0026*\u0026 result == v;"
        },
        {
          "limitHit": false,
          "lineNumber": 185,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 186,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures token(multiplier_place(1));"
        },
        {
          "limitHit": false,
          "lineNumber": 191,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires token(?t1) \u0026*\u0026 m1_io(Multiplier.class)(t1, ?return_value, ?t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 192,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures token(t2) \u0026*\u0026 result == return_value;"
        },
        {
          "limitHit": false,
          "lineNumber": 205,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires token(?t1) \u0026*\u0026 m2_io(Multiplier.class)(t1, ?t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 206,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures token(t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 217,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires token(?t);"
        },
        {
          "limitHit": false,
          "lineNumber": 218,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures token(t) \u0026*\u0026 exists\u003cint\u003e(?x) \u0026*\u0026 t == multiplier_place(x) \u0026*\u0026 result == x;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class NotAnnotatedClassMain_1\n{\n  private int x; \n\n  NotAnnotatedClassMain_1(int i) {/*@ assert false; @*/x = i;}\n\n  int NotAnnotatedMethodMain_1_1(int i) {/*@ assert false; @*/return i;}\n}\n\n//@ predicate incPredicateMain(int i, int j) = j == i + 1;\n\npublic class Main\n{\n  public static void main(String[] args) \n    //@ requires true;\n    //@ ensures true; \n  {\n    int i = 1;\n    PartiallyAnnotated1 o1 = new PartiallyAnnotated1(0);\n    PartiallyAnnotatedInterface1 o1_i = o1;\n    PartiallyAnnotated2 o2 = new PartiallyAnnotated2(0);\n    PartiallyAnnotatedInterface2 o2_i = o2;\n    i = annotatedIncMain(i);\n    //@ open incPredicateMain(1,i);\n    //@ assert i == 2;\n    i = o1.annotatedIncInterface1_1(i);\n    //@ assert i == 3;\n    i = o1_i.annotatedIncInterface1_2(i);\n    //@ assert i == 4;\n    i = o1.annotatedIncClass1(i);\n    //@ assert i == 5;\n    i = o2.annotatedIncInterface2_1(i);\n    //@ assert i == 6;\n    i = o2_i.annotatedIncInterface2_2(i);\n    //@ assert i == 7;\n    i = o2.annotatedIncClass2(i);\n    //@ assert i == 8;\n\n//     System.out.println(\"Final value   \" + i);\n//     i = notAnnotatedIncMain(i);\n//     System.out.println(\"Final value++ \" + i);\n  }\n\n//   class NotAnnotatedClassMain_2\n//   {\n//     private int x; \n// \n//     NotAnnotatedClassMain_2(int i) {/*@ assert false; @*/ x = i;}\n// \n//     int NotAnnotatedMethodMain_2_1(int i) {/*@ assert false; @*/ return i;}\n//   }\n  \n  int NotAnnotatedMethodMain_1(int i) {return i;}\n\n  static int annotatedIncMain(int i)\n  //@ requires i \u003c 100;\n  //@ ensures incPredicateMain(i, result);\n  {\n    //@ close incPredicateMain(i, i + 1);\n    return ++i;\n  }\n  \n  static int notAnnotatedIncMain(int i) throws Exception\n  {\n    //@ assert false;\n    PartiallyAnnotatedInterface1 o = new PartiallyAnnotated1();\n\n    for (int j = 0; j \u003c 4; j++)\n    {\n      System.out.println(\"Foobar\");\n    }\n\n    return o.NotAnnotatedIncInterface1(i);\n  }\n  \n  int NotAnnotatedMethodMain_2(int i) throws Exception, RuntimeException {return i;}\n}\n\nclass NotAnnotatedClassMain_3 \n{\n  private int x; \n\n  NotAnnotatedClassMain_3(int i) {/*@ assert false; @*/ x = i;}\n\n  int NotAnnotatedMethodMain_3_1(int i) {/*@ assert false; @*/return i;}\n}\n",
        "name": "Main.java",
        "path": "examples/reduced_annotations/java_language/Main.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/reduced_annotations/java_language/Main.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true; "
        },
        {
          "limitHit": false,
          "lineNumber": 55,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires i \u003c 100;"
        },
        {
          "limitHit": false,
          "lineNumber": 56,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures incPredicateMain(i, result);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "// This example Java 7 program illustrates the support added to VeriFast\n// as part of the STANCE EU project for many Java 7 features, including:\n// - generics\n// - anonymous inner classes\n// - varargs (variable-length argument lists)\n// - boxing and unboxing of primitive types\n// - enhanced for loops (a.k.a. foreach loops)\n// This support is enabled through VeriFast's use of the STANCE Java frontend,\n// which is derived from OpenJDK.\n//\n// Furthermore, the example illustrates VeriFast's support for the following Java features:\n// - classes\n// - interfaces\n// - arrays\n// - class methods that implement interface methods\n// - checked and unchecked exceptions\n// - Java Collections API usage, including types List and Iterator\n\npackage mypackage;\n\nimport java.util.*;\n\n/*@\n\nfixpoint int sum(list\u003cint\u003e l){\n   switch(l) {\n     case nil : return 0;\n     case cons(i, r) : return i + sum(r);\n   }\n}\n\nfixpoint list\u003cb\u003e map\u003ca, b\u003e (fixpoint(a, b) f, list\u003ca\u003e l){\n  switch(l){\n    case nil : return nil;\n    case cons (x, r) : return cons(f (x), map(f, r));\n  }\n}\n\npredicate_family FoldFunc(Class c)(FoldFunc f, list\u003cObject\u003e in, Object acc, any info);\n\n@*/\n\ninterface FoldFunc\u003cA, T\u003e \n{    \n  T fold(T x0, A x1);  \n    //@ requires FoldFunc(this.getClass())(this, cons(x1, ?r), x0, ?info);\n    //@ ensures FoldFunc(this.getClass())(this, r, result, info);\n}\n\nclass EmptyException extends Exception \n{\n}\n\n/*@\n  \npredicate_family_instance FoldFunc(Java7Program$1.class)(FoldFunc f, list\u003cInteger\u003e in, Integer acc, list\u003cInteger\u003e info) =\n         not_null(in) == true \u0026*\u0026 acc != null \u0026*\u0026\n         sum(map(Integer_intValue, info)) == sum(map(Integer_intValue, in)) + Integer_intValue(acc); \n  \n@*/\n\npublic class Java7Program\n{\n  public static \u003cT\u003e void addAll(List\u003cT\u003e l, T... xs) throws EmptyException /*@ ensures xs.length == 0; @*/\n    //@ requires l.List(?l_es) \u0026*\u0026 [?f]xs[..] |-\u003e ?xs_es;\n    //@ ensures l.List(append(l_es, xs_es)) \u0026*\u0026 [f]xs[..] |-\u003e xs_es \u0026*\u0026 xs.length \u003e 0;\n  {\n    if (xs.length \u003e 0)\n    {\n      List\u003cT\u003e temp = Arrays.asList(xs);\n      //@ close listIsCollection(temp, temp);\n      l.addAll(temp);\n    }\n    else\n    {\n      throw new EmptyException();\n    }\n  }\n  \n  public static \u003cA, T\u003e T fold(FoldFunc\u003cA, T\u003e f, List\u003cA\u003e xs, T acc0)\n    //@ requires xs.List(?es) \u0026*\u0026 FoldFunc(f.getClass())(f, es, acc0, ?info) \u0026*\u0026 f != null;\n    //@ ensures xs.List(es) \u0026*\u0026 FoldFunc(f.getClass())(f, nil, result, info);\n  {\n    T acc = acc0;\n    \n    //@ xs.listToIterable();\n    for (A x : xs) \n      //@ requires i$.Iterator((seq_of_list)(es), _, ?n) \u0026*\u0026 FoldFunc(f.getClass())(f, drop(n, es), acc, info) \u0026*\u0026 f != null \u0026*\u0026 n \u003e= 0 \u0026*\u0026 n \u003c= length(es);\n      //@ ensures FoldFunc(f.getClass())(f, nil, acc, info) \u0026*\u0026 i$.Iterator((seq_of_list)(es), _, length(es));\n    {\n      //@ drop_n_plus_one(n, es);\n      acc = f.fold(acc, x);\n    }\n    //@ xs.destroyIterator();\n    //@ xs.iterableToList();\n    \n    return acc;\n  }\n  \n  public static void main(String... args)\n    //@ requires true;\n    //@ ensures true;\n  {\n    List\u003cInteger\u003e xs = new ArrayList\u003cInteger\u003e();\n    Integer i1 = 3;\n    Integer i2 = 5;\n    Integer i3 = 7;\n\n    try\n    {\n      addAll(xs, i1, i2, i3);\n    }\n    catch (EmptyException e)\n    {\n      //@ assert false;\n    }\n    \n    //@ list\u003cInteger\u003e exs = {i1, i2, i3};\n    \n    FoldFunc func = new FoldFunc\u003cInteger, Integer\u003e() \n    {\n      public Integer fold(Integer x0, Integer x1) \n        //@ requires FoldFunc(Java7Program$1.class)(this, cons(x1, ?r), x0, ?info);\n        //@ ensures FoldFunc(Java7Program$1.class)(this, r, result, info);\n      { \n        //@ open FoldFunc(Java7Program$1.class)(this, cons(?_o, ?_r), x0, ?_info);\n        Integer res = x0 + x1;\n        return res;\n         //@ close FoldFunc(Java7Program$1.class)(this, _r, res, _info);\n      }\n    }; \n    Integer acc = 2;\n    //@ close FoldFunc(Java7Program$1.class)(func, exs, acc, cons(acc, exs));\n    Integer vi = fold(func, xs, acc);\n    //@ open FoldFunc(Java7Program$1.class)(_, _, _, _);\n    int v = vi;\n    \n    //@ assert v == 17;\n    \n    //@ boolean is_thrown = false;\n    try\n    {\n      addAll(xs);\n    }\n    catch (EmptyException e)\n    {\n      //@ is_thrown = true;\n    }\n    //@ assert is_thrown;\n    \n    Object i = null;\n    //@ is_thrown = false;\n    try\n    {\n      if (i == null)\n        throw new NullPointerException();\n      else\n      {}\n    }\n    catch (NullPointerException e)\n    {\n      //@ is_thrown = true;\n    }\n    //@ assert is_thrown;\n  }\n}\n",
        "name": "Java7Program.java",
        "path": "examples/java/frontend/big_example/Java7Program.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/big_example/Java7Program.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 45,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires FoldFunc(this.getClass())(this, cons(x1, ?r), x0, ?info);"
        },
        {
          "limitHit": false,
          "lineNumber": 46,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures FoldFunc(this.getClass())(this, r, result, info);"
        },
        {
          "limitHit": false,
          "lineNumber": 64,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires l.List(?l_es) \u0026*\u0026 [?f]xs[..] |-\u003e ?xs_es;"
        },
        {
          "limitHit": false,
          "lineNumber": 65,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures l.List(append(l_es, xs_es)) \u0026*\u0026 [f]xs[..] |-\u003e xs_es \u0026*\u0026 xs.length \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 80,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires xs.List(?es) \u0026*\u0026 FoldFunc(f.getClass())(f, es, acc0, ?info) \u0026*\u0026 f != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 81,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures xs.List(es) \u0026*\u0026 FoldFunc(f.getClass())(f, nil, result, info);"
        },
        {
          "limitHit": false,
          "lineNumber": 87,
          "offsetAndLengths": [
            [
              6,
              13
            ]
          ],
          "preview": "      //@ requires i$.Iterator((seq_of_list)(es), _, ?n) \u0026*\u0026 FoldFunc(f.getClass())(f, drop(n, es), acc, info) \u0026*\u0026 f != null \u0026*\u0026 n \u003e= 0 \u0026*\u0026 n \u003c= length(es);"
        },
        {
          "limitHit": false,
          "lineNumber": 88,
          "offsetAndLengths": [
            [
              6,
              12
            ]
          ],
          "preview": "      //@ ensures FoldFunc(f.getClass())(f, nil, acc, info) \u0026*\u0026 i$.Iterator((seq_of_list)(es), _, length(es));"
        },
        {
          "limitHit": false,
          "lineNumber": 100,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 101,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 122,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires FoldFunc(Java7Program$1.class)(this, cons(x1, ?r), x0, ?info);"
        },
        {
          "limitHit": false,
          "lineNumber": 123,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures FoldFunc(Java7Program$1.class)(this, r, result, info);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package be.fedict.neweidapplet;\r\n\r\n\tpublic class NewEidPoints implements INewEidPoints {\r\n\r\n\t\t//@ javacard.framework.Applet applet;\r\n\t\t//@ predicate Shareable(javacard.framework.Applet a) = [_]applet |-\u003e a;\r\n\r\n\t\tpublic byte sharePoints(byte points)\r\n\t\t    //@ requires true;\r\n\t\t    //@ ensures true;\r\n\t\t{\r\n\t        return points \u003c= 125 ? (byte) (points + 2) : points;\r\n\t\t}\r\n\t\t\r\n\t\t/*@ lemma void getShareable() requires [_]applet |-\u003e ?a; ensures Shareable(a); {} @*/\r\n\r\n\t}",
        "name": "NewEidPoints.java",
        "path": "examples/java/Java Card/NewEidCard/NewEidPoints.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/NewEidCard/NewEidPoints.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              6,
              13
            ]
          ],
          "preview": "\t\t    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              6,
              12
            ]
          ],
          "preview": "\t\t    //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class Main\r\n{\r\n  public static void main(String[] args) \r\n    //@ requires true;\r\n    //@ ensures true; \r\n  {\r\n    Super o = new Sub();\r\n    int i = 0;\r\n    i = o.increment(i);\r\n    //@ assert i == 1;\r\n  }\r\n}\r\n",
        "name": "Main.java",
        "path": "examples/java/out_of_order_jarsrc/in_order/Main.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/out_of_order_jarsrc/in_order/Main.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true; \r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package wallet;\nimport javacard.framework.*;\n\npublic final class EPhone extends Applet {\n\n    private static final byte EPhone_CLA = (byte)0xB0;\n\n    private static final byte GET_BALANCE = (byte) 0x10;\n    private static final byte CREDIT = (byte) 0x20;\n\n    private static final byte SW_EWALLET_AID_NOT_EXIST = (byte) 0x5300;\n    private static final byte SW_FAILED_TO_OBTAIN_SIO = (byte) 0x5200;\n    private static final byte SW_DOES_NOT_IMPLEMENT_INTERFACE = (byte) 0x2000;\n    private static final byte SW_AMOUNT_TO_HIGH = (byte) 0x2222;\n    \n    static final byte max_transaction_amount = 90;\n    private static final short max_balance = 120;\n    private static short balance;\n    private static byte[] ewallet_aid_bytes; //= new byte[] {(byte)0x15, (byte)0xEF, (byte)0x4D, (byte)0x55, (byte)0x86, (byte)0xB3};\n    \n    /*@\n    predicate valid() = balance |-\u003e ?phone_balance \u0026*\u0026 0 \u003c= phone_balance \u0026*\u0026 phone_balance \u003c= max_balance\n    \t\t\t\u0026*\u0026 ewallet_aid_bytes |-\u003e ?e_array \u0026*\u0026 e_array != null \n    \t\t\t\u0026*\u0026 array_slice(e_array,0,e_array.length,_) \u0026*\u0026 e_array.length == 6;\n    @*/\n\n    public static void install(byte[] bArray, short bOffset, byte bLength)\n    //@ requires class_init_token(EPhone.class) \u0026*\u0026 system();\n    //@ ensures true;\n    {\n        EPhone Ephone = new EPhone();\n        Ephone.register();\n    }\n\n    protected EPhone() \n    //@ requires class_init_token(EPhone.class);\n    //@ ensures valid();\n    {\n        //@ init_class();\n        balance = 0;\n        ewallet_aid_bytes = new byte[] {(byte)0xA8, (byte)0xB6, (byte)0xD1, (byte)0x26, (byte)0xB1, (byte)0xB3};\n        //@ close valid();\n    }\n\n    public void process(APDU apdu)\n    /*@\n    requires\n      current_applet(this) \u0026*\u0026\n      [1/2]valid() \u0026*\u0026\n      apdu != null \u0026*\u0026\n      APDU(apdu, ?buffer) \u0026*\u0026\n      array_slice(buffer, 0, buffer.length, _);\n    @*/\n    /*@\n    ensures\n      current_applet(this) \u0026*\u0026\n      [1/2]valid() \u0026*\u0026\n      apdu != null \u0026*\u0026\n      APDU(apdu, buffer) \u0026*\u0026\n      array_slice(buffer, 0, buffer.length, _);\n    @*/\n    {\n        byte[] abuffer = apdu.getBuffer();\n\n        if(selectingApplet())\n            return;\n\n        if(abuffer[ISO7816.OFFSET_CLA] != EPhone_CLA)\n            ISOException.throwIt(ISO7816.SW_CLA_NOT_SUPPORTED);\n\n        switch(abuffer[ISO7816.OFFSET_INS]){\n            case GET_BALANCE: getBalance(apdu);return;\n            case CREDIT: credit(apdu);return;\n            default: ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);\n        }\n    }\n\n    private void credit(APDU apdu)\n    //@requires current_applet(this) \u0026*\u0026 APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 [1/2]this.valid();\n    //@ensures current_applet(this) \u0026*\u0026 APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 [1/2]this.valid();\n    {\n        byte[] abuffer = apdu.getBuffer();\n\n        byte count = abuffer[ISO7816.OFFSET_LC];\n        \n        if(count != 1)\n            ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\n\n        short amount = (short)abuffer[ISO7816.OFFSET_CDATA];\n        if(amount \u003c 0)\n            ISOException.throwIt(ISO7816.SW_WRONG_DATA);\n        if(amount \u003e max_transaction_amount)\n            ISOException.throwIt(ISO7816.SW_WRONG_DATA);\n            \n        //@ open [1/2]valid();\n        short newBalance = (short)(balance + amount);\n        //@ close [1/2]valid();\n            \n        if(newBalance \u003e max_balance)\n            ISOException.throwIt(SW_AMOUNT_TO_HIGH);\n\tJCSystem.beginTransaction();\n        makeBankcardDebit(amount);\n        //@ open valid();\n        balance = newBalance;\n        //@ close valid();\n        JCSystem.commitTransaction();\n    }\n\n    private void getBalance(APDU apdu) \n    //@requires APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 registered_applets(?as) \u0026*\u0026 mem\u003cApplet\u003e(this,as)==true \u0026*\u0026 foreachp\u003cApplet\u003e(remove\u003cApplet\u003e(this, as),semi_valid) \u0026*\u0026 [1/2]this.valid();\n    //@ensures APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 registered_applets(as) \u0026*\u0026 foreachp\u003cApplet\u003e(remove\u003cApplet\u003e(this, as),semi_valid) \u0026*\u0026 [1/2]this.valid();\n    {\n    \tbyte[] abuffer = apdu.getBuffer();\n\n        apdu.setOutgoing();\n        apdu.setOutgoingLength((byte)1);\n\n        // place balance in the APDU buffer\n        //@ open [1/2]valid();\n        abuffer[0] = (byte)balance;\n        //@ close [1/2]valid();\n\n        apdu.sendBytes((short)0, (short)1);\n    }\n\n    private void makeBankcardDebit(short amount)\n    //@ requires 0 \u003c= amount \u0026*\u0026 amount \u003c= max_transaction_amount \u0026*\u0026 this.valid() \u0026*\u0026 in_transaction(this);\n    //@ ensures in_transaction(this) \u0026*\u0026 this.valid();\n    {\n    \t//@ open valid();\n        AID ewallet_aid = JCSystem.lookupAID(ewallet_aid_bytes,(short)0,(byte)ewallet_aid_bytes.length);\n\t//@ close valid();\n        if(ewallet_aid == null)\n           ISOException.throwIt(SW_EWALLET_AID_NOT_EXIST);\n\n        Shareable sio = JCSystem.getAppletShareableInterfaceObject(ewallet_aid, (byte)0x01);\n\t        \n        if(sio == null)\n          ISOException.throwIt(SW_FAILED_TO_OBTAIN_SIO);\n\n        if(sio instanceof EWalletInterface){\n          EWalletInterface WalletInterface = (EWalletInterface)sio;\n        \n          byte[] pin = new byte[] {(byte)1,(byte)1,(byte)1,(byte)1};\n          //@ close full_valid(this);\n          //@ assert registered_applets(?as);\n          //@ foreachp_unremove\u003cApplet\u003e(this,as);\n          //@ mem_registered_applets_is(this);\n          //@ assert sio.Shareable(?a);\n          //@ set_current_applet(a);\n          //@ foreachp_remove\u003cApplet\u003e(a,as);\n          //@ open full_valid(a);\n          WalletInterface.verify(pin, (short)0, (byte)(short)pin.length);\n          WalletInterface.debit((byte)amount);\n          //@ close full_valid(a);\n          //@ open in_transaction0(a);\n          //@ assert registered_applets(?as1);\n          //@ foreachp_unremove\u003cApplet\u003e(a, as1);\n          //@ is_registered_applets_mem(this);\n          //@ set_current_applet(this);\n          //@ foreachp_remove\u003cApplet\u003e(this, as1);\n          //@ open full_valid(this);\n          \n        }else\n          ISOException.throwIt(SW_DOES_NOT_IMPLEMENT_INTERFACE);\n    }\n}",
        "name": "EPhone.java",
        "path": "examples/java/Java Card/shareable-applets/EPhone.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/shareable-applets/EPhone.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires class_init_token(EPhone.class) \u0026*\u0026 system();"
        },
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 35,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires class_init_token(EPhone.class);"
        },
        {
          "limitHit": false,
          "lineNumber": 36,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 126,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= amount \u0026*\u0026 amount \u003c= max_transaction_amount \u0026*\u0026 this.valid() \u0026*\u0026 in_transaction(this);"
        },
        {
          "limitHit": false,
          "lineNumber": 127,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures in_transaction(this) \u0026*\u0026 this.valid();"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package be.fedict.neweidapplet;\r\n\r\n/*@\r\npredicate file_element(File child;) = child == null ? true : [1/2]child.File(_, _, _);\r\npredicate valid_id(File child;) = [_]child.fileID |-\u003e_;\r\n@*/\r\n\r\npublic class DedicatedFile extends File {\r\n\r\n\t/*@ predicate File(short theFileID, boolean activeState, triple\u003cDedicatedFile, list\u003cFile\u003e, any\u003e info) = \r\n\t\tDedicatedFile(theFileID, ?dedFile, activeState, ?siblist, ?oinfo) \u0026*\u0026 info == triple(dedFile, siblist, oinfo); @*/\r\n\t/*@ predicate DedicatedFile(short fileID, DedicatedFile parentFile, boolean activeState, list\u003cFile\u003e siblist, any info) = \r\n\t\tthis.File(File.class)(fileID, activeState, _) \u0026*\u0026 this.parentFile |-\u003e parentFile \u0026*\u0026 this.siblings |-\u003e ?siblings \u0026*\u0026 \r\n\t\tsiblings != null \u0026*\u0026 siblings.length == MAX_SIBLINGS \u0026*\u0026 array_slice(siblings, 0, siblings.length, ?sb) \u0026*\u0026 this.number |-\u003e ?number \u0026*\u0026 siblist == take(number, sb) \u0026*\u0026\r\n\t\tnumber \u003e= 0 \u0026*\u0026 number \u003c= DedicatedFile.MAX_SIBLINGS \u0026*\u0026 info == unit \u0026*\u0026\r\n\t\tforeachp(take(number, sb), valid_id); @*/\r\n\r\n\t// link to parent DF\r\n\tpublic DedicatedFile parentFile;\r\n\t// list of sibling files (either EF or DF)\r\n\tprivate static final byte MAX_SIBLINGS = 10;\r\n\tprivate File[] siblings;\r\n\t// number of siblings\r\n\tprivate byte number;\r\n\t// constructor only used by MasterFile\r\n\tprotected DedicatedFile(short fid) \r\n  \t    //@ requires true;\r\n      \t    //@ ensures DedicatedFile(fid, null, true, nil, _);\r\n\t{\r\n\t\tsuper(fid);\r\n\t\tparentFile = null;\r\n\t\tsiblings = new File[MAX_SIBLINGS];\r\n\t\tnumber = 0;\r\n\t\t//@ assert this.siblings |-\u003e ?siblings;\r\n\t\t//@ assert array_slice(siblings, 0, siblings.length, ?siblist);\r\n\t\t//@ close foreachp(nil, valid_id);\r\n\t\t//@ close DedicatedFile(fid, null, true, nil, _);\r\n\t}\r\n\tpublic DedicatedFile(short fid, DedicatedFile parent) \r\n  \t    //@ requires parent != null \u0026*\u0026 parent.DedicatedFile(?fileID, ?pf, ?activeState, ?siblist, ?info);\r\n      \t    //@ ensures DedicatedFile(fid, parent, true, nil, _) \u0026*\u0026 parent.DedicatedFile(fileID, pf, activeState, (length(siblist) \u003c DedicatedFile.MAX_SIBLINGS ? append(siblist, cons(this, nil)) : siblist), info);\r\n\t{\r\n\t\tsuper(fid);\r\n\t\tparentFile = parent;\r\n\t\tsiblings = new File[MAX_SIBLINGS];\r\n\t\tnumber = 0;\r\n\t\tparent.addSibling(this);\r\n\t\t//@ close foreachp(nil, valid_id);\r\n\t\t//@ close DedicatedFile(fid, parent, true, nil, _);\r\n\t}\r\n\tpublic DedicatedFile getParent() \r\n\t    //@ requires DedicatedFile(?fid, ?parentfile, ?active, ?siblist, ?info);\r\n\t    //@ ensures DedicatedFile(fid, parentfile, active, siblist, info) \u0026*\u0026 result == parentfile;\r\n\t{\r\n\t\t//@ open DedicatedFile(fid, parentfile, active, siblist, info);\r\n\t\treturn parentFile;\r\n\t\t//@ close DedicatedFile(fid, parentfile, active, siblist, info);\r\n\t}\r\n\t\r\n\tprotected void addSibling(File s) \r\n  \t    //@ requires DedicatedFile(?fileID, ?parentFile, ?activeState, ?siblist, ?info) \u0026*\u0026 valid_id(s);\r\n  \t    /*@ ensures DedicatedFile(fileID, parentFile, activeState, ?newSibList, info)\r\n  \t    \t\t\u0026*\u0026 newSibList == (length(siblist) \u003c MAX_SIBLINGS ? append(siblist, cons(s, nil)) : siblist)\r\n  \t    \t\t\u0026*\u0026 length(siblist) \u003c MAX_SIBLINGS ? mem(s, newSibList) == true : true; @*/\r\n\t{\r\n\t\t//@ open DedicatedFile(fileID, parentFile, activeState, siblist, info);\r\n\t\t//@ assert array_slice(?thesiblings, _, _, ?sb);\r\n\t\t//@ int snumber = length(siblist);\r\n\t\tif (number \u003c MAX_SIBLINGS) {\r\n\t\t\tsiblings[number++] = s;\r\n\t\t\t//@ take_one_more(snumber, update(snumber, s, sb));\r\n\t\t\t//@ assert array_slice(thesiblings, _, _, ?sb2);\r\n\t\t\t//@ assert sb2 == update(snumber, s, sb);\r\n\t\t\t//@ assert nth(snumber, update(snumber, s, sb)) == s;\r\n\t\t\t//@ assert take(snumber, sb) == take(snumber, update(snumber, s, sb));\r\n\t\t\t//@ assert take(snumber + 1, update(snumber, s, sb)) == append(take(snumber, update(snumber, s, sb)), cons(nth(snumber, update(snumber, s, sb)), nil));\r\n\t\t\t//@ close foreachp(nil, valid_id);\r\n\t\t\t//@ close foreachp(cons(s, nil), valid_id);\r\n\t\t\t//@ foreachp_append(take(snumber, sb), cons(s, nil));\t\r\n\t\t}\r\n\t\t\r\n\t\t/*@ close DedicatedFile(fileID, parentFile, activeState,\t\t \r\n\t\t\tsnumber \u003c MAX_SIBLINGS ? append(take(snumber, siblist), cons(s, nil)) : siblist, \r\n\t\t\tinfo); @*/\r\n\t}\r\n\r\n\tpublic File getSibling(short fid) \r\n  \t    //@ requires [?f]DedicatedFile(?fileID, ?parentFile, ?activeState, ?siblist, ?info);\r\n      \t    //@ ensures [f]DedicatedFile(fileID, parentFile, activeState, siblist, info) \u0026*\u0026 result == null ? true : mem(result, siblist) == true;\r\n\t{\r\n\t\t//@ open DedicatedFile(fileID, parentFile, activeState, siblist, info);\r\n\t\t//@ assert [f]array_slice(?thesiblings, _, _, ?sb);\r\n\t\t//@ int snumber = length(siblist);\r\n\t\tfor (byte i = 0; i \u003c number; i++) \r\n\t\t/*@ invariant i \u003e= 0 \u0026*\u0026 [f]this.File(File.class)(fileID, activeState, _) \u0026*\u0026 [f]this.parentFile |-\u003e parentFile \u0026*\u0026 [f]number |-\u003e (byte) length(siblist) \u0026*\u0026 [f]this.siblings |-\u003e thesiblings \u0026*\u0026 [f]array_slice(thesiblings, 0, thesiblings.length, sb)\r\n\t\t      \u0026*\u0026 [f]foreachp(siblist, valid_id); @*/\r\n\t\t{\r\n\t\t\t//@ assert 0 \u003c= i \u0026*\u0026 i \u003c thesiblings.length;\r\n\t\t\tFile fl = siblings[i];\r\n\t\t\t//@ assert nth(i, siblist) == fl;\r\n\t\t\t//@ int tmp = thesiblings.length;\r\n\t\t\t//@ assert snumber \u003c= tmp;\r\n\t\t\t//@ nth_take(i, snumber, sb);\r\n\t\t\t//@ assert nth(i, take(snumber, sb)) == nth(i, sb);\r\n\t\t\t//@ assert nth(i, take(snumber, sb)) == nth(i, sb);\r\n\t\t\t//@ assert nth(i, siblist) == fl;\r\n\t\t\t//@ mem_nth(i, siblist);\r\n\t\t\t//@ foreachp_remove\u003cFile\u003e(fl, siblist);\r\n\t\t\tif (fl != null \u0026\u0026 fl.getFileID() == fid) {\r\n\t\t\t\t//@ foreachp_unremove\u003cFile\u003e(fl, siblist);\r\n\t\t\t\treturn fl;\r\n\t\t\t\t//@ close [f]DedicatedFile(fileID, parentFile, activeState, siblist, info);\r\n\t\t\t}\r\n\t\t\t//@ foreachp_unremove\u003cFile\u003e(fl, siblist);\r\n\t\t}\r\n\t\t//@ close [f]DedicatedFile(fileID, parentFile, activeState, siblist, info);\r\n\t\treturn null;\r\n\t}\r\n\r\n        /*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic short getFileID() \r\n\t    //@ requires [?f]valid_id(this);\r\n\t    //@ ensures [f]valid_id(this);\r\n\t{\r\n\t\t//@ open [f]valid_id(this);\r\n\t\tFile thiz = this;\r\n\t\treturn fileID;\r\n\t\t//@ close [f]valid_id(this);\r\n\t}\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic void setActive(boolean b)\r\n\t    //@ requires File(?fid, _, ?info);\r\n\t    //@ ensures File(fid, b, info);\r\n\t{\r\n\t\t//@ open File(fid, _, info);\r\n\t\t//@ open DedicatedFile(fid, ?d1, _, ?siblist, ?info2);\r\n\t\tFile thiz = this;\r\n\t\t//@ open thiz.File(fid, _, ?info3);\r\n\t\tactive = b;\r\n\t\t//@ close thiz.File(fid, b, info3);\r\n\t\t//@ close DedicatedFile(fid, d1, b, siblist, info2);\r\n\t\t//@ close File(fid, b, info);\r\n\t}\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic boolean isActive() \r\n\t    //@ requires [?f]File(?fid, ?state, ?info);\r\n\t    //@ ensures [f]File(fid, state, info) \u0026*\u0026 result == state;\r\n\t{\r\n\t\t//@ open [f]File(fid, state, info);\r\n\t\t//@ open [f]DedicatedFile(fid, ?d1, state, ?siblist, ?info2);\r\n\t\t//@ open this.File(File.class)(fid, state, ?info3);\r\n\t\treturn active;\r\n\t\t//@ close [f]this.File(File.class)(fid, state, info3);\r\n\t\t//@ close [f]DedicatedFile(fid, d1, state, siblist, info2);\r\n\t\t//@ close [f]File(fid, state, info);\r\n\t}\r\n\t\r\n\t/*@ \r\n\tlemma void castFileToDedicated()\r\n            requires [?f]File(?fid, ?state, ?info);\r\n            ensures switch (info) { case triple(dedFile, siblist, oinfo): return [f]DedicatedFile(fid, dedFile, state, siblist, oinfo); } ;\r\n\t{\r\n\t    open [f]File(fid, state, _);\r\n    \t}\r\n\r\n\tlemma void castDedicatedToFile()\r\n            requires [?f]DedicatedFile(?fid, ?dedFile, ?state, ?siblist, ?oinfo);\r\n            ensures [f]File(fid, state, triple(dedFile, siblist, oinfo));\r\n\t{\r\n\t    close [f]File(fid, state, triple(dedFile, siblist, oinfo));\r\n    \t}\r\n    \t@*/\r\n}\r\n",
        "name": "DedicatedFile.java",
        "path": "examples/java/Java Card/NewEidCard/DedicatedFile.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/NewEidCard/DedicatedFile.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 26,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures DedicatedFile(fid, null, true, nil, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 39,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires parent != null \u0026*\u0026 parent.DedicatedFile(?fileID, ?pf, ?activeState, ?siblist, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 40,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures DedicatedFile(fid, parent, true, nil, _) \u0026*\u0026 parent.DedicatedFile(fileID, pf, activeState, (length(siblist) \u003c DedicatedFile.MAX_SIBLINGS ? append(siblist, cons(this, nil)) : siblist), info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 51,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires DedicatedFile(?fid, ?parentfile, ?active, ?siblist, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 52,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures DedicatedFile(fid, parentfile, active, siblist, info) \u0026*\u0026 result == parentfile;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 60,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires DedicatedFile(?fileID, ?parentFile, ?activeState, ?siblist, ?info) \u0026*\u0026 valid_id(s);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 87,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires [?f]DedicatedFile(?fileID, ?parentFile, ?activeState, ?siblist, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 88,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures [f]DedicatedFile(fileID, parentFile, activeState, siblist, info) \u0026*\u0026 result == null ? true : mem(result, siblist) == true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 121,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires [?f]valid_id(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 122,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures [f]valid_id(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 131,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires File(?fid, _, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 132,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures File(fid, b, info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 145,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires [?f]File(?fid, ?state, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 146,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures [f]File(fid, state, info) \u0026*\u0026 result == state;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "abstract class A \r\n{\r\n  //@ predicate pred() = true;\r\n\r\n  public A()\r\n    //@ requires true;\r\n    //@ ensures pred();\r\n  {\r\n    //@ close pred();\r\n  }\r\n\r\n  public void m()\r\n    //@ requires pred();\r\n    //@ ensures pred();\r\n  {\r\n  }\r\n}\r\n\r\nclass B extends A \r\n{\r\n  public B()\r\n\r\n\r\n  {\r\n    super();\r\n  }\r\n}\r\n\r\nclass C \r\n{\r\n  public void m()\r\n\r\n\r\n  {\r\n    B b = new B();\r\n  }\r\n}\r\n",
        "name": "NoOverrideNoUsage.java",
        "path": "examples/java/override_methods/NoOverrideNoUsage.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/override_methods/NoOverrideNoUsage.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures pred();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires pred();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures pred();\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package be.fedict.neweidapplet;\r\n\r\nimport javacard.framework.Shareable;\r\n\r\n\r\npublic interface INewEidPoints extends Shareable {\r\n\t\r\n\tbyte sharePoints (byte points);\r\n\t    //@ requires true;\r\n\t    //@ ensures true;\r\n\r\n}\r\n",
        "name": "INewEidPoints.java",
        "path": "examples/java/Java Card/NewEidCard/INewEidPoints.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/NewEidCard/INewEidPoints.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import java.util.*;\n\npublic class Varargs_desugared\n{\n  public static void addAll(List l,  Object[] xs)\n    //@ requires l.List(?l_es) \u0026*\u0026 [?f]xs[..] |-\u003e ?l_xs; \n    //@ ensures l.List(append(l_es, l_xs)) \u0026*\u0026 [f]xs[..] |-\u003e l_xs; \n  {\n    List temp = Arrays.asList(xs);\n    //@ close listIsCollection(temp, temp);\n    l.addAll(temp);\n  }\n\n  public static void main(String[] args)\n    //@ requires true;\n    //@ ensures true;\n  {\n    List l = new ArrayList();\n    addAll(l, new Object[]{new Object(), new Object(), new Object()});\n  }\n}\n",
        "name": "Varargs_desugared.java",
        "path": "examples/java/frontend/varargs/Varargs_desugared.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/varargs/Varargs_desugared.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires l.List(?l_es) \u0026*\u0026 [?f]xs[..] |-\u003e ?l_xs; "
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures l.List(append(l_es, l_xs)) \u0026*\u0026 [f]xs[..] |-\u003e l_xs; "
        },
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public interface Inter\r\n{\r\n  public int increment(int i);\r\n    //@ requires i \u003c 100;\r\n    //@ ensures result == i + 1;\r\n}\r\n",
        "name": "Inter.java",
        "path": "examples/java/out_of_order_jarsrc/in_order/Inter.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/out_of_order_jarsrc/in_order/Inter.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires i \u003c 100;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class Super implements Inter\r\n{\r\n  public int increment(int i)\r\n    //@ requires i \u003c 100;\r\n    //@ ensures result == i + 1;\r\n  {\r\n    return ++i;\r\n  }\r\n}\r\n",
        "name": "Super.java",
        "path": "examples/java/out_of_order_jarsrc/in_order/Super.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/out_of_order_jarsrc/in_order/Super.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires i \u003c 100;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import subpackage.*;\n\nclass Main \n{\n  public static void main(String[] args) \n    //@ requires true;\n    //@ ensures true; \n  {\n    Subpackage o = new Subpackage();\n    //@ int i = fixpoint1(0);\n    //@ close predicate1();\n    //@ open predicate1();\n    //@ lemma1();\n  }\n}\n",
        "name": "Main_package_include.java",
        "path": "examples/java/ghost_imports/Main_package_include.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/ghost_imports/Main_package_include.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true; "
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import java.util.*;\n\npublic class Foreach_desugared\n{\n  public static void main(String[] args)\n    //@ requires true;\n    //@ ensures true;\n  {\n    List ints = new ArrayList();\n    Integer i1 = new Integer(1);\n    Integer i2 = new Integer(2);\n    Integer i3 = new Integer(3);\n    Integer i4 = new Integer(4);\n    ints.add(i1); ints.add(i2); ints.add(i3); ints.add(i4);\n\n    //@ assert ints.List(?es);\n    int result = 0;\n    {\n      //@ ints.listToIterable();\n      Iterator iSSS = ints.iterator();\n      while (iSSS.hasNext())\n        //@ requires iSSS.Iterator((seq_of_list)(es), _, ?n) \u0026*\u0026 n \u003e= 0 \u0026*\u0026 n \u003c= length(es);\n        //@ ensures  iSSS.Iterator((seq_of_list)(es), _, length(es));\n      {\n        Integer x = (Integer) iSSS.next();\n        {\n          result += x.intValue();\n        }\n      }\n      //@ ints.destroyIterator();\n      //@ ints.iterableToList();\n    }\n  }\n}\n\n\n",
        "name": "Foreach_desugared.java",
        "path": "examples/java/frontend/foreach/Foreach_desugared.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/foreach/Foreach_desugared.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires iSSS.Iterator((seq_of_list)(es), _, ?n) \u0026*\u0026 n \u003e= 0 \u0026*\u0026 n \u003c= length(es);"
        },
        {
          "limitHit": false,
          "lineNumber": 22,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures  iSSS.Iterator((seq_of_list)(es), _, length(es));"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package newepurse;\n\nimport javacard.framework.*;\n\nimport org.globalplatform.GPSystem;\nimport org.globalplatform.SecureChannelx;\n\n/*@\n\nfixpoint boolean non_null(list\u003cObject\u003e os) {\n    switch (os) {\n        case nil: return true;\n        case cons(o0, os0): return o0 != null \u0026\u0026 non_null(os0);\n    }\n}\n\nlemma void non_null_nth(list\u003cObject\u003e os, int i)\n    requires 0 \u003c= i \u0026*\u0026 i \u003c length(os) \u0026*\u0026 non_null(os) == true;\n    ensures nth(i, os) != null;\n{\n    switch (os) {\n        case nil:\n        case cons(o0, os0):\n            if (i != 0)\n                non_null_nth(os0, i - 1);\n    }\n}\n\n@*/\n\npublic final class NewEPurseApplet extends Applet {\n\n    /*** Constants ***/\n    \n    public static final byte EPURSE_CLA = ISO7816.CLA_ISO7816;\n\n    public static final byte GET_BALANCE_INS = 0x01;\n    public static final byte CREDIT_INS = 0x02;\n    public static final byte DEBIT_INS = 0x03;\n    public static final byte SET_LIMIT_INS = 0x04;\n    public static final byte ADD_CLIENT_APPLET_INS = 0x05;\n    \n    public static final short SW_INVALID_AID = 0x42;\n    public static final short SW_CLIENT_CAPACITY_EXCEEDED = 0x43;\n    public static final short SW_INVALID_STATE = 0x44;\n    public static final short SW_INVALID_CLIENT = 0x45;\n    public static final short SW_INVALID_CLIENT_LIMIT = 0x46;\n    public static final short SW_CLIENT_LIMIT_EXCEEDED = 0x47;\n\n    private static final short INITIAL_BALANCE_LIMIT = 100;\n    private static final short CLIENT_NUMBER_LIMIT = 10;\n\n\n    /*** Instance variables ***/\n    \n    private short balance;\n    private short limit;\n\n    private AID[] clientAIDs;\n    private short[] clientLimits;\n    private short clientNumber;\n\n    private byte[] workingBuffer;\n\n    /*@\n    predicate valid() =\n        balance |-\u003e ?balance_ \u0026*\u0026\n        limit |-\u003e ?limit_ \u0026*\u0026\n        0 \u003c= balance_ \u0026*\u0026 balance_ \u003c= limit_ \u0026*\u0026\n        clientAIDs |-\u003e ?clientAIDs_ \u0026*\u0026 clientAIDs_.length == CLIENT_NUMBER_LIMIT \u0026*\u0026\n        clientLimits |-\u003e ?clientLimits_ \u0026*\u0026 clientLimits_.length == CLIENT_NUMBER_LIMIT \u0026*\u0026\n        clientNumber |-\u003e ?clientNumber_ \u0026*\u0026\n        array_slice(clientAIDs_, 0, clientNumber_, ?activeAids) \u0026*\u0026 non_null(activeAids) == true \u0026*\u0026\n        array_slice(clientAIDs_, clientNumber_, CLIENT_NUMBER_LIMIT, _) \u0026*\u0026\n        array_slice(clientLimits_, 0, CLIENT_NUMBER_LIMIT, ?limits) \u0026*\u0026\n        workingBuffer |-\u003e ?workingBuffer_ \u0026*\u0026 is_transient_byte_array(workingBuffer_) == true \u0026*\u0026 workingBuffer_.length == 16;\n    @*/\n\n    /*** Constructor ***/\n\n    /**\n     * Constructor of the EPurse applet.\n     * This constructor allocates all the memory to be used by the EPurse applet.\n     */\n    \n    private NewEPurseApplet()\n        //@ requires system();\n        //@ ensures system() \u0026*\u0026 valid();\n    {\n\tbalance = 0;\n\tlimit = INITIAL_BALANCE_LIMIT;\n\tclientAIDs = new AID[CLIENT_NUMBER_LIMIT];\n\tclientLimits = new short[CLIENT_NUMBER_LIMIT];\n\tclientNumber = 0;\n\tworkingBuffer = JCSystem.makeTransientByteArray((short) 16, JCSystem.CLEAR_ON_DESELECT);\n\t//@ close valid();\n    }\n    \n\n    /*** Methods ***/\n        \n    /**\n     * Invoked by the Card Manager to install the EPurse applet.\n     * Allocates necessary memory for use by the EPurse applet.\n     *\n     * @param bArray - the array containing installation parameters\n     * @param sOffset - the starting offset in bArray\n     * @param bLength - the length in bytes of the parameter data in bArray\n     */    \n\n    public static void install(byte[] bArray, short sOffset, byte bLength)\n        //@ requires system() \u0026*\u0026 array_slice(bArray, sOffset, sOffset + bLength, _);\n        //@ ensures true;\n    {\n        new NewEPurseApplet().register(bArray, sOffset, bLength);\n    }\n    \n    /** \n     * Process the APDU commands.\n     *\n     * @param oApdu the APDU object\n     * @exception ISO7816.SW_CLA_NOT_SUPPORTED\n     * @exception ISO7816.SW_INS_NOT_SUPPORTED\n     * TODO: complete\n     */\n    \n    public void process(APDU apdu)\n        //@ requires current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\n        //@ ensures current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\n    {\n        byte[] apduBuffer = apdu.getBuffer();\n\t// APDU header processing\n\t// CLA checking\n\tif (apduBuffer[ISO7816.OFFSET_CLA] != EPURSE_CLA)\n\t    ISOException.throwIt(ISO7816.SW_CLA_NOT_SUPPORTED);\n\t// P1 and P2 checking\n\tif (apduBuffer[ISO7816.OFFSET_P1] != 0 || apduBuffer[ISO7816.OFFSET_P2] != 0)\n\t    ISOException.throwIt(ISO7816.SW_WRONG_P1P2);\n\t// INS checking and dispatching\n\tswitch (apduBuffer[ISO7816.OFFSET_INS]) {\n\tcase GET_BALANCE_INS :\n\t    getBalance(apdu);\n\t    break;\n\tcase CREDIT_INS :\n\t    credit(apdu);\n\t    break;\n\tcase DEBIT_INS :\n\t    debit(apdu);\n\t    break;\n\tcase SET_LIMIT_INS :\n\t    setLimit(apdu);\n\t    break;\n\tcase ADD_CLIENT_APPLET_INS :\n\t    SecureChannelx sc = (SecureChannelx) GPSystem.getSecureChannel();\n\t    sc.setSecurityLevel((byte) 0x83);\n\t    short lc_encrypted = sc.processSecurity(apdu);\n\t    //@ assume(0 \u003c= lc_encrypted \u0026\u0026 lc_encrypted \u003c= apduBuffer.length - ISO7816.OFFSET_CDATA);\n\t    short lc = sc.decryptData(apduBuffer, ISO7816.OFFSET_CDATA, lc_encrypted);\n\t    sc.unwrap(apduBuffer, ISO7816.OFFSET_CDATA, lc);\n\t    addClientApplet(apdu);\n\t    break;\n\tdefault :\n\t    ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);\n\t}\n    }\n    \n\n    private void getBalance(APDU apdu)\n        //@ requires current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\n        //@ ensures current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\n    {\n\tbyte[] apduBuffer = apdu.getBuffer();\n\t// LC checking\n        if (apduBuffer[ISO7816.OFFSET_LC] != 0)\n\t    ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\n\t\n\t//@ open valid();\n\t//@ transient_byte_arrays_mem(workingBuffer);\n\t//@ assert transient_byte_arrays(?as);\n\t//@ foreachp_remove(workingBuffer, as);\n\t//@ open transient_byte_array(workingBuffer);\n\tUtil.setShort(workingBuffer, (short) 0, balance);\n        Util.arrayCopy(workingBuffer, (short) 0, apduBuffer, ISO7816.OFFSET_CDATA, (short) 2);\n        //@ close transient_byte_array(workingBuffer);\n        //@ foreachp_unremove(workingBuffer, as);\n        \n        apdu.setOutgoingAndSend(ISO7816.OFFSET_CDATA, (short) 2);\n    }\n\n    private void credit(APDU apdu)\n        //@ requires current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\n        //@ ensures current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\n    {\n\tbyte[] apduBuffer = apdu.getBuffer();\n\t// LC checking\n\tif (apduBuffer[ISO7816.OFFSET_LC] != 2)\n\t    ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\n\tapdu.setIncomingAndReceive();\n\t\n\t//@ open valid();\n\t//@ transient_byte_arrays_mem(workingBuffer);\n\t//@ assert transient_byte_arrays(?as);\n\t//@ foreachp_remove(workingBuffer, as);\n\t//@ open transient_byte_array(workingBuffer);\n        Util.arrayCopy(apduBuffer, ISO7816.OFFSET_CDATA, workingBuffer, (short) 0, (short) 2);\n\tshort amount = Util.getShort(workingBuffer, (short) 0);\n        //@ close transient_byte_array(workingBuffer);\n        //@ foreachp_unremove(workingBuffer, as);\n        \n\t// BUG: if (amount \u003c= (short)0 || (short) (balance + amount) \u003e limit) // Overflow!\n\tif (amount \u003c= (short)0 || (short)(limit - amount) \u003c balance)\n\t    ISOException.throwIt(ISO7816.SW_DATA_INVALID);\n\tJCSystem.beginTransaction(); // Added for VeriFast\n\tbalance += amount;\n\tJCSystem.commitTransaction(); // Added for VeriFast\n    }\n\n    private void debit(APDU apdu)\n        //@ requires current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\n        //@ ensures current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\n    {\n\tbyte[] apduBuffer = apdu.getBuffer();\n\t// LC checking\n\tif (apduBuffer[ISO7816.OFFSET_LC] != 2)\n\t    ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\n\tapdu.setIncomingAndReceive();\n\t\n\t//@ open valid();\n\t//@ transient_byte_arrays_mem(workingBuffer);\n\t//@ assert transient_byte_arrays(?as);\n\t//@ foreachp_remove(workingBuffer, as);\n\t//@ open transient_byte_array(workingBuffer);\n        Util.arrayCopy(apduBuffer, ISO7816.OFFSET_CDATA, workingBuffer, (short) 0, (short) 2);\n\tshort amount = Util.getShort(workingBuffer, (short) 0);\n        //@ close transient_byte_array(workingBuffer);\n        //@ foreachp_unremove(workingBuffer, as);\n\t\n\tJCSystem.beginTransaction(); // Added for VeriFast\n\tdebit(amount);\n\tJCSystem.commitTransaction(); // Added for VeriFast\n    }\n\n    void debit(short amount)\n        //@ requires valid();\n        //@ ensures valid();\n    {\n\tif (amount \u003c= (short)0 || (short)(balance - amount) \u003c (short)0)\n\t    ISOException.throwIt(ISO7816.SW_DATA_INVALID);\n\tbalance -= amount;\n    }\n    \n    void transaction(short amount)\n        //@ requires valid();\n        //@ ensures valid();\n    {\n    \tif (amount \u003c= (short)0 || (short)(balance - amount) \u003c (short)0)\n    \t    ISOException.throwIt(ISO7816.SW_DATA_INVALID);\n    \tbalance -= amount;      \n    }\n    \n    void charge(short amount)\n        //@ requires valid();\n        //@ ensures valid();\n    {\n    \t//BUG: if (amount \u003c= (short)0 || (short)(balance - amount) \u003c (short)0) \n\tif (amount \u003c= (short)0 || (short)(limit - amount) \u003c balance)\n\t    ISOException.throwIt(ISO7816.SW_DATA_INVALID);\n    \tbalance += amount;\n    }\n\n    private void setLimit(APDU apdu)\n        //@ requires current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\n        //@ ensures current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\n    {\n\tbyte[] apduBuffer = apdu.getBuffer();\n\t// LC checking\n\tif (apduBuffer[ISO7816.OFFSET_LC] != 2)\n\t    ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\n\tapdu.setIncomingAndReceive();\n\t\n\t//@ open valid();\n\t//@ transient_byte_arrays_mem(workingBuffer);\n\t//@ assert transient_byte_arrays(?as);\n\t//@ foreachp_remove(workingBuffer, as);\n\t//@ open transient_byte_array(workingBuffer);\n        Util.arrayCopy(apduBuffer, ISO7816.OFFSET_CDATA, workingBuffer, (short) 0, (short) 2);\n\tshort newLimit = Util.getShort(workingBuffer, (short) 0);\n        //@ close transient_byte_array(workingBuffer);\n        //@ foreachp_unremove(workingBuffer, as);\n\t\n\tif (newLimit \u003c= 0 || balance \u003e newLimit)\n\t    ISOException.throwIt(ISO7816.SW_DATA_INVALID);\n\t\n\tJCSystem.beginTransaction(); // Added for VeriFast\n\tlimit = newLimit;\n\tJCSystem.commitTransaction(); // Added for VeriFast\n    }\n\n    private void addClientApplet(APDU apdu)\n        //@ requires current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\n        //@ ensures current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\n    {\n\tbyte[] apduBuffer = apdu.getBuffer();\n\t// LC checking\n\tbyte lc = apduBuffer[ISO7816.OFFSET_LC];\n\tif (lc \u003c 8 || lc \u003e 19)\n\t    ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\n\tapdu.setIncomingAndReceive();\n\tbyte aidLength = apduBuffer[ISO7816.OFFSET_CDATA];\n\tif (lc != aidLength + 3)\n\t    ISOException.throwIt(ISO7816.SW_DATA_INVALID);\n\t\n\t//@ open valid();\n\t//@ transient_byte_arrays_mem(workingBuffer);\n\t//@ assert transient_byte_arrays(?as);\n\t//@ foreachp_remove(workingBuffer, as);\n\t//@ open transient_byte_array(workingBuffer);\n\tUtil.arrayCopy(apduBuffer, (short) (ISO7816.OFFSET_CDATA + 1), \n\t\t       workingBuffer, (short) 0, aidLength);\n\tAID clientAID = JCSystem.lookupAID(workingBuffer, (short) 0, aidLength);\n\tif (clientAID == null)\n\t    ISOException.throwIt(SW_INVALID_AID);\n\tUtil.arrayCopy(apduBuffer, (short) (ISO7816.OFFSET_CDATA + 1 + aidLength), \n\t\t       workingBuffer, (short) 0, (short) 2);\n\tshort clientLimit = Util.getShort(workingBuffer, (short) 0);\n        //@ close transient_byte_array(workingBuffer);\n        //@ foreachp_unremove(workingBuffer, as);\n\n\tif (clientLimit \u003c 0 || clientLimit \u003e limit)\n\t    ISOException.throwIt(SW_INVALID_CLIENT_LIMIT);\n\tshort clientId = 0;\n\tJCSystem.beginTransaction(); // Added for VeriFast\n\t//@ open [1/2]valid();\n\tif (clientNumber == clientAIDs.length) {\n\t    if ((clientId = searchClientAID(clientAID)) == -1)\n\t\tISOException.throwIt(SW_CLIENT_CAPACITY_EXCEEDED);\n\t    clientLimits[clientId] = clientLimit;\n\t} else if ((clientId = searchClientAID(clientAID)) == -1) {\n\t    clientAIDs[clientNumber] = clientAID;\n\t    clientLimits[clientNumber] = clientLimit;\n\t} else {\n\t    clientLimits[clientId] = clientLimit;\t    \n\t}\n\t// BUG: Does not update clientNumber!\n\tJCSystem.commitTransaction(); // Added for VeriFast\n    }\n\n    short searchClientAID(AID clientAID)\n        //@ requires [?f]clientNumber |-\u003e ?n \u0026*\u0026 [f]clientAIDs |-\u003e ?aids \u0026*\u0026 [f]array_slice(aids, 0, n, ?aidsElems) \u0026*\u0026 non_null(aidsElems) == true;\n        //@ ensures [f]clientNumber |-\u003e n \u0026*\u0026 [f]clientAIDs |-\u003e aids \u0026*\u0026 [f]array_slice(aids, 0, n, aidsElems) \u0026*\u0026 result == -1 ? true : 0 \u003c= result \u0026*\u0026 result \u003c n;\n    {\n\tfor (short i = 0; i \u003c clientNumber; i++)\n\t    //@ invariant [f]clientNumber |-\u003e n \u0026*\u0026 [f]clientAIDs |-\u003e aids \u0026*\u0026 [f]array_slice(aids, 0, n, aidsElems) \u0026*\u0026 0 \u003c= i;\n\t{\n\t    //@ non_null_nth(aidsElems, i);\n\t    if (clientAIDs[i].equals(clientAID))\n\t\treturn i;\n\t}\n\treturn -1;\n    }\n\n    short getClientLimit(short clientId)\n        //@ requires [?f]clientLimits |-\u003e ?limits \u0026*\u0026 [f]array_slice(limits, 0, CLIENT_NUMBER_LIMIT, ?ls) \u0026*\u0026 0 \u003c= clientId \u0026*\u0026 clientId \u003c CLIENT_NUMBER_LIMIT;\n        //@ ensures [f]clientLimits |-\u003e limits \u0026*\u0026 [f]array_slice(limits, 0, CLIENT_NUMBER_LIMIT, ls);\n    {\n\treturn clientLimits[clientId];\n    }\n\n    public Shareable getShareableInterfaceObject(AID clientAID, byte parameter)\n        //@ requires registered_applets(?as) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 AID(clientAID) \u0026*\u0026 mem\u003cApplet\u003e(this, as) == true;\n        //@ ensures registered_applets(as) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 AID(clientAID) \u0026*\u0026 result == null ? true : result.Shareable(?a) \u0026*\u0026 mem\u003cApplet\u003e(a, as) == true;\n    {\n\t// Security: when the applet is LOCKED, it cannot be selected,\n\t// but it can be accessed trough method calls.\n\tif (GPSystem.getCardContentState() == GPSystem.APPLICATION_LOCKED)\n\t    return null;\n\t// Security: client AID verification\n\tif (searchClientAID(clientAID) == -1)\n\t    return null;\n\tif (parameter \u003e (byte)1) return null;\n\tif (parameter == (byte)0)return new EPurseServicesDebit(this);\n\telse return new EPurseServicesCredit(this);\n    }\n\n}\n",
        "name": "NewEPurseApplet.java",
        "path": "examples/java/Java Card/NewEPurse/NewEPurseApplet.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/NewEPurse/NewEPurseApplet.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 86,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires system();"
        },
        {
          "limitHit": false,
          "lineNumber": 87,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures system() \u0026*\u0026 valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 111,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires system() \u0026*\u0026 array_slice(bArray, sOffset, sOffset + bLength, _);"
        },
        {
          "limitHit": false,
          "lineNumber": 112,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 127,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);"
        },
        {
          "limitHit": false,
          "lineNumber": 128,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);"
        },
        {
          "limitHit": false,
          "lineNumber": 168,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);"
        },
        {
          "limitHit": false,
          "lineNumber": 169,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);"
        },
        {
          "limitHit": false,
          "lineNumber": 190,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);"
        },
        {
          "limitHit": false,
          "lineNumber": 191,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);"
        },
        {
          "limitHit": false,
          "lineNumber": 218,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);"
        },
        {
          "limitHit": false,
          "lineNumber": 219,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);"
        },
        {
          "limitHit": false,
          "lineNumber": 243,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 244,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 252,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 253,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 261,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 262,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 271,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);"
        },
        {
          "limitHit": false,
          "lineNumber": 272,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);"
        },
        {
          "limitHit": false,
          "lineNumber": 299,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);"
        },
        {
          "limitHit": false,
          "lineNumber": 300,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures current_applet(this) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);"
        },
        {
          "limitHit": false,
          "lineNumber": 348,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [?f]clientNumber |-\u003e ?n \u0026*\u0026 [f]clientAIDs |-\u003e ?aids \u0026*\u0026 [f]array_slice(aids, 0, n, ?aidsElems) \u0026*\u0026 non_null(aidsElems) == true;"
        },
        {
          "limitHit": false,
          "lineNumber": 349,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [f]clientNumber |-\u003e n \u0026*\u0026 [f]clientAIDs |-\u003e aids \u0026*\u0026 [f]array_slice(aids, 0, n, aidsElems) \u0026*\u0026 result == -1 ? true : 0 \u003c= result \u0026*\u0026 result \u003c n;"
        },
        {
          "limitHit": false,
          "lineNumber": 362,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [?f]clientLimits |-\u003e ?limits \u0026*\u0026 [f]array_slice(limits, 0, CLIENT_NUMBER_LIMIT, ?ls) \u0026*\u0026 0 \u003c= clientId \u0026*\u0026 clientId \u003c CLIENT_NUMBER_LIMIT;"
        },
        {
          "limitHit": false,
          "lineNumber": 363,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [f]clientLimits |-\u003e limits \u0026*\u0026 [f]array_slice(limits, 0, CLIENT_NUMBER_LIMIT, ls);"
        },
        {
          "limitHit": false,
          "lineNumber": 369,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires registered_applets(?as) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 AID(clientAID) \u0026*\u0026 mem\u003cApplet\u003e(this, as) == true;"
        },
        {
          "limitHit": false,
          "lineNumber": 370,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures registered_applets(as) \u0026*\u0026 [1/2]this.valid() \u0026*\u0026 AID(clientAID) \u0026*\u0026 result == null ? true : result.Shareable(?a) \u0026*\u0026 mem\u003cApplet\u003e(a, as) == true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package wallet;\n\nimport javacard.framework.*;\n\npublic final class EWallet extends Applet implements EWalletInterface {\n\n    //@ predicate Shareable(Applet owner) = owner == this;\n    \n    //CLA byte\n    static final byte EWallet_CLA =(byte)0x80;\n\n    //Instruction (ins) bytes\n    static final byte VERIFY = (byte) 0x20;\n    static final byte CREDIT = (byte) 0x30;\n    static final byte DEBIT = (byte) 0x40;\n    static final byte GET_BALANCE = (byte) 0x50;\n\n    // maximum balance\n    static final short MAX_BALANCE = 120;\n    // maximum transaction amount\n    static final byte MAX_TRANSACTION_AMOUNT = 90;\n    // max nb of incorrect tries before pin is blocked\n    static final byte PIN_TRY_LIMIT =(byte)0x03;\n    // max pin size\n    static final byte MAX_PIN_SIZE =(byte)0x08;\n\n    // exceptions\n    static final short SW_VERIFICATION_FAILED = 0x6300;\n    static final short SW_PIN_VERIFICATION_REQUIRED = 0x6301;\n    // amount \u003e MAX_TRANSACTION_AMOUNT or amount \u003c 0\n    static final short SW_INVALID_TRANSACTION_AMOUNT = 0x6A83;\n    static final short SW_EXCEED_MAXIMUM_BALANCE = 0x6A84;\n    static final short SW_NEGATIVE_BALANCE = 0x6A85;\n\n    /* instance variables declaration */\n    private static OwnerPIN pin;\n    private static short balance;\n    private static byte[] pinnb;\n\n    /*@\n    predicate valid() = balance |-\u003e ?wallet_balance \u0026*\u0026 0 \u003c= wallet_balance \u0026*\u0026 wallet_balance \u003c= MAX_BALANCE \n    \t\t\t\u0026*\u0026 pin |-\u003e ?ownerPin \u0026*\u0026 ownerPin != null \u0026*\u0026 OwnerPIN(ownerPin,_,_) \u0026*\u0026 pinnb |-\u003e ?pinnumber \u0026*\u0026 pinnumber != null \n    \t\t\t\u0026*\u0026 array_slice(pinnumber,0,pinnumber.length,_) \u0026*\u0026 pinnumber.length \u003c= MAX_PIN_SIZE; \n    @*/\n\n    private EWallet () \n    //@ requires class_init_token(EWallet.class);\n    //@ ensures valid();\n    {\n        //@ init_class();\n    \t\n        pin = new OwnerPIN(PIN_TRY_LIMIT, MAX_PIN_SIZE);\n\tpinnb = new byte[] {(byte)1,(byte)1,(byte)1,(byte)1};\n        //Initialize pin to 1111\n        pin.update(pinnb, (short)0, (byte)4);\n        balance = 5;\n        //@ close valid();\n    }\n\n    public static void install(byte[] bArray, short bOffset, byte bLength) \n    //@ requires class_init_token(EWallet.class) \u0026*\u0026 system();\n    //@ ensures true;\n    {\n        EWallet wallet = new EWallet();\n        wallet.register();\n    }\n\n    public boolean select() \n    //@ requires [1/2]this.valid();\n    //@ ensures [1/2]this.valid();\n    {\n        // The applet declines to be selected\n        // if the pin is blocked.\n        //@ open [1/2]valid();\n        if ( pin.getTriesRemaining() == 0 ){\n           //@ close [1/2]valid();\n\t   return false;\n\t}\n\t//@ close [1/2]valid();\n        return true;\n    }\n\n    public void deselect() \n    //@ requires [1/2]this.valid();\n    //@ ensures [1/2]this.valid();\n    {\n        // reset the pins validated flag to unvalidated\n        //@ open [1/2]valid();\n        pin.reset();\n        //@ close [1/2]valid();\n    }\n\n    public void process(APDU apdu)\n    /*@\n    requires\n      current_applet(this) \u0026*\u0026\n      [1/2]valid() \u0026*\u0026\n      apdu != null \u0026*\u0026\n      APDU(apdu, ?buffer) \u0026*\u0026\n      array_slice(buffer, 0, buffer.length, _);\n    @*/\n    /*@\n    ensures\n      current_applet(this) \u0026*\u0026\n      [1/2]valid() \u0026*\u0026\n      apdu != null \u0026*\u0026\n      APDU(apdu, buffer) \u0026*\u0026\n      array_slice(buffer, 0, buffer.length, _);\n    @*/\n    {\n        byte[] abuffer = apdu.getBuffer();\n\n        if(selectingApplet())\n            return;\n\n        if(abuffer[ISO7816.OFFSET_CLA] != EWallet_CLA)\n            ISOException.throwIt(ISO7816.SW_CLA_NOT_SUPPORTED);\n\n        switch (abuffer[ISO7816.OFFSET_INS]) {\n        case GET_BALANCE:\n            getBalance(apdu);\n            return;\n        case DEBIT:\n            debit(apdu);\n            return;\n        case CREDIT:\n            credit(apdu);\n            return;\n        case VERIFY:\n            verify(apdu);\n            return;\n        default:\n            ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);\n        }\n    }\n\n    private void credit(APDU apdu) \n    //@requires current_applet(this) \u0026*\u0026 APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 [1/2]this.valid();\n    //@ensures current_applet(this) \u0026*\u0026 APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 [1/2]this.valid();\n    {\n    \t//@ open [1/2]valid();\n        if (!pin.isValidated())\n            ISOException.throwIt(SW_PIN_VERIFICATION_REQUIRED);\n\t//@ close [1/2]valid();\n        byte[] abuffer = apdu.getBuffer();\n\n        // read nb of data bytes\n        byte numBytes = abuffer[ISO7816.OFFSET_LC];\n        // count nb of data bytes read\n       \n        if ((numBytes != 1))\n            ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\n\n        // get the credit amount\n        short creditAmount = (short)abuffer[ISO7816.OFFSET_CDATA];\n\n        // check the credit amount\n        if ((creditAmount \u003e MAX_TRANSACTION_AMOUNT) || (creditAmount \u003c 0))\n            ISOException.throwIt(SW_INVALID_TRANSACTION_AMOUNT);\n\t\n\t//@ open [1/2]valid();\n\tshort newBalance = (short)(balance + creditAmount);\n\t//@ close [1/2]valid();\n\t\n\t// check the new balance\n\tif (newBalance \u003e MAX_BALANCE)\n\t    ISOException.throwIt(SW_EXCEED_MAXIMUM_BALANCE);\n        JCSystem.beginTransaction();\n        //@ open valid();\n        // credit the amount\n        balance = newBalance;\n        //@ close valid();\n        JCSystem.commitTransaction();\n    }\n\n    private void debit(APDU apdu) \n    //@ requires current_applet(this) \u0026*\u0026 APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 [1/2]this.valid();\n    //@ ensures current_applet(this) \u0026*\u0026 APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 [1/2]this.valid();\n    {\n    \t//@ open [1/2]valid();\n        if (!pin.isValidated())\n            ISOException.throwIt(SW_PIN_VERIFICATION_REQUIRED);\n        //@ close [1/2]valid();\n\n        byte[] abuffer = apdu.getBuffer();\n\n        byte numBytes = (byte)(abuffer[ISO7816.OFFSET_LC]);\n\n        if (numBytes != 1)\n           ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\n\n        // get debit amount\n        byte debitAmount = abuffer[ISO7816.OFFSET_CDATA];\n\n        // check debit amount\n        if ((debitAmount \u003e MAX_TRANSACTION_AMOUNT) || (debitAmount \u003c 0))\n           ISOException.throwIt(SW_INVALID_TRANSACTION_AMOUNT);\n\n        // check the new balance\n        //@ open [1/2]valid();\n        short newBalance = (short)(balance - debitAmount);\n        //@ close [1/2]valid();\n        \n        if (newBalance \u003c (short)0)\n             ISOException.throwIt(SW_NEGATIVE_BALANCE);\n\n\tJCSystem.beginTransaction();\n\t//@ open valid();\n        balance = newBalance;\n        //@ close valid();\n        JCSystem.commitTransaction();\n    }\n\n    private void getBalance(APDU apdu) \n    //@requires APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 registered_applets(?as) \u0026*\u0026 mem\u003cApplet\u003e(this,as)==true \u0026*\u0026 foreachp\u003cApplet\u003e(remove\u003cApplet\u003e(this, as),semi_valid) \u0026*\u0026 [1/2]this.valid();\n    //@ensures APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 registered_applets(as) \u0026*\u0026 foreachp\u003cApplet\u003e(remove\u003cApplet\u003e(this, as),semi_valid) \u0026*\u0026 [1/2]this.valid();\n    {\n    \t//@ open [1/2]valid();\n        if (!pin.isValidated())\n            ISOException.throwIt(SW_PIN_VERIFICATION_REQUIRED);\n        //@ close [1/2]valid();\n\n        byte[] abuffer = apdu.getBuffer();\n\n        apdu.setOutgoing();\n        apdu.setOutgoingLength((byte)1);\n\n        // place balance in the APDU buffer\n        //@ open [1/2]valid();\n        abuffer[0] = (byte)balance;\n        //@ close [1/2]valid();\n\n        apdu.sendBytes((short)0, (short)1);\n    }\n\n    private void verify(APDU apdu) \n    //@requires APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 registered_applets(?as) \u0026*\u0026 mem\u003cApplet\u003e(this,as)==true \u0026*\u0026 foreachp\u003cApplet\u003e(remove\u003cApplet\u003e(this, as),semi_valid) \u0026*\u0026 [1/2]this.valid();\n    //@ensures APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 registered_applets(as) \u0026*\u0026 foreachp\u003cApplet\u003e(remove\u003cApplet\u003e(this, as),semi_valid) \u0026*\u0026 [1/2]this.valid();\n    {\n        byte[] abuffer = apdu.getBuffer();\n\n        // retrieve nb of bytes read (pin data length)\n        byte numBytes = (byte)(abuffer[ISO7816.OFFSET_LC]);\n\n        // check pin\n        //@ open [1/2]valid();\n        if (numBytes \u003c 0 || pin.check(abuffer, ISO7816.OFFSET_CDATA, numBytes) == false )\n            ISOException.throwIt(SW_VERIFICATION_FAILED);\n        //@ close [1/2]valid();\n    }\n\n    public void verify(byte[] pincode, short offset, byte length) \n    //@ requires array_slice(pincode, 0, pincode.length,_) \u0026*\u0026 Shareable(?a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\n    //@ ensures array_slice(pincode, 0, pincode.length,_) \u0026*\u0026 Shareable(a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\n    {\n    \t//@ open Shareable(_);\n    \t//@ open valid();\n    \tif (offset \u003c 0 || length \u003c 0 || offset + length \u003e pincode.length)\n    \t    ISOException.throwIt(ISO7816.SW_WRONG_DATA);\n        if ( pin.check(pincode, /*(short)0*/ offset, length) == false )\n            ISOException.throwIt(SW_VERIFICATION_FAILED);\n        //@ close valid();\n    \t//@ close Shareable(this);\n    }\n\n    public void debit(byte debitAmount) \n    //@ requires 0 \u003c= debitAmount \u0026*\u0026 Shareable(?a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\n    //@ ensures Shareable(a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\n    {\n    \t//@ open Shareable(_);\n    \t//@ open valid();\n        if (!pin.isValidated())\n            ISOException.throwIt(SW_PIN_VERIFICATION_REQUIRED);\n        //@ close valid();\n\n        // check debit amount\n        if ((debitAmount \u003e MAX_TRANSACTION_AMOUNT) || (debitAmount \u003c 0))\n           ISOException.throwIt(SW_INVALID_TRANSACTION_AMOUNT);\n\n        // check the new balance\n        //@ open valid();\n        short newBalance = (short)(balance - debitAmount);\n        //@ close valid();\n        \n        if (newBalance \u003c (short)0)\n             ISOException.throwIt(SW_NEGATIVE_BALANCE);\n\n\t//@ open valid();\n        balance = newBalance;\n        //@ close valid();\n    \t//@ close Shareable(this);\n    }\n\n    public Shareable getShareableInterfaceObject(AID clientAID, byte parameter)\n    \t//@ requires registered_applets(?as) \u0026*\u0026 mem\u003cApplet\u003e(this,as) == true \u0026*\u0026 AID(clientAID);\n    \t/*@ ensures registered_applets(as) \u0026*\u0026 mem\u003cApplet\u003e(this,as) == true \u0026*\u0026 AID(clientAID) \u0026*\u0026\n    \t        result == null ? true : result.Shareable(?a) \u0026*\u0026 mem\u003cApplet\u003e(a, as) == true; @*/\n    {\n    \tif(clientAID == null)\n    \t    return null;\n\n        byte[] ephone_aid_bytes = new byte[] {(byte)0xA8, (byte)0xB6, (byte)0xD1, (byte)0x26, (byte)0xB1, (byte)0x60};\n        \n        if(clientAID.equals(ephone_aid_bytes,(short)0,(byte)ephone_aid_bytes.length) == false)\n            return null;\n\n        if(parameter != (byte)0x01)\n            return null;\n\n\t//@ close Shareable(this);\n        return (Shareable)this;\n    }\n}",
        "name": "EWallet.java",
        "path": "examples/java/Java Card/shareable-applets/EWallet.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/shareable-applets/EWallet.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 46,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires class_init_token(EWallet.class);"
        },
        {
          "limitHit": false,
          "lineNumber": 47,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 60,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires class_init_token(EWallet.class) \u0026*\u0026 system();"
        },
        {
          "limitHit": false,
          "lineNumber": 61,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 68,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires [1/2]this.valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 69,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures [1/2]this.valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 83,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires [1/2]this.valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 84,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures [1/2]this.valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 176,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires current_applet(this) \u0026*\u0026 APDU(apdu,?buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 [1/2]this.valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 177,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures current_applet(this) \u0026*\u0026 APDU(apdu,buffer) \u0026*\u0026 array_slice(buffer,0,buffer.length,_) \u0026*\u0026 [1/2]this.valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 252,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires array_slice(pincode, 0, pincode.length,_) \u0026*\u0026 Shareable(?a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 253,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures array_slice(pincode, 0, pincode.length,_) \u0026*\u0026 Shareable(a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 266,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= debitAmount \u0026*\u0026 Shareable(?a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 267,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures Shareable(a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 294,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "    \t//@ requires registered_applets(?as) \u0026*\u0026 mem\u003cApplet\u003e(this,as) == true \u0026*\u0026 AID(clientAID);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package be.fedict.neweidapplet;\r\n\r\nimport javacard.framework.*;\r\n\r\npublic /*VF*ADDED*/final class ElementaryFile extends File {\r\n\t/*@ predicate File(short theFileID, boolean activeState, quad\u003cDedicatedFile, byte[], short, any\u003e info) = \r\n\t\tElementaryFile(theFileID, ?dedFile, ?data, activeState, ?sz, ?ifo) \u0026*\u0026 info == quad(dedFile, data, sz, ifo); @*/\r\n\t/*@ predicate ElementaryFile(short fileID, DedicatedFile parentFile, byte[] data, boolean activeState, short size, any info) = \r\n\t\tthis.File(File.class)(fileID, activeState, _) \u0026*\u0026 this.parentFile |-\u003e parentFile \u0026*\u0026 \r\n\t\tthis.data |-\u003e data \u0026*\u0026 data != null \u0026*\u0026 this.size |-\u003e size \u0026*\u0026 array_slice(data, 0, data.length, _) \u0026*\u0026\r\n\t\tsize \u003e= 0 \u0026*\u0026 size \u003c= data.length \u0026*\u0026 info == unit \u0026*\u0026 data.length \u003c= 30000; @*/\r\n\t\t\r\n\t// link to parent DF\r\n\tpublic DedicatedFile parentFile;\r\n\t// data stored in file\r\n\tprivate byte[] data;\r\n\t// current size of data stored in file\r\n\tshort size;\r\n\tpublic ElementaryFile(short fid, DedicatedFile parent, byte[] d) \r\n  \t    //@ requires d != null \u0026*\u0026 array_slice(d, 0, d.length, _) \u0026*\u0026 d.length \u003c= 255 \u0026*\u0026 parent != null \u0026*\u0026 parent.DedicatedFile(?fileID, ?pf, ?activeState, _, _);\r\n      \t    //@ ensures ElementaryFile(fid, parent, d, true, (short)d.length, _);\r\n\t{\r\n\t\tsuper(fid);\r\n\t\tparentFile = parent;\r\n\t\tparent.addSibling(this);\r\n\t\tdata = d;\r\n\t\tsize = (short) d.length;\r\n\t\t//@ close ElementaryFile(fid, parent, d, true, (short)d.length, _);\r\n\t}\r\n\tpublic ElementaryFile(short fid, DedicatedFile parent, short maxSize) \r\n  \t    //@ requires parent != null \u0026*\u0026 30000 \u003e= maxSize \u0026*\u0026 maxSize \u003e= 0 \u0026*\u0026 parent.DedicatedFile(?fileID, ?pf, ?activeState, ?siblist, ?info) \u0026*\u0026 length(siblist) \u003c DedicatedFile.MAX_SIBLINGS;\r\n      \t    //@ ensures ElementaryFile(fid, parent, ?data, true, 0, _) \u0026*\u0026 data != null \u0026*\u0026 data.length == maxSize \u0026*\u0026 parent.DedicatedFile(fileID, pf, activeState, append(siblist, cons(this, nil)), info) \u0026*\u0026 length(append(siblist, cons(this, nil))) == length(siblist) + 1;\r\n\t{\r\n\t\tsuper(fid);\r\n\t\tparentFile = parent;\r\n\t\tparent.addSibling(this);\r\n\t\tdata = new byte[maxSize];\r\n\t\tsize = (short) 0;\r\n\t\t//@ close ElementaryFile(fid, parent, data, true, size, _);\r\n\t\t//@ length_append(siblist, cons(this, nil));\r\n\t}\r\n\tpublic byte[] getData() \r\n  \t    //@ requires [?f]ElementaryFile(?fid, ?pf, ?d, ?a, ?size, ?info);\r\n      \t    //@ ensures [f]ElementaryFile(fid, pf, d, a, size, info) \u0026*\u0026 result == d;\r\n\t{\r\n\t\tif (active == true) {\r\n\t\t\treturn data;\r\n\t\t} else {\r\n\t\t\tISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n\t\t\treturn null; //~allow_dead_code\r\n\t\t}\r\n\t}\r\n\tpublic short getCurrentSize() \r\n  \t    //@ requires [?f]ElementaryFile(?fid, ?parent, ?data, ?state, ?thesize, ?info);\r\n      \t    //@ ensures [f]ElementaryFile(fid, parent, data, state, thesize, info) \u0026*\u0026 result == thesize;\r\n\t{\t\r\n\t\t//@ open [f]ElementaryFile(fid, parent, data, state, thesize, info);\r\n\t\t//@ open [f]this.File(File.class)(fid, state, ?info2);\r\n\t\tif (active == true) {\r\n\t\t\treturn size;\r\n\t\t\t//@ close [f]this.File(File.class)(fid, state, info2);\r\n\t\t\t//@ close [f]ElementaryFile(fid, parent, data, state, thesize, info);\r\n\t\t} else {\r\n\t\t\tISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n\t\t}\r\n\t\treturn 0; //~allow_dead_code\r\n\t}\r\n\tpublic short getMaxSize() \r\n  \t    //@ requires [?f]ElementaryFile(?fid, ?parent, ?data, ?state, ?thesize, ?info);\r\n      \t    //@ ensures [f]ElementaryFile(fid, parent, data, state, thesize, info) \u0026*\u0026 data != null \u0026*\u0026 result == data.length \u0026*\u0026 data.length \u003c= 30000;\r\n\t{\r\n\t\t//@ open [f]ElementaryFile(fid, parent, data, state, thesize, info);\r\n\t\treturn (short) this.data.length;\r\n\t\t//@ close [f]ElementaryFile(fid, parent, data, state, thesize, info);\r\n\t}\r\n\tpublic void eraseData(short offset) \r\n  \t    //@ requires ElementaryFile(?fid, ?parent, ?theData, ?state, ?thesize, ?info) \u0026*\u0026 offset \u003e= 0 \u0026*\u0026 offset \u003c= thesize;\r\n      \t    //@ ensures ElementaryFile(fid, parent, theData, state, thesize, info);\r\n\t{\r\n\t\t//@ open ElementaryFile(fid, parent, theData, state, thesize, info);\r\n\t\tUtil.arrayFillNonAtomic(data, offset, (short)(size - offset), (byte) 0);\r\n\t\t//@ close ElementaryFile(fid, parent, theData, state, thesize, info);\r\n\t}\r\n\tpublic void updateData(short dataOffset, byte[] newData, short newDataOffset, short length) \r\n  \t    /*@ requires ElementaryFile(?fid, ?parent, ?theData, ?state, ?thesize, ?info) \u0026*\u0026 newData != null \u0026*\u0026 array_slice(newData, 0, newData.length, _)\r\n  \t    \t\t\u0026*\u0026 newDataOffset \u003e= 0 \u0026*\u0026 length \u003e= 0 \u0026*\u0026 newDataOffset + length \u003c= newData.length\r\n  \t    \t\t\u0026*\u0026 dataOffset \u003e= 0 \u0026*\u0026 theData != null \u0026*\u0026 dataOffset + length \u003c= theData.length; @*/\r\n      \t    /*@ ensures ElementaryFile(fid, parent, theData, state, (short)(dataOffset + length), info) \u0026*\u0026 array_slice(newData, 0, newData.length, _); @*/\r\n\t{\r\n\t\t//@ open ElementaryFile(fid, parent, theData, state, thesize, info);\r\n\t\t// update size\r\n\t\tsize = (short) (dataOffset + length);\r\n\t\t// copy new data\r\n\t\tUtil.arrayCopy(newData, newDataOffset, data, dataOffset, length);\r\n\t\t//@ close ElementaryFile(fid, parent, theData, state, (short)(dataOffset + length), info);\r\n\t}\r\n\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic short getFileID() \r\n\t    //@ requires [?f]valid_id(this);\r\n\t    //@ ensures [f]valid_id(this);\r\n\t{\r\n\t\t//@ open [f]valid_id(this);\r\n\t\treturn fileID;\r\n\t\t//@ close [f]valid_id(this);\r\n\t}\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic void setActive(boolean b)\r\n\t    //@ requires File(?fid, _, ?info);\r\n\t    //@ ensures File(fid, b, info);\r\n\t{\r\n\t\t//@ open File(fid, _, info);\r\n\t\t//@ open ElementaryFile(fid, _, _, _, _, ?info2);\r\n\t\tsuper.setActive(b);\r\n\t\t//@ close ElementaryFile(fid, _, _, _, _, info2);\r\n\t\t//@ close File(fid, _, info);\r\n\t}\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic boolean isActive() \r\n\t    //@ requires [?f]File(?fid, ?state, ?info);\r\n\t    //@ ensures [f]File(fid, state, info) \u0026*\u0026 result == state;\r\n\t{\r\n\t\t//@ open [f]File(fid, _, info);\r\n\t\t//@ open [f]ElementaryFile(fid, _, _, _, _, ?info2);\r\n\t\tboolean b = super.isActive();\r\n\t\t//@ close [f]ElementaryFile(fid, _, _, _, _, info2);\r\n\t\t//@ close [f]File(fid, _, info);\r\n\t\treturn b;\r\n\t}\r\n\t\r\n\t/*@\r\n\tlemma void castFileToElementary()\r\n            requires [?f]File(?fid, ?state, ?info);\r\n            ensures switch(info) { case quad(dedFile, dta, sz, ifo) : return [f]ElementaryFile(fid, dedFile, dta, state, sz, ifo); };\r\n\t{\r\n\t    open [f]File(fid, state, info);\r\n    \t}\r\n\r\n\tlemma void castElementaryToFile()\r\n            requires [?f]ElementaryFile(?fid, ?dedFile, ?dta, ?state, ?sz, ?ifo);\r\n            ensures [f]File(fid, state, quad(dedFile, dta, sz, ifo));\r\n\t{\r\n\t    close [f]File(fid, state, quad(dedFile, dta, sz, ifo));\r\n    \t}\r\n    \t\r\n    \tlemma void neq(ElementaryFile other)\r\n    \t  requires ElementaryFile(?fid, ?dedFile, ?dta, ?state, ?sz, ?ifo) \u0026*\u0026 other.ElementaryFile(?fid2, ?dedFile2, ?dta2, ?state2, ?sz2, ?ifo2);\r\n    \t  ensures ElementaryFile(fid, dedFile, dta, state, sz, ifo) \u0026*\u0026 other.ElementaryFile(fid2, dedFile2, dta2, state2, sz2, ifo2) \u0026*\u0026 this != other;\r\n    \t{\r\n    \t  open ElementaryFile(fid, dedFile, dta, state, sz, ifo);\r\n    \t  open other.ElementaryFile(fid2, dedFile2, dta2, state2, sz2, ifo2);\r\n    \t}\r\n    \t@*/\r\n}\r\n",
        "name": "ElementaryFile.java",
        "path": "examples/java/Java Card/NewEidCard/ElementaryFile.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/NewEidCard/ElementaryFile.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 19,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires d != null \u0026*\u0026 array_slice(d, 0, d.length, _) \u0026*\u0026 d.length \u003c= 255 \u0026*\u0026 parent != null \u0026*\u0026 parent.DedicatedFile(?fileID, ?pf, ?activeState, _, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures ElementaryFile(fid, parent, d, true, (short)d.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 30,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires parent != null \u0026*\u0026 30000 \u003e= maxSize \u0026*\u0026 maxSize \u003e= 0 \u0026*\u0026 parent.DedicatedFile(?fileID, ?pf, ?activeState, ?siblist, ?info) \u0026*\u0026 length(siblist) \u003c DedicatedFile.MAX_SIBLINGS;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures ElementaryFile(fid, parent, ?data, true, 0, _) \u0026*\u0026 data != null \u0026*\u0026 data.length == maxSize \u0026*\u0026 parent.DedicatedFile(fileID, pf, activeState, append(siblist, cons(this, nil)), info) \u0026*\u0026 length(append(siblist, cons(this, nil))) == length(siblist) + 1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 42,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires [?f]ElementaryFile(?fid, ?pf, ?d, ?a, ?size, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 43,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures [f]ElementaryFile(fid, pf, d, a, size, info) \u0026*\u0026 result == d;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 53,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires [?f]ElementaryFile(?fid, ?parent, ?data, ?state, ?thesize, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 54,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures [f]ElementaryFile(fid, parent, data, state, thesize, info) \u0026*\u0026 result == thesize;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 68,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires [?f]ElementaryFile(?fid, ?parent, ?data, ?state, ?thesize, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 69,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures [f]ElementaryFile(fid, parent, data, state, thesize, info) \u0026*\u0026 data != null \u0026*\u0026 result == data.length \u0026*\u0026 data.length \u003c= 30000;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 76,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires ElementaryFile(?fid, ?parent, ?theData, ?state, ?thesize, ?info) \u0026*\u0026 offset \u003e= 0 \u0026*\u0026 offset \u003c= thesize;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 77,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures ElementaryFile(fid, parent, theData, state, thesize, info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 99,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires [?f]valid_id(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 100,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures [f]valid_id(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires File(?fid, _, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 109,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures File(fid, b, info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 119,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires [?f]File(?fid, ?state, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 120,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures [f]File(fid, state, info) \u0026*\u0026 result == state;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "interface AnonymousInterface\n{\n  int increment(int i);\n    //@ requires true;\n    //@ ensures result == i + 1;\n        \n  int decrement(int i);\n    //@ requires true;\n    //@ ensures result == i - 1;\n}\n\npublic class AnonymousClass\n{\n  public static void main(String[] args)\n    //@ requires true;\n    //@ ensures true; \n  {\n    AnonymousInterface inner = new AnonymousInterface()\n    {\n      public int increment(int i)\n        //@ requires true;\n        //@ ensures result == i + 1;\n      {\n        return i + 1;\n      }\n      \n      public int decrement(int i)\n        //@ requires true;\n        //@ ensures result == i - 1;\n      {\n        return i - 1;\n      }\n    };\n    \n    int i = 0;\n    i = inner.increment(100);\n    //@ assert i == 101;\n    i = inner.increment(i);\n    //@ assert i == 102;\n    i = inner.decrement(i);\n    //@ assert i == 101;\n    i = inner.decrement(i);\n    //@ assert i == 100;\n }\n}",
        "name": "AnonymousClass.java",
        "path": "examples/java/frontend/inner_class/AnonymousClass.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/inner_class/AnonymousClass.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i - 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true; "
        },
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures result == i + 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures result == i - 1;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import java.util.*;\r\n\r\npublic class BinaryOps\r\n{\r\n  public static void main(String[] args)\r\n    //@ requires true;\r\n    //@ ensures true;\r\n  {\r\n     int a = 60; /* 60 = 0011 1100 */  \r\n     int b = 13;  /* 13 = 0000 1101 */\r\n     int c = 0;\r\n\r\n     c = a \u0026 b;\r\n     c = a | b;\r\n     c = a ^ b;\r\n     c = ~a;\r\n     c = a \u003c\u003c 2;\r\n     c = a \u003e\u003e 2;\r\n  }\r\n}\r\n\r\n",
        "name": "BinaryOps.java",
        "path": "examples/java/frontend/binary_operators/BinaryOps.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/binary_operators/BinaryOps.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import subpackage.Subpackage;\n//@ import subpackage.fixpoint1;\n//@ import subpackage.lemma1;\n//@ import subpackage.predicate1;\n\nclass Main \n{\n  public static void main(String[] args) \n    //@ requires true;\n    //@ ensures true; \n  {\n    Subpackage o = new Subpackage();\n    //@ int i = fixpoint1(0);\n    //@ close predicate1();\n    //@ open predicate1();\n    //@ lemma1();\n  }\n}\n",
        "name": "Main_separate_include.java",
        "path": "examples/java/ghost_imports/Main_separate_include.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/ghost_imports/Main_separate_include.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true; "
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class A \n{\n    int i;\n  \n    //@ predicate valid() = this.i |-\u003e ?m_i;\n      \n    public int getI()\n    //@ requires valid();\n    //@ ensures valid();\n    {\n        return i;\n    }\n}\n\n\nclass B extends A\n{\n    int j;\n    \n    //@ predicate valid() = this.valid(A.class)() \u0026*\u0026 this.j |-\u003e ?m_j;\n\n    public int getI()\n    //@ requires valid();\n    //@ ensures valid();\n    {\n        //@ open valid();\n        return super.getI();\n        //@ close valid();\n    }\n}\n\nclass Program {\n    public void test(B b) \n      //@ requires b != null \u0026*\u0026 b.valid();\n      //@ ensures true;\n    {\n    \tb.getI();\n    }\n}",
        "name": "OverrideTargetParam.java",
        "path": "examples/java/override_methods/OverrideTargetParam.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/override_methods/OverrideTargetParam.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 22,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 23,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 33,
          "offsetAndLengths": [
            [
              6,
              13
            ]
          ],
          "preview": "      //@ requires b != null \u0026*\u0026 b.valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 34,
          "offsetAndLengths": [
            [
              6,
              12
            ]
          ],
          "preview": "      //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "abstract class A \r\n{\r\n  //@ predicate pred() = true;\r\n\r\n  public A()\r\n    //@ requires true;\r\n    //@ ensures pred();\r\n  {\r\n    //@ close pred();\r\n  }\r\n\r\n  public void m()\r\n    //@ requires pred();\r\n    //@ ensures pred();\r\n  {\r\n  }\r\n}\r\n\r\nclass B extends A //~\r\n{\r\n  public B()\r\n    //@ requires true;\r\n    //@ ensures true;\r\n  {\r\n    super();\r\n  }\r\n}\r\n\r\nclass C \r\n{\r\n  public void m()\r\n\r\n\r\n  {\r\n    B b = new B();\r\n  }\r\n}\r\n",
        "name": "NoOverrideSuperCall.java",
        "path": "examples/java/override_methods/NoOverrideSuperCall.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/override_methods/NoOverrideSuperCall.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures pred();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires pred();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures pred();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 22,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package subpackage1;\n\nimport  subpackage1.subsub1.Number1_1;\n\npublic class Add1\n{\n  static public int add()\n    //@ requires true;\n    //@ ensures result == 11;\n  {\n    return 0 + Number1_1.getNumber();\n  }\n}",
        "name": "Add1.java",
        "path": "examples/java/frontend/many_files/subpackage1/Add1.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/many_files/subpackage1/Add1.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == 11;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package subpackage2;\n\nimport  subpackage2.subsub1.Number2_1;\nimport  subpackage2.subsub2.Number2_2;\n\npublic class Add2\n{\n  static public int add()\n    //@ requires true;\n    //@ ensures result == 21 + 22;\n  {\n    return 0 + Number2_1.getNumber() + Number2_2.getNumber();\n  }\n}",
        "name": "Add2.java",
        "path": "examples/java/frontend/many_files/subpackage2/Add2.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/many_files/subpackage2/Add2.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == 21 + 22;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class Sub extends Super\r\n{\r\n  public int increment(int i)\r\n    //@ requires i \u003c 100;\r\n    //@ ensures result == i + 1;\r\n  {\r\n    int j = i;\r\n    j++;\r\n    return j;\r\n  }\r\n\r\n  public int dummy(int i)\r\n    //@ requires true;\r\n    //@ ensures result == i;\r\n  {\r\n    return i;\r\n  }\r\n}\r\n",
        "name": "Sub.java",
        "path": "examples/java/out_of_order_jarsrc/out_of_order/Sub.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/out_of_order_jarsrc/out_of_order/Sub.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires i \u003c 100;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package subpackage3;\n\nimport  subpackage3.subsub1.Number3_1;\nimport  subpackage3.subsub2.Number3_2;\nimport  subpackage3.subsub3.Number3_3;\n\npublic class Add3\n{\n  static public int add()\n    //@ requires true;\n    //@ ensures result == 31 + 32 + 33;\n  {\n    return 0 + Number3_1.getNumber() + Number3_2.getNumber() + Number3_3.getNumber();\n  }\n}",
        "name": "Add3.java",
        "path": "examples/java/frontend/many_files/subpackage3/Add3.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/many_files/subpackage3/Add3.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == 31 + 32 + 33;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package newjticket;\r\n\r\n\r\nimport newepurse.IEPurseServicesDebit;\r\n\r\nimport javacard.framework.*;\r\n\r\npublic final class NewJTicketApplet extends Applet {\r\n\r\n    /*** Constants ***/\r\n    \r\n    public static final byte JTICKET_CLA = ISO7816.CLA_ISO7816;\r\n\r\n    public static final byte GET_COUNTER_INS = 0x01;\r\n    public static final byte USE_TICKET_INS = 0x02;\r\n    public static final byte BUY_TICKETS_INS = 0x03;\r\n    public static final byte SET_EPURSE_AID_INS = 0x04;\r\n\r\n    public static final short SW_NOT_ENOUGH_TICKETS = 0x42;\r\n    public static final short SW_TOO_MANY_TICKETS = 0x43;\r\n    public static final short SW_INVALID_AID = 0x44;\r\n    public static final short SW_EPURSE_SERVICE_ERROR = 0x45;\r\n\r\n\r\n    /*** Instance variables ***/\r\n    \r\n    private byte counter;\r\n    private byte[] workingBuffer;\r\n    private AID epurseAID;\r\n    \r\n    /*@\r\n    \r\n    predicate valid() =\r\n        counter |-\u003e ?c \u0026*\u0026 0 \u003c= c \u0026*\u0026\r\n        workingBuffer |-\u003e ?b \u0026*\u0026 is_transient_byte_array(b) == true \u0026*\u0026 b.length == 16 \u0026*\u0026\r\n        epurseAID |-\u003e ?aid;\r\n    \r\n    @*/\r\n\r\n\r\n    /*** Constructor ***/\r\n\r\n    public NewJTicketApplet()\r\n        //@ requires system();\r\n        //@ ensures valid() \u0026*\u0026 system();\r\n    {\r\n        counter = 0;\r\n        workingBuffer = JCSystem.makeTransientByteArray((short) 16, JCSystem.CLEAR_ON_DESELECT);\r\n    }\r\n    \r\n\r\n    /*** Methods ***/\r\n        \r\n    /**\r\n     * Invoked by the Card Manager to install the JTicket applet.\r\n     *\r\n     * @param bArray - the array containing installation parameters\r\n     * @param sOffset - the starting offset in bArray\r\n     * @param bLength - the length in bytes of the parameter data in bArray\r\n     */    \r\n\r\n    public static void install(byte[] bArray, short sOffset, byte bLength)\r\n        //@ requires array_slice(bArray, sOffset, sOffset + bLength, _) \u0026*\u0026 system();\r\n        //@ ensures true;\r\n    {\r\n        new NewJTicketApplet().register(bArray, sOffset, bLength);\r\n    }\r\n    \r\n    /** \r\n     * Process the APDU commands.\r\n     *\r\n     * @param oApdu the APDU object\r\n     * @exception ISO7816.SW_CLA_NOT_SUPPORTED\r\n     * @exception ISO7816.SW_INS_NOT_SUPPORTED\r\n     * TODO: complete\r\n     */\r\n    \r\n    public void process(APDU apdu)\r\n    /*@\r\n    requires\r\n      current_applet(this) \u0026*\u0026\r\n      [1/2]valid() \u0026*\u0026\r\n      apdu != null \u0026*\u0026\r\n      APDU(apdu, ?buffer) \u0026*\u0026\r\n      array_slice(buffer, 0, buffer.length, _);\r\n    @*/\r\n    /*@\r\n    ensures\r\n      current_applet(this) \u0026*\u0026\r\n      [1/2]valid() \u0026*\u0026\r\n      apdu != null \u0026*\u0026\r\n      APDU(apdu, buffer) \u0026*\u0026\r\n      array_slice(buffer, 0, buffer.length, _);\r\n    @*/\r\n    {\r\n        byte[] apduBuffer = apdu.getBuffer();\r\n        // APDU header processing\r\n        // CLA checking\r\n        if (apduBuffer[ISO7816.OFFSET_CLA] != JTICKET_CLA)\r\n            ISOException.throwIt(ISO7816.SW_CLA_NOT_SUPPORTED);\r\n        // P1 and P2 checking\r\n        if (apduBuffer[ISO7816.OFFSET_P1] != 0 || apduBuffer[ISO7816.OFFSET_P2] != 0)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n        // INS checking and dispatching\r\n        switch (apduBuffer[ISO7816.OFFSET_INS]) {\r\n        case GET_COUNTER_INS :\r\n            getCounter(apdu);\r\n            break;\r\n        case USE_TICKET_INS :\r\n            useTicket(apdu);\r\n            break;\r\n        case BUY_TICKETS_INS :\r\n            buyTickets(apdu);\r\n            break;\r\n        case SET_EPURSE_AID_INS :\r\n            setEPurseAID(apdu);\r\n            break;\r\n        default :\r\n            ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);\r\n        }\r\n    }\r\n\r\n    private void getCounter(APDU apdu)\r\n        //@ requires [1/2]valid() \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n        //@ ensures [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        byte[] apduBuffer = apdu.getBuffer();\r\n        // LC checking\r\n        if (apduBuffer[ISO7816.OFFSET_LC] != 0)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n        apduBuffer[ISO7816.OFFSET_CDATA] = counter;\r\n        apdu.setOutgoingAndSend(ISO7816.OFFSET_CDATA, (short) 1);\r\n    }\r\n\r\n    private void useTicket(APDU apdu)\r\n        //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n        //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        byte[] apduBuffer = apdu.getBuffer();\r\n        // LC checking\r\n        if (apduBuffer[ISO7816.OFFSET_LC] != 0)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n        // counter checking\r\n        if (counter == 0)\r\n            ISOException.throwIt(SW_NOT_ENOUGH_TICKETS);\r\n        // counter update\r\n        JCSystem.beginTransaction(); // Added for VeriFast\r\n        counter--;\r\n        JCSystem.commitTransaction(); // Added for VeriFast\r\n    }\r\n\r\n    private void buyTickets(APDU apdu)\r\n        //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n        //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        byte[] apduBuffer = apdu.getBuffer();\r\n        // LC checking\r\n        if (apduBuffer[ISO7816.OFFSET_LC] != 3)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n        // DATA processing and checking\r\n        apdu.setIncomingAndReceive();\r\n        byte nbOfTickets = apduBuffer[ISO7816.OFFSET_CDATA];\r\n\t//@ open valid();\r\n\t//@ transient_byte_arrays_mem(workingBuffer);\r\n\t//@ assert transient_byte_arrays(?as);\r\n\t//@ foreachp_remove(workingBuffer, as);\r\n\t//@ open transient_byte_array(workingBuffer);\r\n        Util.arrayCopy(apduBuffer, (short) (ISO7816.OFFSET_CDATA + 1), \r\n                       workingBuffer, (short) 0, (short) 2);\r\n        short amount = Util.getShort(workingBuffer, (short) 0);\r\n        //@ close transient_byte_array(workingBuffer);\r\n        //@ foreachp_unremove(workingBuffer, as);\r\n        // EPurse Service call\r\n        JCSystem.beginTransaction(); // Added for VeriFast\r\n        IEPurseServicesDebit epurseService = \r\n            (IEPurseServicesDebit) JCSystem.getAppletShareableInterfaceObject(epurseAID, (byte) 0);\r\n        if (epurseService == null)\r\n            ISOException.throwIt(SW_EPURSE_SERVICE_ERROR);\r\n        //@ Shareable epurseServiceSIO = epurseService;\r\n        //@ assert epurseServiceSIO.Shareable(?epurseApplet);\r\n        //@ mem_registered_applets_is(this);\r\n        //@ assert registered_applets(?as1);\r\n        //@ foreachp_unremove\u003cApplet\u003e(this, as1);\r\n        //@ set_current_applet(epurseApplet);\r\n        //@ foreachp_remove(epurseApplet, as1);\r\n        epurseService.debit(amount);\r\n        //@ is_registered_applets_mem(this);\r\n        //@ assert registered_applets(?as2);\r\n        //@ foreachp_unremove(epurseApplet, as2);\r\n        //@ set_current_applet(this);\r\n        //@ foreachp_remove\u003cApplet\u003e(this, as2);\r\n        // counter update\r\n        if (nbOfTickets \u003c= 0 || (short) (nbOfTickets + counter) \u003e 127)\r\n            ISOException.throwIt(SW_TOO_MANY_TICKETS);\r\n        counter += nbOfTickets;\r\n        JCSystem.commitTransaction(); // Added for VeriFast\r\n    }\r\n\r\n    private void setEPurseAID(APDU apdu)\r\n        //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n        //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n    {\r\n        byte[] apduBuffer = apdu.getBuffer();\r\n        // LC checking\r\n        byte lc = apduBuffer[ISO7816.OFFSET_LC];\r\n        if (lc \u003c 6 || lc \u003e 17)\r\n            ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n        apdu.setIncomingAndReceive();\r\n        byte aidLength = apduBuffer[ISO7816.OFFSET_CDATA];\r\n        if (lc != aidLength + 1)\r\n            ISOException.throwIt(ISO7816.SW_DATA_INVALID);\r\n\t//@ open valid();\r\n\t//@ transient_byte_arrays_mem(workingBuffer);\r\n\t//@ assert transient_byte_arrays(?as);\r\n\t//@ foreachp_remove(workingBuffer, as);\r\n\t//@ open transient_byte_array(workingBuffer);\r\n        Util.arrayCopy(apduBuffer, (short) (ISO7816.OFFSET_CDATA + 1), \r\n                       workingBuffer, (short) 0, aidLength);\r\n        AID aid = JCSystem.lookupAID(workingBuffer, (short) 0, aidLength);\r\n        //@ close transient_byte_array(workingBuffer);\r\n        //@ foreachp_unremove(workingBuffer, as);\r\n        if (aid == null)\r\n            ISOException.throwIt(SW_INVALID_AID);\r\n        JCSystem.beginTransaction(); // Added for VeriFast\r\n        epurseAID = aid;\r\n        JCSystem.commitTransaction(); // Added for VeriFast\r\n    }\r\n\r\n}\r\n",
        "name": "NewJTicketApplet.java",
        "path": "examples/java/Java Card/NewJTicket/NewJTicketApplet.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/NewJTicket/NewJTicketApplet.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 43,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires system();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 44,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid() \u0026*\u0026 system();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 62,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires array_slice(bArray, sOffset, sOffset + bLength, _) \u0026*\u0026 system();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 63,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 123,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [1/2]valid() \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 124,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 135,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 136,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 152,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 153,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 199,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, ?buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 200,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class Main\r\n{\r\n  public static void main(String[] args) \r\n    //@ requires true;\r\n    //@ ensures true; \r\n  {\r\n    Super o = new Sub();\r\n    int i = 0;\r\n    i = o.increment(i);\r\n    //@ assert i == 1;\r\n  }\r\n}\r\n",
        "name": "Main.java",
        "path": "examples/java/out_of_order_jarsrc/out_of_order/Main.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/out_of_order_jarsrc/out_of_order/Main.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true; \r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "// Note: on this program, VeriFast/Redux is much faster than VeriFast/Z3! (2s versus 70s). To use Redux, use:\r\n//   vfide -prover redux EidCard.java\r\n//   verifast -c -prover redux EidCard.java\r\n\r\n/*\r\n                           \r\n                                         @@@@                                \r\n                                     @@@@@@@@@@@                             \r\n                                @@@@@@@@@@@@@@@@@@@@@                        \r\n                          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  \r\n                @@@@@@@@@@@@@@@@@@@@@@@@.....@@@@@@@@@@@@@@@@@@@@@@@@@       \r\n                @@@@@@@@@@@@@@@@@@@@.............@@@@@@@@@@@@@@@@@@@@@       \r\n                @@@@@@@@@@@@@@.........................@@@@@@@@@@@@@@@       \r\n                @@@@@............................................@@@@@       \r\n                @@@@@............................................@@@@        \r\n                @@@@@............................................@@@@        \r\n                 @@@@............................................@@@@        \r\n                 @@@@......::::.................::::::::::::.....@@@@        \r\n                 @@@@......'@@@,...............'@@@@@@@@@@@@,...@@@@@        \r\n                  @@@@......#@@@..............:@@@,.............@@@@         \r\n                  @@@@.......@@@#.............@@@'..............@@@@         \r\n                  @@@@.......,@@@;...........#@@#..............@@@@@         \r\n                   @@@@.......;@@@..........'@@@@@@@@@+........@@@@          \r\n                   @@@@........+@@@........:@@@''''''';........@@@@          \r\n                    @@@@........@@@+.......@@@:...............@@@@           \r\n                    @@@@.........@@@,.....#@@'................@@@@           \r\n                     @@@@........,@@@....'@@#................@@@@            \r\n                      @@@@........'@@#..,@@@................@@@@             \r\n                      @@@@.........#@@;.@@@................@@@@              \r\n                       @@@@.........@@@+@@:...............@@@@@              \r\n                        @@@@........,@@@@+...............@@@@@               \r\n                         @@@@@..........................@@@@@                \r\n                          @@@@@........................@@@@@                 \r\n                           @@@@@......................@@@@                   \r\n                             @@@@@..................@@@@@                    \r\n                              @@@@@@..............@@@@@@                     \r\n                                @@@@@@..........@@@@@@                       \r\n                                 @@@@@@@......@@@@@@                         \r\n                                   @@@@@@@@@@@@@@@                           \r\n                                      @@@@@@@@@@\r\n                                      \r\n                                Powered by VeriFast (c)\r\n*/\r\n\r\n\r\n/*\r\n * Quick-Key Toolset Project.\r\n * Copyright (C) 2010 FedICT.\r\n *\r\n * This is free software; you can redistribute it and/or modify it\r\n * under the terms of the GNU Lesser General Public License version\r\n * 3.0 as published by the Free Software Foundation.\r\n *\r\n * This software is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this software; if not, see \r\n * http://www.gnu.org/licenses/.\r\n */\r\npackage be.fedict.eidapplet;\r\n\r\nimport javacard.security.KeyPair;\r\nimport javacard.security.RSAPrivateKey;\r\nimport javacard.security.RSAPrivateCrtKey;\r\nimport javacard.security.RSAPublicKey;\r\nimport javacard.security.RandomData;\r\nimport javacardx.crypto.Cipher;\r\nimport org.globalplatform.GPSystem;\r\n\r\n/*VF*ADDED FOLLOWING IMPORTS*/\r\nimport javacard.framework.Applet;\r\nimport javacard.framework.*;\r\nimport javacard.security.PrivateKey;\r\nimport javacard.security.PublicKey;\r\n/*VF*ADDED FOLLOWING CLASSES*/\r\n\r\n/*@\r\n\r\ninductive triple\u003ca, b, c\u003e = triple(a, b, c);\r\n\r\ninductive quad\u003ca, b, c, d\u003e = quad(a, b, c, d);\r\n\r\n@*/\r\n\r\npublic abstract class File {\r\n\t/*@ predicate File(short theFileID, boolean activeState, any info) = \r\n\t \t[_]this.fileID |-\u003e theFileID \u0026*\u0026 this.active |-\u003e activeState\r\n\t \t\u0026*\u0026 info == unit; @*/\r\n\r\n\t// file identifier\r\n\tprivate short fileID;\r\n\tprotected boolean active;\r\n\t\r\n\tpublic File(short fid) \r\n  \t    //@ requires true;\r\n      \t    //@ ensures File(fid, true, _) \u0026*\u0026 valid_id(this);\r\n    \t{\r\n\t\tfileID = fid;\r\n\t\tactive = true;\r\n\t\t//@ leak File_fileID(this, _);\r\n\t\t////@ close valid_id(this); // auto\r\n\t\t////@ close File(fid, true, _); // auto\r\n\t}\r\n\tpublic short getFileID() \r\n\t    //@ requires [?f]valid_id(this);\r\n\t    //@ ensures [f]valid_id(this);\r\n\t{\r\n\t\t////@ open [f]valid_id(this); // auto\r\n\t\treturn fileID;\r\n\t\t//@ close [f]valid_id(this); // todo\r\n\t}\r\n\t\r\n\tpublic void setActive(boolean b)\r\n\t    //@ requires File(?fid, _, ?info);\r\n\t    //@ ensures File(fid, b, info);\r\n\t{\r\n\t\t////@ open File(fid, _, info); // auto\r\n\t\tactive = b;\r\n\t\t////@ close File(fid, b, info); // auto\r\n\t}\r\n\t\r\n\t/*VF* added because VeriFast can't access protected variables */\r\n\tpublic boolean isActive() \r\n\t    //@ requires [?f]File(?fid, ?state, ?info);\r\n\t    //@ ensures [f]File(fid, state, info) \u0026*\u0026 result == state;\r\n\t{\r\n\t\t////@ open [f]File(fid, state, info); // auto\r\n\t\treturn active;\r\n\t\t////@ close [f]File(fid, state, info); // auto\r\n\t}\r\n}\r\n\r\n/*@\r\npredicate file_element(File child;) = child == null ? true : [1/2]child.File(_, _, _);\r\npredicate valid_id(File child;) = [_]child.fileID |-\u003e_;\r\n@*/\r\n\r\npublic class DedicatedFile extends File {\r\n\r\n\t/*@ predicate File(short theFileID, boolean activeState, triple\u003cDedicatedFile, list\u003cFile\u003e, any\u003e info) = \r\n\t\tDedicatedFile(theFileID, ?dedFile, activeState, ?siblist, ?oinfo) \u0026*\u0026 info == triple(dedFile, siblist, oinfo); @*/\r\n\t/*@ predicate DedicatedFile(short fileID, DedicatedFile parentFile, boolean activeState, list\u003cFile\u003e siblist, any info) = \r\n\t\tthis.File(File.class)(fileID, activeState, _) \u0026*\u0026 this.parentFile |-\u003e parentFile \u0026*\u0026 this.siblings |-\u003e ?siblings \u0026*\u0026 \r\n\t\tsiblings != null \u0026*\u0026 siblings.length == MAX_SIBLINGS \u0026*\u0026 array_slice(siblings, 0, siblings.length, ?sb) \u0026*\u0026 this.number |-\u003e ?number \u0026*\u0026 siblist == take(number, sb) \u0026*\u0026\r\n\t\tnumber \u003e= 0 \u0026*\u0026 number \u003c= DedicatedFile.MAX_SIBLINGS \u0026*\u0026 info == unit \u0026*\u0026\r\n\t\tforeachp(take(number, sb), valid_id); @*/\r\n\r\n\t// link to parent DF\r\n\tprivate DedicatedFile parentFile;\r\n\t// list of sibling files (either EF or DF)\r\n\tprivate static final byte MAX_SIBLINGS = 10;\r\n\tprivate File[] siblings;\r\n\t// number of siblings\r\n\tprivate byte number;\r\n\t// constructor only used by MasterFile\r\n\tprotected DedicatedFile(short fid) \r\n  \t    //@ requires true;\r\n      \t    //@ ensures DedicatedFile(fid, null, true, nil, _);\r\n\t{\r\n\t\tsuper(fid);\r\n\t\tparentFile = null;\r\n\t\tsiblings = new File[MAX_SIBLINGS];\r\n\t\tnumber = 0;\r\n\t\t////@ close foreachp(nil, valid_id); // auto\r\n\t\t////@ close DedicatedFile(fid, null, true, nil, _); // auto\r\n\t}\r\n\tpublic DedicatedFile(short fid, DedicatedFile parent) \r\n  \t    //@ requires parent != null \u0026*\u0026 parent.DedicatedFile(?fileID, ?pf, ?activeState, ?siblist, ?info);\r\n      \t    //@ ensures DedicatedFile(fid, parent, true, nil, _) \u0026*\u0026 parent.DedicatedFile(fileID, pf, activeState, (length(siblist) \u003c DedicatedFile.MAX_SIBLINGS ? append(siblist, cons(this, nil)) : siblist), info);\r\n\t{\r\n\t\tsuper(fid);\r\n\t\tparentFile = parent;\r\n\t\tsiblings = new File[MAX_SIBLINGS];\r\n\t\tnumber = 0;\r\n\t\tparent.addSibling(this);\r\n\t\t////@ close foreachp(nil, valid_id); // auto\r\n\t\t////@ close DedicatedFile(fid, parent, true, nil, _); // auto\r\n\t}\r\n\tpublic DedicatedFile getParent() \r\n\t    //@ requires DedicatedFile(?fid, ?parentfile, ?active, ?siblist, ?info);\r\n\t    //@ ensures DedicatedFile(fid, parentfile, active, siblist, info) \u0026*\u0026 result == parentfile;\r\n\t{\r\n\t\t////@ open DedicatedFile(fid, parentfile, active, siblist, info); // auto\r\n\t\treturn parentFile;\r\n\t\t////@ close DedicatedFile(fid, parentfile, active, siblist, info); // auto\r\n\t}\r\n\t\r\n\tprotected void addSibling(File s) \r\n  \t    //@ requires DedicatedFile(?fileID, ?parentFile, ?activeState, ?siblist, ?info) \u0026*\u0026 valid_id(s);\r\n  \t    /*@ ensures DedicatedFile(fileID, parentFile, activeState, ?newSibList, info)\r\n  \t    \t\t\u0026*\u0026 newSibList == (length(siblist) \u003c MAX_SIBLINGS ? append(siblist, cons(s, nil)) : siblist)\r\n  \t    \t\t\u0026*\u0026 length(siblist) \u003c MAX_SIBLINGS ? mem(s, newSibList) == true : true; @*/\r\n\t{\r\n                ////@ open DedicatedFile(fileID, parentFile, activeState, siblist, info); // auto\r\n\t\tif (number \u003c MAX_SIBLINGS) {\r\n\t\t\t//@ assert array_slice(?thesiblings, _, _, ?sb);\r\n\t\t\tsiblings[number++] = s;\r\n\t\t\t//@ take_one_more(length(siblist), update(length(siblist), s, sb));\r\n\t\t\t//@ assert array_slice(thesiblings, _, _, ?sb2);\r\n\t\t\t////@ close foreachp(nil, valid_id); // auto\r\n\t\t\t//@ close foreachp(cons(s, nil), valid_id);\r\n\t\t\t//@ foreachp_append(take(length(siblist), sb), cons(s, nil));\t\r\n\t\t}\r\n\t\t\r\n\t\t///*@ close DedicatedFile(fileID, parentFile, activeState,\t\t // auto\r\n\t\t//\tsnumber \u003c MAX_SIBLINGS ? append(take(snumber, siblist), cons(s, nil)) : siblist, \r\n\t\t//\tinfo); @*/\r\n\t}\r\n\r\n\tpublic File getSibling(short fid) \r\n  \t    //@ requires [?f]DedicatedFile(?fileID, ?parentFile, ?activeState, ?siblist, ?info);\r\n      \t    //@ ensures [f]DedicatedFile(fileID, parentFile, activeState, siblist, info) \u0026*\u0026 result == null ? true : mem(result, siblist) == true;\r\n\t{\r\n\t\t//@ open DedicatedFile(fileID, parentFile, activeState, siblist, info); // todo (by allowing patterns in wanted terms)\r\n\t\t//@ assert [f]array_slice(?thesiblings, _, _, ?sb);\r\n\t\t//@ int snumber = length(siblist);\r\n\t\tfor (byte i = 0; i \u003c number; i++) \r\n\t\t/*@ invariant i \u003e= 0 \u0026*\u0026 [f]this.File(File.class)(fileID, activeState, _) \u0026*\u0026 [f]this.parentFile |-\u003e parentFile \u0026*\u0026 [f]number |-\u003e (byte) length(siblist) \u0026*\u0026 [f]this.siblings |-\u003e thesiblings \u0026*\u0026 [f]array_slice(thesiblings, 0, thesiblings.length, sb)\r\n\t\t      \u0026*\u0026 [f]foreachp(siblist, valid_id); @*/\r\n\t\t{\r\n\t\t\tFile fl = siblings[i];\r\n\t\t\t//@ nth_take(i, snumber, sb);\r\n\t\t\t//@ foreachp_remove\u003cFile\u003e(fl, siblist);\r\n\t\t\tif (fl != null \u0026\u0026 fl.getFileID() == fid) {\r\n\t\t\t\t//@ foreachp_unremove\u003cFile\u003e(fl, siblist);\r\n\t\t\t\treturn fl;\r\n\t\t\t\t////@ close [f]DedicatedFile(fileID, parentFile, activeState, siblist, info); // auto\r\n\t\t\t}\r\n\t\t\t//@ foreachp_unremove\u003cFile\u003e(fl, siblist);\r\n\t\t}\r\n\t\t////@ close [f]DedicatedFile(fileID, parentFile, activeState, siblist, info); // auto\r\n\t\treturn null;\r\n\t}\r\n\r\n        /*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic short getFileID() \r\n\t    //@ requires [?f]valid_id(this);\r\n\t    //@ ensures [f]valid_id(this);\r\n\t{\r\n\t\t////@ open [f]valid_id(this); // auto\r\n\t\tFile thiz = this;\r\n\t\treturn fileID;\r\n\t\t//@ close [f]valid_id(this); // todo\r\n\t}\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic void setActive(boolean b)\r\n\t    //@ requires File(?fid, _, ?info);\r\n\t    //@ ensures File(fid, b, info);\r\n\t{\r\n\t\t////@ open File(fid, _, info); // auto\r\n\t\t////@ open DedicatedFile(fid, ?d1, _, ?siblist, ?info2); // auto\r\n\t\tFile thiz = this;\r\n\t\t////@ open thiz.File(fid, _, ?info3); // auto\r\n\t\tactive = b;\r\n\t\t////@ close thiz.File(fid, b, info3); // auto\r\n\t\t////@ close DedicatedFile(fid, d1, b, siblist, info2); // auto\r\n\t\t////@ close File(fid, b, info); // auto\r\n\t}\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic boolean isActive() \r\n\t    //@ requires [?f]File(?fid, ?state, ?info);\r\n\t    //@ ensures [f]File(fid, state, info) \u0026*\u0026 result == state;\r\n\t{\r\n\t\t////@ open [f]File(fid, state, info); // auto\r\n\t\t////@ open [f]DedicatedFile(fid, ?d1, state, ?siblist, ?info2); // auto\r\n\t\t////@ open this.File(File.class)(fid, state, ?info3); // auto\r\n\t\treturn active;\r\n\t\t////@ close [f]this.File(File.class)(fid, state, info3); // auto\r\n\t\t////@ close [f]DedicatedFile(fid, d1, state, siblist, info2); // auto\r\n\t\t////@ close [f]File(fid, state, info); // auto\r\n\t}\r\n\t\r\n\t/*@ \r\n\tlemma void castFileToDedicated()\r\n            requires [?f]File(?fid, ?state, ?info);\r\n            ensures switch (info) { case triple(dedFile, siblist, oinfo): return [f]DedicatedFile(fid, dedFile, state, siblist, oinfo); } ;\r\n\t{\r\n\t   // open [f]File(fid, state, _); // auto\r\n    \t}\r\n\r\n\tlemma void castDedicatedToFile()\r\n            requires [?f]DedicatedFile(?fid, ?dedFile, ?state, ?siblist, ?oinfo);\r\n            ensures [f]File(fid, state, triple(dedFile, siblist, oinfo));\r\n\t{\r\n\t   // close [f]File(fid, state, triple(dedFile, siblist, oinfo)); // auto\r\n    \t}\r\n    \t@*/\r\n}\r\n\r\npublic /*VF*ADDED*/final class MasterFile extends DedicatedFile {\r\n\t//@ predicate File(short theFileID, boolean activeState, triple\u003cDedicatedFile, list\u003cFile\u003e, any\u003e info) = MasterFile(theFileID, ?dedFile, activeState, ?siblist, ?oinfo) \u0026*\u0026 info == triple(dedFile, siblist, oinfo);\r\n\t//@ predicate DedicatedFile(short fileID, DedicatedFile parentFile, boolean activeState, list\u003cFile\u003e siblist, any info) = MasterFile(fileID, parentFile, activeState, siblist, info);\r\n\t//@ predicate MasterFile(short fileID, DedicatedFile parentFile, boolean activeState, list\u003cFile\u003e siblist, any info) = this.DedicatedFile(DedicatedFile.class)(fileID, parentFile, activeState, siblist, _) \u0026*\u0026 fileID == 0x3F00 \u0026*\u0026 parentFile == null \u0026*\u0026 info == unit;\r\n\r\n\tprivate static final short MF_FID = 0x3F00;\r\n\tpublic MasterFile() \r\n  \t    //@ requires true;\r\n      \t    //@ ensures this.MasterFile(0x3F00, null, true, nil, _);\r\n\t{\r\n\t\tsuper(MF_FID);\r\n\t\t////@ close MasterFile(0x3F00, null, true, _, _); // auto\r\n\t}\r\n\t\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic DedicatedFile getParent() \r\n\t    //@ requires DedicatedFile(?fid, ?parentfile, ?active, ?siblist, ?info);\r\n\t    //@ ensures DedicatedFile(fid, parentfile, active, siblist, info) \u0026*\u0026 result == parentfile;\r\n\t{\r\n\t\t////@ open DedicatedFile(fid, parentfile, active, siblist, info); // auto\r\n\t\t////@ open MasterFile(fid, parentfile, active, siblist, ?info2); // auto\r\n\t\t////@ open this.DedicatedFile(DedicatedFile.class)(fid, parentfile, active, siblist, ?info3); // auto\r\n\t\treturn parentFile;\r\n\t\t////@ close this.DedicatedFile(DedicatedFile.class)(fid, parentfile, active, siblist, info3); // auto\r\n\t\t////@ close MasterFile(fid, parentfile, active, siblist, info2); // auto\r\n\t\t////@ close DedicatedFile(fid, parentfile, active, siblist, info); // auto\r\n\t}\r\n\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic File getSibling(short fid) \r\n  \t    //@ requires [?f]DedicatedFile(?fileID, ?parentFile, ?activeState, ?siblist, ?info);\r\n      \t    //@ ensures [f]DedicatedFile(fileID, parentFile, activeState, siblist, info) \u0026*\u0026 result == null ? true : mem(result, siblist) == true;\r\n\t{\r\n\t\t///@ open [f]DedicatedFile(fileID, parentFile, activeState, siblist, info); // auto\r\n\t\t////@ open [f]MasterFile(fileID, parentFile, activeState, siblist, info); // auto\r\n\t\treturn super.getSibling(fid);\r\n\t\t////@ close [f]MasterFile(fileID, parentFile, activeState, siblist, info); // auto\r\n\t\t////@ close [f]DedicatedFile(fileID, parentFile, activeState, siblist, info); // todo\r\n\t}\r\n\t\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic short getFileID() \r\n\t    //@ requires [?f]valid_id(this);\r\n\t    //@ ensures [f]valid_id(this);\r\n\t{\r\n\t\t////@ open [f]valid_id(this); // auto\r\n\t\treturn fileID;\r\n\t\t//@ close [f]valid_id(this);\r\n\t}\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic void setActive(boolean b)\r\n\t    //@ requires File(?fid, _, ?info);\r\n\t    //@ ensures File(fid, b, info);\r\n\t{\r\n\t\t////@ open File(fid, _, info); // auto\r\n\t\t////@ open MasterFile(fid, ?d0, _, ?d1, ?info2); // auto\r\n\t\t////@ open this.DedicatedFile(DedicatedFile.class)(fid, null, _, d1, ?info3); // auto\r\n\t\t////@ open this.File(File.class)(fid, _, ?info4); // auto\r\n\t\tactive = b;\r\n\t\t////@ close this.File(File.class)(fid, b, info4); // auto\r\n\t\t////@ close this.DedicatedFile(DedicatedFile.class)(fid, null, b, d1, info3); // auto\r\n\t\t////@ close MasterFile(fid, null, b, d1, info2); // auto\r\n\t\t////@ close File(fid, b, info); // auto\r\n\t}\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic boolean isActive() \r\n\t    //@ requires [?f]File(?fid, ?state, ?info);\r\n\t    //@ ensures [f]File(fid, state, info) \u0026*\u0026 result == state;\r\n\t{\r\n\t\t////@ open [f]File(fid, state, info); // auto\r\n\t\t////@ open [f]MasterFile(fid, ?d0, state, ?d1, ?info2); // auto\r\n\t\t////@ open [f]this.DedicatedFile(DedicatedFile.class)(fid, null, state, d1, ?info3); // auto\r\n\t\t////@ open [f]this.File(File.class)(fid, state, ?info4); // auto\r\n\t\treturn active;\r\n\t\t////@ close [f]this.File(File.class)(fid, state, info4); // auto\r\n\t\t////@ close [f]this.DedicatedFile(DedicatedFile.class)(fid, null, state, d1, info3); // auto\r\n\t\t////@ close [f]MasterFile(fid, null, state, d1, info2); // auto\r\n\t\t////@ close [f]File(fid, state, info); // auto\r\n\t}\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tprotected void addSibling(File s) \r\n  \t    //@ requires DedicatedFile(?fileID, ?parentFile, ?activeState, ?siblist, ?info) \u0026*\u0026 valid_id(s);\r\n  \t    /*@ ensures DedicatedFile(fileID, parentFile, activeState, ?newSibList, info)\r\n  \t    \t\t\u0026*\u0026 newSibList == (length(siblist) \u003c MAX_SIBLINGS ? append(siblist, cons(s, nil)) : siblist)\r\n  \t    \t\t\u0026*\u0026 length(siblist) \u003c MAX_SIBLINGS ? mem(s, newSibList) == true : true; @*/\r\n \t{\r\n\t\t\r\n\t\t////@ open DedicatedFile(fileID, parentFile, activeState, siblist, info); // auto\r\n\t\t////@ open MasterFile(fileID, parentFile, activeState, siblist, ?info2); // auto\r\n\t\tsuper.addSibling(s);\r\n\t\t////@ close MasterFile(fileID, parentFile, activeState, (length(siblist) \u003c MAX_SIBLINGS ? append(siblist, cons(s, nil)) : siblist), info2); // auto\r\n\t\t////@ close DedicatedFile(fileID, parentFile, activeState, (length(siblist) \u003c MAX_SIBLINGS ? append(siblist, cons(s, nil)) : siblist), info);\r\n\t}\r\n\t\r\n\t/*@ lemma void castFileToMaster()\r\n            requires [?f]File(?fid, ?state, ?info);\r\n            ensures switch (info) { case triple(dedFile, siblist, oinfo): return [f]MasterFile(fid, dedFile, state, siblist, oinfo); } ;\r\n\t{\r\n\t   // open [f]File(fid, state, _);\r\n    \t}\r\n\r\n\tlemma void castMasterToFile()\r\n            requires [?f]MasterFile(?fid, ?dedFile, ?state, ?siblist, ?oinfo);\r\n            ensures [f]File(fid, state, triple(dedFile, siblist, oinfo));\r\n\t{\r\n\t   // close [f]File(fid, state, triple(dedFile, siblist, oinfo));\r\n    \t}\r\n\r\n\tlemma void castMasterToDedicated()\r\n            requires [?f]MasterFile(?fid, ?dedFile, ?state, ?siblist, ?oinfo);\r\n            ensures [f]DedicatedFile(fid, dedFile, state, siblist, oinfo);\r\n\t{\r\n\t   // close [f]DedicatedFile(fid, dedFile, state, siblist, oinfo); // auto\r\n    \t}\r\n\r\n\tlemma void castDedicatedToMaster()\r\n            requires [?f]DedicatedFile(?fid, ?dedFile, ?state, ?siblist, ?oinfo);\r\n            ensures [f]MasterFile(fid, dedFile, state, siblist, oinfo);\r\n\t{\r\n\t   // open [f]DedicatedFile(fid, dedFile, state, siblist, oinfo); // auto\r\n    \t}\r\n\r\n\tlemma void castFileToDedicated()\r\n            requires [?f]File(?fid, ?state, ?info);\r\n            ensures switch (info) { case triple(dedFile, siblist, oinfo): return [f]DedicatedFile(fid, dedFile, state, siblist, oinfo); } ;\r\n\t{\r\n\t  // open [f]File(fid, state, _); // auto\r\n\t    close [f]DedicatedFile(fid, _, _, _, _); // todo\r\n    \t}\r\n\r\n\tlemma void castDedicatedToFile()\r\n            requires [?f]DedicatedFile(?fid, ?dedFile, ?state, ?siblist, ?oinfo);\r\n            ensures [f]File(fid, state, triple(dedFile, siblist, oinfo));\r\n\t{\r\n   \t  //  open [f]DedicatedFile(fid, _, _, _, _); // auto\r\n\t    close [f]File(fid, state, triple(dedFile, siblist, oinfo)); // todo\r\n    \t}\r\n    \t@*/\r\n}\r\n\r\npublic /*VF*ADDED*/final class ElementaryFile extends File {\r\n\t/*@ predicate File(short theFileID, boolean activeState, quad\u003cDedicatedFile, byte[], short, any\u003e info) = \r\n\t\tElementaryFile(theFileID, ?dedFile, ?data, activeState, ?sz, ?ifo) \u0026*\u0026 info == quad(dedFile, data, sz, ifo); @*/\r\n\t/*@ predicate ElementaryFile(short fileID, DedicatedFile parentFile, byte[] data, boolean activeState, short size, any info) = \r\n\t\tthis.File(File.class)(fileID, activeState, _) \u0026*\u0026 this.parentFile |-\u003e parentFile \u0026*\u0026 \r\n\t\tthis.data |-\u003e data \u0026*\u0026 data != null \u0026*\u0026 this.size |-\u003e size \u0026*\u0026 array_slice(data, 0, data.length, _) \u0026*\u0026\r\n\t\tsize \u003e= 0 \u0026*\u0026 size \u003c= data.length \u0026*\u0026 info == unit \u0026*\u0026 data.length \u003c= Short.MAX_VALUE; @*/\r\n\t\t\r\n\t// link to parent DF\r\n\tprivate DedicatedFile parentFile;\r\n\t// data stored in file\r\n\tprivate byte[] data;\r\n\t// current size of data stored in file\r\n\tshort size;\r\n\tpublic ElementaryFile(short fid, DedicatedFile parent, byte[] d) \r\n  \t    //@ requires d != null \u0026*\u0026 array_slice(d, 0, d.length, _) \u0026*\u0026 d.length \u003c= Short.MAX_VALUE \u0026*\u0026 parent != null \u0026*\u0026 parent.DedicatedFile(?fileID, ?pf, ?activeState, _, _);\r\n      \t    //@ ensures ElementaryFile(fid, parent, d, true, (short)d.length, _);\r\n\t{\r\n\t\tsuper(fid);\r\n\t\tparentFile = parent;\r\n\t\tparent.addSibling(this);\r\n\t\tdata = d;\r\n\t\tsize = (short) d.length;\r\n\t\t// //@ close ElementaryFile(fid, parent, d, true, (short)d.length, _); // auto\r\n\t}\r\n\tpublic ElementaryFile(short fid, DedicatedFile parent, short maxSize) \r\n  \t    //@ requires parent != null \u0026*\u0026 maxSize \u003e= 0 \u0026*\u0026 parent.DedicatedFile(?fileID, ?pf, ?activeState, ?siblist, ?info) \u0026*\u0026 length(siblist) \u003c DedicatedFile.MAX_SIBLINGS;\r\n      \t    //@ ensures ElementaryFile(fid, parent, ?data, true, 0, _) \u0026*\u0026 data != null \u0026*\u0026 data.length == maxSize \u0026*\u0026 parent.DedicatedFile(fileID, pf, activeState, append(siblist, cons(this, nil)), info) \u0026*\u0026 length(append(siblist, cons(this, nil))) == length(siblist) + 1;\r\n\t{\r\n\t\tsuper(fid);\r\n\t\tparentFile = parent;\r\n\t\tparent.addSibling(this);\r\n\t\tdata = new byte[maxSize];\r\n\t\tsize = (short) 0;\r\n\t\t//@ length_append(siblist, cons(this, nil));\r\n\t\t// //@ close ElementaryFile(fid, parent, data, true, size, _); // auto\r\n\t}\r\n\tpublic byte[] getData() \r\n  \t    //@ requires [?f]ElementaryFile(?fid, ?pf, ?d, ?a, ?size, ?info);\r\n      \t    //@ ensures [f]ElementaryFile(fid, pf, d, a, size, info) \u0026*\u0026 result == d;\r\n\t{\r\n\t\tif (active == true) {\r\n\t\t\treturn data;\r\n\t\t} else {\r\n\t\t\tISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n\t\t\t////@ close [f]ElementaryFile(fid, pf, d, a, size); // auto\r\n\t\t\treturn null; //~allow_dead_code\r\n\t\t}\r\n\t}\r\n\tpublic short getCurrentSize() \r\n  \t    //@ requires [?f]ElementaryFile(?fid, ?parent, ?data, ?state, ?thesize, ?info);\r\n      \t    //@ ensures [f]ElementaryFile(fid, parent, data, state, thesize, info) \u0026*\u0026 result == thesize;\r\n\t{\t\r\n\t\t////@ open [f]ElementaryFile(fid, parent, data, state, thesize, info); // auto\r\n\t\t////@ open [f]this.File(File.class)(fid, state, ?info2); // auto\r\n\t\tif (active == true) {\r\n\t\t\treturn size;\r\n\t\t\t////@ close [f]this.File(File.class)(fid, state, info2); // auto\r\n\t\t\t////@ close [f]ElementaryFile(fid, parent, data, state, thesize, info); // auto\r\n\t\t} else {\r\n\t\t\tISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n\t\t}\r\n\t}\r\n\tpublic short getMaxSize() \r\n  \t    //@ requires [?f]ElementaryFile(?fid, ?parent, ?data, ?state, ?thesize, ?info);\r\n      \t    //@ ensures [f]ElementaryFile(fid, parent, data, state, thesize, info) \u0026*\u0026 data != null \u0026*\u0026 result == data.length;\r\n\t{\r\n\t\t////@ open [f]ElementaryFile(fid, parent, data, state, thesize, info); // auto\r\n\t\treturn (short) this.data.length;\r\n\t\t////@ close [f]ElementaryFile(fid, parent, data, state, thesize, info); // auto\r\n\t}\r\n\tpublic void eraseData(short offset) \r\n  \t    //@ requires ElementaryFile(?fid, ?parent, ?theData, ?state, ?thesize, ?info) \u0026*\u0026 offset \u003e= 0 \u0026*\u0026 offset \u003c= thesize;\r\n      \t    //@ ensures ElementaryFile(fid, parent, theData, state, thesize, info);\r\n\t{\r\n\t\t////@ open ElementaryFile(fid, parent, theData, state, thesize, info); // auto\r\n\t\tUtil.arrayFillNonAtomic(data, offset, (short)(size - offset), (byte) 0);\r\n\t\t////@ close ElementaryFile(fid, parent, theData, state, thesize, info); // auto\r\n\t}\r\n\tpublic void updateData(short dataOffset, byte[] newData, short newDataOffset, short length) \r\n  \t    /*@ requires ElementaryFile(?fid, ?parent, ?theData, ?state, ?thesize, ?info) \u0026*\u0026 newData != null \u0026*\u0026 array_slice(newData, 0, newData.length, _)\r\n  \t    \t\t\u0026*\u0026 newDataOffset \u003e= 0 \u0026*\u0026 length \u003e= 0 \u0026*\u0026 newDataOffset + length \u003c= newData.length\r\n  \t    \t\t\u0026*\u0026 dataOffset \u003e= 0 \u0026*\u0026 theData != null \u0026*\u0026 dataOffset + length \u003c= theData.length; @*/\r\n      \t    /*@ ensures ElementaryFile(fid, parent, theData, state, (short)(dataOffset + length), info) \u0026*\u0026 array_slice(newData, 0, newData.length, _); @*/\r\n\t{\r\n\t\t//@ open ElementaryFile(fid, parent, theData, state, thesize, info); // todo \r\n\t\t// update size\r\n\t\tsize = (short) (dataOffset + length);\r\n\t\t// copy new data\r\n\t\tUtil.arrayCopy(newData, newDataOffset, data, dataOffset, length);\r\n\t\t////@ close ElementaryFile(fid, parent, theData, state, (short)(dataOffset + length), info); // auto\r\n\t}\r\n\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic short getFileID() \r\n\t    //@ requires [?f]valid_id(this);\r\n\t    //@ ensures [f]valid_id(this);\r\n\t{\r\n\t\t////@ open [f]valid_id(this); // auto\r\n\t\treturn fileID;\r\n\t\t//@ close [f]valid_id(this);\r\n\t}\r\n\t\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic void setActive(boolean b)\r\n\t    //@ requires File(?fid, _, ?info);\r\n\t    //@ ensures File(fid, b, info);\r\n\t{\r\n\t\t////@ open File(fid, _, info); // auto\r\n\t\t////@ open ElementaryFile(fid, _, _, _, _, ?info2); // auto\r\n\t\tsuper.setActive(b);\r\n\t\t////@ close ElementaryFile(fid, _, _, _, _, info2); // auto\r\n\t\t////@ close File(fid, _, info); // auto\r\n\t}\r\n\t\r\n\t/*VF* METHODE ERBIJ GEZET VOOR VERIFAST */\r\n\tpublic boolean isActive() \r\n\t    //@ requires [?f]File(?fid, ?state, ?info);\r\n\t    //@ ensures [f]File(fid, state, info) \u0026*\u0026 result == state;\r\n\t{\r\n\t\t////@ open [f]File(fid, _, info); // auto\r\n\t\t////@ open [f]ElementaryFile(fid, _, _, _, _, ?info2); // auto\r\n\t\tboolean b = super.isActive();\r\n\t\t////@ close [f]ElementaryFile(fid, _, _, _, _, info2); // auto\r\n\t\t////@ close [f]File(fid, _, info); // auto\r\n\t\treturn b;\r\n\t}\r\n\t\r\n\t/*@\r\n\tlemma void castFileToElementary()\r\n            requires [?f]File(?fid, ?state, ?info);\r\n            ensures switch(info) { case quad(dedFile, dta, sz, ifo) : return [f]ElementaryFile(fid, dedFile, dta, state, sz, ifo); };\r\n\t{\r\n\t    //open [f]File(fid, state, info); // auto\r\n    \t}\r\n\r\n\tlemma void castElementaryToFile()\r\n            requires [?f]ElementaryFile(?fid, ?dedFile, ?dta, ?state, ?sz, ?ifo);\r\n            ensures [f]File(fid, state, quad(dedFile, dta, sz, ifo));\r\n\t{\r\n\t    //close [f]File(fid, state, quad(dedFile, dta, sz, ifo)); // auto\r\n    \t}\r\n    \t\r\n    \tlemma void neq(ElementaryFile other)\r\n    \t  requires ElementaryFile(?fid, ?dedFile, ?dta, ?state, ?sz, ?ifo) \u0026*\u0026 other.ElementaryFile(?fid2, ?dedFile2, ?dta2, ?state2, ?sz2, ?ifo2);\r\n    \t  ensures ElementaryFile(fid, dedFile, dta, state, sz, ifo) \u0026*\u0026 other.ElementaryFile(fid2, dedFile2, dta2, state2, sz2, ifo2) \u0026*\u0026 this != other;\r\n    \t{\r\n    \t   open ElementaryFile(fid, dedFile, dta, state, sz, ifo);\r\n    \t   open other.ElementaryFile(fid2, dedFile2, dta2, state2, sz2, ifo2);\r\n    \t}\r\n    \t@*/\r\n}\r\n\r\n/*VF*DONE ADDING CLASSES*/\r\n\r\n/*@\r\n  predicate array_pointer(byte[] buffer, short length) =\r\n    buffer == null ?\r\n      true\r\n    :\r\n      array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer.length == length;\r\n\r\n  predicate transient_array_pointer(byte[] buffer, short length;) =\r\n    buffer == null ?\r\n      true\r\n    :\r\n      array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer.length == length \u0026*\u0026 is_transient_byte_array(buffer) == true;\r\n\r\n  predicate selected_file_types(File theSelectedFile, MasterFile theMasterFile, DedicatedFile theBelpicDirectory, DedicatedFile theIdDirectory, ElementaryFile theIdentityFile, ElementaryFile theIdentityFileSignature, ElementaryFile theAddressFile, ElementaryFile theAddressFileSignature, ElementaryFile thePhotoFile, \r\n\t  ElementaryFile thecaRoleIDFile, ElementaryFile theDirFile, ElementaryFile theTokenInfo, ElementaryFile theObjectDirectoryFile, ElementaryFile theAuthenticationObjectDirectoryFile, ElementaryFile thePrivateKeyDirectoryFile, ElementaryFile theCaCertificate, ElementaryFile theCertificateDirectoryFile, ElementaryFile theRrnCertificate, ElementaryFile theRootCaCertificate, ElementaryFile theAuthenticationCertificate, ElementaryFile theNonRepudationCertificate, ElementaryFile thePreferencesFile; ElementaryFile theSelectedFile2) = \r\n\t    theSelectedFile == theMasterFile || theSelectedFile == theBelpicDirectory || theSelectedFile == theIdDirectory ? theSelectedFile2 == null : \r\n\t      theSelectedFile == theIdentityFile ? theSelectedFile2 == theIdentityFile : \r\n\t        theSelectedFile == theIdentityFileSignature ? theSelectedFile2 == theIdentityFileSignature : \r\n\t          theSelectedFile == theAddressFile ? theSelectedFile2 == theAddressFile : \r\n\t            theSelectedFile == theAddressFileSignature ? theSelectedFile2 == theAddressFileSignature : \r\n\t              theSelectedFile == thePhotoFile ? theSelectedFile2 == thePhotoFile : \r\n\t                theSelectedFile == thecaRoleIDFile ? theSelectedFile2 == thecaRoleIDFile : \r\n\t                  theSelectedFile == theDirFile ? theSelectedFile2 == theDirFile : \r\n\t                    theSelectedFile == theTokenInfo ? theSelectedFile2 == theTokenInfo : \r\n\t                      theSelectedFile == theObjectDirectoryFile ? theSelectedFile2 == theObjectDirectoryFile : \r\n\t                        theSelectedFile == theAuthenticationObjectDirectoryFile ? theSelectedFile2 == theAuthenticationObjectDirectoryFile : \r\n \t                          theSelectedFile == thePrivateKeyDirectoryFile ? theSelectedFile2 == thePrivateKeyDirectoryFile : \r\n                                    theSelectedFile == theCaCertificate ? theSelectedFile2 == theCaCertificate :\r\n                                      theSelectedFile == theRrnCertificate ? theSelectedFile2 == theRrnCertificate :\r\n                                        theSelectedFile == theRootCaCertificate ? theSelectedFile2 == theRootCaCertificate :\r\n                                          theSelectedFile == theAuthenticationCertificate ? theSelectedFile2 == theAuthenticationCertificate :\r\n                                            theSelectedFile == theNonRepudationCertificate ? theSelectedFile2 == theNonRepudationCertificate :\r\n                                              theSelectedFile == thePreferencesFile ? theSelectedFile2 == thePreferencesFile :\r\n                                                (theSelectedFile == theCertificateDirectoryFile \u0026*\u0026 theSelectedFile2 == theCertificateDirectoryFile);\r\n\r\n@*/\r\n\r\n//@ predicate eq\u003cT\u003e(T t1; T t2) = t2 == t1;\r\n\r\npublic final class EidCard extends Applet {\r\n\t/*@\r\n\t\r\n          predicate valid() =\r\n            randomBuffer |-\u003e ?theRandomBuffer \u0026*\u0026 theRandomBuffer != null \u0026*\u0026 array_slice(theRandomBuffer, 0, theRandomBuffer.length, _) \u0026*\u0026 theRandomBuffer.length == 256 \u0026*\u0026\r\n            responseBuffer |-\u003e ?theResponseBuffer \u0026*\u0026 theResponseBuffer != null \u0026*\u0026 array_slice(theResponseBuffer, 0, theResponseBuffer.length, _) \u0026*\u0026 theResponseBuffer.length == 128 \u0026*\u0026\r\n            randomData |-\u003e ?theRandomData \u0026*\u0026 theRandomData != null \u0026*\u0026\r\n            cipher |-\u003e ?theCipher \u0026*\u0026 theCipher != null \u0026*\u0026\r\n            messageBuffer |-\u003e ?theMessageBuffer \u0026*\u0026 theMessageBuffer != null \u0026*\u0026 theMessageBuffer.length == 128 \u0026*\u0026 is_transient_byte_array(theMessageBuffer) == true \u0026*\u0026\r\n            previousApduType |-\u003e ?thePreviousApduType \u0026*\u0026 thePreviousApduType != null \u0026*\u0026 thePreviousApduType.length == 1 \u0026*\u0026 is_transient_byte_array(thePreviousApduType) == true \u0026*\u0026\r\n            signatureType |-\u003e ?theSignatureType \u0026*\u0026 theSignatureType != null \u0026*\u0026 theSignatureType.length == 1 \u0026*\u0026 is_transient_byte_array(theSignatureType) == true \u0026*\u0026\r\n            masterFile |-\u003e ?theMasterFile \u0026*\u0026 theMasterFile.MasterFile(0x3F00, null, _, ?masterSibs, _) \u0026*\u0026 theMasterFile != null \u0026*\u0026 theMasterFile.getClass() == MasterFile.class \u0026*\u0026\r\n            cardholderPin |-\u003e ?theCardholderPin \u0026*\u0026 OwnerPIN(theCardholderPin, _, _) \u0026*\u0026 theCardholderPin != null \u0026*\u0026 \r\n            resetPin |-\u003e ?theResetPin \u0026*\u0026 OwnerPIN(theResetPin, _, _) \u0026*\u0026 theResetPin != null \u0026*\u0026\r\n            unblockPin |-\u003e ?theUnblockPin \u0026*\u0026 OwnerPIN(theUnblockPin, _, _) \u0026*\u0026 theUnblockPin != null \u0026*\u0026\r\n            activationPin |-\u003e ?theActivationPin \u0026*\u0026 OwnerPIN(theActivationPin, _, _) \u0026*\u0026 theActivationPin != null \u0026*\u0026\r\n            identityFile |-\u003e ?theIdentityFile \u0026*\u0026 theIdentityFile.ElementaryFile(_, _, ?identityData, _, _, _) \u0026*\u0026 theIdentityFile != null \u0026*\u0026 identityData != null \u0026*\u0026 identityData.length == 0xD0 \u0026*\u0026 theIdentityFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n            identityFileSignature |-\u003e ?theIdentityFileSignature \u0026*\u0026 theIdentityFileSignature.ElementaryFile(_, _, ?theIdentityFileSignatureData, _, _, _) \u0026*\u0026 theIdentityFileSignature != null \u0026*\u0026 theIdentityFileSignatureData != null \u0026*\u0026 theIdentityFileSignatureData.length == 0x80 \u0026*\u0026 theIdentityFileSignature.getClass() == ElementaryFile.class \u0026*\u0026\r\n            addressFile |-\u003e ?theAddressFile \u0026*\u0026 theAddressFile.ElementaryFile(_, _, ?theAddressFileData, _, _, _) \u0026*\u0026 theAddressFile != null \u0026*\u0026 theAddressFileData != null \u0026*\u0026 theAddressFileData.length == 117 \u0026*\u0026 theAddressFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n            addressFileSignature |-\u003e ?theAddressFileSignature \u0026*\u0026 theAddressFileSignature.ElementaryFile(_, _, ?theAddressFileSignatureData, _, _, _) \u0026*\u0026 theAddressFileSignature != null \u0026*\u0026 theAddressFileSignatureData != null \u0026*\u0026 theAddressFileSignatureData.length == 128 \u0026*\u0026 theAddressFileSignature.getClass() == ElementaryFile.class \u0026*\u0026\r\n            photoFile |-\u003e ?thePhotoFile \u0026*\u0026 thePhotoFile.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 thePhotoFile != null \u0026*\u0026 thePhotoFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n            caRoleIDFile |-\u003e ?thecaRoleIDFile \u0026*\u0026 thecaRoleIDFile.ElementaryFile(_, _, ?theCaRoleIDFileData, _, _, _) \u0026*\u0026 thecaRoleIDFile != null \u0026*\u0026 theCaRoleIDFileData != null \u0026*\u0026 theCaRoleIDFileData.length == 0x20 \u0026*\u0026 thecaRoleIDFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n            dirFile |-\u003e ?theDirFile \u0026*\u0026 theDirFile.ElementaryFile(_, _, ?theDirFileData, _, _, _) \u0026*\u0026 theDirFile != null \u0026*\u0026 theDirFileData != null \u0026*\u0026 theDirFileData.length ==  0x25 \u0026*\u0026 theDirFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n            tokenInfo |-\u003e ?theTokenInfo \u0026*\u0026 theTokenInfo.ElementaryFile(_, _, ?theTokenInfoData, _, _, _) \u0026*\u0026 theTokenInfo != null \u0026*\u0026 theTokenInfoData != null \u0026*\u0026 theTokenInfoData.length == 0x30 \u0026*\u0026 theTokenInfo.getClass() == ElementaryFile.class \u0026*\u0026\r\n            objectDirectoryFile |-\u003e ?theObjectDirectoryFile \u0026*\u0026 theObjectDirectoryFile.ElementaryFile(_, _, ?theObjectDirectoryFileData, _, _, _) \u0026*\u0026 theObjectDirectoryFile != null \u0026*\u0026 theObjectDirectoryFileData != null \u0026*\u0026 theObjectDirectoryFileData.length == 40 \u0026*\u0026 theObjectDirectoryFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n            authenticationObjectDirectoryFile |-\u003e ?theAuthenticationObjectDirectoryFile \u0026*\u0026 theAuthenticationObjectDirectoryFile.ElementaryFile(_, _, ?theAuthenticationObjectDirectoryFileData, _, _, _) \u0026*\u0026 theAuthenticationObjectDirectoryFile != null \u0026*\u0026 theAuthenticationObjectDirectoryFileData != null \u0026*\u0026 theAuthenticationObjectDirectoryFileData.length == 0x40 \u0026*\u0026  theAuthenticationObjectDirectoryFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n            privateKeyDirectoryFile |-\u003e ?thePrivateKeyDirectoryFile \u0026*\u0026 thePrivateKeyDirectoryFile.ElementaryFile(_, _, ?thePrivateKeyDirectoryFileData, _, _, _) \u0026*\u0026 thePrivateKeyDirectoryFile != null \u0026*\u0026 thePrivateKeyDirectoryFileData != null \u0026*\u0026 thePrivateKeyDirectoryFileData.length == 0xB0 \u0026*\u0026 thePrivateKeyDirectoryFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n            certificateDirectoryFile |-\u003e ?theCertificateDirectoryFile \u0026*\u0026 theCertificateDirectoryFile.ElementaryFile(_, _, ?theCertificateDirectoryFileData, _, _, _) \u0026*\u0026 theCertificateDirectoryFile != null \u0026*\u0026 theCertificateDirectoryFileData != null \u0026*\u0026 theCertificateDirectoryFileData.length == 0xB0 \u0026*\u0026 theCertificateDirectoryFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n            belpicDirectory |-\u003e ?theBelpicDirectory \u0026*\u0026 theBelpicDirectory.DedicatedFile(_, _, _, ?belpicSibs, _) \u0026*\u0026 theBelpicDirectory != null \u0026*\u0026 theBelpicDirectory.getClass() == DedicatedFile.class \u0026*\u0026\r\n            idDirectory |-\u003e ?theIdDirectory \u0026*\u0026 theIdDirectory.DedicatedFile(_, _, _, ?idSibs, _) \u0026*\u0026 theIdDirectory != null \u0026*\u0026 theIdDirectory.getClass() == DedicatedFile.class \u0026*\u0026\r\n            caCertificate |-\u003e ?theCaCertificate \u0026*\u0026 theCaCertificate.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 theCaCertificate.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t    selectedFile |-\u003e ?theSelectedFile \u0026*\u0026 theSelectedFile != null \u0026*\u0026\r\n\t    masterSibs == cons\u003cFile\u003e(theDirFile, cons(theBelpicDirectory, cons(theIdDirectory, nil))) \u0026*\u0026\r\n\t    rootCaCertificate |-\u003e ?theRootCaCertificate \u0026*\u0026 theRootCaCertificate.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 theRootCaCertificate.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t    rrnCertificate |-\u003e ?theRrnCertificate \u0026*\u0026 theRrnCertificate.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 theRrnCertificate.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t    authenticationCertificate |-\u003e ?theAuthenticationCertificate \u0026*\u0026 theAuthenticationCertificate.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 theAuthenticationCertificate.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t    nonRepudiationCertificate |-\u003e ?theNonRepudiationCertificate \u0026*\u0026 theNonRepudiationCertificate.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 theNonRepudiationCertificate.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t    preferencesFile |-\u003e ?thePreferencesFile \u0026*\u0026 thePreferencesFile != theCaCertificate \u0026*\u0026 thePreferencesFile != theRrnCertificate \u0026*\u0026 thePreferencesFile.ElementaryFile(_, _, ?thePreferencesFileData, _, _, _) \u0026*\u0026 thePreferencesFile != null \u0026*\u0026 thePreferencesFileData != null \u0026*\u0026 thePreferencesFileData.length == 100 \u0026*\u0026 thePreferencesFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t    belpicSibs == cons\u003cFile\u003e(theTokenInfo, cons(theObjectDirectoryFile, cons(theAuthenticationObjectDirectoryFile, cons(thePrivateKeyDirectoryFile, cons(theCertificateDirectoryFile, cons(theCaCertificate, cons(theRrnCertificate, cons(theRootCaCertificate, cons(theAuthenticationCertificate, cons(theNonRepudiationCertificate, nil)))))))))) \u0026*\u0026\r\n\t    idSibs == cons\u003cFile\u003e(theIdentityFile, cons(theIdentityFileSignature, cons(theAddressFile, cons(theAddressFileSignature, cons(thecaRoleIDFile, cons(thePreferencesFile, cons(thePhotoFile, nil))))))) \u0026*\u0026\r\n\t    selected_file_types(theSelectedFile, theMasterFile, theBelpicDirectory, theIdDirectory, theIdentityFile, theIdentityFileSignature, theAddressFile, theAddressFileSignature, thePhotoFile, thecaRoleIDFile, theDirFile, theTokenInfo, theObjectDirectoryFile, theAuthenticationObjectDirectoryFile, thePrivateKeyDirectoryFile, theCaCertificate, theCertificateDirectoryFile, theRrnCertificate, theRootCaCertificate, theAuthenticationCertificate, theNonRepudiationCertificate, thePreferencesFile, _) \u0026*\u0026\r\n    \t    (theSelectedFile.getClass() == ElementaryFile.class || theSelectedFile.getClass() == MasterFile.class || theSelectedFile.getClass() == DedicatedFile.class) \u0026*\u0026\r\n\t    signatureAlgorithm |-\u003e ?theSignatureAlgorithm \u0026*\u0026\r\n\t    nonRepKeyPair |-\u003e ?theNonRepKeyPair \u0026*\u0026 theNonRepKeyPair != null \u0026*\u0026\r\n\t    authKeyPair |-\u003e ?theAuthKeyPair \u0026*\u0026 theAuthKeyPair != null \u0026*\u0026\r\n\t    basicKeyPair |-\u003e ?theBasicKeyPair \u0026*\u0026\r\n\t    PKCS1_HEADER |-\u003e ?thePKCS1HEADER \u0026*\u0026\r\n\t    //EidCard_PKCS1_HEADER(?thePKCS1HEADER) \u0026*\u0026\r\n\t     thePKCS1HEADER != null \u0026*\u0026 array_slice(thePKCS1HEADER, 0, thePKCS1HEADER.length, _) \u0026*\u0026 thePKCS1HEADER.length == 1 \u0026*\u0026\r\n\t    PKCS1_SHA1_HEADER |-\u003e ?thePKCS1SHA1HEADER \u0026*\u0026 thePKCS1SHA1HEADER != null \u0026*\u0026 array_slice(thePKCS1SHA1HEADER, 0, thePKCS1SHA1HEADER.length, _) \u0026*\u0026 thePKCS1SHA1HEADER.length == 16 \u0026*\u0026\r\n\t    PKCS1_MD5_HEADER |-\u003e ?thePKCS1MD5HEADER \u0026*\u0026 thePKCS1MD5HEADER != null \u0026*\u0026 array_slice(thePKCS1MD5HEADER, 0, thePKCS1MD5HEADER.length, _) \u0026*\u0026 thePKCS1MD5HEADER.length == 19 \u0026*\u0026\r\n\t    theDirFile != thePreferencesFile \u0026*\u0026 theTokenInfo != thePreferencesFile \u0026*\u0026 thePreferencesFile != theObjectDirectoryFile \u0026*\u0026 thePreferencesFile != theAuthenticationObjectDirectoryFile \u0026*\u0026 thePreferencesFile != thePrivateKeyDirectoryFile\r\n\t    ;\r\n    \t@*/\r\n\r\n\t/* APDU header related constants */\r\n\t// codes of CLA byte in the command APDUs\r\n\tprivate final static byte EIDCARD_CLA_2 = (byte) 0x80;\r\n\tprivate final static byte EIDCARD_CLA_1 = (byte) 0x00;\r\n\t// codes of INS byte in the command APDUs\r\n\tprivate final static byte INS_GET_RESPONSE = (byte) 0xC0;\r\n\tprivate final static byte INS_SELECT_FILE = (byte) 0xA4;\r\n\tprivate final static byte INS_ACTIVATE_FILE = (byte) 0x44;\r\n\tprivate final static byte INS_DEACTIVATE_FILE = (byte) 0x04;\r\n\tprivate final static byte INS_READ_BINARY = (byte) 0xB0;\r\n\tprivate final static byte INS_UPDATE_BINARY = (byte) 0xD6;\r\n\tprivate final static byte INS_ERASE_BINARY = (byte) 0x0E;\r\n\tprivate final static byte INS_VERIFY_PIN = (byte) 0x20;\r\n\tprivate final static byte INS_CHANGE_PIN = (byte) 0x24;\r\n\tprivate final static byte INS_UNBLOCK = (byte) 0x2C;\r\n\tprivate final static byte INS_GET_CHALLENGE = (byte) 0x84;\r\n\tprivate final static byte INS_INTERNAL_AUTHENTICATE = (byte) 0x88;\r\n\r\n\tprivate final static byte INS_EXTERNAL_AUTHENTICATE = (byte) 0x82;\r\n\r\n\tprivate final static byte INS_ENVELOPE = (byte) 0xC2;\r\n\tprivate final static byte INS_PREPARE_SIGNATURE = (byte) 0x22;\r\n\tprivate final static byte INS_GENERATE_SIGNATURE = (byte) 0x2A;\r\n\tprivate final static byte INS_GENERATE_KEYPAIR = (byte) 0x46;\r\n\tprivate final static byte INS_GET_KEY = (byte) 0xE2;\r\n\tprivate final static byte INS_PUT_KEY = (byte) 0xF2;\r\n\tprivate final static byte INS_ERASE_KEY = (byte) 0xF4;\r\n\tprivate final static byte INS_ACTIVATE_KEY = (byte) 0xF6;\r\n\tprivate final static byte INS_DEACTIVATE_KEY = (byte) 0xF8;\r\n\tprivate final static byte INS_GET_CARD_DATA = (byte) 0xE4;\r\n\tprivate final static byte INS_LOG_OFF = (byte) 0xE6;\r\n\tprivate final static byte INS_BLOCK = (byte) 0xE8;\r\n\tprivate byte[] previousApduType; // transient byte array with 1 element\r\n\t// \"generate signature\" needs to know whether the previous APDU checked the\r\n\t// cardholder PIN\r\n\tprivate final static byte VERIFY_CARDHOLDER_PIN = (byte) 0x01;\r\n\t// PIN Change needs to know whether the previous APDU checked the reset PIN\r\n\tprivate final static byte VERIFY_RESET_PIN = (byte) 0x02;\r\n\tprivate final static byte GENERATE_KEY_PAIR = (byte) 0x03;\r\n\tprivate final static byte OTHER = (byte) 0x00;\r\n\t/* applet specific status words */\r\n\t// some are defined in ISO7816, but not by JavaCard\r\n\r\n\tprivate final static short SW_CANCELLED = (short) 0xFFFF;\r\n\tprivate final static short SW_ALGORITHM_NOT_SUPPORTED = (short) 0x9484;\r\n\t// last nibble of SW2 needs to be overwritten by the counter value/number of\r\n\t// PIN tries left\r\n\tprivate final static short SW_WRONG_PIN_0_TRIES_LEFT = (short) 0x63C0;\r\n\tprivate final static short SW_INCONSISTENT_P1P2 = (short) 0x6A87;\r\n\tprivate final static short SW_REFERENCE_DATA_NOT_FOUND = (short) 0x6A88;\r\n\t// wrong Le field; SW2 encodes the exact number of available data bytes\r\n\tprivate final static short SW_WRONG_LENGTH_00 = (short) 0x6C00;\r\n\t/* PIN related variables */\r\n\t// offsets within PIN related APDUs\r\n\tprivate final static byte OFFSET_PIN_HEADER = ISO7816.OFFSET_CDATA;\r\n\tprivate final static byte OFFSET_PIN_DATA = ISO7816.OFFSET_CDATA + 1;\r\n\t\r\n\tprivate final static byte OFFSET_SECOND_PIN_HEADER = ISO7816.OFFSET_CDATA + 8;\r\n\r\n\tprivate final static byte OFFSET_SECOND_PIN_DATA = ISO7816.OFFSET_CDATA + 9;\r\n\r\n\tprivate final static byte OFFSET_SECOND_PIN_DATA_END = ISO7816.OFFSET_CDATA + 15;\r\n\t// 4 different PIN codes\r\n\tprotected final static byte PIN_SIZE = 8;\r\n\tprotected final static byte CARDHOLDER_PIN = (byte) 0x01;\r\n\tprotected final static byte CARDHOLDER_PIN_TRY_LIMIT = 3;\r\n\tprotected final static byte RESET_PIN = (byte) 0x02;\r\n\tprotected final static byte RESET_PIN_TRY_LIMIT = 10;\r\n\tprotected final static byte UNBLOCK_PIN = (byte) 0x03;\r\n\tprotected final static byte UNBLOCK_PIN_TRY_LIMIT = 12;\r\n\tprotected final static byte ACTIVATE_PIN = (byte) 0x84;\r\n\tprotected final static byte ACTIVATE_PIN_TRY_LIMIT = 15;\r\n\tprotected OwnerPIN cardholderPin;\r\n\tprotected OwnerPIN resetPin;\r\n\tprotected OwnerPIN unblockPin;\r\n\tprotected OwnerPIN activationPin;\r\n\t//protected OwnerPIN cardholderPin, resetPin, unblockPin, activationPin;\r\n\t\r\n\t\r\n\t/* signature related variables */\r\n\tprivate byte signatureAlgorithm;\r\n\tprivate final static byte ALG_PKCS1 = (byte) 0x01;\r\n\tprivate final static byte ALG_SHA1_PKCS1 = (byte) 0x02;\r\n\tprivate final static byte ALG_MD5_PKCS1 = (byte) 0x04;\r\n\tprivate final static byte[] PKCS1_HEADER = { (byte) 0x00 };\r\n\tprivate final static byte[] PKCS1_SHA1_HEADER = { 0x00, (byte) 0x30, (byte) 0x21, (byte) 0x30, (byte) 0x09, (byte) 0x06, (byte) 0x05, (byte) 0x2b, (byte) 0x0e, (byte) 0x03, (byte) 0x02, (byte) 0x1a, (byte) 0x05, (byte) 0x00, (byte) 0x04,\r\n\t\t\t(byte) 0x14 };\r\n\tprivate final static byte[] PKCS1_MD5_HEADER = { (byte) 0x00, (byte) 0x30, (byte) 0x20, (byte) 0x30, (byte) 0x0c, (byte) 0x06, (byte) 0x08, (byte) 0x2a, (byte) 0x86, (byte) 0x48, (byte) 0x86, (byte) 0xf7, (byte) 0x0d, (byte) 0x02, (byte) 0x05,\r\n\t\t\t(byte) 0x05, (byte) 0x00, (byte) 0x04, (byte) 0x10 };\r\n\tprivate byte[] signatureType; // transient byte array with 1 element\r\n\tprivate final static byte NO_SIGNATURE = (byte) 0x00;\r\n\tprivate final static byte BASIC = (byte) 0x81;\r\n\tprivate final static byte AUTHENTICATION = (byte) 0x82;\r\n\tprivate final static byte NON_REPUDIATION = (byte) 0x83;\r\n\tprivate final static byte CA_ROLE = (byte) 0x87;\r\n\t\r\n\t// make this static to save some memory\r\n\tprotected static KeyPair basicKeyPair;\r\n\tprotected static KeyPair authKeyPair;\r\n\tprotected static KeyPair nonRepKeyPair;\r\n\t\r\n\t\r\n\t\r\n\t// reuse these objects in all subclasses, otherwise we will use up all\r\n\t// memory\r\n\tprivate static Cipher cipher;\r\n\tprivate static RandomData randomData;\r\n\t// this buffer is used to correct PKCS#1 clear text message\r\n\tprivate static byte[] messageBuffer;\r\n\t/*\r\n\t * \"file system\" related variables see Belgian Electronic Identity Card\r\n\t * content\r\n\t */\r\n\tprotected final static short MF = (short) 0x3F00;\r\n\tprotected final static short EF_DIR = (short) 0x2F00;\r\n\tprotected final static short DF_BELPIC = (short) 0xDF00;\r\n\tprotected final static short DF_ID = (short) 0xDF01;\r\n\tprotected MasterFile masterFile;\r\n\tprotected DedicatedFile belpicDirectory, idDirectory;\r\n\tprotected ElementaryFile dirFile;\r\n\t// data under BELPIC directory\r\n\tprotected final static short ODF = (short) 0x5031;\r\n\tprotected final static short TOKENINFO = (short) 0x5032;\r\n\tprotected final static short AODF = (short) 0x5034;\r\n\tprotected final static short PRKDF = (short) 0x5035;\r\n\tprotected final static short CDF = (short) 0x5037;\r\n\tprotected final static short AUTH_CERTIFICATE = (short) 0x5038;\r\n\tprotected final static short NONREP_CERTIFICATE = (short) 0x5039;\r\n\tprotected final static short CA_CERTIFICATE = (short) 0x503A;\r\n\tprotected final static short ROOT_CA_CERTIFICATE = (short) 0x503B;\r\n\tprotected final static short RRN_CERTIFICATE = (short) 0x503C;\r\n\tprotected ElementaryFile objectDirectoryFile, tokenInfo, authenticationObjectDirectoryFile, privateKeyDirectoryFile, certificateDirectoryFile, authenticationCertificate, nonRepudiationCertificate, caCertificate, rootCaCertificate, rrnCertificate;\r\n\t// data under ID directory\r\n\tprotected final static short IDENTITY = (short) 0x4031;\r\n\tprotected final static short SGN_IDENTITY = (short) 0x4032;\r\n\tprotected final static short ADDRESS = (short) 0x4033;\r\n\tprotected final static short SGN_ADDRESS = (short) 0x4034;\r\n\tprotected final static short PHOTO = (short) 0x4035;\r\n\tprotected final static short CA_ROLE_ID = (short) 0x4038;\r\n\tprotected final static short PREFERENCES = (short) 0x4039;\r\n\tprotected ElementaryFile identityFile, identityFileSignature, addressFile, addressFileSignature, photoFile, caRoleIDFile, preferencesFile;\r\n\r\n\t/*\r\n\t * different file operations see ISO 7816-4 table 17+18\r\n\t */\r\n\t// access mode byte for EFs\r\n\tprivate final static byte READ_BINARY = (byte) 0x01;\r\n\r\n\tprivate final static byte SEARCH_BINARY = (byte) 0x01;\r\n\tprivate final static byte UPDATE_BINARY = (byte) 0x02;\r\n\tprivate final static byte ERASE_BINARY = (byte) 0x02;\r\n\r\n\tprivate final static byte WRITE_BINARY = (byte) 0x04;\r\n\t// access mode byte for DFs\r\n\r\n\tprivate final static byte DELETE_CHILD_FILE = (byte) 0x01;\r\n\r\n\tprivate final static byte CREATE_EF = (byte) 0x02;\r\n\r\n\tprivate final static byte CREATE_DF = (byte) 0x04;\r\n\t// access mode byte common to DFs and EFs\r\n\r\n\tprivate final static byte DEACTIVATE_FILE = (byte) 0x08;\r\n\r\n\tprivate final static byte ACTIVATE_FILE = (byte) 0x10;\r\n\r\n\tprivate final static byte TERMINATE_FILE = (byte) 0x20;\r\n\r\n\tprivate final static byte DELETE_FILE = (byte) 0x40;\r\n\t/* variables to pass information between different APDU commands */\r\n\t// last generated random challenge will be stored in this buffer\r\n\tprivate byte[] randomBuffer;\r\n\t// last generated response (e.g. signature) will be stored in this buffer\r\n\tprivate byte[] responseBuffer;\r\n\t// file selected by SELECT FILE; defaults to the MF\r\n\tprivate File selectedFile;\r\n\t// only 5000 internal authenticates can be done and then the activation\r\n\t// PIN needs to be checked again\r\n\tprivate short internalAuthenticateCounter = 5000;\r\n\t/**\r\n\t * called by the JCRE to create an applet instance\r\n\t */\r\n\tpublic static void install(byte[] bArray, short bOffset, byte bLength) \r\n  \t    //@ requires class_init_token(EidCard.class) \u0026*\u0026 system();\r\n      \t    //@ ensures true;\r\n\t{\r\n\t\t// create a eID card applet instance\r\n\t\tnew EidCard();\r\n\t}\r\n\t\r\n\t/**\r\n\t * Initialise all files on the card as empty with max size\r\n\t * \r\n\t * see \"Belgian Electronic Identity Card content\" (version x)\r\n\t * \r\n\t * depending on the eid card version, the address is of different length\r\n\t * (current: 117)\r\n\t */\r\n\tprivate void initializeFileSystem() \r\n  \t    /*@ requires identityFile |-\u003e _ \u0026*\u0026 identityFileSignature |-\u003e _ \u0026*\u0026 addressFile |-\u003e _ \u0026*\u0026 addressFileSignature |-\u003e _\r\n\t\t\t  \u0026*\u0026 caRoleIDFile |-\u003e _ \u0026*\u0026 preferencesFile |-\u003e _ \u0026*\u0026 idDirectory |-\u003e _\r\n\t\t\t  \u0026*\u0026 certificateDirectoryFile |-\u003e _ \u0026*\u0026 privateKeyDirectoryFile |-\u003e _ \u0026*\u0026 authenticationObjectDirectoryFile |-\u003e _ \u0026*\u0026 objectDirectoryFile |-\u003e _\r\n\t\t\t  \u0026*\u0026 tokenInfo |-\u003e _ \u0026*\u0026 belpicDirectory |-\u003e _ \u0026*\u0026 dirFile |-\u003e _\r\n\t\t\t  \u0026*\u0026 masterFile |-\u003e _ \u0026*\u0026 selectedFile |-\u003e _;\r\n\t    @*/\r\n      \t/*@ ensures dirFile |-\u003e ?theDirFile \u0026*\u0026 theDirFile.ElementaryFile(_, _, ?dirFileData, _, _, _) \u0026*\u0026 theDirFile != null \r\n      \t              \u0026*\u0026 dirFileData != null \u0026*\u0026 dirFileData.length == 0x25\r\n\t         \u0026*\u0026 belpicDirectory |-\u003e ?theBelpicDirectory \u0026*\u0026 theBelpicDirectory.DedicatedFile(_, _, _, ?belpic_siblings, _) \u0026*\u0026 theBelpicDirectory != null\r\n\t         \u0026*\u0026 tokenInfo |-\u003e ?theTokenInfo \u0026*\u0026 theTokenInfo.ElementaryFile(_, _, ?tokenInfoData, _, _, _) \u0026*\u0026 theTokenInfo != null\r\n\t              \u0026*\u0026 tokenInfoData != null \u0026*\u0026 tokenInfoData.length == 0x30\r\n\t         \u0026*\u0026 objectDirectoryFile |-\u003e ?theObjectDirectoryFile \u0026*\u0026 theObjectDirectoryFile.ElementaryFile(_, _, ?objectDirectoryFileData, _, _, _) \u0026*\u0026 theObjectDirectoryFile != null\r\n\t              \u0026*\u0026 objectDirectoryFileData != null \u0026*\u0026 objectDirectoryFileData.length == 40\r\n\t         \u0026*\u0026 authenticationObjectDirectoryFile |-\u003e ?theAuthenticationObjectDirectoryFile \u0026*\u0026 theAuthenticationObjectDirectoryFile.ElementaryFile(_, _, ?authenticationObjectDirectoryFileData, _, _, _) \u0026*\u0026 theAuthenticationObjectDirectoryFile != null\r\n\t              \u0026*\u0026 authenticationObjectDirectoryFileData != null \u0026*\u0026 authenticationObjectDirectoryFileData.length == 0x40\r\n\t         \u0026*\u0026 privateKeyDirectoryFile |-\u003e ?thePrivateKeyDirectoryFile \u0026*\u0026 thePrivateKeyDirectoryFile.ElementaryFile(_, _, ?privateKeyDirectoryFileData, _, _, _) \u0026*\u0026 thePrivateKeyDirectoryFile != null\r\n\t              \u0026*\u0026 privateKeyDirectoryFileData != null \u0026*\u0026 privateKeyDirectoryFileData.length == 0xB0\r\n\t         \u0026*\u0026 certificateDirectoryFile |-\u003e ?theCertificateDirectoryFile \u0026*\u0026 theCertificateDirectoryFile.ElementaryFile(_, _, ?certificateDirectoryFileData, _, _, _) \u0026*\u0026 theCertificateDirectoryFile !=  null\r\n\t              \u0026*\u0026 certificateDirectoryFileData != null \u0026*\u0026 certificateDirectoryFileData.length == 0xB0\r\n\t         \u0026*\u0026 idDirectory |-\u003e ?theIdDirectory \u0026*\u0026 theIdDirectory.DedicatedFile(_, _, _, ?idDirectory_siblings, _) \u0026*\u0026 theIdDirectory != null\r\n\t         \u0026*\u0026 identityFile |-\u003e ?theIdentityFile \u0026*\u0026 theIdentityFile.ElementaryFile(_, _, ?identityData, _, _, _) \u0026*\u0026 theIdentityFile != null\r\n\t              \u0026*\u0026 identityData != null \u0026*\u0026 identityData.length == 0xD0\r\n\t         \u0026*\u0026 identityFileSignature |-\u003e ?theIdentityFileSignature \u0026*\u0026 theIdentityFileSignature.ElementaryFile(_, _, ?identitySignatureData, _, _, _) \u0026*\u0026 theIdentityFileSignature != null\r\n\t              \u0026*\u0026 identitySignatureData != null \u0026*\u0026 identitySignatureData.length == 0x80\r\n\t         \u0026*\u0026 addressFile |-\u003e ?theAddressFile \u0026*\u0026 theAddressFile.ElementaryFile(_, _, ?addressFileData, _, _, _) \u0026*\u0026 theAddressFile != null\r\n\t              \u0026*\u0026 addressFileData != null \u0026*\u0026 addressFileData.length == 117\r\n\t         \u0026*\u0026 addressFileSignature |-\u003e ?theAddressFileSignature \u0026*\u0026 theAddressFileSignature.ElementaryFile(_, _, ?addressFileSignatureData, _, _, _) \u0026*\u0026 theAddressFileSignature != null\r\n\t              \u0026*\u0026 addressFileSignatureData != null \u0026*\u0026 addressFileSignatureData.length == 128\r\n\t         \u0026*\u0026 caRoleIDFile |-\u003e ?theCaRoleIDFile \u0026*\u0026 theCaRoleIDFile.ElementaryFile(_, _, ?caRoldIDFileData, _, _, _) \u0026*\u0026 theCaRoleIDFile != null\r\n\t              \u0026*\u0026 caRoldIDFileData != null \u0026*\u0026 caRoldIDFileData.length == 0x20\r\n\t         \u0026*\u0026 preferencesFile |-\u003e ?thePreferencesFile \u0026*\u0026 thePreferencesFile.ElementaryFile(_, _, ?preferencesFileData, _, _, _) \u0026*\u0026 thePreferencesFile != null\r\n\t              \u0026*\u0026 preferencesFileData != null \u0026*\u0026 preferencesFileData.length == 100\r\n\t         \u0026*\u0026 masterFile |-\u003e ?theMasterFile \u0026*\u0026 theMasterFile.MasterFile(0x3F00, null, _, ?master_siblings, _) \u0026*\u0026 theMasterFile != null\r\n\t         \u0026*\u0026 master_siblings == cons\u003cFile\u003e(theDirFile, cons(theBelpicDirectory, cons(theIdDirectory, nil)))\r\n\t         \u0026*\u0026 belpic_siblings == cons\u003cFile\u003e(theTokenInfo, cons(theObjectDirectoryFile, cons(theAuthenticationObjectDirectoryFile, cons(thePrivateKeyDirectoryFile, cons(theCertificateDirectoryFile,nil)))))\r\n\t         \u0026*\u0026 idDirectory_siblings == cons\u003cFile\u003e(theIdentityFile, cons(theIdentityFileSignature, cons(theAddressFile, cons(theAddressFileSignature, cons(theCaRoleIDFile, cons(thePreferencesFile, nil))))))\r\n\t         \u0026*\u0026 selectedFile |-\u003e theMasterFile \u0026*\u0026 theBelpicDirectory.getClass() == DedicatedFile.class \u0026*\u0026 theIdDirectory.getClass() == DedicatedFile.class;\r\n\t    @*/\r\n\t{\r\n\t\tmasterFile = new MasterFile();\r\n\t\t/*\r\n\t\t * initialize PKCS#15 data structures see\r\n\t\t * \"5. PKCS#15 information details\" for more info\r\n\t\t */\r\n\t\t\r\n\t\t//@ masterFile.castMasterToDedicated();\r\n\t\t\r\n\t\tdirFile = new ElementaryFile(EF_DIR, masterFile, (short) 0x25);\r\n\t\tbelpicDirectory = new DedicatedFile(DF_BELPIC, masterFile);\r\n\t\ttokenInfo = new ElementaryFile(TOKENINFO, belpicDirectory, (short) 0x30);\r\n\t\tobjectDirectoryFile = new ElementaryFile(ODF, belpicDirectory, (short) 40);\r\n\t\tauthenticationObjectDirectoryFile = new ElementaryFile(AODF, belpicDirectory, (short) 0x40);\r\n\t\tprivateKeyDirectoryFile = new ElementaryFile(PRKDF, belpicDirectory, (short) 0xB0);\r\n\t\tcertificateDirectoryFile = new ElementaryFile(CDF, belpicDirectory, (short) 0xB0);\r\n\t\tidDirectory = new DedicatedFile(DF_ID, masterFile);\r\n\t\t/*\r\n\t\t * initialize all citizen data stored on the eID card copied from sample\r\n\t\t * eID card 000-0000861-85\r\n\t\t */\r\n\t\t// initialize ID#RN EF\r\n\t\tidentityFile = new ElementaryFile(IDENTITY, idDirectory, (short) 0xD0);\r\n\t\t// initialize SGN#RN EF\r\n\t\tidentityFileSignature = new ElementaryFile(SGN_IDENTITY, idDirectory, (short) 0x80);\r\n\t\t// initialize ID#Address EF\r\n\t\t// address is 117 bytes, and should be padded with zeros\r\n\t\taddressFile = new ElementaryFile(ADDRESS, idDirectory, (short) 117);\r\n\t\t// initialize SGN#Address EF\r\n\t\taddressFileSignature = new ElementaryFile(SGN_ADDRESS, idDirectory, (short) 128);\r\n\t\t// initialize PuK#7 ID (CA Role ID) EF\r\n\t\tcaRoleIDFile = new ElementaryFile(CA_ROLE_ID, idDirectory, (short) 0x20);\r\n\t\t// initialize Preferences EF to 100 zero bytes\r\n\t\tpreferencesFile = new ElementaryFile(PREFERENCES, idDirectory, (short) 100);\r\n\t\t\r\n\t\tselectedFile = masterFile;\r\n\t\t//@ masterFile.castDedicatedToMaster();\r\n\t}\r\n\t\r\n\t/**\r\n\t * erase data in file that was selected with SELECT FILE\r\n\t */\r\n\tprivate void eraseBinary(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t// check if access to this file is allowed\r\n\t\tif (!fileAccessAllowed(ERASE_BINARY))\r\n\t\t\tISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n\t\t// use P1 and P2 as offset\r\n\t\tshort offset = Util.makeShort(buffer[ISO7816.OFFSET_P1], buffer[ISO7816.OFFSET_P2]);\r\n\t\tJCSystem.beginTransaction();\r\n\t\t//@ open valid(); // hard to eliminate as the conjunct selectedFile.ElementaryFile depends on non-input parameters\r\n\t\tif (selectedFile == masterFile)\r\n\t\t\tISOException.throwIt(ISO7816.SW_FILE_INVALID); //~allow_dead_code Dead because fileAccessAllowed() checks that selectedFile instanceof ElementaryFile and masterFile is not an ElementaryFile.\r\n\t\t// impossible to start erasing from offset large than size of file\r\n\t\t//@ open selected_file_types(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _);\r\n\t\tshort size = ((ElementaryFile)selectedFile).getCurrentSize();\r\n\t\t\r\n\t\tif (offset \u003e size || offset \u003c 0)\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n\t\t((ElementaryFile) selectedFile).eraseData(offset);\r\n\t\t////@ close valid(); // auto\r\n\t\tJCSystem.commitTransaction();\r\n\t}\r\n\t/**\r\n\t * change data in a file that was selected with SELECT FILE\r\n\t */\r\n\tprivate void updateBinary(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t// check if access to this file is allowed\r\n\t\tif (!fileAccessAllowed(UPDATE_BINARY))\r\n\t\t\tISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n\t\t// use P1 and P2 as offset\r\n\t\tshort offset = Util.makeShort(buffer[ISO7816.OFFSET_P1], buffer[ISO7816.OFFSET_P2]);\r\n\t\t// impossible to start updating from offset larger than max size of file\r\n\t\t// this however does not imply that the file length can not change\r\n\t\tJCSystem.beginTransaction();\r\n\t\t//@ open valid();\r\n\t\tif (selectedFile == masterFile)\r\n\t\t\tISOException.throwIt(ISO7816.SW_FILE_INVALID); //~allow_dead_code Dead because fileAccessAllowed() checks that selectedFile instanceof ElementaryFile and masterFile is not an ElementaryFile.\r\n\t\t//@ open selected_file_types(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _);\r\n\t\tshort size = ((ElementaryFile) selectedFile).getMaxSize();\r\n\t\tif (offset \u003e size)\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n\t\t// number of bytes in file starting from offset\r\n\t\t// short remaining = (short) (size - offset);\r\n\t\t// get the new data\r\n\t\tshort byteRead = apdu.setIncomingAndReceive();\r\n\t\t// check Lc\r\n\t\tshort lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n\t\tif ((lc == 0) || (byteRead == 0))\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n\t\t// update file\r\n\t\tif (offset \u003c 0 || ISO7816.OFFSET_CDATA + lc \u003e buffer.length || offset + lc \u003e size)\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n\t\t((ElementaryFile) selectedFile).updateData(offset, buffer, ISO7816.OFFSET_CDATA, lc);\r\n\t\t// //@ close valid(); // auto\r\n\t\tJCSystem.commitTransaction();\r\n\t}\r\n\t/**\r\n\t * checks if a certain file operation is allowed on the currently selected\r\n\t * file\r\n\t * \r\n\t * remark 1: a very dedicated (so not generic) implementation! a more\r\n\t * elegant solution would be to put (parts of) access control in File\r\n\t * objects\r\n\t * \r\n\t * remark 2: there is a huge hack to allow some write updates. this hack is\r\n\t * harmless, as these write operations happen during the copying of a card,\r\n\t * not during its use\r\n\t */\r\n\tprivate boolean fileAccessAllowed(byte mode) \r\n  \t    //@ requires [?f]selectedFile |-\u003e ?theSelectedFile \u0026*\u0026 [f]this.preferencesFile |-\u003e ?thePreferencesFile \u0026*\u0026 [f]this.cardholderPin |-\u003e ?theCardHolderPin \u0026*\u0026 theCardHolderPin != null \u0026*\u0026 [f]OwnerPIN(theCardHolderPin, _, _);\r\n      \t    //@ ensures [f]selectedFile |-\u003e theSelectedFile \u0026*\u0026 [f]this.preferencesFile |-\u003e thePreferencesFile \u0026*\u0026 [f]this.cardholderPin |-\u003e theCardHolderPin \u0026*\u0026 [f]OwnerPIN(theCardHolderPin, _, _) \u0026*\u0026 theSelectedFile instanceof ElementaryFile;\r\n\t{\r\n\t\t\t// if selected file is not an EF, throw \"no current EF\" exception\r\n\t\tif (!(selectedFile instanceof ElementaryFile))\r\n\t\t\tISOException.throwIt(ISO7816.SW_COMMAND_NOT_ALLOWED);\r\n\t\t// always allow READ BINARY\r\n\t\tif (mode == READ_BINARY) {\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\t\t// allow write access to the preference file if the cardholder pin was\r\n\t\t// entered correctly\r\n\t\tif ((selectedFile == preferencesFile) \u0026\u0026 cardholderPin.isValidated()) {\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\t\t// we abuse the activation pin to update some of the large files (photo\r\n\t\t// + certificates)\r\n\t\tif (GPSystem.getCardContentState() == GPSystem.APPLICATION_SELECTABLE) {\r\n\t\t\t\treturn true;\t\t\t\r\n\t\t}\r\n\t\t\t// default to false\r\n\t\treturn false;\r\n\t}\r\n\t/**\r\n\t * Gives back information on this eID\r\n\t * \r\n\t * @param apdu\r\n\t * @param buffer\r\n\t */\r\n\tprivate void getCardData(APDU apdu, byte[] buffer) \r\n  \t    //@ requires [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t// check P1 and P2\r\n\t\tif (buffer[ISO7816.OFFSET_P1] != (byte) 0x00 || buffer[ISO7816.OFFSET_P2] != (byte) 0x00)\r\n\t\t\tISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n\t\t// inform the JCRE that the applet has data to return\r\n\t\tapdu.setOutgoing();\r\n\t\t\r\n\t\t////@ open [1/2]valid();\r\n\t\t\t\t\t\t\t\t\r\n\t\tbyte[] data = identityFile.getData(); \r\n\t\t// Only the chip number is of importance: get this at tag position 2\r\n\t\tshort pos = 1;\r\n\t\t//@ open [1/2]identityFile.ElementaryFile(_, _, ?identityFileData, _, _, ?info); // todo (integrate with array_element search)\r\n\t\tshort dataLen = (short) data[pos];\r\n\t\tpos = (short) (pos + 1 + dataLen + 1);\r\n\t\t////@ close [1/2]identityFile.ElementaryFile(_, _, identityFileData, _, _, info); // auto\r\n\t\tif (dataLen \u003c= 0 || dataLen + pos + 2 \u003e= identityFile.getCurrentSize())\r\n\t\t\tISOException.throwIt(ISO7816.SW_DATA_INVALID);\r\n\t\t//@ open [1/2]identityFile.ElementaryFile(_, _, identityFileData, _, _, info);\r\n\t\tdataLen = (short) data[pos];\r\n\t\tpos = (short) (pos + 1);\r\n\t\t////@ close [1/2]identityFile.ElementaryFile(_, _, identityFileData, _, _, info); // auto\r\n\t\tif (dataLen \u003c 0 || pos + dataLen \u003e= identityFile.getCurrentSize())\r\n\t\t\tISOException.throwIt(ISO7816.SW_DATA_INVALID);\r\n\t\t//@ open [1/2]identityFile.ElementaryFile(_, _, identityFileData, _, _, info);\r\n\t\t// check Le\r\n\t\t// if (le != dataLen)\r\n\t\t// ISOException.throwIt((short)(ISO7816.SW_WRONG_LENGTH));\r\n\t\t/*VF*byte version[] = { (byte) 0xA5, (byte) 0x03, (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x11, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x01, (byte) 0x01, (byte) 0x0F };*/\r\n\t\tbyte version[] = new byte[] { (byte) 0xA5, (byte) 0x03, (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x11, (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x01, (byte) 0x01, (byte) 0x0F };\r\n\t\tbyte chipNumber[] = new byte[(short) (dataLen + 12)];\r\n\t\tUtil.arrayCopy(data, pos, chipNumber, (short) 0, dataLen);\r\n\t\tUtil.arrayCopy(version, (short) 0, chipNumber, dataLen, (short) 12);\r\n\t\t// //Set serial number\r\n\t\t// Util.arrayCopy(tokenInfo.getData(), (short) 7, tempBuffer, (short) 0,\r\n\t\t// (short) 16);\r\n\t\t//\t\t\r\n\t\t// //Set component code: TODO\r\n\t\t//\t\t\r\n\t\t//\t\t\r\n\t\t// //Set OS number: TODO\r\n\t\t//\t\t\r\n\t\t//\t\t\r\n\t\t// //Set OS version: TODO\r\n\t\t// JCSystem.getVersion();\r\n\t\t//\t\t\r\n\t\t// //Set softmask number: TODO\r\n\t\t//\t\t\r\n\t\t// //Set softmask version: TODO\r\n\t\t//\t\t\r\n\t\t// //Set applet version: TODO : 4 bytes in file system\r\n\t\t//\t\t\r\n\t\t//\t\t\r\n\t\t// //Set Interface version: TODO\r\n\t\t//\t\t\r\n\t\t// //Set PKCS#15 version: TODO\r\n\t\t//\t\t\r\n\t\t// //Set applet life cycle\r\n\t\t// tempBuffer[(short)(le-1)] = GPSystem.getCardState();\r\n\t\t// set the actual number of outgoing data bytes\r\n\t\tapdu.setOutgoingLength((short) chipNumber.length);\r\n\t\t// send content of buffer in apdu\r\n\t\tapdu.sendBytesLong(chipNumber, (short) 0, (short) chipNumber.length);\r\n\t\t\t\t\t\t\t\t\r\n\t\t////@ close [1/2]identityFile.ElementaryFile(_, _, identityFileData, _, _, info); // auto\r\n\t\t////@ close [1/2]valid(); // auto\r\n\t}\r\n\t\r\n\t/**\r\n\t * put file that was selected with SELECT FILE in a response APDU\r\n\t */\r\n\tprivate void readBinary(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t////@ open [1/2]valid(); // auto\r\n\t\t// check if access to this file is allowed\r\n\t\tif (!fileAccessAllowed(READ_BINARY))\r\n\t\t\tISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n\t\t// use P1 and P2 as offset\r\n\t\tshort offset = Util.makeShort(buffer[ISO7816.OFFSET_P1], buffer[ISO7816.OFFSET_P2]);\r\n\t\tif (offset \u003c 0)\r\n\t\t\tISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n\t\t// inform the JCRE that the applet has data to return\r\n\t\tshort le = apdu.setOutgoing();\r\n\t\t// impossible to start reading from offset large than size of file\t\t\t\t\r\n\t\tif (selectedFile == masterFile)\r\n\t\t\tISOException.throwIt(ISO7816.SW_FILE_INVALID); //~allow_dead_code Dead because fileAccessAllowed() checks that selectedFile instanceof ElementaryFile and masterFile is not an ElementaryFile.\r\n\t\t//@ open selected_file_types(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _);\r\n\t\tshort size = ((ElementaryFile) selectedFile).getCurrentSize();\r\n\t\tif (offset \u003e size)\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n\t\t// number of bytes in file starting from offset\r\n\t\tshort remaining = (short) (size - offset);\r\n\t\tif (le == 0) {\r\n\t\t\tif (remaining \u003c 256) {\r\n\t\t\t\t// wrong Le field\r\n\t\t\t\t// SW2 encodes the exact number of available data bytes\r\n\t\t\t\tshort sw = (short) (ISO7816.SW_CORRECT_LENGTH_00 | remaining);\r\n\t\t\t\tISOException.throwIt(sw);\r\n\t\t\t} else\r\n\t\t\t\t// Le = 0 is interpreted as 256 bytes\r\n\t\t\t\tle = 256;\r\n\t\t}\r\n\t\t// only read out the remaining bytes\r\n\t\tif (le \u003e remaining) {\r\n\t\t\tle = remaining;\r\n\t\t}\r\n\t\t// set the actual number of outgoing data bytes\r\n\t\tapdu.setOutgoingLength(le);\r\n\t\t// write selected file in APDU\r\n\t\t//VF bug; was   apdu.sendBytesLong(((ElementaryFile) selectedFile).getData(), offset, le);\r\n\t\t//VF probleem: originele lijn was    apdu.sendBytesLong(ef.getData(), offset, le);\r\n\t\t// het probleem hiermee is dat de getData()-methode een ElementaryFile nodig heeft, en dat\r\n\t\t// sendBytesLong vereist dat het resultaat niet null is. De niet-null vereiste zit geencodeerd\r\n\t\t// in ElementaryFile, dus als je dat predicaat opent, dan weet VF dat de data niet-null is, maar\r\n\t\t// dan werkt de call op getData niet. Als je de ElementaryFile gesloten laat, dan lukt de call naar\r\n\t\t// getData, maar weet je niet dat het niet-null is.\r\n\t\tElementaryFile ef = (ElementaryFile)selectedFile;\r\n\t\tbyte[] bf = ef.getData();\r\n\t\t//@ open [1/2]ef.ElementaryFile(?d1, ?d2, ?d3, ?d4, ?d5, ?info); // hard to eliminate\r\n\t\tapdu.sendBytesLong(bf, offset, le);\r\n\t\t////@ close [1/2]ef.ElementaryFile(d1, d2, d3, d4, d5, info); // auto\r\n\t\t////@ close [1/2]valid(); // auto\r\n\t}\r\n\t\r\n\t/**\r\n\t * activate a file on the eID card security conditions depend on file to\r\n\t * activate: see belgian eID content file\r\n\t */\r\n\tprivate void activateFile(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t// check P2\r\n\t\tif (buffer[ISO7816.OFFSET_P2] != (byte) 0x0C)\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n\t\t// P1 determines the select method\r\n\t\tswitch (buffer[ISO7816.OFFSET_P1]) {\r\n\t\tcase (byte) 0x02:\r\n\t\t\tselectByFileIdentifier(apdu, buffer);\r\n\t\t\tbreak;\r\n\t\tcase (byte) 0x08:\r\n\t\t\tselectByPath(apdu, buffer);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n\t\t\tbreak; //~allow_dead_code\r\n\t\t}\r\n\t\t// check if activating this file is allowed\r\n\t\tif (!fileAccessAllowed(UPDATE_BINARY))\r\n\t\t\tISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n\t\tJCSystem.beginTransaction();\r\n\t\t//@ open valid(); // hard to eliminate\r\n\t\t//@ open selected_file_types(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, ?sf2);\r\n\t\t//@ sf2.castElementaryToFile();\r\n\t\tselectedFile.setActive(true);\r\n\t\t//@ sf2.castFileToElementary();\r\n\t\t////@ close valid(); // auto\r\n\t\tJCSystem.commitTransaction();\r\n\t}\t\r\n\t\r\n\t/*VF* COPIED FROM EmptyEidCard */\r\n\tstatic byte[] dirData;\r\n\tstatic byte[] tokenInfoData;\r\n\tstatic byte[] odfData;\r\n\tstatic byte[] aodfData;\r\n\tstatic byte[] prkdfData;\r\n\tstatic byte[] cdfData;\r\n\tstatic byte[] citizenCaCert;\r\n\tstatic byte[] rrnCert;\r\n\tstatic byte[] rootCaCert;\r\n\tstatic byte[] photoData;  // save some more memory by making the photo static as well\r\n\t\r\n\t/**\r\n\t * perform any cleanup tasks and set default selectedFile\r\n\t */\r\n\tprivate void clear() \r\n    \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid();\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid();\r\n\t{\r\n\t\tJCSystem.beginTransaction();\r\n\t\t\r\n\t\t// //@ open valid(); // auto\r\n\r\n\t\t// clear signature and random data buffer\r\n\t\tUtil.arrayFillNonAtomic(randomBuffer, (short) 0, (short) 256, (byte) 0);\r\n\t\tUtil.arrayFillNonAtomic(responseBuffer, (short) 0, (short) 128, (byte) 0);\r\n\t\t// no EF and DF selected yet; select MF by default\r\n\t\tselectedFile = masterFile;\r\n\t\t// invalidate cardholder PIN\r\n\t\tcardholderPin.reset();\r\n\t\t/*\r\n\t\t * clear text message buffer, signature and previous ADPU type are\r\n\t\t * transient so no need to reset these manually\r\n\t\t */\r\n\r\n\t\t// open selectedFile.File(?d1, ?d2);\r\n\t\t////@ close valid(); // auto\r\n\r\n\t\tJCSystem.commitTransaction();\r\n\t}\r\n\t/**\r\n\t * initialize empty files that need to be filled latter using UPDATE BINARY\r\n\t */\r\n\tprivate void initializeEmptyLargeFiles() \r\n\t    /*@ requires belpicDirectory |-\u003e ?bpd \u0026*\u0026 bpd != null \u0026*\u0026 bpd.DedicatedFile(_, _, _, ?belpic_sibs, _) \u0026*\u0026 \r\n\t     \t\tlength(belpic_sibs) \u003c 6 \u0026*\u0026\r\n\t    \t\tidDirectory |-\u003e ?idd \u0026*\u0026 idd != null \u0026*\u0026 idd.DedicatedFile(_, _, _, ?iddir_sibs, _) \u0026*\u0026 \r\n\t    \t\tlength(iddir_sibs) \u003c 7 \u0026*\u0026\r\n\t    \t\tcaCertificate |-\u003e _ \u0026*\u0026 rrnCertificate |-\u003e _ \u0026*\u0026 rootCaCertificate |-\u003e _ \u0026*\u0026 \r\n\t    \t\tphotoFile |-\u003e _ \u0026*\u0026 authenticationCertificate |-\u003e _ \u0026*\u0026 nonRepudiationCertificate |-\u003e _; @*/\r\n      \t    /*@ ensures belpicDirectory |-\u003e bpd \u0026*\u0026 \r\n\t    \t\tidDirectory |-\u003e idd \u0026*\u0026\r\n\t    \t\tcaCertificate |-\u003e ?cac \u0026*\u0026 cac.ElementaryFile(CA_CERTIFICATE, bpd, ?d1, true, 0, _) \u0026*\u0026 d1 != null \u0026*\u0026 d1.length == 1200 \u0026*\u0026\r\n\t    \t\trrnCertificate |-\u003e ?rrnc \u0026*\u0026  rrnc.ElementaryFile(RRN_CERTIFICATE, bpd, ?d2, true, 0, _) \u0026*\u0026 d2 != null \u0026*\u0026 d2.length == 1200 \u0026*\u0026\r\n\t    \t\trootCaCertificate |-\u003e ?rootcac \u0026*\u0026  rootcac.ElementaryFile(ROOT_CA_CERTIFICATE, bpd, ?d3, true, 0, _) \u0026*\u0026 d3 != null \u0026*\u0026 d3.length == 1200 \u0026*\u0026\r\n\t    \t\tphotoFile |-\u003e ?pf \u0026*\u0026  pf.ElementaryFile(PHOTO, idd, ?d4, true, 0, _) \u0026*\u0026 d4 != null \u0026*\u0026 d4.length == 3584 \u0026*\u0026\r\n\t    \t\tauthenticationCertificate |-\u003e ?ac \u0026*\u0026  ac.ElementaryFile(AUTH_CERTIFICATE, bpd, ?d5, true, 0, _) \u0026*\u0026 d5 != null \u0026*\u0026 d5.length == 1200 \u0026*\u0026\r\n\t    \t\tnonRepudiationCertificate |-\u003e ?nrc \u0026*\u0026  nrc.ElementaryFile(NONREP_CERTIFICATE, bpd, ?d6, true, 0, _) \u0026*\u0026 d6 != null \u0026*\u0026 d6.length == 1200 \u0026*\u0026\r\n\t    \t\tidd.DedicatedFile(_, _, _, append(iddir_sibs, cons(pf, nil)), _) \u0026*\u0026 \r\n\t    \t\tbpd.DedicatedFile(_, _, _, append(append(append(append(append(belpic_sibs, cons(cac, nil)), cons(rrnc, nil)), cons(rootcac, nil)), cons(ac, nil)), cons(nrc, nil)), _); @*/\r\n\t{\r\n\t\t/*\r\n\t\t * these 3 certificates are the same for all sample eid card applets\r\n\t\t * therefor they are made static and the data is allocated only once\r\n\t\t */\r\n\t\tcaCertificate = new ElementaryFile(CA_CERTIFICATE, belpicDirectory, (short) 1200);\r\n\t\trrnCertificate = new ElementaryFile(RRN_CERTIFICATE, belpicDirectory, (short) 1200);\r\n\t\t\r\n\t\trootCaCertificate = new ElementaryFile(ROOT_CA_CERTIFICATE, belpicDirectory, (short) 1200);\r\n\t\t/*\r\n\t\t * to save some memory we only support 1 photo for all subclasses\r\n\t\t * ideally this should be applet specific and have max size 3584 (3.5K)\r\n\t\t */\r\n\t\tphotoFile = new ElementaryFile(PHOTO, idDirectory, (short) 3584);\r\n\t\t/*\r\n\t\t * certificate #2 and #3 are applet specific allocate enough memory\r\n\t\t */\r\n\t\tauthenticationCertificate = new ElementaryFile(AUTH_CERTIFICATE, belpicDirectory, (short) 1200);\r\n\t\tnonRepudiationCertificate = new ElementaryFile(NONREP_CERTIFICATE, belpicDirectory, (short) 1200);\r\n\t}\r\n\t\r\n\t/**\r\n\t * initialize basic key pair\r\n\t */\r\n\tprivate void initializeKeyPairs() \r\n  \t    //@ requires nonRepKeyPair |-\u003e _ \u0026*\u0026 authKeyPair |-\u003e _ \u0026*\u0026 basicKeyPair |-\u003e _;\r\n      \t    /*@ ensures nonRepKeyPair |-\u003e ?theNonRepKeyPair \u0026*\u0026 theNonRepKeyPair != null \u0026*\u0026\r\n\t      \t    authKeyPair |-\u003e ?theAuthKeyPair \u0026*\u0026 theAuthKeyPair != null \u0026*\u0026\r\n\t      \t    basicKeyPair |-\u003e ?theBasicKeyPair \u0026*\u0026 theBasicKeyPair != null;\r\n\t    @*/\r\n\t{\r\n\t\t/*\r\n\t\t * basicKeyPair is static (so same for all applets) so only allocate\r\n\t\t * memory once\r\n\t\t */\r\n\t\tif (EidCard.basicKeyPair != null \u0026\u0026 authKeyPair != null \u0026\u0026 nonRepKeyPair != null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\tbasicKeyPair = new KeyPair(KeyPair.ALG_RSA_CRT, (short) 1024);\r\n\t\tbasicKeyPair.genKeyPair();\r\n\t\t\r\n\t\tauthKeyPair = new KeyPair(KeyPair.ALG_RSA_CRT, (short) (1024));\r\n\t\tauthKeyPair.genKeyPair();\r\n\t\t\r\n\t\t\r\n\t\r\n\t\t//authPrivateKey = (RSAPrivateCrtKey) KeyBuilder.buildKey(KeyBuilder.TYPE_RSA_CRT_PRIVATE, KeyBuilder.LENGTH_RSA_1024, false);\r\n\t\t\r\n\r\n\t\tnonRepKeyPair = new KeyPair(KeyPair.ALG_RSA_CRT, (short) (1024));\r\n\t\tnonRepKeyPair.genKeyPair();\r\n\t\r\n\t\t//nonRepPrivateKey = (RSAPrivateCrtKey) KeyBuilder.buildKey(KeyBuilder.TYPE_RSA_CRT_PRIVATE, KeyBuilder.LENGTH_RSA_1024, false);\r\n\t}\r\n\t/**\r\n\t * select file under the current DF\r\n\t */\r\n\tprivate void selectByFileIdentifier(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t// receive the data to see which file needs to be selected\r\n\t\tshort byteRead = apdu.setIncomingAndReceive();\r\n\t\t// check Lc\r\n\t\tshort lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n\t\tif ((lc != 2) || (byteRead != 2))\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n\t\t// get the file identifier out of the APDU\r\n\t\tshort fid = Util.makeShort(buffer[ISO7816.OFFSET_CDATA], buffer[ISO7816.OFFSET_CDATA + 1]);\r\n\t\tJCSystem.beginTransaction();\r\n\t\t//@ open valid(); // todo (implement patterns as arguments to rules instead of terms )\r\n\t\t//@ assert selected_file_types(_, ?f1, ?f2, ?f3, ?f4, ?f5, ?f6, ?f7, ?f8, ?f9, ?f10, ?f11, ?f12, ?f13, ?f14, ?f15, ?f16, ?f17, ?f18, ?f19, ?f20, ?f21, _);\r\n\t\t// if file identifier is the master file, select it immediately\r\n\t\tif (fid == MF)\r\n\t\t\tselectedFile = masterFile;\t\t\r\n\t\telse {\r\n\t\t\t// check if the requested file exists under the current DF\r\n\t\t\t////@ close masterFile.DedicatedFile();\r\n\t\t\t////@ MasterFile theMasterFile = masterFile; // auto\r\n\t\t\t////@ assert theMasterFile.MasterFile(16128, null, ?x1, ?x2, ?x3); // auto\r\n\t\t\t////@ close theMasterFile.DedicatedFile(16128, null, x1, x2, x3); // auto\r\n\t\t\tFile s = ((DedicatedFile) masterFile).getSibling(fid);\r\n\t\t\t////@ open theMasterFile.DedicatedFile(16128, null, x1, x2, x3); // auto\r\n\t\t\t//VF /bug\r\n\t\t\tif (s != null) {\r\n\t\t\t\tselectedFile = s;\r\n\t\t\t//the fid is an elementary file:\r\n\t\t\t} else {\r\n\t\t\t\ts = belpicDirectory.getSibling(fid);\r\n\t\t\t\tif (s != null) {\r\n\t\t\t\t\tselectedFile = s;\r\n\t\t\t\t} else {\r\n\t\t\t\t\ts = idDirectory.getSibling(fid);\r\n\t\t\t\t\tif (s != null) {\r\n\t\t\t\t\t\tselectedFile = s;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tISOException.throwIt(ISO7816.SW_FILE_NOT_FOUND);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t//@ close selected_file_types(s, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f20, f21, _);\t\r\n\t\t}\t\r\n\t\t\r\n\t\t// //@ close valid(); // auto\r\n\t\tJCSystem.commitTransaction();\r\n\t}\r\n\t/**\r\n\t * select file by path from the MF\r\n\t */\r\n\tprivate void selectByPath(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t// receive the path name\r\n\t\tshort byteRead = apdu.setIncomingAndReceive();\r\n\t\t// check Lc\r\n\t\t////@ masking_and(buffer[ISO7816.OFFSET_LC], 0x00FF);\r\n\t\tshort lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n\t\t// it must be a multiple of 2\r\n\t\tif (((lc \u0026 1) == 1) || ((byteRead \u0026 1) == 1))\r\n\t\t\tISOException.throwIt(SW_INCONSISTENT_P1P2);\r\n\t\tif (buffer.length \u003c ISO7816.OFFSET_CDATA + lc + 1)\r\n\t\t\tISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n\t\t////@ open [1/2]valid(); // auto\r\n\t\t// use the path name in the APDU data to select a file\r\n\t\tFile f = masterFile;\r\n\t\t////@ assert [1/2]masterFile |-\u003e ?theMasterFile;\r\n\t\tfor (byte i = 0; i \u003c lc; i += 2) \r\n\t\t    /*@ invariant array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 i \u003e= 0 \u0026*\u0026 i \u003c (lc + 2) \u0026*\u0026 \r\n\t\t    \t\t\t[1/2]randomBuffer |-\u003e ?theRandomBuffer \u0026*\u0026 theRandomBuffer != null \u0026*\u0026 [1/2]array_slice(theRandomBuffer, 0, theRandomBuffer.length, _) \u0026*\u0026 theRandomBuffer.length == 256 \u0026*\u0026\r\n\t\t\t\t    [1/2]responseBuffer |-\u003e ?theResponseBuffer \u0026*\u0026 theResponseBuffer != null \u0026*\u0026 [1/2]array_slice(theResponseBuffer, 0, theResponseBuffer.length, _) \u0026*\u0026 theResponseBuffer.length == 128 \u0026*\u0026\r\n\t\t\t\t    [1/2]randomData |-\u003e ?theRandomData \u0026*\u0026 theRandomData != null \u0026*\u0026\r\n\t\t\t\t    [1/2]cipher |-\u003e ?theCipher \u0026*\u0026 theCipher != null \u0026*\u0026\r\n\t\t\t\t    [1/2]messageBuffer |-\u003e ?theMessageBuffer \u0026*\u0026 theMessageBuffer != null \u0026*\u0026 theMessageBuffer.length == 128 \u0026*\u0026 is_transient_byte_array(theMessageBuffer) == true \u0026*\u0026\r\n\t\t\t\t    [1/2]previousApduType |-\u003e ?thePreviousApduType \u0026*\u0026 thePreviousApduType != null \u0026*\u0026 thePreviousApduType.length == 1 \u0026*\u0026 is_transient_byte_array(thePreviousApduType) == true \u0026*\u0026\r\n\t\t\t\t    [1/2]signatureType |-\u003e ?theSignatureType \u0026*\u0026 theSignatureType != null \u0026*\u0026 theSignatureType.length == 1 \u0026*\u0026 is_transient_byte_array(theSignatureType) == true \u0026*\u0026\r\n\t\t\t\t    [1/2]masterFile |-\u003e ?theMasterFile \u0026*\u0026 [1/2]theMasterFile.MasterFile(0x3F00, null, _, ?masterSibs, _) \u0026*\u0026 theMasterFile != null \u0026*\u0026 theMasterFile.getClass() == MasterFile.class \u0026*\u0026\r\n\t\t\t\t    [1/2]cardholderPin |-\u003e ?theCardholderPin \u0026*\u0026 [1/2]OwnerPIN(theCardholderPin, _, _) \u0026*\u0026 theCardholderPin != null \u0026*\u0026 \r\n\t\t\t\t    [1/2]resetPin |-\u003e ?theResetPin \u0026*\u0026 [1/2]OwnerPIN(theResetPin, _, _) \u0026*\u0026 theResetPin != null \u0026*\u0026\r\n\t\t\t\t    [1/2]unblockPin |-\u003e ?theUnblockPin \u0026*\u0026 [1/2]OwnerPIN(theUnblockPin, _, _) \u0026*\u0026 theUnblockPin != null \u0026*\u0026\r\n\t\t\t\t    [1/2]activationPin |-\u003e ?theActivationPin \u0026*\u0026 [1/2]OwnerPIN(theActivationPin, _, _) \u0026*\u0026 theActivationPin != null \u0026*\u0026\r\n\t\t\t\t    [1/2]identityFile |-\u003e ?theIdentityFile \u0026*\u0026 [1/2]theIdentityFile.ElementaryFile(_, _, ?identityData, _, _, _) \u0026*\u0026 theIdentityFile != null \u0026*\u0026 identityData != null \u0026*\u0026 identityData.length == 0xD0 \u0026*\u0026 theIdentityFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t\t\t\t    [1/2]identityFileSignature |-\u003e ?theIdentityFileSignature \u0026*\u0026 [1/2]theIdentityFileSignature.ElementaryFile(_, _, ?theIdentityFileSignatureData, _, _, _) \u0026*\u0026 theIdentityFileSignature != null \u0026*\u0026 theIdentityFileSignatureData != null \u0026*\u0026 theIdentityFileSignatureData.length == 0x80 \u0026*\u0026 theIdentityFileSignature.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t\t\t\t    [1/2]addressFile |-\u003e ?theAddressFile \u0026*\u0026 [1/2]theAddressFile.ElementaryFile(_, _, ?theAddressFileData, _, _, _) \u0026*\u0026 theAddressFile != null \u0026*\u0026 theAddressFileData != null \u0026*\u0026 theAddressFileData.length == 117 \u0026*\u0026 theAddressFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t\t\t\t    [1/2]addressFileSignature |-\u003e ?theAddressFileSignature \u0026*\u0026 [1/2]theAddressFileSignature.ElementaryFile(_, _, ?theAddressFileSignatureData, _, _, _) \u0026*\u0026 theAddressFileSignature != null \u0026*\u0026 theAddressFileSignatureData != null \u0026*\u0026 theAddressFileSignatureData.length == 128 \u0026*\u0026 theAddressFileSignature.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t\t\t\t    [1/2]photoFile |-\u003e ?thePhotoFile \u0026*\u0026 [1/2]thePhotoFile.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 thePhotoFile != null \u0026*\u0026 thePhotoFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t\t\t\t    [1/2]caRoleIDFile |-\u003e ?thecaRoleIDFile \u0026*\u0026 [1/2]thecaRoleIDFile.ElementaryFile(_, _, ?theCaRoleIDFileData, _, _, _) \u0026*\u0026 thecaRoleIDFile != null \u0026*\u0026 theCaRoleIDFileData != null \u0026*\u0026 theCaRoleIDFileData.length == 0x20 \u0026*\u0026 thecaRoleIDFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t\t\t\t    [1/2]dirFile |-\u003e ?theDirFile \u0026*\u0026 [1/2]theDirFile.ElementaryFile(_, _, ?theDirFileData, _, _, _) \u0026*\u0026 theDirFile != null \u0026*\u0026 theDirFileData != null \u0026*\u0026 theDirFileData.length ==  0x25 \u0026*\u0026 theDirFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t\t\t\t    [1/2]tokenInfo |-\u003e ?theTokenInfo \u0026*\u0026 [1/2]theTokenInfo.ElementaryFile(_, _, ?theTokenInfoData, _, _, _) \u0026*\u0026 theTokenInfo != null \u0026*\u0026 theTokenInfoData != null \u0026*\u0026 theTokenInfoData.length == 0x30 \u0026*\u0026 theTokenInfo.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t\t\t\t    [1/2]objectDirectoryFile |-\u003e ?theObjectDirectoryFile \u0026*\u0026 [1/2]theObjectDirectoryFile.ElementaryFile(_, _, ?theObjectDirectoryFileData, _, _, _) \u0026*\u0026 theObjectDirectoryFile != null \u0026*\u0026 theObjectDirectoryFileData != null \u0026*\u0026 theObjectDirectoryFileData.length == 40 \u0026*\u0026 theObjectDirectoryFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t\t\t\t    [1/2]authenticationObjectDirectoryFile |-\u003e ?theAuthenticationObjectDirectoryFile \u0026*\u0026 [1/2]theAuthenticationObjectDirectoryFile.ElementaryFile(_, _, ?theAuthenticationObjectDirectoryFileData, _, _, _) \u0026*\u0026 theAuthenticationObjectDirectoryFile != null \u0026*\u0026 theAuthenticationObjectDirectoryFileData != null \u0026*\u0026 theAuthenticationObjectDirectoryFileData.length == 0x40 \u0026*\u0026  theAuthenticationObjectDirectoryFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t\t\t\t    [1/2]privateKeyDirectoryFile |-\u003e ?thePrivateKeyDirectoryFile \u0026*\u0026 [1/2]thePrivateKeyDirectoryFile.ElementaryFile(_, _, ?thePrivateKeyDirectoryFileData, _, _, _) \u0026*\u0026 thePrivateKeyDirectoryFile != null \u0026*\u0026 thePrivateKeyDirectoryFileData != null \u0026*\u0026 thePrivateKeyDirectoryFileData.length == 0xB0 \u0026*\u0026 thePrivateKeyDirectoryFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t\t\t\t    [1/2]certificateDirectoryFile |-\u003e ?theCertificateDirectoryFile \u0026*\u0026 [1/2]theCertificateDirectoryFile.ElementaryFile(_, _, ?theCertificateDirectoryFileData, _, _, _) \u0026*\u0026 theCertificateDirectoryFile != null \u0026*\u0026 theCertificateDirectoryFileData != null \u0026*\u0026 theCertificateDirectoryFileData.length == 0xB0 \u0026*\u0026 theCertificateDirectoryFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t\t\t\t    [1/2]belpicDirectory |-\u003e ?theBelpicDirectory \u0026*\u0026 [1/2]theBelpicDirectory.DedicatedFile(_, _, _, ?belpicSibs, _) \u0026*\u0026 theBelpicDirectory != null \u0026*\u0026 theBelpicDirectory.getClass() == DedicatedFile.class \u0026*\u0026\r\n\t\t\t\t    [1/2]idDirectory |-\u003e ?theIdDirectory \u0026*\u0026 [1/2]theIdDirectory.DedicatedFile(_, _, _, ?idSibs, _) \u0026*\u0026 theIdDirectory != null \u0026*\u0026 theIdDirectory.getClass() == DedicatedFile.class \u0026*\u0026\r\n\t\t\t\t    [1/2]caCertificate |-\u003e ?theCaCertificate \u0026*\u0026 [1/2]theCaCertificate.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 theCaCertificate.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t\t\t\t    [1/2]selectedFile |-\u003e ?theSelectedFile \u0026*\u0026 theSelectedFile != null \u0026*\u0026\r\n\t\t\t\t    masterSibs == cons\u003cFile\u003e(theDirFile, cons(theBelpicDirectory, cons(theIdDirectory, nil))) \u0026*\u0026\r\n\t\t\t\t    [1/2]rootCaCertificate |-\u003e ?theRootCaCertificate \u0026*\u0026 [1/2]theRootCaCertificate.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 theRootCaCertificate.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t\t\t\t    [1/2]rrnCertificate |-\u003e ?theRrnCertificate \u0026*\u0026 [1/2]theRrnCertificate.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 theRrnCertificate.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t\t\t\t    [1/2]authenticationCertificate |-\u003e ?theAuthenticationCertificate \u0026*\u0026 [1/2]theAuthenticationCertificate.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 theAuthenticationCertificate.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t\t\t\t    [1/2]nonRepudiationCertificate |-\u003e ?theNonRepudiationCertificate \u0026*\u0026 [1/2]theNonRepudiationCertificate.ElementaryFile(_, _, _, _, _, _) \u0026*\u0026 theNonRepudiationCertificate.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t\t\t\t    [1/2]preferencesFile |-\u003e ?thePreferencesFile \u0026*\u0026 thePreferencesFile != theCaCertificate \u0026*\u0026 thePreferencesFile != theRrnCertificate \u0026*\u0026 [1/2]thePreferencesFile.ElementaryFile(_, _, ?thePreferencesFileData, _, _, _) \u0026*\u0026 thePreferencesFile != null \u0026*\u0026 thePreferencesFileData != null \u0026*\u0026 thePreferencesFileData.length == 100 \u0026*\u0026 thePreferencesFile.getClass() == ElementaryFile.class \u0026*\u0026\r\n\t\t\t\t    belpicSibs == cons\u003cFile\u003e(theTokenInfo, cons(theObjectDirectoryFile, cons(theAuthenticationObjectDirectoryFile, cons(thePrivateKeyDirectoryFile, cons(theCertificateDirectoryFile, cons(theCaCertificate, cons(theRrnCertificate, cons(theRootCaCertificate, cons(theAuthenticationCertificate, cons(theNonRepudiationCertificate, nil)))))))))) \u0026*\u0026\r\n\t\t\t\t    idSibs == cons\u003cFile\u003e(theIdentityFile, cons(theIdentityFileSignature, cons(theAddressFile, cons(theAddressFileSignature, cons(thecaRoleIDFile, cons(thePreferencesFile, cons(thePhotoFile, nil))))))) \u0026*\u0026\r\n\t\t\t\t    [1/2]selected_file_types(theSelectedFile, theMasterFile, theBelpicDirectory, theIdDirectory, theIdentityFile, theIdentityFileSignature, theAddressFile, theAddressFileSignature, thePhotoFile, thecaRoleIDFile, theDirFile, theTokenInfo, theObjectDirectoryFile, theAuthenticationObjectDirectoryFile, thePrivateKeyDirectoryFile, theCaCertificate, theCertificateDirectoryFile, theRrnCertificate, theRootCaCertificate, theAuthenticationCertificate, theNonRepudiationCertificate, thePreferencesFile, _) \u0026*\u0026\r\n\t\t\t    \t    (theSelectedFile.getClass() == ElementaryFile.class || theSelectedFile.getClass() == MasterFile.class || theSelectedFile.getClass() == DedicatedFile.class) \u0026*\u0026\r\n\t\t\t      \t    /*internalAuthenticateCounter |-\u003e ?theInternalAuthenticateCounter \u0026*\u0026*/\r\n\t\t\t\t    [1/2]signatureAlgorithm |-\u003e ?theSignatureAlgorithm \u0026*\u0026\r\n\t\t\t\t    [1/2]nonRepKeyPair |-\u003e ?theNonRepKeyPair \u0026*\u0026 theNonRepKeyPair != null \u0026*\u0026\r\n\t\t\t\t    [1/2]authKeyPair |-\u003e ?theAuthKeyPair \u0026*\u0026 theAuthKeyPair != null \u0026*\u0026\r\n\t\t\t\t    [1/2]basicKeyPair |-\u003e ?theBasicKeyPair \u0026*\u0026\r\n\t\t\t\t    [1/2]PKCS1_HEADER |-\u003e ?thePKCS1HEADER \u0026*\u0026 thePKCS1HEADER != null \u0026*\u0026 [1/2]array_slice(thePKCS1HEADER, 0, thePKCS1HEADER.length, _) \u0026*\u0026 thePKCS1HEADER.length == 1 \u0026*\u0026\r\n\t\t\t\t    [1/2]PKCS1_SHA1_HEADER |-\u003e ?thePKCS1SHA1HEADER \u0026*\u0026 thePKCS1SHA1HEADER != null \u0026*\u0026 [1/2]array_slice(thePKCS1SHA1HEADER, 0, thePKCS1SHA1HEADER.length, _) \u0026*\u0026 thePKCS1SHA1HEADER.length == 16 \u0026*\u0026\r\n\t\t\t\t    [1/2]PKCS1_MD5_HEADER |-\u003e ?thePKCS1MD5HEADER \u0026*\u0026 thePKCS1MD5HEADER != null \u0026*\u0026 [1/2]array_slice(thePKCS1MD5HEADER, 0, thePKCS1MD5HEADER.length, _) \u0026*\u0026 thePKCS1MD5HEADER.length == 19 \u0026*\u0026\r\n\t\t\t\t    theDirFile != thePreferencesFile \u0026*\u0026 theTokenInfo != thePreferencesFile \u0026*\u0026 thePreferencesFile != theObjectDirectoryFile \u0026*\u0026 thePreferencesFile != theAuthenticationObjectDirectoryFile \u0026*\u0026 thePreferencesFile != thePrivateKeyDirectoryFile \u0026*\u0026\r\n\t\t\t\t    (f == null ? \r\n\t\t\t\t      true \r\n\t\t\t\t        : \r\n\t\t\t\t      selected_file_types(f, theMasterFile, theBelpicDirectory, theIdDirectory, theIdentityFile, theIdentityFileSignature, theAddressFile, theAddressFileSignature, thePhotoFile, thecaRoleIDFile, theDirFile, theTokenInfo, theObjectDirectoryFile, theAuthenticationObjectDirectoryFile, thePrivateKeyDirectoryFile, theCaCertificate, theCertificateDirectoryFile, theRrnCertificate, theRootCaCertificate, theAuthenticationCertificate, theNonRepudiationCertificate, thePreferencesFile, _) \u0026*\u0026\r\n\t\t\t\t      f.getClass() == ElementaryFile.class || f.getClass() == MasterFile.class || f.getClass() == DedicatedFile.class\t\t\t                 \r\n\t\t\t\t    ) \u0026*\u0026\r\n\t\t\t\t    (i == 0 ? \r\n\t\t\t\t      f == theMasterFile \r\n\t\t\t\t        :\r\n\t\t\t\t      (i \u003c= 2 ?\r\n\t\t\t\t        f == null || f == theMasterFile || mem(f, masterSibs) \r\n\t\t\t\t          :\r\n\t\t\t\t        (i \u003c= 4 ?\r\n\t\t\t\t          f == null || mem(f, masterSibs) || mem(f, belpicSibs) || mem(f, idSibs)\r\n\t\t\t\t        :\r\n\t\t\t\t          (i \u003c= 6 ?\r\n\t\t\t\t            f == null || mem(f, belpicSibs) || mem(f, idSibs)\r\n\t\t\t\t              :\r\n\t\t\t\t            false\r\n\t\t\t\t          )\r\n\t\t\t\t        )\r\n\t\t\t\t      )\r\n\t\t\t\t    ); @*/\r\n\t\t{\r\n\t\t\tshort fid = Util.makeShort(buffer[(short) (ISO7816.OFFSET_CDATA + i)], buffer[(short) (ISO7816.OFFSET_CDATA + i + 1)]);\r\n\t\t\t// MF can be explicitely or implicitely in the path name\r\n\t\t\tif ((i == 0) \u0026\u0026 (fid == MF))\r\n\t\t\t\tf = masterFile;\r\n\t\t\telse {\r\n\t\t\t        \r\n\t\t\t\tif ((f instanceof ElementaryFile) || f == null)\r\n\t\t\t\t\tISOException.throwIt(ISO7816.SW_FILE_NOT_FOUND);\r\n\t\t\t\t//@ open selected_file_types(f, theMasterFile, theBelpicDirectory, theIdDirectory, theIdentityFile, theIdentityFileSignature, theAddressFile, theAddressFileSignature, thePhotoFile, thecaRoleIDFile, theDirFile, theTokenInfo, theObjectDirectoryFile, theAuthenticationObjectDirectoryFile, thePrivateKeyDirectoryFile, theCaCertificate, theCertificateDirectoryFile, theRrnCertificate, theRootCaCertificate, theAuthenticationCertificate, theNonRepudiationCertificate, thePreferencesFile, _);\r\n\t\t\t\t//@ File oldf = f;\r\n\t\t\t\t/*@ \r\n\t\t\t\tif(f == masterFile) \r\n\t\t\t\t{} else if (f == idDirectory) {} else {}\r\n\t\t\t\t@*/\r\n\t\t\t\t/*@\r\n\t\t\t\tif(f == masterFile) {\r\n\t\t\t\t  masterFile.castMasterToDedicated();\r\n\t\t  \t\t}\t  \t\t\r\n\t\t  \t\t@*/\r\n\t\t\t\tf = ((DedicatedFile) f).getSibling(fid);\r\n\t\t\t\t/*@ if(oldf == masterFile) {\r\n\t\t\t  \t      masterFile.castDedicatedToMaster();\r\n\t\t\t  \t      assert f == null || (f == idDirectory \u0026\u0026 f.getClass() == DedicatedFile.class) || (f == belpicDirectory \u0026\u0026 f.getClass() == DedicatedFile.class)|| (f == dirFile \u0026\u0026 f.getClass() == ElementaryFile.class);\r\n\t\t\t\t    } \r\n\t\t\t\t@*/\r\n\t\t\t\t/*@\r\n\t\t\t\t  if(f != null) {\r\n\t\t\t\t    close selected_file_types(f, theMasterFile, theBelpicDirectory, theIdDirectory, theIdentityFile, theIdentityFileSignature, theAddressFile, theAddressFileSignature, thePhotoFile, thecaRoleIDFile, theDirFile, theTokenInfo, theObjectDirectoryFile, theAuthenticationObjectDirectoryFile, thePrivateKeyDirectoryFile, theCaCertificate, theCertificateDirectoryFile, theRrnCertificate, theRootCaCertificate, theAuthenticationCertificate, theNonRepudiationCertificate, thePreferencesFile, _);\r\n\t\t\t\t  }\r\n\t\t\t\t@*/\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (f == null)\r\n\t\t\tISOException.throwIt(ISO7816.SW_FILE_NOT_FOUND);\r\n\r\n\t\tJCSystem.beginTransaction();\r\n\t\t////@ open [1/2]valid(); // auto\r\n\t\t////@ open selected_file_types(f, ?g1, ?g2, ?g3, ?g4, ?g5, ?g6, ?g7, ?g8, ?g9, ?g10, ?g11, ?g12, ?g13, ?g14, ?g15, ?g16, ?g17, ?g18, ?g19, ?g20, ?g21, _);\r\n\t\tselectedFile = f;\r\n\t\t////@ close selected_file_types(f, g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11, g12, g13, g14, g15, g16, g17, g18, g19, g20, g21, _);\r\n\t\t////@ close valid(); // auto\r\n\t\tJCSystem.commitTransaction();\r\n\t}\r\n\r\n\t/*VF* END COPY */\r\n\t\r\n\r\n\t/**\r\n\t * initialize all the PINs\r\n\t * \r\n\t * PINs are set to the same values as the sample eID card\r\n\t */\r\n\tprivate void initializePins() \r\n  \t    /*@ requires this.cardholderPin |-\u003e _ \u0026*\u0026 this.resetPin |-\u003e _\r\n  \t    \t\t\t\u0026*\u0026 this.unblockPin |-\u003e _ \u0026*\u0026 this.activationPin |-\u003e _;\r\n  \t    @*/\r\n      \t    /*@ ensures this.cardholderPin |-\u003e ?theCardholderPin \u0026*\u0026 OwnerPIN(theCardholderPin, _, _) \u0026*\u0026 theCardholderPin != null \r\n\t\t\t\u0026*\u0026 this.resetPin |-\u003e ?theResetPin \u0026*\u0026 OwnerPIN(theResetPin, _, _) \u0026*\u0026 theResetPin != null\r\n\t\t\t\u0026*\u0026 this.unblockPin |-\u003e ?theUnblockPin \u0026*\u0026 OwnerPIN(theUnblockPin, _, _) \u0026*\u0026 theUnblockPin != null\r\n\t\t\t\u0026*\u0026 this.activationPin |-\u003e ?theActivationPin \u0026*\u0026 OwnerPIN(theActivationPin, _, _) \u0026*\u0026 theActivationPin != null;\r\n      \t    @*/\r\n      \t    //this.cardholderPin |-\u003e ?theCardholderPin \u0026*\u0026 \r\n\t{\r\n\t\t/*\r\n\t\t * initialize cardholder PIN (hardcoded to fixed value)\r\n\t\t * \r\n\t\t * PIN header is \"24\" (length of PIN = 4) PIN itself is \"1234\" (4\r\n\t\t * digits) fill rest of PIN data with F\r\n\t\t */\r\n\t\t/*VF*byte[] cardhold = { (byte) 0x24, (byte) 0x12, (byte) 0x34, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }; */\r\n\t\tbyte cardhold[] = new byte[] { (byte) 0x24, (byte) 0x12, (byte) 0x34, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF };\r\n\t\tcardholderPin = new OwnerPIN(CARDHOLDER_PIN_TRY_LIMIT, PIN_SIZE);\r\n\t\tcardholderPin.update(cardhold, (short) 0, PIN_SIZE);\r\n\t\t/*\r\n\t\t * initialize unblock PUK (hardcoded to fixed value)\r\n\t\t * \r\n\t\t * PUK header is \"2c\" (length of PUK = 12) PUK itself consists of 2\r\n\t\t * parts PUK2 is \"222222\" (6 digits) PUK1 is \"111111\" (6 digits) so in\r\n\t\t * total the PUK is \"222222111111\" (12 digits) fill last bye of PUK data\r\n\t\t * with \"FF\"\r\n\t\t */\r\n\t\t/*VF* byte[] unblock = { (byte) 0x2c, (byte) 0x22, (byte) 0x22, (byte) 0x22, (byte) 0x11, (byte) 0x11, (byte) 0x11, (byte) 0xFF }; */\r\n\t\tbyte unblock[] = new byte[] { (byte) 0x2c, (byte) 0x22, (byte) 0x22, (byte) 0x22, (byte) 0x11, (byte) 0x11, (byte) 0x11, (byte) 0xFF };\r\n\t\tunblockPin = new OwnerPIN(UNBLOCK_PIN_TRY_LIMIT, PIN_SIZE);\r\n\t\tunblockPin.update(unblock, (short) 0, PIN_SIZE);\r\n\t\t/*\r\n\t\t * activation PIN is same as PUK\r\n\t\t */\r\n\t\tactivationPin = new OwnerPIN(ACTIVATE_PIN_TRY_LIMIT, PIN_SIZE);\r\n\t\tactivationPin.update(unblock, (short) 0, PIN_SIZE);\r\n\t\t/*\r\n\t\t * initialize reset PIN (hardcoded to fixed value)\r\n\t\t * \r\n\t\t * PUK header is \"2c\" (length of PUK = 12) PIN itself consists of 2\r\n\t\t * parts PUK3 is \"333333\" (6 digits) PUK1 is \"111111\" (6 digits) so in\r\n\t\t * total the PIN is \"333333111111\" (12 digits) fill last bye of PIN data\r\n\t\t * with \"FF\"\r\n\t\t */\r\n\t\t/*VF* byte[] reset = { (byte) 0x2c, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x11, (byte) 0x11, (byte) 0x11, (byte) 0xFF }; */\r\n\t\tbyte reset[] = new byte[] { (byte) 0x2c, (byte) 0x33, (byte) 0x33, (byte) 0x33, (byte) 0x11, (byte) 0x11, (byte) 0x11, (byte) 0xFF };\r\n\t\tresetPin = new OwnerPIN(RESET_PIN_TRY_LIMIT, PIN_SIZE);\r\n\t\tresetPin.update(reset, (short) 0, PIN_SIZE);\r\n\t}\r\n\t\r\n\t/**\r\n\t * private constructor - called by the install method to instantiate a\r\n\t * EidCard instance\r\n\t * \r\n\t * needs to be protected so that it can be invoked by subclasses\r\n\t */\r\n\tprotected EidCard() \r\n    \t/*@ requires class_init_token(EidCard.class) \u0026*\u0026 system(); @*/\r\n    \t//@ ensures true;\r\n\t{\r\n\t\t//@ init_class();\r\n\t\t//internalAuthenticateCounter = 5000;\r\n\r\n\t\trandomBuffer = new byte[256];\r\n\t\tresponseBuffer = new byte[128];\r\n\t\t// initialize these objects once for the superclass\r\n\t\t// otherwise we have RAM problems when running multiple EidCard applets\r\n\t\tif (EidCard.randomData == null)\r\n\t\t\tEidCard.randomData = RandomData.getInstance(RandomData.ALG_SECURE_RANDOM);\r\n\t\tif (EidCard.cipher == null)\r\n\t\t\tEidCard.cipher = Cipher.getInstance(Cipher.ALG_RSA_NOPAD, false);\r\n\t\tCipher c =  Cipher.getInstance(Cipher.ALG_RSA_NOPAD, false);\r\n\t\tif (EidCard.messageBuffer == null)\r\n\t\t\tEidCard.messageBuffer = JCSystem.makeTransientByteArray((short) 128, JCSystem.CLEAR_ON_DESELECT);\r\n\t\t// make these transient objects so that they are stored in RAM\r\n\t\tpreviousApduType = JCSystem.makeTransientByteArray((short) 1, JCSystem.CLEAR_ON_DESELECT);\r\n\t\tsignatureType = JCSystem.makeTransientByteArray((short) 1, JCSystem.CLEAR_ON_DESELECT);\r\n\t\t// register the applet instance with the JCRE\r\n\r\n\t\t/*VF* COPIED FROM EmptyEidCard */\r\n\t\t// initialize PINs to fixed value\r\n\t\tinitializePins();\r\n\t\t// initialize file system\r\n\t\tinitializeFileSystem();\r\n\t\t// initialize place holders for large files (certificates + photo)\r\n\t\tinitializeEmptyLargeFiles();\r\n\t\t// initialize basic keys pair\r\n\t\tinitializeKeyPairs();\r\n\t\t/*VF* END COPY */\r\n \t\t//@ preferencesFile.neq(caCertificate);\r\n \t\t//@ preferencesFile.neq(rrnCertificate);\r\n \t\t//@ preferencesFile.neq(dirFile);\r\n \t\t//@ preferencesFile.neq(tokenInfo);\r\n \t\t//@ preferencesFile.neq(objectDirectoryFile);\r\n \t\t//@ preferencesFile.neq(authenticationObjectDirectoryFile);\r\n \t\t//@ preferencesFile.neq(privateKeyDirectoryFile);\r\n\t\t////@ close valid(); // auto\r\n\t\tregister();\r\n\t}\r\n\t/**\r\n\t * initialize the applet when it is selected\r\n\t * \r\n\t * select always has to happen after a reset\r\n\t */\r\n\tpublic boolean select() \r\n            //@ requires current_applet(this) \u0026*\u0026 [1/2]valid();\r\n            //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid();\r\n\t{\r\n\t\t// Clear data and set default selectedFile to masterFile\r\n\t\tclear();\r\n\t\treturn true;\r\n\t}\r\n\t/**\r\n\t * perform any cleanup and bookkeeping tasks before the applet is deselected\r\n\t */\r\n\tpublic void deselect() \r\n    \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid();\r\n    \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid();\r\n\t{\r\n\t\tclear();\r\n\t\treturn;\r\n\t}\r\n\t/**\r\n\t * process APDUs\r\n\t */\r\n\tpublic void process(APDU apdu) \r\n            //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, ?buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _);\r\n            //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _);\r\n\t{\r\n\t\tbyte[] buffer = apdu.getBuffer();\r\n\t\t/*\r\n\t\t * - non repudiation signatures can only be generated if the previous\r\n\t\t * APDU verified the cardholder PIN - administrator PIN change is only\r\n\t\t * possible if the previous APDU verified the reset PIN\r\n\t\t * \r\n\t\t * so only the \"generate signature\" and PIN Change APDU needs to check\r\n\t\t * the previous APDU type; in all other cases overwrite the previous\r\n\t\t * APDU type, because this information is not needed; we do this as\r\n\t\t * early as possible to cope with exceptions being thrown during\r\n\t\t * processing of APDU\r\n\t\t * \r\n\t\t * IMPORTANT : we have to set the previous APDU type in the processing\r\n\t\t * of a PIN Verify APDU (because the type gets overwritten to a wrong\r\n\t\t * value) and at the end of a \"generate signature\" and PIN Change APDU\r\n\t\t */\r\n\t\tJCSystem.beginTransaction();\r\n\t\t////@ open valid(); // auto\r\n\t\tif ((buffer[ISO7816.OFFSET_INS] != INS_GENERATE_SIGNATURE) \u0026\u0026 (buffer[ISO7816.OFFSET_INS] != INS_CHANGE_PIN) \u0026\u0026 (buffer[ISO7816.OFFSET_INS] != INS_GET_KEY))\r\n\t\t\tsetPreviousApduType(OTHER);\r\n\t\t////@ close valid(); // auto\r\n\t\tJCSystem.commitTransaction();\r\n\t\t// return if the APDU is the applet SELECT command\r\n\t\tif (selectingApplet()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (buffer[ISO7816.OFFSET_CLA] == EIDCARD_CLA_1)\r\n\t\t\t// check the INS byte to decide which service method to call\r\n\t\t\tswitch (buffer[ISO7816.OFFSET_INS]) {\r\n\t\t\t// case INS_CHANGE_ATR :\r\n\t\t\t// changeATR(apdu);\r\n\t\t\t// break;\r\n\t\t\tcase INS_VERIFY_PIN:\r\n\t\t\t\tverifyPin(apdu, buffer);\r\n\t\t\t\tbreak;\r\n\t\t\tcase INS_CHANGE_PIN:\r\n\t\t\t\tchangePin(apdu, buffer);\r\n\t\t\t\tbreak;\r\n\t\t\tcase INS_UNBLOCK:\r\n\t\t\t\tunblock(apdu, buffer);\r\n\t\t\t\tbreak;\r\n\t\t\tcase INS_GET_CHALLENGE:\r\n\t\t\t\tgetChallenge(apdu, buffer);\r\n\t\t\t\tbreak;\r\n\t\t\tcase INS_PREPARE_SIGNATURE:\r\n\t\t\t\tprepareForSignature(apdu, buffer);\r\n\t\t\t\tbreak;\r\n\t\t\tcase INS_GENERATE_SIGNATURE:\r\n\t\t\t\tgenerateSignature(apdu, buffer);\r\n\t\t\t\tbreak;\r\n\t\t\tcase INS_GENERATE_KEYPAIR:\r\n\t\t\t\tgenerateKeyPair(apdu);\r\n\t\t\t\tbreak;\r\n\t\t\tcase INS_INTERNAL_AUTHENTICATE:\r\n\t\t\t\tinternalAuthenticate(apdu, buffer);\r\n\t\t\t\tbreak;\r\n\t\t\tcase INS_GET_RESPONSE:\r\n\t\t\t\t// if only T=0 supported: remove\r\n\t\t\t\t// not possible in case of T=0 protocol\r\n\t\t\t\tif (APDU.getProtocol() == APDU.PROTOCOL_T1)\r\n\t\t\t\t\tgetResponse(apdu, buffer);\r\n\t\t\t\telse\r\n\t\t\t\t\tISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);\r\n\t\t\t\tbreak;\r\n\t\t\tcase INS_SELECT_FILE:\r\n\t\t\t\tselectFile(apdu, buffer);\r\n\t\t\t\tbreak;\r\n\t\t\tcase INS_ACTIVATE_FILE:\r\n\t\t\t\tactivateFile(apdu, buffer);\r\n\t\t\t\tbreak;\r\n\t\t\tcase INS_DEACTIVATE_FILE:\r\n\t\t\t\tdeactivateFile(apdu, buffer);\r\n\t\t\t\tbreak;\r\n\t\t\tcase INS_READ_BINARY:\r\n\t\t\t\treadBinary(apdu, buffer);\r\n\t\t\t\tbreak;\r\n\t\t\tcase INS_UPDATE_BINARY:\r\n\t\t\t\tupdateBinary(apdu, buffer);\r\n\t\t\t\tbreak;\r\n\t\t\tcase INS_ERASE_BINARY:\r\n\t\t\t\teraseBinary(apdu, buffer);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);\r\n\t\t\t\tbreak; //~allow_dead_code\r\n\t\t\t}\r\n\t\telse if (buffer[ISO7816.OFFSET_CLA] == EIDCARD_CLA_2)\r\n\t\t\tswitch (buffer[ISO7816.OFFSET_INS]) {\r\n\t\t\tcase INS_GET_KEY:\r\n\t\t\t\tgetPublicKey(apdu);\r\n\t\t\t\tbreak;\r\n\t\t\tcase INS_PUT_KEY:\r\n\t\t\t\tputPublicKey(apdu, buffer);\r\n\t\t\t\tbreak;\r\n\t\t\tcase INS_ERASE_KEY:\r\n\t\t\t\teraseKey(apdu, buffer);\r\n\t\t\t\tbreak;\r\n\t\t\tcase INS_ACTIVATE_KEY:\r\n\t\t\t\tactivateKey(apdu, buffer);\r\n\t\t\t\tbreak;\r\n\t\t\tcase INS_DEACTIVATE_KEY:\r\n\t\t\t\tdeactivateKey(apdu, buffer);\r\n\t\t\t\tbreak;\r\n\t\t\tcase INS_GET_CARD_DATA:\r\n\t\t\t\tgetCardData(apdu, buffer);\r\n\t\t\t\tbreak;\r\n\t\t\tcase INS_LOG_OFF:\r\n\t\t\t\tlogOff(apdu, buffer);\r\n\t\t\t\tbreak;\r\n\t\t\t// case INS_BLOCK :\r\n\t\t\t// blockCard(apdu, buffer);\r\n\t\t\t// break;\r\n\t\t\t}\r\n\t\telse\r\n\t\t\tISOException.throwIt(ISO7816.SW_CLA_NOT_SUPPORTED);\r\n\t}\r\n\t/**\r\n\t * verify the PIN\r\n\t */\r\n\tprivate void verifyPin(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t\r\n\t\t// check P1\r\n\t\tif (buffer[ISO7816.OFFSET_P1] != (byte) 0x00)\r\n\t\t\tISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n\t\t// receive the PIN data for validation\r\n\t\tapdu.setIncomingAndReceive();\r\n\t\t// check PIN depending on value of P2\r\n\t\tJCSystem.beginTransaction();\r\n\t\t////@ open valid(); // auto\r\n\t\tswitch (buffer[ISO7816.OFFSET_P2]) {\r\n\t\tcase CARDHOLDER_PIN:\r\n\t\t\t// overwrite previous APDU type\r\n\t\t\tsetPreviousApduType(VERIFY_CARDHOLDER_PIN);\r\n\t\t\t// check the cardholder PIN\r\n\t\t\tcheckPin(cardholderPin, buffer);\r\n\t\t\tbreak;\r\n\t\tcase ACTIVATE_PIN:\r\n\t\t\t// check the activation PIN\r\n\t\t\tcheckPin(activationPin, buffer);\r\n\t\t\t// if the activation PIN was entered correctly\r\n\t\t\tif (GPSystem.getCardContentState() == GPSystem.APPLICATION_SELECTABLE)\r\n\t\t\t\t// set the applet status to personalized\r\n\t\t\t\tGPSystem.setCardContentState(GPSystem.CARD_SECURED);\r\n\t\t\t// reset internal authenticate counter\r\n\t\t\t//internalAuthenticateCounter = 5000;\r\n\t\t\tbreak;\r\n\t\tcase RESET_PIN:\r\n\t\t\t// overwrite previous APDU type\r\n\t\t\tsetPreviousApduType(VERIFY_RESET_PIN);\r\n\t\t\t// check the reset PIN\r\n\t\t\tcheckPin(resetPin, buffer);\r\n\t\t\tbreak;\r\n\t\tcase UNBLOCK_PIN:\r\n\t\t\t// check the unblock PIN: after this, the pin will be 'activated'\r\n\t\t\tcheckPin(unblockPin, buffer);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tISOException.throwIt(SW_REFERENCE_DATA_NOT_FOUND);\r\n\t\t}\r\n\t\t////@ close valid(); // auto\r\n\t\tJCSystem.commitTransaction();\r\n\t}\r\n\t/**\r\n\t * check the PIN\r\n\t */\r\n\tprivate void checkPin(OwnerPIN pin, byte[] buffer) \r\n  \t    //@ requires [1/2]cardholderPin |-\u003e ?theCardholderPin \u0026*\u0026 [1/2]OwnerPIN(pin, _, _) \u0026*\u0026 pin != null \u0026*\u0026 buffer != null \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer.length \u003e= 13;\r\n      \t    //@ ensures [1/2]cardholderPin |-\u003e theCardholderPin \u0026*\u0026 [1/2]OwnerPIN(pin, _, _) \u0026*\u0026 pin != null \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer != null \u0026*\u0026 buffer.length \u003e= 13;\r\n\t{\r\n\t\tif (pin.check(buffer, OFFSET_PIN_HEADER, PIN_SIZE) == true)\r\n\t\t\treturn;\r\n\t\tshort tries = pin.getTriesRemaining();\r\n\t\t// the eID card throws this exception, SW=0x63C0 would make more sense\r\n\t\tif (tries == 0) {\r\n\t\t\t// if the cardholder PIN is no longer valid (too many tries)\r\n\t\t\tif (pin == cardholderPin)\r\n\t\t\t\t// set the applet status to blocked\r\n\t\t\t\tGPSystem.setCardContentState(GPSystem.CARD_LOCKED);\r\n\t\t\tISOException.throwIt(ISO7816.SW_FILE_INVALID);\r\n\t\t}\r\n\t\t/*\r\n\t\t * create the correct exception the status word is of the form 0x63Cx\r\n\t\t * with x the number of tries left\r\n\t\t */\r\n\t\tshort sw = (short) (SW_WRONG_PIN_0_TRIES_LEFT | tries);\r\n\t\tISOException.throwIt(sw);\r\n\t}\r\n\t/**\r\n\t * change the PIN\r\n\t */\r\n\tprivate void changePin(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t/*\r\n\t\t * IMPORTANT: in all other APDUs the previous APDU type gets overwritten\r\n\t\t * in process() function; this is not the case here because the\r\n\t\t * information is needed when processing to verify the security\r\n\t\t * condition for administrator PIN change\r\n\t\t * \r\n\t\t * the previous APDU type has to be overwritten in every possible exit\r\n\t\t * path out of this function\r\n\t\t */\r\n\t\tJCSystem.beginTransaction();\r\n\t\t////@ open valid(); // auto\r\n\t\t// check P2\r\n\t\tif (buffer[ISO7816.OFFSET_P2] != (byte) 0x01) {\r\n\t\t\tsetPreviousApduType(OTHER);\r\n\t\t\tISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n\t\t}\r\n\t\t// P1 determines whether it is user or administrator PIN change\r\n\t\tswitch (buffer[ISO7816.OFFSET_P1]) {\r\n\t\tcase (byte) 0x00:\r\n\t\t\tsetPreviousApduType(OTHER);\r\n\t\t\t////@ close valid(); // auto\r\n\t\t\tJCSystem.commitTransaction();\r\n\t\t\tuserChangePin(apdu, buffer);\r\n\t\t\tbreak;\r\n\t\tcase (byte) 0x01:\r\n\t\t\t// //@ close valid(); // auto\r\n\t\t\tJCSystem.commitTransaction();\r\n\t\t\tadministratorChangePin(apdu, buffer);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tsetPreviousApduType(OTHER);\r\n\t\t\t// //@ close valid(); // auto\r\n\t\t\tJCSystem.commitTransaction();\r\n\t\t\tISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n\t\t\tbreak; //~allow_dead_code\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t/**\r\n\t * user changes the PIN\r\n\t */\r\n\tprivate void userChangePin(APDU apdu, byte[] buffer) \r\n  \t    //@ requires [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer.length \u003e OFFSET_SECOND_PIN_HEADER + PIN_SIZE;\r\n      \t    //@ ensures [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer.length \u003e OFFSET_SECOND_PIN_HEADER + PIN_SIZE;\r\n\t{\r\n\t\t////@ open [1/2]valid(); // auto\r\n\t\t// receive the PIN data\r\n\t\tshort byteRead = apdu.setIncomingAndReceive();\r\n\t\t// check Lc\r\n\t\tshort lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n\t\tif ((lc != 16) || (byteRead != 16))\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n\t\t// first check old cardholder PIN\r\n\t\tcheckPin(cardholderPin, buffer);\r\n\t\t// do some checks on the new PIN header and data\r\n\t\tif (!isNewPinFormattedCorrectly(buffer, OFFSET_SECOND_PIN_HEADER))\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_DATA);\r\n\t\t// include header as well in PIN object\r\n\t\tcardholderPin.update(buffer, OFFSET_SECOND_PIN_HEADER, PIN_SIZE);\r\n\t\t// validate cardholder PIN immediately after change PIN\r\n\t\t// so that cardholder access rights are immediately granted\r\n\t\tcardholderPin.check(buffer, OFFSET_SECOND_PIN_HEADER, PIN_SIZE);\r\n\t\t////@ close [1/2]valid(); // auto\r\n\t}\r\n\t/**\r\n\t * administrator changes the PIN\r\n\t */\r\n\tprivate void administratorChangePin(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t// The previous getChallenge() should ask for at least the length of the\r\n\t\t// new administrator pin. Otherwise exception is thrown\r\n\t\t/*\r\n\t\t * IMPORTANT: the previous APDU type has to be overwritten in every\r\n\t\t * possible exit path out of this function; therefore we check the\r\n\t\t * security conditions as early as possible\r\n\t\t */\r\n\t\tJCSystem.beginTransaction();\r\n\t\t////@ open valid(); // auto\r\n\t\t// previous APDU must have checked the reset PIN\r\n\t\tif ((!resetPin.isValidated()) || (getPreviousApduType() != VERIFY_RESET_PIN)) {\r\n\t\t\tsetPreviousApduType(OTHER);\r\n\t\t\tISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n\t\t}\r\n\t\t// overwrite previous ADPU type as soon as possible\r\n\t\tsetPreviousApduType(OTHER);\r\n\t\t// receive the PIN data\r\n\t\tshort byteRead = apdu.setIncomingAndReceive();\r\n\t\t// check Lc\r\n\t\tshort lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n\t\tif ((lc != 8) || (byteRead != 8))\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n\t\t// do some checks on the new PIN header and data\r\n\t\tif (!isNewPinFormattedCorrectly(buffer, OFFSET_PIN_HEADER))\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_DATA);\r\n\t\t// compare the new PIN with the last generated random challenge\r\n\t\tif (!isNewPinCorrectValue(buffer))\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_DATA);\r\n\t\t// include header as well in PIN object\r\n\t\tcardholderPin.update(buffer, OFFSET_PIN_HEADER, PIN_SIZE);\r\n\t\t////@ close valid(); // auto\r\n\t\tJCSystem.commitTransaction();\r\n\t}\r\n\t/**\r\n\t * check if new PIN conforms to internal format\r\n\t * \r\n\t * returns false if new PIN is not formatted correctly\r\n\t */\r\n\tprivate boolean isNewPinFormattedCorrectly(byte[] buffer, byte offset) \r\n  \t    //@ requires buffer != null \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 offset \u003e= 0 \u0026*\u0026 offset \u003c buffer.length - PIN_SIZE \u0026*\u0026 offset + PIN_SIZE \u003c= Byte.MAX_VALUE;\r\n      \t    //@ ensures array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t// 1st nibble of new PIN header should be 2\r\n\t\tif ((buffer[offset] \u003e\u003e 4) != 2)\r\n\t\t\treturn false;\r\n\t\t// 2nd nibble of new PIN header is the length (in digits)\r\n\t\t//@ and_limits(buffer[offset], 0x0F, nat_of_pos(p1(p1(p1_))));\r\n\t\tbyte pinLength = (byte) (buffer[offset] \u0026 0x0F);\r\n\t\t// the new PIN should be between 4 and 12 digits\r\n\t\tif (pinLength \u003c 4 || pinLength \u003e 12)\r\n\t\t\treturn false;\r\n\t\t// divide PIN length by 2 to get the length in bytes\r\n\t\t//@ shr_limits(pinLength, 1, nat_of_pos(p1(p1(p1_))));\r\n\t\tbyte pinLengthInBytes = (byte) (pinLength \u003e\u003e 1);\r\n\t\t\r\n\t\t// check if PIN length is odd\r\n\t\tif ((pinLength \u0026 (byte) 0x01) == (byte) 0x01)\r\n\t\t\tpinLengthInBytes++;\r\n\t\t// check if PIN data is padded with 0xFF\r\n\t\tbyte i = (byte) (offset + PIN_SIZE - 1);\r\n\t\tfor (; i \u003e offset + pinLengthInBytes; i--) \r\n\t\t\t/*@ invariant array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 i \u003e= offset + pinLengthInBytes\r\n\t\t\t\t\u0026*\u0026 i \u003c= offset + PIN_SIZE - 1;\r\n\t\t\t@*/\r\n\t\t{\r\n\t\t\tif (buffer[i] != (byte) 0xFF)\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t\t// if PIN length is odd, check if last PIN data nibble is F\r\n\t\tif ((pinLength \u0026 (byte) 0x01) == (byte) 0x01) {\r\n\t\t\tif (/*@truncating@*/ (byte) (buffer[i] \u003c\u003c 4) != (byte) 0xF0)\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\t/**\r\n\t * check if new PIN is based on the last generated random challenge\r\n\t */\r\n\tprivate boolean isNewPinCorrectValue(byte[] buffer) \r\n  \t    /*@ requires buffer != null \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer.length \u003e= OFFSET_PIN_DATA + 8\r\n  \t    \t  \u0026*\u0026 randomBuffer |-\u003e ?theRandomBuffer \u0026*\u0026 theRandomBuffer != null \u0026*\u0026 array_slice(theRandomBuffer, 0, theRandomBuffer.length, _) \u0026*\u0026 theRandomBuffer.length == 256;\r\n  \t    @*/\r\n      \t    //@ ensures array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 randomBuffer |-\u003e theRandomBuffer \u0026*\u0026 array_slice(theRandomBuffer, 0, theRandomBuffer.length, _);\r\n\t{\r\n\t\t// 2nd nibble of the PIN header is the length (in digits)\r\n\t\tint tmp = buffer[OFFSET_PIN_HEADER];\r\n\t\tif(tmp \u003c 0) { // BUG\r\n\t\t  return false;\r\n\t\t}\r\n\t\tbyte pinLength = (byte) (buffer[OFFSET_PIN_HEADER] \u0026 0x0F);\r\n\t\t// check if PIN length is odd\r\n\t\tbyte oldLength = (byte) (pinLength \u0026 0x01);\r\n\t\t// divide PIN length by 2 to get the length in bytes\r\n\t\tbyte pinLengthInBytes = (byte) (pinLength \u003e\u003e 1);\r\n\t\t//@ assert 0 \u003c= pinLengthInBytes \u0026\u0026 pinLengthInBytes \u003c 8;\r\n\t\tbyte i;\r\n\t\tfor (i = 0; i \u003c pinLengthInBytes; i++) \r\n\t\t\t/*@ invariant array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 i \u003e= 0 \u0026*\u0026 i \u003c= pinLengthInBytes \r\n\t\t\t       \u0026*\u0026 randomBuffer |-\u003e ?theRandomBuffer2 \u0026*\u0026 theRandomBuffer == theRandomBuffer2 \u0026*\u0026 theRandomBuffer2 != null \u0026*\u0026 array_slice(theRandomBuffer2, 0, theRandomBuffer2.length, _) \u0026*\u0026 theRandomBuffer2.length \u003e= pinLengthInBytes;\r\n\t\t\t@*/\r\n\t\t{\r\n\t\t\tif (buffer[OFFSET_PIN_DATA + i] != (randomBuffer[i] \u0026 0x77))\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t\tif (oldLength == (byte) 0x01) {\r\n\t\t\tif ((buffer[OFFSET_PIN_DATA + pinLengthInBytes] \u003e\u003e 4) != ((randomBuffer[i] \u0026 0x7F) \u003e\u003e 4))\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\t/**\r\n\t * Discard current fulfilled access conditions\r\n\t */\r\n\tprivate void logOff(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t// check P1 and P2\r\n\t\tif (buffer[ISO7816.OFFSET_P1] != (byte) 0x00 || buffer[ISO7816.OFFSET_P2] != (byte) 0x00)\r\n\t\t\tISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n\t\t// remove previous access conditions:\r\n\t\tJCSystem.beginTransaction();\r\n\t\t////@ open valid(); // auto\r\n\t\tsetPreviousApduType(OTHER);\r\n\t\tsetSignatureType(NO_SIGNATURE);\r\n\t\tcardholderPin.reset();\r\n\t\tresetPin.reset();\r\n\t\tunblockPin.reset();\r\n\t\tactivationPin.reset();\r\n\t\t////@ close valid(); // auto\r\n\t\tJCSystem.commitTransaction();\r\n\t}\r\n\t/**\r\n\t * unblock card\r\n\t */\r\n\tprivate void unblock(APDU apdu, byte[] buffer) \r\n  \t    //@ requires [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t// check P1 and P2\r\n\t\tif (buffer[ISO7816.OFFSET_P1] != (byte) 0x00 || buffer[ISO7816.OFFSET_P2] != (byte) 0x01)\r\n\t\t\tISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n\t\t// receive the PUK data for validation\r\n\t\tapdu.setIncomingAndReceive();\r\n\t\t// check PUK\r\n\t\t////@ open valid(); // auto\r\n\t\tcheckPin(unblockPin, buffer);\r\n\t\t// if PUK is correct, then unblock cardholder PINs\r\n\t\tcardholderPin.resetAndUnblock();\r\n\t\t// set the applet status back to personalized\r\n\t\tGPSystem.setCardContentState(GPSystem.CARD_SECURED);\r\n\t\t////@ close [1/2]valid(); // auto\r\n\t}\r\n\t/**\r\n\t * prepare for authentication or non repudiation signature\r\n\t */\r\n\tprivate void prepareForSignature(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t// check P1 and P2\r\n\t\tif (buffer[ISO7816.OFFSET_P1] != (byte) 0x41 || buffer[ISO7816.OFFSET_P2] != (byte) 0xB6)\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n\t\t// receive the data to see which kind of signature\r\n\t\tshort byteRead = apdu.setIncomingAndReceive();\r\n\t\t// check Lc\r\n\t\tshort lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n\t\tif ((lc != 5) || (byteRead != 5))\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n\t\t// the first 2 bytes of the data part should be 0x04 0x80\r\n\t\t// the fourth byte should be 0x84\r\n\t\tif ((buffer[ISO7816.OFFSET_CDATA] != (byte) 0x04) || (buffer[ISO7816.OFFSET_CDATA + 1] != (byte) 0x80) || (buffer[ISO7816.OFFSET_CDATA + 3] != (byte) 0x84))\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_DATA);\r\n\t\t// initialize signature object depending on hash function type\r\n\t\t\r\n\t\tJCSystem.beginTransaction();\r\n\t\t////@ open valid(); // auto\r\n\t\tswitch (buffer[ISO7816.OFFSET_CDATA + 2]) {\r\n\t\tcase ALG_SHA1_PKCS1:\r\n\t\t\tsignatureAlgorithm = ALG_SHA1_PKCS1;\r\n\t\t\tbreak;\r\n\t\tcase ALG_MD5_PKCS1:\r\n\t\t\tsignatureAlgorithm = ALG_MD5_PKCS1;\r\n\t\t\tbreak;\r\n\t\tcase ALG_PKCS1:\r\n\t\t\tsignatureAlgorithm = ALG_PKCS1;\r\n\t\t\tbreak;\r\n\t\tdefault: // algorithm not supported (SW=9484)\r\n\t\t\tISOException.throwIt(SW_ALGORITHM_NOT_SUPPORTED);\r\n\t\t\tbreak; //~allow_dead_code\r\n\t\t}\r\n\t\t// signature type is determined by the the last byte\r\n\t\tswitch (buffer[ISO7816.OFFSET_CDATA + 4]) {\r\n\t\tcase BASIC:\r\n\t\t\tsetSignatureType(BASIC);\r\n\t\t\tbreak;\r\n\t\tcase AUTHENTICATION: // use authentication private key\r\n\t\t\tsetSignatureType(AUTHENTICATION);\r\n\t\t\tbreak;\r\n\t\tcase NON_REPUDIATION: // use non repudiation private key\r\n\t\t\tsetSignatureType(NON_REPUDIATION);\r\n\t\t\tbreak;\r\n\t\tcase CA_ROLE:\r\n\t\t\tsetSignatureType(NO_SIGNATURE);\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_DATA);\r\n\t\t\tbreak; //~allow_dead_code\r\n\t\tdefault:\r\n\t\t\tsetSignatureType(NO_SIGNATURE);\r\n\t\t\tISOException.throwIt(SW_REFERENCE_DATA_NOT_FOUND);\r\n\t\t\tbreak; //~allow_dead_code\r\n\t\t}\r\n\t\t////@ close valid(); // auto\r\n\t\tJCSystem.commitTransaction();\r\n\t}\r\n\t/**\r\n\t * generate (authentication or non repudiation) signature\r\n\t */\r\n\tprivate void generateSignature(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t/*\r\n\t\t * IMPORTANT: in all other APDUs the previous APDU type gets overwritten\r\n\t\t * in process() function; this is not the case here because the\r\n\t\t * information is needed when processing to verify the security\r\n\t\t * condition for non repudiation signature\r\n\t\t * \r\n\t\t * the previous APDU type has to be overwritten in every possible exit\r\n\t\t * path out of this function; therefore we check the security conditions\r\n\t\t * of the non repudiation signature as early as possible, but we have to\r\n\t\t * overwrite the previous APDU type in the 2 possible exceptions before\r\n\t\t */\r\n\t\tJCSystem.beginTransaction();\r\n\t\t////@ open valid(); // auto\r\n\t\t// check P1 and P2\t\t\r\n\t\tif (buffer[ISO7816.OFFSET_P1] != (byte) 0x9E || buffer[ISO7816.OFFSET_P2] != (byte) 0x9A) {\r\n\t\t\tsetPreviousApduType(OTHER);\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n\t\t}\r\n\t\t// generate signature without prepare signature results:\r\n\t\t// \"conditions of use not satisfied\"\r\n\t\tif (getSignatureType() == NO_SIGNATURE) {\r\n\t\t\tsetPreviousApduType(OTHER);\r\n\t\t\tISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);\r\n\t\t}\r\n\t\t/*\r\n\t\t * verify authentication information throw\r\n\t\t * \"security condition not satisfied\" if something is wrong\r\n\t\t */\r\n\t\t// check if previous APDU did a cardholder PIN verification\r\n\t\tif ((getSignatureType() == NON_REPUDIATION) \u0026\u0026 (getPreviousApduType() != VERIFY_CARDHOLDER_PIN)) {\r\n\t\t\tsetPreviousApduType(OTHER);\r\n\t\t\tISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n\t\t}\r\n\t\t// overwrite previous ADPU type as soon as possible\r\n\t\tsetPreviousApduType(OTHER);\r\n\r\n\t\t// it is impossible to generate basic signatures with this command\r\n\t\tif (getSignatureType() == BASIC)\r\n\t\t\tISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n\t\t// check if cardholder PIN was entered correctly\r\n\t\tif (!cardholderPin.isValidated())\r\n\t\t\tISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n\t\t\r\n\t\t////@ close valid(); // auto\r\n\t\tJCSystem.commitTransaction();\r\n\t\t////@ open [1/2]valid(); // auto\r\n\t\tswitch (signatureAlgorithm) {\r\n\t\tcase ALG_MD5_PKCS1:\r\n\t\t\t////@ close [1/2]valid(); // auto\r\n\t\t\tgeneratePkcs1Md5Signature(apdu, buffer);\r\n\t\t\t////@ open [1/2]valid(); // auto\r\n\t\t\tbreak;\r\n\t\tcase ALG_SHA1_PKCS1:\r\n\t\t\t////@ close [1/2]valid(); // auto\r\n\t\t\tgeneratePkcs1Sha1Signature(apdu, buffer);\r\n\t\t\t////@ open [1/2]valid(); // auto\r\n\t\t\tbreak;\r\n\t\tcase ALG_PKCS1:\r\n\t\t\t////@ close [1/2]valid(); // auto\r\n\t\t\tgeneratePkcs1Signature(apdu, buffer);\r\n\t\t\t////@ open [1/2]valid(); // auto\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t////@ close [1/2]valid(); // auto\r\n\t\t// if T=1, store signature in sigBuffer so that it can latter be sent\r\n\t\tif (APDU.getProtocol() == APDU.PROTOCOL_T1) {\r\n\t\t\tJCSystem.beginTransaction();\r\n\t\t\t//@ open valid(); // todo (???)\r\n\t\t\tUtil.arrayCopy(buffer, (short) 0, responseBuffer, (short) 0, (short) 128);\r\n\t\t\t////@ close valid(); // auto\r\n\t\t\tJCSystem.commitTransaction();\r\n\t\t\t\r\n\t\t\t// in case T=0 protocol, send the signature immediately in a\r\n\t\t\t// response APDU\r\n\t\t} else {\r\n\t\t\t// send first 128 bytes (= 1024 bit) of buffer\r\n\t\t\tapdu.setOutgoingAndSend((short) 0, (short) 128);\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t * generate PKCS#1 MD5 signature\r\n\t */\r\n\tprivate void generatePkcs1Md5Signature(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t// receive the data that needs to be signed\r\n\t\tshort byteRead = apdu.setIncomingAndReceive();\r\n\t\t// check Lc\r\n\t\tshort lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n\t\tif ((lc != 16) || (byteRead != 16))\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n\t\t// use the correct key\r\n\t\t////@ open [1/2]valid(); // auto\r\n\t\t\r\n\t\tif (getSignatureType() == NON_REPUDIATION) {\t\t\r\n\t\t\tcipher.init((RSAPrivateCrtKey)nonRepKeyPair.getPrivate(), Cipher.MODE_ENCRYPT);\r\n\t\t}\r\n\t\tif (getSignatureType() == AUTHENTICATION) {\r\n\t\t\tcipher.init((RSAPrivateCrtKey)authKeyPair.getPrivate(), Cipher.MODE_ENCRYPT);\r\n\t\t}\r\n\t\t////@ close [1/2]valid(); // auto\r\n\t\tJCSystem.beginTransaction();\r\n\t\t\r\n\t\t////@ open valid(); // todo\r\n\t\t\r\n\t\t//@ transient_byte_arrays_mem(messageBuffer);\r\n\t\t//@ assert transient_byte_arrays(?as);\r\n\t\t//@ foreachp_remove(messageBuffer, as);\r\n\t\t////@ open transient_byte_array(messageBuffer); // auto\r\n\t\t\r\n\t\t// prepare the message buffer to the PKCS#1 (v1.5) structure\r\n\t\t////@ open [1/2]valid();\r\n\t\tpreparePkcs1ClearText(messageBuffer, ALG_MD5_PKCS1, lc);\r\n\t\t// copy the MD5 hash from the APDU to the message buffer\r\n\t\tUtil.arrayCopy(buffer, (short) (ISO7816.OFFSET_CDATA), messageBuffer, (short) (128 - lc), lc);\r\n\r\n\t\t//@ close transient_byte_array(messageBuffer);\r\n\t\t//@ foreachp_unremove(messageBuffer, as);\r\n\r\n\t\t////@ close valid(); // auto\r\n\t\tJCSystem.commitTransaction();\r\n\t\t////@ open [1/2]valid(); // auto\r\n\t\t// generate signature\r\n\t\t//@ transient_byte_arrays_mem(messageBuffer);\r\n\t\t//@ assert transient_byte_arrays(?as1);\r\n\t\t//@ foreachp_remove(messageBuffer, as1);\r\n\t\t//@ open transient_byte_array(messageBuffer);\r\n\t\tcipher.doFinal(messageBuffer, (short) 0, (short) 128, buffer, (short) 0);\r\n\t\t//@ close transient_byte_array(messageBuffer);\r\n\t\t//@ foreachp_unremove(messageBuffer, as1);\r\n\r\n\t\t////@ close [1/2]valid(); // auto\r\n\r\n\r\n\t}\r\n\t/**\r\n\t * generate PKCS#1 SHA1 signature\r\n\t */\r\n\tprivate void generatePkcs1Sha1Signature(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t// receive the data that needs to be signed\r\n\t\tshort byteRead = apdu.setIncomingAndReceive();\r\n\t\t// check Lc\r\n\t\t\r\n\t\t\r\n\t\tshort lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n\t\tif ((lc != 20) || (byteRead != 20))\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n\t\t\r\n\t\t\r\n\t\t////@ open [1/2]valid(); // auto\r\n\t\t// use the correct key\r\n\t\tif (getSignatureType() == NON_REPUDIATION) {\r\n\t\t\t////cipher.init(nonRepPrivateKey, Cipher.MODE_ENCRYPT); // stond al in comments\r\n\t\t\tcipher.init((RSAPrivateCrtKey)nonRepKeyPair.getPrivate(), Cipher.MODE_ENCRYPT);\r\n\t\t}\r\n\t\t\r\n\t\tif (getSignatureType() == AUTHENTICATION) {\r\n\t\t\tcipher.init((RSAPrivateCrtKey)authKeyPair.getPrivate(), Cipher.MODE_ENCRYPT);\r\n\t\t}\r\n\t\t\r\n\t\t////@ close [1/2]valid(); // auto\r\n\t\tJCSystem.beginTransaction();\r\n\t\t////@ open valid(); // auto\r\n\t\t\r\n\t\t//@ transient_byte_arrays_mem(messageBuffer);\r\n\t\t//@ assert transient_byte_arrays(?as);\r\n\t\t//@ foreachp_remove(messageBuffer, as);\r\n\t\t////@ open transient_byte_array(messageBuffer); // auto\r\n\r\n\t\t// prepare the message buffer to the PKCS#1 (v1.5) structure\r\n\t\tpreparePkcs1ClearText(messageBuffer, ALG_SHA1_PKCS1, lc);\r\n\t\t// copy the SHA1 hash from the APDU to the message buffer\r\n\t\tUtil.arrayCopy(buffer, (short) (ISO7816.OFFSET_CDATA), messageBuffer, (short) (128 - lc), lc);\r\n\r\n\t\t//@ close transient_byte_array(messageBuffer);\r\n\t\t//@ foreachp_unremove(messageBuffer, as);\r\n\r\n\t\t////@ close valid(); // auto\r\n\t\tJCSystem.commitTransaction();\r\n\t\t////@ open [1/2]valid(); // auto\r\n\t\t// generate signature\r\n\t\t//@ transient_byte_arrays_mem(messageBuffer);\r\n\t\t//@ assert transient_byte_arrays(?as1);\r\n\t\t//@ foreachp_remove(messageBuffer, as1);\r\n\t\t////@ open transient_byte_array(messageBuffer); // auto\r\n\t\tcipher.doFinal(messageBuffer, (short) 0, (short) 128, buffer, (short) 0);\r\n\t\t//@ close transient_byte_array(messageBuffer); // todo\r\n\t\t//@ foreachp_unremove(messageBuffer, as1);\r\n\t\t////@ close [1/2]valid(); // auto\r\n\t}\r\n\t/**\r\n\t * generate PKCS#1 signature\r\n\t */\r\n\tprivate void generatePkcs1Signature(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t// receive the data that needs to be signed\r\n\t\tshort byteRead = apdu.setIncomingAndReceive();\r\n\t\t// check Lc\r\n\t\t//@ positive_and(buffer[ISO7816.OFFSET_LC], 0x00FF);\r\n\t\tshort lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n\t\tif ((lc \u003e 117) || (byteRead \u003e 117))\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n\t\t// use the correct key\r\n\t\t////@ open [1/2]valid(); // auto\r\n\t\tif (getSignatureType() == NON_REPUDIATION) {\r\n\t\t\tcipher.init((RSAPrivateCrtKey)nonRepKeyPair.getPrivate(), Cipher.MODE_ENCRYPT);\r\n\t\t}\r\n\t\tif (getSignatureType() == AUTHENTICATION) {\r\n\t\t\tcipher.init((RSAPrivateCrtKey)authKeyPair.getPrivate(), Cipher.MODE_ENCRYPT);\r\n\t\t}\r\n\t\t////@ close [1/2]valid(); // auto\r\n\t\tJCSystem.beginTransaction();\r\n\t\t////@ open valid(); // auto\r\n\r\n\t\t//@ transient_byte_arrays_mem(messageBuffer);\r\n\t\t//@ assert transient_byte_arrays(?as);\r\n\t\t//@ foreachp_remove(messageBuffer, as);\r\n\t\t//@ open transient_byte_array(messageBuffer);\r\n\r\n\t\t// prepare the message buffer to the PKCS#1 (v1.5) structure\r\n\t\tpreparePkcs1ClearText(messageBuffer, ALG_PKCS1, lc);\r\n\t\t// copy the clear text from the APDU to the message buffer\r\n\t\tUtil.arrayCopy(buffer, (short) (ISO7816.OFFSET_CDATA), messageBuffer, (short) (128 - lc), lc);\r\n\t\t//@ close transient_byte_array(messageBuffer);\r\n\t\t//@ foreachp_unremove(messageBuffer, as);\r\n\r\n\t\t////@ close valid(); // auto\r\n\t\tJCSystem.commitTransaction();\r\n\t\t////@ open [1/2]valid(); // auto\r\n\t\t//@ transient_byte_arrays_mem(messageBuffer);\r\n\t\t//@ assert transient_byte_arrays(?as1);\r\n\t\t//@ foreachp_remove(messageBuffer, as1);\r\n\t\t////@ open transient_byte_array(messageBuffer); // auto\r\n\t\t// generate signature\r\n\t\tcipher.doFinal(messageBuffer, (short) 0, (short) 128, buffer, (short) 0);\r\n\t\t//@ close transient_byte_array(messageBuffer);\r\n\t\t//@ foreachp_unremove(messageBuffer, as1);\r\n\t\t////@ close [1/2]valid(); // auto\r\n\t}\r\n\t/**\r\n\t * prepare the clear text buffer with correct PKCS#1 encoding\r\n\t */\r\n\tprivate void preparePkcs1ClearText(byte[] clearText, short type, short messageLength) \r\n  \t    /*@ requires clearText != null \u0026*\u0026 array_slice(clearText, 0, clearText.length, _) \u0026*\u0026 clearText.length \u003e= 128\r\n\t  \t    \u0026*\u0026 PKCS1_HEADER |-\u003e ?thePKCS1HEADER \u0026*\u0026 PKCS1_SHA1_HEADER |-\u003e ?thePKCS1SHA1HEADER \u0026*\u0026 PKCS1_MD5_HEADER |-\u003e ?thePKCS1MD5HEADER\r\n\t  \t    \u0026*\u0026 thePKCS1HEADER != null \u0026*\u0026 thePKCS1SHA1HEADER != null \u0026*\u0026 thePKCS1MD5HEADER != null\r\n\t  \t    \u0026*\u0026 thePKCS1HEADER.length == 1 \u0026*\u0026 thePKCS1SHA1HEADER.length == 16 \u0026*\u0026 thePKCS1MD5HEADER.length == 19\r\n\t  \t    \u0026*\u0026 array_slice(thePKCS1HEADER, 0, thePKCS1HEADER.length, _)\r\n\t  \t    \u0026*\u0026 array_slice(thePKCS1SHA1HEADER, 0, thePKCS1SHA1HEADER.length, _)\r\n\t  \t    \u0026*\u0026 array_slice(thePKCS1MD5HEADER, 0, thePKCS1MD5HEADER.length, _)\r\n\t  \t    \u0026*\u0026 messageBuffer |-\u003e ?theMessageBuffer \u0026*\u0026 theMessageBuffer != null \r\n\t  \t    \u0026*\u0026 messageLength \u003e= 0\r\n\t  \t    \u0026*\u0026 type == ALG_SHA1_PKCS1 ? messageLength == 20 || messageLength == 22 : type == ALG_MD5_PKCS1 ? messageLength == 16 : messageLength \u003c 126; @*/\r\n      \t    /*@ ensures array_slice(clearText, 0, clearText.length, _) \u0026*\u0026 PKCS1_HEADER |-\u003e thePKCS1HEADER \r\n      \t    \t    \u0026*\u0026 PKCS1_SHA1_HEADER |-\u003e thePKCS1SHA1HEADER \u0026*\u0026 PKCS1_MD5_HEADER |-\u003e thePKCS1MD5HEADER\r\n\t  \t    \u0026*\u0026 array_slice(thePKCS1HEADER, 0, thePKCS1HEADER.length, _)\r\n\t  \t    \u0026*\u0026 array_slice(thePKCS1SHA1HEADER, 0, thePKCS1SHA1HEADER.length, _)\r\n\t  \t    \u0026*\u0026 array_slice(thePKCS1MD5HEADER, 0, thePKCS1MD5HEADER.length, _)\r\n      \t    \t    \u0026*\u0026 messageBuffer |-\u003e theMessageBuffer ; @*/\r\n\t{\r\n\t\t// first pad the whole clear text with 0xFF\r\n\t\tUtil.arrayFillNonAtomic(clearText, (short) 0, (short) 128, (byte) 0xff);\r\n\t\t// first 2 bytes should be 0x00 and 0x01\r\n\t\tUtil.arrayFillNonAtomic(clearText, (short) 0, (short) 1, (byte) 0x00);\r\n\t\tUtil.arrayFillNonAtomic(clearText, (short) 1, (short) 1, (byte) 0x01);\r\n\t\t// add the PKCS#1 header at the correct location\r\n\t\tbyte[] header = PKCS1_HEADER;\r\n\t\tif (type == ALG_SHA1_PKCS1)\r\n\t\t\theader = PKCS1_SHA1_HEADER;\r\n\t\tif (type == ALG_MD5_PKCS1)\r\n\t\t\theader = PKCS1_MD5_HEADER;\r\n\t\tUtil.arrayCopy(header, (short) 0, clearText, (short) (128 - messageLength - header.length), (short) header.length);\r\n\t}\r\n\t/**\r\n\t * generate a key pair\r\n\t * \r\n\t * only the private key will be stored in the eid. the get public key method\r\n\t * should be called directly after this method, otherwise the public key\r\n\t * will be discarded security conditions depend on the key to generate the\r\n\t * role R03 (see belgian eid card content) shall be verified for changing\r\n\t * authentication or non repudiation keys.\r\n\t */\r\n\tprivate void generateKeyPair(APDU apdu) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, ?theBuffer) \u0026*\u0026 array_slice(theBuffer, 0, theBuffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, theBuffer) \u0026*\u0026 array_slice(theBuffer, 0, theBuffer.length, _);\r\n\t{\r\n\t\tapdu.setIncomingAndReceive();// If this was removed, function will not\r\n\t\t// work: no data except for command will be read\r\n\t\tbyte[] buffer = apdu.getBuffer();\r\n\t\t// check if access to this method is allowed\r\n\t\tif (GPSystem.getCardContentState() != GPSystem.APPLICATION_SELECTABLE)\r\n\t\t\tISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n\t\t// check P1 and P2\r\n\t\tif (buffer[ISO7816.OFFSET_P1] != (byte) 0x00)\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n\t\t// check Lc\r\n\t\tshort lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n\t\tif (lc != (short) 11)\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n\t\tbyte offset = (ISO7816.OFFSET_CDATA + 0x01);\r\n\t\t//byte offset = (byte)(ISO7816.OFFSET_CDATA + 0x01);\r\n\t\t// create keypair using parameters given:\r\n\t\t// short keyLength = Util.makeShort(buffer[ISO7816.OFFSET_CDATA],\r\n\t\t// buffer[offset]);\r\n\t\tif (buffer[offset] != (byte) 0x80)\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t// This is commented out as changing exponent makes getting modulus\r\n\t\t// impossible on some java cards\r\n\t\t// ((RSAPublicKey)tempkp.getPublic()).setExponent(buffer, (short)(13),\r\n\t\t// (short)3);\r\n\t\tJCSystem.beginTransaction();\r\n\t\t////@ open valid(); // auto\r\n\t\tsetPreviousApduType(GENERATE_KEY_PAIR);\r\n\t\tswitch (buffer[ISO7816.OFFSET_P2]) {\r\n\t\tcase BASIC:\r\n\t\t\tbasicKeyPair = new KeyPair(KeyPair.ALG_RSA_CRT, (short) (1024));\r\n\t\t\tbasicKeyPair.genKeyPair();\r\n\t\t\t\r\n\t\t\tbreak;\r\n\t\tcase AUTHENTICATION: // use authentication private key\r\n\t\t\tauthKeyPair = new KeyPair(KeyPair.ALG_RSA_CRT, (short) (1024));\r\n\t\t\tauthKeyPair.genKeyPair();\r\n\t\t\t\r\n\t\t\tbreak;\r\n\t\tcase NON_REPUDIATION: // use non repudiation private key\r\n\t\t\tnonRepKeyPair = new KeyPair(KeyPair.ALG_RSA_CRT, (short) (1024));\r\n\t\t\tnonRepKeyPair.genKeyPair();\r\n\t\t\t\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t\r\n\t\t\tISOException.throwIt(SW_REFERENCE_DATA_NOT_FOUND);\r\n\t\t\tbreak; //~allow_dead_code\r\n\t\t}\r\n\t\t////@ close valid(); // auto\r\n\t\tJCSystem.commitTransaction();\r\n\t}\r\n\t/**\r\n\t * get a public key. for the authentication and non-repudiation key, this\r\n\t * method can only be called after the generateKeyPair method was called\r\n\t * \r\n\t */\r\n\tprivate void getPublicKey(APDU apdu) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, ?theBuffer) \u0026*\u0026 array_slice(theBuffer, 0, theBuffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, theBuffer) \u0026*\u0026 array_slice(theBuffer, 0, theBuffer.length, _);\r\n\t{\r\n\t\t\r\n\t\t\r\n\t\tbyte[] buffer = apdu.getBuffer();\r\n\t\t// if this is thrown: problem accesses getPreviousapdu\r\n\t\t// check P1\r\n\t\tif (buffer[ISO7816.OFFSET_P1] != (byte) 0x00)\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n\t\t// inform the JCRE that the applet has data to return\r\n\t\tshort le = apdu.setOutgoing();\r\n\t\t// Le = 0 is not allowed\r\n\t\tif (le != (short) (5 + 8 + 128))\r\n\t\t\tISOException.throwIt((short) (SW_WRONG_LENGTH_00 + (5 + 8 + 128)));\r\n\t\tbyte[] tempBuffer = new byte[le];\r\n\t\ttempBuffer[(short) 0] = (byte) 0x02;\r\n\t\ttempBuffer[(short) 1] = (byte) 0x08;\r\n\t\ttempBuffer[(short) 10] = (byte) 0x03;\r\n\t\ttempBuffer[(short) 11] = (byte) 0x81;\r\n\t\ttempBuffer[(short) 12] = (byte) 0x80;\r\n\t\t////@ open [1/2]valid(); // auto\r\n\t\tif (buffer[ISO7816.OFFSET_P2] == AUTHENTICATION){\r\n\t\t\tif (getPreviousApduType() != GENERATE_KEY_PAIR) {\r\n\t\t\t\tauthKeyPair.getPublic().clearKey();\r\n\t\t\t        ////@ close [1/2]valid(); // auto\r\n\t\t\t\tJCSystem.beginTransaction();\r\n\t\t\t        ////@ open valid(); // auto\r\n\t\t\t\tsetPreviousApduType(OTHER);\r\n\t\t\t        ////@ close valid(); // auto\r\n\t\t\t\tJCSystem.commitTransaction();\r\n\t\t\t        ////@ open [1/2]valid(); // auto\r\n\t\t\t\tISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);\r\n\t\t\t}\r\n\t\t\t((RSAPublicKey) authKeyPair.getPublic()).getExponent(tempBuffer, (short) 7);\r\n\t\t\t((RSAPublicKey) authKeyPair.getPublic()).getModulus(tempBuffer, (short) 13);\r\n\t\t}else if (buffer[ISO7816.OFFSET_P2] == NON_REPUDIATION) { \r\n\t\t\tif (getPreviousApduType() != GENERATE_KEY_PAIR) {\r\n\t\t\t\tnonRepKeyPair.getPublic().clearKey();\r\n\t\t\t        ////@ close [1/2]valid(); // auto\r\n\t\t\t\tJCSystem.beginTransaction();\r\n\t\t\t        ////@ open valid(); // auto\r\n\t\t\t\tsetPreviousApduType(OTHER);\r\n\t\t\t\t////@ close valid(); // auto\r\n\t\t\t\tJCSystem.commitTransaction();\r\n\t\t\t\t////@ open [1/2]valid(); // auto\r\n\t\t\t\tISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);\r\n\t\t\t}\t\t\t\r\n\t\t\t((RSAPublicKey) nonRepKeyPair.getPublic()).getExponent(tempBuffer, (short) 7);\r\n\t\t\t((RSAPublicKey) nonRepKeyPair.getPublic()).getModulus(tempBuffer, (short) 13);\r\n\t\t}else if (buffer[ISO7816.OFFSET_P2] == BASIC) {\t\t\r\n\t\t\tif (basicKeyPair == null)\r\n\t\t\t\tISOException.throwIt(SW_REFERENCE_DATA_NOT_FOUND);\r\n\t\t\t((RSAPublicKey) basicKeyPair.getPublic()).getExponent(tempBuffer, (short) 7);\r\n\t\t\t((RSAPublicKey) basicKeyPair.getPublic()).getModulus(tempBuffer, (short) 13);\r\n\t\t} else {\r\n\t\t\tISOException.throwIt(SW_REFERENCE_DATA_NOT_FOUND);\r\n\t\t}\r\n\t        ////@ close [1/2]valid(); // auto\r\n\t\tJCSystem.beginTransaction();\r\n\t        ////@ open valid(); // auto\r\n\t\tsetPreviousApduType(OTHER);\r\n\t\t////@ close valid(); // auto\r\n\t\tJCSystem.commitTransaction();\r\n\t\t////@ open [1/2]valid(); // auto\r\n\t\tauthKeyPair.getPublic().clearKey();\r\n\t\tnonRepKeyPair.getPublic().clearKey();\r\n\t\t// set the actual number of outgoing data bytes\r\n\t\tapdu.setOutgoingLength(le);\r\n\t\t// send content of buffer in apdu\r\n\t\tapdu.sendBytesLong(tempBuffer, (short) 0, le);\r\n\t\t////@ close [1/2]valid(); // auto\r\n\t}\r\n\t/**\r\n\t * put a public key as commune or role key this is not supported anymore\r\n\t */\r\n\tprivate void putPublicKey(APDU apdu, byte[] buffer) \r\n  \t    //@ requires [1/2]valid();\r\n      \t    //@ ensures [1/2]valid();\r\n\t{\r\n\t\tISOException.throwIt(SW_REFERENCE_DATA_NOT_FOUND);\r\n\t}\r\n\t/**\r\n\t * erase a public key (basic, commune or role key) only basic supported\r\n\t */\r\n\tprivate void eraseKey(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t// check P1\r\n\t\tif (buffer[ISO7816.OFFSET_P1] != (byte) 0x00)\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n\t\tswitch (buffer[ISO7816.OFFSET_P2]) {\r\n\t\tcase BASIC:\r\n\t\t\tJCSystem.beginTransaction();\r\n\t\t\t//@ open valid();\r\n\t\t\tbasicKeyPair = null;\r\n\t\t\t////@ close valid(); // auto\r\n\t\t\tJCSystem.commitTransaction();\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tISOException.throwIt(SW_REFERENCE_DATA_NOT_FOUND);\r\n\t\t\tbreak; //~allow_dead_code\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t * activate a public authentication or non repudiation key if deactivated\r\n\t * keys in this applet are always active\r\n\t */\r\n\tprivate void activateKey(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t// check P1\r\n\t\tif (buffer[ISO7816.OFFSET_P1] != (byte) 0x00)\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n\t\tswitch (buffer[ISO7816.OFFSET_P2]) {\r\n\t\tcase AUTHENTICATION:\r\n\t\t\t// activate key: key always active, do nothing\r\n\t\t\tbreak;\r\n\t\tcase NON_REPUDIATION:\r\n\t\t\t// activate key: key always active, do nothing\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tISOException.throwIt(SW_REFERENCE_DATA_NOT_FOUND);\r\n\t\t\tbreak; //~allow_dead_code\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t * deactivate a public authentication or non repudiation key if activated as\r\n\t * keys are always active, throw exception\r\n\t */\r\n\tprivate void deactivateKey(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\tISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);\r\n\t}\r\n\t/**\r\n\t * internal authenticate generates a signature with the basic private key no\r\n\t * security conditions needed if used for internal authentication only\r\n\t * (Mutual authentication not supported)\r\n\t */\r\n\tprivate void internalAuthenticate(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t// check P1 and P2\r\n\t\tif ((buffer[ISO7816.OFFSET_P1] != ALG_SHA1_PKCS1) || buffer[ISO7816.OFFSET_P2] != BASIC)\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n\t\t// receive the data that needs to be signed\r\n\t\tshort byteRead = apdu.setIncomingAndReceive();\r\n\t\t// check Lc\r\n\t\tshort lc = (short) (buffer[ISO7816.OFFSET_LC] \u0026 0x00FF);\r\n\t\t// we do not support Lc=0x97, only Lc=0x16\r\n\t\tif ((lc == 0x97) || (byteRead == 0x97))\r\n\t\t\tISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n\t\tif ((lc != 0x16) || (byteRead != 0x16))\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n\t\t// the first data byte must be \"94\" and the second byte is the length\r\n\t\t// (20 bytes)\r\n\t\tif ((buffer[ISO7816.OFFSET_CDATA] != (byte) 0x94) || (buffer[ISO7816.OFFSET_CDATA + 1] != (byte) 0x14))\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_DATA);\r\n\t\t// use the basic private key\r\n\t\tJCSystem.beginTransaction();\r\n\t\t////@ open valid(); // auto\r\n\t\t\r\n\t\t//@ transient_byte_arrays_mem(messageBuffer);\r\n\t\t//@ assert transient_byte_arrays(?as);\r\n\t\t//@ foreachp_remove(messageBuffer, as);\r\n\t\t//@ open transient_byte_array(messageBuffer);\r\n\r\n\t\tif (basicKeyPair == null)\r\n\t\t\tISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);\r\n\r\n\t\t//VF: bovenstaande is mogelijk bug in programma!\r\n\t\tcipher.init(basicKeyPair.getPrivate(), Cipher.MODE_ENCRYPT);\r\n\t\t// prepare the message buffer to the PKCS#1 (v1.5) structure\r\n\t\tpreparePkcs1ClearText(messageBuffer, ALG_SHA1_PKCS1, lc);\r\n\t\t// copy the challenge (SHA1 hash) from the APDU to the message buffer\r\n\t\tUtil.arrayCopy(buffer, (short) (ISO7816.OFFSET_CDATA + 2), messageBuffer, (short) 108, (short) 20);\r\n\t\t// generate signature\r\n\t\tcipher.doFinal(messageBuffer, (short) 0, (short) 128, buffer, (short) 0);\r\n\t\t// if T=0, store signature in sigBuffer so that it can latter be sent\r\n\t\tif (APDU.getProtocol() == APDU.PROTOCOL_T1) {\r\n\t\t\tUtil.arrayCopy(buffer, (short) 0, responseBuffer, (short) 0, (short) 128);\r\n\t\t\t// in case T=1 protocol, send the signature immediately in a\r\n\t\t\t// response APDU\r\n\t\t} else {\r\n\t\t\t// send first 128 bytes (= 1024 bit) of buffer\r\n\t\t\tapdu.setOutgoingAndSend((short) 0, (short) 128);\r\n\t\t}\r\n\t\t// decrement internal authenticate counter\r\n\t\t//internalAuthenticateCounter--;\r\n\t\t//@ close transient_byte_array(messageBuffer);\r\n\t\t//@ foreachp_unremove(messageBuffer, as);\r\n\t\t\r\n\t\t////@ close valid(); // auto\r\n\t\tJCSystem.commitTransaction();\r\n\t}\r\n\t/**\r\n\t * return the generated signature in a response APDU Used in T=0 protocol\r\n\t */\r\n\tprivate void getResponse(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t////@ open [1/2]valid(); // auto\r\n\t\t// use P1 and P2 as offset\r\n\t\tshort offset = Util.makeShort(buffer[ISO7816.OFFSET_P1], buffer[ISO7816.OFFSET_P2]);\r\n\t\tif (offset \u003e responseBuffer.length)\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n\t\t// inform the JCRE that the applet has data to return\r\n\t\tshort le = apdu.setOutgoing();\r\n\t\t// if Le = 0, then return the complete signature (128 bytes = 1024 bits)\r\n\t\t// Le = 256 possible on real card\r\n\t\tif ((le == 0) || (le == 256))\r\n\t\t\tle = 128;\r\n\t\t// set the actual number of outgoing data bytes\r\n\t\tapdu.setOutgoingLength(le);\r\n\t\t// send content of sigBuffer in apdu\r\n\t\tif (offset + le \u003e 128 || offset \u003c 0)\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n\t\tapdu.sendBytesLong(responseBuffer, offset, le);\r\n\t\t////@ close [1/2]valid(); // auto\r\n\t}\r\n\t/**\r\n\t * generate a random challenge\r\n\t */\r\n\tprivate void getChallenge(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t// check P1 and P2\r\n\t\tif (buffer[ISO7816.OFFSET_P1] != (byte) 0x00 || buffer[ISO7816.OFFSET_P2] != (byte) 0x00)\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n\t\t// inform the JCRE that the applet has data to return\r\n\t\tshort le = apdu.setOutgoing();\r\n\t\t// Le = 0 is not allowed\r\n\t\tif (le == 0)\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_LENGTH);\r\n\t\tJCSystem.beginTransaction();\r\n\t\t////@ open valid(); // auto\r\n\t\tRandomData random = EidCard.randomData;\r\n\t\t// generate random data and put it into buffer\r\n\t\trandom.generateData(randomBuffer, (short) 0, le);\r\n\t\t// set the actual number of outgoing data bytes\r\n\t\tapdu.setOutgoingLength(le);\r\n\t\t// send content of buffer in apdu\r\n\t\tapdu.sendBytesLong(randomBuffer, (short) 0, le);\r\n\t\t////@ close valid(); // auto\r\n\t\tJCSystem.commitTransaction();\r\n\t}\r\n\t/**\r\n\t * select a file on the eID card\r\n\t * \r\n\t * this file can latter be read by a READ BINARY\r\n\t */\r\n\tprivate void selectFile(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t// check P2\r\n\t\tif (buffer[ISO7816.OFFSET_P2] != (byte) 0x0C)\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n\t\t// P1 determines the select method\r\n\t\tswitch (buffer[ISO7816.OFFSET_P1]) {\r\n\t\tcase (byte) 0x02:\r\n\t\t\tselectByFileIdentifier(apdu, buffer);\r\n\t\t\tbreak;\r\n\t\tcase (byte) 0x08:\r\n\t\t\tselectByPath(apdu, buffer);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n\t\t\tbreak; //~allow_dead_code\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t * set the previous APDU type to a certain value\r\n\t */\r\n\tprivate void setPreviousApduType(byte type) \r\n  \t    //@ requires previousApduType |-\u003e ?thePreviousApduType \u0026*\u0026 thePreviousApduType != null \u0026*\u0026 thePreviousApduType.length == 1 \u0026*\u0026 is_transient_byte_array(thePreviousApduType) == true \u0026*\u0026 transient_byte_arrays(?ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r\n      \t    //@ ensures previousApduType |-\u003e thePreviousApduType \u0026*\u0026 thePreviousApduType != null \u0026*\u0026 transient_byte_arrays(ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r\n\t{\r\n\t\t//@ transient_byte_arrays_mem(thePreviousApduType);\r\n\t\t//@ foreachp_remove(thePreviousApduType, ta);\r\n\t\t//@ open transient_byte_array(thePreviousApduType);\r\n\t\tpreviousApduType[0] = type;\r\n\t\t//@ close transient_byte_array(thePreviousApduType); // todo\r\n\t\t//@ foreachp_unremove(thePreviousApduType, ta);\r\n\t}\r\n\t/**\r\n\t * return the previous APDU type\r\n\t */\r\n\tprivate byte getPreviousApduType() \r\n  \t    //@ requires [?f]previousApduType |-\u003e ?thePreviousApduType \u0026*\u0026 thePreviousApduType != null \u0026*\u0026 thePreviousApduType.length == 1 \u0026*\u0026 is_transient_byte_array(thePreviousApduType) == true \u0026*\u0026 transient_byte_arrays(?ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r\n  \t    //@ ensures [f]previousApduType |-\u003e thePreviousApduType \u0026*\u0026 transient_byte_arrays(ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r\n\t{\r\n\t\t//@ transient_byte_arrays_mem(thePreviousApduType);\r\n\t\t//@ foreachp_remove(thePreviousApduType, ta);\r\n\t\t//@ open transient_byte_array(thePreviousApduType);\r\n\t\treturn previousApduType[0];\r\n\t\t//@ close transient_byte_array(thePreviousApduType);\r\n\t\t//@ foreachp_unremove(thePreviousApduType, ta);\r\n\t}\r\n\t/**\r\n\t * set the signature type to a certain value\r\n\t */\r\n\tprivate void setSignatureType(byte type) \r\n  \t    //@ requires signatureType |-\u003e ?theSignatureType \u0026*\u0026 theSignatureType != null \u0026*\u0026 theSignatureType.length == 1 \u0026*\u0026 is_transient_byte_array(theSignatureType) == true \u0026*\u0026 transient_byte_arrays(?ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r\n      \t    //@ ensures signatureType |-\u003e theSignatureType \u0026*\u0026 is_transient_byte_array(theSignatureType) == true \u0026*\u0026 transient_byte_arrays(ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r\n\t{\r\n\t\t//@ transient_byte_arrays_mem(theSignatureType);\r\n\t\t//@ foreachp_remove(theSignatureType, ta);\r\n\t\t//@ open transient_byte_array(theSignatureType);\r\n\t\tsignatureType[0] = type;\r\n\t\t//@ close transient_byte_array(theSignatureType);\r\n\t\t//@ foreachp_unremove(theSignatureType, ta);\r\n\t}\r\n\t/**\r\n\t * return the signature type\r\n\t */\r\n\tprivate byte getSignatureType() \r\n  \t    //@ requires [?f]signatureType |-\u003e ?theSignatureType \u0026*\u0026 theSignatureType != null \u0026*\u0026 theSignatureType.length == 1 \u0026*\u0026 is_transient_byte_array(theSignatureType) == true \u0026*\u0026 transient_byte_arrays(?ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r\n      \t    //@ ensures [f]signatureType |-\u003e theSignatureType \u0026*\u0026 transient_byte_arrays(ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r\n\t{\r\n\t\t//@ transient_byte_arrays_mem(theSignatureType);\r\n\t\t//@ foreachp_remove(theSignatureType, ta);\r\n\t\t//@ open transient_byte_array(theSignatureType);\r\n\t\treturn signatureType[0];\r\n\t\t//@ close transient_byte_array(theSignatureType);\r\n\t\t//@ foreachp_unremove(theSignatureType, ta);\r\n\t}\r\n\t\r\n\r\n\t/**\r\n\t * deactivate a file on the eID card security conditions depend on file to\r\n\t * activate: see belgian eID content file\r\n\t */\r\n\tprivate void deactivateFile(APDU apdu, byte[] buffer) \r\n  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r\n\t{\r\n\t\t// check P2\r\n\t\tif (buffer[ISO7816.OFFSET_P2] != (byte) 0x0C)\r\n\t\t\tISOException.throwIt(ISO7816.SW_WRONG_P1P2);\r\n\t\t// P1 determines the select method\r\n\t\tswitch (buffer[ISO7816.OFFSET_P1]) {\r\n\t\tcase (byte) 0x02:\r\n\t\t\tselectByFileIdentifier(apdu, buffer);\r\n\t\t\tbreak;\r\n\t\tcase (byte) 0x08:\r\n\t\t\tselectByPath(apdu, buffer);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);\r\n\t\t\tbreak; //~allow_dead_code\r\n\t\t}\r\n\t\t// check if deactivating this file is allowed\r\n\t\tif (!fileAccessAllowed(UPDATE_BINARY))\r\n\t\t\tISOException.throwIt(ISO7816.SW_SECURITY_STATUS_NOT_SATISFIED);\r\n\t\tJCSystem.beginTransaction();\r\n\t\t//@ open valid(); // todo\r\n\t  \t//@ open selected_file_types(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, ?sf2);\r\n\t\t//@ sf2.castElementaryToFile();\r\n\t\tselectedFile.setActive(false);\r\n\t\t//@ sf2.castFileToElementary();\r\n\t\t////@ close valid(); // auto\r\n\t\tJCSystem.commitTransaction();\r\n\t}\r\n}\r\n",
        "name": "EidCard-with-auto.java",
        "path": "examples/java/Java Card/NewEidCard/EidCard-with-auto.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/NewEidCard/EidCard-with-auto.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 97,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 98,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures File(fid, true, _) \u0026*\u0026 valid_id(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 107,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires [?f]valid_id(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures [f]valid_id(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 116,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires File(?fid, _, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 117,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures File(fid, b, info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 126,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires [?f]File(?fid, ?state, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 127,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures [f]File(fid, state, info) \u0026*\u0026 result == state;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 159,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 160,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures DedicatedFile(fid, null, true, nil, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 170,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires parent != null \u0026*\u0026 parent.DedicatedFile(?fileID, ?pf, ?activeState, ?siblist, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 171,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures DedicatedFile(fid, parent, true, nil, _) \u0026*\u0026 parent.DedicatedFile(fileID, pf, activeState, (length(siblist) \u003c DedicatedFile.MAX_SIBLINGS ? append(siblist, cons(this, nil)) : siblist), info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 182,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires DedicatedFile(?fid, ?parentfile, ?active, ?siblist, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 183,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures DedicatedFile(fid, parentfile, active, siblist, info) \u0026*\u0026 result == parentfile;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 191,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires DedicatedFile(?fileID, ?parentFile, ?activeState, ?siblist, ?info) \u0026*\u0026 valid_id(s);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 213,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires [?f]DedicatedFile(?fileID, ?parentFile, ?activeState, ?siblist, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 214,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures [f]DedicatedFile(fileID, parentFile, activeState, siblist, info) \u0026*\u0026 result == null ? true : mem(result, siblist) == true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 239,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires [?f]valid_id(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 240,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures [f]valid_id(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 249,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires File(?fid, _, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 250,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures File(fid, b, info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 263,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires [?f]File(?fid, ?state, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 264,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures [f]File(fid, state, info) \u0026*\u0026 result == state;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 299,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 300,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures this.MasterFile(0x3F00, null, true, nil, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 308,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires DedicatedFile(?fid, ?parentfile, ?active, ?siblist, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 309,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures DedicatedFile(fid, parentfile, active, siblist, info) \u0026*\u0026 result == parentfile;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 322,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires [?f]DedicatedFile(?fileID, ?parentFile, ?activeState, ?siblist, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 323,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures [f]DedicatedFile(fileID, parentFile, activeState, siblist, info) \u0026*\u0026 result == null ? true : mem(result, siblist) == true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 334,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires [?f]valid_id(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 335,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures [f]valid_id(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 343,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires File(?fid, _, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 344,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures File(fid, b, info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 358,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires [?f]File(?fid, ?state, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 359,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures [f]File(fid, state, info) \u0026*\u0026 result == state;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 373,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires DedicatedFile(?fileID, ?parentFile, ?activeState, ?siblist, ?info) \u0026*\u0026 valid_id(s);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 447,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires d != null \u0026*\u0026 array_slice(d, 0, d.length, _) \u0026*\u0026 d.length \u003c= Short.MAX_VALUE \u0026*\u0026 parent != null \u0026*\u0026 parent.DedicatedFile(?fileID, ?pf, ?activeState, _, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 448,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures ElementaryFile(fid, parent, d, true, (short)d.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 458,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires parent != null \u0026*\u0026 maxSize \u003e= 0 \u0026*\u0026 parent.DedicatedFile(?fileID, ?pf, ?activeState, ?siblist, ?info) \u0026*\u0026 length(siblist) \u003c DedicatedFile.MAX_SIBLINGS;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 459,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures ElementaryFile(fid, parent, ?data, true, 0, _) \u0026*\u0026 data != null \u0026*\u0026 data.length == maxSize \u0026*\u0026 parent.DedicatedFile(fileID, pf, activeState, append(siblist, cons(this, nil)), info) \u0026*\u0026 length(append(siblist, cons(this, nil))) == length(siblist) + 1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 470,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires [?f]ElementaryFile(?fid, ?pf, ?d, ?a, ?size, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 471,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures [f]ElementaryFile(fid, pf, d, a, size, info) \u0026*\u0026 result == d;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 482,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires [?f]ElementaryFile(?fid, ?parent, ?data, ?state, ?thesize, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 483,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures [f]ElementaryFile(fid, parent, data, state, thesize, info) \u0026*\u0026 result == thesize;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 496,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires [?f]ElementaryFile(?fid, ?parent, ?data, ?state, ?thesize, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 497,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures [f]ElementaryFile(fid, parent, data, state, thesize, info) \u0026*\u0026 data != null \u0026*\u0026 result == data.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 504,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires ElementaryFile(?fid, ?parent, ?theData, ?state, ?thesize, ?info) \u0026*\u0026 offset \u003e= 0 \u0026*\u0026 offset \u003c= thesize;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 505,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures ElementaryFile(fid, parent, theData, state, thesize, info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 527,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires [?f]valid_id(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 528,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures [f]valid_id(this);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 537,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires File(?fid, _, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 538,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures File(fid, b, info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 549,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires [?f]File(?fid, ?state, ?info);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 550,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures [f]File(fid, state, info) \u0026*\u0026 result == state;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 864,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires class_init_token(EidCard.class) \u0026*\u0026 system();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 865,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 961,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 962,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 987,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 988,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1033,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires [?f]selectedFile |-\u003e ?theSelectedFile \u0026*\u0026 [f]this.preferencesFile |-\u003e ?thePreferencesFile \u0026*\u0026 [f]this.cardholderPin |-\u003e ?theCardHolderPin \u0026*\u0026 theCardHolderPin != null \u0026*\u0026 [f]OwnerPIN(theCardHolderPin, _, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1034,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures [f]selectedFile |-\u003e theSelectedFile \u0026*\u0026 [f]this.preferencesFile |-\u003e thePreferencesFile \u0026*\u0026 [f]this.cardholderPin |-\u003e theCardHolderPin \u0026*\u0026 [f]OwnerPIN(theCardHolderPin, _, _) \u0026*\u0026 theSelectedFile instanceof ElementaryFile;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1063,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1064,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1137,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1138,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1196,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1197,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1243,
          "offsetAndLengths": [
            [
              9,
              13
            ]
          ],
          "preview": "    \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1244,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1312,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires nonRepKeyPair |-\u003e _ \u0026*\u0026 authKeyPair |-\u003e _ \u0026*\u0026 basicKeyPair |-\u003e _;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1347,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1348,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1401,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1402,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1651,
          "offsetAndLengths": [
            [
              12,
              13
            ]
          ],
          "preview": "            //@ requires current_applet(this) \u0026*\u0026 [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1652,
          "offsetAndLengths": [
            [
              12,
              12
            ]
          ],
          "preview": "            //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1662,
          "offsetAndLengths": [
            [
              9,
              13
            ]
          ],
          "preview": "    \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1663,
          "offsetAndLengths": [
            [
              9,
              12
            ]
          ],
          "preview": "    \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1672,
          "offsetAndLengths": [
            [
              12,
              13
            ]
          ],
          "preview": "            //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, ?buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1673,
          "offsetAndLengths": [
            [
              12,
              12
            ]
          ],
          "preview": "            //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer_) \u0026*\u0026 array_slice(buffer_, 0, buffer_.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1795,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1796,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1844,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires [1/2]cardholderPin |-\u003e ?theCardholderPin \u0026*\u0026 [1/2]OwnerPIN(pin, _, _) \u0026*\u0026 pin != null \u0026*\u0026 buffer != null \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer.length \u003e= 13;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1845,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures [1/2]cardholderPin |-\u003e theCardholderPin \u0026*\u0026 [1/2]OwnerPIN(pin, _, _) \u0026*\u0026 pin != null \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer != null \u0026*\u0026 buffer.length \u003e= 13;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1869,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1870,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1914,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer.length \u003e OFFSET_SECOND_PIN_HEADER + PIN_SIZE;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1915,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 buffer.length \u003e OFFSET_SECOND_PIN_HEADER + PIN_SIZE;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1940,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1941,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1982,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires buffer != null \u0026*\u0026 array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 offset \u003e= 0 \u0026*\u0026 offset \u003c buffer.length - PIN_SIZE \u0026*\u0026 offset + PIN_SIZE \u003c= Byte.MAX_VALUE;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1983,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2025,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures array_slice(buffer, 0, buffer.length, _) \u0026*\u0026 randomBuffer |-\u003e theRandomBuffer \u0026*\u0026 array_slice(theRandomBuffer, 0, theRandomBuffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2057,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2058,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2079,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2080,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2100,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2101,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2161,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2162,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2247,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2248,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2304,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2305,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2362,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2363,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2453,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, ?theBuffer) \u0026*\u0026 array_slice(theBuffer, 0, theBuffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2454,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, theBuffer) \u0026*\u0026 array_slice(theBuffer, 0, theBuffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2516,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, ?theBuffer) \u0026*\u0026 array_slice(theBuffer, 0, theBuffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2517,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, theBuffer) \u0026*\u0026 array_slice(theBuffer, 0, theBuffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2593,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2594,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures [1/2]valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2602,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2603,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2626,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2627,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2649,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2650,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2660,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2661,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2720,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2721,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2746,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2747,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2775,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2776,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2798,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires previousApduType |-\u003e ?thePreviousApduType \u0026*\u0026 thePreviousApduType != null \u0026*\u0026 thePreviousApduType.length == 1 \u0026*\u0026 is_transient_byte_array(thePreviousApduType) == true \u0026*\u0026 transient_byte_arrays(?ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2799,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures previousApduType |-\u003e thePreviousApduType \u0026*\u0026 thePreviousApduType != null \u0026*\u0026 transient_byte_arrays(ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2812,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires [?f]previousApduType |-\u003e ?thePreviousApduType \u0026*\u0026 thePreviousApduType != null \u0026*\u0026 thePreviousApduType.length == 1 \u0026*\u0026 is_transient_byte_array(thePreviousApduType) == true \u0026*\u0026 transient_byte_arrays(?ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2813,
          "offsetAndLengths": [
            [
              7,
              12
            ]
          ],
          "preview": "  \t    //@ ensures [f]previousApduType |-\u003e thePreviousApduType \u0026*\u0026 transient_byte_arrays(ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2826,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires signatureType |-\u003e ?theSignatureType \u0026*\u0026 theSignatureType != null \u0026*\u0026 theSignatureType.length == 1 \u0026*\u0026 is_transient_byte_array(theSignatureType) == true \u0026*\u0026 transient_byte_arrays(?ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2827,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures signatureType |-\u003e theSignatureType \u0026*\u0026 is_transient_byte_array(theSignatureType) == true \u0026*\u0026 transient_byte_arrays(ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2840,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires [?f]signatureType |-\u003e ?theSignatureType \u0026*\u0026 theSignatureType != null \u0026*\u0026 theSignatureType.length == 1 \u0026*\u0026 is_transient_byte_array(theSignatureType) == true \u0026*\u0026 transient_byte_arrays(?ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2841,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures [f]signatureType |-\u003e theSignatureType \u0026*\u0026 transient_byte_arrays(ta) \u0026*\u0026 foreachp(ta, transient_byte_array);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2857,
          "offsetAndLengths": [
            [
              7,
              13
            ]
          ],
          "preview": "  \t    //@ requires current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 2858,
          "offsetAndLengths": [
            [
              11,
              12
            ]
          ],
          "preview": "      \t    //@ ensures current_applet(this) \u0026*\u0026 [1/2]valid() \u0026*\u0026 APDU(apdu, buffer) \u0026*\u0026 array_slice(buffer, 0, buffer.length, _);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 1604,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "    \t//@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "interface Func {\r\n    //@ predicate valid(list\u003cClass\u003e level);\r\n    /*@\r\n    lemma void getClass_le_level();\r\n        requires [_]valid(?level);\r\n        ensures level_le({this.getClass()}, level) == true;\r\n    @*/\r\n    int apply(int x);\r\n        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\r\n        //@ ensures true;\r\n        //@ terminates;\r\n}\r\n\r\n//@ predicate Func(Func f, list\u003cClass\u003e level;) = f.valid(?level0) \u0026*\u0026 level_le(level0, level) == true;\r\n\r\nclass Util {\r\n    static int apply(Func f, int x)\r\n        //@ requires [_]Func(f, ?level) \u0026*\u0026 [2]call_perm(currentThread, level);\r\n        //@ ensures true;\r\n        //@ terminates;\r\n    {\r\n        //@ open Func(_, _);\r\n        //@ assert [_]f.valid(?level0);\r\n        //@ call_perm_weaken(2, level0);\r\n        //@ f.getClass_le_level();\r\n        //@ consume_call_perm_for(f.getClass());\r\n        return f.apply(x);\r\n    }\r\n    \r\n    static int deriv(Func f, int x)\r\n        //@ requires [_]Func(f, ?level) \u0026*\u0026 call_perm(currentThread, cons(Util.class, level));\r\n        //@ ensures true;\r\n        //@ terminates;\r\n    {\r\n        //@ call_perm_weaken_and_dup(4);\r\n        return apply(f, x + 1) - apply(f, x);\r\n    }\r\n}\r\n\r\nfinal class ZeroFunc implements Func {\r\n    //@ predicate valid(list\u003cClass\u003e level) = level == {ZeroFunc.class};\r\n    /*@\r\n    lemma void getClass_le_level()\r\n        requires [_]valid(?level);\r\n        ensures level_le({this.getClass()}, level) == true;\r\n    {\r\n        open valid(_);\r\n    }\r\n    @*/\r\n    ZeroFunc()\r\n        //@ requires true;\r\n        //@ ensures valid({ZeroFunc.class});\r\n        //@ terminates;\r\n    {\r\n        //@ close valid({ZeroFunc.class});\r\n    }\r\n    public int apply(int x)\r\n        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\r\n        //@ ensures true;\r\n        //@ terminates;\r\n    {\r\n        return 0;\r\n    }\r\n    public static Func create()\r\n        //@ requires true;\r\n        //@ ensures Func(result, {ZeroFunc.class});\r\n        //@ terminates;\r\n    {\r\n        Func f = new ZeroFunc();\r\n        //@ close Func(f, {ZeroFunc.class});\r\n        return f;\r\n    }\r\n}\r\n\r\nfinal class PlusOneFunc implements Func {\r\n    Func f;\r\n    //@ list\u003cClass\u003e fLevel;\r\n    //@ predicate valid(list\u003cClass\u003e level) = f |-\u003e ?f \u0026*\u0026 fLevel |-\u003e ?fLevel \u0026*\u0026 [_]Func(f, fLevel) \u0026*\u0026 level == cons(PlusOneFunc.class, fLevel);\r\n    /*@\r\n    lemma void getClass_le_level()\r\n        requires [_]valid(?level);\r\n        ensures level_le({this.getClass()}, level) == true;\r\n    {\r\n        open valid(_);\r\n    }\r\n    @*/\r\n    PlusOneFunc(Func f)\r\n        //@ requires [_]Func(f, ?fLevel);\r\n        //@ ensures valid(cons(PlusOneFunc.class, fLevel));\r\n        //@ terminates;\r\n    {\r\n        this.f = f;\r\n        //@ this.fLevel = fLevel;\r\n    }\r\n    public int apply(int x)\r\n        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\r\n        //@ ensures true;\r\n        //@ terminates;\r\n    {\r\n        //@ open valid(_);\r\n        //@ call_perm_weaken_and_dup(2);\r\n        return Util.apply(f, x) + 1;\r\n    }\r\n    public static Func create(Func f)\r\n        //@ requires [_]Func(f, ?fLevel) \u0026*\u0026 call_perm(currentThread, cons(PlusOneFunc.class, fLevel));\r\n        //@ ensures Func(result, cons(PlusOneFunc.class, fLevel));\r\n        //@ terminates;\r\n    {\r\n        return new PlusOneFunc(f);\r\n    }\r\n}\r\n\r\nclass Main {\r\n    public static void main(String[] args)\r\n        //@ requires true;\r\n        //@ ensures true;\r\n        //@ terminates;\r\n    {\r\n        //@ produce_call_below_perm_();\r\n        //@ list\u003cClass\u003e level = {Util.class, PlusOneFunc.class, PlusOneFunc.class, ZeroFunc.class};\r\n        //@ call_below_perm__elim(3, level);\r\n        Func f1 = ZeroFunc.create();\r\n        //@ call_perm_weaken(1, {PlusOneFunc.class, ZeroFunc.class});\r\n        Func f2 = PlusOneFunc.create(f1);\r\n        //@ call_perm_weaken(1, {PlusOneFunc.class, PlusOneFunc.class, ZeroFunc.class});\r\n        Func f3 = PlusOneFunc.create(f2);\r\n        Util.deriv(f3, 0);\r\n    }\r\n}\r\n",
        "name": "AbstractObjectConstruction.java",
        "path": "examples/java/termination/AbstractObjectConstruction.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/termination/AbstractObjectConstruction.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]Func(f, ?level) \u0026*\u0026 [2]call_perm(currentThread, level);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 18,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 30,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]Func(f, ?level) \u0026*\u0026 call_perm(currentThread, cons(Util.class, level));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 50,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 51,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid({ZeroFunc.class});\r"
        },
        {
          "limitHit": false,
          "lineNumber": 57,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 58,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 64,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 65,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Func(result, {ZeroFunc.class});\r"
        },
        {
          "limitHit": false,
          "lineNumber": 87,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]Func(f, ?fLevel);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 88,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures valid(cons(PlusOneFunc.class, fLevel));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 95,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]valid(?level) \u0026*\u0026 call_perm(currentThread, level);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 96,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 104,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires [_]Func(f, ?fLevel) \u0026*\u0026 call_perm(currentThread, cons(PlusOneFunc.class, fLevel));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 105,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Func(result, cons(PlusOneFunc.class, fLevel));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 114,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 115,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class OuterClass\n{\n  static class InnerClass\n  {\n    //@ predicate OuterClass$InnerClass(int x) = this.x |-\u003e x;\n    \n    int x = 1;\n    static int y = 1;\n    \n    InnerClass()\n    //@ requires true;\n    //@ ensures  OuterClass$InnerClass(1);\n    {\n      //@ close OuterClass$InnerClass(1);\n    }\n      \n    int getX()    \n      //@ requires OuterClass$InnerClass(?x);\n      //@ ensures OuterClass$InnerClass(x) \u0026*\u0026 result == x;\n    {\n      //@ open OuterClass$InnerClass(x);\n      return this.x;\n    }\n      \n    void setX(int i)    \n      //@ requires OuterClass$InnerClass(_);\n      //@ ensures OuterClass$InnerClass(i);\n    {\n      x = i;\n    }\n      \n    static int getY()    \n    //@ requires OuterClass$InnerClass_y(?y');\n    //@ ensures OuterClass$InnerClass_y(y') \u0026*\u0026 result == y'; \n    {\n      return y;\n    }\n      \n    static void setY(int i)    \n      //@ requires OuterClass$InnerClass_y(_);\n      //@ ensures OuterClass$InnerClass_y(i);\n    {\n      y = i;\n    }\n  }\n}\n\npublic class StaticMemberClass\n{\n  public static void main(String[] args)\n    //@ requires class_init_token(OuterClass$InnerClass.class);\n    //@ ensures true; \n  {\n    //@ init_class(OuterClass$InnerClass.class);\n    \n    OuterClass.InnerClass first = new OuterClass.InnerClass();\n    OuterClass.InnerClass second = new OuterClass.InnerClass();\n    \n    //Non-static stuff\n    first.setX(111);\n    int i = first.getX();\n    //@ assert i == 111;\n    \n    //Static stuff\n    first.setY(222);\n    int j = second.getY();\n    //@ assert j == 222;\n }\n}\n",
        "name": "StaticMemberClass.java",
        "path": "examples/java/frontend/inner_class/StaticMemberClass.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/inner_class/StaticMemberClass.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              6,
              13
            ]
          ],
          "preview": "      //@ requires OuterClass$InnerClass(?x);"
        },
        {
          "limitHit": false,
          "lineNumber": 18,
          "offsetAndLengths": [
            [
              6,
              12
            ]
          ],
          "preview": "      //@ ensures OuterClass$InnerClass(x) \u0026*\u0026 result == x;"
        },
        {
          "limitHit": false,
          "lineNumber": 25,
          "offsetAndLengths": [
            [
              6,
              13
            ]
          ],
          "preview": "      //@ requires OuterClass$InnerClass(_);"
        },
        {
          "limitHit": false,
          "lineNumber": 26,
          "offsetAndLengths": [
            [
              6,
              12
            ]
          ],
          "preview": "      //@ ensures OuterClass$InnerClass(i);"
        },
        {
          "limitHit": false,
          "lineNumber": 32,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires OuterClass$InnerClass_y(?y');"
        },
        {
          "limitHit": false,
          "lineNumber": 33,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures OuterClass$InnerClass_y(y') \u0026*\u0026 result == y'; "
        },
        {
          "limitHit": false,
          "lineNumber": 39,
          "offsetAndLengths": [
            [
              6,
              13
            ]
          ],
          "preview": "      //@ requires OuterClass$InnerClass_y(_);"
        },
        {
          "limitHit": false,
          "lineNumber": 40,
          "offsetAndLengths": [
            [
              6,
              12
            ]
          ],
          "preview": "      //@ ensures OuterClass$InnerClass_y(i);"
        },
        {
          "limitHit": false,
          "lineNumber": 50,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires class_init_token(OuterClass$InnerClass.class);"
        },
        {
          "limitHit": false,
          "lineNumber": 51,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true; "
        },
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  OuterClass$InnerClass(1);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class A \n{\n    int i;\n  \n    //@ predicate valid() = false;\n      \n    public int getI()\n    //@ requires valid();\n    //@ ensures valid();\n    {\n    \t//@ open valid();\n        return i/0; //~allow_dead_code\n    }\n}\n\n\nclass B extends A //~should_fail\n{\n    int j;\n    \n    //@ predicate valid() = this.i |-\u003e ?m_i \u0026*\u0026 this.j |-\u003e ?m_j;\n}\n\nclass Program {\n    public void test(B b) \n      //@ requires b != null \u0026*\u0026 b.valid();\n      //@ ensures true;\n    {\n    \tb.getI();\n    }\n}",
        "name": "NoOverrideTargetParam.java",
        "path": "examples/java/override_methods/NoOverrideTargetParam.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/override_methods/NoOverrideTargetParam.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 25,
          "offsetAndLengths": [
            [
              6,
              13
            ]
          ],
          "preview": "      //@ requires b != null \u0026*\u0026 b.valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 26,
          "offsetAndLengths": [
            [
              6,
              12
            ]
          ],
          "preview": "      //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public interface Inter\r\n{\r\n  public int increment(int i);\r\n    //@ requires i \u003c 100;\r\n    //@ ensures result == i + 1;\r\n}\r\n",
        "name": "Inter.java",
        "path": "examples/java/out_of_order_jarsrc/out_of_order/Inter.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/out_of_order_jarsrc/out_of_order/Inter.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires i \u003c 100;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class Super implements Inter\r\n{\r\n  public int increment(int i)\r\n    //@ requires i \u003c 100;\r\n    //@ ensures result == i + 1;\r\n  {\r\n    return ++i;\r\n  }\r\n}\r\n",
        "name": "Super.java",
        "path": "examples/java/out_of_order_jarsrc/out_of_order/Super.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/out_of_order_jarsrc/out_of_order/Super.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires i \u003c 100;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package newepurse;\r\n\r\nimport javacard.framework.*;\r\n\r\nimport org.globalplatform.GPSystem;\r\n\r\n\r\npublic class EPurseServicesDebit implements IEPurseServicesDebit {\r\n\r\n    private NewEPurseApplet epurseApplet;\r\n\r\n    //@ predicate Shareable(NewEPurseApplet a) = epurseApplet |-\u003e a;\r\n\r\n    EPurseServicesDebit(NewEPurseApplet epurseApplet)\r\n        //@ requires true;\r\n        //@ ensures Shareable(epurseApplet);\r\n    {\r\n\tthis.epurseApplet = epurseApplet;\r\n    }\r\n\r\n\r\n    public void debit(short amount)\r\n        //@ requires Shareable(?a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r\n        //@ ensures Shareable(a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r\n    {\r\n\t// application state checking\r\n\t// Rational: when the applet is LOCKED, it cannot be selected,\r\n\t// but it can be accessed trough shared method calls.\r\n\tif (GPSystem.getCardContentState() == GPSystem.APPLICATION_LOCKED)\r\n\t    ISOException.throwIt(NewEPurseApplet.SW_INVALID_STATE);\r\n\tshort clientId;\r\n\t// client registration checking\r\n\tAID clientAID = JCSystem.getPreviousContextAID();\r\n\tif ((clientId = epurseApplet.searchClientAID(clientAID)) == -1)\r\n\t    ISOException.throwIt(NewEPurseApplet.SW_INVALID_CLIENT);\r\n\tshort clientLimit = epurseApplet.getClientLimit(clientId);\r\n\t// client limit checking\r\n\tif (amount \u003e clientLimit) \r\n\t    ISOException.throwIt(NewEPurseApplet.SW_CLIENT_LIMIT_EXCEEDED);\r\n\t// service delivering\r\n\tepurseApplet.debit(amount);\r\n    }\r\n\r\n}\r\n",
        "name": "EPurseServicesDebit.java",
        "path": "examples/java/Java Card/NewEPurse/EPurseServicesDebit.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/NewEPurse/EPurseServicesDebit.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Shareable(epurseApplet);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 22,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires Shareable(?a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 23,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Shareable(a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package newmypackage;\r\n\r\n\tpublic class NewMyAppletPoints implements INewMyAppletPoints {\r\n\r\n\t\t//@ javacard.framework.Applet applet;\r\n\t\t//@ predicate Shareable(javacard.framework.Applet a) = [_]applet |-\u003e a;\r\n\t\t\r\n\t\tpublic byte sharePoints(byte points) \r\n\t\t  //@ requires true;\r\n                  //@ ensures true;\r\n\t\t{\r\n\t        return points \u003c= 124 ? (byte) (points + 3) : points;\r\n\t\t}\r\n\t\t\r\n\t\t//@ lemma void getShareable() requires [_]applet |-\u003e ?a; ensures Shareable(a); {}\r\n\r\n\t}",
        "name": "NewMyAppletPoints.java",
        "path": "examples/java/Java Card/NewMyApplet/NewMyAppletPoints.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/NewMyApplet/NewMyAppletPoints.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "\t\t  //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              18,
              12
            ]
          ],
          "preview": "                  //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package newepurse;\r\n\r\nimport javacard.framework.*;\r\n\r\nimport org.globalplatform.GPSystem;\r\n\r\n\r\npublic class EPurseServicesCredit implements IEPurseServicesCredit {\r\n\r\n    private NewEPurseApplet epurseApplet;\r\n\r\n    //@ predicate Shareable(NewEPurseApplet a) = epurseApplet |-\u003e a;\r\n\r\n    EPurseServicesCredit(NewEPurseApplet epurseApplet)\r\n        //@ requires true;\r\n        //@ ensures Shareable(epurseApplet);\r\n    {\r\n\tthis.epurseApplet = epurseApplet;\r\n    }\r\n\r\n\r\n    public void charge(short amount)\r\n        //@ requires Shareable(?a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r\n        //@ ensures Shareable(a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r\n    {\r\n\t// application state checking\r\n\t// Rational: when the applet is LOCKED, it cannot be selected,\r\n\t// but it can be accessed trough shared method calls.\r\n\tif (GPSystem.getCardContentState() == GPSystem.APPLICATION_LOCKED)\r\n\t    ISOException.throwIt(NewEPurseApplet.SW_INVALID_STATE);\r\n\tshort clientId;\r\n\t// client registration checking\r\n\tAID clientAID = JCSystem.getPreviousContextAID();\r\n\tif ((clientId = epurseApplet.searchClientAID(clientAID)) == -1)\r\n\t    ISOException.throwIt(NewEPurseApplet.SW_INVALID_CLIENT);\r\n\tshort clientLimit = epurseApplet.getClientLimit(clientId);\r\n\t// client limit checking\r\n\tif (amount \u003e clientLimit) \r\n\t    ISOException.throwIt(NewEPurseApplet.SW_CLIENT_LIMIT_EXCEEDED);\r\n\t// service delivering\r\n\tepurseApplet.charge(amount);\r\n    }\r\n    \r\n    public void transaction(short amount)\r\n        //@ requires Shareable(?a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r\n        //@ ensures Shareable(a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r\n    {\r\n       \t// application state checking\r\n       \t// Rational: when the applet is LOCKED, it cannot be selected,\r\n       \t// but it can be accessed trough shared method calls.\r\n       \tif (GPSystem.getCardContentState() == GPSystem.APPLICATION_LOCKED)\r\n       \t    ISOException.throwIt(NewEPurseApplet.SW_INVALID_STATE);\r\n       \tshort clientId;\r\n       \t// client registration checking\r\n       \tAID clientAID = JCSystem.getPreviousContextAID();\r\n       \tif ((clientId = epurseApplet.searchClientAID(clientAID)) == -1)\r\n       \t    ISOException.throwIt(NewEPurseApplet.SW_INVALID_CLIENT);\r\n       \tshort clientLimit = epurseApplet.getClientLimit(clientId);\r\n       \t// client limit checking\r\n       \tif (amount \u003e clientLimit) \r\n       \t    ISOException.throwIt(NewEPurseApplet.SW_CLIENT_LIMIT_EXCEEDED);\r\n       \t// service delivering\r\n       \tepurseApplet.transaction(amount);\r\n    }\r\n    \r\n\r\n}\r\n",
        "name": "EPurseServicesCredit.java",
        "path": "examples/java/Java Card/NewEPurse/EPurseServicesCredit.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/NewEPurse/EPurseServicesCredit.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Shareable(epurseApplet);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 22,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires Shareable(?a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 23,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Shareable(a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 44,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires Shareable(?a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 45,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Shareable(a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package newmypackage;\r\n\r\nimport javacard.framework.Shareable;\r\n\r\n\r\npublic interface INewMyAppletPoints extends Shareable {\r\n\r\n\tbyte sharePoints (byte points);\r\n\t    //@ requires true;\r\n\t    //@ ensures true;\r\n\r\n}\r\n",
        "name": "INewMyAppletPoints.java",
        "path": "examples/java/Java Card/NewMyApplet/INewMyAppletPoints.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/NewMyApplet/INewMyAppletPoints.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              5,
              13
            ]
          ],
          "preview": "\t    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              5,
              12
            ]
          ],
          "preview": "\t    //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package newepurse;\r\n\r\nimport javacard.framework.*;\r\n\r\npublic interface IEPurseServicesDebit extends Shareable {\r\n\r\n    public void debit(short amount) throws ISOException /*@ ensures true; @*/;\r\n        //@ requires Shareable(?a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r\n        //@ ensures Shareable(a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r\n\r\n}\r\n",
        "name": "IEPurseServicesDebit.java",
        "path": "examples/java/Java Card/NewEPurse/IEPurseServicesDebit.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/NewEPurse/IEPurseServicesDebit.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires Shareable(?a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Shareable(a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import subpackage.Subpackage;\n//@ import subpackage.fixpoint1;\n//@ import subpackage.predicate1;\n\nclass Main \n{\n  public static void main(String[] args) \n    //@ requires true;\n    //@ ensures true; \n  {\n    Subpackage o = new Subpackage();\n    //@ int i = fixpoint1(0);\n    //@ close predicate1();\n    //@ open predicate1();\n    /*~*/ //@ lemma1();\n  }\n}\n",
        "name": "Main_missing_lemma_include.java",
        "path": "examples/java/ghost_imports/Main_missing_lemma_include.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/ghost_imports/Main_missing_lemma_include.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true; "
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "abstract class A \r\n{\r\n  //@ predicate pred() = true;\r\n\r\n  public A()\r\n    //@ requires true;\r\n    //@ ensures pred();\r\n  {\r\n    //@ close pred();\r\n  }\r\n\r\n  public void m()\r\n    //@ requires pred();\r\n    //@ ensures pred();\r\n  {\r\n  }\r\n}\r\n\r\nclass B extends A //~\r\n{\r\n  public B()\r\n    \r\n\r\n  {\r\n    super();\r\n  }\r\n}\r\n\r\nclass C \r\n{\r\n  public void m()\r\n\r\n\r\n  {\r\n    B b = new B();\r\n  }\r\n}\r\n",
        "name": "NoOverrideSpecfileExport.java",
        "path": "examples/java/override_methods/NoOverrideSpecfileExport.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/override_methods/NoOverrideSpecfileExport.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures pred();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires pred();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures pred();\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "abstract class A \r\n{\r\n  //@ predicate pred() = true;\r\n\r\n  public A()\r\n    //@ requires true;\r\n    //@ ensures pred();\r\n  {\r\n    //@ close pred();\r\n  }\r\n\r\n  public void m()\r\n    //@ requires pred();\r\n    //@ ensures pred();\r\n  {\r\n  }\r\n}\r\n\r\nclass B extends A //~\r\n{\r\n  public B()\r\n\r\n\r\n  {\r\n    super();\r\n  }\r\n}\r\n\r\nclass C \r\n{\r\n  public void m()\r\n    //@ requires true;\r\n    //@ ensures true;\r\n  {\r\n    B b = new B();\r\n  }\r\n}\r\n",
        "name": "NoOverrideObjectCreation.java",
        "path": "examples/java/override_methods/NoOverrideObjectCreation.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/override_methods/NoOverrideObjectCreation.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures pred();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires pred();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures pred();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 32,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class LocalClass_desugared\n{\n  public static void main(String[] args)\n    //@ requires true;\n    //@ ensures true;  \n  {\n    LocalClass_desugared$1InnerClass first = new LocalClass_desugared$1InnerClass();\n    first.setX(111);\n    int i = first.getX();\n    /*@ assert i == 111;@*/\n  }\n}\n\nclass LocalClass_desugared$1InnerClass \n{\n  //@ predicate LocalClass_desugared$1InnerClass(int x) = this.x |-\u003e x; \n  \n  int x = 1;\n    \n  LocalClass_desugared$1InnerClass()    \n    //@ requires true;\n    //@ ensures  LocalClass_desugared$1InnerClass(1);\n  {\n    super();\n    //@ close LocalClass_desugared$1InnerClass(1);\n  }\n    \n  int getX()    \n    //@ requires LocalClass_desugared$1InnerClass(?x);\n    //@ ensures LocalClass_desugared$1InnerClass(x) \u0026*\u0026 result == x;\n  {\n    //@ open LocalClass_desugared$1InnerClass(x);\n    return this.x;\n  }\n    \n  void setX(int i)    \n    //@ requires LocalClass_desugared$1InnerClass(_);\n    //@ ensures LocalClass_desugared$1InnerClass(i);\n  {\n    x = i;\n  }\n}\n",
        "name": "LocalClass_desugared.java",
        "path": "examples/java/frontend/inner_class/LocalClass_desugared.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/inner_class/LocalClass_desugared.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;  "
        },
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires LocalClass_desugared$1InnerClass(?x);"
        },
        {
          "limitHit": false,
          "lineNumber": 29,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures LocalClass_desugared$1InnerClass(x) \u0026*\u0026 result == x;"
        },
        {
          "limitHit": false,
          "lineNumber": 36,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires LocalClass_desugared$1InnerClass(_);"
        },
        {
          "limitHit": false,
          "lineNumber": 37,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures LocalClass_desugared$1InnerClass(i);"
        },
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  LocalClass_desugared$1InnerClass(1);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package newepurse;\r\n\r\nimport javacard.framework.*;\r\n\r\npublic interface IEPurseServicesCredit extends Shareable {\r\n\r\n    public void charge(short amount);\r\n        //@ requires Shareable(?a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r\n        //@ ensures Shareable(a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r\n    public void transaction(short amount);\r\n        //@ requires Shareable(?a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r\n        //@ ensures Shareable(a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r\n\r\n}\r\n",
        "name": "IEPurseServicesCredit.java",
        "path": "examples/java/Java Card/NewEPurse/IEPurseServicesCredit.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/NewEPurse/IEPurseServicesCredit.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires Shareable(?a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Shareable(a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires Shareable(?a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Shareable(a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package subpackage1;\n\nimport  subpackage1.subsub1.Number1_1;\n\npublic class Multiply1\n{\n  static public int multiply()\n    //@ requires true;\n    //@ ensures result == 11;\n  {\n    return 1 * Number1_1.getNumber();\n  }\n}\n",
        "name": "Multiply1.java",
        "path": "examples/java/frontend/many_files/subpackage1/Multiply1.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/many_files/subpackage1/Multiply1.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == 11;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package subpackage2;\n\nimport  subpackage2.subsub1.Number2_1;\nimport  subpackage2.subsub2.Number2_2;\n\npublic class Multiply2\n{\n  static public int multiply()\n    //@ requires true;\n    //@ ensures result == 21 * 22;\n  {\n    return 1 * Number2_1.getNumber() * Number2_2.getNumber();\n  }\n}\n",
        "name": "Multiply2.java",
        "path": "examples/java/frontend/many_files/subpackage2/Multiply2.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/many_files/subpackage2/Multiply2.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == 21 * 22;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class Sub extends Super //~\r\n{\r\n  public int increment(int i)\r\n    //@ requires i \u003c 100;\r\n    //@ ensures result == i + 1;\r\n  {\r\n    int j = i;\r\n    j++;\r\n    return j;\r\n  }\r\n\r\n  public int dummy(int i)\r\n    //@ requires true;\r\n    //@ ensures result == i;\r\n  {\r\n    return i;\r\n  }\r\n}\r\n",
        "name": "Sub.java",
        "path": "examples/java/out_of_order_jarsrc/inheritance_cycle/Sub.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/out_of_order_jarsrc/inheritance_cycle/Sub.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires i \u003c 100;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package subpackage3;\n\nimport  subpackage3.subsub1.Number3_1;\nimport  subpackage3.subsub2.Number3_2;\nimport  subpackage3.subsub3.Number3_3;\n\npublic class Multiply3\n{\n  static public int multiply()\n    //@ requires true;\n    //@ ensures result == 31 * 32 * 33;\n  {\n    return 1 * Number3_1.getNumber() * Number3_2.getNumber() * Number3_3.getNumber();\n  }\n}\n",
        "name": "Multiply3.java",
        "path": "examples/java/frontend/many_files/subpackage3/Multiply3.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/many_files/subpackage3/Multiply3.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == 31 * 32 * 33;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class OuterClass \n{\n}\n\npublic class MemberClass_desugared\n{\n  public static void main(String[] args)    \n    //@ requires class_init_token(OuterClass$InnerClass.class);\n    //@ ensures true; \n  {\n    //@ init_class(OuterClass$InnerClass.class);\n\n    OuterClass first = new OuterClass();\n    OuterClass$InnerClass second = new OuterClass$InnerClass(first /**Null check is missing*/);\n    second.setX(111);\n    int i = second.getX();\n    /*@ assert i == 111;@*/\n  }\n}\n\nclass OuterClass$InnerClass \n{\n  final OuterClass this$0;\n  \n  //@ predicate OuterClass$InnerClass(int x) = this.x |-\u003e x;\n  \n  int x = 1;\n    \n  OuterClass$InnerClass(OuterClass this$0)    \n    //@ requires true;\n    //@ ensures  OuterClass$InnerClass(1); \n  {\n    super();\n    this.this$0 = this$0;\n    //@ close OuterClass$InnerClass(1);\n  }\n\n  int getX()    \n    //@ requires OuterClass$InnerClass(?x);\n    //@ ensures OuterClass$InnerClass(x) \u0026*\u0026 result == x;\n  {\n     //@ open OuterClass$InnerClass(x);\n    return this.x;\n  }\n    \n  void setX(int i)    \n    //@ requires OuterClass$InnerClass(_);\n    //@ ensures OuterClass$InnerClass(i);\n  {\n    x = i;\n  }\n}\n",
        "name": "MemberClass_desugared.java",
        "path": "examples/java/frontend/inner_class/MemberClass_desugared.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/inner_class/MemberClass_desugared.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires class_init_token(OuterClass$InnerClass.class);"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true; "
        },
        {
          "limitHit": false,
          "lineNumber": 29,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires OuterClass$InnerClass(?x);"
        },
        {
          "limitHit": false,
          "lineNumber": 39,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures OuterClass$InnerClass(x) \u0026*\u0026 result == x;"
        },
        {
          "limitHit": false,
          "lineNumber": 46,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires OuterClass$InnerClass(_);"
        },
        {
          "limitHit": false,
          "lineNumber": 47,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures OuterClass$InnerClass(i);"
        },
        {
          "limitHit": false,
          "lineNumber": 30,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  OuterClass$InnerClass(1); "
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class Main\r\n{\r\n  public static void main(String[] args) \r\n    //@ requires true;\r\n    //@ ensures true; \r\n  {\r\n    Super o = new Sub();\r\n    int i = 0;\r\n    i = o.increment(i);\r\n    //@ assert i == 1;\r\n  }\r\n}\r\n",
        "name": "Main.java",
        "path": "examples/java/out_of_order_jarsrc/inheritance_cycle/Main.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/out_of_order_jarsrc/inheritance_cycle/Main.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true; \r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package mypackage;\n\nimport java.util.*;\n\n/*@\n\nfixpoint int sumize(list\u003cint\u003e l){\n   switch(l) {\n     case nil : return 0;\n     case cons(i, r) : return i + sumize(r);\n   }\n}\n\nfixpoint list\u003cb\u003e map\u003ca, b\u003e (fixpoint(a, b) f, list\u003ca\u003e l){\n  switch(l){\n    case nil : return nil;\n    case cons (x, r) : return cons(f (x), map(f, r));\n  }\n}\n\npredicate_family FoldFunc(Class c)(FoldFunc f, list\u003cObject\u003e in, Object acc, any info);\n\n@*/\n\ninterface FoldFunc\n{    \n  Object fold(Object acc, Object x);   \n    //@ requires FoldFunc(this.getClass())(this, cons(?o, ?r), acc, ?info) \u0026*\u0026 o == x;\n    //@ ensures FoldFunc(this.getClass())(this, r, result, info);\n}\n\nclass EmptyException extends Exception \n{\n}\n\n/*@\n  \npredicate_family_instance FoldFunc(Java7Program_desugared$1.class)(FoldFunc f, list\u003cInteger\u003e in, Integer acc, list\u003cInteger\u003e info) =\n         not_null(in) == true \u0026*\u0026 acc != null \u0026*\u0026\n         sumize(map(Integer_intValue, info)) == sumize(map(Integer_intValue, in)) + Integer_intValue(acc); \n  \n@*/\n\npublic class Java7Program_desugared \n{\n  public static \u003cT\u003e void addAll(List\u003cT\u003e l, T[] xs) throws EmptyException /*@ ensures xs.length == 0; @*/\n    //@ requires l.List(?l_es) \u0026*\u0026 [?f]xs[..] |-\u003e ?xs_es;\n    //@ ensures l.List(append(l_es, xs_es)) \u0026*\u0026 [f]xs[..] |-\u003e xs_es \u0026*\u0026 xs.length \u003e 0;\n  {\n    if (xs.length \u003e 0)\n    {\n      List\u003cT\u003e temp = Arrays.asList(xs);\n      //@ close listIsCollection(temp, temp);\n      l.addAll(temp);\n    }\n    else\n    {\n      throw new EmptyException();\n    }\n  }\n\n  public static \u003cT\u003e T fold(FoldFunc f, List\u003cT\u003e xs, T acc0)\n    //@ requires xs.List(?es) \u0026*\u0026 FoldFunc(f.getClass())(f, es, acc0, ?info) \u0026*\u0026 f != null;\n    //@ ensures xs.List(es) \u0026*\u0026 FoldFunc(f.getClass())(f, nil, result, info);\n  {\n    T acc = acc0;\n    \n    //@ xs.listToIterable();\n    {\n      Iterator\u003cT\u003e iSSS = xs.iterator();\n      while (iSSS.hasNext())\n        //@ requires iSSS.Iterator((seq_of_list)(es), _, ?n) \u0026*\u0026 FoldFunc(f.getClass())(f, drop(n, es), acc, info) \u0026*\u0026 f != null \u0026*\u0026 n \u003e= 0 \u0026*\u0026 n \u003c= length(es);\n        //@ ensures FoldFunc(f.getClass())(f, nil, acc, info) \u0026*\u0026 iSSS.Iterator((seq_of_list)(es), _, length(es));\n      {\n        T x = iSSS.next();\n        {\n          //@ drop_n_plus_one(n, es);\n          acc = f.fold(acc, x);\n        }\n      }\n    }\n    //@ xs.destroyIterator();\n    //@ xs.iterableToList();\n    \n    return acc;\n  } \n\n  public static void main(String[] args)\n    //@ requires true;\n    //@ ensures true;\n  {\n    List\u003cInteger\u003e xs = new ArrayList\u003cInteger\u003e(); \n    Integer i1 = Integer.valueOf(3);\n    Integer i2 = Integer.valueOf(5);\n    Integer i3 = Integer.valueOf(7);\n    \n    try\n    {\n      Java7Program_desugared.\u003cInteger\u003eaddAll(xs, new Integer[]{i1, i2, i3});\n    }\n    catch (EmptyException e)\n    {\n      //@ assert false;\n    }\n    //@ list\u003cInteger\u003e exs = {i1, i2, i3};\n    \n    FoldFunc func = new Java7Program_desugared$1();\n    Integer acc = Integer.valueOf(2);\n    //@ close FoldFunc(Java7Program_desugared$1.class)(func, exs, acc, cons(acc, exs));\n    Integer vi = Java7Program_desugared.\u003cInteger\u003efold(func, xs, acc);\n    //@ open FoldFunc(Java7Program_desugared$1.class)(_, _, _, _);\n    int v = vi.intValue();\n    \n    //@ assert v == 17;\n    \n    //@ boolean is_thrown = false;\n    try\n    {\n      Java7Program_desugared.\u003cInteger\u003eaddAll(xs, new Integer[]{});\n    }\n    catch (EmptyException e)\n    {\n      //@ is_thrown = true;\n    }\n    //@ assert is_thrown;\n    \n    Object i = null;\n    //@ is_thrown = false;\n    try\n    {\n      if (i == null)\n        throw new NullPointerException();\n      else\n      {}\n    }\n    catch (NullPointerException e)\n    {\n      //@ is_thrown = true;\n    }\n    //@ assert is_thrown;\n  }\n}\n\nclass Java7Program_desugared$1 implements FoldFunc \n{\n  public Integer fold(Integer acc, Integer x)\n    //@ requires FoldFunc(Java7Program_desugared$1.class)(this, cons(?o, ?r), acc, ?info) \u0026*\u0026 o == x;\n    //@ ensures FoldFunc(Java7Program_desugared$1.class)(this, r, result, info);\n  {\n    //@ open FoldFunc(Java7Program_desugared$1.class)(this, cons(?_o, ?_r), acc, ?_info);\n    Integer res = Integer.valueOf(acc.intValue() + x.intValue());\n    return res;\n    //@ close FoldFunc(Java7Program_desugared$1.class)(this, _r, res, _info);\n  }  \n\n  public Object fold(Object x0, Object x1)\n    //@ requires FoldFunc(Java7Program_desugared$1.class)(this, cons(?o, ?r), x0, ?info) \u0026*\u0026 o == x1;\n    //@ ensures FoldFunc(Java7Program_desugared$1.class)(this, r, result, info);\n  {\n    return this.fold((Integer) x0, (Integer) x1);\n  }\n}\n\n\n",
        "name": "Java7Program_desugared.java",
        "path": "examples/java/frontend/big_example/Java7Program_desugared.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/big_example/Java7Program_desugared.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires FoldFunc(this.getClass())(this, cons(?o, ?r), acc, ?info) \u0026*\u0026 o == x;"
        },
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures FoldFunc(this.getClass())(this, r, result, info);"
        },
        {
          "limitHit": false,
          "lineNumber": 46,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires l.List(?l_es) \u0026*\u0026 [?f]xs[..] |-\u003e ?xs_es;"
        },
        {
          "limitHit": false,
          "lineNumber": 47,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures l.List(append(l_es, xs_es)) \u0026*\u0026 [f]xs[..] |-\u003e xs_es \u0026*\u0026 xs.length \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 62,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires xs.List(?es) \u0026*\u0026 FoldFunc(f.getClass())(f, es, acc0, ?info) \u0026*\u0026 f != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 63,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures xs.List(es) \u0026*\u0026 FoldFunc(f.getClass())(f, nil, result, info);"
        },
        {
          "limitHit": false,
          "lineNumber": 71,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires iSSS.Iterator((seq_of_list)(es), _, ?n) \u0026*\u0026 FoldFunc(f.getClass())(f, drop(n, es), acc, info) \u0026*\u0026 f != null \u0026*\u0026 n \u003e= 0 \u0026*\u0026 n \u003c= length(es);"
        },
        {
          "limitHit": false,
          "lineNumber": 72,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures FoldFunc(f.getClass())(f, nil, acc, info) \u0026*\u0026 iSSS.Iterator((seq_of_list)(es), _, length(es));"
        },
        {
          "limitHit": false,
          "lineNumber": 88,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 89,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 146,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires FoldFunc(Java7Program_desugared$1.class)(this, cons(?o, ?r), acc, ?info) \u0026*\u0026 o == x;"
        },
        {
          "limitHit": false,
          "lineNumber": 147,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures FoldFunc(Java7Program_desugared$1.class)(this, r, result, info);"
        },
        {
          "limitHit": false,
          "lineNumber": 156,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires FoldFunc(Java7Program_desugared$1.class)(this, cons(?o, ?r), x0, ?info) \u0026*\u0026 o == x1;"
        },
        {
          "limitHit": false,
          "lineNumber": 157,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures FoldFunc(Java7Program_desugared$1.class)(this, r, result, info);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "abstract class A \r\n{\r\n  //@ predicate pred() = true;\r\n\r\n  public A()\r\n    //@ requires true;\r\n    //@ ensures pred();\r\n  {\r\n    //@ close pred();\r\n  }\r\n\r\n  public void m()\r\n    //@ requires pred();\r\n    //@ ensures pred();\r\n  {\r\n  }\r\n}\r\n\r\nclass B extends A\r\n{\r\n  public B()\r\n\r\n\r\n  {\r\n    super();\r\n  }\r\n}\r\n\r\nclass C \r\n{\r\n  public void m()\r\n\r\n\r\n  {\r\n    B b = new B();\r\n  }\r\n}\r\n",
        "name": "NoOverrideSpecfileNoExport.java",
        "path": "examples/java/override_methods/NoOverrideSpecfileNoExport.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/override_methods/NoOverrideSpecfileNoExport.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures pred();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires pred();\r"
        },
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures pred();\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package subpackage;\n\npublic class Multiply\n{\n  public int multiply()\n    //@ requires true;\n    //@ ensures result == 30;\n  {\n    NumberFive five = new NumberFive();\n    NumberSix six = new NumberSix();\n    return five.getFive() * six.getSix();\n  }\n}\n",
        "name": "Multiply.java",
        "path": "examples/java/frontend/multiple_files/subpackage/Multiply.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/multiple_files/subpackage/Multiply.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == 30;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public interface Inter\r\n{\r\n  public int increment(int i);\r\n    //@ requires i \u003c 100;\r\n    //@ ensures result == i + 1;\r\n}\r\n",
        "name": "Inter.java",
        "path": "examples/java/out_of_order_jarsrc/inheritance_cycle/Inter.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/out_of_order_jarsrc/inheritance_cycle/Inter.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires i \u003c 100;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class Super extends Sub implements Inter\r\n{\r\n  public int increment(int i)\r\n    //@ requires i \u003c 100;\r\n    //@ ensures result == i + 1;\r\n  {\r\n    return ++i;\r\n  }\r\n}\r\n",
        "name": "Super.java",
        "path": "examples/java/out_of_order_jarsrc/inheritance_cycle/Super.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/out_of_order_jarsrc/inheritance_cycle/Super.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires i \u003c 100;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import subpackage.Subpackage;\n//@ import subpackage.predicate1;\n//@ import subpackage.lemma1;\n\nclass Main \n{\n  public static void main(String[] args) \n    //@ requires true;\n    //@ ensures true; \n  {\n    Subpackage o = new Subpackage();\n    /*~*/ //@ int i = fixpoint1(0);\n  }\n}\n",
        "name": "Main_missing_fixpoint_include.java",
        "path": "examples/java/ghost_imports/Main_missing_fixpoint_include.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/ghost_imports/Main_missing_fixpoint_include.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true; "
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package wallet;\n\nimport javacard.framework.*;\n\npublic interface EWalletInterface extends Shareable {\n\n    public void verify(byte[] pincode, short offset, byte length);\n        //@ requires array_slice(pincode, 0, pincode.length, _) \u0026*\u0026 Shareable(?a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\n        //@ ensures array_slice(pincode, 0, pincode.length, _) \u0026*\u0026 Shareable(a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\n    \n    public void debit(byte amount);\n        //@ requires 0 \u003c= amount \u0026*\u0026 Shareable(?a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\n        //@ ensures Shareable(a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();\n    \n}\n",
        "name": "EWalletInterface.java",
        "path": "examples/java/Java Card/shareable-applets/EWalletInterface.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Java%20Card/shareable-applets/EWalletInterface.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires array_slice(pincode, 0, pincode.length, _) \u0026*\u0026 Shareable(?a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures array_slice(pincode, 0, pincode.length, _) \u0026*\u0026 Shareable(a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires 0 \u003c= amount \u0026*\u0026 Shareable(?a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures Shareable(a) \u0026*\u0026 in_transaction(a) \u0026*\u0026 a.valid();"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package subpackage;\n\nclass NumberSix\n{\n  int getSix()\n    //@ requires true;\n    //@ ensures result == 6;\n  {\n    return 6;\n  }\n}\n",
        "name": "NumberSix.java",
        "path": "examples/java/frontend/multiple_files/subpackage/NumberSix.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/multiple_files/subpackage/NumberSix.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == 6;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import subpackage.Subpackage;\n//@ import subpackage.fixpoint1;\n//@ import subpackage.lemma1;\n\nclass Main \n{\n  public static void main(String[] args) \n    //@ requires true;\n    //@ ensures true; \n  {\n    Subpackage o = new Subpackage();\n    //@ int i = fixpoint1(0);\n    /*~*/ //@ close predicate1();\n  }\n}\n",
        "name": "Main_missing_predicate_include.java",
        "path": "examples/java/ghost_imports/Main_missing_predicate_include.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/ghost_imports/Main_missing_predicate_include.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true; "
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "interface AnonymousInterface\n{\n  int increment(int i);    \n    //@ requires true;\n    //@ ensures result == i + 1;\n    \n  int decrement(int i);    \n    //@ requires true;\n    //@ ensures result == i - 1;\n}\n\npublic class AnonymousClass_desugared\n{    \n  public static void main(String[] args)    \n    //@ requires true;\n    //@ ensures true;\n  {\n    AnonymousInterface inner = new AnonymousClass_desugared$1();\n    \n    int i = 0;\n    i = inner.increment(100);\n    //@ assert i == 101;\n    i = inner.increment(i);\n    //@ assert i == 102;\n    i = inner.decrement(i);\n    //@ assert i == 101;\n    i = inner.decrement(i);\n    //@ assert i == 100;\n  }\n}\n\nclass AnonymousClass_desugared$1 implements AnonymousInterface \n{\n  public int increment(int i)    \n    //@ requires true;\n    //@ ensures result == i + 1;\n  {\n    return i + 1;\n  }\n    \n  public int decrement(int i)    \n    //@ requires true;\n    //@ ensures result == i - 1;\n  {\n    return i - 1;\n  }\n}\n",
        "name": "AnonymousClass_desugared.java",
        "path": "examples/java/frontend/inner_class/AnonymousClass_desugared.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/inner_class/AnonymousClass_desugared.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i - 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 34,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 35,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 41,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 42,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i - 1;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package subpackage;\n\npublic class NumberFive\n{\n  int getFive()\n    //@ requires true;\n    //@ ensures result == 5;\n  {\n    return 5;\n  }\n}\n",
        "name": "NumberFive.java",
        "path": "examples/java/frontend/multiple_files/subpackage/NumberFive.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/multiple_files/subpackage/NumberFive.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == 5;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class NotAnnotatedClass2_1\n{\n  private int x; \n\n  NotAnnotatedClass2_1(int i) {/*@ assert false; @*/x = i;}\n\n  int NotAnnotatedClass2_1_1(int i) {/*@ assert false; @*/return i;}\n}\n\npublic class PartiallyAnnotated2 implements PartiallyAnnotatedInterface2\n{\n  //@ predicate PartiallyAnnotatedClassPred2(int value) = this.i |-\u003e value;\n  \n  private int i;\n  \n  public PartiallyAnnotated2()\n  {\n    this.i = 0;\n  }\n  \n  public PartiallyAnnotated2(int i)\n    //@ requires true;\n    //@ ensures  PartiallyAnnotatedClassPred2(i);\n  {\n    this.i = i;\n    //@ close PartiallyAnnotatedClassPred2(i);\n  }\n  \n  public int annotatedIncInterface2_1(int i)\n    //@ requires i \u003c 100;\n    //@ ensures result == i + 1;\n  {\n    return ++i;\n  }\n\n//   class NotAnnotatedClass2_2\n//   {\n//     private int x; \n// \n//     NotAnnotatedClass2_2(int i) {/*@ assert false; @*/x = i;}\n// \n//     int NotAnnotatedClass2_2_1(int i) {/*@ assert false; @*/return i;}\n//   }\n\n  public int NotAnnotatedIncInterface2(int i) \n  {\n    //@ assert false;\n    return ++i;\n  }\n\n  public int annotatedIncInterface2_2(int i)\n    //@ requires i \u003c 100;\n    //@ ensures result == i + 1;\n  {\n    return ++i;\n  }\n  \n  public int annotatedIncClass2(int i)\n    //@ requires i \u003c 100;\n    //@ ensures result == i + 1;\n  {\n    return ++i;\n  }\n}\n\nclass NotAnnotatedClass2_3\n{\n  private int x; \n\n  NotAnnotatedClass2_3(int i) {/*@ assert false; @*/x = i;}\n\n  int NotAnnotatedClass2_3_1(int i) {/*@ assert false; @*/return i;}\n}\n",
        "name": "PartiallyAnnotated2.java",
        "path": "examples/reduced_annotations/java_language/PartiallyAnnotated2.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/reduced_annotations/java_language/PartiallyAnnotated2.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 29,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires i \u003c 100;"
        },
        {
          "limitHit": false,
          "lineNumber": 30,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 51,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires i \u003c 100;"
        },
        {
          "limitHit": false,
          "lineNumber": 52,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 58,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires i \u003c 100;"
        },
        {
          "limitHit": false,
          "lineNumber": 59,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 22,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  PartiallyAnnotatedClassPred2(i);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class NotAnnotatedClass1_1\n{\n  private int x; \n\n  NotAnnotatedClass1_1(int i) {/*@ assert false; @*/x = i;}\n\n  int NotAnnotatedClass1_1_1(int i) {/*@ assert false; @*/return i;}\n}\n\npublic class PartiallyAnnotated1 implements PartiallyAnnotatedInterface1\n{\n  //@ predicate PartiallyAnnotatedClassPred1(int value) = this.i |-\u003e value;\n  \n  private int i;\n  \n  public PartiallyAnnotated1()\n  {\n    this.i = 0;\n  }\n  \n  public PartiallyAnnotated1(int i)\n    //@ requires true;\n    //@ ensures  PartiallyAnnotatedClassPred1(i);\n  {\n    this.i = i;\n    //@ close PartiallyAnnotatedClassPred1(i);\n  }\n  \n  public int annotatedIncInterface1_1(int i)\n    //@ requires i \u003c 100;\n    //@ ensures result == i + 1;\n  {\n    return ++i;\n  }\n\n//   class NotAnnotatedClass1_2\n//   {\n//     private int x; \n// \n//     NotAnnotatedClass1_3(int i) {/*@ assert false; @*/x = i;}\n// \n//     int NotAnnotatedClass1_3_1(int i) {/*@ assert false; @*/return i;}\n//   }\n\n  public int NotAnnotatedIncInterface1(int i) \n  {\n    //@ assert false;\n    PartiallyAnnotatedInterface2 o = new PartiallyAnnotated2();\n    return o.NotAnnotatedIncInterface2(i);\n  }\n\n  public int annotatedIncInterface1_2(int i)\n    //@ requires i \u003c 100;\n    //@ ensures result == i + 1;\n  {\n    return ++i;\n  }\n  \n  public int annotatedIncClass1(int i)\n    //@ requires i \u003c 100;\n    //@ ensures result == i + 1;\n  {\n    return ++i;\n  }\n}\n\nclass NotAnnotatedClass1_3\n{\n  private int x; \n\n  NotAnnotatedClass1_3(int i) {/*@ assert false; @*/x = i;}\n\n  int NotAnnotatedClass1_3_1(int i) {/*@ assert false; @*/return i;}\n}\n",
        "name": "PartiallyAnnotated1.java",
        "path": "examples/reduced_annotations/java_language/PartiallyAnnotated1.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/reduced_annotations/java_language/PartiallyAnnotated1.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 29,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires i \u003c 100;"
        },
        {
          "limitHit": false,
          "lineNumber": 30,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 52,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires i \u003c 100;"
        },
        {
          "limitHit": false,
          "lineNumber": 53,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 59,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires i \u003c 100;"
        },
        {
          "limitHit": false,
          "lineNumber": 60,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 22,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  PartiallyAnnotatedClassPred1(i);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class OuterClass \n{\n}\n\npublic class StaticMemberClass_desugared\n{   \n  public static void main(String[] args)    \n    //@ requires class_init_token(OuterClass$InnerClass.class);\n    //@ ensures true; \n  {\n    //@ init_class(OuterClass$InnerClass.class);\n    \n    OuterClass$InnerClass first = new OuterClass$InnerClass();\n    OuterClass$InnerClass second = new OuterClass$InnerClass();\n    first.setX(111);\n    int i = first.getX();\n    /*@ assert i == 111;@*/\n\n    first.setY(222);\n    int j = second.getY();\n    /*@ assert j == 222;@*/\n  }\n}\nclass OuterClass$InnerClass \n{  \n  //@ predicate OuterClass$InnerClass(int x) = this.x |-\u003e x;\n  \n  int x = 1;\n  static int y = 1;\n\n  OuterClass$InnerClass()\n    //@ requires true;\n    //@ ensures  OuterClass$InnerClass(1);\n  {\n    //@ close OuterClass$InnerClass(1);\n  }\n    \n  int getX()    \n    //@ requires OuterClass$InnerClass(?x);\n    //@ ensures OuterClass$InnerClass(x) \u0026*\u0026 result == x;\n  {\n    //@ open OuterClass$InnerClass(x);\n    return this.x;\n  }\n    \n  void setX(int i)    \n    //@ requires OuterClass$InnerClass(_);\n    //@ ensures OuterClass$InnerClass(i);\n  {\n    x = i;\n  }\n    \n  static int getY()    \n   //@ requires OuterClass$InnerClass_y(?y');\n   //@ ensures OuterClass$InnerClass_y(y') \u0026*\u0026 result == y'; \n  {\n    return y;\n  }\n    \n  static void setY(int i)    \n    //@ requires OuterClass$InnerClass_y(_);\n    //@ ensures OuterClass$InnerClass_y(i);\n  {\n    y = i;\n  }\n}\n",
        "name": "StaticMemberClass_desugared.java",
        "path": "examples/java/frontend/inner_class/StaticMemberClass_desugared.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/inner_class/StaticMemberClass_desugared.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires class_init_token(OuterClass$InnerClass.class);"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true; "
        },
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires OuterClass$InnerClass(?x);"
        },
        {
          "limitHit": false,
          "lineNumber": 39,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures OuterClass$InnerClass(x) \u0026*\u0026 result == x;"
        },
        {
          "limitHit": false,
          "lineNumber": 46,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires OuterClass$InnerClass(_);"
        },
        {
          "limitHit": false,
          "lineNumber": 47,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures OuterClass$InnerClass(i);"
        },
        {
          "limitHit": false,
          "lineNumber": 53,
          "offsetAndLengths": [
            [
              3,
              13
            ]
          ],
          "preview": "   //@ requires OuterClass$InnerClass_y(?y');"
        },
        {
          "limitHit": false,
          "lineNumber": 54,
          "offsetAndLengths": [
            [
              3,
              12
            ]
          ],
          "preview": "   //@ ensures OuterClass$InnerClass_y(y') \u0026*\u0026 result == y'; "
        },
        {
          "limitHit": false,
          "lineNumber": 60,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires OuterClass$InnerClass_y(_);"
        },
        {
          "limitHit": false,
          "lineNumber": 61,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures OuterClass$InnerClass_y(i);"
        },
        {
          "limitHit": false,
          "lineNumber": 32,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  OuterClass$InnerClass(1);"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package subpackage1.subsub1;\n\npublic class Number1_1\n{\n  static public int getNumber()\n    //@ requires true;\n    //@ ensures result == 11;\n  {\n    return 11;\n  }\n}\n",
        "name": "Number1_1.java",
        "path": "examples/java/frontend/many_files/subpackage1/subsub1/Number1_1.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/many_files/subpackage1/subsub1/Number1_1.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == 11;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package subpackage2.subsub1;\n\npublic class Number2_1\n{\n  public static int getNumber()\n    //@ requires true;\n    //@ ensures result == 21;\n  {\n    return 21;\n  }\n}\n",
        "name": "Number2_1.java",
        "path": "examples/java/frontend/many_files/subpackage2/subsub1/Number2_1.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/many_files/subpackage2/subsub1/Number2_1.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == 21;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package subpackage2.subsub2;\n\npublic class Number2_2\n{\n  public static int getNumber()\n    //@ requires true;\n    //@ ensures result == 22;\n  {\n    return 22;\n  }\n}\n",
        "name": "Number2_2.java",
        "path": "examples/java/frontend/many_files/subpackage2/subsub2/Number2_2.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/many_files/subpackage2/subsub2/Number2_2.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == 22;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package subpackage3.subsub1;\n\npublic class Number3_1\n{\n  public static int getNumber()\n    //@ requires true;\n    //@ ensures result == 31;\n  {\n    return 31;\n  }\n}\n",
        "name": "Number3_1.java",
        "path": "examples/java/frontend/many_files/subpackage3/subsub1/Number3_1.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/many_files/subpackage3/subsub1/Number3_1.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == 31;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package subpackage3.subsub2;\n\npublic class Number3_2\n{\n  public static int getNumber()\n    //@ requires true;\n    //@ ensures result == 32;\n  {\n    return 32;\n  }\n}\n",
        "name": "Number3_2.java",
        "path": "examples/java/frontend/many_files/subpackage3/subsub2/Number3_2.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/many_files/subpackage3/subsub2/Number3_2.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == 32;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package subpackage3.subsub3;\n\npublic class Number3_3\n{\n  public static int getNumber()\n    //@ requires true;\n    //@ ensures result == 33;\n  {\n    return 33;\n  }\n}\n",
        "name": "Number3_3.java",
        "path": "examples/java/frontend/many_files/subpackage3/subsub3/Number3_3.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/frontend/many_files/subpackage3/subsub3/Number3_3.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == 33;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class NotAnnotatedInterface1_1\n{\n  private int x; \n\n  NotAnnotatedInterface1_1(int i) {/*@ assert false; @*/x = i;}\n\n  int NotAnnotatedInterface1_1_1(int i) {/*@ assert false; @*/return i;}\n}\n\npublic interface PartiallyAnnotatedInterface1\n{\n  public int annotatedIncInterface1_1(int i);\n    //@ requires i \u003c 100;\n    //@ ensures result == i + 1;\n\n  public int NotAnnotatedIncInterface1(int i);\n\n  public int annotatedIncInterface1_2(int i);\n    //@ requires i \u003c 100;\n    //@ ensures result == i + 1;\n}\n\nclass NotAnnotatedInterface1_3\n{\n  private int x; \n\n  NotAnnotatedInterface1_3(int i) {/*@ assert false; @*/x = i;}\n\n  int NotAnnotatedInterface1_3_1(int i) {/*@ assert false; @*/return i;}\n}",
        "name": "PartiallyAnnotatedInterface1.java",
        "path": "examples/reduced_annotations/java_language/PartiallyAnnotatedInterface1.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/reduced_annotations/java_language/PartiallyAnnotatedInterface1.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires i \u003c 100;"
        },
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 18,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires i \u003c 100;"
        },
        {
          "limitHit": false,
          "lineNumber": 19,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class NotAnnotatedInterface2_1\n{\n  private int x; \n\n  NotAnnotatedInterface2_1(int i) {/*@ assert false; @*/x = i;}\n\n  int NotAnnotatedInterface2_1_1(int i) {/*@ assert false; @*/return i;}\n}\n\npublic interface PartiallyAnnotatedInterface2\n{\n  public int annotatedIncInterface2_1(int i);\n    //@ requires i \u003c 100;\n    //@ ensures result == i + 1;\n\n//   class NotAnnotatedInterface2_2\n//   {\n//     private int x; \n// \n//     NotAnnotatedInterface2_2(int i) {/*@ assert false; @*/x = i;}\n// \n//     int NotAnnotatedInterface2_2_1(int i) {/*@ assert false; @*/return i;}\n//   }\n\n  public int NotAnnotatedIncInterface2(int i);\n\n  public int annotatedIncInterface2_2(int i);\n    //@ requires i \u003c 100;\n    //@ ensures result == i + 1;\n}\n\nclass NotAnnotatedInterface2_3\n{\n  private int x; \n\n  NotAnnotatedInterface2_3(int i) {/*@ assert false; @*/x = i;}\n\n  int NotAnnotatedInterface2_3_1(int i) {/*@ assert false; @*/return i;}\n}\n",
        "name": "PartiallyAnnotatedInterface2.java",
        "path": "examples/reduced_annotations/java_language/PartiallyAnnotatedInterface2.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/reduced_annotations/java_language/PartiallyAnnotatedInterface2.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires i \u003c 100;"
        },
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires i \u003c 100;"
        },
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures result == i + 1;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class C {\r\n    void m()\r\n        //@ requires true;\r\n        //@ ensures false;\r\n    {\r\n        throw null;\r\n    }\r\n}\r\n\r\nclass D extends C {\r\n    D()\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {}\r\n    \r\n    void m()\r\n        //@ requires false; //~ should_fail\r\n        //@ ensures false;\r\n    {\r\n    }\r\n}\r\n\r\nclass Program {\r\n    public static void main(String[] args)\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        D d = new D();\r\n        C c = d;\r\n        c.m();\r\n        assert false;\r\n    }\r\n}",
        "name": "override.java",
        "path": "tests/errors/override.java",
        "url": "/github.com/verifast/verifast/-/blob/tests/errors/override.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 2,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures false;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires false; //~ should_fail\r"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures false;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 24,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 25,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class C {\r\n    void m()\r\n        //@ requires true;\r\n        //@ ensures false;\r\n    {\r\n        //@ assume (false);\r\n    }\r\n}\r\n\r\nclass D extends C {\r\n    void m()\r\n        //@ requires this.getClass() == D.class;\r\n        //@ ensures false;\r\n    {\r\n        if (this.getClass() == D.class)\r\n        {\r\n            throw new RuntimeException();\r\n        }\r\n    }\r\n}\r\n\r\nclass E extends D { //~ should_fail\r\n    E()\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n    }\r\n}\r\n\r\nclass Program {\r\n    static void main(String[] args)\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        E e = new E();\r\n        /*\r\n        C c = e;\r\n        c.m();\r\n        assert false;\r\n        */\r\n    }\r\n}",
        "name": "override2.java",
        "path": "tests/errors/override2.java",
        "url": "/github.com/verifast/verifast/-/blob/tests/errors/override2.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 2,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures false;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires this.getClass() == D.class;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures false;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 23,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 24,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 32,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "interface I {\r\n    void m();\r\n        //@ requires true;\r\n        //@ ensures false;\r\n}\r\n\r\nclass D implements I {\r\n    D()\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {}\r\n    \r\n    void m()\r\n        //@ requires false; //~ should_fail\r\n        //@ ensures false;\r\n    {\r\n    }\r\n}\r\n\r\nclass Program {\r\n    public static void main(String[] args)\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        D d = new D();\r\n        I i = d;\r\n        i.m();\r\n        assert false;\r\n    }\r\n}",
        "name": "override3.java",
        "path": "tests/errors/override3.java",
        "url": "/github.com/verifast/verifast/-/blob/tests/errors/override3.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 2,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures false;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 9,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires false; //~ should_fail\r"
        },
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures false;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 22,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class C {\r\n    C()\r\n        //@ requires false;\r\n        //@ ensures true;\r\n    {\r\n        assert false;\r\n    }\r\n}\r\n\r\nclass D extends C {\r\n    D()  //~ should_fail\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n    }\r\n}\r\n\r\nclass Program {\r\n    static void main(String[] args)\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        D d = new D();\r\n    }\r\n}",
        "name": "superctor.java",
        "path": "tests/errors/superctor.java",
        "url": "/github.com/verifast/verifast/-/blob/tests/errors/superctor.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 2,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires false;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 19,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 20,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "\n/*@\npredicate_family predfam(Class c)(option\u003cboolean\u003e y; option\u003cboolean\u003e z);\n@*/\n\n/*@\npredicate_family_instance predfam(A)(option\u003cboolean\u003e x, option\u003cboolean\u003e y) = y == none;\npredicate_family_instance predfam(B)(option\u003cboolean\u003e x, option\u003cboolean\u003e y) = y == some(true);\n@*/\npublic abstract class A {\n  \n  public abstract void m();\n    // note the (atypical) A.class. z3 gives a type error (crashes VeriFast).\n    //@ requires exists\u003coption\u003cboolean \u003e \u003e(?t1) \u0026*\u0026 predfam(A.class)(t1, ?t2);\n    //@ ensures true;\n}\n\n\npublic class B extends A {\n\n  public void m()\n    //@ requires exists\u003coption\u003cboolean \u003e \u003e(?t1) \u0026*\u0026 predfam(B.class)(t1, ?t2);\n    //@ ensures true;\n  {\n  }   \n  \n}\n",
        "name": "z3-type-error.java",
        "path": "tests/bugs/z3-type-error.java",
        "url": "/github.com/verifast/verifast/-/blob/tests/bugs/z3-type-error.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires exists\u003coption\u003cboolean \u003e \u003e(?t1) \u0026*\u0026 predfam(A.class)(t1, ?t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 14,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires exists\u003coption\u003cboolean \u003e \u003e(?t1) \u0026*\u0026 predfam(B.class)(t1, ?t2);"
        },
        {
          "limitHit": false,
          "lineNumber": 22,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Test {\n\n  static void test(int[] xs)\n    //@ requires [_]xs[..1] |-\u003e _;\n    //@ ensures true;\n  {\n    xs[0] = 42; //~should_fail\n  }\n\n}\n",
        "name": "array_update.java",
        "path": "tests/errors/array_update.java",
        "url": "/github.com/verifast/verifast/-/blob/tests/errors/array_update.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires [_]xs[..1] |-\u003e _;"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Test {\r\n    int x;\r\n\r\n    Test()\r\n        //@ requires true;\r\n        //@ ensures x |-\u003e 0;\r\n    {\r\n    }\r\n\r\n    int foo(int a)\r\n        //@ requires x |-\u003e ?v \u0026*\u0026 v == a;\r\n        //@ ensures x |-\u003e v + 1 \u0026*\u0026 result == v + 1;\r\n    {\r\n        x++;\r\n        return x;\r\n    }\r\n\r\n    static void bar(int a, int b)\r\n        //@ requires a == 1 \u0026*\u0026 b == 2;\r\n        //@ ensures true;\r\n    {\r\n    }\r\n\r\n    static void test()\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        Test t = new Test();\r\n        bar(t.foo(0), t.foo(1));\r\n        //@ assert t.x |-\u003e 2;\r\n    }\r\n}",
        "name": "NestedExprTest.java",
        "path": "examples/java/NestedExprTest.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/NestedExprTest.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures x |-\u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires x |-\u003e ?v \u0026*\u0026 v == a;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures x |-\u003e v + 1 \u0026*\u0026 result == v + 1;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 18,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires a == 1 \u0026*\u0026 b == 2;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 19,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 24,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 25,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class B\u003cE\u003e{}\nclass Bar\u003cT\u003e extends B\u003cInteger\u003e{}\nclass Foo\u003cT\u003e extends B\u003cBoolean\u003e{}\n\npublic class Test3{\n    \n    public void test2()\n    //@ requires true;\n    //@ ensures true;\n    {\n    \tBoolean boola = new Boolean(false);\n\t\tInteger inta = new Integer(3);\n\t\tInteger intb = new Integer(5);\n    \tInteger infer2IntShouldFail = infer2(inta, intb, boola, boola); //~\n    }\n\n    public static \u003cT\u003e T infer2(T arg1, T arg2, Object arg3, Integer arg4)\n\t//@requires true;\n\t//@ensures true;\n\t{\n        \treturn arg1;\n\t}\n}",
        "name": "Test3.java",
        "path": "tests/java/generics/errors/Test3.java",
        "url": "/github.com/verifast/verifast/-/blob/tests/java/generics/errors/Test3.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 8,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Program {\n\n  public static void test(int[] xs)\n    //@ requires array_slice(xs, 0, 10, _);\n    //@ ensures array_slice(xs, 3, 2, _); //~should_fail\n  {\n  }\n\n}\n",
        "name": "array_slice_autosplit.java",
        "path": "tests/errors/array_slice_autosplit.java",
        "url": "/github.com/verifast/verifast/-/blob/tests/errors/array_slice_autosplit.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires array_slice(xs, 0, 10, _);"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures array_slice(xs, 3, 2, _); //~should_fail"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import java.util.*;\n\npublic class GenericClass\u003cT\u003e {\n    public T t;\n\t\n    public static void main(String[] args)\n    //@ requires true;\n    //@ ensures true;\n    {\n        GenericClass\u003cInteger\u003e gi = new GenericClass\u003c \u003e();\n        Integer i = gi.t;\n        ArrayList\u003cInteger\u003e arrayInt = new ArrayList\u003c \u003e();\n        Foo\u003cInteger\u003e fooI = new Foo\u003c \u003e();\n        ArrayList\u003cInteger\u003e ai = fooI.t;\n    }\n}\n\nclass Foo\u003cU\u003e extends GenericClass\u003cArrayList\u003cU\u003e \u003e {}\n\n",
        "name": "CorrectFieldTypes.java",
        "path": "tests/java/generics/CorrectFieldTypes.java",
        "url": "/github.com/verifast/verifast/-/blob/tests/java/generics/CorrectFieldTypes.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class SelfCall {\n\n    static void foo()\n        //@ requires true;\n        //@ ensures true;\n        //@ terminates;\n    {\n        foo(); //~ should_fail\n    }\n\n}\n\n",
        "name": "SelfCall.java",
        "path": "examples/java/termination/tests/SelfCall.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/termination/tests/SelfCall.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Bar {\n\n    static void bar()\n        //@ requires true;\n        //@ ensures true;\n        //@ terminates;\n    {\n        Baz.baz(); //~ should_fail\n    }\n    \n}\n\nclass Baz {\n\n    static void baz()\n        //@ requires true;\n        //@ ensures true;\n        //@ terminates;\n    {\n        Bar.bar();\n    }\n\n}\n",
        "name": "MutualCall2.java",
        "path": "examples/java/termination/tests/MutualCall2.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/termination/tests/MutualCall2.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class MutualCall {\n\n    static void bar()\n        //@ requires true;\n        //@ ensures true;\n        //@ terminates;\n    {\n        baz(); //~ should_fail\n    }\n    \n    static void baz()\n        //@ requires true;\n        //@ ensures true;\n        //@ terminates;\n    {\n        bar();\n    }\n\n}\n",
        "name": "MutualCall1.java",
        "path": "examples/java/termination/tests/MutualCall1.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/termination/tests/MutualCall1.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Foo {\n    \n    Foo()\n        //@ requires true;\n        //@ ensures true;\n        //@ terminates;\n    {\n        new Foo(); //~ should_fail\n    }\n\n}\n",
        "name": "CtorSelfCall.java",
        "path": "examples/java/termination/tests/CtorSelfCall.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/termination/tests/CtorSelfCall.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "import java.util.Arrays;\n\npublic class QualifiedGenericMethodCall {\n\n\tpublic static \u003cT,V\u003e V usefulMethod(T arg, V arg2)\n\t//@ requires true;\n\t//@ ensures true;\n\t{\n\t\treturn arg2;\n\t}\n\t\n\tpublic static void main(String[] args) \n\t//@ requires true;\n\t//@ ensures true;\n\t{\n\t\t// Qualified call to static parameterised method:\n\t\t// Type arguments explicitly provided.\n\t\tInteger[] a = {new Integer(1), new Integer(2)};\n\t\tBoolean b = new Boolean(true);\n\t\tQualifiedGenericMethodCall.\u003cInteger[], Boolean\u003eusefulMethod(a, b);\n\t\t\n\t\tInteger c = new Integer(3);\n\t\t\n\t\tBar myBar = new Bar();\n\t\tmyBar.\u003cInteger, Boolean\u003efoo(c,b);\n\t}\n}\n\npublic class Bar {\n    public \u003cT\u003e void foo(Integer x, T y) \n    //@ requires true;\n    //@ ensures true;\n    {  \n    \tthis.\u003cInteger, T\u003efoo(x,y);\n    }\n    public \u003cT, U\u003e void foo(T x, U y)\n    //@ requires true;\n    //@ ensures true;\n    {  }\n}",
        "name": "QualifiedGenericMethodCall.java",
        "path": "tests/java/generics/QualifiedGenericMethodCall.java",
        "url": "/github.com/verifast/verifast/-/blob/tests/java/generics/QualifiedGenericMethodCall.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 30,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 36,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 37,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 5,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 13,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class Foo {\n    \n    Foo()\n        //@ requires true;\n        //@ ensures true;\n        //@ terminates;\n    {\n        new Bar(); //~ should_fail\n    }\n\n}\n\nclass Bar {\n\n    Bar()\n        //@ requires true;\n        //@ ensures true;\n        //@ terminates;\n    {\n        new Foo();\n    }\n\n}",
        "name": "MutualCtorCall.java",
        "path": "examples/java/termination/tests/MutualCtorCall.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/termination/tests/MutualCtorCall.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "class SimpleTermination {\n\n    static void foo()\n        //@ requires true;\n        //@ ensures true;\n        //@ terminates;\n    {\n        for (int i = 0; i \u003c 10; i++)\n            //@ invariant true;\n            //@ decreases 10 - i;\n        {\n        }\n    }\n\n    static void bar()\n        //@ requires true;\n        //@ ensures true;\n        //@ terminates;\n    {\n        for (int i = 0; i \u003c 10; i++)\n            //@ invariant true;\n            //@ decreases 10 - i;\n        {\n            foo();\n        }\n    }\n    \n}\n\nclass AnotherClass {\n\n    AnotherClass()\n        //@ requires true;\n        //@ ensures true;\n        //@ terminates;\n    {}\n\n    static void quux()\n        //@ requires true;\n        //@ ensures true;\n        //@ terminates;\n    {\n        SimpleTermination.bar();\n    }\n\n}\n\nclass Foo {\n\n    void bar()\n        //@ requires true;\n        //@ ensures true;\n        //@ terminates;\n    {\n        AnotherClass anotherClass = new AnotherClass();\n    }\n\n    static void foo()\n        //@ requires true;\n        //@ ensures true;\n        //@ terminates;\n    {\n        Foo foo = new Foo(); // Default constructor is declared as 'terminates'.\n        //foo.bar(); //TODO: allow this\n    }\n\n}",
        "name": "SimpleTermination.java",
        "path": "examples/java/termination/tests/SimpleTermination.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/termination/tests/SimpleTermination.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 15,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 16,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 32,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 33,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 39,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 50,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 51,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 58,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 59,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "/* Error scenario of combining lemma pointers and nonghostcallers_only in Java */\n\n\n/*@\ntypedef lemma void empty_t();\nrequires true;\nensures true;\n\nlemma void empty()\nrequires true;\nensures true;\n{\n}\n\nlemma void normal_lemma()\nrequires true;\nensures true;\n{\n}\n\nlemma void nonghost_only_lemma()\nnonghost_callers_only\nrequires true;\nensures true;\n{\n}\n@*/\n\nclass CallNonghost{\n  public void m()\n  //@ requires true;\n  //@ ensures true;\n  {\n    /*@\n         produce_lemma_function_pointer_chunk(empty) : empty_t()()\n                {\n                    normal_lemma(); // can call preceding lemmas.\n                    nonghost_only_lemma(); //~   \u003c-- must fail\n                    //call();\n                    //normal_lemma();\n                }\n                {\n                    //nonghost_only_lemma();\n                }\n    @*/\n  }\n}",
        "name": "CallNonghost.java",
        "path": "tests/lemma_ptrs_with_nonghostcallersonly/CallNonghost.java",
        "url": "/github.com/verifast/verifast/-/blob/tests/lemma_ptrs_with_nonghostcallersonly/CallNonghost.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 30,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "/* Sunny day scenario of combining lemma pointers and nonghostcallers_only in Java */\n\n\n/*@\ntypedef lemma void empty_t();\nrequires true;\nensures true;\n\nlemma void empty()\nrequires true;\nensures true;\n{\n}\n\nlemma void normal_lemma()\nrequires true;\nensures true;\n{\n}\n\nlemma void nonghost_only_lemma()\nnonghost_callers_only\nrequires true;\nensures true;\n{\n}\n@*/\n\nclass SunnyDayScenario{\n  public void m()\n  //@ requires true;\n  //@ ensures true;\n  {\n    /*@\n         produce_lemma_function_pointer_chunk(empty) : empty_t()()\n                {\n                    normal_lemma(); // can call preceding lemmas.\n                    call();\n                    normal_lemma();\n                }\n                {\n                    nonghost_only_lemma();\n                }\n    @*/\n  }\n}",
        "name": "SunnyDayScenario.java",
        "path": "tests/lemma_ptrs_with_nonghostcallersonly/SunnyDayScenario.java",
        "url": "/github.com/verifast/verifast/-/blob/tests/lemma_ptrs_with_nonghostcallersonly/SunnyDayScenario.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 30,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "package tree;\r\n\r\n/*@\r\npredicate tree(Tree t,bintree b) =\r\n  switch(b){\r\n    case tnil: return t==null;\r\n    case tcons(a,bl,br): return t.value |-\u003e ?v \u0026*\u0026 t.left |-\u003e ?l \u0026*\u0026 t.right |-\u003e ?r\r\n\t\t\t\u0026*\u0026 tree(l,bl) \u0026*\u0026 tree(r,br) \u0026*\u0026 t!=null \u0026*\u0026 a==v ;\r\n  }\u0026*\u0026 inorder(b)==true;\r\n\r\ninductive bintree = |tnil |tcons(int,bintree,bintree);\r\n\r\nfixpoint boolean t_contains(bintree b, int v) {\r\n  switch (b) {\r\n    case tnil: return false;\r\n    case tcons(a,l,r): return (a==v ? true: (v \u003c a? t_contains(l,v):t_contains(r,v)));\r\n  }\r\n}\r\nfixpoint bintree tree_add(bintree b, int x) {\r\n  switch (b) {\r\n    case tnil: return tcons(x,tnil,tnil);\r\n    case tcons(v,l,r): return x \u003c v? tcons(v,tree_add(l,x),r):\r\n\t\t\t(x==v? tcons(v,l,r):tcons(v,l,tree_add(r,x)));\r\n  }\r\n}\r\nfixpoint int max(bintree b){\r\n  switch(b){\r\n    case tcons(a,bl,br): return (br==tnil? a:max(br));\r\n    case tnil: return 0;\r\n  }\r\n}\r\nfixpoint int min(bintree b){\r\n  switch(b){\r\n    case tcons(a,bl,br): return (bl==tnil? a:min(bl));\r\n    case tnil: return 0;\r\n  }\r\n}\r\nfixpoint bintree tree_rem(bintree b, int x) {\r\n  switch (b) {\r\n    case tcons(v,l,r): return l==tnil\u0026\u0026r==tnil\u0026\u0026x==v? tnil:\r\n\t\t\t(x==v\u0026\u0026l==tnil? r:\r\n\t\t\t(x==v\u0026\u0026r==tnil? l:\r\n\t\t\t(x==v? tcons(max(l),tree_rem(l,max(l)),r):\r\n\t\t\tx \u003c v? tcons(v,tree_rem(l,x),r):tcons(v,l,tree_rem(r,x)) ))) ;\r\n    case tnil: return tnil;\r\n  }\r\n}\r\nfixpoint boolean inorder(bintree b){\r\n  switch(b){\r\n\tcase tnil: return true;\r\n\tcase tcons(a,bl,br): return (bl==tnil? true:max(bl) \u003c a)\u0026\u0026 (br==tnil? true: a \u003c min(br))\r\n\t\t\u0026\u0026 inorder(bl) \u0026\u0026 inorder(br);\r\n  }\r\n}\r\nlemma void min_le_max(bintree b)\r\n  requires inorder(b)==true \u0026*\u0026 b!=tnil;\r\n  ensures min(b)\u003c=max(b);\r\n{\r\n  switch(b){\r\n        case tnil:\r\n\tcase tcons(v,l,r):if(l!=tnil||r!=tnil){\r\n\t\t\t   if(l==tnil){\r\n\t\t\t     min_le_max(r);\r\n\t\t\t   }else{\r\n\t\t\t     if(r!=tnil){\r\n\t\t\t       min_le_max(r);\r\n\t\t\t     }\r\n\t\t\t     min_le_max(l);\r\n\t\t\t   }\r\n\t\t\t}\r\n  }\r\n}\r\nlemma void contains_max(bintree r)\r\n  requires r!=tnil \u0026\u0026 inorder(r)==true;\r\n  ensures t_contains(r,max(r))==true;\r\n{\r\n  switch(r){\r\n\tcase tnil:\r\n\tcase tcons(a,b,c):if(c!=tnil){\r\n\t\t\t   min_le_max(c);\r\n\t\t\t   contains_max(c);\r\n\t\t\t }\r\n  }\r\n}\r\nlemma void contains_min(bintree r)\r\n  requires r!=tnil \u0026*\u0026 inorder(r)==true;\r\n  ensures t_contains(r,min(r))==true;\r\n{\r\n  switch(r){\r\n\tcase tnil:\r\n\tcase tcons(a,b,c):if(b!=tnil){\r\n\t\t\t min_le_max(b);\r\n\t\t\t contains_min(b);\r\n\t\t\t }\r\n  }\r\n}\r\nlemma void max_conj_add(bintree l,int v,int x)\r\n  requires x \u003c v \u0026*\u0026 (max(l) \u003c v||l==tnil) \u0026*\u0026 inorder(l)==true;\r\n  ensures max(tree_add(l,x)) \u003c v \u0026*\u0026 inorder(l)==true;\r\n{\r\n  switch(l){\r\n\tcase tnil:\r\n\tcase tcons(a,b,c):if(x \u003c a){\r\n\t\t\t  max_conj_add(b,a,x);\r\n\t\t\t }\r\n\t\t\t if(a \u003c x){\r\n\t\t\t  max_conj_add(c,v,x);\r\n\t\t\t }\r\n  }\r\n}\r\nlemma void min_conj_add(bintree r,int v,int x)\r\n  requires v \u003c x \u0026*\u0026 (v \u003c min(r)||r==tnil) \u0026*\u0026 inorder(r)==true;\r\n  ensures v \u003c min(tree_add(r,x)) \u0026*\u0026 inorder(r)==true;\r\n{\r\n  switch(r){\r\n\tcase tnil:\r\n\tcase tcons(a,b,c):if(a \u003c x){\r\n\t\t\t  min_conj_add(c,a,x);\r\n\t\t\t }\r\n\t\t\t if(x \u003c a){\r\n\t\t\t  min_conj_add(b,v,x);\r\n\t\t\t }\r\n  }\r\n}\r\nlemma void max_conj_rem(bintree l,int v,int x)\r\n  requires x \u003c v \u0026*\u0026 (max(l) \u003c v||l==tnil) \u0026*\u0026 inorder(l)==true;\r\n  ensures (max(tree_rem(l,x)) \u003c v||tree_rem(l,x)==tnil) \u0026*\u0026 inorder(l)==true;\r\n{\r\n  switch(l){\r\n\tcase tnil:\r\n\tcase tcons(a,b,c):if(x \u003c a){\r\n\t\t\t  max_conj_rem(b,a,x);\r\n\t\t\t }\r\n\t\t\t if(a \u003c x){\r\n\t\t\t  max_conj_rem(c,v,x);\r\n\t\t\t }\r\n  }\r\n}\r\n\r\nlemma void tree_add_inorder(bintree b, int x)\r\n    requires inorder(b)==true \u0026*\u0026 t_contains(b,x)==false;\r\n    ensures inorder(tree_add(b,x))==true \u0026*\u0026 t_contains(tree_add(b,x),x)==true;\r\n{\r\n    switch (b) {\r\n        case tnil:\r\n        case tcons(v,l,r):if(x \u003c v){\r\n\t\t\t  max_conj_add(l,v,x);\r\n\t\t\t  tree_add_inorder(l,x);\r\n\t\t\t }\r\n\t\t\t if(v \u003c x){\r\n\t\t\t  min_conj_add(r,v,x);\r\n\t\t\t  tree_add_inorder(r,x);\r\n\t\t  \t }\r\n    }\r\n}\r\nlemma void min_all(bintree r,int x)\r\n  requires t_contains(r,x)==true \u0026*\u0026 inorder(r)==true;\r\n  ensures min(r)\u003c=x;\r\n{\r\n  switch(r){\r\n\tcase tnil:\r\n\tcase tcons(a,b,c):if(b!=tnil){\r\n\t\t\t   contains_max(b);\r\n\t\t\t   min_all(b,max(b));\r\n\t\t\t }\r\n\t\t\t if(t_contains(b,x)){\r\n\t\t\t   min_all(b,x);\r\n\t\t\t }\r\n  }\r\n}\r\nlemma void max_all(bintree r,int x)\r\n  requires inorder(r)==true \u0026*\u0026 t_contains(r,x)==true \u0026*\u0026 x!=max(r);\r\n  ensures x \u003c max(r);\r\n{\r\n  switch(r){\r\n\tcase tnil:\r\n\tcase tcons(a,b,c):if(c!=tnil){\r\n\t\t\t   contains_min(c);\r\n\t\t\t   min_le_max(c);\r\n\t\t\t }\r\n\t\t\t if(t_contains(c,x)){\r\n\t\t\t   max_all(c,x);\r\n\t\t\t }\r\n  }\r\n}\r\nlemma void min_conj_rem(bintree r,int v,int x)\r\n  requires v \u003c x \u0026*\u0026 (v \u003c min(r)||r==tnil) \u0026*\u0026 inorder(r)==true;\r\n  ensures (v \u003c min(tree_rem(r,x))||tree_rem(r,x)==tnil) \u0026*\u0026 inorder(r)==true;\r\n{\r\n  switch(r){\r\n\tcase tnil:\r\n\tcase tcons(a,b,c):if(a \u003c x){\r\n\t\t\t  min_conj_rem(c,a,x);\r\n\t\t\t }\r\n\t\t\t if(x \u003c a){\r\n\t\t\t  min_conj_rem(b,v,x);\r\n\t\t\t }\r\n\t\t\t if(b!=tnil\u0026\u0026c!=tnil){\r\n\t\t\t  contains_max(b);\r\n\t\t\t  min_all(b,max(b));\r\n\t\t\t  min_conj_rem(b,v,max(b));\r\n\t\t\t }\r\n  }\r\n}\r\nlemma void contains_rem_max(bintree b)\r\n  requires inorder(b)==true \u0026*\u0026 b!=tnil \u0026*\u0026 tree_rem(b,max(b))!=tnil \u0026*\u0026 inorder(tree_rem(b,max(b)))==true;\r\n  ensures t_contains(b,max(tree_rem(b,max(b))))==true;\r\n{\r\n  switch (b) {\r\n        case tnil:\r\n        case tcons(v,l,r):if(l==tnil||r!=tnil){\r\n\t\t\t   if(tree_rem(r,max(r))==tnil){\r\n\t\t\t     min_le_max(r);\r\n\t\t  \t     contains_max(tree_rem(b,max(b)));\r\n\t\t\t   }else{\r\n\t\t\t     min_le_max(r);\r\n\t\t\t     if(v!=max(tree_rem(b,max(b)))){\r\n\t\t\t       max_all(tree_rem(b,max(b)),v);\r\n\t\t\t     }\r\n\t\t\t     contains_rem_max(r);\r\n\t\t\t   }\r\n\t\t\t }else{\r\n\t\t\t   contains_max(tree_rem(b,max(b)));\r\n\t\t\t }\r\n  }\r\n}\r\nlemma void tree_rem_inorder(bintree b, int x)\r\n    requires inorder(b)==true \u0026*\u0026 t_contains(b,x)==true;\r\n    ensures inorder(tree_rem(b,x))==true\u0026*\u0026 t_contains(tree_rem(b,x),x)==false;\r\n{\r\n    switch (b) {\r\n        case tnil:\r\n        case tcons(v,l,r):if(x \u003c v){\r\n\t\t\t  max_conj_rem(l,v,x);\r\n\t\t\t  tree_rem_inorder(l,x);\r\n\t\t\t }\r\n\t\t  \t if(v \u003c x){\r\n\t\t\t  min_conj_rem(r,v,x);\r\n\t\t\t  tree_rem_inorder(r,x);\r\n\t\t\t }\r\n\t\t\t if(x==v){\r\n\t\t\t\tif(l==tnil \u0026\u0026 r!=tnil){\r\n\t\t\t\t\tif(t_contains(r,x)==false){\r\n\t\t\t\t\t  contains_min(r);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t  min_all(r,x);\r\n\t\t\t\t\t}\r\n\t\t\t\t}if(r==tnil\u0026\u0026l!=tnil){\r\n\t\t\t\t\tif(t_contains(l,x)==false){\r\n\t\t\t\t\t  contains_min(l);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t  max_all(l,x);\r\n\t\t\t\t\t}\r\n\t\t\t\t}if(r!=tnil\u0026\u0026l!=tnil){\r\n\t\t\t\t   if(tree_rem(l,max(l))!=tnil){\r\n\t\t\t\t     contains_max(l);\r\n\t\t\t\t     tree_rem_inorder(l,max(l));\r\n\t\t\t\t     contains_rem_max(l);\r\n\t\t\t\t     if(max(l)!=max(tree_rem(l,max(l)))){\r\n\t\t\t\t       max_all(l,max(tree_rem(l,max(l))));\r\n\t\t\t\t       if(t_contains(r,x)==false){\r\n\t\t\t\t         contains_min(r);\r\n\t\t\t\t       }else{\r\n\t\t\t\t         min_all(r,x);\r\n\t\t\t\t       }\r\n\t\t\t\t     }else{\r\n\t\t\t\t       contains_max(tree_rem(l,max(l)));\r\n\t\t\t\t     }\r\n\t\t\t\t   }else{\r\n\t\t\t\t     if(t_contains(r,x)==false){\r\n\t\t\t\t       contains_min(r);\r\n\t\t\t\t     }else{\r\n\t\t\t\t       min_all(r,x);\r\n\t\t\t\t     }\r\n\t\t\t\t   }\t\r\n\t\t\t    }\r\n\t\t  \t}\r\n  }\r\n}\r\n@*/\r\npublic class Tree{\r\n\tpublic int value;\r\n\tpublic Tree left;\r\n\tpublic Tree right;\r\n\r\n\tpublic Tree(int x)\r\n\t//@ requires true;\r\n\t//@ ensures tree(this,tcons(x,tnil,tnil));\r\n\t{\r\n\t    \tthis.value=x;\r\n\t\tthis.left=null;\r\n\t\tthis.right=null;\r\n\t\t//@ Tree l = this.left;\r\n\t\t//@ close tree(l,tnil);\r\n\t\t//@ Tree r = this.right;\r\n\t\t//@ close tree(r,tnil);\r\n\t\t//@ close tree(this,tcons(x,tnil,tnil));\r\n\t}\r\n\tpublic boolean contains(int x)\r\n\t//@ requires tree(this,?b);\r\n\t//@ ensures tree(this,b) \u0026*\u0026 result==t_contains(b,x);\r\n\t{\r\n\t\t//@ open tree(this,b);\r\n\t\tint v=this.value;\r\n\t\tTree l=this.left;\r\n\t\tTree r=this.right;\r\n\t\tif(v==x){\r\n\t\t\t//@close tree(this,b);\r\n\t\t\treturn true;\r\n\t\t}else{\r\n\t\t\tif(x \u003c v){\r\n\t\t\t\tboolean temp1=false;\r\n\t\t\t\tif(l != null) {\r\n\t\t\t\t  temp1 = l.contains(x);\r\n\t\t\t\t} else {\r\n\t\t\t\t  //@ open tree(l, ?lv);\r\n\t\t\t\t  //@ close tree(l, lv);\r\n\t\t\t\t}\r\n\t\t\t\t//@close tree(this,b);\r\n\t\t\t\treturn temp1;\r\n\t\t\t}else{\r\n\t\t\t\tboolean temp2=false;\r\n\t\t\t\tif(r != null) {\r\n\t\t\t\t  temp2 = r.contains(x);\r\n\t\t\t\t} else {\r\n\t\t\t\t  //@ open tree(r, ?rv);\r\n\t\t\t\t  //@ close tree(r, rv);\r\n\t\t\t\t}\r\n\t\t\t\t//@close tree(this,b);\r\n\t\t\t\treturn temp2;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tpublic void add(int x)\r\n\t//@ requires tree(this,?b) \u0026*\u0026 b!=tnil \u0026*\u0026 false==t_contains(b,x) \u0026*\u0026 inorder(b)==true;\r\n\t//@ ensures tree(this,tree_add(b,x)) \u0026*\u0026 inorder(tree_add(b,x))==true;\r\n\t{\r\n\t\t//@ open tree(this,b);\r\n\t\tint v=this.value;\r\n\t\tTree l=this.left;\r\n\t\t//@ open tree(l,?bl);\r\n\t\t//@ close tree(l,bl);\r\n\t\tTree r=this.right;\r\n\t\t//@ open tree(r,?br);\r\n\t\t//@ close tree(r,br);\r\n\t\tif(x \u003c v){\r\n\t\t\tif(l!=null){\r\n\t\t\t\tl.add(x);\r\n\t\t\t\t//@ tree_add_inorder(b,x);\r\n\t\t\t\t//@ close tree(this,tcons(v,tree_add(bl,x),br));\r\n\t\t\t}else{\r\n\t\t\t\tTree temp=new Tree(x);\r\n\t\t\t\tthis.left=temp;\r\n\t\t\t\t//@ open tree(l,bl);\r\n\t\t\t\t//@ close tree(this,tcons(v,tcons(x,tnil,tnil),br));\r\n\t\t\t\t//@ tree_add_inorder(b,x);\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tif(v \u003c x){\r\n\t\t\t\tif(r!=null){\r\n\t\t\t\t\tr.add(x);\r\n\t\t\t\t\t//@ tree_add_inorder(b,x);\r\n\t\t\t\t\t//@ close tree(this,tcons(v,bl,tree_add(br,x)));\t\r\n\t\t\t\t}else{\r\n\t\t\t\t\tTree temp=new Tree(x);\r\n\t\t\t\t\tthis.right=temp;\r\n\t\t\t\t\t//@ open tree(r,br);\r\n\t\t\t\t\t//@ close tree(this,tcons(v,bl,tcons(x,tnil,tnil)));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tpublic int maximum()\r\n\t//@ requires tree(this,?b) \u0026*\u0026 b!=tnil \u0026*\u0026 inorder(b)==true;\r\n\t//@ ensures result==max(b) \u0026*\u0026 tree(this,b);\r\n\t{\r\n\t\t//@ open tree(this,b);\r\n\t\tint v=this.value;\r\n\t\tTree r=this.right;\r\n\t\t//@ open tree(r,?br);\r\n\t\t//@ close tree(r,br);\r\n\t\tif(r==null){\r\n\t\t\t//@ close tree(this,b);\r\n\t\t\treturn v;\r\n\t\t}else{\r\n\t\t\tint m= r.maximum();\r\n\t\t\t//@ close tree(this,b);\r\n\t\t\treturn m;\r\n\t\t}\r\n\t}\r\n\tpublic Tree remove(int x)\r\n\t//@ requires tree(this,?b) \u0026*\u0026 b!=tnil \u0026*\u0026 true==t_contains(b,x)  \u0026*\u0026 inorder(b)==true;\r\n\t//@ ensures tree(result,tree_rem(b,x))\u0026*\u0026 inorder(tree_rem(b,x))==true \u0026*\u0026 false==t_contains(tree_rem(b,x),x);\r\n\t{\r\n\t\t//@ open tree(this,b);\r\n\t\tint v=this.value;\r\n\t\tTree l=this.left;\r\n\t\t//@ open tree(l,?bl);\r\n\t\t//@ close tree(l,bl);\r\n\t\tTree r=this.right;\r\n\t\t//@ open tree(r,?br);\r\n\t\t//@ close tree(r,br);\r\n\t\t//@ tree_rem_inorder(b,x);\r\n\t\tif(x \u003c v){\r\n\t\t\tif(l!=null){\r\n\t\t\t\tTree temp=l.remove(x);\r\n\t\t\t\tthis.left=temp;\r\n\t\t\t\t//@ close tree(this,tcons(v,tree_rem(bl,x),br));\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(v \u003c x){\r\n\t\t\tif(r!=null){\r\n\t\t\t\tTree temp=r.remove(x);\r\n\t\t\t\tthis.right=temp;\r\n\t\t\t\t//@ close tree(this,tcons(v,bl,tree_rem(br,x)));\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(v==x){\r\n\t\t\tif(l!=null\u0026\u0026r==null){\r\n\t\t\t\t//@ open tree(r,tnil);\r\n\t\t\t\treturn l;\r\n\t\t\t}\r\n\t\t\tif(l==null\u0026\u0026r==null){\r\n\t\t\t\t//@ close tree(this,b);\r\n\t\t\t\t//@ close tree(null,tnil);\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\tif(l==null\u0026\u0026r!=null){\r\n\t\t\t\t//@ open tree(l,tnil);\r\n\t\t\t\treturn r;\r\n\t\t\t}\r\n\t\t\tif(l!=null\u0026\u0026r!=null){\r\n\t\t\t\tTree temp=null;\r\n\t\t\t\tint m=l.maximum();\r\n\t\t\t\tthis.value=m;\r\n\t\t\t\t//@ contains_max(bl);\r\n\t\t\t\ttemp=l.remove(m);\r\n\t\t\t\tthis.left=temp;\r\n\t\t\t\t//@ close tree(this,tcons(m,tree_rem(bl,m),br));\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\t}\r\n\t\t//@ assert false;\r\n\t\t//this return statement is necessary because javac can't tell that this code will never be reached\r\n\t\treturn null; //~allow_dead_code\r\n\t}\r\n\tpublic static void main(String[]  args)\r\n\t//@ requires true;\r\n\t//@ ensures true;\r\n\t{\r\n\t\tTree t1=null;\r\n\t\tTree t2=null;\r\n\t\tTree t3=null;\r\n\t\tboolean a=false;\r\n\t\tboolean b=false;\r\n\t\tboolean c=false;\r\n\t\tboolean d=false;\r\n\t\tboolean e=false;\r\n\t\tboolean f=false;\r\n\r\n\t\tt1 = new Tree(3);\r\n\t\tb=t1.contains(2);\r\n\t\tassert(!b);\r\n\t\tt1.add(2);\r\n\r\n\t\ta=t1.contains(2);\r\n\t\tassert(a);\r\n\t\tc=t1.contains(3);\r\n\t\tassert(c);\r\n\t\tt2=t1.remove(3);\r\n\t\tif(t2 != null) {\r\n\t\t  d= t2.contains(3);\r\n\t\t  assert(!d);\r\n\r\n\t\t  t2.add(3);\r\n\t\t  e= t2.contains(2);\r\n\t\t  assert(e);\r\n\t\t  t3=t2.remove(3);\r\n\t\t  if(t3 != null) {\r\n\t\t    f=t3.contains(3);\r\n\t\t    assert(!f);\r\n\t\t  }\r\n\t\t}\r\n\t}\r\n}\r\n",
        "name": "Tree.java",
        "path": "examples/java/Tree.java",
        "url": "/github.com/verifast/verifast/-/blob/examples/java/Tree.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 286,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 287,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures tree(this,tcons(x,tnil,tnil));\r"
        },
        {
          "limitHit": false,
          "lineNumber": 299,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires tree(this,?b);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 300,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures tree(this,b) \u0026*\u0026 result==t_contains(b,x);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 334,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires tree(this,?b) \u0026*\u0026 b!=tnil \u0026*\u0026 false==t_contains(b,x) \u0026*\u0026 inorder(b)==true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 335,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures tree(this,tree_add(b,x)) \u0026*\u0026 inorder(tree_add(b,x))==true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 373,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires tree(this,?b) \u0026*\u0026 b!=tnil \u0026*\u0026 inorder(b)==true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 374,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures result==max(b) \u0026*\u0026 tree(this,b);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 391,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires tree(this,?b) \u0026*\u0026 b!=tnil \u0026*\u0026 true==t_contains(b,x)  \u0026*\u0026 inorder(b)==true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 392,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures tree(result,tree_rem(b,x))\u0026*\u0026 inorder(tree_rem(b,x))==true \u0026*\u0026 false==t_contains(tree_rem(b,x),x);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 449,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires true;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 450,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures true;\r"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class DiamondOperator{\n\t\n\tpublic static void main(String[] args)\n\t//@requires true;\n\t//@ensures true;\n\t{\n\t\t// Base case: Constructor, type inference through the target\n\t\tOther\u003cInteger,Boolean\u003e o = new Other\u003c \u003e();\n\t\tInteger f1 = o.get1();\n\t\tBoolean f2 = o.get2();\n\t\t\n\t\tassert f1 == null \u0026\u0026 f2 == null;\n\t\t\n\t\t// Case 1: Constructor with arguments\n\t\tInteger a = new Integer(2);\n\t\tBoolean b = new Boolean(true);\n\t\tOther\u003cInteger,Boolean\u003e o1 = new Other\u003c \u003e(a,b);\n\t\tf1 = o1.get1();\n\t\tf2 = o1.get2();\n\t\t\n\t\tOther\u003cBoolean,Integer\u003e invert = new Other\u003c \u003e(b,a);\n\t\tf2 = invert.get1();\n\t\tf1 = invert.get2();\n\t\t\n\t\tOther\u003cBoolean,Integer\u003e abba = new Other\u003c \u003e(b,b,a);\n\t\t\n\t\tassert f1 == a \u0026\u0026 f2 == b;\n\t}\n}\n\npublic class Other\u003cT,V\u003e{\n\tT f1;\n\tV f2;\n\t\n\tpublic Other()\n\t//@requires true;\n\t//@ensures this.f1 |-\u003e null \u0026*\u0026 this.f2 |-\u003e null;\n\t{ \n\t\tf1 = null;\n\t\tf2 = null;\n\t}\n\t\n\tpublic Other(T arg1, V arg2)\n\t//@requires true;\n\t//@ensures this.f1 |-\u003e arg1 \u0026*\u0026 this.f2 |-\u003e arg2;\n\t{\n\t\tf1 = arg1;\n\t\tf2 = arg2;\n\t}\n\t\n\tpublic Other(T arg1, T arg2, V arg3)\n\t//@requires true;\n\t//@ensures this.f1 |-\u003e arg1 \u0026*\u0026 this.f2 |-\u003e arg3;\n\t{\n\t\tf1 = arg1;\n\t\tf2 = arg3;\n\t}\n\t\n\tpublic T get1()\n\t//@ requires this.f1 |-\u003e ?f;\n\t//@ ensures result == f \u0026*\u0026 this.f1 |-\u003e f;\n\t{\n\t\treturn f1;\n\t}\n\t\n\tpublic V get2()\n\t//@ requires this.f2 |-\u003e ?f;\n\t//@ ensures result == f \u0026*\u0026 this.f2 |-\u003e f;\n\t{\n\t\treturn f2;\n\t}\n}",
        "name": "DiamondOperator.java",
        "path": "tests/java/generics/DiamondOperator.java",
        "url": "/github.com/verifast/verifast/-/blob/tests/java/generics/DiamondOperator.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 59,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires this.f1 |-\u003e ?f;"
        },
        {
          "limitHit": false,
          "lineNumber": 60,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures result == f \u0026*\u0026 this.f1 |-\u003e f;"
        },
        {
          "limitHit": false,
          "lineNumber": 66,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires this.f2 |-\u003e ?f;"
        },
        {
          "limitHit": false,
          "lineNumber": 67,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures result == f \u0026*\u0026 this.f2 |-\u003e f;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class GenericClass\u003cT\u003e{\n\tpublic T field;\n\tpublic GenericClass(T f)\n\t//@ requires true;\n\t//@ ensures this.field |-\u003e f;\n\t{\n\t\tfield = f;\n\t}\n\t\n\tpublic void add(T arg)\n\t//@ requires this.field |-\u003e ?f;\n\t//@ ensures this.field |-\u003e arg;\n\t{\n\t\tfield = arg;\n\t}\n\t\n\tpublic T get()\n\t//@ requires this.field |-\u003e ?f;\n\t//@ ensures this.field |-\u003e f;\n\t{\n\t\treturn field;\n\t}\n}",
        "name": "BasicGenericClass.java",
        "path": "tests/java/generics/BasicGenericClass.java",
        "url": "/github.com/verifast/verifast/-/blob/tests/java/generics/BasicGenericClass.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 3,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 4,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures this.field |-\u003e f;"
        },
        {
          "limitHit": false,
          "lineNumber": 10,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires this.field |-\u003e ?f;"
        },
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures this.field |-\u003e arg;"
        },
        {
          "limitHit": false,
          "lineNumber": 17,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires this.field |-\u003e ?f;"
        },
        {
          "limitHit": false,
          "lineNumber": 18,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures this.field |-\u003e f;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "public class Test1 {\n\t\n\t/**\n\t * Sunny day scenario test.\n\t */\n\tpublic static void main()\n\t//@ requires true;\n\t//@ ensures true;\n\t{\n\t\tTest1[] own1 = null;\n\t\tTest1[] own2 = null;\n\t\tObject[] obj1 = null;\n\t\tObject[] obj2 = null;\n\t\tint[] int1 = null;\n\t\tint[] int2 = null;\n\t\tshort[] short1 = null;\n\t\tshort[] short2 = null;\n\t\t\n\t\town1 = own2;\n\t\tobj1 = obj2;\n\t\tint1 = int2;\n\t\tshort1 = short2;\n\t\t\n\t\tobj1 = own1;\n\t}\n\t\n\tpublic void test1()\n\t//@ requires true;\n\t//@ ensures true;\n\t{\n\t\tTest1[] own1;\n\t\tObject [] obj1;\n\t\town1 = obj1; //~\n\t}\n}\n",
        "name": "Test1.java",
        "path": "tests/errors/java_typing_array_assignment/Test1.java",
        "url": "/github.com/verifast/verifast/-/blob/tests/errors/java_typing_array_assignment/Test1.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 6,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 7,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures true;"
        },
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "d152da790c7ebf72ce616533a6c83082629adbdb"
        },
        "content": "/**\n * See Test1.java\n *\n * (we have to split to multiple files because VeriFast\n * does not support multiple allow-fails (even when they\n * are in multiple methods).\n */\n\npublic class Test2 {\n\t\n\tpublic void test2()\n\t//@ requires true;\n\t//@ ensures true;\n\t{\n\t\tint[] int1;\n\t\tshort [] short1;\n\t\tint1 = short1; //~ should-fail\n\t}\n}\n\n",
        "name": "Test2.java",
        "path": "tests/errors/java_typing_array_assignment/Test2.java",
        "url": "/github.com/verifast/verifast/-/blob/tests/errors/java_typing_array_assignment/Test2.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 11,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires true;"
        },
        {
          "limitHit": false,
          "lineNumber": 12,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures true;"
        }
      ],
      "repository": {
        "name": "github.com/verifast/verifast",
        "url": "/github.com/verifast/verifast"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 1827,
  "ElapsedMilliseconds": 1199,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
