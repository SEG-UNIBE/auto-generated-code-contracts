{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/star-finder/jpf-star lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "4b5c3b28aed2dc80c960a506d530850b6aee403d"
        },
        "content": "//import gnu.trove.THashMap.KeyView.EntryIterator;\npackage rbt;\n\nimport java.util.NoSuchElementException;\n\npublic class TreeMap  {\n\n\tpublic boolean repOK() {\n\t\tif (root == null) return size == realSize();\n\t\treturn root.consistency() \u0026\u0026 size == realSize();\n\t}\n\t\n    //@ invariant (root == null || root.consistency()) \u0026\u0026 size == realSize();\n\n    public Entry root = null;\n\n    /**\n     * The number of entries in the tree\n     */\n    public int size = 0;\n\n    /**\n     * The number of structural modifications to the tree.\n     */\n    public transient int modCount = 0;\n\n    private void incrementSize() {\n        modCount++;\n        size++;\n    }\n\n    private void decrementSize() {\n        modCount++;\n        size--;\n    }\n\n    // Query Operations\n\n    /**\n     * Returns the number of key-value mappings in this map.\n     * \n     * @return the number of key-value mappings in this map.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Returns \u003ctt\u003etrue\u003c/tt\u003e if this map contains a mapping for the specified\n     * key.\n     * \n     * @param key\n     *            key whose presence in this map is to be tested.\n     * \n     * @return \u003ctt\u003etrue\u003c/tt\u003e if this map contains a mapping for the specified\n     *         key.\n     * @throws ClassCastException\n     *             if the key cannot be compared with the keys currently in the\n     *             map.\n     * @throws NullPointerException\n     *             key is \u003ctt\u003enull\u003c/tt\u003e and this map uses natural ordering, or\n     *             its comparator does not tolerate \u003ctt\u003enull\u003c/tt\u003e keys.\n     */\n    public boolean containsKey(int key) {\n        return getEntry(key) != null;\n    }\n\n    /**\n     * Returns \u003ctt\u003etrue\u003c/tt\u003e if this map maps one or more keys to the\n     * specified value. More formally, returns \u003ctt\u003etrue\u003c/tt\u003e if and only if\n     * this map contains at least one mapping to a value \u003ctt\u003evalue\u003c/tt\u003e such that\n     * \u003ctt\u003e(value==null ? value==null : value.equals(value))\u003c/tt\u003e. This operation\n     * will probably require time linear in the Map size for most\n     * implementations of Map.\n     * \n     * @param value\n     *            value whose presence in this Map is to be tested.\n     * @return \u003ctt\u003etrue\u003c/tt\u003e if a mapping to \u003ctt\u003evalue\u003c/tt\u003e exists;\n     *         \u003ctt\u003efalse\u003c/tt\u003e otherwise.\n     * @since 1.2\n     */\n    public boolean containsValue(Object value) {\n        return (root == null ? false : (value == null ? valueSearchNull(root)\n                : valueSearchNonNull(root, value)));\n    }\n\n    private boolean valueSearchNull(Entry n) {\n        if (n.value == null)\n            return true;\n\n        // Check left and right subtrees for value\n        return (n.left != null \u0026\u0026 valueSearchNull(n.left))\n                || (n.right != null \u0026\u0026 valueSearchNull(n.right));\n    }\n\n    private boolean valueSearchNonNull(Entry n, Object value) {\n        // Check this node for the value\n//        if (value.equals(n.value))\n    \tif (value == n.value)\n            return true;\n\n        // Check left and right subtrees for value\n        return (n.left != null \u0026\u0026 valueSearchNonNull(n.left, value))\n                || (n.right != null \u0026\u0026 valueSearchNonNull(n.right, value));\n    }\n\n    /**\n     * Returns the value to which this map maps the specified key. Returns\n     * \u003ctt\u003enull\u003c/tt\u003e if the map contains no mapping for this key. A return\n     * value of \u003ctt\u003enull\u003c/tt\u003e does not \u003ci\u003enecessarily\u003c/i\u003e indicate that the\n     * map contains no mapping for the key; it's also possible that the map\n     * explicitly maps the key to \u003ctt\u003enull\u003c/tt\u003e. The \u003ctt\u003econtainsKey\u003c/tt\u003e\n     * operation may be used to distinguish these two cases.\n     * \n     * @param key\n     *            key whose associated value is to be returned.\n     * @return the value to which this map maps the specified key, or\n     *         \u003ctt\u003enull\u003c/tt\u003e if the map contains no mapping for the key.\n     * @throws ClassCastException\n     *             key cannot be compared with the keys currently in the map.\n     * @throws NullPointerException\n     *             key is \u003ctt\u003enull\u003c/tt\u003e and this map uses natural ordering, or\n     *             its comparator does not tolerate \u003ctt\u003enull\u003c/tt\u003e keys.\n     * \n     * @see #containsKey(Object)\n     */\n    public Object get(int key) {\n        Entry p = getEntry(key);\n        return (p == null ? null : p.value);\n    }\n\n\n    /**\n     * Returns the first (lowest) key currently in this sorted map.\n     * \n     * @return the first (lowest) key currently in this sorted map.\n     * @throws NoSuchElementException\n     *             Map is empty.\n     */\n    public int firstKey() {\n        return key(firstEntry());\n    }\n\n    /**\n     * Returns the last (highest) key currently in this sorted map.\n     * \n     * @return the last (highest) key currently in this sorted map.\n     * @throws NoSuchElementException\n     *             Map is empty.\n     */\n    public int lastKey() {\n        return key(lastEntry());\n    }\n\n\n    /**\n     * Returns this map's entry for the given key, or \u003ctt\u003enull\u003c/tt\u003e if the map\n     * does not contain an entry for the key.\n     * \n     * @return this map's entry for the given key, or \u003ctt\u003enull\u003c/tt\u003e if the map\n     *         does not contain an entry for the key.\n     * @throws ClassCastException\n     *             if the key cannot be compared with the keys currently in the\n     *             map.\n     * @throws NullPointerException\n     *             key is \u003ctt\u003enull\u003c/tt\u003e and this map uses natural order, or\n     *             its comparator does not tolerate * \u003ctt\u003enull\u003c/tt\u003e keys.\n     */\n    private Entry getEntry(int key) {\n        Entry p = root;\n        int k =  key;\n        while (p != null) {\n            //int cmp = compare(k, p.key);\n            if (k == p.key)\n                return p;\n            else if (k \u003c p.key)\n                p = p.left;\n            else\n                p = p.right;\n        }\n        return null;\n    }\n\n\n    /**\n     * Returns the key corresponding to the specified Entry. Throw\n     * NoSuchElementException if the Entry is \u003ctt\u003enull\u003c/tt\u003e.\n     */\n    private static int key(Entry e) {\n        if (e == null)\n            throw new NoSuchElementException();\n        return e.key;\n    }\n\n    /**\n     * Associates the specified value with the specified key in this map. If the\n     * map previously contained a mapping for this key, the old value is\n     * replaced.\n     * \n     * @param key\n     *            key with which the specified value is to be associated.\n     * @param value\n     *            value to be associated with the specified key.\n     * \n     * @return previous value associated with specified key, or \u003ctt\u003enull\u003c/tt\u003e\n     *         if there was no mapping for key. A \u003ctt\u003enull\u003c/tt\u003e return can\n     *         also indicate that the map previously associated \u003ctt\u003enull\u003c/tt\u003e\n     *         with the specified key.\n     * @throws ClassCastException\n     *             key cannot be compared with the keys currently in the map.\n     * @throws NullPointerException\n     *             key is \u003ctt\u003enull\u003c/tt\u003e and this map uses natural order, or\n     *             its comparator does not tolerate \u003ctt\u003enull\u003c/tt\u003e keys.\n     */\n    //@ ensures root != null;\n    public Object put(int key, Object value) {\n        Entry t = root;\n\n        if (t == null) {\n            incrementSize();\n            root = new Entry(key, value, null);\n            return null;\n        }\n\n        while (true) {\n            int cmp = compare(key, t.key);\n            if (cmp == 0) {\n                return t.setValue(value);\n            } else if (cmp \u003c 0) {\n                if (t.left != null) {\n                    t = t.left;\n                } else {\n                    incrementSize();\n                    t.left = new Entry(key, value, t);\n                    fixAfterInsertion(t.left);\n                    return null;\n                }\n            } else { // cmp \u003e 0\n                if (t.right != null) {\n                    t = t.right;\n                } else {\n                    incrementSize();\n                    t.right = new Entry(key, value, t);\n                    fixAfterInsertion(t.right);\n                    return null;\n                }\n            }\n        }\n        //return null;\n    }\n\n    /**\n     * Removes the mapping for this key from this TreeMap if present.\n     * \n     * @param key\n     *            key for which mapping should be removed\n     * @return previous value associated with specified key, or \u003ctt\u003enull\u003c/tt\u003e\n     *         if there was no mapping for key. A \u003ctt\u003enull\u003c/tt\u003e return can\n     *         also indicate that the map previously associated \u003ctt\u003enull\u003c/tt\u003e\n     *         with the specified key.\n     * \n     * @throws ClassCastException\n     *             key cannot be compared with the keys currently in the map.\n     * @throws NullPointerException\n     *             key is \u003ctt\u003enull\u003c/tt\u003e and this map uses natural order, or\n     *             its comparator does not tolerate \u003ctt\u003enull\u003c/tt\u003e keys.\n     */\n    public Object remove(int key) {\n        Entry p = getEntry(key);\n        if (p == null)\n            return null;\n\n        Object oldValue = p.value;\n        deleteEntry(p);\n        return oldValue;\n    }\n    private int realSize() {\n        if(root==null) {\n            return 0;\n        }\n        return root.size();\n    }\n\n    /**\n     * Removes all mappings from this TreeMap.\n     */\n    public void clear() {\n        modCount++;\n        size = 0;\n        root = null;\n    }\n\n    /**\n     * Compares two keys using the correct comparison method for this TreeMap.\n     */\n    private int compare(int k1, int k2) {\n        if(k1 \u003c k2) {\n            return -1;\n            \n        }else if(k1==k2) {\n            return 0;\n        }else {\n            return 1;\n        }\n    }\n\n    /**\n     * Test two values for equality. Differs from o1.equals(o2) only in that it\n     * copes with \u003ctt\u003enull\u003c/tt\u003e o1 properly.\n     */\n    private static boolean valEquals(Object o1, Object o2) {\n        return (o1 == null ? o2 == null : o1.equals(o2));\n    }\n\n    private static final boolean RED = false;\n\n    private static final boolean BLACK = true;\n\n    /**\n     * Node in the Tree. Doubles as a means to pass key-value pairs back to user\n     * (see Map.Entry).\n     */\n\n    static public class Entry {\n        int key;\n\n        Object value;\n\n        Entry left = null;\n\n        Entry right = null;\n\n        Entry parent;\n\n        boolean color = BLACK;\n        public Entry() {\n            parent=null;\n            value=null;\n            key=-1;\n        }\n\n        /**\n         * Make a new cell with given key, value, and parent, and with\n         * \u003ctt\u003enull\u003c/tt\u003e child links, and BLACK color.\n         */\n        Entry(int key, Object value, Entry parent) {\n            this.key = key;\n            this.value = value;\n            this.parent = parent;\n        }\n        public boolean consistency()\n        {\n            return wellConnected(null) \u0026\u0026 redConsistency() \u0026\u0026 blackConsistency() \u0026\u0026 ordered() ;\n        }\n        boolean ordered() {\n            return ordered(this,new Range());\n        }\n        boolean ordered(Entry t, Range range) {\n            if(t == null) {\n                return true;\n            }\n            if(!range.inRange(t.key)) {\n                return false;\n            }\n            boolean ret=true;\n            ret = ret \u0026\u0026 ordered(t.left,range.setUpper(t.key));\n            ret = ret \u0026\u0026 ordered(t.right,range.setLower(t.key));\n            return ret;\n        }\n        int size() {\n            int ls=0,rs=0;\n            if(left!=null) {\n                ls=left.size();\n            }\n            if(right!=null) {\n                rs=right.size();\n            }\n            return 1+ls+rs;\n        }\n        /**\n         * Returns true iff this tree is well-connected.\n         */\n\n        public boolean wellConnected(Entry expectedParent) {\n            boolean ok = true;\n            if (expectedParent != parent) {\n\n                return false;\n            }\n            \n            if (right != null) {\n                //ok \u0026\u0026 is redundant because ok is assigned true\n                ok = ok \u0026\u0026 right.wellConnected(this);\n            }\n            \n            if (left != null) {\n                \n                ok = ok \u0026\u0026 left.wellConnected(this);\n            }\n            \n            if(right==left \u0026\u0026 right!=null \u0026\u0026 left!=null) {//left!=null is redundant because left==right \u0026\u0026 right!=null\n                return false;\n            }\n            \n            return ok;\n        }\n\n        /**\n         * Returns true if no red node in subtree has red children\n         * \n         * @post returns true if no red node in subtree has red children\n         */\n        protected boolean redConsistency() {\n            boolean ret = true;\n            if (color == RED\n                    \u0026\u0026 ((left != null \u0026\u0026 left.color == RED) || (right != null \u0026\u0026 right.color == RED)))\n                return false;\n            if (left != null) {\n                ret = ret \u0026\u0026 left.redConsistency();\n            }\n            if (right != null) {\n                ret = ret \u0026\u0026 right.redConsistency();\n            }\n            return ret;\n        }\n\n        /**\n         * Returns the black height of this subtree.\n         * \n         * @pre\n         * @post returns the black height of this subtree\n         */\n        protected int blackHeight() {\n            int ret = 0;\n            if (color == BLACK) {\n                ret = 1;\n            }\n            if (left != null) {\n                ret += left.blackHeight();\n            }\n            return ret;\n        }\n\n        /**\n         * Returns true if black properties of tree are correct\n         * \n         * @post returns true if black properties of tree are correct\n         */\n        protected boolean blackConsistency() {\n\n            if (color != BLACK) // root must be black\n            {\n                return false;\n            }\n            // the number of black nodes on way to any leaf must be same\n            if (!consistentlyBlackHeight(blackHeight())) {\n                return false;\n            }\n            return true;\n        }\n\n        /**\n         * Checks to make sure that the black height of tree is height\n         * \n         * @post checks to make sure that the black height of tree is height\n         */\n        protected boolean consistentlyBlackHeight(int height) {\n            boolean ret = true;\n            if (color == BLACK)\n                height--;\n            if (left == null) {\n                ret = ret \u0026\u0026 (height == 0);\n            } else {\n                ret = ret \u0026\u0026 (left.consistentlyBlackHeight(height));\n            }\n            if (right == null) {\n                ret = ret \u0026\u0026 (height == 0);\n            } else {\n                ret = ret \u0026\u0026 (right.consistentlyBlackHeight(height));\n            }\n\n            return ret;\n        }\n\n        /**\n         * Returns the key.\n         * \n         * @return the key.\n         */\n        public int getKey() {\n            return key;\n        }\n\n        /**\n         * Returns the value associated with the key.\n         * \n         * @return the value associated with the key.\n         */\n        public Object getValue() {\n            return value;\n        }\n\n        /**\n         * Replaces the value currently associated with the key with the given\n         * value.\n         * \n         * @return the value associated with the key before this method was\n         *         called.\n         */\n        public Object setValue(Object value) {\n        \tObject oldValue = this.value;\n            this.value = value;\n            return oldValue;\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof Entry))\n                return false;\n            Entry e = (Entry) o;\n\n            return key== e.getKey() \u0026\u0026 valEquals(value, e.getValue());\n        }\n\n        public int hashCode() {\n            int keyHash = key;\n            int valueHash = (value == null ? 0 : value.hashCode());\n            return keyHash ^ valueHash;\n        }\n\n        public String toString() {\n            return key + \"=\" + value;\n        }\n    }\n\n    /**\n     * Returns the first Entry in the TreeMap (according to the TreeMap's\n     * key-sort function). Returns null if the TreeMap is empty.\n     */\n    private Entry firstEntry() {\n        Entry p = root;\n        if (p != null)\n            while (p.left != null)\n                p = p.left;\n        return p;\n    }\n\n    /**\n     * Returns the last Entry in the TreeMap (according to the TreeMap's\n     * key-sort function). Returns null if the TreeMap is empty.\n     */\n    private Entry lastEntry() {\n        Entry p = root;\n        if (p != null)\n            while (p.right != null)\n                p = p.right;\n        return p;\n    }\n\n    /**\n     * Returns the successor of the specified Entry, or null if no such.\n     */\n    private Entry successor(Entry t) {\n        if (t == null)\n            return null;\n        else if (t.right != null) {\n            Entry p = t.right;\n            while (p.left != null)\n                p = p.left;\n            return p;\n        } else {\n            Entry p = t.parent;\n            Entry ch = t;\n            while (p != null \u0026\u0026 ch == p.right) {\n                ch = p;\n                p = p.parent;\n            }\n            return p;\n        }\n    }\n\n    /**\n     * Balancing operations.\n     * \n     * Implementations of rebalancings during insertion and deletion are\n     * slightly different than the CLR version. Rather than using dummy\n     * nilnodes, we use a set of accessors that deal properly with null. They\n     * are used to avoid messiness surrounding nullness checks in the main\n     * algorithms.\n     */\n\n    private static \u003c V\u003e boolean colorOf(Entry p) {\n        return (p == null ? BLACK : p.color);\n    }\n\n    private static \u003c V\u003e Entry parentOf(Entry p) {\n        return (p == null ? null : p.parent);\n    }\n\n    private static  void setColor(Entry p, boolean c) {\n        if (p != null)\n            p.color = c;\n    }\n\n    private static  Entry leftOf(Entry p) {\n        return (p == null) ? null : p.left;\n    }\n\n    private static  Entry rightOf(Entry p) {\n        return (p == null) ? null : p.right;\n    }\n\n    /** From CLR * */\n    private void rotateLeft(Entry p) {\n        Entry r = p.right;\n        p.right = r.left;\n        if (r.left != null)\n            r.left.parent = p;\n        r.parent = p.parent;\n        if (p.parent == null)\n            root = r;\n        else if (p.parent.left == p)\n            p.parent.left = r;\n        else\n            p.parent.right = r;\n        r.left = p;\n        p.parent = r;\n    }\n\n    /** From CLR * */\n    private void rotateRight(Entry p) {\n        Entry l = p.left;\n        p.left = l.right;\n        if (l.right != null)\n            l.right.parent = p;\n        l.parent = p.parent;\n        if (p.parent == null)\n            root = l;\n        else if (p.parent.right == p)\n            p.parent.right = l;\n        else\n            p.parent.left = l;\n        l.right = p;\n        p.parent = l;\n    }\n\n    /** From CLR * */\n    private void fixAfterInsertion(Entry x) {\n        x.color = RED;\n        \n        while (x != null \u0026\u0026 x != root \u0026\u0026 x.parent.color == RED) {\n        \tif (parentOf(x) == leftOf(parentOf(parentOf(x)))) {\n                Entry y = rightOf(parentOf(parentOf(x)));\n                if (colorOf(y) == RED) {\n                    setColor(parentOf(x), BLACK);\n                    setColor(y, BLACK);\n                    setColor(parentOf(parentOf(x)), RED);\n                    x = parentOf(parentOf(x));\n                } else {\n                    if (x == rightOf(parentOf(x))) {\n                        x = parentOf(x);\n                        rotateLeft(x);\n                    }\n                    setColor(parentOf(x), BLACK);//bug seeded\n                    setColor(parentOf(parentOf(x)), RED);\n                    if (parentOf(parentOf(x)) != null)\n                        rotateRight(parentOf(parentOf(x)));\n                }\n            } else {\n                Entry y = leftOf(parentOf(parentOf(x)));\n                if (colorOf(y) == RED) {\n                    setColor(parentOf(x), BLACK);\n                    setColor(y, BLACK);\n                    setColor(parentOf(parentOf(x)), RED);\n                    x = parentOf(parentOf(x));\n                } else {\n                    if (x == leftOf(parentOf(x))) {\n                        x = parentOf(x);\n                        rotateRight(x);\n                    }\n                    setColor(parentOf(x), BLACK);\n                    setColor(parentOf(parentOf(x)), RED);\n                    if (parentOf(parentOf(x)) != null)\n                        rotateLeft(parentOf(parentOf(x)));\n                }\n            }\n        }\n        root.color = BLACK;\n    }\n\n    /**\n     * Delete node p, and then rebalance the tree.\n     */\n    //@ requires p.wellConnected(p.parent);\n    private void deleteEntry(//@NonNull\n    Entry p) {\n        decrementSize();\n\n        // If strictly internal, copy successor's element to p and then make p\n        // point to successor.\n        if (p.left != null \u0026\u0026 p.right != null) {\n            Entry s = successor(p);\n            p.key = s.key;\n            p.value = s.value;\n            p = s;\n        } // p has 2 children\n\n        // Start fixup at replacement node, if it exists.\n        Entry replacement = (p.left != null ? p.left : p.right);\n\n        if (replacement != null) {\n            // Link replacement to parent\n            replacement.parent = p.parent;\n            if (p.parent == null)\n                root = replacement;\n            else if (p == p.parent.left)\n                p.parent.left = replacement;\n            else\n                p.parent.right = replacement;\n\n            // Null out links so they are OK to use by fixAfterDeletion.\n            p.left = p.right = p.parent = null;\n\n            // Fix replacement\n            if (p.color == BLACK) // 1 of 2\n                fixAfterDeletion(replacement);\n        } else if (p.parent == null) { // return if we are the only node.\n            root = null;\n        } else { // No children. Use self as phantom replacement and unlink.\n            if (p.color == BLACK)\n                fixAfterDeletion(p);\n\n            if (p.parent != null) { // 1 of 2\n                if (p == p.parent.left)\n                    p.parent.left = null;\n                else if (p == p.parent.right) // 1 of 2\n                    p.parent.right = null;\n                p.parent = null;\n            }\n        }\n    }\n\n    /** From CLR * */\n    private void fixAfterDeletion(Entry x) {\n        while (x != root \u0026\u0026 colorOf(x) == BLACK) {\n            if (x == leftOf(parentOf(x))) {\n                Entry sib = rightOf(parentOf(x));\n\n                if (colorOf(sib) == RED) {\n                    setColor(sib, BLACK);\n                    setColor(parentOf(x), RED);\n                    rotateLeft(parentOf(x));\n                    sib = rightOf(parentOf(x));\n                }\n\n                if (colorOf(leftOf(sib)) == BLACK\n                        \u0026\u0026 colorOf(rightOf(sib)) == BLACK) {\n                    setColor(sib, RED);\n                    x = parentOf(x);\n                } else {\n                    if (colorOf(rightOf(sib)) == BLACK) {\n                        setColor(leftOf(sib), BLACK);\n                        setColor(sib, RED);\n                        rotateRight(sib);\n                        sib = rightOf(parentOf(x));\n                    }\n                    setColor(sib, colorOf(parentOf(x)));\n                    setColor(parentOf(x), BLACK);\n                    setColor(rightOf(sib), BLACK);\n                    rotateLeft(parentOf(x));\n                    x = root;\n                }\n            } else { // symmetric\n                Entry sib = leftOf(parentOf(x));\n\n                if (colorOf(sib) == RED) {\n                    setColor(sib, BLACK);\n                    setColor(parentOf(x), RED);\n                    rotateRight(parentOf(x));\n                    sib = leftOf(parentOf(x));\n                }\n\n                if (colorOf(rightOf(sib)) == BLACK\n                        \u0026\u0026 colorOf(leftOf(sib)) == BLACK) {\n                    setColor(sib, RED);\n                    x = parentOf(x);\n                } else {\n                    if (colorOf(leftOf(sib)) == BLACK) {\n                        setColor(rightOf(sib), BLACK);\n                        setColor(sib, RED);\n                        rotateLeft(sib);\n                        sib = leftOf(parentOf(x));\n                    }\n                    setColor(sib, colorOf(parentOf(x)));\n                    setColor(parentOf(x), BLACK);\n                    setColor(leftOf(sib), BLACK);\n                    rotateRight(parentOf(x));\n                    x = root;\n                }\n            }\n        }\n\n        setColor(x, BLACK);\n    }\n}\n",
        "name": "TreeMap.java",
        "path": "src/examples/rbt/TreeMap.java",
        "url": "/github.com/star-finder/jpf-star/-/blob/src/examples/rbt/TreeMap.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 214,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures root != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 692,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires p.wellConnected(p.parent);"
        }
      ],
      "repository": {
        "name": "github.com/star-finder/jpf-star",
        "url": "/github.com/star-finder/jpf-star"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 2,
  "ElapsedMilliseconds": 697,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
