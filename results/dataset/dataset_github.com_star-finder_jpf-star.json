[
    {
        "repository": "github.com/star-finder/jpf-star",
        "file": "src/examples/rbt/TreeMap.java",
        "code": "    public Object put(int key, Object value) {\n        Entry t = root;\n\n        if (t == null) {\n            incrementSize();\n            root = new Entry(key, value, null);\n            return null;\n        }\n\n        while (true) {\n            int cmp = compare(key, t.key);\n            if (cmp == 0) {\n                return t.setValue(value);\n            } else if (cmp < 0) {\n                if (t.left != null) {\n                    t = t.left;\n                } else {\n                    incrementSize();\n                    t.left = new Entry(key, value, t);\n                    fixAfterInsertion(t.left);\n                    return null;\n                }\n            } else { // cmp > 0\n                if (t.right != null) {\n                    t = t.right;\n                } else {\n                    incrementSize();\n                    t.right = new Entry(key, value, t);\n                    fixAfterInsertion(t.right);\n                    return null;\n                }\n            }\n        }\n        //return null;\n    }\n",
        "methodStartingLine": 216,
        "methodEndingLine": 250,
        "jml": "//@ ensures root != null;"
    },
    {
        "repository": "github.com/star-finder/jpf-star",
        "file": "src/examples/rbt/TreeMap.java",
        "code": "    private void deleteEntry(//@NonNull\n    Entry p) {\n        decrementSize();\n\n        // If strictly internal, copy successor's element to p and then make p\n        // point to successor.\n        if (p.left != null && p.right != null) {\n            Entry s = successor(p);\n            p.key = s.key;\n            p.value = s.value;\n            p = s;\n        } // p has 2 children\n\n        // Start fixup at replacement node, if it exists.\n        Entry replacement = (p.left != null ? p.left : p.right);\n\n        if (replacement != null) {\n            // Link replacement to parent\n            replacement.parent = p.parent;\n            if (p.parent == null)\n                root = replacement;\n            else if (p == p.parent.left)\n                p.parent.left = replacement;\n            else\n                p.parent.right = replacement;\n\n            // Null out links so they are OK to use by fixAfterDeletion.\n            p.left = p.right = p.parent = null;\n\n            // Fix replacement\n            if (p.color == BLACK) // 1 of 2\n                fixAfterDeletion(replacement);\n        } else if (p.parent == null) { // return if we are the only node.\n            root = null;\n        } else { // No children. Use self as phantom replacement and unlink.\n            if (p.color == BLACK)\n                fixAfterDeletion(p);\n\n            if (p.parent != null) { // 1 of 2\n                if (p == p.parent.left)\n                    p.parent.left = null;\n                else if (p == p.parent.right) // 1 of 2\n                    p.parent.right = null;\n                p.parent = null;\n            }\n        }\n    }\n",
        "methodStartingLine": 694,
        "methodEndingLine": 740,
        "jml": "//@ requires p.wellConnected(p.parent);"
    }
]