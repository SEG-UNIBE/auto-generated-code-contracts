[
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/04-tdp-pyramides/java/old/Pyramide.java",
        "code": "    public /*@pure@*/ int hauteur(){\n        return hauteur ;\n    } \n",
        "methodStartingLine": 39,
        "methodEndingLine": 41,
        "jml": "//@ requires h >= 1 ;\n//@ ensures hauteur() == h ;"
    },
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/04-tdp-pyramides/java/old/Pyramide.java",
        "code": "    private  /*@pure@*/ int indice(int lig, int diag){\n        /* BEGINKILL */\n        return (diag * (diag - 1 ) / 2 + lig - 1);\n        /* ENDKILL */\n    } \n",
        "methodStartingLine": 67,
        "methodEndingLine": 71,
        "jml": "//@ requires lig >= 1 && lig <= hauteur() "
    },
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/04-tdp-pyramides/java/old/Pyramide.java",
        "code": "    private  /*@pure@*/ int valueAt(int lig, int diag){\n        return (elements[indice(lig,diag)]);\n    }\n",
        "methodStartingLine": 76,
        "methodEndingLine": 78,
        "jml": "//@ requires lig >= 1 && lig <= hauteur()"
    },
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/04-tdp-pyramides/java/old/Pyramide.java",
        "code": "    private void setValueAt(int v, int lig, int diag){\n        elements[indice(lig,diag)] = v;\n    }\n",
        "methodStartingLine": 84,
        "methodEndingLine": 86,
        "jml": "//@ requires nombreAutorise(v) && lig>=1 && lig<=hauteur() \n//@ ensures valueAt(lig,diag) == v ;"
    },
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/04-tdp-pyramides/java/old/Pyramide.java",
        "code": "    private  /*@pure@*/ boolean correcte(int diag){\n        // Récursivité portant sur les diagonales de 1 à diag\n        /* BEGINKILL */\n        if (diag == 0)\n          return true;\n\n\n        for (int lig=1; lig<=diag;lig++)\n          if (posCorrecte(lig,diag) == false)\n            return false;\n\n        return correcte(diag-1);\n        /* ENDKILL */\n    } // correcte(int)\n",
        "methodStartingLine": 106,
        "methodEndingLine": 119,
        "jml": "//@ requires diag >= 0 && diag <= hauteur() ;\n//@ ensures correcte() ;"
    },
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/04-tdp-pyramides/java/old/Pyramide.java",
        "code": "    public  /*@pure@*/  boolean posCorrecte(int lig, int diag) {\n        /* BEGINKILL */\n        // Récursivité portant sur les lignes de 1 à lig\n        if (lig == diag + 1) \n            return true;\n\n        int nbre = valueAt(lig,diag);\n\n        /* jamais le droit de sortir de [1..count] */\n        if (!nombreAutorise(nbre)) \n            return false;\n\n        /* Aucune [autre] contrainte sur la premiere case */\n        if (lig == 1 && diag == 1)\n            return true;\n\n        /* il faut toujours être original */\n        if (contains(nbre,lig-1,diag)) \n            return false;\n\n        /* Il faut être la différence des ancêtres (sauf sur la première ligne) */\n        if (lig > 1) {\n            int n1 = valueAt(lig-1,diag-1);\n            int n2 = valueAt(lig-1,diag);\n\n            if (nbre != Math.abs(n1 - n2) )\n                return false;\n        }\n\n        /* Tous les tests ont été passés avec succès */\n        return true;\n        /* ENDKILL */\n    } // posCorrecte(int, int)\n",
        "methodStartingLine": 125,
        "methodEndingLine": 157,
        "jml": "//@ requires lig >= 1&& lig <= diag+1 "
    },
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/04-tdp-pyramides/java/old/Pyramide.java",
        "code": "    private  /*@pure@*/ boolean contains(int val, int lig, int diag) {\n        /* On tient compte de l'implantation de la pyramide par soucis d'optimisation */\n\n        int fin = indice(lig,diag);\n        for (int i=0; i < fin; i++) {\n\n            if (val == elements[i])\n                return true;\n        }\n\n        return false;\n    }//contains\n",
        "methodStartingLine": 163,
        "methodEndingLine": 174,
        "jml": "//@ requires lig >= 1 && lig <= hauteur() "
    },
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/04-tdp-pyramides/java/old/Pyramide.java",
        "code": "    public void remplir(){\n        remplir(1);         // on commence a la diagonale 1\n    } \n",
        "methodStartingLine": 189,
        "methodEndingLine": 191,
        "jml": "//@ ensures correcte() ;"
    },
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/04-tdp-pyramides/java/old/Pyramide.java",
        "code": "    private boolean remplir(int diag){\n        /* BEGINKILL */\n        // Itération conditionnelle parcourt le domaine [count .. 1]\n        // Arret lorsqu'une solution est trouvee\n\n        if (diag > hauteur) \n            return true;\n\n        for (int k=count(); k>=1; k--) {\n\n            // si k est déjà utilisé, on passe au tour de boucle suivant\n            if (!contains(k,1,diag)) {\n\n                // Essayer de propager k sur la diagonale\n\n                if (propager(diag,k)) {\n                    // La propagation a été faite, on essaie de remplir la suite\n                    if (remplir(diag+1)) {\n                        // L'appel récursif est une réussite : on tient une solution\n                        return true;\n                    }\n                }\n              \n            } // k n'est pas encore pris\n        }\n        return false;\n        /* ENDKILL */\n    }//remplir(int)\n",
        "methodStartingLine": 196,
        "methodEndingLine": 223,
        "jml": "//@ requires diag >= 1 && diag <= hauteur() + 1 && correcte(diag-1) ;\n//@ ensures  (\\result && correcte()) || !\\result  ;  "
    },
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/04-tdp-pyramides/java/old/Pyramide.java",
        "code": "    private boolean propager(int diag, int val){\n        // On pose val en haut de la diagonale\n        setValueAt(val,1,diag);\n\n        // On essaie de propager sur le reste de la diagonale\n\n        /* BEGINKILL */\n        // Itération conditionnelle portant sur le domaine [ 2 .. diag ]\n        // On s'arrête dès que les contraintes ne sont plus respectées\n\n        int nbre = val;\n        for (int lig=2; lig <= diag; lig++) {\n            /** invariant\n                -- la diagonale diag est <<bien construite>> jusqu'en lig-1\n                diagonale_correcte(lig-1,diag)\n            **/\n            /** variant         diag - lig  **/\n            nbre -= valueAt(lig-1,diag-1);    // économise les accès au tableau\n            nbre = Math.abs(nbre);\n            // On s'assure que le nombre ainsi calculé n'est pas déjà utilisé\n            if (contains(nbre,lig,diag))\n                return false;\n\n            // Le nombre n'est pas utilisé; on le pose et on continue\n            setValueAt(nbre,lig,diag);\n\n        }\n        return true;\n        /* ENDKILL */\n    }//propager(int,int)\n",
        "methodStartingLine": 236,
        "methodEndingLine": 265,
        "jml": "//@ requires diag >= 1 && diag <= hauteur() && val >= 1 && val <= count();\n//@ ensures !\\result  || (\\result && posCorrecte(diag,diag)) ;"
    },
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/04-tdp-pyramides/java/old/PyramideVite.java",
        "code": "    public /*@pure@*/ int hauteur(){\n\treturn hauteur ;\n    } \n",
        "methodStartingLine": 45,
        "methodEndingLine": 47,
        "jml": "//@ requires h >= 1 ;\n//@ ensures hauteur() == h ;"
    },
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/04-tdp-pyramides/java/old/PyramideVite.java",
        "code": "    private  /*@pure@*/ int valueAt(int lig, int diag){\n\treturn (elements[indice(lig,diag)]);\n    }\n",
        "methodStartingLine": 71,
        "methodEndingLine": 73,
        "jml": "//@ requires lig >= 1 && lig <= hauteur() && diag >= lig && diag <= hauteur() ;"
    },
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/04-tdp-pyramides/java/old/PyramideVite.java",
        "code": "    private  /*@pure@*/ int indice(int lig, int diag){\n        return (diag * (diag - 1 ) / 2 + lig - 1);\n    } \n",
        "methodStartingLine": 77,
        "methodEndingLine": 79,
        "jml": "//@ requires lig >= 1 && lig <= hauteur() && diag >= lig && diag <= hauteur();"
    },
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/04-tdp-pyramides/java/old/PyramideVite.java",
        "code": "    private  /*@pure@*/ boolean correcte(int diag){\n\t// Récursivité portant sur les diagonales de 1 à diag\n\treturn ((diag == 0) || \n\t\t(diagonaleCorrecte(diag,diag) && correcte(diag-1)));\n    } // correcte(int)\n",
        "methodStartingLine": 99,
        "methodEndingLine": 103,
        "jml": "//@ requires diag >= 0 && diag <= hauteur() ;\n//@ ensures correcte() ;"
    },
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/04-tdp-pyramides/java/old/PyramideVite.java",
        "code": "    public  /*@pure@*/  boolean diagonaleCorrecte(int lig, int diag) {\n\t// Récursivité portant sur les lignes de 1 à lig\n\tif (lig == diag + 1) \n\t    return true;\n\n\tint nbre = valueAt(lig,diag);\n\n\t/* jamais le droit de sortir de [1..count] */\n\tif (!nombreAutorise(nbre)) {\n\t    System.out.println(\"Nombre invalide \"+nbre);\n\t    return false;\n\t}\n\n\t/* Aucune [autre] contrainte sur la premiere case */\n\tif (lig == 1 && diag == 1)\n\t    return true;\n\n\t/* il faut toujours être original */\n\tif (contains(nbre,lig-1,diag)) {\n\t    System.out.println(\"Nombre duppliqué \"+nbre);\n\t    return false;\n\t}\n\n\t/* Il faut être la différence des ancêtres (sauf sur la première ligne) */\n\tif (lig > 1) {\n\t    int n1 = valueAt(lig-1,diag-1);\n\t    int n2 = valueAt(lig-1,diag);\n\n\t    if (nbre != Math.abs(n1 - n2) ) {\n\t\tSystem.out.println(\"soustraction ratée \"+nbre);\n\t\treturn false;\n\t    }\n\t}\n\n\t/* Tous les tests ont été passés avec succès */\n\treturn true;\n    } // diagonaleCorrecte(int, int)\n",
        "methodStartingLine": 108,
        "methodEndingLine": 144,
        "jml": "//@ requires lig >= 1&& lig <= diag+1 && diag >= 1 && diag <= hauteur() ;"
    },
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/04-tdp-pyramides/java/old/PyramideVite.java",
        "code": "    private  /*@pure@*/ boolean contains(int val, int lig, int diag) {\n\t/* On tient compte de l'implantation de la pyramide par soucis d'optimisation */\n\n\tint fin = indice(lig,diag);\n\tfor (int i=0; i < fin; i++) {\n\n\t    if (val == elements[i])\n\t\treturn true;\n\t}\n\n\treturn false;\n    }//contains\n",
        "methodStartingLine": 155,
        "methodEndingLine": 166,
        "jml": "//@ requires lig >= 1 && lig <= hauteur() && diag >= 1 && diag <= hauteur();"
    },
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/04-tdp-pyramides/java/old/PyramideVite.java",
        "code": "    private void setValueAt(int v, int lig, int diag){\n\telements[indice(lig,diag)] = v;\n\tnbPris[v-1] = true;\n    }//setValueAt\n",
        "methodStartingLine": 182,
        "methodEndingLine": 185,
        "jml": "//@ requires nombreAutorise(v) && lig >= 1 \n//@ ensures valueAt(lig,diag) == v ;"
    },
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/04-tdp-pyramides/java/old/PyramideVite.java",
        "code": "    public void remplir(){\n\tremplir(1); \t// on commence a la diagonale 1\n    } \n",
        "methodStartingLine": 197,
        "methodEndingLine": 199,
        "jml": "//@ ensures correcte() ;"
    },
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/04-tdp-pyramides/java/old/PyramideVite.java",
        "code": "    private boolean remplir(int diag){\n\t// Itération conditionnelle parcourt le domaine [count .. 1]\n        // Arret lorsqu'une solution est trouvee\n\n\tif (diag > hauteur) \n\t    return true;\n\n\tfor (int k=count(); k>=1; k--) {\n\n\t    // si k est déjà utilisé, on passe au tour de boucle suivant\n\t    if (!contains(k)) {\n\n\t\t// Essayer de propager k sur la diagonale\n\n\t\tif (propager(diag,k)) {\n\t\t    // La propagation a été faite, on essaie de remplir la suite\n\t\t    if (remplir(diag+1)) {\n\t\t\t// L'appel récursif est une réussite : on tient une solution\n\t\t\treturn true;\n\t\t    }\n\t\t}\n\t      \n\t    } // k n'est pas encore pris\n        }//while\n\treturn false;\n    }//remplir(int)\n",
        "methodStartingLine": 204,
        "methodEndingLine": 229,
        "jml": "//@ requires diag >= 1 && diag <= hauteur() + 1 && correcte(diag-1);\n//@ ensures  (\\result && correcte()) || !\\result  ;"
    },
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/04-tdp-pyramides/java/old/PyramideVite.java",
        "code": "    private boolean propager(int diag, int val){\n\t// On pose val en haut de la diagonale\n        setValueAt(val,1,diag);\n\n        // On essaie de propager sur le reste de la diagonale\n\n        // Itération conditionnelle portant sur le domaine [ 2 .. diag ]\n        // On s'arrête dès que les contraintes ne sont plus respectées\n\n\tint lig = 2;\n\tint nbre = val;\n\twhile (lig <= diag) {\n\t    /** invariant\n\t\t-- la diagonale diag est <<bien construite>> jusqu'en lig-1\n\t\tdiagonaleCorrecte(lig-1,diag)\n\t    **/\n\t    /** variant         diag - lig  **/\n\n\t    nbre -= valueAt(lig-1,diag-1);    // évite deux accès dans elements\n\t    nbre = Math.abs(nbre);\n            // On s'assure que le nombre ainsi calculé n'est pas déjà utilisé\n\t    if (contains(nbre)) {\n\t\tlig--;\n\t\twhile (lig>=1) {\n\t\t    unsetValueAt(lig,diag);\n\t\t    lig--;\n\t\t}\n\t\treturn false;\n\t    }\n\n\t    // Le nombre n'est pas utilisé; on le pose et on continue\n\t    setValueAt(nbre,lig,diag);\n\t    lig++;\n\t}//while\n\treturn true;\n    }//propager(int,int)\n",
        "methodStartingLine": 239,
        "methodEndingLine": 274,
        "jml": "//@ requires diag >= 1 && diag <= hauteur() && val >= 1 && val <= count();\n//@ ensures (!\\result)  || (\\result && diagonaleCorrecte(diag,diag)) ;"
    },
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/03-tdp-dicho-knapsack/src/knap/KnapsackSolution.java",
        "code": "    public void prendObjet(int i)   { \n\tpris[i] = true; \n\tvaleurTotale += valeur[i];\n    }\n",
        "methodStartingLine": 60,
        "methodEndingLine": 63,
        "jml": "//@ requires !getPris(i) ;"
    },
    {
        "repository": "github.com/mquinson/algo-prog",
        "file": "TD/03-tdp-dicho-knapsack/src/knap/KnapsackSolution.java",
        "code": "    public void poseObjet(int i) {\n\tpris[i] = false; \n\tvaleurTotale -= valeur[i];\n    }\n",
        "methodStartingLine": 65,
        "methodEndingLine": 68,
        "jml": "//@ requires getPris(i) ;"
    }
]