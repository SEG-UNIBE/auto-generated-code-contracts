{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/smtlib/jSMTLIB lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\n * This file is part of the SMT project.\n * Copyright 2010 David R. Cok\n * Created August 2010\n */\npackage org.smtlib;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.List;\n\nimport org.smtlib.ICommand.IScript;\nimport org.smtlib.IPos.IPosable;\n\n/** This interface represents the functionality for any class implementing an SMT-LIB term or formula */\npublic interface IExpr extends IAccept, IPosable, IAttributeValue {\n\t\n\t/** Helpful method that indicates the class of expression, used in human-readable messages. */\n\t//@ pure\n\tString kind();\n\n\t/** The interface defining the factory type for producing objects of various subtypes of IExpr;\n\t * the IPos argument is an optional argument giving information about the textual position of an expression. */\n\tstatic public interface IFactory {\n\t\t/** Creates a INumeral object; the argument must be a string of digits. */\n\t\tINumeral numeral(String v);\n\t\t/** Creates a INumeral object; the argument must be non-negative */\n\t\t//@ requires v \u003e= 0;\n\t\tINumeral numeral(long v);\n\t\t/** Creates a IDecimal object; the argument must be a string of digits with just one decimal point */\n\t\tIDecimal decimal(String v);\n\t\t/** The argument is a pure character string, with no Java or SMTLIB escapes or enclosing quotes */\n\t\tIStringLiteral unquotedString(String v);\n\t\t/** The argument is SMTLIB escaped, with enclosing quotes */\n\t\tIStringLiteral quotedString(String v);\n\t\t/** Creates a IKeyword object from a canonical string representation */\n\t\tIKeyword keyword(String v);\n\t\t/** Creates a IBinaryLiteral from a string of 0 and 1 digits */\n\t\tIBinaryLiteral binary(String v);\n\t\t/** Creates a IHexLiteral object from a string of hex digits (either case) */\n\t\tIHexLiteral hex(String v);\n\t\t/** Creates a ISymbol object from a canonical String representation of the symbol */\n\t\tISymbol symbol(String v);\n\t\t/** Creates an attribute with just a keyword and no attribute value */\n\t\tIAttribute\u003c?\u003e attribute(IKeyword k);\n\t\t/** Creates an attribute with a keyword and a value */\n\t\t\u003cT extends IAttributeValue\u003e IAttribute\u003cT\u003e attribute(IKeyword k, T value);\n\t\t/** Creates an attributed expression (an expression with a positive number of attributes) */\n\t\t//@ requires attributes.size() \u003e 0;\n\t\tIAttributedExpr attributedExpr(IExpr e, List\u003cIAttribute\u003c?\u003e\u003e attributes);\n\t\t/** Creates an attributed expression with just one attribute. */\n\t\t\u003cT extends IAttributeValue\u003e IAttributedExpr attributedExpr(IExpr e, IKeyword key, /*@Nullable*/T value);\n\t\t/** Creates a function expression (perhaps with an empty argument list) */\n        IFcnExpr fcn(IQualifiedIdentifier id, List\u003cIExpr\u003e args);\n\t\t/** Creates a function expression (perhaps with an empty argument list) */\n        IFcnExpr fcn(IQualifiedIdentifier id, IExpr... args);\n        /** Creates a parameterized identifier from a symbol and a non-empty list of numerals */\n        //@ requires num.size() \u003e 0;\n\t\tIParameterizedIdentifier id(ISymbol symbol, List\u003cINumeral\u003e num);\n\t\t/** Creates a 'as' identifier from an identifier and a sort qualifier */\n\t\tIAsIdentifier id(IIdentifier identifier, ISort qualifier);\n\t\t/** Creates a Let expression */\n\t\t//@ requires bindings.size() \u003e 0;\n\t\tILet let(List\u003cIBinding\u003e bindings, IExpr e);\n\t\t/** Creates a binding for a Let expression */\n\t\tIBinding binding(ISymbol symbol, IExpr expr);\n\t\t/** Creates a parameter declaration */\n\t\tIDeclaration declaration(ISymbol symbol, ISort sort);\n\t\t/** Creates a Forall expression */\n\t\t//@ requires params.size() \u003e 0;\n        IForall forall(List\u003cIDeclaration\u003e params, IExpr e);\n        IForall forall(List\u003cIDeclaration\u003e params, IExpr e, List\u003cIExpr\u003e patterns);\n\t\t/** Creates a Exists expression */\n\t\t//@ requires params.size() \u003e 0;\n        IExists exists(List\u003cIDeclaration\u003e params, IExpr e);\n        IExists exists(List\u003cIDeclaration\u003e params, IExpr e, List\u003cIExpr\u003e patterns);\n\n\t\t/** Creates a command script from a file of commands or a list of commands */\n\t\tIScript script(/*@Nullable*/IStringLiteral filename, /*@Nullable*/List\u003cICommand\u003e commands);\n\n\t\t/** Creates an error expression */\n\t\tIError error(String text);\n\n\t}\n\t\n\t/** This interface represents all literal (explicit constant) expressions. */\n\tstatic public interface ILiteral extends IExpr, IAttributeValue {\n\t}\n\t\n\t/** This interface represents non-negative integers of arbitrary size. */\n\tstatic public interface INumeral extends ILiteral {\n\t\t//@ ensures compareTo(BigInteger.ZERO) \u003e= 0;\n\t\t/*@ pure */\n\t\tBigInteger value();\n\t\t\n\t\t//@ ensures value().compareTo(BigInteger.valueOf(Integer.INT_MAX)) \u003c= 0 ==\u003e value().intValue() == \\result;\n\t\t//@ ensures \\result \u003e= 0;\n\t\t/*@ pure */\n\t\tint intValue();\n\t\t\n\t}\n\t\n\t/** This interface represents non-negative decimal numbers of arbitrary size\n\t * (i.e. an arbitrary non-negative integer divided by an arbitrary non-negative power of ten).\n\t */\n\tstatic public interface IDecimal extends ILiteral {\n\t\t//@ pure\n\t\tBigDecimal value();\n\t}\n\t\n\t/** This interface represents SMT-LIB ids; equal ids have equal (using .equals) values\n\t * of value().\n\t */\n\tstatic public interface ISymbol extends IAttributeValue, IIdentifier {\n\t\t/** A String giving the canonical value of symbol. */\n\t\t//@ pure\n\t\tString value();\n\n\t\t/** A printable String giving the original text of this symbol. */\n\t\t//@ pure\n\t\t@Override\n\t\tString toString();\n\t}\n\t\n\t/** This interface represents SMT-LIB attribute and infoflag names. */\n\tstatic public interface IKeyword extends IAccept, IPosable{\n\t\t/** A canonical representation of keyword key */\n\t\t//@ pure\n\t\tString value();\n\t\t\n\t\t/** The original textual representation of the keyword */\n\t\t//@ pure\n\t\t@Override\n\t\tString toString();\n\t\t\n\t\t/** Helpful method that indicates the class of expression, used in human-readable messages. */\n\t\t//@ pure\n\t\tString kind();\n\t\t\n\t\t@Override\n\t\tboolean equals(Object o);\n\t}\n\t\n\t/** This interface represents SMT-LIB binary literals */\n\tstatic public interface IBinaryLiteral extends ILiteral {\n\t\t/** Returns a canonical value of the binary literal: 0 and 1 digits from MSB to LSB */\n\t\tString value();\n\t\t\n\t\t/** The binary value as an unsigned integer */\n\t\tBigInteger intValue();\n\t\t\n\t\t/** Number of binary bits */\n\t\tint length();\n\t}\n\t\n\t/** This interface represents SMT-LIB hex literals */\n\tstatic public interface IHexLiteral extends ILiteral {\n\t\t/** Returns a canonical value of the hex literal; lower-case hex digits from most-significant to least-significant */\n\t\tString value(); \n\t\t\n\t\t/** The hex value as an unsigned integer */\n\t\tBigInteger intValue();\n\t\t\n\t\t/** Number of hex digits */\n\t\tint length();\n\t}\n\t\n\t// FIXME - document toString for all interfaces\n\t// FIXME - review headSymbol, head\n\t// FIXME - review IParameter, ILetParameter\n\t\n\t/** This interface represents SMT-LIB string literals */\n\tstatic public interface IStringLiteral extends ILiteral {\n\t\t/** Returns the value without enclosing quotes and without any escape sequences; there may be explicit new line (and other white space characters) */\n\t\t//@ pure\n\t\tString value();\n\n\t\t/** Returns a value with enclosing quotes and appropriate SMT-LIB escape sequences so that the String value\n\t\t * can be represented with SMT-LIB printable characters; the result may have explicit newline characters. */\n\t\t//@ pure\n\t\t@Override\n\t\tString toString();\n\t}\n\t\n\t/** This interface represents SMT-LIB expressions that are a function identifier applied to one or more arguments. */\n\tstatic public interface IFcnExpr extends IExpr {\n\t\t/** The function identifier */\n\t\t//@ pure\n\t\tIQualifiedIdentifier head();\n\t\t\n\t\t/** The arguments of the function */\n\t\t//@ ensures \\result.size() \u003e 0;\n\t\t//@ pure\n\t\tList\u003cIExpr\u003e args();\n\t}\n\n\t/** This interface represents SMT-LIB identifiers for function ids (either ids or parameterized ids\n\t * or as-type identifiers) */\n\tstatic public interface IQualifiedIdentifier extends IExpr {\n\t\t/** The head symbol of the identifier */\n\t\tISymbol headSymbol();\n\t}\n\t\n\t/** This interface represents SMT-LIB identifiers (either ids or parameterized ids) */\n\tstatic public interface IIdentifier extends IQualifiedIdentifier {\n\t\t/** The head symbol of the identifier */\n\t\t@Override\n\t\tISymbol headSymbol();\n\n\t}\n\t\n\t/** This interface represents SMT-LIB identifiers that are sort qualifiers on function ids */\n\tstatic public interface IAsIdentifier extends IQualifiedIdentifier {\n\t\t/** The head of the identifier */\n\t\tIIdentifier head();\n\t\t\n\t\t/** The head symbol of the identifier */\n\t\t@Override\n\t\tISymbol headSymbol();\n\n\t\t/** The Sort qualifier */\n\t\tISort qualifier();\n\t}\n\t\n\t/** This interface represents SMT-LIB parameterized identifiers */\n\tstatic public interface IParameterizedIdentifier extends IIdentifier {\n\t\t\n\t\t// TODO - document\n\t\tIIdentifier head();\n\t\t\n\t\t/** The head symbol of the identifier */\n\t\t@Override\n\t\tISymbol headSymbol();\n\t\t\n\t\t/** The non-negative integer parameters of the identifier */\n\t\t//@ ensures \\result.size() \u003e 0;\n\t\tList\u003cINumeral\u003e numerals();\n\t}\n\t\n\t/** This interface represents an SMT-LIB expression with attributes. */\n\tstatic public interface IAttributedExpr extends IExpr {\n\t\t//@ pure\n\t\tIExpr expr();\n\t\t\n\t\t//@ ensures \\result.size() \u003e 0;\n\t\t//@ pure\n\t\tList\u003cIAttribute\u003c?\u003e\u003e attributes();\n\t}\n\t\n\t/** This interface represents an SMT-LIB attribute-value pair */\n\tstatic public interface IAttribute\u003cTT extends IAttributeValue\u003e extends IAccept, IPosable, IResponse {\n\t\t//@ pure\n\t\tIKeyword keyword();\n\t\t\n\t\t//@ pure\n\t\t/*@Nullable*/ TT attrValue();\n\t}\n\t\n\t/** This interface represents a declaration of a parameter and its sort */\n\tstatic public interface IDeclaration extends IAccept, IPosable {\n\t\tISymbol parameter();\n\t\tISort sort();\n\t}\n\t\n\t/** This interface represents a binding of a parameter and an expression */\n\tstatic public interface IBinding extends IAccept, IPosable {\n\t\tISymbol parameter();\n\t\tIExpr expr();\n\t}\n\t\n\t/** This interface represents an SMT-LIB let-expression */\n\tstatic public interface ILet extends IExpr {\n\t\t//@ ensures \\result.size() \u003e 0;\n\t\tList\u003cIBinding\u003e bindings();\n\t\tIExpr expr();\n\t}\n\n\t/** This interface represents an SMT-LIB quantified forall expression */\n\tstatic public interface IForall extends IExpr {\n\t\t//@ ensures \\result.size() \u003e 0;\n\t\tList\u003cIDeclaration\u003e parameters();\n\t\tIExpr expr();\n\t}\n\t\n\t/** This interface represents an SMT-LIB quantified exists expression */\n\tstatic public interface IExists extends IExpr {\n\t\t//@ ensures \\result.size() \u003e 0;\n\t\tList\u003cIDeclaration\u003e parameters();\n\t\tIExpr expr();\n\t}\n\t\n\t/** This interface represents an error, e.g. a parsing error that is part of a larger\n\t * expression.  Using an error expression as a sub-expression allows further error\n\t * checking to be performed.\n\t */\n\tstatic public interface IError extends IExpr {\n\t\t/** Returns an informational message about the error */\n\t\tString value();\n\t}\n\n}\n",
        "name": "IExpr.java",
        "path": "SMT/src/org/smtlib/IExpr.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMT/src/org/smtlib/IExpr.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 57,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires num.size() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires v \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 48,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires attributes.size() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 62,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires bindings.size() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 69,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires params.size() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 73,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires params.size() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 91,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures compareTo(BigInteger.ZERO) \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 95,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures value().compareTo(BigInteger.valueOf(Integer.INT_MAX)) \u003c= 0 ==\u003e value().intValue() == \\result;"
        },
        {
          "limitHit": false,
          "lineNumber": 96,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 191,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result.size() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 235,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result.size() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 244,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result.size() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 272,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result.size() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 279,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result.size() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 286,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result.size() \u003e 0;"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\r\n * This file is part of the SMT plugin project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.plugin;\r\n\r\n// FIXME - still needs review\r\n// FIXME - need to be sure that the showMessage... methods are called in the UI context when they need to be\r\n\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.Reader;\r\nimport java.io.StringBufferInputStream;\r\nimport java.util.Date;\r\nimport java.util.Iterator;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\n\r\nimport org.eclipse.core.resources.IContainer;\r\nimport org.eclipse.core.resources.IFile;\r\nimport org.eclipse.core.resources.IResource;\r\nimport org.eclipse.core.resources.IStorage;\r\nimport org.eclipse.core.runtime.CoreException;\r\nimport org.eclipse.core.runtime.IAdaptable;\r\nimport org.eclipse.core.runtime.IPath;\r\nimport org.eclipse.core.runtime.IProgressMonitor;\r\nimport org.eclipse.core.runtime.IStatus;\r\nimport org.eclipse.core.runtime.Status;\r\nimport org.eclipse.core.runtime.jobs.Job;\r\nimport org.eclipse.jface.dialogs.Dialog;\r\nimport org.eclipse.jface.dialogs.MessageDialog;\r\nimport org.eclipse.jface.resource.ImageDescriptor;\r\nimport org.eclipse.jface.text.IDocument;\r\nimport org.eclipse.jface.text.ITextSelection;\r\nimport org.eclipse.jface.viewers.ISelection;\r\nimport org.eclipse.jface.viewers.IStructuredSelection;\r\nimport org.eclipse.swt.SWT;\r\nimport org.eclipse.swt.widgets.Display;\r\nimport org.eclipse.swt.widgets.Shell;\r\nimport org.eclipse.ui.IEditorInput;\r\nimport org.eclipse.ui.IEditorPart;\r\nimport org.eclipse.ui.IPersistableElement;\r\nimport org.eclipse.ui.IStorageEditorInput;\r\nimport org.eclipse.ui.IWorkbenchPage;\r\nimport org.eclipse.ui.IWorkbenchWindow;\r\nimport org.eclipse.ui.IWorkingSet;\r\nimport org.eclipse.ui.PlatformUI;\r\nimport org.eclipse.ui.texteditor.IDocumentProvider;\r\nimport org.eclipse.ui.texteditor.ITextEditor;\r\nimport org.smtlib.IResponse;\r\nimport org.smtlib.SMT;\r\n\r\n/** This class holds utility values and methods to support the Eclipse plugin.\r\n * \r\n * @author David Cok\r\n *\r\n */\r\npublic class Utils {\r\n\t\r\n\tfinal static String windowHeader = \"SMT Plugin\";\r\n\r\n    /** This class is used to wrap arbitrary exceptions coming from the plug-in */\r\n    public static class PluginException extends RuntimeException {\r\n        /** Default serial version Symbol */\r\n        private static final long serialVersionUID = 1L;\r\n\r\n        /** Used to signal some unexpected error situation during plug-in processing. */\r\n        public PluginException(String error) {\r\n            super(error);\r\n        }\r\n        /** Used to signal some unexpected error situation during plug-in processing. */\r\n        public PluginException(String error, /*@NonNull*/ java.lang.Exception e) {\r\n            super(error,e);\r\n        }\r\n    }\r\n\r\n    /** The Symbol of the marker, which must match that in the plugin file. */\r\n    final public static  String SMT_MARKER_ID = Activator.PLUGIN_ID + \".SMTProblem\";\r\n\r\n    \r\n    /** Run a specific solver on the given text, belonging to the given file (unsaved edits), in a computational job. \r\n     * If solver is null, then use the default from the options.  Call the method from the UI thread.\r\n     */\r\n    public void runSolver(String solver, IFile file, String text) {\r\n    \tif (solver == null) solver = Preferences.poptions.defaultSolver.getStringValue();\r\n    \tString exec = \"\";\r\n    \t// FIXME - there is a lot of code in common with the previous method\r\n    \tif (!solver.equals(org.smtlib.Utils.TEST_SOLVER)) try {// FIXME - make \"test\" a symbolic constant\r\n    \t\texec = Preferences.getExec(solver);\r\n    \t\tif (exec == null) {\r\n    \t\t\tActivator.log.errorlog(\"SMT: INTERNAL ERROR: Could not find an executable option for \" + solver,null);\r\n    \t\t\treturn;\r\n    \t\t}\r\n    \t\tFile execFile = new File(exec);\r\n    \t\tif (!execFile.exists()) {\r\n    \t\t\tActivator.utils.showMessageInUI(null,windowHeader,\"The executable path for this solver does not appear to exist: \" + solver + \" \\\"\" + exec + \"\\\"\");\r\n    \t\t\treturn;\r\n    \t\t}\r\n    \t\tif (!execFile.canExecute()) {\r\n    \t\t\tActivator.utils.showMessageInUI(null,windowHeader,\"The executable path for this solver does not appear to be executable: \" + solver + \" \" + exec);\r\n    \t\t\treturn;\r\n    \t\t}\r\n    \t} catch (java.lang.Exception e) {\r\n\t\t\tActivator.log.errorlog(\"SMT: Could not find the executable for the solver \" + solver,e);\r\n\t\t\treturn;\r\n    \t}\r\n    \tif (Activator.verbose) Activator.log.logln(\"ISolver = \" + solver);\r\n    \ttry {\r\n\t\t\tSMT smt = new SMT();\r\n\t\t\tsmt.smtConfig = Activator.smtConfiguration.clone();\r\n\t\t\tsmt.smtConfig.files = null;\r\n\t\t\tString[] cmd = text == null ? new String[]{ \"-s\", solver, \"--exec\", exec, file.getLocation().toString() }\r\n\t\t\t\t\t\t\t\t\t\t: new String[]{ \"-s\", solver, \"--exec\", exec, \"--text\", text, file.getLocation().toString() };\r\n\t\t\tdeleteMarkers(file,null);\r\n\t\t\tboolean batch = false;\r\n\t\t\tif (batch) { // FIXME - get rid of launchJob now?\r\n\t\t\t\tlaunchJob(file.getLocation().toString(),smt,cmd,null);\r\n\t\t\t} else {\r\n\t\t\t\tinteractiveJob(file.getLocation().toString(),smt,cmd,null);\r\n\t\t\t}\r\n    \t} catch (java.lang.Exception e) {\r\n    \t\tActivator.log.errorlog(\"SMT - Internal exception\",e);\r\n    \t}\r\n    }\r\n    \r\n    SMT saved_smt = null;\r\n    \r\n    /** Executes the given command (cmd) by the smt instance as a computational (non-UI) Job\r\n     *\r\n     * @param name name of the Job\r\n     * @param smt the SMT instance in which to execute the commands\r\n     * @param cmd the command to execute\r\n     * @param shell the shell in which to display any UI messages\r\n     */\r\n    public void launchJob(String name, final SMT smt, final String[] cmd, /*@Nullable*/ final Shell shell) {\r\n    \tJob j = new Job(\"SMT Solver: \" + name) {\r\n    \t\t@Override\r\n    \t\tpublic IStatus run(IProgressMonitor monitor) {\r\n    \t\t\tboolean c = false;\r\n    \t\t\ttry {\r\n    \t\t\t\tsmt.smtConfig.log.numErrors = 0;\r\n    \t\t\t\tint exitCode = smt.exec(cmd);\r\n    \t\t\t\tString timestring = \"[\" + new Date().toString() + \"] \";\r\n    \t\t\t\tActivator.log.logln(timestring + \"Completed \" + cmd[1]\r\n    \t\t\t\t\t\t+ (exitCode == 0 ? \"\" : \" (exitcode=\" + exitCode +\")\")\r\n    \t\t\t\t\t\t+ (smt.smtConfig.log.numErrors == 0? \"\" : (\" : \" + smt.smtConfig.log.numErrors + \" errors\")) \r\n    \t\t\t\t\t\t+ (smt.checkSatStatus == null ? \"(no result)\" : (\" \" + smt.smtConfig.defaultPrinter.toString(smt.checkSatStatus)))\r\n    \t\t\t\t\t\t);\r\n    \t\t\t} catch (PluginException e) {\r\n    \t\t\t\tshowMessageInUI(shell,\"SMT PluginException\",e.getClass() + \" - \" + e.getMessage());\r\n    \t\t\t\tc = true;\r\n    \t\t\t}\r\n    \t\t\treturn c ? Status.CANCEL_STATUS : Status.OK_STATUS;\r\n    \t\t}\r\n    \t};\r\n    \tj.setUser(true); // true = initiated by an end-user\r\n    \tj.schedule();\r\n    }\r\n\r\n    /** Executes the given command within the given SMT object,\r\n     *  reporting results on the console and to the given shell;\r\n     *  'name' is an informational name giving the file being working on;\r\n     *  this method must be called in a computational thread.\r\n     */\r\n    public void interactiveJob(String name, SMT smt, String[] cmd, /*@Nullable*/ final Shell shell) {\r\n    \t\t\ttry {\r\n    \t\t\t\tsmt.smtConfig.log.numErrors = 0;\r\n    \t\t\t\tint exitCode = smt.exec(cmd);\r\n    \t\t\t\tString timestring = \"[\" + new Date().toString() + \"] \";\r\n    \t\t\t\tActivator.log.logln(timestring + \"Completed \" + cmd[1] + \" on \" + name + \" :\"\r\n    \t\t\t\t\t\t+ (exitCode == 0 ? \"\" : \" (exitcode=\" + exitCode +\")\")\r\n    \t\t\t\t\t\t+ (smt.smtConfig.log.numErrors == 0? \"\" : (\" : \" + smt.smtConfig.log.numErrors + \" errors\")) \r\n    \t\t\t\t\t\t+ (smt.checkSatStatus == null ? \"(no result)\" : (\" \" + smt.smtConfig.defaultPrinter.toString(smt.checkSatStatus)))\r\n    \t\t\t\t\t\t);\r\n    \t\t\t} catch (PluginException e) {\r\n    \t\t\t\tshowMessageInUI(shell,\"SMT PluginException\",e.getClass() + \" - \" + e.getMessage());\r\n    \t\t\t}\r\n\t\t\t\tsaved_smt = smt;\r\n    }\r\n\r\n    /** This runs a type-check only on the given text, in the UI thread. */\r\n    public void runCheck(IFile file, String text) {\r\n    \tif (text.length() \u003e 1000000) return; // FIXME - disable for large text\r\n    \ttry {\r\n\t\t\tSMT smt = new SMT();\r\n\t\t\t// FIXME - would rather not clone the configuration and allocate\r\n\t\t\t// a new log and ProblemListener on each edit, but we might want\r\n\t\t\t// to have any configuration parameters in force as they change\r\n\t\t\tsmt.smtConfig = Activator.smtConfiguration.clone();\r\n\t\t\tsmt.smtConfig.log = new org.smtlib.Log(smt.smtConfig);\r\n\t\t\tsmt.smtConfig.log.clearListeners(); // This removes the standard listener that would otherwise send log information to the console\r\n\t\t    smt.smtConfig.log.addListener(new ProblemListener());\r\n\r\n\t\t\tsmt.smtConfig.files = null;\r\n    \t\tString[] cmd = new String[]{ \"-s\", org.smtlib.Utils.TEST_SOLVER, \"--text\", text, file.getFullPath().toString() };\r\n    \t\tdeleteMarkers(file,null);\r\n    \t\tsmt.exec(cmd);\r\n    \t\t//launchJob(\"interactive\",smt,cmd,null);\r\n    \t} catch (java.lang.Exception e) {\r\n    \t\tActivator.log.errorlog(\"SMT - Internal exception\",e);\r\n    \t}\r\n    }\r\n\r\n\r\n    /** Returns the ITextSelection corresponding to a selection, if there is one (null otherwise). */\r\n    /*@Nullable*/\r\n    static public ITextSelection getSelectedText(ISelection selection) {\r\n        if (!selection.isEmpty() \u0026\u0026 selection instanceof ITextSelection) {\r\n            return (ITextSelection)selection;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    \r\n\r\n    /**\r\n     * This method interprets the selection returning a List of IResources, and\r\n     * ignoring things it does not know how to handle.  The selection is ignored\r\n     * if it is not an IStructuredSelection (e.g. ITextSelections are ignored).\r\n     * If the selection is empty and 'window'\r\n     * is non-null, then the routine attempts to find a resource that corresponds\r\n     * to the currently active editor.  The method expects to be called in the UI thread,\r\n     * \u003cUL\u003e\r\n     * \u003cLI\u003eIResource - added directly to list, whether a file or a container\r\n     * \u003cLI\u003eworking set - adds the elements of the working set if they can be\r\n     *          converted (through IAdaptor) to an IResource\r\n     * \u003cLI\u003eIJavaElement - adds the IResource that contains the element\r\n     * \u003cLI\u003eotherwise - ignored\r\n     * \u003c/UL\u003e\r\n     * \r\n     * @param selection  The selection to inspect\r\n     * @param window  The window in which a selected editor exists\r\n     * @param shell the shell to use in displaying information dialogs\r\n     * @return A List of IResources found in the selection\r\n     */\r\n    public List\u003cIResource\u003e getSelectedResources(ISelection selection, \r\n            /*@Nullable*/ IWorkbenchWindow window, /*@Nullable*/ Shell shell) {\r\n        List\u003cIResource\u003e list = new LinkedList\u003cIResource\u003e();\r\n        if (!selection.isEmpty() \u0026\u0026 selection instanceof IStructuredSelection) {\r\n            IStructuredSelection structuredSelection = (IStructuredSelection) selection;\r\n            for (Iterator\u003c?\u003e iter = structuredSelection.iterator(); iter.hasNext(); ) {\r\n                Object element = iter.next();\r\n                if (element instanceof IResource) {\r\n                    list.add((IResource)element);\r\n                } else if (element instanceof IWorkingSet) {\r\n                    for (IAdaptable a: ((IWorkingSet)element).getElements()) {\r\n                        IResource r = (IResource) a.getAdapter(IResource.class);\r\n                        if (r != null) list.add(r);\r\n                    }\r\n                    continue;\r\n                } else if (element instanceof IAdaptable) {\r\n                    IResource r = (IResource) ((IAdaptable)element).getAdapter(IResource.class);\r\n                    if (r != null) list.add(r);\r\n                }\t\r\n            }\r\n        } else {\r\n            // We had nothing selected\r\n            // Look for the active editor instead\r\n            try {\r\n                IEditorPart p = window.getActivePage().getActiveEditor();\r\n                IEditorInput e = p==null? null : p.getEditorInput();\r\n                IResource o = e==null ? null : (IFile)e.getAdapter(IFile.class);\r\n                if (o != null) {\r\n                    list.add(o);  // This is an IFile\r\n                } \r\n            } catch (PluginException ee) {\r\n            \t// These methods expect to be called in the UI thread.\r\n                Activator.log.errorlog(\"PluginException when finding selected targets: \" + ee,ee);\r\n                showMessage(shell,\"JML Plugin PluginException\",\"PluginException occurred when finding selected targets: \" + ee);\r\n            }\r\n        }\r\n        return list;\r\n    }\r\n\r\n    /** Creates a list of all the selected files, or files that are in selected containers. */\r\n    public List\u003cIFile\u003e getSelectedFiles(ISelection selection, \r\n            /*@Nullable*/ IWorkbenchWindow window, /*@Nullable*/ Shell shell) throws CoreException {\r\n        List\u003cIFile\u003e list = new LinkedList\u003cIFile\u003e();\r\n        if (!selection.isEmpty() \u0026\u0026 selection instanceof IStructuredSelection) {\r\n            IStructuredSelection structuredSelection = (IStructuredSelection) selection;\r\n            for (Iterator\u003c?\u003e iter = structuredSelection.iterator(); iter.hasNext(); ) {\r\n                Object element = iter.next();\r\n                if (element instanceof IResource) {\r\n                \taddFiles((IResource)element,list);\r\n                } else if (element instanceof IWorkingSet) {\r\n                    for (IAdaptable a: ((IWorkingSet)element).getElements()) {\r\n                        IResource r = (IResource) a.getAdapter(IResource.class);\r\n                        if (r != null) addFiles(r,list);\r\n                    }\r\n                } else if (element instanceof IAdaptable) {\r\n                    IResource r = (IResource) ((IAdaptable)element).getAdapter(IResource.class);\r\n                    if (r != null) addFiles(r,list);\r\n                }\r\n            }\r\n        }\r\n        return list;\r\n    }\r\n    \r\n    // TODO - duplicated with Preferences.solverNames, and should be made configurable\r\n\tfinal String[] solverList = new String[]{ \"simplify\", \"yices\", \"cvc\", \"z3_2_11\", \"z3_4_3\"};\r\n    \r\n\t/** Interprets the input string (the action id, as in action.getId()) to\r\n\t * determine which solvers to run, returning their names in a list.\r\n\t */\r\n    public List\u003cString\u003e getSolvers(String id) {\r\n    \tList\u003cString\u003e solvers = new LinkedList\u003cString\u003e();\r\n\t\tint i = id.lastIndexOf('.');\r\n\t\tString name = id.substring(i+1);\r\n    \tif (\"All\".equals(name)) {\r\n    \t\tfor (String s: solverList) solvers.add(s);\r\n    \t} else if (\"default\".equals(name)) {\r\n        \tname = Preferences.poptions.defaultSolver.getStringValue();\r\n        \tsolvers.add(name);\r\n    \t} else {\r\n    \t\tsolvers.add(name);\r\n    \t}\r\n    \treturn solvers;\r\n    }\r\n    \r\n    public void runJobs(final List\u003cString\u003e solvers, final List\u003cIFile\u003e files) {\r\n\t\tJob j = new Job(\"SMT Solving\") {\r\n\t\t\t@Override\r\n\t\t\tpublic IStatus run(IProgressMonitor monitor) {\r\n\t\t\t\tIStatus status = Status.OK_STATUS;\r\n\t\t\t\tif (monitor != null) {\r\n\t\t\t\t\tmonitor.beginTask(\"SMT solving\", solvers.size() * (files.isEmpty() ? 1 : files.size()));\r\n\t\t\t\t}\r\n        \t\tfor (IFile file: files) {\r\n        \t\t\tfor (String solver: solvers) {\r\n        \t\t\t\ttry {\r\n        \t\t\t\t\tif (monitor != null) monitor.subTask(solver + \" on \" + file.getName().substring(file.getName().lastIndexOf('/')+1));\r\n        \t\t\t\t\trunSolver(solver,file,text);\r\n        \t\t\t\t} catch (Exception e) {\r\n        \t\t\t\t\tActivator.log.errorlog(\"Exception while executing \" + solver + \" on \" + file.getName() + \": \" + e,e);\r\n        \t\t\t\t}\r\n        \t\t\t\tif (monitor != null) {\r\n        \t\t\t\t\tmonitor.worked(1);\r\n        \t\t\t\t\tif (monitor.isCanceled()) {\r\n        \t\t\t\t\t\tstatus = Status.CANCEL_STATUS;\r\n        \t\t\t\t\t\tbreak;\r\n        \t\t\t\t\t}\r\n        \t\t\t\t}\r\n        \t\t\t}\r\n        \t\t}\r\n\t\t\t\tif (monitor != null) {\r\n\t\t\t\t\tmonitor.done();\r\n\t\t\t\t}\r\n\t\t\t\treturn status;\r\n\t\t\t}\r\n\t\t};\r\n\t\tj.setUser(true); // true = initiated by an end-user\r\n\t\tj.schedule();\r\n    }\r\n    \r\n    /** Finds the selected editor; if it is a TextEditor, then if the editor is\r\n     * dirty, runs the solver on the text; if the editor is not dirty, runs the\r\n     * solver on the file. Returns true if successfully found file or text on which\r\n     * to run; returns false otherwise.\r\n     * \r\n     * This must be called in the UI thread; executes the check in a computational Job.\r\n     * */\r\n    public boolean runSolverOnSelectedEditor(String solver, List\u003cIFile\u003e files) throws CoreException {\r\n\t\tfor (IFile r: files) runSolver(solver,r,text);\r\n        return true;\r\n    }\r\n    \r\n    String text;\r\n    \r\n    // FIXME - document\r\n    public List\u003cIFile\u003e resources(ISelection selection, \r\n            /*@Nullable*/ IWorkbenchWindow window, /*@Nullable*/ Shell shell) throws CoreException {\r\n    \tIFile file = null;\r\n\t\tList\u003cIFile\u003e list = new LinkedList\u003cIFile\u003e();\r\n\t\ttext = null;\r\n    \ttry {\r\n    \t\tIWorkbenchPage page = window == null ? null : window.getActivePage();\r\n    \t\tIEditorPart p = page == null ? null : window.getActivePage().getActiveEditor();\r\n    \t\tIEditorInput e = p==null? null : p.getEditorInput();\r\n    \t\tfile = e==null ? null : (IFile)e.getAdapter(IFile.class);\r\n    \t\tif (file == null) return null;\r\n\t\t\tif (p instanceof ITextEditor) {\r\n\t\t\t\tlist.add(file);\r\n\t\t\t\tif (p.isDirty()) {\r\n\t\t\t\t\tIDocumentProvider doc = ((ITextEditor)p).getDocumentProvider();\r\n\t\t\t\t\tif (doc == null) return null;\r\n\t\t\t\t\tIDocument d = doc.getDocument(e);\r\n\t\t\t\t\tif (d == null) return null;\r\n\t\t\t\t\ttext = d.get();\r\n\t\t\t\t}\r\n\t\t\t}\r\n    \t} catch (PluginException ee) {\r\n    \t\t// These calls expect to be in the UI thread\r\n    \t\tActivator.log.errorlog(\"PluginException when finding selected targets: \" + ee,ee);\r\n    \t\tshowMessage(shell,\"JML Plugin PluginException\",\"PluginException occurred when finding selected targets: \" + ee);\r\n    \t}\r\n    \treturn list;\r\n    }\r\n    \r\n    /** This adds files in the given resource to the list; if the resource is a container, it \r\n     * adds the files that are in the container.\r\n     */\r\n    private void addFiles(IResource resource, List\u003cIFile\u003e list) throws CoreException {\r\n    \tif (resource instanceof IFile) {\r\n    \t\tif (resource.getName().toString().endsWith(org.smtlib.Utils.SUFFIX)) {\r\n        \t\t//Activator.log.log(\"ADDING \" + resource.getLocation().toString());\r\n    \t\t\tlist.add((IFile)resource);\r\n    \t\t}\r\n    \t\treturn;\r\n    \t} else if (resource instanceof IContainer) {\r\n    \t\tfor (IResource r: ((IContainer)resource).members()) {\r\n    \t\t\taddFiles(r,list);\r\n    \t\t}\r\n    \t}\r\n    }\r\n\r\n\r\n    // FIXME - should resource things be happening in another thread?\r\n    /** Deletes all JML markers from the items selected, right within the UI thread,\r\n     * without a progress dialog.  The resources for which markers are deleted are\r\n     * those returned by Utils.getSelectedResources.   This should be called from\r\n     * the UI thread.\r\n     * @param selection the IStructuredSelection whose markers are to be deleted\r\n     * @param window the current workbench window, or null (used in getSelectedResources)\r\n     * @param shell the current Shell, or null for the default shell (for message dialogs)\r\n     */\r\n    public void deleteMarkersInSelection(ISelection selection, IWorkbenchWindow window, Shell shell) {\r\n        List\u003cIResource\u003e list = getSelectedResources(selection,window,shell);\r\n        //list.add(ResourcesPlugin.getWorkspace().getRoot()); // FIXME - temporarily here to clear out unrooted markers\r\n        if (list.isEmpty()) {\r\n            showMessage(shell,windowHeader,\"Nothing appropriate to delete markers of\");\r\n            return;\r\n        }\r\n        deleteMarkers(list,shell);\r\n        return;\r\n    }\r\n\r\n\r\n    /** This class is an implementation of the interfaces needed to provide input\r\n     * to and launch editors in the workspace.\r\n     * @author David R. Cok\r\n     */\r\n    public static class StringStorage implements IStorage, IStorageEditorInput {\r\n        /** The initial content of the editor */\r\n        private String content;\r\n        /** The name of storage unit (e.g. the file name) */\r\n        private String name;\r\n        \r\n        /** A constructor for a new storage unit */\r\n        //@ assignable this.*;\r\n        public StringStorage(String content, String name) { \r\n            this.content = content; \r\n            this.name = name; \r\n        }\r\n        \r\n        /** Interface method that returns the contents of the storage unit */\r\n        //JAVA16 @Override\r\n        public InputStream getContents() throws CoreException {\r\n            return new StringBufferInputStream(content);\r\n        }\r\n\r\n        /** Returns the path to the underlying resource\r\n         * @return null (not needed for readonly Strings)\r\n         */\r\n        //JAVA16 @Override\r\n        public IPath getFullPath() {\r\n            return null;\r\n        }\r\n\r\n        /** Returns the name of the storage object \r\n         * @return the name of the storage unit\r\n         */\r\n        //JAVA16 @Override\r\n        public String getName() { return name; }\r\n\r\n        /** Returns whether the storage object is read only\r\n         * @return always true\r\n         */\r\n        //JAVA16 @Override\r\n        public boolean isReadOnly() { return true; }\r\n\r\n        /** Returns the object adapted to the given class.  It appears we can\r\n         * ignore this and always return null.\r\n         * @return null\r\n         */\r\n        //JAVA16 @Override\r\n        public /*@Nullable*/ Object getAdapter(Class arg0) { return null; }\r\n\r\n        /** Returns self\r\n         * @return this object\r\n         */\r\n        //@ ensures \\return == this;\r\n        //JAVA16 @Override\r\n        public IStorage getStorage() throws CoreException {\r\n            return (IStorage)this;\r\n        }\r\n        \r\n        /** Returns whether the underlying storage object exists\r\n         * @return always true\r\n         */\r\n        //JAVA16 @Override\r\n        public boolean exists() {\r\n            return true;\r\n        }\r\n        \r\n        /** Returns an ImageDescriptor, here ignored\r\n         * @return always null\r\n         */\r\n        //JAVA16 @Override\r\n        public /*@Nullable*/ ImageDescriptor getImageDescriptor() {\r\n            return null;\r\n        }\r\n        \r\n        /** Returns a corresponding Persistable object, here ignored\r\n         * @return always null\r\n         */\r\n        //JAVA16 @Override\r\n        public /*@Nullable*/ IPersistableElement getPersistable() {\r\n            return null;\r\n        }\r\n        \r\n        /** Return the text desired in a tool tip, here the name of the\r\n         * storage unit\r\n         */\r\n        //@NonNull\r\n        //JAVA16 @Override\r\n        public String getToolTipText() {\r\n            return name;\r\n        }\r\n\r\n    }\r\n\r\n    /** Launches a read-only text editor with the given content and name\r\n     * @param content the content of the editor\r\n     * @param name the name (as in the title) of the editor\r\n     */\r\n    public void launchEditor(String content,String name) {\r\n        try {\r\n            IEditorInput editorInput = new StringStorage(content,name);\r\n            IWorkbenchWindow window = PlatformUI.getWorkbench().getActiveWorkbenchWindow();\r\n            if (window == null) {\r\n                showMessageInUI(null,\"SMT PluginException\",\"No window found for editor named \" + name);\r\n            \treturn;\r\n            }\r\n            IWorkbenchPage page = window.getActivePage();\r\n            if (page == null) {\r\n                showMessageInUI(null,\"SMT PluginException\",\"No active page found for editor named \" + name);\r\n            \treturn;\r\n            }\r\n\r\n            //            IEditorPart[] parts = page.getEditors();\r\n            //            for (IEditorPart e: parts) Log.log(\"EDITOR \" + e.getEditorSite().getId());\r\n            page.openEditor(editorInput, \"org.eclipse.ui.DefaultTextEditor\");\r\n        } catch (java.lang.Exception e) {\r\n            showMessageInUI(null,\"SMT PluginException\",e.getMessage());\r\n\t\t}\r\n    }\r\n\r\n    /** Deletes the SMT_MARKER_ID markers in any of the objects in the List that are \r\n     * IResource objects; if the object is a container, markers are deleted for\r\n     * any resources in the container; other kinds of objects are ignored.\r\n     * Expects to be called from the UI thread.\r\n     * @param \u003cT\u003e just the type of the list\r\n     * @param list a list of objects whose markers are to be deleted\r\n     * @param shell the current shell for dialogs (or null for default)\r\n     */\r\n    public \u003cT extends IResource\u003e void deleteMarkers(List\u003cT\u003e list, /*@Nullable*/ Shell shell) {\r\n    \tStringBuilder sb = new StringBuilder();\r\n        for (T t: list) {\r\n            IResource resource = (IResource)t;\r\n            String s = deleteMarkers(resource,shell);\r\n            if (s != null) { sb.append(s); sb.append(\"\\n\"); }\r\n        }\r\n        String ss = sb.toString();\r\n        if (!ss.isEmpty()) Activator.utils.showMessage(shell,windowHeader,ss);\r\n    }\r\n    \r\n    /** Deletes any SMT_MARKER_ID markers on the given resource, returns an error message, if any (else null);\r\n     * expects to be called from the UI thread. */\r\n    public /*@Nullable*/ String deleteMarkers(IResource resource, /*@Nullable*/ Shell shell) {\r\n\t\ttry {\r\n\t\t\ttry {\r\n\t\t\t\tif (Activator.verbose) Activator.log.logln(\"Deleting markers in \" + resource.getName());\r\n\t\t\t\tresource.deleteMarkers(SMT_MARKER_ID, false,\r\n\t\t\t\t\t\tIResource.DEPTH_INFINITE);\r\n\t\t\t} catch (CoreException e) {\r\n\t\t\t\tString msg = \"Failed to delete markers on \"\r\n\t\t\t\t\t\t+ resource.getProject();\r\n\t\t\t\tActivator.log.errorlog(msg, e);\r\n\t\t\t}\r\n\t\t} catch (PluginException e) {\r\n\t\t\tActivator.log.errorlog(\"PluginException while deleting markers: \" + e, e);\r\n\t\t\treturn \"PluginException while deleting markers \"\r\n\t\t\t\t\t\t\t+ (resource != null ? \"on \" + resource.getName()\r\n\t\t\t\t\t\t\t\t\t: \"\");\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n \r\n    /**\r\n     * Displays a message in a dialog in the UI thread - this may\r\n     * be called from other threads.\r\n     * @param sh  The shell to use to display the dialog, or \r\n     *      a top-level shell if the parameter is null\r\n     * @param title  The title of the dialog window\r\n     * @param msg  The message to display in the dialog\r\n     */\r\n    public void showMessageInUI(/*@Nullable*/ Shell sh, \r\n            final String title, final String msg) {\r\n        final Shell shell = sh;\r\n        Display d = shell == null ? Display.getDefault() : shell.getDisplay();\r\n        d.asyncExec(new Runnable() {\r\n            public void run() {\r\n                MessageDialog.openInformation(\r\n                        shell,\r\n                        title,\r\n                        msg);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Displays a message in a non-modal dialog in the UI thread - this may\r\n     * be called from other threads.\r\n     * @param sh  The shell to use to display the dialog, or \r\n     *      a top-level shell if the parameter is null\r\n     * @param title  The title of the dialog window\r\n     * @param msg  The message to display in the dialog\r\n     */\r\n    public void showMessageInUINM(/*@Nullable*/ Shell sh, \r\n            final String title, final String msg) {\r\n        final Shell shell = sh;\r\n        Display d = shell == null ? Display.getDefault() : shell.getDisplay();\r\n        d.asyncExec(new Runnable() {\r\n            public void run() {\r\n                Dialog d = new NonModalDialog(\r\n                        shell,\r\n                        title,\r\n                        msg);\r\n                d.open();\r\n            }\r\n        });\r\n    }\r\n\r\n    // FIXME this does not seem to be working\r\n    static public class NonModalDialog extends MessageDialog {\r\n        final static String[] buttons = { \"OK\" };\r\n        public NonModalDialog(Shell shell, String title, String message) {\r\n            super(new Shell(),title,null,message,INFORMATION,buttons,0);\r\n            setShellStyle(getShellStyle()|SWT.MODELESS);\r\n            setBlockOnOpen(false);\r\n        }\r\n    }\r\n    \r\n\r\n    /**\r\n     * Displays a message in a information dialog; must be called from the UI thread.\r\n     * @param shell  Either the parent shell\r\n     * @param title  A title for the dialog window\r\n     * @param msg   The message to display in the dialog window\r\n     */\r\n    //@ requires msg != null;\r\n    public void showMessage(/*@Nullable*/Shell shell, /*@Nullable*/String title, String msg) {\r\n        MessageDialog.openInformation(\r\n                shell,\r\n                title,\r\n                msg);\r\n    }\r\n    \r\n    /** Shows an error dialog box for an exception; must be called from the UI thread */\r\n    public void topLevelException(/*@Nullable*/Shell shell, String title, java.lang.Exception e) {\r\n        //e.printStackTrace(sw); // TODO\r\n        showMessage(shell,\"SMT Top-level PluginException: \" + title,\r\n                e.toString());\r\n    }\r\n    \r\n    /** Shows the logic or theory file of the selected text; error dialogs if can't find an appropriate file to show. */\r\n    public void viewLogic(Shell shell, ISelection selection) {\r\n    \tString name = \"\";\r\n    \tString path = \"\";\r\n\t\tReader r = null;\r\n\t\tInputStream stream = null;\r\n    \ttry {\r\n    \t\tITextSelection tsel = Utils.getSelectedText(selection);\r\n    \t\tif (tsel == null) {\r\n    \t\t\tActivator.utils.showMessage(shell,windowHeader,\"Select the name of a logic or theory to show\");\r\n    \t\t\treturn;\r\n    \t\t}\r\n    \t\tname = tsel.getText();\r\n    \t\tif (name == null || name.length() == 0) {\r\n    \t\t\tActivator.utils.showMessage(shell,windowHeader,\"Select the name of a logic or theory to show\");\r\n    \t\t\treturn;\r\n    \t\t}\r\n    \t\tString dir = Preferences.poptions.logics.getValue();\r\n    \t\tif (dir != null) dir = dir.trim();\r\n    \t\t\r\n\t\t\tif (dir == null || dir.isEmpty()) {\r\n\t    \t\ttry {\r\n\t    \t\t\tstream = SMT.logicFinder.find(null,name,null);\r\n\t    \t\t\tif (stream == null) {\r\n\t    \t\t\t\treturn;\r\n\t    \t\t\t}\r\n\t\t    \t\tr = new InputStreamReader(stream);\r\n\t    \t\t} catch (IOException e) {\r\n\t\t\t\t\tshowMessage(shell,\"SMT View Logic\",\"Could not read the definition file for \" + name\r\n\t\t\t\t\t\t\t+ \"\\n\" + e.getMessage());\r\n\t\t\t\t\treturn;\r\n\t    \t\t} catch (org.smtlib.Utils.SMTLIBException e) {\r\n\t\t\t\t\tshowMessage(shell,\"SMT View Logic\",\"Could not read the definition file for \" + name\r\n\t\t\t\t\t\t\t+ \"\\n\" + e.errorResponse);\r\n\t\t\t\t\treturn;\r\n\t    \t\t}\r\n\t\t\t} else {\r\n\t\t\t\tString fname = dir + File.separator + name + org.smtlib.Utils.SUFFIX;\r\n\t\t\t\tif (Activator.verbose) Activator.log.logln(\"Trying to read logic file \" + fname);\r\n\t\t\t\tFile f = new File(fname);\r\n\t\t\t\tif (f.isFile()) r = new FileReader(f);\r\n\t\t\t}\r\n\t\t\tif (r == null) {\r\n\t\t\t\tshowMessage(shell,\"SMT View Logic\",\"Could not find a definition file for \" + name\r\n\t\t\t\t\t\t+ \"\\nTry setting the directory for logic definitions in the SMT preferences\");\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n    \t\tchar[] buf = new char[10000];\r\n    \t\tint p = 0;\r\n    \t\tint n = 0;\r\n    \t\ttry {\r\n    \t\t\twhile (p \u003c buf.length) {\r\n    \t\t\t\tn = r.read(buf,p,buf.length-p);\r\n    \t\t\t\tif (n == -1) break; \r\n    \t\t\t\tp += n;\r\n    \t\t\t}\r\n    \t\t\tActivator.utils.launchEditor(new String(buf,0,p),name);\r\n    \t\t} catch (IOException e) {\r\n    \t\t\tActivator.utils.showMessage(shell,windowHeader,\"Failed to read logic file for \" + name);\r\n    \t\t\tActivator.log.errorlog(\"Failed to read logic file for \" + name,e);\r\n    \t\t}\r\n    \t} catch (FileNotFoundException e) {\r\n    \t\tActivator.utils.showMessage(shell,windowHeader,\"Could not find logic or theory named \" + name + \"\\n(\" + path + \")\");\r\n\r\n    \t} catch (PluginException e) {\r\n    \t\tActivator.utils.topLevelException(shell,windowHeader,e);\r\n    \t} finally {\r\n    \t\ttry {\r\n    \t\t\tif (r != null) r.close();\r\n    \t\t\tif (stream != null) stream.close();\r\n    \t\t} catch (IOException e) {\r\n    \t\t\tActivator.log.errorlog(\"Failed to close reader for the logic file\",e);\r\n    \t\t}\r\n    \t}\r\n    }\r\n    \r\n    /** Performs a get-value command on the selected text. */\r\n    public void getValue(Shell shell, ISelection selection) {\r\n    \tString text = \"\";\r\n    \ttry {\r\n    \t\tITextSelection tsel = Utils.getSelectedText(selection);\r\n    \t\tif (tsel == null) {\r\n    \t\t\tActivator.utils.showMessage(shell,windowHeader,\"Select an expression whose value is wanted\");\r\n    \t\t\treturn;\r\n    \t\t}\r\n    \t\ttext = tsel.getText();\r\n    \t\tif (text == null || text.length() == 0) {\r\n    \t\t\tActivator.utils.showMessage(shell,windowHeader,\"Select an expression whose value is wanted\");\r\n    \t\t\treturn;\r\n    \t\t}\r\n    \t\tif (saved_smt == null) {\r\n    \t\t\tActivator.utils.showMessage(shell,windowHeader,\"There is no current model\");\r\n    \t\t\treturn;\r\n    \t\t}\r\n    \t\t\r\n    \t\tint e = saved_smt.execCommand(\"(get-value (\" + text + \"))\");\r\n    \t\tif (e != 0) {\r\n    \t\t\tActivator.utils.showMessage(shell,windowHeader,\"The selected text is not a valid expression:\\n\" + text);\r\n    \t\t} else {\r\n    \t\t\tIResponse response = saved_smt.lastResponse;\r\n    \t\t\tActivator.utils.showMessage(shell,windowHeader,\"Value: \" + saved_smt.smtConfig.defaultPrinter.toString(response));\r\n    \t\t}\r\n    \t} catch (PluginException e) {\r\n    \t\tActivator.utils.topLevelException(shell,windowHeader,e);\r\n    \t}\r\n    }\r\n\r\n}\r\n",
        "name": "Utils.java",
        "path": "SMTPlugin/src/org/smtlib/plugin/Utils.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMTPlugin/src/org/smtlib/plugin/Utils.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 495,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures \\return == this;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 665,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires msg != null;\r"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\r\n * This file is part of the SMT plugin project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.plugin;\r\n\r\nimport org.eclipse.jface.resource.JFaceResources;\r\nimport org.eclipse.swt.SWT;\r\nimport org.eclipse.swt.events.ModifyListener;\r\nimport org.eclipse.swt.events.MouseAdapter;\r\nimport org.eclipse.swt.events.MouseEvent;\r\nimport org.eclipse.swt.graphics.Font;\r\nimport org.eclipse.swt.layout.GridData;\r\nimport org.eclipse.swt.layout.GridLayout;\r\nimport org.eclipse.swt.widgets.Button;\r\nimport org.eclipse.swt.widgets.Composite;\r\nimport org.eclipse.swt.widgets.DirectoryDialog;\r\nimport org.eclipse.swt.widgets.FileDialog;\r\nimport org.eclipse.swt.widgets.Label;\r\nimport org.eclipse.swt.widgets.Shell;\r\nimport org.eclipse.swt.widgets.Text;\r\n\r\n/**\r\n * This class just holds a bunch of related classes which are\r\n * custom widgets for building dialogs.\r\n * \r\n * @author David Cok\r\n *\r\n */\r\npublic class Widgets {\r\n\r\n\r\n  /** \r\n   * A composite that lays its children out in a number of\r\n   * columns.\r\n   * \r\n   * @author David Cok\r\n   *\r\n   */\r\n  public static class HComposite extends Composite {\r\n    /**\r\n     * Constructs the composite as a member of the given\r\n     * parent and with the given number of columns.\r\n     * \r\n     * @param parent  The container into which to place this new widget\r\n     * @param cols    The number of columns of this widget\r\n     */\r\n    //@ requires cols \u003e 0;\r\n    public HComposite(/*@ non_null */ Composite parent,int cols) {\r\n      super(parent, SWT.NONE);\r\n      GridLayout layout = new GridLayout();\r\n      layout.numColumns = cols;\r\n      setLayout(layout);\r\n      GridData data = new GridData();\r\n      data.verticalAlignment = GridData.FILL;\r\n      data.horizontalAlignment = GridData.FILL;\r\n      setLayoutData(data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * A custom widget that lays out its children in one vertical\r\n   * column.\r\n   */\r\n  public static class VComposite extends Composite {\r\n    /**\r\n     * Constructs the composite as a member of the given\r\n     * parent.\r\n     * \r\n     * @param parent  The container into which to place this new widget\r\n     */\r\n    public VComposite(/*@ non_null */ Composite parent) {\r\n      super(parent, SWT.NONE);\r\n      GridLayout layout = new GridLayout();\r\n      layout.numColumns = 1;\r\n      setLayout(layout);\r\n      GridData data = new GridData();\r\n      data.verticalAlignment = GridData.FILL;\r\n      data.horizontalAlignment = GridData.FILL;\r\n      setLayoutData(data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * A custom widget that is a separator followed by a label,\r\n   * typically used as a title to a set of widgets below it.\r\n   * \r\n   * @author David Cok\r\n   */\r\n  public static class LabeledSeparator extends Composite {\r\n    /**\r\n     * @param parent  The container this widget is made part of\r\n     * @param label\t  The text to be used as the label in the widget\r\n     */\r\n    public LabeledSeparator(/*@ non_null */ Composite parent, \r\n            /*@ non_null */ String label) {\r\n      super(parent, SWT.NONE);\r\n      GridLayout layout = new GridLayout();\r\n      layout.numColumns = 2;\r\n      setLayout(layout);\r\n      GridData data = new GridData();\r\n      data.verticalAlignment = GridData.FILL;\r\n      data.horizontalAlignment = GridData.FILL;\r\n      setLayoutData(data);\r\n      new Label(this,SWT.SEPARATOR|SWT.HORIZONTAL);\r\n      new Label(this,SWT.NONE).setText(label);\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * A custom widget that is used to provide a way for the user\r\n   * to specify a file; it combines a label, a Browse button,\r\n   * and a text field.  The Browse button pops up a file browser;\r\n   * that lets the user browse for a file; the path of the selected\r\n   * file is then put into the text field.  Or the user can type into\r\n   * the text field directly.\r\n   * \r\n   * @author David Cok\r\n   */\r\n  public static class FileTextField extends VComposite {\r\n    /** The text field that shows the file path */\r\n    private Text text;\r\n    /** A String used for spaces */\r\n    final private static String tenspaces = \"          \";\r\n    // The length of this string defines the minimum size of the text field.\r\n    // FIXME - there must be a better way to set the size,\r\n    // and a better way to make a long string\r\n    /** A String used for spaces that helps set the size of the text widget */\r\n    final private static String spaces = tenspaces + tenspaces + tenspaces\r\n    + tenspaces + tenspaces + tenspaces + tenspaces + tenspaces + tenspaces;\r\n\r\n\r\n    /**\r\n     * Constructs the composite widget as a member of the given\r\n     * parent and with the given parameters.\r\n     * @param parent\tThe container this new widget is made part of\r\n     * @param label\t\tThe label to be used for this widget (e.g. the purpose of the directory being identified)\r\n     * @param initialValue  The initial value for the text field (a directory path)\r\n     * @param toolTipText   The explantory text used as a tooltip\r\n     * @param length    The size of the visible part of the field, in characters\r\n     *\t\t */\r\n    public FileTextField(/*@ non_null */ Composite parent,\r\n            /*@ non_null */ String label, \r\n            /*@ non_null */ String initialValue,\r\n            /*@ non_null */ String toolTipText,\r\n            int length) {\r\n      super(parent);\r\n      final Shell shell = parent.getShell();\r\n\r\n      // This is a composite widget with internals\r\n      // arranged as follows:\r\n      //   *********************************************\r\n      //   *   label     *  Browse button              *\r\n      //   *********************************************\r\n      //   *        Text field                         *\r\n      //   *********************************************\r\n\r\n      Composite hc = new HComposite(this,2);\r\n\r\n      new Label(hc,SWT.NONE).setText(label);\r\n\r\n      text = new Text(this,SWT.SINGLE);\r\n      String s = initialValue;\r\n      int n = spaces.length();\r\n      if (length \u003c n) n = length;\r\n      if (s.length() \u003c n) s += spaces.substring(0,n-s.length());\r\n      text.setText(s);\r\n      text.setToolTipText(toolTipText);\r\n      // Make the text fixed width and bold\r\n      Font f = JFaceResources.getFontRegistry().getBold(JFaceResources.TEXT_FONT);\r\n      text.setFont(f);\r\n      final Text t = text;\r\n\r\n      Button browse = new Button(hc, SWT.PUSH);\r\n      browse.setText(\"Browse\");\r\n      browse.setToolTipText(toolTipText);\r\n      browse.addMouseListener(new MouseAdapter() {\r\n    \t@Override\r\n        public void mouseUp(MouseEvent e) {\r\n          // TODO: Would be nice to start the directory browser\r\n          // in the location that is currently set in the text\r\n          // field, but there does not seem to be away to do that\r\n          FileDialog dd = new FileDialog(shell,SWT.OPEN);\r\n          String result = dd.open();\r\n          if (result != null) t.setText(result);\r\n        }\r\n      });\r\n    }\r\n\r\n    /** Returns the current value of the specified file path.\r\n     *\r\n     * @return the current value of the specified file path\r\n     */\r\n    //@ modifies \\nothing;\r\n    //@ ensures \\result != null;\r\n    public String value() {\r\n      return text.getText();\r\n    }\r\n\r\n    /**\r\n     * Sets the current value in the text field.\r\n     * \r\n     * @param v The text to display\r\n     */\r\n    public void setText(String v) {\r\n      text.setText(v);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * A custom widget that is used to provide a way for the user\r\n   * to specify a directory; it combines a label, a Browse button,\r\n   * and a text field.  The Browse button pops up a file system browser;\r\n   * that lets the user browse for a directory; the path of the selected\r\n   * directory is then put into the text field.  Or the user can type into\r\n   * the text field directly.\r\n   * \r\n   * @author David Cok\r\n   */\r\n  public static class DirTextField extends VComposite {\r\n    /** The text field that shows the directory path */\r\n    private Text text;\r\n    /** A String used for spaces */\r\n    final private static String tenspaces = \"          \";\r\n    // The length of this string defines the minimum size of the text field.\r\n    // FIXME - there must be a better way to set the size,\r\n    // and a better way to make a long string\r\n    /** A String used for spaces that helps set the size of the text widget */\r\n    final private static String spaces = tenspaces + tenspaces + tenspaces\r\n    + tenspaces + tenspaces + tenspaces + tenspaces + tenspaces + tenspaces;\r\n\r\n\r\n    /**\r\n     * Constructs the composite widget as a member of the given\r\n     * parent and with the given parameters.\r\n     * @param parent    The container this new widget is made part of\r\n     * @param label     The label to be used for this widget (e.g. the purpose of the directory being identified)\r\n     * @param initialValue  The initial value for the text field (a directory path)\r\n     * @param toolTipText   The explanatory text used as a tooltip\r\n     * @param length    The size of the visible part of the field, in characters\r\n     *       */\r\n    public DirTextField(/*@ non_null */ Composite parent,\r\n            /*@ non_null */ String label, \r\n            /*@ non_null */ String initialValue,\r\n            /*@ non_null */ String toolTipText,\r\n            int length) {\r\n      super(parent);\r\n      final Shell shell = parent.getShell();\r\n\r\n      // This is a composite widget with internals\r\n      // arranged as follows:\r\n      //   *********************************************\r\n      //   *   label     *  Browse button              *\r\n      //   *********************************************\r\n      //   *        Text field                         *\r\n      //   *********************************************\r\n\r\n      Composite hc = new HComposite(this,2);\r\n\r\n      new Label(hc,SWT.NONE).setText(label);\r\n\r\n      text = new Text(this,SWT.SINGLE);\r\n      String s = initialValue;\r\n      int n = spaces.length();\r\n      if (length \u003c n) n = length;\r\n      if (s.length() \u003c n) s += spaces.substring(0,n-s.length());\r\n      text.setText(s);\r\n      text.setToolTipText(toolTipText);\r\n      // Make the text fixed width and bold\r\n      Font f = JFaceResources.getFontRegistry().getBold(JFaceResources.TEXT_FONT);\r\n      text.setFont(f);\r\n      final Text t = text;\r\n\r\n      Button browse = new Button(hc, SWT.PUSH);\r\n      browse.setText(\"Browse\");\r\n      browse.setToolTipText(toolTipText);\r\n      browse.addMouseListener(new MouseAdapter() {\r\n    \t@Override\r\n        public void mouseUp(MouseEvent e) {\r\n          // TODO: Would be nice to start the directory browser\r\n          // in the location that is currently set in the text\r\n          // field, but there does not seem to be away to do that\r\n          DirectoryDialog dd = new DirectoryDialog(shell,SWT.OPEN);\r\n          String result = dd.open();\r\n          if (result != null) t.setText(result);\r\n        }\r\n      });\r\n    }\r\n    \r\n    public void addModifyListener(ModifyListener listener) {\r\n    \ttext.addModifyListener(listener);\r\n    }\r\n\r\n    /** Returns the current value of the specified directory path.\r\n     *\r\n     * @return the current value of the specified directory path\r\n     */\r\n    //@ modifies \\nothing;\r\n    //@ ensures \\result != null;\r\n    public String value() {\r\n      return text.getText();\r\n    }\r\n\r\n    /**\r\n     * Sets the current value in the text field.\r\n     * \r\n     * @param v The text to display\r\n     */\r\n    public void setText(String v) {\r\n      text.setText(v);\r\n    }\r\n  }\r\n  \r\n}\r\n",
        "name": "Widgets.java",
        "path": "SMTPlugin/src/org/smtlib/plugin/Widgets.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMTPlugin/src/org/smtlib/plugin/Widgets.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 48,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires cols \u003e 0;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 196,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 300,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result != null;\r"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\r\n * This file is part of the SMT plugin project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.plugin;\r\n\r\nimport java.util.List;\r\n\r\nimport org.eclipse.core.resources.IFile;\r\nimport org.eclipse.jface.action.IAction;\r\nimport org.eclipse.jface.viewers.ISelection;\r\nimport org.eclipse.swt.widgets.Shell;\r\nimport org.eclipse.ui.IWorkbenchWindow;\r\nimport org.eclipse.ui.IWorkbenchWindowActionDelegate;\r\n\r\n/**\r\n * This class holds the implementations of the utils in response to\r\n * menu items in the menubar and toolbar\r\n */\r\nabstract public class MenuActions implements IWorkbenchWindowActionDelegate {\r\n\r\n    // IWorkbenchWindowActionDelegate is the interface for actions that\r\n    // are contributed as menubar or toolbar items\r\n\r\n    /** Caches the value of the window, when informed of it. */\r\n    /*@Nullable*/ protected IWorkbenchWindow window;\r\n\r\n    /** Caches the value of the shell in which the window exists. */\r\n    /*@Nullable*/ protected Shell shell = null;\r\n\r\n    /** The current selection. */\r\n    /*@Nullable*/ protected ISelection selection;\r\n\r\n    /* (non-Javadoc)\r\n     * @see org.eclipse.ui.IActionDelegate#selectionChanged(org.eclipse.jface.action.IAction, org.eclipse.jface.viewers.ISelection)\r\n     */\r\n    //@ ensures this.selection != null;\r\n    //JAVA16 @Override\r\n    public final void selectionChanged(final IAction action, final ISelection selection) {\r\n        this.selection = selection;\r\n    }\r\n\r\n    /**\r\n     * We can use this method to dispose of any system\r\n     * resources we previously allocated.\r\n     * @see IWorkbenchWindowActionDelegate#dispose\r\n     */\r\n    //JAVA16 @Override\r\n    public void dispose() {\r\n    }\r\n\r\n    /**\r\n     * We will cache window object in order to\r\n     * be able to provide a parent shell for the message dialog.\r\n     * @param window The parent window\r\n     * @see IWorkbenchWindowActionDelegate#init\r\n     */\r\n    //JAVA16 @Override\r\n    public void init(IWorkbenchWindow window) {\r\n        this.window = window;\r\n        this.shell = window.getShell();\r\n    }\r\n\r\n    /** Called by the system in response to a menu selection (or other command).\r\n     * This should be overridden for individual menu items.\r\n     */\r\n    //JAVA16 @Override\r\n    abstract public void run(final IAction action);\r\n\r\n    /**\r\n     * This class implements the action for checking\r\n     * JML in the selected objects (which may be working sets, folders,\r\n     * or java files).  Applying the operation\r\n     * to a container applies it to all its contents recursively.\r\n     * The checks are done in a non-UI thread.\r\n     * \r\n     * @author David R. Cok\r\n     */\r\n    public static class RunSolver extends MenuActions {\r\n\r\n    \t@Override\r\n    \tpublic final void run(final IAction action) {\r\n    \t\ttry {\r\n    \t\t\tfinal List\u003cString\u003e solvers = Activator.utils.getSolvers(action.getId());\r\n    \t\t\tList\u003cIFile\u003e files = Activator.utils.getSelectedFiles(selection,window,shell);\r\n    \t\t\tActivator.utils.text = null; // TODO - setting 'text' through side-effects is a bad design\r\n        \t\tif (files.isEmpty()) files = Activator.utils.resources(selection,window,shell); // sets Activator.utils.text also\r\n        \t\tif (files.isEmpty()) {\r\n        \t\t\tActivator.utils.showMessageInUI(shell,\"SMT Run Solver\",\r\n        \t\t\t\t\t\"Failed to find a resource on which to run a solver (select one or more files or an editor)\");\r\n        \t\t\treturn;\r\n        \t\t}\r\n    \t\t\tActivator.utils.runJobs(solvers,files);\r\n    \t\t} catch (Exception e) {\r\n    \t\t\tActivator.utils.topLevelException(shell,\"MenuActions.RunSolver\",e);\r\n    \t\t}\r\n\r\n    \t}\r\n    }\r\n\r\n    /**\r\n     * This class implements the action that clears\r\n     * SMT markers.  It is performed entirely in the UI thread, with no\r\n     * progress reporting.  Its ought to be fast.\r\n     * \r\n     * @author David R. Cok\r\n     */\r\n    public static class DeleteMarkers extends MenuActions {\r\n        @Override\r\n        public final void run(final IAction action) {\r\n            try {\r\n                Activator.utils.deleteMarkersInSelection(selection,window,shell);\r\n            } catch (Exception e) {\r\n                Activator.utils.topLevelException(shell,\"MenuActions.DeleteMarkers\",e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Shows the content of the SMT logic or theory whose name is selected */\r\n    public static class ViewLogic extends MenuActions {\r\n        @Override\r\n        public final void run(final IAction action) {\r\n        \tActivator.utils.viewLogic(shell,selection);\r\n        }\r\n    }\r\n\r\n    /** Does a get-value command on the selected text */\r\n    public static class GetValue extends MenuActions {\r\n        @Override\r\n        public final void run(final IAction action) {\r\n        \tActivator.utils.getValue(shell,selection);\r\n        }\r\n    }\r\n\r\n}\r\n",
        "name": "MenuActions.java",
        "path": "SMTPlugin/src/org/smtlib/plugin/MenuActions.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMTPlugin/src/org/smtlib/plugin/MenuActions.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 37,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures this.selection != null;\r"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\r\n * This file is part of the SMT plugin project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.plugin;\r\n\r\n// FIXME : Needs a color selection widget\r\n\r\nimport org.eclipse.swt.SWT;\r\nimport org.eclipse.swt.events.ModifyListener;\r\nimport org.eclipse.swt.widgets.Button;\r\nimport org.eclipse.swt.widgets.Text;\r\nimport org.eclipse.swt.widgets.Combo;\r\nimport org.eclipse.swt.widgets.Composite;\r\n\r\n/**\r\n * This class is a base class for the controls that are used in\r\n * the property page; each control is connected to an Option object.\r\n * \r\n * @author David Cok\r\n *\r\n */\r\nabstract public class PreferenceWidget {\r\n\t\r\n\t/** The option object represented by this PreferenceWidget */\r\n\t/*@Nullable*/ AbstractPreference option;\r\n\t\r\n\t\r\n\t/**\r\n\t * Base class constructor, taking some common arguments.\r\n\t * \r\n\t * @param option The option that this widget represents.\r\n\t */\r\n\tpublic PreferenceWidget(/*@Nullable*/ AbstractPreference option) {\r\n\t\tthis.option = option;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Creates and adds the widget to the given control\r\n\t * @param parent The composite to add the widget to.\r\n\t */\r\n\tabstract public void addWidget(Composite parent);\r\n\t\r\n\t/**\r\n\t * Sets the UI widget to the built-in default value\r\n\t *\r\n\t */\r\n\tabstract public void setDefault();\r\n\t\r\n\t/**\r\n\t * Sets the value of the associated option based on the\r\n\t * current UI setting.\r\n\t * \r\n\t */\r\n\tabstract public void setOptionValue();\r\n\r\n\t\r\n\t/**\r\n\t * A UI widget that offers a selection from a fixed \r\n\t * set of strings,\r\n\t * corresponding to a ChoiceOption.\r\n\t *  \r\n\t * @author David Cok\r\n\t *\r\n\t */\r\n\tpublic static class ChoiceWidget extends PreferenceWidget {\r\n\t\t\r\n\t\t/** The widget used to get input from the user. */\r\n\t\t/*@Nullable*/ protected Combo widget = null;\r\n\t\t\r\n\t\t/**\r\n\t\t * A constructor that creates a Combo widget, initializing\r\n\t\t * it from the associated property.\r\n\t\t * \r\n\t\t * @param option The option with which the widget is associated\r\n\t\t */\r\n\t\t//@ pure\r\n\t\tpublic ChoiceWidget(AbstractPreference.ChoiceOption option) {\r\n\t\t\tsuper(option);\r\n\t\t}\r\n        \r\n\t\t/**\r\n\t\t * Creates the corresponding widget and adds it to the given\r\n\t\t * Composite widget; the UI widgets are recreated for each\r\n\t\t * instance of a property page.\r\n\t\t * @param parent The Composite that holds all of the option widgets\r\n\t\t */\r\n\t\t//@ ensures widget != null;\r\n\t\t@Override\r\n\t\tpublic void addWidget(Composite parent) {\r\n\t\t\tAbstractPreference.ChoiceOption opt = (AbstractPreference.ChoiceOption)option;\r\n\t\t\tComposite composite = new Widgets.HComposite(parent,2);\r\n\t\t\twidget = new Combo(composite, SWT.READ_ONLY);\r\n\t\t\twidget.setItems(opt.choices());\r\n\t\t\twidget.select(opt.getIndexValue());\r\n\t\t\twidget.setVisibleItemCount(opt.choices().length);\r\n\t\t\twidget.setToolTipText(opt.tooltip());\r\n\t\t\torg.eclipse.swt.widgets.Label label2 = new org.eclipse.swt.widgets.Label(composite,SWT.NONE);\r\n\t\t\tlabel2.setText(opt.label());\r\n\t\t\tlabel2.setToolTipText(opt.tooltip());\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns the current setting of the widget; this method\r\n\t\t * may be called only when there is a current Properties Page.\r\n\t\t * @return The current setting of the widget\r\n\t\t */\r\n\t\t//@ requires widget != null;\r\n\t\t//@ ensures \\result != null;\r\n\t\t//@ pure\r\n\t\tpublic String value() { return widget.getText(); }\r\n\t\t\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets the UI widget to the option's default value\r\n\t\t *\r\n\t\t */\r\n\t\t@Override\r\n\t\tpublic void setDefault() {\r\n\t\t\twidget.select(((AbstractPreference.ChoiceOption)option).getDefaultIndex());\r\n\t\t}\t\t\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets the option value to be consistent with the\r\n\t\t * current setting of the UI's widget.\r\n\t\t */\r\n\t\t@Override\r\n\t\tpublic void setOptionValue() { ((AbstractPreference.ChoiceOption)option).setValue(value()); } \r\n\t\t\r\n\t\t/** Resets the list of choice items */\r\n\t\tpublic void setChoices(String[] choices) { widget.setItems(choices); }\r\n\t}\r\n\t\r\n\t// FIXME - improve the handling of lengths of file/directory/string fields\r\n\t\r\n\t/**\r\n\t * This class implements an PreferenceWidget for a text field\r\n\t * property that holds a file name, using the FileTextField widget, which \r\n\t * incorporates a Browse button.\r\n\t * \r\n\t * @author David Cok\r\n\t *\r\n\t */\r\n\tpublic static class FileWidget extends PreferenceWidget {\r\n\t\t\r\n\t\t/** The UI widget representing a file browser. */\r\n\t\t/*@Nullable*/ protected Widgets.FileTextField widget = null;\r\n\r\n\t\t/**\r\n\t\t * Creates a FileWidget (the underlying widget is not\r\n\t\t * created until createContents is called).\r\n\t\t * @param option The option on which this widget is based\r\n\t\t */\r\n\t\t//@ reqiures option != null;\r\n\t\t//@ ensures widget == null;\r\n\t\t//@ ensures this.option == option;\r\n\t\t//@ pure\r\n\t\tpublic FileWidget(AbstractPreference.StringOption option) {\r\n\t\t\tsuper(option);\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t/**\r\n\t\t * Creates the corresponding widget and adds it to the given\r\n\t\t * Composite widget; the UI widgets are recreated for each\r\n\t\t * instance of a property page.\r\n\t\t * @param parent The Composite that holds all of the option widgets\r\n\t\t */\r\n\t\t//@ ensures widget != null;\r\n\t\t@Override\r\n\t\tpublic void addWidget(Composite parent) {\r\n\t\t\tString fn = ((AbstractPreference.StringOption)option).getValue();\r\n\t\t\twidget = new Widgets.FileTextField(parent,option.label(),fn,option.tooltip(),50);\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns the current setting of the widget; this method\r\n\t\t * may be called only when there is a current Properties Page.\r\n\t\t * @return The current setting of the widget\r\n\t\t */\r\n\t\t//@ requires widget != null;\r\n\t\tpublic String value() { return widget.value().trim(); }\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets the UI widget to the built-in default value\r\n\t\t *\r\n\t\t */\r\n\t\t//@ requires widget != null;\r\n\t\t//@ requires option != null;\r\n\t\t@Override\r\n\t\tpublic void setDefault() {\r\n\t\t\twidget.setText(((AbstractPreference.StringOption)option).getDefault());\r\n\t\t}\r\n\t\t\t\t\r\n\t\t/**\r\n\t\t * Sets the option value to be consistent with the\r\n\t\t * current setting of the UI's widget.\r\n\t\t */\r\n\t\t//@ requires widget != null;\r\n\t\t//@ requires option != null;\r\n\t\t@Override\r\n\t\tpublic void setOptionValue() { ((AbstractPreference.StringOption)option).setValue(value()); } \r\n\t}\r\n\t\r\n\t/**\r\n\t * This class implements an PreferenceWidget for a text field\r\n\t * property that holds a directory name, using the DirTextField widget, which \r\n\t * incorporates a Browse button.\r\n\t * \r\n\t * @author David Cok\r\n\t *\r\n\t */\r\n\tpublic static class DirectoryWidget extends PreferenceWidget {\r\n\t\t\r\n\t\t/** The UI widget representing a file browser. */\r\n\t\t/*@Nullable*/ protected Widgets.DirTextField widget = null;\r\n\r\n\t\t/**\r\n\t\t * Creates a FileWidget (the underlying widget is not\r\n\t\t * created until createContents is called).\r\n\t\t * @param option The option on which this widget is based\r\n\t\t */\r\n\t\t//@ reqiures option != null;\r\n\t\t//@ ensures widget == null;\r\n\t\t//@ ensures this.option == option;\r\n\t\t//@ pure\r\n\t\tpublic DirectoryWidget(AbstractPreference.StringOption option) {\r\n\t\t\tsuper(option);\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t/**\r\n\t\t * Creates the corresponding widget and adds it to the given\r\n\t\t * Composite widget; the UI widgets are recreated for each\r\n\t\t * instance of a property page.\r\n\t\t * @param parent The Composite that holds all of the option widgets\r\n\t\t */\r\n\t\t//@ ensures widget != null;\r\n\t\t@Override\r\n\t\tpublic void addWidget(Composite parent) {\r\n\t\t\tString fn = ((AbstractPreference.StringOption)option).getValue();\r\n\t\t\twidget = new Widgets.DirTextField(parent,option.label(),fn,option.tooltip(),80);\r\n\t\t}\r\n\t\t\r\n\t\tpublic void addModifyListener(ModifyListener listener) {\r\n\t\t\twidget.addModifyListener(listener);\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns the current setting of the widget; this method\r\n\t\t * may be called only when there is a current Properties Page.\r\n\t\t * @return The current setting of the widget\r\n\t\t */\r\n\t\t//@ requires widget != null;\r\n\t\tpublic String value() { return widget.value().trim(); }\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets the UI widget to the built-in default value\r\n\t\t *\r\n\t\t */\r\n\t\t//@ requires widget != null;\r\n\t\t//@ requires option != null;\r\n\t\t@Override\r\n\t\tpublic void setDefault() {\r\n\t\t\twidget.setText(((AbstractPreference.StringOption)option).getDefault());\r\n\t\t}\r\n\t\t\t\t\r\n\t\t/**\r\n\t\t * Sets the option value to be consistent with the\r\n\t\t * current setting of the UI's widget.\r\n\t\t */\r\n\t\t//@ requires widget != null;\r\n\t\t//@ requires option != null;\r\n\t\t@Override\r\n\t\tpublic void setOptionValue() { ((AbstractPreference.StringOption)option).setValue(value()); } \r\n\t}\r\n\t\r\n\t/**\r\n\t * This class implements a PropertyWidget for a boolean-valued\r\n\t * property, associating it with a check-box Button in the UI.\r\n\t * \r\n\t * @author David Cok\r\n\t *\r\n\t */\r\n\tpublic static class BooleanWidget extends PreferenceWidget {\r\n\t\t\r\n\t\t/** The UI widget representing a boolean choice. */\r\n\t\t/*@Nullable*/ protected Button widget = null;\r\n\t\t\r\n\t\t/**\r\n\t\t * Creates a checkbox widget on the given parent Composite widget;\r\n\t\t * initializes the widget with the value of the given option\r\n\t\t * @param option The option on which this widget is based\r\n\t\t */\r\n\t\t//@ requires option != null;\r\n\t\t//@ ensures this.option == option;\r\n\t\t//@ pure\r\n\t\tpublic BooleanWidget(AbstractPreference.BooleanOption option) {\r\n\t\t\tsuper(option);\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * Creates the corresponding widget and adds it to the given\r\n\t\t * Composite widget; the UI widgets are recreated for each\r\n\t\t * instance of a property page.\r\n\t\t * @param parent The Composite that holds all of the option widgets\r\n\t\t */\r\n\t\t//@ requires option != null;\r\n\t\t//@ ensures widget != null;\r\n\t\t@Override\r\n\t\tpublic void addWidget(Composite parent) {\r\n\t\t\twidget = new Button(parent,SWT.CHECK);\r\n\t\t\twidget.setText(option.label());\r\n\t\t\twidget.setToolTipText(option.tooltip());\r\n\t\t\twidget.setSelection(((AbstractPreference.BooleanOption)option).getValue());\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns the current setting of the widget; this method\r\n\t\t * may be called only when there is a current Properties Page.\r\n\t\t * @return The current setting of the widget\r\n\t\t */\r\n\t\t//@ requires widget != null;\r\n\t\tpublic boolean value() { return widget.getSelection(); }\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets the UI widget to the built-in default value\r\n\t\t *\r\n\t\t */\r\n\t\t//@ requires widget != null;\r\n\t\t//@ requires option != null;\r\n\t\t@Override\r\n\t\tpublic void setDefault() {\r\n\t\t\twidget.setSelection(((AbstractPreference.BooleanOption)option).getDefault());\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets the workspace property value to be consistent with the\r\n\t\t * current setting of the UI's widget.\r\n\t\t */\r\n\t\t//@ requires widget != null;\r\n\t\t//@ requires option != null;\r\n\t\t@Override\r\n\t\tpublic void setOptionValue() { ((AbstractPreference.BooleanOption)option).setValue(value()); } \r\n\t}\r\n\r\n    /**\r\n     * This class implements a PropertyWidget for a boolean-valued\r\n     * property, associating it with a check-box Button in the UI.\r\n     * \r\n     * @author David Cok\r\n     *\r\n     */\r\n    public static class IntWidget extends PreferenceWidget {\r\n    \t\r\n    \t// FIXME - change this to be an int field with arrow keys?  Use FieldEditors?\r\n        \r\n        /** The UI widget representing a choice. */\r\n    \t/*@Nullable*/ protected Combo widget = null;\r\n        \r\n        /** The strings giving the specific choices displayed. */\r\n        protected String[] choices;\r\n        \r\n        /**\r\n         * Creates a checkbox widget on the given parent Composite widget;\r\n         * initializes the widget with the value of the given option\r\n         * @param option The option on which this widget is based\r\n         * @param choices the specific alternates displayed as choices\r\n         */\r\n        //@ requires option != null;\r\n        //@ ensures this.option == option;\r\n        //@ pure\r\n        public IntWidget(AbstractPreference.IntOption option, String[] choices) {\r\n            super(option);\r\n            this.choices = choices;\r\n        }\r\n        \r\n        /**\r\n         * Creates the corresponding widget and adds it to the given\r\n         * Composite widget; the UI widgets are recreated for each\r\n         * instance of a property page.\r\n         * @param parent The Composite that holds all of the option widgets\r\n         */\r\n        //@ requires option != null;\r\n        //@ ensures widget != null;\r\n\t\t@Override\r\n        public void addWidget(Composite parent) {\r\n            AbstractPreference.IntOption opt = (AbstractPreference.IntOption)option;\r\n            Composite composite = new Widgets.HComposite(parent,2);\r\n            org.eclipse.swt.widgets.Label label2 = new org.eclipse.swt.widgets.Label(composite,SWT.NONE);\r\n            label2.setText(opt.label());\r\n            label2.setToolTipText(opt.tooltip());\r\n            widget = new Combo(composite, SWT.READ_ONLY);\r\n            widget.setItems(choices);\r\n            widget.select(opt.getValue());\r\n            widget.setVisibleItemCount(choices.length);\r\n            widget.setToolTipText(opt.tooltip());\r\n\r\n//            widget = new Button(parent,SWT.CHECK);\r\n//            widget.setText(option.label());\r\n//            widget.setToolTipText(option.tooltip());\r\n//            widget.setSelection(((AbstractPreference.BooleanOption)option).getValue());\r\n        }\r\n        \r\n        /**\r\n         * Returns the current setting of the widget; this method\r\n         * may be called only when there is a current Properties Page.\r\n         * @return The current setting of the widget\r\n         */\r\n        //@ requires widget != null;\r\n        public int value() { return widget.getSelectionIndex(); }\r\n        \r\n        /**\r\n         * Sets the UI widget to the built-in default value\r\n         *\r\n         */\r\n        //@ requires widget != null;\r\n        //@ requires option != null;\r\n\t\t@Override\r\n        public void setDefault() {\r\n            widget.select(((AbstractPreference.IntOption)option).getDefault());\r\n        }\r\n        \r\n        /**\r\n         * Sets the workspace property value to be consistent with the\r\n         * current setting of the UI's widget.\r\n         */\r\n        //@ requires widget != null;\r\n        //@ requires option != null;\r\n\t\t@Override\r\n        public void setOptionValue() { ((AbstractPreference.IntOption)option).setValue(value()); } \r\n    }\r\n    \r\n\r\n    /**\r\n     * This class implements a PropertyWidget for a String-valued\r\n     * property, associating it with an editable text box in the UI.\r\n     * \r\n     * @author David Cok\r\n     *\r\n     */\r\n    public static class StringWidget extends PreferenceWidget {\r\n        \r\n        /** The UI widget representing a String value. */\r\n    \t/*@Nullable*/ protected Text widget = null;\r\n        \r\n        /**\r\n         * Creates a checkbox widget on the given parent Composite widget;\r\n         * initializes the widget with the value of the given option\r\n         * @param option The option on which this widget is based\r\n         */\r\n        //@ requires option != null;\r\n        //@ ensures this.option == option;\r\n        //@ pure\r\n        public StringWidget(AbstractPreference.StringOption option) {\r\n            super(option);\r\n        }\r\n        \r\n        /**\r\n         * Creates the corresponding widget and adds it to the given\r\n         * Composite widget; the UI widgets are recreated for each\r\n         * instance of a property page.\r\n         * @param parent The Composite that holds all of the option widgets\r\n         */\r\n        //@ requires option != null;\r\n        //@ ensures widget != null;\r\n\t\t@Override\r\n        public void addWidget(Composite parent) {\r\n          Composite composite = new Widgets.HComposite(parent,2);\r\n          org.eclipse.swt.widgets.Label label2 = new org.eclipse.swt.widgets.Label(composite,SWT.NONE);\r\n          label2.setText(option.label());\r\n          label2.setToolTipText(option.tooltip());\r\n          widget = new Text(composite, SWT.SINGLE);\r\n          widget.setText(((AbstractPreference.StringOption)option).getValue());\r\n          widget.setToolTipText(option.tooltip());\r\n        }\r\n\r\n        /**\r\n         * Returns the current setting of the widget; this method\r\n         * may be called only when there is a current Properties Page.\r\n         * @return The current setting of the widget\r\n         */\r\n        //@ requires widget != null;\r\n        public String value() { return widget.getText(); }\r\n        \r\n        /**\r\n         * Sets the UI widget to the built-in default value\r\n         *\r\n         */\r\n        //@ requires widget != null;\r\n        //@ requires option != null;\r\n\t\t@Override\r\n        public void setDefault() {\r\n            widget.setText(((AbstractPreference.StringOption)option).getDefault());\r\n        }\r\n        \r\n        /**\r\n         * Sets the workspace property value to be consistent with the\r\n         * current setting of the UI's widget.\r\n         */\r\n        //@ requires widget != null;\r\n        //@ requires option != null;\r\n\t\t@Override\r\n        public void setOptionValue() {\r\n          ((AbstractPreference.StringOption)option).setValue(value()); \r\n        } \r\n    }\r\n\t/**\r\n\t * This class implements an PreferenceWidget that is a Label, so\r\n\t * that it can sit in lists of PreferenceWidgets.  However, it does\r\n\t * not have an option associated with it.\r\n\t * \r\n\t * @author David Cok\r\n\t *\r\n\t */\r\n\tpublic static class Label extends PreferenceWidget {\r\n\t\t\r\n\t\t/** The UI widget that is a label. */\r\n\t\t/*@Nullable*/ protected Widgets.LabeledSeparator widget = null;\r\n\t\t\r\n\t\t/** The label value */\r\n\t\tprotected String label;\r\n\t\r\n\t\t/** \r\n\t\t * Creates a Label widget on the given parent Composite widget.\r\n\t\t * @param label The label text for the widget\r\n\t\t */\r\n\t\t//@ requires label != null;\r\n\t\t//@ ensures this.label == label;\r\n\t\t//@ pure\r\n\t\tpublic Label(String label) {\r\n\t\t\tsuper(null);\r\n\t\t\tthis.label = label;\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * Creates the corresponding widget and adds it to the given\r\n\t\t * Composite widget; the UI widgets are recreated for each\r\n\t\t * instance of a property page.\r\n\t\t * @param parent The Composite that holds all of the option widgets\r\n\t\t */\r\n\t\t//@ ensures widget != null;\r\n\t\t@Override\r\n\t\tpublic void addWidget(Composite parent) {\r\n\t\t\twidget = new Widgets.LabeledSeparator(parent,label);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Does nothing.\r\n\t\t */\r\n\t\t@Override\r\n\t\tpublic void setDefault() { } \r\n\t\t\r\n\t\t/**\r\n\t\t * Does nothing.\r\n\t\t */\r\n\t\t@Override\r\n\t\tpublic void setOptionValue() { } \r\n\t}\r\n\r\n}\r\n",
        "name": "PreferenceWidget.java",
        "path": "SMTPlugin/src/org/smtlib/plugin/PreferenceWidget.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMTPlugin/src/org/smtlib/plugin/PreferenceWidget.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 370,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 371,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures this.option == option;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 384,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 385,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 410,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 417,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 418,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 428,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 429,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 452,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 453,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures this.option == option;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 465,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 466,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 483,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 490,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 491,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 501,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 502,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 88,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 108,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 109,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 155,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures widget == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 156,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures this.option == option;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 169,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 181,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 188,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 189,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 199,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 200,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 224,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures widget == null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 225,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures this.option == option;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 238,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 254,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 261,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 262,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 272,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 273,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 295,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 296,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures this.option == option;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 308,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 309,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 323,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 330,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 331,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 341,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires widget != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 342,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires option != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 528,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires label != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 529,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures this.label == label;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 542,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures widget != null;\r"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\r\n * This file is part of the SMT plugin project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.plugin;\r\n\r\nimport java.util.Collection;\r\nimport java.util.LinkedList;\r\n\r\nimport org.eclipse.jface.preference.IPreferenceStore;\r\n\r\n/**\r\n * This is a base class for persistent options.  The options are\r\n * stored as workspace preferences.\r\n * \r\n * @author David R. Cok\r\n */\r\npublic class AbstractPreference {\r\n\r\n    /** A reference to the plugin's preference store */\r\n    public IPreferenceStore preferenceStore() { \r\n    \treturn Activator.getDefault().getPreferenceStore(); \r\n    }\r\n\r\n    /** The name used as the key into the \r\n     * persistent store for the value of the option.\r\n     */\r\n    //@ non_null\r\n    protected String key;\r\n\r\n    /** The label to use for the widget */\r\n    //@ non_null\r\n    protected String label;\r\n\r\n    /** The tooltip help for the widget */\r\n    //@ non_null\r\n    protected String tooltip;\r\n\r\n    /**\r\n     * The protected constructor used by derived classes\r\n     * @param key  The name used as a preference key\r\n     * @param label  A short description suitable as a label\r\n     * @param tooltip  A longer description suitable as help\r\n     */\r\n    protected AbstractPreference(String key, String label, String tooltip) {\r\n        this.key = key;\r\n        this.label = label;\r\n        this.tooltip = tooltip;\r\n    }\r\n\r\n    /** An interface for the listeners that are fired when options change.*/\r\n    static public interface Listener {\r\n        /** The method executed when the listener is notified. */\r\n        public void run();\r\n    }\r\n\r\n    /** The listeners that will be notified when options change (through the workspace preferences dialog). */\r\n    static private Collection\u003cListener\u003e listeners = new LinkedList\u003cListener\u003e();\r\n\r\n    /** Adds a listener to the collection of listeners.\r\n     * \r\n     * @param l Listener to be added\r\n     */\r\n    static synchronized public void addListener(Listener l) {\r\n        listeners.add(l);\r\n    }\r\n\r\n    /** Adds a listener to the collection of listeners.\r\n     * \r\n     * @param l Listener to be removed\r\n     */\r\n    static synchronized public void removeListener(Listener l) {\r\n        listeners.remove(l);\r\n    }\r\n\r\n    /** Executes all listeners */\r\n    static synchronized public void notifyListeners() {\r\n        for (Listener i: listeners) {\r\n            i.run();\r\n        }\r\n    }\r\n    \r\n    /** Returns the key string\r\n     * @return the key\r\n     */\r\n    public String key() { return key; }\r\n\r\n    /** Returns the label string (short description) for this option\r\n     * \r\n     * @return the label string\r\n     */\r\n    public String label() { return label; }\r\n\r\n    /** Returns the help string for this option\r\n     * \r\n     * @return the help string\r\n     */\r\n    public String tooltip() { return tooltip; }\r\n\r\n    /** Sets the option to its default value */\r\n    public void setToDefault() {\r\n        preferenceStore().setToDefault(key);\r\n    }\r\n\r\n    /** An option that has a boolean value */\r\n    static public class BooleanOption extends AbstractPreference {\r\n\r\n        /**\r\n         * Creating a boolean option object\r\n         * @param key  The name used as a preference key\r\n         * @param def  The default value used if no value is previously stored\r\n         * @param label A short description usable as a label\r\n         * @param tooltip A long description usable as help\r\n         */\r\n        public BooleanOption(String key, boolean def,\r\n                String label, String tooltip) {\r\n            super(key,label,tooltip);\r\n            preferenceStore().setDefault(key,def);\r\n        }\r\n\r\n        /**\r\n         * Returns the current value of the option \r\n         * @return The current value of the option\r\n         */\r\n        public boolean getValue() { return preferenceStore().getBoolean(key); }\r\n\r\n        /**\r\n         * Sets the workspace property value to the given value.\r\n         * \r\n         * @param b The value to set\r\n         */\r\n        public void setValue(boolean b) { preferenceStore().setValue(key,b); } \r\n\r\n        /** Returns the default value of the preference\r\n         * @return the default value of the preference\r\n         */\r\n        public boolean getDefault() {\r\n            return preferenceStore().getDefaultBoolean(key);\r\n        }\r\n\r\n    }\r\n\r\n    /** An option that has a int value */\r\n    static public class IntOption extends AbstractPreference {\r\n\r\n        /**\r\n         * Creating a int option object\r\n         * @param key  The name used as a preference key\r\n         * @param def  The default value used if no value is previously stored\r\n         * @param label A short description usable as a label\r\n         * @param tooltip A long description usable as help\r\n         */\r\n        public IntOption(String key, int def,\r\n                String label, String tooltip) {\r\n            super(key,label,tooltip);\r\n            preferenceStore().setDefault(key,def);\r\n        }\r\n\r\n        /**\r\n         * Returns the current value of the option \r\n         * @return The current value of the option\r\n         */\r\n        public int getValue() { return preferenceStore().getInt(key); }\r\n\r\n        /**\r\n         * Sets the workspace property value to the given value.\r\n         * \r\n         * @param i The value to set\r\n         */\r\n        public void setValue(int i) { preferenceStore().setValue(key,i); } \r\n\r\n        /** Returns the default value of the preference\r\n         * @return the default value of the preference\r\n         */\r\n        public int getDefault() {\r\n            return preferenceStore().getDefaultInt(key);\r\n        }\r\n\r\n    }\r\n\r\n    /** An option that has a String value */\r\n    static public class StringOption extends AbstractPreference {\r\n\r\n        /**\r\n         * Creating a String option object\r\n         * @param key  The qualified name used as a property key\r\n         * @param def  The default value used if no value is previously stored\r\n         * @param label A short description usable as a label\r\n         * @param tooltip A long description usable as help\r\n         */\r\n        public StringOption(String key, String def,\r\n                String label, String tooltip) {\r\n            super(key,label,tooltip);\r\n            if (def != null) preferenceStore().setDefault(key,def);\r\n        }\r\n\r\n        /** Returns the default value of the preference\r\n         * @return the default value of the preference\r\n         */\r\n        public String getDefault() {\r\n            return preferenceStore().getDefaultString(key);\r\n        }\r\n\r\n        /**\r\n         * Returns the current value of the option \r\n         * @return The current value of the option\r\n         */\r\n        public String getValue() { return preferenceStore().getString(key); }\r\n\r\n        /**\r\n         * Sets the option value to the given value.\r\n         * \r\n         * @param v The value to set\r\n         */\r\n        public void setValue(String v) { preferenceStore().setValue(key,v); } \r\n    }\r\n\r\n    /** An option that has one of a set of Strings as its value */\r\n    static public class ChoiceOption extends AbstractPreference {\r\n\r\n        /** The choices */\r\n        protected String[] choices;\r\n\r\n        /**\r\n         * Creating a String option object\r\n         * @param key  The name used as a preference key\r\n         * @param def  The default value used if no value is previously stored (an index into the array of choices)\r\n         * @param choices The choices (as Strings) to be chosen among\r\n         * @param label A short description usable as a label\r\n         * @param tooltip A long description usable as help\r\n         */\r\n        public ChoiceOption(String key, String[] choices,\r\n                int def,\r\n                String label, String tooltip) {\r\n            super(key,label,tooltip);\r\n            preferenceStore().setDefault(key,choices[def]);\r\n            this.choices = choices;\r\n        }\r\n\r\n        /** Returns the array of choices; this array should not be modified.\r\n         * \r\n         * @return the array of choices\r\n         */\r\n        public String[] choices() { return choices; }\r\n\r\n        /** Returns the default value of the preference\r\n         * @return the default value of the preference\r\n         */\r\n        public String getDefault() {\r\n            return preferenceStore().getDefaultString(key);\r\n        }\r\n\r\n        /** Returns the default value of the preference\r\n         * @return the default value of the preference\r\n         */\r\n        public int getDefaultIndex() {\r\n            return lookup(preferenceStore().getDefaultString(key));\r\n        }\r\n\r\n        /**\r\n         * Returns the current value of the option \r\n         * @return The current value of the option\r\n         */\r\n        public int getIndexValue() { \r\n            String r = preferenceStore().getString(key);\r\n            return lookup(r);\r\n        }\r\n\r\n        /**\r\n         * Returns the current value of the option \r\n         * @return The current value of the option\r\n         */\r\n        public String getStringValue() { \r\n            return preferenceStore().getString(key);\r\n        }\r\n\r\n        /**\r\n         * Sets the option value to the given value.\r\n         * \r\n         * @param v The String value to set\r\n         */\r\n        public void setValue(String v) { preferenceStore().setValue(key,v); }\r\n\r\n        /**\r\n         * Sets the option value to the given value.\r\n         * \r\n         * @param i The index value to set\r\n         */\r\n        //@ requires 0\u003c=i \u0026\u0026 i\u003cchoices.length;\r\n        public void setValue(int i) { preferenceStore().setValue(key,choices[i]); } \r\n\r\n        /**\r\n         * Returns the index in the choices array corresponding\r\n         * to the argument; returns -1 if not found.\r\n         * @param s The String to be sought in the choices array\r\n         * @return The index of the argument in the array\r\n         */\r\n        //@ requires s != null;\r\n        //@ ensures \\result != -1 ==\u003e choices[\\result].equals(s);\r\n        //@ ensures \\result == -1 ==\u003e (\\forall int i; 0\u003c=i \u0026\u0026 i\u003cchoices.length; !choices[i].equals(s));\r\n        private int lookup(String s) {\r\n            for (int i=0; i\u003cchoices.length; ++i) {\r\n                if (s.equals(choices[i])) return i;\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n}\r\n",
        "name": "AbstractPreference.java",
        "path": "SMTPlugin/src/org/smtlib/plugin/AbstractPreference.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMTPlugin/src/org/smtlib/plugin/AbstractPreference.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 289,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires 0\u003c=i \u0026\u0026 i\u003cchoices.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 298,
          "offsetAndLengths": [
            [
              8,
              13
            ]
          ],
          "preview": "        //@ requires s != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 299,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures \\result != -1 ==\u003e choices[\\result].equals(s);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 300,
          "offsetAndLengths": [
            [
              8,
              12
            ]
          ],
          "preview": "        //@ ensures \\result == -1 ==\u003e (\\forall int i; 0\u003c=i \u0026\u0026 i\u003cchoices.length; !choices[i].equals(s));\r"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\n * This file is part of the SMT project.\n * Copyright 2010 David R. Cok\n * Created August 2010\n */\npackage org.smtlib;\n\nimport java.util.List;\nimport java.util.Map;\n\nimport org.smtlib.IExpr.IIdentifier;\nimport org.smtlib.IExpr.INumeral;\nimport org.smtlib.IExpr.ISymbol;\nimport org.smtlib.IPos.IPosable;\nimport org.smtlib.IVisitor.VisitorException;\n\n/** The interface for an SMT-LIB concept of a Sort. Two kinds of things are modeled here.\n * \u003cP\u003e\n * First, a definition of a Sort, modeled by ISort.IDefinition. There are these kinds of \n * definitions:\n * \u003cUL\u003e\n * \u003cLI\u003e an ISort.IFamily, which defines a new sort symbol of a given arity\n * \u003cLI\u003e an ISort.IAbbreviation, which defines a (possibly parameterized) abbreviation for a sort expression.\n * \u003cLI\u003e an ISort.IParameter, which defines a sort name used as a parameter in an abbreviation definition\n * \u003cLI\u003e The ISort.ErrorDefinition class, which is used as a definition place holder for ill-formed definitions, to avoid excessive redundant errors\n * \u003c/UL\u003e\n * Second, Sort expressions themselves, modeled by ISort:\n * \u003cUL\u003e\n * \u003cLI\u003eA ISort.IApplication, which is the application of an IDefinition to the appropriate number\n * (possibly 0) of Sort expressions\n * \u003cLI\u003eA ISort.IParameter, which is a simple symbol designating the parameter of a parameterized abbreviation\n * \u003cLI\u003eA ISort.IFcnSort, an expression designating a function sort; this is not expressible in SMT-LIBv2, but is \n * useful internally within jSMTLIB.\n * \u003c/UL\u003e\n */\npublic interface ISort extends IAccept, IPosable {\n\n\t/** Structural equality after expansion of abbreviations, but without any substitution of free parameters. */\n\t//@ pure\n\t@Override\n\tboolean equals(Object o);\n\n\t/** Structural equality after expansion of abbreviations (as looked up in the symbol table)\n\t * and substitution of free parameters according to the respective maps. \n\t */\n\t//@ pure\n\tboolean equals(Map\u003cIParameter,ISort\u003e leftmap, ISort s, Map\u003cIParameter,ISort\u003e rightmap, SymbolTable symTable);\n\n\t/** Returns true if the receiver designates the Bool pre-defined Sort. */\n\t//@ pure\n\tboolean isBool();\n\t\n\t/** Expands all abbreviations */\n\t//@ pure\n\tISort expand();\n\t\n\t/** Returns a new sort with any parameters substituted */\n\t//@ pure\n\tISort substitute(java.util.Map\u003cIParameter,ISort\u003e map);\n\n\t/** Compares sort expressions without abbreviation expansion or parameter substitution */\n\t//@ pure\n\tboolean equalsNoExpand(ISort sort);\n\t\n\t/** A super-interface for definitions of new sort ids.\n\t */\n\tstatic public interface IDefinition extends IAccept {\n\t\t/** The identifier for the sort symbol */\n\t\t//@ pure\n\t\tIIdentifier identifier();\n\t\t\n\t\t/** A new sort expression that results from applying the sort symbol to a list of sort expressions */\n\t\t//@ requires sorts.size() == intArity();\n\t\t//@ pure\n\t\tISort eval(List\u003cISort\u003e sorts);\n\t\t\n\t\t/** The arity of the symbol*/\n\t\t//@ ensures \\result \u003e= 0;\n\t\t//@ pure\n\t\tint intArity();\n\t}\n\t\n\t/** This class is an instance of a sort definition that represents an erroneous definition\n\t * of a Sort; by defining an actual IDefinition, excessive propagation of errors is avoided.\n\t */ // TODO - check if the above statement is actually valid and that having this class makes a difference\n\tstatic public class ErrorDefinition implements IDefinition {\n\t\tpublic IIdentifier id;\n\t\tpublic String error;\n\t\tpublic IPos pos;\n\t\t\n\t\tpublic ErrorDefinition(IIdentifier id, String error, IPos pos) {\n\t\t\tthis.id = id;\n\t\t\tthis.error = error;\n\t\t\tthis.pos = pos;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic \u003cT\u003e T accept(IVisitor\u003cT\u003e v) throws VisitorException {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic IIdentifier identifier() {\n\t\t\treturn id;\n\t\t}\n\n\t\t@Override\n\t\tpublic ISort eval(List\u003cISort\u003e sorts) {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic int intArity() {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t}\n\t\n\t/** This interface represents a new Sort symbol designating either\n\t * a new Sort (if the arity is 0) or a new parameterized Sort family\n\t * (if the arity is greater than 0); each new symbol has a (new) name\n\t * and a non-negative arity.\n\t */\n\tstatic public interface IFamily extends IDefinition {\n\t\t/** The unique identifier for this sort symbol */\n\t\t@Override\n\t\tIIdentifier identifier();\n\t\t\n\t\t/** The arity of the sort symbol */\n\t\t//@ ensures \\result.intValue() \u003e= 0;\n\t\tINumeral arity();\n\t}\n\t\n\t/** This interface represents a new Sort symbol designating an\n\t * abbreviation for a (possibly parameterized) sort expression.\n\t */\n\tstatic public interface IAbbreviation extends IDefinition {\n\t\t/** The identifier of the abbreviation */\n\t\t@Override\n\t\tIIdentifier identifier();\n\n\t\t/** The list of parameters of the abbreviation (possibly empty, but not null) */\n\t\tList\u003cIParameter\u003e parameters();\n\n\t\t/** The sort expression that the abbreviation represents, presumably using the given parameters */\n\t\tISort sortExpression();\n\t}\n\t\n\t/** The interface for a Sort expression that consists of either\n\t * an arity 0 sort symbol or a positive-arity symbol with the \n\t * appropriate number of arguments.\n\t */\n\tstatic public interface IApplication extends ISort {\n\t\t/** The head identifier of the sort expression */\n\t\tIIdentifier family();\n\t\t\n\t\t/** Returns the ith parameter */\n\t\t//@ requires i \u003e= 0 \u0026\u0026 i \u003c parameters().size();\n\t\tISort param(int i);\n\t\t\n\t\t/** Returns the list of parameters */\n\t\tList\u003cISort\u003e parameters();\n\t\t\n\t\t/** The definition of the family identifier, valid after the sort expression has been type-checked. */\n\t\tIDefinition definition();\n\n\t\t/** Sets and returns the value of definition() for this object to the value that is the argument */\n\t\t//@ ensures \\result == definition;\n\t\tIDefinition definition(IDefinition definition);\n\t\t\n\t\t/** Expands any head abbreviations, if any; requires definition() to be defined */\n\t\t@Override\n\t\tISort expand();\n\n\t\t@Override\n\t\tboolean equals(/*@Nullable*/Object o);\n\t\t\n\t\t@Override\n\t\tboolean equals(Map\u003cIParameter,ISort\u003e leftmap, ISort s, Map\u003cIParameter,ISort\u003e rightmap, SymbolTable symTable);\n\n\t\t@Override\n\t\tboolean equalsNoExpand(ISort sort);\n\n\t}\n\n\t/** The interface for a sort parameter, as used in sort abbreviations\n\t * (including in the defining expression).\n\t */\n\tstatic public interface IParameter extends ISort, IDefinition {\n\t\t/** The symbol that names the parameter */\n\t\tISymbol symbol();\n\t\t\n\t\t@Override\n\t\tboolean equals(/*@Nullable*/Object o);\n\t\t\n\t\t@Override\n\t\tboolean equals(Map\u003cIParameter,ISort\u003e leftmap, ISort s, Map\u003cIParameter,ISort\u003e rightmap, SymbolTable symTable);\n\t\t\n\t\t@Override\n\t\tboolean equalsNoExpand(ISort sort);\n\n\t}\n\t\n\t/** An interface to represent the Sort of a function; this is\n\t * not something that can be written as a sort expression in SMT-LIB,\n\t * but it is convenient to be able to represent the sorts of function\n\t * ids uniformly with the sorts of other ids.  // FIXME - perhaps we can get around this - IFcnSort\n\t */\n\tstatic public interface IFcnSort extends ISort {\n\t\tISort resultSort();\n\t\tISort[] argSorts();\n\t}\n\t\n\t/** The interface for a Sort-creating factory */\n\tstatic public interface IFactory {\n\t\t/** Creates a sort family with the given identifier and arity */\n\t\tIFamily createSortFamily(IIdentifier identifier, INumeral arity);\n\t\t\n\t\t/** Creates a parameter for a parameterized sort abbreviation */\n\t\tIParameter createSortParameter(ISymbol symbol);\n\t\t\n\t\t/** Creates a sort expression, applying a family to a list of sort arguments;\n\t\t * the arity of the identifier in the applicable symbol table must match the number of sort arguments\n\t\t */\n\t\tIApplication createSortExpression(IIdentifier sortFamily, ISort... exprs);\n\n\t\t/** Creates a sort expression, applying a family to a list of sort arguments;\n\t\t * the arity of the identifier in the applicable symbol table must match the number of sort arguments\n\t\t */\n\t\tIApplication createSortExpression(IIdentifier sortFamily, List\u003cISort\u003e exprs);\n\t\t\n\t\t/** Creates a new sort abbreviation */\n\t\tIAbbreviation createSortAbbreviation(IIdentifier identifier, List\u003cIParameter\u003e params, ISort sortExpr);\n\t\t\n\t\t/** Creates a function sort */\n\t\tIFcnSort createFcnSort(ISort[] args, ISort result);\n\t\t\n\t\t/** Returns the Bool Sort */\n\t\tIApplication Bool();\n\t}\n}\n",
        "name": "ISort.java",
        "path": "SMT/src/org/smtlib/ISort.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMT/src/org/smtlib/ISort.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 72,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires sorts.size() == intArity();"
        },
        {
          "limitHit": false,
          "lineNumber": 77,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 129,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result.intValue() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 157,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires i \u003e= 0 \u0026\u0026 i \u003c parameters().size();"
        },
        {
          "limitHit": false,
          "lineNumber": 167,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result == definition;"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\n * This file is part of the SMT project.\n * Copyright 2010 David R. Cok\n * Created August 2010\n */\npackage org.smtlib;\n\nimport java.util.Map;\n\nimport org.smtlib.IExpr.IAttribute;\nimport org.smtlib.IExpr.IKeyword;\nimport org.smtlib.IExpr.ISymbol;\n\n/** This interface represents a definition of an SMT_LIB logic */\npublic interface ILogic extends IAccept, ILanguage {\n\t/** The name of the logic */\n\tISymbol logicName();\n\t\n\t/** The attributes of the logic */\n\t//@ ensures \\result.size() \u003e 0;\n\tMap\u003cIKeyword,IAttribute\u003c?\u003e\u003e attributes();\n\t\n\t/** The value of an attribute; returns null if the attribute does not exist for this logic. */\n\t/*@Nullable*/IAttributeValue value(IKeyword keyword);\n}\n",
        "name": "ILogic.java",
        "path": "SMT/src/org/smtlib/ILogic.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMT/src/org/smtlib/ILogic.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 19,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result.size() \u003e 0;"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\n * This file is part of the SMT project.\n * Copyright 2010 David R. Cok\n * Created August 2010\n */\npackage org.smtlib;\n\nimport org.smtlib.ICommand.Ideclare_const;\nimport org.smtlib.ICommand.Ideclare_fun;\nimport org.smtlib.ICommand.Ideclare_sort;\nimport org.smtlib.ICommand.Idefine_fun;\nimport org.smtlib.ICommand.Idefine_sort;\nimport org.smtlib.IExpr.IKeyword;\nimport org.smtlib.IExpr.IStringLiteral;\n\n\n/** This is the interface to be implemented by any solver adapter;\n * there is an abstract method for each SMT-LIB command */\npublic interface ISolver {\n\n\t/** Returns the configuration object with which the solver is initialized */\n\tSMT.Configuration smt();\n\t\n\t/** Current check-sat status; returns sat, unsat, unknown, error, or null */ // TODO - be more specific\n\t/*@Nullable*/ IResponse checkSatStatus();\n\t\n\t/** Starts the solver; this is not an SMT-LIB command, but it is convenient in some implementations\n\t * to separate the starting and initialization from the construction of the solver instance.\n\t * @return success or error\n\t */\n\tIResponse start();\n\t\n\t/** Reset the solver to the start state.\n\t * @return success or error\n\t */\n\tIResponse reset();\n\t\n\t/** Remove asserted assertions, depending on the value of :global-declarations.\n\t * @return success or error\n\t */\n\tIResponse reset_assertions();\n\t\n\t/** Terminate the solver; no further commands are permitted.\n\t * @return success or error\n\t */\n\tIResponse exit();\n\t\n\t/** Terminate the solver forcibly, without using commands\n\t */\n\tvoid forceExit();\n\t\n\t/** Echo the argument */\n\tIResponse echo(IStringLiteral arg);\n\t\n\t/** Send comment text - the argument must be white-space + legitimate comment text */\n\tvoid comment(String comment);\n\t\n\t/** Sets the logic the solver should use; the position argument is\n\t * just used for position information in error messages.\n\t * @return success or error\n\t */\n\tIResponse set_logic(String logicName, /*@Nullable*/ IPos pos);\n\t\n\t/** Adds the given number of empty stack frames to the solver state.\n\t * @param number non-negative number of stack frames to push\n\t * @return success or error\n\t */\n\t//@ requires number \u003e= 0;\n\tIResponse push(int number);\n\t\n\t/** Pops the given number of stack frames from the solver state.\n\t * @param number non-negative number of stack frames to pop\n\t * @return success or error\n\t */\n\t//@ requires number \u003e= 0;\n\tIResponse pop(int number);\n\t\n\t/** Asserts the given expression into the solver state (in the top stack frame);\n\t * the expression is expected to be already checked that it is a valid, well-formed and well-sorted\n\t * expression in the current logic; returns success or error */\n\tIResponse assertExpr(IExpr expr); // Not named assert because that is a Java reserved word, though\n\t\t\t\t\t\t\t\t\t\t// the SMT-LIB command is 'assert'\n\t\n\t/** Checks whether the current state is satisfiable in the current logic.\n\t * @return sat, unsat, unknown or error\n\t */\n\tIResponse check_sat();\n\t\n\t/** Checks whether the current state is satisfiable in the current logic, under specified assumptions.\n\t * @return sat, unsat, unknown or error\n\t */\n\tIResponse check_sat_assuming(IExpr...  exprs);\n\t\n\t/** Defines a new uninterpreted constant; returns success or error*/\n\tIResponse declare_const(Ideclare_const cmd); // FIXME - use ISymbol, ISort as arguments?\n\t\n\t/** Defines a new uninterpreted constant or function; returns success or error*/\n\tIResponse declare_fun(Ideclare_fun cmd);\n\t\n\t/** Declares a new basic sort; returns success or error */\n\tIResponse declare_sort(Ideclare_sort cmd);\n\n\t/** Defines a new constant or function; returns success or error */\n\tIResponse define_fun(Idefine_fun cmd);\n\t\n\t/** Defines a new sort abbreviation; returns success or error */\n\tIResponse define_sort(Idefine_sort cmd);\n\t\n\t/** Sets an SMT-LIB option\n\t * @param option the option whose value is to be set\n\t * @param value the value to which to set it\n\t * @return SUCCESS or an error or unsupported\n\t */\n\tIResponse set_option(IKeyword option, IAttributeValue value);\n\n\t/** Sets an SMT-LIB info value\n\t * @param key the info item whose value is to be set\n\t * @param value the value to which to set it\n\t * @return SUCCESS or an error or unsupported\n\t */\n\tIResponse set_info(IKeyword key, IAttributeValue value);\n\t\n\t/** Returns a list of all the formulae that have been asserted in the current state.\n\t * If the solver prints the list of assertions itself, then this method simply returns success.\n\t * May only be used in interactive mode.  If interactive mode is not implemented,\n\t * this command may return unsupported.\n\t * @return success or a list of formulae (as Strings or terms?) // TODO is this what we want?\n\t */\n\tIResponse get_assertions();\n\t\n\t/** Returns a proof that the current state is unsatisfiable. If the solver prints the proof itself,\n\t * then it returns simply success. // TODO check is this what we want\n\t * May only be issued if the :produce-proofs option is enabled.\n\t * Supporting proof production is optional.\n\t * @return error or success or unsupported (if proof production is not supported) or a proof\n\t */\n\tIResponse get_proof();\n\t\n\t/** Returns a model of current satisfiable state */\n\tIResponse get_model();\n\t\n\t/** Returns a list of the names of formulae in the unsat core of the current (unsatisfiable) state.\n\t * May only be issued if :produce-unsat-core is enabled.\n\t * @return unsupported or error or a list of names (as ids)\n\t */\n\tIResponse get_unsat_core();\n\t\n\t/** Returns a list of values for the given expressions.\n\t * May only be used if :produce-models is enabled.\n\t * @param terms expressions whose value in the current (Satisfiable) state is to be determined\n\t * @return error or list of values (which may include IError instances)\n\t */\n\tIResponse get_value(IExpr... terms);\n\n\t/** Retrieves values for all named formulae in the current (satisfiable) state.\n\t * May only be used if :produce-assignments is enabled.\n\t * @return error or a list of name-value pairs\n\t */\n\tIResponse get_assignment();\n\n\t/** Gets the value of an SMT-LIB option\n\t * \n\t * @param option the option whose value is desired\n\t * @return TODO\n\t */\n\tIResponse get_option(IKeyword option);\n\n\t/** Gets the value of an SMT-LIB information topic\n\t * \n\t * @param option the info option whose value is desired\n\t * @return TODO\n\t */\n\tIResponse get_info(IKeyword option);\n\t\n}\n",
        "name": "ISolver.java",
        "path": "SMT/src/org/smtlib/ISolver.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMT/src/org/smtlib/ISolver.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 67,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires number \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 74,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires number \u003e= 0;"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "package org.smtlib;\n\n/** This interface represents sources of characters.  The source need not be fully available at\n * any given time, but it does need to be able to supply characters at a given position on demand\n * and to determine line numbers from the beginning of the source.\n */\npublic interface ISource {\n\t// NOTE - the methods are not necessarily pure, since the internals may change.  However, the\n\t// implicit character content should not change.\n\t\n\t/** The internal character stream as a CharSequence.  We would like to avoid the constraint of\n\t * having to have this kind of internal representation, but the parser uses Pattern and Matcher,\n\t * which require a CharSequence.  The CharSequence might not contain all the characters that might\n\t * ever be read, but will contain characters as they are read.\n\t */\n\tCharSequence chars();\n\t\n\t/** Closes any open resources - the source is not usable after this call. */\n\tvoid close();\n\t\n\t/** User-specified identification of the location of the source; the user is responsible to use\n\t * the result in the way in which the source object was created.\n\t * @return the location object of the source\n\t */\n\t/*@Nullable*/ Object location();\n\t\n\t/** Returns the character at the given character position within the source. Character positions \n\t * begin at 0.*/\n\t//@ requires pos \u003e= 0;\n\tchar charAt(int pos);\n\t\n\t/** Returns the character position of the beginning of the line containing the given position. \n\t * Character positions begin at 0.*/\n\t//@ requires pos \u003e= 0;\n\t//@ ensures 0 \u003c= \\result \u0026\u0026 \\result \u003c= pos;\n\tint lineBeginning(int pos);\n\t\n\t/** Returns the text of the line containing the given position, at least through the given position,\n\t * and always ending with a (perhaps added) line termination sequence. Character positions begin at 0.\n\t * @param pos a character position\n\t * @return the line of text containing that character position\n\t */\n\t//@ requires pos \u003e= 0;\n\tString textLine(int pos);\n\t\n\t/** Returns the number (beginning with 1) of the line containing the given character position (which begins at 0). */\n\t//@ requires pos \u003e= 0;\n\t//@ ensures \\result \u003e 0;\n\tint lineNumber(int pos);\n}",
        "name": "ISource.java",
        "path": "SMT/src/org/smtlib/ISource.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMT/src/org/smtlib/ISource.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 28,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires pos \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 33,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires pos \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 34,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures 0 \u003c= \\result \u0026\u0026 \\result \u003c= pos;"
        },
        {
          "limitHit": false,
          "lineNumber": 42,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires pos \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 46,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires pos \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 47,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result \u003e 0;"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\n * This file is part of the SMT project.\n * Copyright 2010 David R. Cok\n * Created August 2010\n */\npackage org.smtlib;\n\nimport java.util.Map;\n\nimport org.smtlib.IExpr.ISymbol;\nimport org.smtlib.IExpr.IKeyword;\n\n/** This interface represents a definition of an SMT-LIB theory */\npublic interface ITheory extends IAccept {\n\t/** The name of the theory */\n\tISymbol theoryName();\n\t\n\t/** The attributes (keyword-value pairs) of the theory. */\n\t//@ ensures \\result.size() \u003e 0;\n\tMap\u003cIKeyword,IExpr.IAttribute\u003c?\u003e\u003e attributes();\n\t\n\t/** The value of an attribute; returns null if the attribute does not exist for this theory */\n\t/*@Nullable*/IAttributeValue value(IKeyword keyword);\n\t\n\t// TODO - do we export the pre-defined symbols?\n}\n",
        "name": "ITheory.java",
        "path": "SMT/src/org/smtlib/ITheory.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMT/src/org/smtlib/ITheory.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 18,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result.size() \u003e 0;"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\n * This file is part of the SMT project.\n * Copyright 2010 David R. Cok\n * Created August 2010\n */\npackage org.smtlib;\n\nimport java.util.List;\n\nimport org.smtlib.IExpr.IDeclaration;\nimport org.smtlib.IExpr.IIdentifier;\nimport org.smtlib.IExpr.IKeyword;\nimport org.smtlib.IExpr.INumeral;\nimport org.smtlib.IExpr.IStringLiteral;\nimport org.smtlib.IExpr.ISymbol;\nimport org.smtlib.ISort.IParameter;\n\n\n/** This interface is the generic interface to command classes, providing functionality\n * to type-check the command and to execute it.\n * @author David R. Cok\n */\npublic interface ICommand extends IAccept {\n\t\n\t/** This interface defines classes that implement techniques for mapping a command name to a class\n\t * that implements that command.\n\t */\n\tpublic static interface IFinder {\n\t\t/** This method finds a class that implements the ICommand interface for the given class name */\n\t\tClass\u003c? extends ICommand\u003e findCommand(String name);\n\t}\n\t\n\t/** Executes the command on the given solver; presumes that the command type-checked\n\t * successfully.\n\t * @param solver the instance of the solver to use (note that solvers have state)\n\t * @return the result of the command\n\t */\n\tIResponse execute(ISolver solver);\n\t\n\t/** This is the interface to be used by a concrete ICommand factory. */\n\tstatic public interface IFactory {\n\t\t/** Creates a script object containing the given filename or the given set of commands */\n\t\tIScript script(/*@Nullable*/IStringLiteral filename, /*@Nullable*/List\u003cICommand\u003e commands);\n\t\t\n\t\t/** Creates an assert command object, asserting the given expression */\n\t\tIassert assertCommand(IExpr expr);\n\t\t\n\t\t/** Creates a check-sat command object */\n\t\tIcheck_sat check_sat();\n\t\t\n\t\t/** Creates a declare-fun command object */\n\t\tIdeclare_fun declare_fun(IIdentifier id, List\u003cISort\u003e argSorts, ISort resultSort);\n\t\t\n\t\t/** Creates a declare-sort command object. */\n\t\tIdeclare_sort declare_sort(ISymbol sym, INumeral arity);\n\t\t\n\t\t/** Creates a define-fun command object */\n\t\tIdefine_fun define_fun(IIdentifier id, List\u003cIDeclaration\u003e declarations, ISort resultSort, IExpr expression);\n\t\t\n\t\t/** Creates a define-sort command object. */\n\t\tIdefine_sort define_sort(IIdentifier id, List\u003cIParameter\u003e parameters, ISort.IApplication expression);\n\t\t\n\t\t/** Creates an exit command object. */\n\t\tIexit exit();\n\t\t\n\t\t/** Creates a get-assertions command object. */\n\t\tIget_assertions get_assertions();\n\t\t\n\t\t/** Creates a get-assignment command object. */\n\t\tIget_assignment get_assignment();\n\t\t\n\t\t/** Creates a get-info command object. */\n\t\tIget_info get_info(IKeyword infoflag);\n\t\t\n\t\t/** Creates a get-option command object */\n\t\tIget_option get_option(IKeyword option);\n\t\t\n\t\t/** Creates a get-proof command object. */\n\t\tIget_proof get_proof();\n\t\t\n\t\t/** Creates a get-unsat-core command object. */\n\t\tIget_unsat_core get_unsat_core();\n\t\t\n\t\t/** Creates a get-value command object. */\n\t\tIget_value get_value(List\u003cIExpr\u003e exprs);\n\t\t\n\t\t/** Creates a push command object. */\n\t\tIpush push(INumeral number);\n\t\t\n\t\t/** Creates a pop command object. */\n\t\tIpop pop(INumeral number);\n\t\t\n\t\t/** Creates a set-logic command object */\n\t\tIset_logic set_logic(ISymbol logic);\n\t\t\n\t\t/** Creates a set-info command object. */\n\t\tIset_info set_info(IKeyword infoflag, IAttributeValue value);\n\t\t\n\t\t/** Creates a set-option command object. */\n\t\tIset_option set_option(IKeyword option, IAttributeValue value);\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB scripts. A script may consist of a file or an explicit list of commands. */\n\t\n\tstatic public interface IScript extends IAccept {\n\t\t/*@Nullable*/ IStringLiteral filename();\n\t\t/*@Nullable*/ List\u003cICommand\u003e commands();\n\t\tIResponse execute(ISolver solver);\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB assert commands. */\n\tstatic public interface Iassert extends ICommand {\n\t\tIExpr expr();\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB check-sat commands. */\n\tstatic public interface Icheck_sat extends ICommand {\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB check-sat-assuming commands. */\n\tstatic public interface Icheck_sat_assuming extends ICommand {\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB declare-const commands. */\n\tstatic public interface Ideclare_const extends ICommand {\n\t\tISymbol symbol();\n\t\tISort resultSort();\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB declare-fun commands. */\n\tstatic public interface Ideclare_fun extends ICommand {\n\t\tISymbol symbol();\n\t\tList\u003cISort\u003e argSorts();\n\t\tISort resultSort();\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB declare-sort commands. */\n\tstatic public interface Ideclare_sort extends ICommand {\n\t\tISymbol sortSymbol();\n\t\tINumeral arity();\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB define-fun commands. */\n\tstatic public interface Idefine_fun extends ICommand {\n\t\tISymbol symbol();\n\t\tList\u003cIDeclaration\u003e parameters();\n\t\tISort resultSort();\n\t\tIExpr expression();\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB define-sort commands. */\n\tstatic public interface Idefine_sort extends ICommand {\n\t\tISymbol sortSymbol();\n\t\tList\u003cIParameter\u003e parameters();\n\t\tISort expression();\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB exit commands. */\n\tstatic public interface Iexit extends ICommand {\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB get-assertions commands. */\n\tstatic public interface Iget_assertions extends ICommand {\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB get-assignment commands. */\n\tstatic public interface Iget_assignment extends ICommand {\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB get-info commands. */\n\tstatic public interface Iget_info extends ICommand {\n\t\tIKeyword infoflag();\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB get-option commands. */\n\tstatic public interface Iget_option extends ICommand {\n\t\tIKeyword option();\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB get-proof commands. */\n\tstatic public interface Iget_proof extends ICommand {\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB get-unsat-assumptions commands. */\n\tstatic public interface Iget_unsat_assumptions extends ICommand {\n\t}\n\n\t/** Interface to be implemented by all objects representing SMT-LIB get-unsat-core commands. */\n\tstatic public interface Iget_unsat_core extends ICommand {\n\t}\n\n\t/** Interface to be implemented by all objects representing SMT-LIB get-value commands. */\n\tstatic public interface Iget_value extends ICommand {\n\t\t//@ ensures exprs().size \u003e 0;\n\t\tList\u003cIExpr\u003e exprs();\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB pop commands. */\n\tstatic public interface Ipop extends ICommand {\n\t\t//@ ensures \\result.intValue() \u003e= 0;\n\t\tINumeral number();\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB push commands. */\n\tstatic public interface Ipush extends ICommand {\n\t\t//@ ensures \\result.intValue() \u003e= 0;\n\t\tINumeral number();\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB reset commands. */\n\tstatic public interface Ireset extends ICommand {\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB reset-assertions commands. */\n\tstatic public interface Ireset_assertions extends ICommand {\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB set-logic commands. */\n\tstatic public interface Iset_logic extends ICommand {\n\t\tISymbol logic();\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB set-info commands. */\n\tstatic public interface Iset_info extends ICommand {\n\t\tIKeyword infoflag();\n\t\tIAttributeValue value();\n\t}\n\t\n\t/** Interface to be implemented by all objects representing SMT-LIB set-option commands. */\n\tstatic public interface Iset_option extends ICommand {\n\t\tIKeyword option();\n\t\t/*@Nullable*/IAttributeValue value();\n\t}\n}\n",
        "name": "ICommand.java",
        "path": "SMT/src/org/smtlib/ICommand.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMT/src/org/smtlib/ICommand.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 193,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures exprs().size \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 199,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result.intValue() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 205,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result.intValue() \u003e= 0;"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\n * This file is part of the SMT project.\n * Copyright 2010 David R. Cok\n * Created August 2010\n */\npackage org.smtlib.impl;\n\nimport java.io.*;\n\nimport org.smtlib.*;\n\n/** Represents a range of characters in a source - used to indicate the location of errors */\npublic class Pos implements IPos {\n\n\t/** The starting character, beginning from 0 */\n\tint charStart;\n\t/** One past the last character of the range, beginning from 0 */\n\tint charEnd;\n\t\n\t/** The source of text */\n\t/*@Nullable*/ISource source;\n\t\n\t/** Constructor for a Pos object\n\t * @param cs the start position of the character range, 0-based\n\t * @param ce one past the end position of the character range, 0- based\n\t * @param s the source of text to which the character positions refer\n\t */\n\tpublic Pos(int cs, int ce, /*@Nullable*/ISource s) {\n\t\tthis.charStart = cs;\n\t\tthis.charEnd = ce;\n\t\tthis.source = s;\n\t}\n\t\n\t/** The starting character, beginning from 0 */\n\t@Override\n\tpublic int charStart() { return charStart; }\n\t/** One past the last character of the range, beginning from 0 */\n\t@Override\n\tpublic int charEnd() { return charEnd; }\n\t/** The source of text */\n\t@Override\n\tpublic /*@Nullable*/ISource source() { return source; }\n\n\t/** An implementation of IPosable, holding an instance of Pos,\n\t *  that can be used as a base class if necessary */\n\tpublic static class Posable implements IPosable {\n\t\tprotected /*@Nullable*/ IPos pos;\n\t\t@Override\n\t\tpublic IPos pos() { return pos; }\n\t\t@Override\n\t\tpublic void setPos(IPos pos) { this.pos = pos; }\n\t}\n\t\n\t/** An implementation of the ISource interface */\n\tpublic static class Source implements ISource {\n\t\tprivate Reader rdr = null;\n\t\t\n\t\t/** The sequence of characters */\n\t\tprivate CharSequence chars;\n\t\t/** The sequence of characters */\n\t\t@Override\n\t\tpublic CharSequence chars() { return chars; }\n\t\t\n\t\t/** The identifier for the location */\n\t\tprivate /*@Nullable*/ Object location;\n\t\t/** The identifier for the location */\n\t\t@Override\n\t\tpublic /*@Nullable*/ Object location() { return location; }\n\n\t\t/** Creates a Source from a character sequence\n\t\t * @param cs the sequence to use as a source of characters\n\t\t * @param location a designator of the location of the source, used for identification only\n\t\t */\n\t\tpublic Source(CharSequence cs, /*@Nullable*/ Object location) {\n\t\t\tthis.chars = cs;\n\t\t\tthis.location = location;\n\t\t}\n\n\t\t/** Creates a Source from a File; for these objects, the location is the file path (a String)\n\t\t * @param smtConfig the SMT Configuration object\n\t\t * @param f the File object from which to read characters\n\t\t * @throws java.io.FileNotFoundException if a problem occurred opening or reading the file\n\t\t */\n\t\tpublic Source(SMT.Configuration smtConfig, java.io.File f) throws java.io.FileNotFoundException {\n\t\t\trdr = new FileReader(f);\n\t\t\t// The numbers in the next call are not magic - they just double the buffer by a factor of 2 if it is not large enough\n\t\t\tCharSequenceReader csr = new CharSequenceReader(rdr,smtConfig.initialInputBufferSize,0,2);\n\t\t\tcsr.prompter = new SMT.Prompter(smtConfig);\n\t\t\tchars = csr;\n\t\t\tthis.location = f.getPath();\n\t\t}\n\t\t\n\t\t/** Creates a Source from a File\n\t\t * @param smtConfig the SMT Configuration object\n\t\t * @param f the InputStream object from which to read characters\n\t\t * @param location object describing the location of the source\n\t\t */\n\t\tpublic Source(SMT.Configuration smtConfig, InputStream f, Object location) {\n\t\t\trdr = new InputStreamReader(f);\n\t\t\t// The numbers in the next call are not magic - they just double the buffer by a factor of 2 if it is not large enough\n\t\t\tCharSequenceReader csr = new CharSequenceReader(rdr,smtConfig.initialInputBufferSize,0,2);\n\t\t\tcsr.prompter = new SMT.Prompter(smtConfig);\n\t\t\tchars = csr;\n\t\t\tthis.location = location;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void close() {\n\t\t\ttry {\n\t\t\t\trdr.close();\n\t\t\t} catch (IOException e) {}\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic char charAt(int pos) {\n\t\t\treturn this.chars.charAt(pos);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int lineBeginning(int pos) {\n\t\t\tint p = pos;\n\t\t\tif (p \u003e= chars().length()) p = chars().length()-1; // If the length is indeterminate, length() should be INT_MAX\n\t\t\tif (p \u003e 0 \u0026\u0026 charAt(p) == '\\n' \u0026\u0026 charAt(p-1) == '\\r') --p;\n\t\t\tchar c;\n\t\t\twhile (p \u003e= 0 \u0026\u0026 (c=charAt(p)) != '\\n' \u0026\u0026 c != '\\r') --p;\n\t\t\treturn p+1;\n\t\t}\n\t\t\n\t\tprivate final static String eol = System.getProperty(\"line.separator\");\n\t\t\n\t\t@Override\n\t\tpublic String textLine(int pos) {\n\t\t\tint b = lineBeginning(pos);\n\t\t\tint e = nextLineTermination(pos);\n\t\t\tString s = chars.subSequence(b,e+1).toString();\n\t\t\tchar c = s.length() == 0 ? ' ' : s.charAt(s.length()-1);\n\t\t\tif (c != '\\n' \u0026\u0026 c != '\\r') s = s + eol;\n\t\t\treturn s;\n\t\t}\n\n\t\t/** The (last character of) the next line termination sequence after the given character position */\n\t\t//@ requires pos \u003e= 0;\n\t\t//@ ensures \\result \u003e= pos;\n\t\tprotected int nextLineTermination(int pos) {\n\t\t\tchar c;\n\t\t\tif (pos \u003e= chars().length()) return chars().length()-1; // If the length is indeterminate, length() should be INT_MAX\n\t\t\twhile ((c=charAt(pos)) != '\\n' \u0026\u0026 c != '\\r' \u0026\u0026 c != CharSequenceInfinite.endChar) ++pos;\n\t\t\tif (c == '\\r' \u0026\u0026 charAt(pos+1) == '\\n') ++pos;\n\t\t\telse if (c == CharSequenceInfinite.endChar) --pos;\n\t\t\treturn pos;\n\t\t}\n\t\t\n\t\t// Note: this counts lines from the beginning of the character sequence, calling charAt at each\n\t\t// character position; this is not very efficient; the presumption is that this method is called\n\t\t// just for the occasional error message.\n\t\t@Override\n\t\tpublic int lineNumber(int pos) {\n\t\t\tint line = 1;\n\t\t\tchar c;\n\t\t\tfor (int i=0; i\u003cpos; i++) {\n\t\t\t\tc = charAt(i);\n\t\t\t\tif (c == '\\n') line++;\n\t\t\t\telse if (c == '\\r') {\n\t\t\t\t\tline++;\n\t\t\t\t\tif (charAt(i+1) == '\\n') i++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn line;\n\t\t}\n\t}\n}\n",
        "name": "Pos.java",
        "path": "SMT/src/org/smtlib/impl/Pos.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMT/src/org/smtlib/impl/Pos.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 141,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires pos \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 142,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "\t\t//@ ensures \\result \u003e= pos;"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\n * This file is part of the SMT project.\n * Copyright 2010 David R. Cok\n * Created August 2010\n */\npackage org.smtlib;\n\nimport java.util.List;\n\nimport org.smtlib.IExpr.IAttribute;\nimport org.smtlib.IExpr.ISymbol;\nimport org.smtlib.IPos.IPosable;\nimport org.smtlib.sexpr.ISexpr.ISeq;\n\n/** This interface represents responses that can be received from SMT-LIB commands. */\npublic interface IResponse extends IAccept {\n\t\n\t/** Returns true if the response is a SUCCESS response */\n\tboolean isOK();\n\t\n\t/** Returns true if the response is an error response */\n\t//@ ensures \\result \u003c==\u003e (this instanceof IResponse.IError);\n\tboolean isError();\n\t\n\t/** The interface for error responses */\n\tpublic static interface IError extends IResponse, IPosable {\n\t\t/** Returns the error message held by this response */\n\t\tString errorMsg();\n\t\t\n\t\t/** Returns the textual location for the response, if available and applicable, otherwise null. */\n\t\t/*@Nullable*/ IPos pos();\n\t}\n\t\n\t/** An interface for simple pairs of objects */\n\tpublic static interface IPair\u003cT1,T2\u003e {\n\t\tT1 first();\n\t\tT2 second();\n\t}\n\n\t\n\t/** The interface representing the factory for IResponse instances */ // TODO _ more restrictive return types?\n\tpublic static interface IFactory {\n\t\tIError error(String msg);\n\t\tIError error(String msg, /*@Nullable*//*@ReadOnly*/ IPos pos);\n\t\tIResponse empty();\n\t\tIResponse success();\n\t\tIResponse unsupported();\n\t\tIResponse unknown();\n\t\tIResponse sat();\n\t\tIResponse unsat();\n\t\tIResponse immediate_exit();\n\t\tIResponse continued_execution();\n\t\tIResponse memout();\n\t\tIResponse incomplete();\n\t\t/** Returns a constant response with the given canonical name */\n\t\tIResponse constant(String id); // FIXME - use abstract keyword?\n\t\t/** The argument has no SMT-LIB escapes and no enclosing quotes */\n\t\tIResponse stringLiteral(String value);\n\t\tIResponse numericLiteral(int value);\n\t\tIResponse get_option_response(IAttributeValue v);\n\t\tIResponse.IAttributeList get_info_response(IAttribute\u003c?\u003e attr);\n\t\tIResponse.IAttributeList get_info_response(List\u003cIAttribute\u003c?\u003e\u003e attrList);\n\t\tIResponse.IProofResponse get_proof_response();\n\t\tIResponse.IValueResponse get_value_response(List\u003cIPair\u003cIExpr,IExpr\u003e\u003e values);\n\t\t\u003cT1,T2\u003e IPair\u003cT1,T2\u003e pair(T1 first, T2 second);\n\t\tIResponse.IAssignmentResponse get_assignment_response(List\u003cIPair\u003cIExpr.ISymbol,Boolean\u003e\u003e assignments);\n\t\tIResponse.IUnsatCoreResponse get_unsat_core_response(List\u003cISymbol\u003e names);\n\t\tIResponse.IAssertionsResponse get_assertions_response(List\u003cIExpr\u003e exprs);\n\t}\n\t\n\tstatic public interface IAttributeList extends IResponse {\n\t\tpublic List\u003cIAttribute\u003c? extends IAttributeValue\u003e\u003e attributes();\n\t}\n\n\tstatic public interface IAssignmentResponse extends IResponse {\n\t\tpublic List\u003cIPair\u003cIExpr.ISymbol,Boolean\u003e\u003e assignments();\n\t}\n\n\tstatic public interface IValueResponse extends IResponse {\n\t\tpublic List\u003cIPair\u003cIExpr,IExpr\u003e\u003e values();\n\t}\n\n\tstatic public interface IUnsatCoreResponse extends IResponse {\n\t\tpublic List\u003cIExpr.ISymbol\u003e names();\n\t}\n\n\tstatic public interface IAssertionsResponse extends IResponse {\n\t\tpublic List\u003cIExpr\u003e assertions();\n\t}\n\n\tstatic public interface IProofResponse extends IResponse {\n\t\tpublic Object proof();\n\t}\n}\n",
        "name": "IResponse.java",
        "path": "SMT/src/org/smtlib/IResponse.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMT/src/org/smtlib/IResponse.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 21,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result \u003c==\u003e (this instanceof IResponse.IError);"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "package org.smtlib.impl;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.smtlib.*;\nimport org.smtlib.ICommand.IScript;\nimport org.smtlib.IExpr.IStringLiteral;\nimport org.smtlib.IParser.ParserException;\n\n/** This class implements the IScript interface, representing SMT-LIB command scripts */\npublic class Script implements IScript {\n\t// This class can hold either a filename from which to read commands\n\t// or a sequence of commands held directly; it should not have both\n\t\n\t//@ invariant (filename() == null) != (commands() != null);\n\t\n\t/** The filename of the script file */\n\t//@ spec_public\n\tprotected /*@Nullable*/ IStringLiteral filename;\n\t\n\t/** The filename of the script file */\n\t//@ ensures \\result == filename;\n\t@Override\n\tpublic /*@Nullable*/IStringLiteral filename() {\n\t\treturn filename;\n\t}\n\t\n\t/** The list of commands */\n\t//@ spec_public\n\tprotected /*@Nullable*/List\u003cICommand\u003e commands;\n\t\n\t/** Returns a reference to the internal list */\n\t//@ ensures \\result == commands;\n\t@Override\n\tpublic /*@Nullable*/List\u003cICommand\u003e commands() {\n\t\treturn commands;\n\t}\n\n\t/** Constructs a script with no commands */\n\tpublic Script() {\n\t\tfilename = null;\n\t\tcommands = new LinkedList\u003cICommand\u003e();\n\t}\n\t\n\t/** Constructs the script with the given list of commands, hijacking the list itself */\n\t//@ requires (filename != null) != (list != null);\n\tpublic Script(/*@Nullable*/IStringLiteral filename, /*@Nullable*/List\u003cICommand\u003e list) {\n\t\tthis.filename = filename;\n\t\tthis.commands = list;\n\t}\n\t\n\t/** Adds a command to the end of the script */\n\t//@ requires commands() != null;\n\tpublic void add(ICommand command) {\n\t\tif (commands == null) commands = new LinkedList\u003cICommand\u003e();  // FIXME - test without this line\n\t\tcommands.add(command);\n\t}\n\t\n\tpublic String kind() { return \"script\"; }  // FIXME - should override?\n\n\t/** Executes the current list */\n\t// FIXME _ should we have an incremental read and execute option?\n\t@Override\n\tpublic IResponse execute(ISolver solver) {\n\t\tSMT.Configuration smtConfig = solver.smt();\n\t\t/*@Mutable*/FileReader fileReader = null;\n\t\tList\u003cICommand\u003e commands = this.commands;\n\t\tif (filename != null) {\n\t\t\tString filename = this.filename.value();\n\t\t\ttry {\n\t\t\t\tfileReader = new FileReader(new File(filename));\n\t\t\t\tISource source = smtConfig.smtFactory.createSource(new CharSequenceReader(fileReader),filename);\n\t\t\t\tIParser p = smtConfig.smtFactory.createParser(smtConfig,source);\n\t\t\t\tIScript script = p.parseScript();\n\t\t\t\tif (script == null) return smtConfig.responseFactory.error(\"Failed to parse the command script: \" + filename,this.filename.pos());\n\t\t\t\tcommands = script.commands();\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\treturn smtConfig.responseFactory.error(e.toString(),this.filename.pos());\n\t\t\t} catch (IOException e) {\n\t\t\t\treturn smtConfig.responseFactory.error(e.toString(),this.filename.pos());\n\t\t\t} catch (ParserException e) {\n\t\t\t\treturn smtConfig.responseFactory.error(e.toString(),e.pos());\n\t\t\t} finally {\n\t\t\t\tif (fileReader != null) {\n\t\t\t\t\ttry { \n\t\t\t\t\t\tfileReader.close(); \n\t\t\t\t\t} catch (IOException e) { \n\t\t\t\t\t\treturn smtConfig.responseFactory.error(\"Failed to close input file: \" + e,this.filename.pos());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (commands == null) {\n\t\t\treturn smtConfig.responseFactory.error(\"INTERNAL ERROR: Unexpected null command list in a script\");\n\t\t}\n\t\tIterator\u003cICommand\u003e iter = commands.iterator();\n\t\tIResponse response = smtConfig.responseFactory.success();\n\t\tICommand s;\n\t\twhile (iter.hasNext() \u0026\u0026 !response.isError()) {\n\t\t\ts = iter.next();\n\t\t\t// TODO: should we typecheck the entire script before executing it?\n\t\t\tresponse = s.execute(solver);\n\t\t\t// TODO: If we include this output, we need a way to control it via the API so OpenJML can control it\n\t\t\t//if (!r.isOK()) smtConfig.log.logDiag(smtConfig.defaultPrinter.toString(r));\n\t\t}\n\t\treturn response;\n\t}\n\t\n\t/** The accept method for visitor classes; the type parameter is the return type of the accept and visit methods */\n\t@Override\n\tpublic \u003c/*@Nullable*/T\u003e /*@Nullable*/T accept(IVisitor\u003c/*@Nullable*/T\u003e v) throws IVisitor.VisitorException {\n\t\treturn v.visit(this);\n\t}\n}",
        "name": "Script.java",
        "path": "SMT/src/org/smtlib/impl/Script.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMT/src/org/smtlib/impl/Script.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 27,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result == filename;"
        },
        {
          "limitHit": false,
          "lineNumber": 38,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result == commands;"
        },
        {
          "limitHit": false,
          "lineNumber": 51,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires (filename != null) != (list != null);"
        },
        {
          "limitHit": false,
          "lineNumber": 58,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires commands() != null;"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\n * This file is part of the SMT project.\n * Copyright 2010 David R. Cok\n * Created August 2010\n */\npackage org.smtlib.sexpr;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.regex.Matcher;\n\nimport org.smtlib.*;\nimport org.smtlib.ICommand.IScript;\nimport org.smtlib.IExpr.IAsIdentifier;\nimport org.smtlib.IExpr.IAttribute;\nimport org.smtlib.IExpr.IBinaryLiteral;\nimport org.smtlib.IExpr.IBinding;\nimport org.smtlib.IExpr.IDecimal;\nimport org.smtlib.IExpr.IDeclaration;\nimport org.smtlib.IExpr.IHexLiteral;\nimport org.smtlib.IExpr.IIdentifier;\nimport org.smtlib.IExpr.IKeyword;\nimport org.smtlib.IExpr.ILiteral;\nimport org.smtlib.IExpr.INumeral;\nimport org.smtlib.IExpr.IQualifiedIdentifier;\nimport org.smtlib.IExpr.IStringLiteral;\nimport org.smtlib.IExpr.ISymbol;\nimport org.smtlib.impl.*;\nimport org.smtlib.impl.SMTExpr.Keyword;\nimport org.smtlib.impl.SMTExpr.Numeral;\nimport org.smtlib.impl.SMTExpr.StringLiteral;\nimport org.smtlib.impl.SMTExpr.Symbol;\n\n//import checkers.nullness.quals.Nullable;\n/** Parses the standard SMT-LIB concrete syntax to produce ASTs of objects that\n * are instances of the org.smtlib.* interfaces.\n */\npublic class Parser extends Lexer implements IParser {\n\t/** A handle to the parent SMTConfig object, in order to see command-line options\n\t * etc. that are fields of smtConfig */\n\tfinal private SMT.Configuration smtConfig;\n\t\n\t/** Returns a handle to the parent SMTConfig object, in order to see command-line options\n\t * etc. that are fields of smtConfig */\n\tpublic SMT.Configuration smt() { return smtConfig; }\n\t\n\t/** The most recent error, or null */\n\tpublic /*@ Nullable */ IResponse.IError lastError = null;\n\t\n\tpublic /*@ Nullable */ IResponse.IError lastError() { return lastError; }\n\t\n\t/** The (common) factory used to generate objects */\n\tfinal protected IExpr.IFactory factory;\n\t\n\t/** Returns an IPos object for the given character start and end \n\t * positions and including a reference to the parser's source object. \n\t * @param start the start character position (counting from 0)\n\t * @param end the end character position (one past the last actual character to be included)\n\t * @return the IPos object representing the character range within the parser's current source\n\t */\n\tpublic /*@Nullable*//*@ReadOnly*/ IPos pos(/*@Nullable*//*@ReadOnly*/IPos start, /*@Nullable*//*@ReadOnly*/IPos end) { \n\t\tif (start == null || end == null) return null;\n\t\treturn pos(start.charStart(),end.charEnd()); \n\t}\n\t\n\t/** Returns an IPos object for the given character start and end \n\t * positions and including a reference to the parser's source object. \n\t * @param start the start character position (counting from 0)\n\t * @param end the end character position (one past the last actual character to be included)\n\t * @return the IPos object representing the character range within the parser's current source\n\t */\n\tpublic /*@Nullable*/ IPos pos(int start, int end) { \n\t\treturn new Pos(start,end,source()); \n\t} // Use factory instead of new Pos?\n\t\n\t/** Creates a Parser using an SMT configuration object and a source for\n\t * characters; ordinarily use a factory to obtain a parser.\n\t */\n\tpublic Parser(SMT.Configuration smtConfig, ISource src) {\n\t\tsuper(smtConfig, src);\n\t\tthis.smtConfig = smtConfig;\n\t\tthis.factory = smtConfig.exprFactory;\n\t}\n\t\t\n\n\t// See the documentation in the interface\n\t@Override\n\tpublic /*@Nullable*/ICommand.IScript parseScript() {\n\t\t// NOTE: interactive is set false here because it is only ever used for parsing exec scripts\n\t\t// if it is used to parse top-level scripts, we have to pass in the appropriate value\n\t\tboolean interactive = smtConfig.interactive;\n\t\tIScript scr;\n\t\ttry {\n\t\t\tStringLiteral filename;\n\t\t\tif (!isLP()) {\n\t\t\t\tfilename = parseStringLiteral();\n\t\t\t\tif (filename == null) return null;\n\t\t\t\t//scr = smtConfig.commandFactory.script(filename,null);\n\t\t\t\tscr = new Script(filename,null); // FIXME - use a factory, set position\n\t\t\t\t//scr = setPos(smtConfig.commandFactory.script(filename,null),filename.pos());// FIXME - set pos\n\t\t\t} else {\n\t\t\t\t// This loop skips over invalid commands, producing error messages (parseCommand\n\t\t\t\t// returns null); the resulting script is valid, but misses the invalid entries\n\t\t\t\tsmtConfig.interactive = false;\n\t\t\t\tICommand s;\n\t\t\t\tList\u003cICommand\u003e res = new LinkedList\u003cICommand\u003e();\n\t\t\t\tparseLP();\n\t\t\t\tboolean anyError = false;\n\t\t\t\twhile (!isRP()) {\n\t\t\t\t\ts = parseCommand();\n\t\t\t\t\tif (s != null) res.add(s);\n\t\t\t\t\telse anyError = true;\n\t\t\t\t}\n\t\t\t\tILexToken rp = parseRP();\n\t\t\t\tif (rp == null || anyError) return null;\n\t\t\t\tscr = new Script(null,res); // FIXME - use a factory, set position\n\t\t\t\t// FIXME set pos pos(lp.pos(),rp.pos(),source);\n\t\t\t}\n\t\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Completed input\");\n\t\t} catch (ParserException e) {\n\t\t\tsmtConfig.log.logError(smt().responseFactory.error(\n\t\t\t\t\t\"A failure occurred while parsing a command: \" + e,\n\t\t\t\t\te.pos()));\n\t\t\treturn null;\n\t\t} finally {\n\t\t\tsmtConfig.interactive = interactive;\n\t\t}\n\t\treturn scr;\n\t}\n\t\n\t/** This field is used to communicate the beginning LP while parsing commands */\n\tpublic /*@Nullable*/ ILexToken savedlp;\n\t\n\t/** This field is used only to communicate the position of the name of a command to the command creator\n\t * (instead of using method arguments).\n\t */\n\tpublic /*@ReadOnly*/ ISymbol commandName;\n\t\n\t/** Parses the next text in the source as a SMT-LIB command; if an error occurs, the error is logged\n\t * and the method skips through a matching number of right parentheses\n\t *  @return returns the parsed command, or EOD.eod if the end of input has been reached, \n\t *  or null if no valid command could be parsed\n\t */\n\t//@ nullable\n\t/*@Nullable*/\n\t/*@Mutable*/\n\tpublic Command parseCommand() {\n\t\tboolean savedTopLevel = smtConfig.topLevel;\n\t\tCommand command = null;\n\t\ttry {\n\t\t\twhile (true) { // The while loop is just so that AbortParseException can cause a retry\n\t\t\t\ttry {\n\t\t\t\t\tILexToken rp = null;\n\t\t\t\t\tsavedlp = parseLP();\n\t\t\t\t\tif (savedlp == null) {\n\t\t\t\t\t\t// We have not consumed a token - if we don't we may get into\n\t\t\t\t\t\t// an infinite loop; if we skipThruRP, we may consume the\n\t\t\t\t\t\t// whole file - so we skip to an LP\n\t\t\t\t\t\tdo { getToken(); } while (!isLP() \u0026\u0026 !isEOD());\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tString prefixText = prefixCommentText;\n\t\t\t\t\tsmtConfig.topLevel = false;\n\t\t\t\t\tSymbol sym = parseSymbolOrReservedWord(\"Expected a symbol here, not a #\");\n\t\t\t\t\tif (sym == null) {\n\t\t\t\t\t\tskipThruRP();\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tcommandName = sym;\n\t\t\t\t\tString name = sym.value();\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// To create a command, we invoke the 'parse' method (that has a Parser argument)\n\t\t\t\t\t\t// in the class corresponding to the given command name.\n\t\t\t\t\t\t// The parse method is supposed to consume its argument from the parser source;\n\t\t\t\t\t\t// the method does not parse the final right-parenthesis or check that there is no\n\t\t\t\t\t\t// extraneous material beyond the last argument parsed - those checks are done here\n\t\t\t\t\t\t// for all commands. We also set the IPos value for the command here.\n\t\t\t\t\t\t// If an error occurs in parsing the command, an error message should be logged and\n\t\t\t\t\t\t// null returned (if null is returned, an error message is expected to have been logged).\n\t\t\t\t\t\t\n\t\t\t\t\t\t// This call translates a name to the class that implements the command with that name.\n\t\t\t\t\t\t// The user can change the lookup behavior by assigning a new command finder object in\n\t\t\t\t\t\t// the configuration\n\t\t\t\t\t\tClass\u003c? extends ICommand\u003e clazz = smt().commandFinder.findCommand(name);\n\t\t\t\t\t\tif (clazz == null) {\n\t\t\t\t\t\t\tlastError = error(\"Unknown command: \" + name,sym.pos());\n\t\t\t\t\t\t\tcommand = null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Call the static parser method of the command class; that will create an\n\t\t\t\t\t\t\t// instance of the appropriate command, initialized according to the parsed data.\n\t\t\t\t\t\t\t// If the parse fails, null is returned and an error will have been logged.\n\t\t\t\t\t\t\tMethod m = clazz.getMethod(\"parse\",Parser.class);\n\t\t\t\t\t\t\tcommand = (Command)m.invoke(null,this);\n\t\t\t\t\t\t\trp = null;\n\t\t\t\t\t\t\tif (command != null) {\n\t\t\t\t\t\t\t\tif (!isRP()) {\n\t\t\t\t\t\t\t\t\tlastError = error(\"Too many arguments or extraneous material after the command or missing right parenthesis\",\n\t\t\t\t\t\t\t\t\t\t\t//pos(currentPos()-1,currentPos()));\n\t\t\t\t\t\t\t\t\t\t\tpeekToken().pos());\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\trp = parseRP();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (InvocationTargetException ex) {\n\t\t\t\t\t\tif (ex.getTargetException() instanceof StackOverflowError) {\n\t\t\t\t\t\t\tlastError = error(\"Stack overflow occurred while parsing input\", sym.pos());\n\t\t\t\t\t\t\tthrow new ParserException(null,null);\n\t\t\t\t\t\t} else if (ex.getTargetException() instanceof OutOfMemoryError) {\n\t\t\t\t\t\t\tlastError = error(\"Out of memory error occurred while parsing input\", sym.pos());\n\t\t\t\t\t\t\tthrow new ParserException(null,null);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlastError = error(ex.getTargetException().toString(),sym.pos());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (command == null) {\n\t\t\t\t\t\tskipThruRP();\n\t\t\t\t\t} else if (rp == null) {\n\t\t\t\t\t\tskipThruRP();\n\t\t\t\t\t\tcommand = null;\n\t\t\t\t\t}\n\t\t\t\t\tif (command != null) {\n\t\t\t\t\t\tsetPos(command,pos(savedlp.pos(),rp.pos()));\n\t\t\t\t\t\tcommand.prefixText = prefixText;\n\t\t\t\t\t}\n\t\t\t\t} catch (AbortParseException e) {\n\t\t\t\t\tsmtConfig.log.logOut(\"Input aborted\\n\");\n\t\t\t\t\tsmtConfig.topLevel = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t} catch (ParserException e) {\n\t\t\t\t\tMatcher m = skipThroughEndOfLine.matcher(csr);\n\t\t\t\t\tm.region(matcher.regionStart(),matcher.regionEnd());\n\t\t\t\t\tif (e.getMessage() != null) lastError = smtConfig.log.logError(smtConfig.responseFactory.error(e.getMessage(),e.pos()));\n\t\t\t\t\tif (m.lookingAt()) {\n\t\t\t\t\t\t//smtConfig.log.logOut(\"SKIPPED \" + m.start() + \" \" + m.end());\n\t\t\t\t\t\tmatcher.region(m.end(),matcher.regionEnd());\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//smtConfig.log.logOut(\"NOTHING TO SKIP\");\n\t\t\t\t\t} // If the match fails, there was nothing left before the end of the line\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tIPos pos = new Pos(0,0,null);\n\t\t\tlastError = smtConfig.responseFactory.error(\"Error while parsing command: \" + e,pos);\n\t\t\te.printStackTrace(System.out); // FIXME - should write to the log output\n\t\t\tsmtConfig.log.logError(lastError);\n\t\t} finally {\n\t\t\tsmtConfig.topLevel = savedTopLevel;\n\t\t}\n\t\treturn command;\n\t}\n\t\n\t/** A helper check, called by command-specific parse methods in which the commands have no arguments */\n\t//@ requires savedlp != null \u0026\u0026 commandName != null;\n\tpublic boolean checkNoArg() {\n\t\ttry {\n\t\t\tif (!isRP()) {\n\t\t\t\tif (isEOD()) {\n\t\t\t\t\tsmtConfig.log.logError(smtConfig.responseFactory.error(\n\t\t\t\t\t\t\t\"The input ends with an unmatched left parenthesis\",\n\t\t\t\t\t\t\tpos(savedlp.pos(),savedlp.pos())));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tsmtConfig.log.logError(smtConfig.responseFactory.error(\n\t\t\t\t\t\t\"A \" + commandName + \" command takes no arguments\",\n\t\t\t\t\t\tpeekToken().pos())); \n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} catch (ParserException e) {\n\t\t\tsmtConfig.log.logError(smt().responseFactory.error(\n\t\t\t\t\t\"A failure occurred while parsing a command: \" + e,\n\t\t\t\t\te.pos()));\n\t\t\treturn false;\n\t\t}\n\n\t}\n\n\n\t/** Parses an Sexpr\n\t * @return an Sexpr or null if no more input\n\t * @throws ParserException if a parsing problem occurred, such as an invalid token or mismatched parentheses\n\t */\n\t// FIXME - should this log errors and return null instead of throwing an exception?\n\t/*@Nullable*/\n\tpublic ISexpr parseSexpr() throws ParserException {\n\t\tif (isEOD()) return null;\n\t\tILexToken t = getToken();\n\t\tif (t.toString() == IPLexToken.RP) {\n\t\t\tthrow new ParserException(\"Unexpected right parenthesis\",t.pos());\n\t\t}\n\t\tif (t.toString() == IPLexToken.LP) {\n\t\t\tboolean saved = smtConfig.topLevel;\n\t\t\tsmtConfig.topLevel = false;\n\t\t\tSexpr res = parseSeq(t);\n\t\t\tsmtConfig.topLevel = saved; // FIXME - use a try-finally block?\n\t\t\treturn res;\n\t\t} \n\t\tif (!(t instanceof ISexpr)) {\n\t\t\tthrow new ParserException(\"Token is not an S-expression token: \" + t.getClass(),t.pos());\n\t\t}\n\t\treturn (ISexpr)t;\n\t}\n\t\n\t/** Parses and adds Sexpr to a list until parseSexpr returns null (indicating\n\t * a RightParen has been seen or end of input or an error)\n\t * @return a SExpr.Seq containing the sequence of SExpr seen\n\t * @throws ParserException FIXME - no more of these?\n\t */\n\tpublic Sexpr.Seq parseSeq(ILexToken lp) throws ParserException {\n\t\tSexpr.Seq seq = new Sexpr.Seq(); // FIXME - use factory\n\t\t\n\t\twhile (true) {\n\t\t\tILexToken token = getToken();\n\t\t\tif (token.toString() == IPLexToken.RP) {\n\t\t\t\tseq.setPos(pos(lp.pos(),token.pos()));\n\t\t\t\treturn seq;\n\t\t\t} else if (token.toString() == IPLexToken.EMPTY) {\n\t\t\t\tthrow new IParser.ParserException(\"Unbalanced parentheses at end of input\",pos(lp.pos(),lp.pos()));\n\t\t\t} else if (token.toString() == IPLexToken.LP) {\n\t\t\t\tISexpr sexpr = parseSeq(token);\n\t\t\t\tseq.sexprs().add(sexpr);\n\t\t\t} else if (token instanceof ISexpr) {\n\t\t\t\tseq.sexprs().add((ISexpr)token);\n\t\t\t} else {\n\t\t\t\t// FIXME - invalid token\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Parses a qualified identifier (either a symbol, a parameterized identifier, or an as identifier)\n\t * from the token stream, returning null (with logged error messages) if there is not one.\n\t */\n\t@Override\n\tpublic /*@Nullable*/IQualifiedIdentifier parseQualifiedIdentifier() throws ParserException {\n\t\tif (!isLP()) {\n\t\t\treturn parseSymbol();\n\t\t} else {\n\t\t\tILexToken lp = parseLP(); // will succeed since isLP() was true\n\t\t\tISymbol head = parseSymbolOrReservedWord(\"Expected a symbol here, not a #\");\n\t\t\tif (head == null) { \n\t\t\t\t \n\t\t\t} else if (head.toString().equals(\"as\")) {\n\t\t\t\treturn parseAsIdentifierRest(lp);\n\t\t\t} else if (head.toString().equals(\"_\")) {\n\t\t\t\treturn parseIdentifierRest(lp);\n\t\t\t} else {\n\t\t\t\terror(\"Invalid beginning of an identifer: expected either 'as' or '_' here\",head.pos());\n\t\t\t}\n\t\t\tskipThruRP();\n\t\t\treturn null; // Unsuccessful parsing\n\t\t}\n\t}\n\t\n//\tprivate \u003cT extends IPos.IPosable\u003e T setPos(T p, IPos pos) { p.setPos(pos); return p; }\n\t\n\t/** Parses an 'as' identifier, presuming the left-paren and the 'as' are already parsed,\n\t * from the token stream, returning null (with logged error messages) if there is not one.\n\t */\n\tprivate /*@Nullable*/ IAsIdentifier parseAsIdentifierRest(ILexToken lp) throws ParserException {\n\t\tIIdentifier name = parseIdentifier();\n\t\tif (name == null) return null;\n\t\tISort sort = parseSort(null);\n\t\tif (sort == null) { skipThruRP(); return null; }\n\t\tILexToken rp = parseRP();\n\t\tif (rp == null) { skipThruRP(); return null; }\n\t\tIPos pos = pos(lp.pos(),rp.pos());\n\t\treturn setPos(smtConfig.exprFactory.id(name,sort),pos);\n\t}\n\t\n\t/** Parses an identifier (either symbol or parameterized identifier) from the token\n\t * stream, returning null with logged error messages if there is not one.\n\t */\n\tpublic /*@Nullable*/IIdentifier parseIdentifier() throws ParserException {\n\t\tif (!isLP()) {\n\t\t\treturn parseSymbol();\n\t\t} else {\n\t\t\tILexToken lp = parseLP();\n\t\t\tISymbol head = parseSymbolOrReservedWord(\"Expected a symbol here, not a #\");\n\t\t\tif (head == null) { \n\t\t\t\t// continue \n\t\t\t} else if (head.toString().equals(\"_\")) {\n\t\t\t\treturn parseIdentifierRest(lp);\n\t\t\t} else {\n\t\t\t\terror(\"Invalid beginning of an identifer: expected a '_' here\",head.pos());\n\t\t\t}\n\t\t\tskipThruRP();\n\t\t\treturn null; // Unsuccessful parsing\n\t\t}\n\t}\n\t\n\t/** Parses a parameterized identifier from the token stream, presuming the left\n\t * parenthesis and the underscore character are already read, return null with \n\t * logged error messages if there is not one.\n\t * @param lp the token for the left parenthesis that starts the identifier\n\t * @return the token or null\n\t * @throws ParserException if unrecoverable error occurs\n\t */\n\tprivate IIdentifier parseIdentifierRest(ILexToken lp) throws ParserException {\n\t\tISymbol name = parseSymbol();\n\t\tif (name == null) { skipThruRP();  return null; }\n\t\tList\u003cINumeral\u003e numerals = new LinkedList\u003cINumeral\u003e();\n\t\tdo {\n\t\t\tif (isEOD()) { \n\t\t\t\terror(\"Unexpected end of data while parsing a parameterized identifier\",pos(lp.pos().charStart(),currentPos()));\n\t\t\t\treturn null; \n\t\t\t}\n\t\t\tINumeral num = parseNumeral();\n\t\t\tif (num == null)  { skipThruRP();  return null; }\n\t\t\tnumerals.add(num);\n\t\t} while (!isRP());\n\t\tILexToken rp = parseRP();\n\t\tif (rp == null)  { skipThruRP();  return null; }\n\t\tIPos pos = pos(lp.pos(),rp.pos());\n\t\treturn setPos(smtConfig.exprFactory.id(name,numerals),pos);\n\t}\n\t\n\t/** Parses an expression, returning null with error messages if there is not a valid\n\t * expression in the token stream.\n\t */\n\t@Override\n\tpublic /*@Nullable*/IExpr parseExpr() throws ParserException {\n\t\t// Here we suffer a bit for using a hand-written top-down parser.\n\t\t// An IExpr can be\n\t\t//\t\tliteral\n\t\t//\t\tsymbol\n\t\t//\t\t( _ symbol numeral+ )\n\t\t//\t\t( as identifier sort )\n\t\t//\t\t( ! ...\n\t\t//\t\t( forall ...\n\t\t//\t\t( exists ...\n\t\t//\t\t( let ...\n\t\t//\t\t( symbol ...\n\t\t//\t\t( ( _ symbol ...\n\t\t//\t\t( ( as ...\n\t\tif (!isLP()) {\n\t\t\tILexToken token = getToken();\n\t\t\tif (token instanceof SMTExpr.Error) return null;\n\t\t\tif (token instanceof IExpr) return (IExpr)token; // FIXME - do we need to check that this is just a literal or symbol\n\t\t\tif (!(token instanceof SMTExpr.Error)) error(\"Expected an expression here\",token.pos());\n\t\t\treturn null;\n\t\t}\n\t\tILexToken lp = getToken();\n\t\tIQualifiedIdentifier head;\n\t\tif (!isLP()) {\n\t\t\thead = parseSymbolOrReservedWord(\"Expected an identifier or reserved word here, not a #\");\n\t\t} else {\n\t\t\thead = parseQualifiedIdentifier();\n\t\t}\n\t\tif (head == null) { skipThruRP(); return null; }\n\t\tif (head instanceof ISymbol) { // in particular we want reserved words here\n\t\t\tString s = ((ISymbol)head).value();\n\t\t\tif (Utils.FORALL.equals(s)) {\n\t\t\t\tList\u003cIDeclaration\u003e decls = parseDeclarations();\n\t\t\t\tIExpr expr = decls == null ? null : parseExpr();\n\t\t\t\tILexToken rp = expr == null ? null : parseRP();\n\t\t\t\tif (rp == null) { skipThruRP(); return null ; }\n\t\t\t\treturn setPos(smtConfig.exprFactory.forall(decls, expr), pos(lp.pos(), rp.pos()));\n\t\t\t} else if (Utils.EXISTS.equals(s)) {\n\t\t\t\tList\u003cIDeclaration\u003e decls = parseDeclarations();\n\t\t\t\tIExpr expr = decls == null ? null : parseExpr();\n\t\t\t\tILexToken rp = expr == null ? null : parseRP();\n\t\t\t\tif (rp == null) { skipThruRP(); return null ; }\n\t\t\t\treturn setPos(smtConfig.exprFactory.exists(decls, expr), pos(lp.pos(), rp.pos()));\n\t\t\t} else if (Utils.LET.equals(s)) {\n\t\t\t\tList\u003cIBinding\u003e decls = parseBindings();\n\t\t\t\tIExpr expr = decls == null ? null : parseExpr();\n\t\t\t\tILexToken rp = expr == null ? null : parseRP();\n\t\t\t\tif (rp == null) { skipThruRP(); return null ; }\n\t\t\t\treturn setPos(smtConfig.exprFactory.let(decls, expr), pos(lp.pos(), rp.pos()));\n\t\t\t} else if (Utils.AS.equals(s)) {\n\t\t\t\treturn parseAsIdentifierRest(lp);\n\t\t\t} else if (Utils.UNDERSCORE.equals(s)) {\n\t\t\t\treturn parseIdentifierRest(lp);\n\t\t\t} else if (Utils.NAMED_EXPR.equals(s)) {\n\t\t\t\tIExpr expr = parseExpr();\n\t\t\t\tif (expr instanceof IExpr.IError) expr = null;\n\t\t\t\tList\u003cIAttribute\u003c?\u003e\u003e list = parseAttributeSequence();\n\t\t\t\tif (list == null) { skipThruRP(); return null; }\n\t\t\t\tILexToken rp = parseRP();\n\t\t\t\tif (rp == null) { skipThruRP(); return null; }\n\t\t\t\treturn setPos(smtConfig.exprFactory.attributedExpr(expr,list),pos(lp.pos(), rp.pos()));\n\t\t\t}\n\t\t}\n\t\tList\u003cIExpr\u003e list = new LinkedList\u003cIExpr\u003e();\n\t\tboolean anyErrors = false;\n\t\twhile (!isRP()) {\n\t\t\tif (isEOD()) {\n\t\t\t\terror(\"Unexpected end of data while parsing a sequence of expressions\",pos(lp.pos().charStart(),currentPos()));\n\t\t\t\treturn null; \n\t\t\t}\n\t\t\tIExpr e = parseExpr();\n\t\t\tif (e != null) list.add(e);\n\t\t\telse anyErrors = true;\n\t\t}\n\t\tif (anyErrors) { skipThruRP(); return null; }\n\t\tILexToken rp = parseRP();\n\t\tif (rp == null) { skipThruRP(); return null; }\n\t\tif (list.size() == 0) {\n\t\t\terror(\"A function expression must have at least one argument\",pos(lp.pos(),rp.pos()));\n\t\t\treturn null;\n\t\t}\n\t\treturn setPos(smtConfig.exprFactory.fcn(head,list), pos(lp.pos(), rp.pos()));\n\t}\n\t\n\t/** Parses a parenthesized sequence of IDeclaration items, returning null with error messages if an error occurs */\n\tpublic /*@Nullable*/List\u003cIDeclaration\u003e parseDeclarations() throws ParserException {\n\t\tILexToken lp = parseLP();\n\t\tif (lp == null) return null;\n\t\tSet\u003cISymbol\u003e names = new HashSet\u003cISymbol\u003e();\n\t\tList\u003cIDeclaration\u003e decls = new LinkedList\u003cIDeclaration\u003e();\n\t\twhile (!isRP()) {\n\t\t\tif (isEOD()) {\n\t\t\t\terror(\"Unexpected end of data while parsing a sequence of declarations\",pos(lp.pos().charStart(),currentPos()));\n\t\t\t\treturn null; \n\t\t\t}\n\t\t\tIDeclaration decl = parseDeclaration();\n\t\t\tif (decl == null) { skipThruRP(); return null; }\n\t\t\tdecls.add(decl);\n\t\t\tif (!names.add(decl.parameter())) {\n\t\t\t\terror(\"Parameter list has a duplicate name: \" + smtConfig.defaultPrinter.toString(decl.parameter()),decl.parameter().pos());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tILexToken rp = parseRP();\n\t\tif (rp == null) { skipThruRP(); return null; }\n\t\treturn decls;\n\t}\n\n\t/** Parses a parenthesized sequence of let-bindings, returning null with error messages if an error occurs */\n\tpublic /*@Nullable*/List\u003cIBinding\u003e parseBindings() throws ParserException {\n\t\tILexToken lp = parseLP();\n\t\tif (lp == null) return null;\n\t\tList\u003cIBinding\u003e decls = new LinkedList\u003cIBinding\u003e();\n\t\tSet\u003cISymbol\u003e names = new HashSet\u003cISymbol\u003e();\n\t\twhile (!isRP()) {\n\t\t\tif (isEOD()) {\n\t\t\t\terror(\"Unexpected end of data while parsing a sequence of parameter bindings\",pos(lp.pos().charStart(),currentPos()));\n\t\t\t\treturn null; \n\t\t\t}\n\t\t\tIBinding decl = parseBinding();\n\t\t\tif (decl == null) { skipThruRP(); return null; }\n\t\t\tdecls.add(decl);\n\t\t\tif (!names.add(decl.parameter())) {\n\t\t\t\terror(\"Parameter list has a duplicate name: \" + smtConfig.defaultPrinter.toString(decl.parameter()),decl.parameter().pos());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tILexToken rp = parseRP();\n\t\tif (rp == null) { skipThruRP(); return null; }\n\t\treturn decls;\n\t}\n\n\t/** Parses a declaration \"(id sort)\", returning null with error messages if an error occurs */\n\t@Override\n\tpublic /*@Nullable*/IDeclaration parseDeclaration() throws ParserException {\n\t\tILexToken lp = parseLP();\n\t\tISymbol sym = lp == null ?  null : parseSymbol();\n\t\tISort sort = sym == null ? null : parseSort(null);\n\t\tILexToken rp = sort == null ? null : parseRP();\n\t\tif (rp == null) return null;\n\t\t//ISymbol.IParameter p = new Symbol.Parameter(sym); // FIXME - use a factory\n\t\treturn setPos(smtConfig.exprFactory.declaration(sym,sort), pos(lp.pos(), rp.pos()));\n\t}\n\n\t/** Parses a binding \"(id expression)\", returning null with error messages if an error occurs */\n\t@Override\n\tpublic /*@Nullable*/IBinding parseBinding() throws ParserException {\n\t\tILexToken lp = parseLP();\n\t\tISymbol sym = lp == null ?  null : parseSymbol();\n\t\tIExpr expr = sym == null ? null : parseExpr();\n\t\tILexToken rp = expr == null ? null : parseRP();\n\t\tif (rp == null) return null;\n\t\t//ISymbol.ILetParameter p = new Symbol.LetParameter(sym); // FIXME - use a factory\n\t\treturn setPos(smtConfig.exprFactory.binding(sym,expr), pos(lp.pos(), rp.pos()));\n\t}\n\n\t/** Parses a symbol, returning null with messages and not advancing the parser if an error occurs */\n\t@Override\n\tpublic /*@Nullable*/Symbol parseSymbol() throws ParserException {\n\t\treturn parseSymbol(\"Expected a symbol here, not a #\");\n\t}\n\n\t/** Parses a symbol (but not a reserved word unless the configuration field 'relax' is true), \n\t * returning null with messages if an error occurs; the parser is advanced only if an actual symbol is parsed.  The error message\n\t * is given by the argument; it may contain a '#' character that will be replaced by the\n\t * kind() of the token actually observed; if the argument is null, no error message is\n\t * emitted. */\n\tpublic /*@Nullable*/Symbol parseSymbol(/*@Nullable*/String msg) throws ParserException {\n\t\tILexToken token = peekToken();\n\t\tif (token instanceof Symbol) {\n\t\t\tif (smtConfig.relax) {\n\t\t\t\tif (smtConfig.reservedWordsNotCommands.contains(token.toString())) {\n\t\t\t\t\terror(\"A reserved word may not be used as a symbol here: \" + token.toString(),token.pos());\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (smtConfig.reservedWords.contains(token.toString())) {\n\t\t\t\t\terror(\"A reserved word may not be used as a symbol here: \" + token.toString(),token.pos());\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoken = getToken();\n\t\t\treturn (Symbol)token;\n\t\t}\n\t\tif (!(token instanceof SMTExpr.Error) \u0026\u0026 msg != null) error(msg.replace(\"#\",token.kind()),token.pos());\n\t\treturn null;\n\t}\n\n\t/** Parses a symbol or a reserved word, returning null with messages if an error occurs.  The error message\n\t * is given by the argument; it may contain a '#' character that will be replaced by the\n\t * kind() of the token actually observed. */\n\tpublic /*@Nullable*/Symbol parseSymbolOrReservedWord(String msg) throws ParserException {\n\t\tILexToken token = getToken();\n\t\tif (token instanceof Symbol) return (Symbol)token;\n\t\tif (!(token instanceof SMTExpr.Error)) error(msg.replace(\"#\",token.kind()),token.pos());\n\t\treturn null;\n\t}\n\n\t/** Parses a literal, returning null with error messages if an error occurs. */\n\t@Override\n\tpublic /*@Nullable*/ILiteral parseLiteral() throws ParserException {\n\t\tILexToken token = getToken();\n\t\tif (token instanceof ILiteral) return (ILiteral)token;\n\t\tif (!(token instanceof SMTExpr.Error)) error(\"Expected a literal here, instead of a \" + token.kind(),token.pos());\n\t\treturn null;\n\t}\n\n\t/** Parses a numeral, returning null with error messages if an error occurs; if\n\t * the next token is not a numeral, the token is not consumed, */\n\t@Override\n\tpublic /*@Nullable*/INumeral parseNumeral() throws ParserException {\n\t\tILexToken token = getToken(INumeral.class);\n\t\tif (token instanceof INumeral) return (INumeral)token;\n\t\tif (!(token instanceof SMTExpr.Error)) error(\"Expected a numeral here, instead of a \" + token.kind(),token.pos());\n\t\treturn null;\n\t}\n\n\t/** Parses a numeral, returning null with the given message if an error occurs; if\n\t * the next token is not a numeral, the token is not consumed, */\n\tpublic /*@Nullable*/Numeral parseNumeral(String msg) throws ParserException {\n\t\tILexToken token = getToken(INumeral.class);\n\t\tif (token instanceof Numeral) return (Numeral)token;\n\t\tif (!(token instanceof SMTExpr.Error)) error(msg,token);\n\t\treturn null;\n\t}\n\n\t/** Parses a decimal, returning null with the given message if an error occurs; if\n\t * the next token is not a decimal, the token is not consumed, */\n\t@Override\n\tpublic IDecimal parseDecimal() throws ParserException {\n\t\tILexToken token = getToken(IDecimal.class);\n\t\tif (token instanceof IDecimal) return (IDecimal)token;\n\t\tif (!(token instanceof SMTExpr.Error)) error(\"Expected a decimal here, instead of a \" + token.kind(),token.pos());\n\t\treturn null;\n\t}\n\n\t/** Parses a binary literal, returning null with the given message if an error occurs; if\n\t * the next token is not a binary literal, the token is not consumed, */\n\t@Override\n\tpublic IBinaryLiteral parseBinary() throws ParserException {\n\t\tILexToken token = getToken(IBinaryLiteral.class);\n\t\tif (token instanceof IBinaryLiteral) return (IBinaryLiteral)token;\n\t\tif (!(token instanceof SMTExpr.Error)) error(\"Expected a binary literal here, instead of a \" + token.kind(),token.pos());\n\t\treturn null;\n\t}\n\n\t/** Parses a hex literal, returning null with the given message if an error occurs; if\n\t * the next token is not a hex literal, the token is not consumed, */\n\t@Override\n\tpublic IHexLiteral parseHex() throws ParserException {\n\t\tILexToken token = getToken(IHexLiteral.class);\n\t\tif (token instanceof IHexLiteral) return (IHexLiteral)token;\n\t\tif (!(token instanceof SMTExpr.Error)) error(\"Expected a hex literal here, instead of a \" + token.kind(),token.pos());\n\t\treturn null;\n\t}\n\t\n\t/** Parses a string literal, returning null with an error message if an error occurs; if\n\t * the next token is not a string literal, the token is not consumed, */\n\t@Override\n\tpublic /*@Nullable*/StringLiteral parseStringLiteral() throws ParserException {\n\t\tILexToken token = getToken(IStringLiteral.class);\n\t\tif (token instanceof StringLiteral) return (StringLiteral)token;\n\t\tif (!(token instanceof SMTExpr.Error)) error(\"Expected a string literal here, instead of a \" + token.kind(),token.pos());\n\t\treturn null;\n\t}\n\n\t/** Parses a keyword, returning null with an error message if an error occurs; if\n\t * the next token is not a keyword, the token is not consumed. */\n\t@Override\n\tpublic /*@Nullable*/Keyword parseKeyword() throws ParserException {\n\t\tILexToken token = getToken(Keyword.class);\n\t\tif (token instanceof Keyword) return (Keyword)token;\n\t\tif (!(token instanceof SMTExpr.Error)) error(\"Expected a keyword (beginning with a colon) here, instead of a \" + token.kind(),token.pos());\n\t\treturn null;\n\t}\n\n\t/** Parses a keyword, returning null with messages if an error occurs.  The error message\n\t * is given by the argument; it may contain a '#' character that will be replaced by the\n\t * kind() of the token actually observed; if\n\t * the next token is not a keyword, the token is not consumed. */\n\tpublic /*@Nullable*/Keyword parseKeyword(String msg) throws ParserException {\n\t\tILexToken token = getToken(Keyword.class);\n\t\tif (token instanceof Keyword) return (Keyword)token;\n\t\tif (!(token instanceof SMTExpr.Error)) error(msg.replace(\"#\",token.kind()),token.pos());\n\t\treturn null;\n\t}\n\t\n\t/** Parses a sort, returning null with error messages if a valid sort is not in the \n\t * next parser tokens.\n\t */\n\t// Can be:\n\t//\t\tid\n\t//\t\t( id sort+ )\n\t// so \n\t//\t\tsymbol\n\t//\t\t( _ symbol numeral+ )\n\t//\t\t( symbol sort+ )\n\t//\t\t( ( _ symbol numeral+ ) sort+ )\n\t@Override\n\tpublic /*@Nullable*/Sort parseSort(List\u003cISort.IParameter\u003e parameters) throws ParserException {\n\t\tif (!isLP()) {\n\t\t\tSymbol sym = parseSymbol();\n\t\t\tif (sym == null) { getToken(); return null; } // Make sure to make some forward progress\n\t\t\tif (parameters != null) {\n\t\t\t\tfor (ISort.IParameter p: parameters) {\n\t\t\t\t\tif (p.identifier().equals(sym)) return (Sort)p;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn setPos(new Sort.Application(sym),sym.pos());\n\t\t} else {\n\t\t\tILexToken lp = parseLP();\n\t\t\t\n\t\t\tif (!isLP()) {\n\t\t\t\tISymbol head = parseSymbolOrReservedWord(\"Expected a symbol or _ here, not a #\");\n\t\t\t\tif (head == null) { \n\t\t\t\t\treturn null; \n\t\t\t\t} else if (head.toString().equals(\"_\")) {\n\t\t\t\t\tIIdentifier id = parseIdentifierRest(lp);\n\t\t\t\t\tif (id == null) { return null; }\n\t\t\t\t\treturn setPos(new Sort.Application(id),id.pos());\n\t\t\t\t}\n\t\t\t\t// else some other symbol\n\n\t\t\t\tList\u003cISort\u003e list = parseSortList(parameters);\n\t\t\t\tif (list == null) { skipThruRP(); return null; }\n\t\t\t\tILexToken rp = parseRP();\n\t\t\t\tif (rp == null) { skipThruRP(); return null; }\n\t\t\t\treturn setPos(new Sort.Application(head,list),pos(lp.pos(),rp.pos()));\n\t\t\t} else {\n\t\t\t\tIIdentifier id = parseIdentifier();\n\t\t\t\tif (id == null) { skipThruRP(); return null; }\n\t\t\t\tList\u003cISort\u003e list = parseSortList(parameters);\n\t\t\t\tif (list == null) { skipThruRP(); return null; }\n\t\t\t\tILexToken rp = parseRP();\n\t\t\t\tif (rp == null) { skipThruRP(); return null; }\n\t\t\t\treturn setPos(new Sort.Application(id,list),pos(lp.pos(),rp.pos()));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/** Parses sequence of sorts up to a right-parenthesis, returning null with error messages\n\t * if an error occurs.\n\t */\n\tpublic /*@Nullable*/List\u003cISort\u003e parseSortList(List\u003cISort.IParameter\u003e parameters) throws ParserException {\n\t\tList\u003cISort\u003e list = new LinkedList\u003cISort\u003e();\n\t\twhile (!isRP()) {\n\t\t\tif (isEOD()) {\n\t\t\t\terror(\"Unexpected end of data while parsing a sort\",pos(currentPos()-1,currentPos()));\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tISort s = parseSort(parameters);\n\t\t\tif (s != null) list.add(s);\n\t\t\telse { skipThruRP(); return null; }\n\t\t}\n\t\treturn list;\n\t}\n\n\t/** Parse an attribute (keyword with optional value), returning null with error messages\n\t * if an error occurs.\n\t */\n\t@Override\n\tpublic /*@Nullable*/IAttributeValue parseAttributeValue() throws ParserException {\n\t\tif (!isLP()) {\n\t\t\tif (isRP()) {\n\t\t\t\tsmtConfig.log.logError(smtConfig.responseFactory.error(\"Expected an attribute value here, instead of a )\",\n\t\t\t\t\t\tpos(currentPos()-1,currentPos())));\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tILexToken t = getToken();\n\t\t\tif (t.isError()) {\n\t\t\t\t// Already have an error message\n\t\t\t\t//smtConfig.log.logError(smtConfig.responseFactory.error(\"Expected an attribute value here, instead of a \" + t.kind(),t.pos()));\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (t instanceof IKeyword) {\n\t\t\t\tsmtConfig.log.logError(smtConfig.responseFactory.error(\"Expected an attribute value here, instead of a \" + t.kind(),t.pos()));\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (t instanceof IAttributeValue) {\n\t\t\t\tIAttributeValue v = (IAttributeValue)t;\n\t\t\t\treturn v;\n\t\t\t} else {\n\t\t\t\tsmtConfig.log.logError(smtConfig.responseFactory.error(\"Expected an attribute value here, instead of a \" + t.kind(),t.pos()));\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\tISexpr value = parseSexpr();\n\t\t\tif (value == null) return null;\n\t\t\treturn value;\n\t\t}\n\t}\n\t\n\t/** Parse an attribute (keyword with optional value), returning null with error messages\n\t * if an error occurs.\n\t */\n\t@Override\n\tpublic /*@Nullable*/IExpr.IAttribute\u003c?\u003e parseAttribute() throws ParserException {\n\t\tIKeyword keyword = parseKeyword();\n\t\tif (keyword == null) return null;\n\t\tif (isRP() || isEOD()) {\n\t\t\treturn setPos(smtConfig.exprFactory.attribute(keyword),keyword.pos());\n\t\t}\n\t\tILexToken n = peekToken();\n\t\tif (n instanceof IKeyword) {\n\t\t\treturn setPos(smtConfig.exprFactory.attribute(keyword),keyword.pos());\n\t\t} else {\n\t\t\tif (!isLP()) {\n\t\t\t\tILexToken t = getToken();\n\t\t\t\tif (t instanceof IAttributeValue) {\n\t\t\t\t\tIAttributeValue v = (IAttributeValue)t;\n\t\t\t\t\treturn setPos(smtConfig.exprFactory.attribute(keyword,v),pos(keyword.pos(),v.pos()));\n\t\t\t\t} else {\n\t\t\t\t\tsmtConfig.log.logError(smtConfig.responseFactory.error(\"The value for the keyword \" + \n\t\t\t\t\t\t\tsmtConfig.defaultPrinter.toString(keyword) + \" is not a legal attribute value\"));\n\t\t\t\t\treturn null;\n\t\t\t\t}\n//\t\t\t} else if (keyword.toString().equals(\":pattern\")) {\n//\t\t\t\tparseLP();\n//\t\t\t\tIExpr value = parseExpr();\n//\t\t\t\tif (value == null) return null;\n//\t\t\t\tparseRP();\n//\t\t\t\t// FIXME - value should be a list of IExpr\n//\t\t\t\treturn setPos(smtConfig.exprFactory.attribute(keyword,value),pos(keyword.pos(),value.pos()));\n\t\t\t} else {\n\t\t\t\tISexpr value = parseSexpr();\n\t\t\t\tif (value == null) return null;\n\t\t\t\treturn setPos(smtConfig.exprFactory.attribute(keyword,value),pos(keyword.pos(),value.pos()));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/** Parse a sequence of attributes (keyword with optional value) terminated by a right parenthesis, returning null with error messages\n\t * if an error occurs.\n\t */\n\tpublic /*@Nullable*/List\u003cIExpr.IAttribute\u003c?\u003e\u003e parseAttributeSequence() throws ParserException {\n\t\tList\u003cIExpr.IAttribute\u003c?\u003e\u003e list = new LinkedList\u003cIExpr.IAttribute\u003c?\u003e\u003e();\n\t\twhile (!isRP()) {\n\t\t\tif (isEOD()) {\n\t\t\t\tsmtConfig.responseFactory.error(\"Unexpected end of data while parsing attributes\",\n\t\t\t\t\t\tpos(currentPos()-1,currentPos()));\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tIExpr.IAttribute\u003c?\u003e attr = parseAttribute();\n\t\t\tif (attr == null) return null;\n\t\t\tlist.add(attr);\n\t\t}\n\t\treturn list;\n\t}\n\t\n\t/** Parses a logic definition (including beginning and ending parentheses, returning null\n\t * with error messages if it fails; only part of the checking of the contents is\n\t * performed in this call (the rest is done in loadLogic).\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic /*@Nullable*/ ILogic parseLogic() throws ParserException {\n\t\tILexToken lp = parseLP();\n\t\tif (lp == null) return null;\n\t\tISymbol sym = parseSymbol();\n\t\tif (sym == null || !Utils.LOGIC.equals(sym.value())) {\n\t\t\terror(\"Faulty logic definition: should have the keyword '\" + Utils.LOGIC + \"' as the first token\",\n\t\t\t\t\tsym == null ? pos(lp.pos(),lp.pos()) : sym.pos());\n\t\t\tskipThruRP(); \n\t\t\treturn null;\n\t\t}\n\t\tISymbol name = parseSymbol();\n\t\tif (name == null) { skipThruRP(); return null; }\n\t\tList\u003cIAttribute\u003c?\u003e\u003e attributes = parseAttributeSequence();\n\t\tif (attributes == null) { skipThruRP(); return null; }\n\t\tILexToken rp = parseRP();\n\t\tif (rp != null) {\n\t\t\tif (!isEOD()) error(\"Expected the end of file after the right parenthesis\",\n\t\t\t\t\tpos(lp.pos().charStart(),currentPos()));\n\t\t}\n\t\tString clazzName = \"org.smtlib.logic.\" + name;\n\t\ttry {\n\t\t\tClass\u003c? extends ILogic\u003e clazz = (Class\u003c? extends ILogic\u003e)Class.forName(clazzName);\n\t\t\tConstructor\u003c? extends ILogic\u003e con = clazz.getConstructor(ISymbol.class,Collection.class);\n\t\t\treturn con.newInstance(name,attributes);\n\t\t} catch (ClassNotFoundException e) {\n\t\t\t// OK - no extension class - no language restrictions\n\t\t} catch (NoSuchMethodException e) {\n\t\t\t// error - the class must have the right constructor\n\t\t\terror(\"The constructor for the class \" + clazzName + \" does not have a constructor with the correct argument types\",\n\t\t\t\t\tpos(lp.pos().charStart(),currentPos()));\n\t\t} catch (IllegalAccessException e) {\n\t\t\t// error - could not create a new instance\n\t\t\terror(\"An exception occured when instantiating class \" + clazzName + \": \" + e,\n\t\t\t\t\tpos(lp.pos().charStart(),currentPos()));\n\t\t} catch (InstantiationException e) {\n\t\t\t// error - could not create a new instance\n\t\t\terror(\"An exception occured when instantiating class \" + clazzName + \": \" + e,\n\t\t\t\t\tpos(lp.pos().charStart(),currentPos()));\n\t\t} catch (InvocationTargetException e) {\n\t\t\t// error - could not create a new instance\n\t\t\terror(\"An exception occured when instantiating class \" + clazzName + \": \" + e,\n\t\t\t\t\tpos(lp.pos().charStart(),currentPos()));\n\t\t}\n\t\treturn new SMTExpr.Logic(name,attributes);\n\t}\n\t\n\t/** Parses a theory definition (including beginning and ending parentheses, returning null\n\t * with error messages if it fails; only part of the checking of the contents is\n\t * performed in this call (the rest is done in loadTheory).\n\t */\n\t@Override\n\tpublic /*@Nullable*/ ITheory parseTheory() throws ParserException {\n\t\tILexToken lp = parseLP();\n\t\tif (lp == null) return null;\n\t\tISymbol sym = parseSymbol();\n\t\tif (sym == null || !Utils.THEORY.equals(sym.value())) {\n\t\t\terror(\"Faulty theory definition: should have the keyword '\" + Utils.THEORY + \"' as the first token\",\n\t\t\t\t\tsym == null ? pos(lp.pos(),lp.pos()) : sym.pos());\n\t\t\tskipThruRP(); \n\t\t\treturn null;\n\t\t}\n\t\tISymbol name = parseSymbol();\n\t\tif (name == null) { skipThruRP(); return null; }\n\t\tList\u003cIAttribute\u003c?\u003e\u003e attributes = parseAttributeSequence();\n\t\tif (attributes == null) { skipThruRP(); return null; }\n\t\tILexToken rp = parseRP();\n\t\tif (rp != null) {\n\t\t\tif (!isEOD()) error(\"Expected the end of file after the right parenthesis\",\n\t\t\t\t\tpos(lp.pos().charStart(),currentPos()));\n\t\t}\n\t\treturn new SMTExpr.Theory(name,attributes);\n\t}\n\t\n\t//@Override // FIXME - put this in the interface\n\tpublic /*@Nullable*/ IResponse parseResponse(String response) throws ParserException {\n\t\tIResponse.IFactory f = smtConfig.responseFactory;\n\t\tresponse = response.trim();\n\t\tif (\"\".equals(response)) return f.empty();\n\t\tif (\"success\".equals(response)) return f.success();\n\t\tif (\"sat\".equals(response)) return f.sat();\n\t\tif (\"unsat\".equals(response)) return f.unsat();\n\t\tif (\"unknown\".equals(response)) return f.unknown();\n\t\tif (\"unsupported\".equals(response)) return f.unsupported();\n\t\tif (\"true\".equals(response)) return smtConfig.exprFactory.symbol(\"true\");\n\t\tif (\"false\".equals(response)) return smtConfig.exprFactory.symbol(\"false\");\n\t\t// FIXME - more - iterate over a list?\n\t\t\n\t\tISexpr sexpr = parseSexpr();\n\t\tif (sexpr instanceof ISexpr.ISeq) {\n\t\t\tList\u003cISexpr\u003e list = ((ISexpr.ISeq)sexpr).sexprs();\n\t\t\tif (list.size() \u003e= 2) {\n\t\t\t\tif (list.get(0).toString().equals(\"error\") \u0026\u0026 list.get(1) instanceof IStringLiteral) {\n\t\t\t\t\treturn f.error(((IStringLiteral)list.get(1)).value());\n\t\t\t\t}\n\t\t\t\tif (list.get(0) instanceof IKeyword) {\n\t\t\t\t\tIAttribute\u003c?\u003e attr = smtConfig.exprFactory.attribute((IKeyword)list.get(0),list.get(1));\n\t\t\t\t\treturn f.get_info_response(attr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sexpr;\n\t\t//return f.error(\"Could not translate response: \" + response);\n\t}\n\t\n\t/** Parses a left parenthesis, returning null and emitting an error message\n\t *  if there isn't one (and the next token is not consumed)\n\t */\n\tpublic /*@Nullable*/ILexToken parseLP() throws ParserException {\n\t\tILexToken token = peekToken();\n\t\tif (token.kind() == LexToken.LP) return getToken();\n\t\tif (!(token instanceof SMTExpr.Error)) error(\"Expected a left parenthesis here, instead of a \" + token.kind(),token.pos());\n\t\treturn null;\n\t}\n\t\n\t/** Parses a right parenthesis, returning null and emitting an error message\n\t *  if there isn't one (and the next token is not consumed)\n\t */\n\tpublic /*@Nullable*/ILexToken parseRP() throws ParserException {\n\t\tILexToken token = peekToken();\n\t\tif (token.kind() == LexToken.RP) return getToken();\n\t\tif (!(token instanceof SMTExpr.Error)) error(\"Expected a right parenthesis here, instead of a \" + token.kind(),token.pos());\n\t\treturn null;\n\t}\n\t\n\t/** Parses a right parenthesis, returning null and emitting an error message\n\t *  if there isn't one (and the next token is not consumed); the error message\n\t *  is the argument, with any '# character replaced by the kind() of the actual next\n\t *  token.\n\t */\n\tpublic /*@Nullable*/ILexToken parseRP(String msg) throws ParserException {\n\t\tILexToken token = peekToken();\n\t\tif (token.kind() == LexToken.RP) return getToken();\n\t\tif (!(token instanceof SMTExpr.Error)) error(msg,token);\n\t\treturn null;\n\t}\n\t\n\t/** Emits an error message consisting of the given message string and position. */\n\tpublic IResponse.IError error(String msg, /*@Nullable*//*@ReadOnly*/IPos pos) {\n\t\treturn smtConfig.log.logError(smtConfig.responseFactory.error(msg,pos));\n\t}\n\t\n\t/** Emits an error message consisting of the given message string with any '#' \n\t * character in the string replaced by the kind() of the second argument; the position\n\t * of the error is the position of the given token. */\n\tpublic void error(String msg, ILexToken token) {\n\t\tif (token.kind().equals(\"error\")) return; // FIXME better comparison? document? no string constant?\n\t\tString description = token.kind();\n\t\tif (description == LexToken.LP) description = \"sequence\";\n\t\tsmtConfig.log.logError(smtConfig.responseFactory.error(msg.replace(\"#\",description),token.pos()));\n\t}\n\n\t\n\t\n}\n",
        "name": "Parser.java",
        "path": "SMT/src/org/smtlib/sexpr/Parser.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMT/src/org/smtlib/sexpr/Parser.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 256,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires savedlp != null \u0026\u0026 commandName != null;"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\n * This file is part of the SMT project.\n * Copyright 2010 David R. Cok\n * Created August 2010\n */\npackage org.smtlib.command;\n\nimport java.io.IOException;\n\nimport org.smtlib.ICommand.Ipop;\nimport org.smtlib.IExpr.INumeral;\nimport org.smtlib.IParser.ParserException;\nimport org.smtlib.IResponse;\nimport org.smtlib.ISolver;\nimport org.smtlib.IVisitor;\nimport org.smtlib.impl.Command;\nimport org.smtlib.sexpr.Parser;\nimport org.smtlib.sexpr.Printer;\n\n/** Implements the pop command */\npublic class C_pop extends Command implements Ipop {\n\t/** The command name */\n\tpublic static final String commandName = \"pop\";\n\t/** The command name */\n\t@Override\n\tpublic String commandName() { return commandName; }\n\t\n\t/** The (non-negative) number of stack frames to pop */\n\t//@ protected invariant n.value().compareTo(BigInteger.ZERO) \u003e 0;\n\tprotected INumeral numeral;\n\t\n\t/** The int value giving the number of stack frames to pop (set by check()), if the value is in the range of an int type */\n\t//@ protected invariant numeral.value().compareTo(BigInteger.MAX_INT) \u003c= 0 ==\u003e numeral.intValue() == number;\n\tprotected int number;\n\t\n\t/** The number of assertion set stack items to pop */\n\t@Override\n\tpublic INumeral number() { \n\t\treturn numeral;\n\t}\n\t/** Constructs a command instance */\n\t//@ requires n.value().compareTo(BigInteger.ZERO) \u003e 0;\n\tpublic C_pop(INumeral n) {\n\t\tnumeral = n;\n\t\tnumber = n.intValue(); \n\t}\n\t\n\t/** Parses the arguments of the command, producing a new command instance */\n\tstatic public /*@Nullable*/ C_pop parse(Parser p) throws ParserException {\n\t\tINumeral num = p.parseNumeral();\n\t\tif (num == null) return null;\n\t\treturn new C_pop(num);\n\t}\n\n\t/** Writes the command in the syntax of the given printer */\n\tpublic void write(Printer p) throws IOException, IVisitor.VisitorException {\n\t\tp.writer().append(\"(\" + commandName + \" \");\n\t\tnumeral.accept(p);\n\t\tp.writer().append(\")\");\n\t}\n\t\n\t@Override\n\tpublic IResponse execute(ISolver solver) {\n\t\treturn solver.pop(number);\n\t}\n\n\t@Override\n\tpublic \u003cT\u003e T accept(IVisitor\u003cT\u003e v) throws IVisitor.VisitorException {\n\t\treturn v.visit(this);\n\t}\n}\n",
        "name": "C_pop.java",
        "path": "SMT/src/org/smtlib/command/C_pop.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMT/src/org/smtlib/command/C_pop.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 41,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires n.value().compareTo(BigInteger.ZERO) \u003e 0;"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\n * This file is part of the SMT project.\n * Copyright 2010 David R. Cok\n * Created August 2010\n */\npackage org.smtlib.command;\n\nimport java.io.IOException;\n\nimport org.smtlib.ICommand.Ipush;\nimport org.smtlib.IExpr.INumeral;\nimport org.smtlib.IParser.ParserException;\nimport org.smtlib.IResponse;\nimport org.smtlib.ISolver;\nimport org.smtlib.IVisitor;\nimport org.smtlib.impl.Command;\nimport org.smtlib.sexpr.Parser;\nimport org.smtlib.sexpr.Printer;\n\n/** Implements the push command */\npublic class C_push extends Command implements Ipush {\n\t/** The command name */\n\tpublic static final String commandName = \"push\";\n\t/** The command name */\n\t@Override\n\tpublic String commandName() { return commandName; }\n\t\n\t/** The (non-negative) number of stack frames to push */\n\t//@ protected invariant n.value().compareTo(BigInteger.ZERO) \u003e 0;\n\tprotected INumeral numeral;\n\t\n\t/** The int value giving the number of stack frames to push (set by check()), if the value is in the range of an int type */\n\t//@ protected invariant numeral.value().compareTo(BigInteger.MAX_INT) \u003c= 0 ==\u003e numeral.intValue() == number;\n\tprotected int number;\n\t\n\t/** The number of assertion set stack items to pop */\n\t@Override\n\tpublic INumeral number() { \n\t\treturn numeral;\n\t}\n\t/** Constructs a command instance */\n\t//@ requires n.value().compareTo(BigInteger.ZERO) \u003e 0;\n\tpublic C_push(INumeral n) {\n\t\tnumeral = n;\n\t\tnumber = n.intValue(); \n\t}\n\t\n\t/** Parses the arguments of the command, producing a new command instance */\n\tstatic public /*@Nullable*/ C_push parse(Parser p) throws ParserException {\n\t\tINumeral num = p.parseNumeral();\n\t\tif (num == null) return null;\n\t\treturn new C_push(num);\n\t}\n\n\t/** Writes the command in the syntax of the given printer */\n\tpublic void write(Printer p) throws IOException, IVisitor.VisitorException {\n\t\tp.writer().append(\"(\" + commandName + \" \");\n\t\tnumeral.accept(p);\n\t\tp.writer().append(\")\");\n\t}\n\t\n\t@Override\n\tpublic IResponse execute(ISolver solver) {\n\t\treturn solver.push(number);\n\t}\n\n\t@Override\n\tpublic \u003cT\u003e T accept(IVisitor\u003cT\u003e v) throws IVisitor.VisitorException {\n\t\treturn v.visit(this);\n\t}\n}\n",
        "name": "C_push.java",
        "path": "SMT/src/org/smtlib/command/C_push.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMT/src/org/smtlib/command/C_push.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 41,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires n.value().compareTo(BigInteger.ZERO) \u003e 0;"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\n * This file is part of the SMT project.\n * Copyright 2010 David R. Cok\n * Created August 2010\n */\npackage org.smtlib.solvers;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.smtlib.*;\nimport org.smtlib.ICommand.*;\nimport org.smtlib.impl.Pos;\nimport org.smtlib.impl.SMTExpr.ParameterizedIdentifier;\nimport org.smtlib.sexpr.ISexpr;\nimport org.smtlib.sexpr.Sexpr;\nimport org.smtlib.ICommand.Idefine_fun;\nimport org.smtlib.IExpr.IAttribute;\nimport org.smtlib.IExpr.IAttributedExpr;\nimport org.smtlib.IExpr.IBinaryLiteral;\nimport org.smtlib.IExpr.IBinding;\nimport org.smtlib.IExpr.IDecimal;\nimport org.smtlib.IExpr.IDeclaration;\nimport org.smtlib.IExpr.IError;\nimport org.smtlib.IExpr.IExists;\nimport org.smtlib.IExpr.IFcnExpr;\nimport org.smtlib.IExpr.IForall;\nimport org.smtlib.IExpr.IHexLiteral;\nimport org.smtlib.IExpr.IIdentifier;\nimport org.smtlib.IExpr.IKeyword;\nimport org.smtlib.IExpr.ILet;\nimport org.smtlib.IExpr.INumeral;\nimport org.smtlib.IExpr.IParameterizedIdentifier;\nimport org.smtlib.IExpr.IStringLiteral;\nimport org.smtlib.IExpr.ISymbol;\nimport org.smtlib.ISort.IApplication;\nimport org.smtlib.IVisitor.VisitorException;\nimport org.smtlib.SMT.Configuration.SMTLIB;\n\n/** This class implements the adapter of SMTv2 to old CVC commands. */ \npublic class Solver_cvc extends Solver_test implements ISolver {\n\t/** Holds the options for the command-line that invokes the solver;\n\t * cmds[0] is filled in with the local file-system path to the executable\n\t */\n\tString cmds[] = new String[]{ \"\", \"+int\" }; \n\t\n\t//private IResponse status;\n\n\t/** The external process driver, initialized in start() */\n\tprivate SolverProcess solverProcess;\n\t\n\tfinal private String errorIndication = \"rror\";\n\t\n\t/** Creates a solver object (which is not yet started)*/\n\tpublic Solver_cvc(SMT.Configuration smtConfig, String executable) {\n\t\tsuper(smtConfig,\"\");\n\t\tcmds[0] = executable;\n\t\tsolverProcess = new SolverProcess(cmds,\"CVC\u003e \",smtConfig.logfile);\n\t}\n\t\n\t@Override\n\tpublic IResponse start() {\n\t\tsuper.start();\n\t\ttry {\n\t\t\tsolverProcess.start(true);\n//\t\t\tString response = solverProcess.sendAndListen(\"DATATYPE T$$PBOOL = _$TRUE | _$FALSE END;\\n\");\n//\t\t\tif (response.contains(errorIndication)) {\n//\t\t\t\treturn smtConfig.responseFactory.error(response);\n//\t\t\t}\n\t\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Started cvc \" );\n\t\t\treturn smtConfig.responseFactory.success();\n\t\t} catch (Exception e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to start process \" + cmds[0] + \" : \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic IResponse exit() {\n\t\tsuper.exit();\n\t\tsolverProcess.exit();\n\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Ended CVC \");\n\t\treturn smtConfig.responseFactory.success();\n\t}\n\n\n\n\t@Override\n\tpublic IResponse assertExpr(IExpr sexpr) {\n\t\ttry {\n\t\t\tIResponse status = super.assertExpr(sexpr);\n\t\t\tif (!status.isOK()) return status;\n\t\t\tString translated = translate(sexpr);\n\t\t\tString response = solverProcess.sendAndListen(\"ASSERT \" + translated + \" ;\\n\");\n\t\t\tif (response.contains(errorIndication)) {\n\t\t\t\treturn smtConfig.responseFactory.error(response);\n\t\t\t}\n\t\t\treturn status;\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to assert expression: \" + e + \" \" + sexpr, sexpr.pos());\n\t\t} catch (VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(e.getMessage(),e.pos());\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse check_sat() { // FIXME - do we need to do a PUSH before a check-sat and then a POP after the last get-value?\n\t\tIResponse res;\n\t\tIResponse status = super.check_sat();\n\t\tif (status.isError()) return status;\n\t\ttry {\n\t\t\tString s = solverProcess.sendAndListen(\"CHECKSAT;\\r\\n\");\n\t\t\t//System.out.println(\"HEARD: \" + s);\n\t\t\tif (s.contains(errorIndication)) {\n\t\t\t\treturn smtConfig.responseFactory.error(s);\n\t\t\t}\n\t\t\tif (s.contains(\"Unsatisfiable.\")) res = smtConfig.responseFactory.unsat();\n\t\t\telse if (s.contains(\"Satisfiable.\")) res = smtConfig.responseFactory.sat();\n\t\t\telse res = smtConfig.responseFactory.unknown();\n\t\t\tcheckSatStatus = res;\n\t\t} catch (IOException e) {\n\t\t\tres = smtConfig.responseFactory.error(\"Failed to check-sat\",null);\n\t\t}\n\t\treturn res;\n\t}\n\n//\t@Override\n//\tpublic CommandResult defineFun(SExpr sexpr) {\n//\t\t// TODO Auto-generated method stub\n//\t\treturn null;\n//\t}\n//\n\t@Override\n\tpublic IResponse pop(int number) {\n\t\ttry {\n\t\t\tIResponse status = super.pop(number);\n\t\t\tif (!status.isOK()) return status;\n\t\t\tif (number == 0) return smtConfig.responseFactory.success();\n\t\t\twhile (number-- \u003e 0) {\n\t\t\t\tString response = solverProcess.sendAndListen(\"POP;\\n\");\n\t\t\t\tif (response.contains(errorIndication)) {\n\t\t\t\t\treturn smtConfig.responseFactory.error(response);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn status;\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to execute pop: \" + e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse push(int number) {\n\t\ttry {\n\t\t\tIResponse status = super.push(number);\n\t\t\tif (!status.isOK()) return status;\n\t\t\tif (number == 0) return smtConfig.responseFactory.success();\n\t\t\twhile (number-- \u003e 0) {\n\t\t\t\tString response = solverProcess.sendAndListen(\"PUSH;\\n\");\n\t\t\t\tif (response.contains(errorIndication)) {\n\t\t\t\t\treturn smtConfig.responseFactory.error(response);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn smtConfig.responseFactory.success();\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to execute push: \" + e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse set_logic(String logicName, /*@Nullable*/ IPos pos) {\n\t\treturn super.set_logic(logicName,pos);\n\t}\n\n\t@Override\n\tpublic IResponse set_option(IKeyword key, IAttributeValue value) {\n\t\tString option = key.value();\n\t\tif (Utils.PRINT_SUCCESS.equals(option)) {\n\t\t\tif (!(Utils.TRUE.equals(value) || Utils.FALSE.equals(value))) {\n\t\t\t\treturn smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be 'true' or 'false'\");\n\t\t\t}\n\t\t}\n\t\tif (logicSet != null \u0026\u0026 (Utils.INTERACTIVE_MODE.equals(option)||Utils.PRODUCE_ASSERTIONS.equals(option))) {\n\t\t\treturn smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be set before the set-logic command\");\n\t\t}\n\t\tif (Utils.PRODUCE_ASSIGNMENTS.equals(option) || \n\t\t\t\t//Utils.PRODUCE_MODELS.equals(option) || \n\t\t\t\tUtils.PRODUCE_PROOFS.equals(option) ||\n\t\t\t\tUtils.PRODUCE_UNSAT_CORES.equals(option)) {\n\t\t\tif (logicSet != null) return smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be set before the set-logic command\");\n\t\t\treturn smtConfig.responseFactory.unsupported();\n\t\t}\n\t\tif (Utils.VERBOSITY.equals(option)) {\n\t\t\tIAttributeValue v = options.get(option);\n\t\t\tsmtConfig.verbose = (v instanceof INumeral) ? ((INumeral)v).intValue() : 0;\n\t\t} else if (Utils.DIAGNOSTIC_OUTPUT_CHANNEL.equals(option)) {\n\t\t\t// Actually, v should never be anything but IStringLiteral - that should\n\t\t\t// be checked during parsing\n\t\t\tString name = (value instanceof IStringLiteral)? ((IStringLiteral)value).value() : \"stderr\";\n\t\t\tif (name.equals(\"stdout\")) {\n\t\t\t\tsmtConfig.log.diag = System.out;\n\t\t\t} else if (name.equals(\"stderr\")) {\n\t\t\t\tsmtConfig.log.diag = System.err;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tFileOutputStream f = new FileOutputStream(name,true); // append\n\t\t\t\t\tsmtConfig.log.diag = new PrintStream(f);\n\t\t\t\t} catch (java.io.IOException e) {\n\t\t\t\t\treturn smtConfig.responseFactory.error(\"Failed to open or write to the diagnostic output \" + e.getMessage(),value.pos());\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Utils.REGULAR_OUTPUT_CHANNEL.equals(option)) {\n\t\t\t// Actually, v should never be anything but IStringLiteral - that should\n\t\t\t// be checked during parsing\n\t\t\tString name = (value instanceof IStringLiteral)?((IStringLiteral)value).value() : \"stdout\";\n\t\t\tif (name.equals(\"stdout\")) {\n\t\t\t\tsmtConfig.log.out = System.out;\n\t\t\t} else if (name.equals(\"stderr\")) {\n\t\t\t\tsmtConfig.log.out = System.err;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tFileOutputStream f = new FileOutputStream(name,true); // append\n\t\t\t\t\tsmtConfig.log.out = new PrintStream(f);\n\t\t\t\t} catch (java.io.IOException e) {\n\t\t\t\t\treturn smtConfig.responseFactory.error(\"Failed to open or write to the regular output \" + e.getMessage(),value.pos());\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Utils.INTERACTIVE_MODE.equals(option) \u0026\u0026 smtConfig.isVersion(SMTLIB.V20)) {\n\t\t\toption = Utils.PRODUCE_ASSERTIONS;\n\t\t}\n\t\toptions.put(option,value);\n\t\tif (key.toString().equals(\":print-success\")) {\n\t\t\tsmtConfig.nosuccess = value.toString().equals(\"false\");\n\t\t}\n\t\treturn smtConfig.responseFactory.success();\n\t}\n\n\t@Override\n\tpublic IResponse get_option(IKeyword key) {\n\t\tString option = key.value();\n\t\tIAttributeValue value = options.get(option);\n\t\tif (value == null) return smtConfig.responseFactory.unsupported();\n\t\treturn value;\n\t}\n\n\t@Override\n\tpublic IResponse get_info(IKeyword key) {\n\t\tString option = key.value();\n\t\tIAttributeValue lit;\n\t\tif (\":error-behavior\".equals(option)) {\n\t\t\tlit = smtConfig.exprFactory.symbol(Utils.CONTINUED_EXECUTION); // FIXME\n\t\t} else if (\":status\".equals(option)) {\n\t\t\treturn checkSatStatus==null ? smtConfig.responseFactory.unsupported() : checkSatStatus; \n\t\t} else if (\":all-statistics\".equals(option)) {\n\t\t\treturn smtConfig.responseFactory.unsupported(); // FIXME\n\t\t} else if (\":reason-unknown\".equals(option)) {\n\t\t\treturn smtConfig.responseFactory.unsupported(); // FIXME\n\t\t} else if (\":authors\".equals(option)) {\n\t\t\tlit = smtConfig.exprFactory.unquotedString(\"Clark Barrett, Cesare Tinelli, and others\");\n\t\t} else if (\":version\".equals(option)) {\n\t\t\tlit = smtConfig.exprFactory.unquotedString(\"2.2\");\n\t\t} else if (\":name\".equals(option)) {\n\t\t\tlit = smtConfig.exprFactory.unquotedString(\"CVC3\");\n\t\t} else {\n\t\t\treturn smtConfig.responseFactory.unsupported();\n\t\t}\n\t\tIAttribute\u003c?\u003e attr = smtConfig.exprFactory.attribute(key,lit);\n\t\treturn smtConfig.responseFactory.get_info_response(attr);\n\t}\n\t\n\t\n\t@Override\n\tpublic IResponse declare_fun(Ideclare_fun cmd){\n\t\ttry {\n\t\t\tIResponse status = super.declare_fun(cmd);\n\t\t\tif (!status.isOK()) return status;\n\t\t\tString encodedName = translate(cmd.symbol());\n\t\t\tString msg = encodedName + \":\";\n\t\t\tif (cmd.argSorts().size() == 0) {\n\t\t\t\tmsg = msg + translate(cmd.resultSort());\n\t\t\t} else if (cmd.argSorts().size() == 1) {\n\t\t\t\tmsg = msg + translate(cmd.argSorts().get(0));\n\t\t\t\tmsg = msg + \"-\u003e\";\n\t\t\t\tmsg = msg + translate(cmd.resultSort());\n\t\t\t} else {\n\t\t\t\tIterator\u003cISort\u003e iter = cmd.argSorts().iterator();\n\t\t\t\tmsg = msg + \"(\" + translate(iter.next());\n\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\tmsg = msg + \",\" + translate(iter.next());\n\t\t\t\t}\n\t\t\t\tmsg = msg + \")-\u003e\";\n\t\t\t\tmsg = msg + translate(cmd.resultSort());\n\t\t\t}\n\t\t\tmsg = msg + \";\\n\";\n\t\t\tString response = solverProcess.sendAndListen(msg);\n\t\t\tif (response.contains(errorIndication)) {\n\t\t\t\treturn smtConfig.responseFactory.error(response);\n\t\t\t}\n\t\t\treturn smtConfig.responseFactory.success();\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to execute set_logic: \" + e);\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to execute set_logic: \" + e, e.pos());\n\t\t}\n\t\t\n\t}\n\t\n\tpublic String encodeSort(IIdentifier id) throws VisitorException {\n\t\tif (id instanceof ISymbol) {\n\t\t\tString nm = org.smtlib.sexpr.Printer.write(id);\n\t\t\tif (\"Bool\".equals(nm)) return \"BOOLEAN\";\n\t\t\tif (\"Int\".equals(nm)) return \"INT\";\n\t\t\tif (\"Real\".equals(nm)) return \"REAL\";\n\t\t\tif (\"Array\".equals(nm)) {\n\t\t\t\tif (!symTable.arrayTheorySet) {\n\t\t\t\t\tthrow new VisitorException(\"Array logic not enabled\",id.pos());\n\t\t\t\t}\n\t\t\t\treturn \"ARRAY\";\n\t\t\t}\n\t\t\treturn \"T$\" + nm;\n\t\t} else if (id instanceof IParameterizedIdentifier){\n\t\t\tIParameterizedIdentifier pid = (IParameterizedIdentifier)id;\n\t\t\tISymbol head = pid.headSymbol();\n\t\t\tString nm = org.smtlib.sexpr.Printer.write(head);\n\t\t\tif (\"BitVec\".equals(nm)) {\n\t\t\t\treturn \"BITVECTOR(\" + pid.numerals().get(0) + \")\";\n\t\t\t}\n\t\t\tnm = \"T$\" + nm;\n\t\t\tfor (INumeral n: pid.numerals()) {\n\t\t\t\tnm = nm + \"$_\" + org.smtlib.sexpr.Printer.write(n);\n\t\t\t}\n\t\t\treturn nm;\n\t\t} else {\n\t\t\tthrow new VisitorException(\"Unexpected kind of identifier: \" + id.getClass(),id.pos());\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic IResponse declare_sort(Ideclare_sort cmd) {\n\t\tIResponse res = super.declare_sort(cmd);\n\t\tif (!res.isOK()) return res;\n\t\ttry {\n\t\t\tif (cmd.arity().value().intValue() == 0) {\n\t\t\t\tString msg = encodeSort(cmd.sortSymbol()) + \": TYPE;\\n\";\n\t\t\t\tString response = solverProcess.sendAndListen(msg);\n\t\t\t\tif (response.contains(errorIndication)) {\n\t\t\t\t\treturn smtConfig.responseFactory.error(response);\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t} else {\n\t\t\t\treturn smtConfig.responseFactory.error(\"CVC adapter does not implement parameterized user-defined sorts\",cmd instanceof IPos.IPosable ? ((IPos.IPosable)cmd).pos() : null);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to execute declare_sort: \" + e);\n\t\t} catch (VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to execute declare_sort: \" + e, e.pos());\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse define_fun(Idefine_fun cmd) {\n\t\tIResponse res = super.define_fun(cmd);\n\t\tif (!res.isOK()) return res;\n\t\ttry {\n\t\t\tif (cmd.parameters().size() == 0) {\n\t\t\t\tString name = encode(cmd.symbol());\n\t\t\t\tString resultSort = translate(cmd.resultSort());\n\t\t\t\tString def = cmd.expression() == null ? null : translate(cmd.expression());\n\t\t\t\tdef = name + \": \" + resultSort + \n\t\t\t\t\t( def == null ? \"\" : (\" = \" + def )) + \n\t\t\t\t\t\";\\n\";\n\t\t\t\tString response = solverProcess.sendAndListen(def);\n\t\t\t\tif (response.contains(errorIndication)) {\n\t\t\t\t\treturn smtConfig.responseFactory.error(response);\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t} else {\n\t\t\t\tString name = encode(cmd.symbol());\n\t\t\t\tStringBuilder def = new StringBuilder();\n\t\t\t\tdef.append(name);\n\t\t\t\tdef.append(\" : \");\n\t\t\t\tif (cmd.parameters().size() == 1) {\n\t\t\t\t\tdef.append(translate(cmd.parameters().get(0).sort()));\n\t\t\t\t} else {\n\t\t\t\t\tdef.append(\"(\");\n\t\t\t\t\tIterator\u003cIDeclaration\u003e iter = cmd.parameters().iterator();\n\t\t\t\t\tdef.append(translate(iter.next().sort()));\n\t\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\t\tdef.append(\",\");\n\t\t\t\t\t\tdef.append(translate(iter.next().sort()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdef.append(\")-\u003e\");\n\t\t\t\tdef.append(translate(cmd.resultSort()));\n\t\t\t\tdef.append(\" = LAMBDA(\");\n\t\t\t\tIterator\u003cIDeclaration\u003e iter = cmd.parameters().iterator();\n\t\t\t\tIDeclaration d = iter.next();\n\t\t\t\tif (cmd.parameters().size() == 1) {\n\t\t\t\t\tdef.append(translate(d.parameter()));\n\t\t\t\t\tdef.append(\":\");\n\t\t\t\t\tdef.append(translate(d.sort()));\n\t\t\t\t} else {\n\t\t\t\t\tdef.append(translate(d.parameter()));\n\t\t\t\t\tdef.append(\":\");\n\t\t\t\t\tdef.append(translate(d.sort()));\n\t\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\t\tdef.append(\",\");\n\t\t\t\t\t\td = iter.next();\n\t\t\t\t\t\tdef.append(translate(d.parameter()));\n\t\t\t\t\t\tdef.append(\":\");\n\t\t\t\t\t\tdef.append(translate(d.sort()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdef.append(\"): \");\n\t\t\t\tdef.append(translate(cmd.expression()));\n\t\t\t\tdef.append(\";\\n\");\n\t\t\t\tString response = solverProcess.sendAndListen(def.toString());\n\t\t\t\tif (response.contains(errorIndication)) {\n\t\t\t\t\treturn smtConfig.responseFactory.error(response);\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to execute define_fun: \" + e);\n\t\t} catch (VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to execute define_fun: \" + e, e.pos());\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse define_sort(Idefine_sort cmd) {\n\t\tIResponse res = super.define_sort(cmd);\n\t\tif (!res.isOK()) return res;\n\t\ttry {\n\t\t\tif (cmd.parameters().size() == 0) {\n\t\t\t\tString def = translate(cmd.expression());\n\t\t\t\tString head = encodeSort(cmd.sortSymbol());\n\t\t\t\tdef = head + \": TYPE = \" + def + \";\\n\";\n\t\t\t\tString response = solverProcess.sendAndListen(def);\n\t\t\t\tif (response.contains(errorIndication)) {\n\t\t\t\t\treturn smtConfig.responseFactory.error(response);\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t} else {\n\t\t\t\treturn smtConfig.responseFactory.error(\"Parameterized sort definitions not implemented\"); // FIXME\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to execute define_sort: \" + e);\n\t\t} catch (VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to execute define_sort: \" + e, e.pos());\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic IResponse get_value(IExpr... terms) {\n\t\tTypeChecker tc = new TypeChecker(symTable);\n\t\ttry {\n\t\t\tfor (IExpr term: terms) {\n\t\t\t\tterm.accept(tc);\n\t\t\t}\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\ttc.result.add(smtConfig.responseFactory.error(e.getMessage()));\n\t\t} finally {\n\t\t\tif (!tc.result.isEmpty()) return tc.result.get(0); // FIXME - report all errors?\n\t\t}\n\t\t// FIXME - do we really want to call get-option here? it involves going to the solver?\n\t\tif (!Utils.TRUE.equals(get_option(smtConfig.exprFactory.keyword(Utils.PRODUCE_MODELS)))) {\n\t\t\treturn smtConfig.responseFactory.error(\"The get-value command is only valid if :produce-models has been enabled\");\n\t\t}\n\t\tif (!smtConfig.responseFactory.sat().equals(checkSatStatus) \u0026\u0026 !smtConfig.responseFactory.unknown().equals(checkSatStatus)) {\n\t\t\treturn smtConfig.responseFactory.error(\"A get-value command is valid only after check-sat has returned sat or unknown\");\n\t\t}\n\t\ttry {\n\t\t\tString response = solverProcess.sendAndListen(\"COUNTERMODEL;\\n\");\n\t\t\tList\u003cISexpr\u003e valueslist = new LinkedList\u003cISexpr\u003e();\n\t\t\torg.smtlib.sexpr.Lexer lexer = new org.smtlib.sexpr.Lexer(smtConfig,null);\n\t\t\tfor (IExpr e: terms) {\n\t\t\t\tList\u003cISexpr\u003e values = new LinkedList\u003cISexpr\u003e();\n\t\t\t\tvalues.add(new Sexpr.Expr(e));\n\t\t\t\tresponse = solverProcess.sendAndListen(\"TRANSFORM \" + translate(e) + \";\\n\");\n\t\t\t\tif (response.endsWith(\"CVC\u003e \")) response = response.substring(0,response.length()-5).trim();\n\t\t\t\tif (response.startsWith(\"0bin\")) response = \"#b\" + response.substring(4);\n\t\t\t\telse if (response.equals(\"TRUE\")) response = \"true\";\n\t\t\t\telse if (response.equals(\"FALSE\")) response = \"false\";\n\t\t\t\telse if (response.contains(\"(\")) {\n\t\t\t\t\tISexpr s = (ISexpr)lexer.getToken(\"\\\"\" + response + \"\\\"\");\n\t\t\t\t\tvalues.add(s);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tISexpr s = ((ISexpr)lexer.getToken(response));\n\t\t\t\tif (s != null) values.add(s);\n\t\t\t\telse {\n\t\t\t\t\t\ts = (ISexpr)lexer.getToken(\"?\");\n\t\t\t\t\t\tvalues.add(s);\n\t\t\t\t}\n\t\t\t\tvalueslist.add(new Sexpr.Seq(values));\n\t\t\t}\n\t\t\treturn new Sexpr.Seq(valueslist);\n//\t\ttry {\n//\t\t\tString response = solverProcess.sendAndListen(\"COUNTERMODEL;\\n\");\n//\t\t\tPattern p = Pattern.compile(\"ASSERT (\\\\(([a-zA-X_]+) = ([0-9a-zA-Z-_\\\\.\\\\(\\\\)]+)|(NOT )?([a-zA-X_]+))\\\\;\");\n//\t\t\tPattern pvalue = Pattern.compile(\"([0-9]+)|(true)|(false)|0bin([01]+)\");\n//\t\t\tMatcher m = p.matcher(response);\n//\t\t\tMap\u003cString,String\u003e map = new HashMap\u003cString,String\u003e();\n//\t\t\twhile (m.find()) {\n//\t\t\t\tString name = m.group(2);\n//\t\t\t\tif (name != null) {\n//\t\t\t\t\tString value = m.group(3);\n//\t\t\t\t\tif (value.startsWith(\"0bin\")) {\n//\t\t\t\t\t\tvalue = \"#b\" + value.substring(4,value.length()-1);\n//\t\t\t\t\t} else {\n//\t\t\t\t\t\tvalue = value.substring(0,value.length()-1);\t\t\t\t\t\t\n//\t\t\t\t\t}\n//\t\t\t\t\tmap.put(name,value);\n//\t\t\t\t} else {\n//\t\t\t\t\tname = m.group(5);\n//\t\t\t\t\tmap.put(name,m.group(4)==null?\"true\":\"false\");\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tList\u003cISexpr\u003e values = new LinkedList\u003cISexpr\u003e();\n//\t\t\torg.smtlib.sexpr.Lexer lexer = new org.smtlib.sexpr.Lexer(smtConfig,null);\n//\t\t\tfor (IExpr e: terms) {\n//\t\t\t\tString v = map.get(e.toString());\n//\t\t\t\tif (v == null) {\n//\t\t\t\t\tISexpr s = (ISexpr)lexer.getToken(\"?\");\n//\t\t\t\t\tvalues.add(s);\n//\t\t\t\t\tcontinue; // FIXME - should have an error\n//\t\t\t\t}\n//\t\t\t\tISexpr s = ((ISexpr)lexer.getToken(v));\n//\t\t\t\tif (s != null) values.add(s);\n//\t\t\t\telse {\n//\t\t\t\t\t\ts = (ISexpr)lexer.getToken(\"\\\"\" + v + \"\\\"\");\n//\t\t\t\t\t\tvalues.add(s);\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\treturn new Sexpr.Seq(values);\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to CVC solver: \" + e);\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to CVC solver: \" + e);\n\t\t} catch (IParser.ParserException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to CVC solver: \" + e);\n\t\t}\n\t}\n\n\n\n\tpublic String translate(IExpr expr) throws IVisitor.VisitorException {\n\t\treturn expr.accept(new Translator(typemap,smtConfig));\n\t}\n\t\n\tpublic String translate(ISort expr) throws IVisitor.VisitorException {\n\t\treturn expr.accept(new Translator(typemap,smtConfig));\n\t}\n\t\n\t/* CVC does distinguish formulas and terms, but allows\n\t * BOOLEAN terms\n\t */\n\t\n\tstatic Map\u003cString,String\u003e fcnNames = new HashMap\u003cString,String\u003e();\n\tstatic Set\u003cString\u003e logicNames = new HashSet\u003cString\u003e();\n\tstatic {\n\t\t/* SMTLIB\t\t\tCVC\n\t\t * (or p q r ...)\t(p OR q OR r ...)\n\t\t * (and p q r ...)\t(p AND q AND r ...)\n\t\t * (not p)\t\t\t(NOT p)\n\t\t * (=\u003e p q r ...)\t(p =\u003e (q =\u003e r)) \n\t\t * (xor p q r ...)\t((p XOR q) XOR r)\n\t\t * (= p q r ...)\t((p \u003c=\u003e q) AND ( q \u003c=\u003e r) ... )   - formulas\n\t\t * (= p q r ...)\t((p = q) AND (q == r) ... )   - terms\n\t\t * (distinct p q r)\t(NOT (p == q))   - formulas (error if more than 2 arguments) \n\t\t * (distinct p q r)\t(DISTINCT p q r ... )   - terms  \n\t\t * true\t\t\t\tTRUE\n\t\t * false\t\t\tFALSE\n\t\t * (ite b p q)\t\t(IF b THEN p ELSE q ENDIF)\n\t\t * \n\t\t */\n\t\t\n\t\tfcnNames.put(\"or\",\"|\");\t\t\t\t// infix for cvc (left-assoc)\n\t\tfcnNames.put(\"and\",\"\u0026\");\t\t\t\t// infix for cvc (left-assoc)\n\t\tfcnNames.put(\"not\",\"~\");\t\t\t\t// prefix\n\t\tfcnNames.put(\"=\u003e\",\"=\u003e\");\t\t\t\t// infix for cvc (right-assoc)\n\t\tfcnNames.put(\"xor\",\"XOR\");\t\t\t\t// infix for cvc (left-assoc)\n\t\tfcnNames.put(\"=\",\"=\"); // \u003c=\u003e for formula \t// infix for cvc (chainable)\n\t\tfcnNames.put(\"distinct\",\"DISTINCT\"); // XOR for formula// \u003e2 arguments OK for cvc (pairwise)\n\t\tfcnNames.put(\"true\",\"TRUE\");\n\t\tfcnNames.put(\"false\",\"FALSE\");\n\t\tfcnNames.put(\"ite\",\"IF\");\t\t\t// special in cvc  IF ... THEN ... ELSE ... FI\n\t\tfcnNames.put(\"+\",\"+\");\t\t\t\t// infix for cvc (left-assoc)\n\t\tfcnNames.put(\"-\",\"-\");\t\t\t\t// infix for cvc (left-assoc)\n\t\tfcnNames.put(\"*\",\"*\");\t\t\t\t// infix for cvc (left-assoc)\n\t\tfcnNames.put(\"\u003e\",\"\u003e\");\t\t\t\t// infix for cvc (left-assoc)\t\t\n\t\tfcnNames.put(\"\u003e=\",\"\u003e=\");\t\t\t// infix for cvc (chainable)\n\t\tfcnNames.put(\"\u003c\",\"\u003c\");\t\t\t\t// infix for cvc (chainable)\n\t\tfcnNames.put(\"\u003c=\",\"\u003c=\");\t\t\t// infix for cvc (chainable)\n\t\t\n\t\tfcnNames.put(\"forall\",\"FORALL\");\n\t\tfcnNames.put(\"exists\",\"EXISTS\");\n\t\tfcnNames.put(\"let\",\"LET\");\n\t\t\n\t\tfcnNames.put(\"bvadd\",\"BVPLUS\"); // needs a first argument of the number of bits\n\t\tfcnNames.put(\"bvsub\",\"BVSUB\"); // needs a first argument of the number of bits\n\t\tfcnNames.put(\"bvmul\",\"BVMULT\"); // needs a first argument of the number of bits\n\t\tfcnNames.put(\"bvneg\",\"BVUMINUS\");\n\t\tfcnNames.put(\"bvnand\",\"BVNAND\");\n\t\tfcnNames.put(\"bvnor\",\"BVNOR\");\n\t\tfcnNames.put(\"bvxor\",\"BVXOR\");\n\t\tfcnNames.put(\"bvxnor\",\"BVXNOR\");\n\t\tfcnNames.put(\"bvnot\",\"~\");\n\t\tfcnNames.put(\"bvand\",\"\u0026\"); // infix\n\t\tfcnNames.put(\"bvor\",\"|\"); // infix\n\t\tfcnNames.put(\"bvudiv\",\"\u0026\"); // FIXME\n\t\tfcnNames.put(\"bvurem\",\"\u0026\"); // FIXME\n\t\tfcnNames.put(\"bvshl\",\"\u003c\u003c\"); // infix// FIXME\n\t\tfcnNames.put(\"bvlshr\",\"\u003e\u003e\"); // infix// FIXME\n\t\tfcnNames.put(\"concat\",\"@\"); // infix\n\t\tfcnNames.put(\"bvult\",\"BVLT\");\n\t\tfcnNames.put(\"bvule\",\"BVLE\");\n\t\tfcnNames.put(\"bvugt\",\"BVGT\");\n\t\tfcnNames.put(\"bvuge\",\"BVGE\");\n\t\tfcnNames.put(\"extract\",\"extract\");\n\t\t\n\t\tlogicNames.add(\"or\");\n\t\tlogicNames.add(\"and\");\n\t\tlogicNames.add(\"not\");\n\t\tlogicNames.add(\"=\u003e\");\n\t}\n\t\n\t\n\tpublic class Translator extends IVisitor.NullVisitor\u003cString\u003e {\n\t\tboolean isFormula = true;\n\t\tfinal private Map\u003cIExpr,ISort\u003e typemap;\n\t\tfinal private SMT.Configuration smtConfig;\n\t\t\n\t\tpublic Translator(Map\u003cIExpr,ISort\u003e typemap, SMT.Configuration smtConfig) {\n\t\t\tthis.typemap = typemap;\n\t\t\tthis.smtConfig = smtConfig;\n\t\t}\n\t\t\n\t\tpublic /*@Nullable*/ IPos pos(Object e) {\n\t\t\treturn e instanceof IPos.IPosable ? ((IPos.IPosable)e).pos() : null;\n\t\t}\n\t\t\n\t\tpublic String encode(IAttributeValue id) throws VisitorException {\n\t\t\tif (id instanceof ISymbol) {\n\t\t\t\treturn org.smtlib.sexpr.Printer.write(id);\n\t\t\t} else if (id instanceof IParameterizedIdentifier){\n\t\t\t\tIParameterizedIdentifier pid = (IParameterizedIdentifier)id;\n\t\t\t\tISymbol head = pid.headSymbol();\n\t\t\t\tString nm = org.smtlib.sexpr.Printer.write(head);\n\t\t\t\tfor (INumeral n: pid.numerals()) {\n\t\t\t\t\tnm = nm + \"$_\" + org.smtlib.sexpr.Printer.write(n);\n\t\t\t\t}\n\t\t\t\treturn nm;\n\t\t\t} else {\n\t\t\t\tthrow new VisitorException(\"Unexpected kind of identifier: \" + id.getClass(),id.pos());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic String encodeSort(IIdentifier id) throws VisitorException {\n\t\t\treturn Solver_cvc.this.encodeSort(id);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String visit(IAttributedExpr e) throws IVisitor.VisitorException {\n\t\t\tIExpr expr = e.expr();\n\t\t\tIAttribute\u003c?\u003e attr = e.attributes().get(0);\n\t\t\tif (attr.keyword().toString().equals(\":named\")) {\n\t\t\t\tString name = encode(attr.attrValue());\n\t\t\t\tString ex = expr.accept(this);\n\t\t\t\tString def = name + \" : \" + \"BOOLEAN\" + \" = \" + ex + \";\\n\";\n\t\t\t\ttry {\n\t\t\t\t\tString response = solverProcess.sendAndListen(def);\n\t\t\t\t\tif (response.contains(errorIndication)) {\n\t\t\t\t\t\tthrow new VisitorException(response,e.pos());\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException exc) {\n\t\t\t\t\tthrow new VisitorException(\"Failed to define attributed expression: \" + exc, e.pos());\n\t\t\t\t}\n\t\t\t\treturn ex;\n\t\t\t} else {\n\t\t\t\tthrow new VisitorException(\"Unexpected kind of keyword: \" + smtConfig.defaultPrinter.toString(attr.keyword()),attr.pos());\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IDecimal e) throws IVisitor.VisitorException {\n\t\t\t// CVC has rationals for decimal numbers\n\t\t\tBigDecimal v = e.value();\n\t\t\tint scale = v.scale();\n\t\t\tif (scale \u003e= 0) {\n\t\t\t\tBigDecimal num = v.scaleByPowerOfTen(scale);\n\t\t\t\tBigDecimal den = BigDecimal.ONE.scaleByPowerOfTen(scale);\n\t\t\t\treturn \"(\" + num.toBigInteger() + \"/\" + den.toBigInteger() + \")\";\n\t\t\t} else {\n\t\t\t\tBigDecimal num = v.scaleByPowerOfTen(-scale);\n\t\t\t\treturn \"(\" + num.toBigInteger() + \")\";\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IStringLiteral e) throws IVisitor.VisitorException {\n\t\t\tthrow new VisitorException(\"The CVC solver cannot handle string literals\", pos(e));\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(INumeral e) throws IVisitor.VisitorException {\n\t\t\treturn org.smtlib.sexpr.Printer.write(e);\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IBinaryLiteral e) throws IVisitor.VisitorException {\n\t\t\t// CVC prefix is 0bin - LSB is on right, MSB on left\n\t\t\treturn \"0bin\" + e.value();\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IHexLiteral e) throws IVisitor.VisitorException {\n\t\t\t// CVC prefix is 0hex - LSB is on right, MSB on left\n\t\t\treturn \"0hex\" + e.value();\n\t\t}\n\t\t\n\t\t//@ requires iter.hasNext();\n\t\tprivate \u003cT extends IExpr\u003e String rightassoc(String fcnname, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\n\t\t\tT n = iter.next();\n\t\t\tif (!iter.hasNext()) {\n\t\t\t\treturn n.accept(this);\n\t\t\t} else {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tsb.append(\"(\");\n\t\t\t\tsb.append(n.accept(this));\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(fcnname);\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(rightassoc(fcnname,iter));\n\t\t\t\tsb.append(\")\");\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\t\t}\n\n\t\t//@ requires iter.hasNext();\n\t\t//@ requires length \u003e 0;\n\t\tprivate \u003cT extends IExpr\u003e String remove_leftassoc(String fcnname, int length, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\n\t\t\tif (length == 1) {\n\t\t\t\treturn iter.next().accept(this);\n\t\t\t} else {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tsb.append(\"(\");\n\t\t\t\tsb.append(remove_leftassoc(fcnname,length-1,iter));\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(fcnname);\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\tsb.append(\")\");\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\t\t}\n\t\t\n\t\t//@ requires iter.hasNext();\n\t\t//@ requires length \u003e 0;\n\t\tprivate \u003cT extends IAccept\u003e String remove_chainable(String newName, int length, Iterator\u003cIExpr\u003e iter ) throws IVisitor.VisitorException {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (length == 2) {\n\t\t\t\tsb.append(\"(\");\n\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(newName);\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\tsb.append(\")\");\n\t\t\t} else {\n\t\t\t\tboolean first = true;\n\t\t\t\tIExpr left = iter.next();\n\t\t\t\tsb.append(\"(\");\n\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\tif (first) first = false; else sb.append(\" AND \");\n\t\t\t\t\tsb.append(\"(\");\n\t\t\t\t\tsb.append(left.accept(this));\n\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\tsb.append(newName);\n\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\tsb.append((left = iter.next()).accept(this));\n\t\t\t\t\tsb.append(\")\");\n\t\t\t\t}\n\t\t\t\tsb.append(\")\");\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tSet\u003cString\u003e infix = new HashSet\u003cString\u003e();\n\t\t{\n\t\t\tinfix.addAll(Arrays.asList(new String[]{\"OR\",\"AND\",\"+\",\"*\",\"XOR\",\"-\",\"/\"}));\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IFcnExpr e) throws IVisitor.VisitorException {\n\t\t\tboolean resultIsFormula = this.isFormula;\n\t\t\tIterator\u003cIExpr\u003e iter = e.args().iterator();\n\t\t\tif (!iter.hasNext()) throw new VisitorException(\"Did not expect an empty argument list\", e.pos());\n\t\t\tString oldName = e.head().headSymbol().toString();\n\t\t\tString newName = e.head().headSymbol().accept(this);\n\t\t\tint length = e.args().size();\n\t\t\t// FIXME - should we be doing these comparisons with strings?\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\ttry {\n\t\t\t\t// Determine if the arguments are formulas or terms\n\t\t\t\tif (resultIsFormula) {\n\t\t\t\t\tif (newName != null \u0026\u0026 logicNames.contains(oldName)) {\n\t\t\t\t\t\t// Propositional boolean item\n\t\t\t\t\t\tthis.isFormula = true;\n\t\t\t\t\t\tif (oldName.equals(\"or\")) newName = \"OR\";\n\t\t\t\t\t\tif (oldName.equals(\"and\")) newName = \"AND\";\n\t\t\t\t\t\tif (oldName.equals(\"not\")) newName = \"NOT\";\n\t\t\t\t\t\tif (oldName.equals(\"=\u003e\")) newName = \"=\u003e\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tIExpr arg = e.args().get(e.args().size() \u003c= 1 ? 0 : 1); // Use argument 1 for ite's sake\n\t\t\t\t\t\tISort sort = typemap.get(arg);\n\t\t\t\t\t\tif (sort == null) {\n\t\t\t\t\t\t\tthrow new VisitorException(\"INTERNAL ERROR: Encountered an un-sorted expression node: \" + smtConfig.defaultPrinter.toString(arg),arg.pos());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sort.isBool()) {\n\t\t\t\t\t\t\t// Some functions can take both bool and non-bool arguments:\n\t\t\t\t\t\t\t//   = /= DISTINCT ite\n\t\t\t\t\t\t\tthis.isFormula = resultIsFormula;\n\t\t\t\t\t\t\tif (\"=\".equals(newName)) newName = \"\u003c=\u003e\";\n\t\t\t\t\t\t\telse if (\"DISTINCT\".equals(newName)) {\n\t\t\t\t\t\t\t\tif (e.args().size() \u003e 2) {\n\t\t\t\t\t\t\t\t\treturn \"FALSE\";\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tString a1 = iter.next().accept(this);\n\t\t\t\t\t\t\t\t\tString a2 = iter.next().accept(this);\n\t\t\t\t\t\t\t\t\treturn \"((\" + a1 + \")XOR(\" + a2 + \"))\"; \n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} // FIXME - what about ite?\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Arguments must be terms\n\t\t\t\t\t\t\tthis.isFormula = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.isFormula = false;\n\t\t\t\t} // FIXME - implies, equality, non-equality, \n\n\t\t\t\tif (infix.contains(newName) \u0026\u0026 length \u003e= 2) {\n\t\t\t\t\t// infix\n\t\t\t\t\tsb.append(\"(\");\n\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t\tsb.append(newName);\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(\")\");\n\t\t\t\t} else if (newName.equals(\"=\u003e\")) {\n\t\t\t\t\tsb.append(rightassoc(newName,iter));\n\t\t\t\t} else if (oldName.equals(\"=\")) {\n\t\t\t\t\tboolean argsAreBool = typemap.get(e.args().get(0)).isBool();\n\t\t\t\t\tboolean needsAnd = length \u003e 2;\n\t\t\t\t\tif (needsAnd) sb.append(\"(\");\n\t\t\t\t\tString right = iter.next().accept(this);\n\t\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\t\tString left = right;\n\t\t\t\t\t\tright = iter.next().accept(this);\n\t\t\t\t\t\tif (resultIsFormula) {\n\t\t\t\t\t\t\tsb.append(\"((\");\n\t\t\t\t\t\t\tsb.append(left);\n\t\t\t\t\t\t\tsb.append(\")\");\n\t\t\t\t\t\t\tsb.append(newName);\n\t\t\t\t\t\t\tsb.append(\"(\");\n\t\t\t\t\t\t\tsb.append(right);\n\t\t\t\t\t\t\tsb.append(\"))\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new VisitorException(\"CVC does not permit = in terms\",e.pos());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (needsAnd) {\n\t\t\t\t\t\t\tif (!iter.hasNext()) sb.append(\")\");\n\t\t\t\t\t\t\telse sb.append(\" AND \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (newName.equals(\"~\") || newName.equals(\"NOT\")) {\n\t\t\t\t\tsb.append(\"(\");\n\t\t\t\t\tsb.append(newName);\n\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\tsb.append(\" )\");\n\t\t\t\t} else if (newName.equals(\"DISTINCT\")) {\n\t\t\t\t\tif (isFormula) {\n\t\t\t\t\t\tif (length == 2) {\n\t\t\t\t\t\t\tsb.append(\"( \");\n\t\t\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\t\t\tsb.append(\" XOR \");\n\t\t\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\t\t\tsb.append(\" )\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsb.append(\"( \");\n\t\t\t\t\t\t\tboolean first = true;\n\t\t\t\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\t\t\t\tIExpr left = iter.next();\n\t\t\t\t\t\t\t\tIterator\u003cIExpr\u003e iter2 = e.args().iterator();\n\t\t\t\t\t\t\t\tIExpr right;\n\t\t\t\t\t\t\t\twhile ((right = iter2.next()) != left) {\n\t\t\t\t\t\t\t\t\tif (first) first = false; else sb.append(\" AND \");\n\t\t\t\t\t\t\t\t\tsb.append(\"( \");\n\t\t\t\t\t\t\t\t\tsb.append(left.accept(this));\n\t\t\t\t\t\t\t\t\tsb.append(\" XOR \");\n\t\t\t\t\t\t\t\t\tsb.append(right.accept(this));\n\t\t\t\t\t\t\t\t\tsb.append(\" )\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsb.append(\" )\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsb.append(\"DISTINCT(\");\n\t\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\t\t\tsb.append(\",\");\n\t\t\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsb.append(\")\");\n\t\t\t\t\t}\n\t\t\t\t} else if (symTable.arrayTheorySet \u0026\u0026 oldName.equals(\"select\")) {\n\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\tsb.append(\"[\");\n\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\tsb.append(\"]\");\n\t\t\t\t} else if (symTable.arrayTheorySet \u0026\u0026 oldName.equals(\"store\")) {\n\t\t\t\t\tsb.append(\"(\");\n\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\tsb.append(\" WITH [\");\n\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\tsb.append(\"] := \");\n\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\tsb.append(\")\");\n\t\t\t\t} else if (oldName.equals(\"ite\")) {\n\t\t\t\t\tif (!resultIsFormula) {\n\t\t\t\t\t\tthrow new VisitorException(\"CVC only allows ite constructs at the formula level\",e.pos());\n\t\t\t\t\t}\n\t\t\t\t\t// FIXME - formula only\n\t\t\t\t\tsb.append(\"(IF \");\n\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\tsb.append(\" THEN \");\n\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\tsb.append(\" ELSE \");\n\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\tsb.append(\" ENDIF)\");\n\t\t\t\t} else if (oldName.equals(\"\u003e\") || oldName.equals(\"\u003c\") || oldName.equals(\"\u003e=\") || oldName.equals(\"\u003c=\")) {\n\t\t\t\t\tsb.append(remove_chainable(newName,length,iter));\n\t\t\t\t} else if (length == 1 \u0026\u0026 newName.equals(\"-\")) {\n\t\t\t\t\tsb.append(\"(\");\n\t\t\t\t\tsb.append(oldName);\n\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\tsb.append(\")\");\n\t\t\t\t} else if (symTable.bitVectorTheorySet \u0026\u0026 oldName.equals(\"extract\")) {\n\t\t\t\t\tIParameterizedIdentifier pid = (IParameterizedIdentifier)e.head();\n\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\tsb.append(\"[\");\n\t\t\t\t\tsb.append(org.smtlib.sexpr.Printer.write(pid.numerals().get(0)));\n\t\t\t\t\tsb.append(\":\");\n\t\t\t\t\tsb.append(org.smtlib.sexpr.Printer.write(pid.numerals().get(1)));\n\t\t\t\t\tsb.append(\"]\");\n\t\t\t\t} else if (symTable.bitVectorTheorySet \u0026\u0026 (oldName.equals(\"bvudiv\") || oldName.equals(\"bvurem\") || oldName.equals(\"bvshl\") || oldName.equals(\"bvlshr\")\n\t\t\t\t\t\t|| oldName.equals(\"bvsge\") || oldName.equals(\"bvsgt\") || oldName.equals(\"bvsle\") || oldName.equals(\"bvslt\") \n\t\t\t\t\t\t|| oldName.equals(\"bvashr\") \n\t\t\t\t\t\t|| oldName.equals(\"bvsmod\") || oldName.equals(\"bvsrem\") || oldName.equals(\"bvsdiv\") \n\t\t\t\t\t\t|| oldName.equals(\"bvcomp\") \n\t\t\t\t\t\t)) {\n\t\t\t\t\tthrow new VisitorException(\"SMT BitVector function \" + oldName + \" is not implemented in cvc\",e.pos());\n\t\t\t\t} else if (symTable.bitVectorTheorySet \u0026\u0026 (\"@\".equals(newName) || (oldName.startsWith(\"bv\") \u0026\u0026 newName != null \u0026\u0026 newName.charAt(0) != 'B'))) {\n\t\t\t\t\t// infix\n\t\t\t\t\tsb.append(\"((\");\n\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\tsb.append(\")\");\n\t\t\t\t\tsb.append(newName);\n\t\t\t\t\tsb.append(\"(\");\n\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\tsb.append(\"))\");\n\t\t\t\t} else if (symTable.bitVectorTheorySet \u0026\u0026 (newName.equals(\"BVPLUS\") || newName.equals(\"BVSUB\") || newName.equals(\"BVMULT\"))) {\n\t\t\t\t\tISort sort = typemap.get(e);\n\t\t\t\t\tint k = 1;\n\t\t\t\t\tif (sort instanceof IApplication) {\n\t\t\t\t\t\tIIdentifier id = ((IApplication)sort).family();\n\t\t\t\t\t\tif (id instanceof IParameterizedIdentifier) {\n\t\t\t\t\t\t\tk = ((IParameterizedIdentifier)id).numerals().get(0).intValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(newName);\n\t\t\t\t\tsb.append(\"(\");\n\t\t\t\t\tsb.append(k);\n\t\t\t\t\tsb.append(\",\");\n\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\tsb.append(\",\");\n\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\tsb.append(\")\");\n\t\t\t\t} else if (symTable.bitVectorTheorySet \u0026\u0026 newName.equals(\"sign_extend\")) {\n\t\t\t\t\tISort sort = typemap.get(e);\n\t\t\t\t\tint k = 1;\n\t\t\t\t\tif (sort instanceof IApplication) {\n\t\t\t\t\t\tIIdentifier id = ((IApplication)sort).family();\n\t\t\t\t\t\tif (id instanceof IParameterizedIdentifier) {\n\t\t\t\t\t\t\tk = ((IParameterizedIdentifier)id).numerals().get(0).intValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//\t\t\t\t\tList\u003cINumeral\u003e numerals = ((IParameterizedIdentifier)e.head()).numerals();\n//\t\t\t\t\tint arg = numerals.get(0).intValue();\n\t\t\t\t\tsb.append(\"SX\");\n\t\t\t\t\tsb.append(\"(\");\n\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\tsb.append(\",\");\n\t\t\t\t\tsb.append(k);\n\t\t\t\t\tsb.append(\")\");\n\t\t\t\t} else if (symTable.bitVectorTheorySet \u0026\u0026 newName.equals(\"rotate_left\")) {\n\t\t\t\t\tISort sort = typemap.get(e);\n\t\t\t\t\tint k = 1;\n\t\t\t\t\tif (sort instanceof IApplication) {\n\t\t\t\t\t\tIIdentifier id = ((IApplication)sort).family();\n\t\t\t\t\t\tif (id instanceof IParameterizedIdentifier) {\n\t\t\t\t\t\t\tk = ((IParameterizedIdentifier)id).numerals().get(0).intValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tList\u003cINumeral\u003e numerals = ((IParameterizedIdentifier)e.head()).numerals();\n\t\t\t\t\tint arg = numerals.get(0).intValue();\n\t\t\t\t\tString expr = (iter.next().accept(this));\n\n\t\t\t\t\tsb.append(\"(\");\n\t\t\t\t\tsb.append(expr);\n\t\t\t\t\tsb.append(\"[\");\n\t\t\t\t\tsb.append(k-1);\n\t\t\t\t\tsb.append(\":\");\n\t\t\t\t\tsb.append(k-arg);\n\t\t\t\t\tsb.append(\"]@\");\n\t\t\t\t\tsb.append(expr);\n\t\t\t\t\tsb.append(\"[\");\n\t\t\t\t\tsb.append(k-arg-1);\n\t\t\t\t\tsb.append(\":0])\");\n\t\t\t\t} else if (symTable.bitVectorTheorySet \u0026\u0026 newName.equals(\"rotate_right\")) {\n\t\t\t\t\tISort sort = typemap.get(e);\n\t\t\t\t\tint k = 1;\n\t\t\t\t\tif (sort instanceof IApplication) {\n\t\t\t\t\t\tIIdentifier id = ((IApplication)sort).family();\n\t\t\t\t\t\tif (id instanceof IParameterizedIdentifier) {\n\t\t\t\t\t\t\tk = ((IParameterizedIdentifier)id).numerals().get(0).intValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tList\u003cINumeral\u003e numerals = ((IParameterizedIdentifier)e.head()).numerals();\n\t\t\t\t\tint arg = numerals.get(0).intValue();\n\t\t\t\t\tString expr = (iter.next().accept(this));\n\n\t\t\t\t\tsb.append(\"(\");\n\t\t\t\t\tsb.append(expr);\n\t\t\t\t\tsb.append(\"[\");\n\t\t\t\t\tsb.append(k-1);\n\t\t\t\t\tsb.append(\":\");\n\t\t\t\t\tsb.append(arg);\n\t\t\t\t\tsb.append(\"]@\");\n\t\t\t\t\tsb.append(expr);\n\t\t\t\t\tsb.append(\"[\");\n\t\t\t\t\tsb.append(arg-1);\n\t\t\t\t\tsb.append(\":0])\");\n\t\t\t\t} else if (symTable.bitVectorTheorySet \u0026\u0026 newName.equals(\"zero_extend\")) {\n\t\t\t\t\tISort sort = typemap.get(e);\n\t\t\t\t\tint k = 1;\n\t\t\t\t\tif (sort instanceof IApplication) {\n\t\t\t\t\t\tIIdentifier id = ((IApplication)sort).family();\n\t\t\t\t\t\tif (id instanceof IParameterizedIdentifier) {\n\t\t\t\t\t\t\tk = ((IParameterizedIdentifier)id).numerals().get(0).intValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tList\u003cINumeral\u003e numerals = ((IParameterizedIdentifier)e.head()).numerals();\n\t\t\t\t\tint arg = numerals.get(0).intValue();\n\t\t\t\t\tString expr = (iter.next().accept(this));\n\t\t\t\t\t\n\t\t\t\t\tString addedzeros = \"\";\n\t\t\t\t\twhile (addedzeros.length() \u003c arg) {\n\t\t\t\t\t\taddedzeros = addedzeros + zeros.substring(zeros.length() - (arg-addedzeros.length()) );\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(\"(0bin\");\n\t\t\t\t\tsb.append(addedzeros);\n\t\t\t\t\tsb.append(\"@\");\n\t\t\t\t\tsb.append(expr);\n\t\t\t\t\tsb.append(\")\");\n\t\t\t\t} else if (symTable.bitVectorTheorySet \u0026\u0026 newName.equals(\"repeat\")) {\n\t\t\t\t\tList\u003cINumeral\u003e numerals = ((IParameterizedIdentifier)e.head()).numerals();\n\t\t\t\t\tint arg = numerals.get(0).intValue();\n\t\t\t\t\tString expr = (iter.next().accept(this));\n\t\t\t\t\tsb.append(\"((\");\n\t\t\t\t\tsb.append(expr);\n\t\t\t\t\tfor (int i=1; i\u003carg; i++) {\n\t\t\t\t\t\tsb.append(\")@(\");\n\t\t\t\t\t\tsb.append(expr);\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(\"))\");\n\t\t\t\t} else if (e.head() instanceof ParameterizedIdentifier) {\n\t\t\t\t\tthrow new VisitorException(\"Unknown parameterized function symbol: \" + oldName, e.pos());\n\t\t\t\t} else {\n\t\t\t\t\t// usual functional notation\n\t\t\t\t\tsb.append(newName == null ? oldName : newName);\n\t\t\t\t\tif (!iter.hasNext()) {\n\t\t\t\t\t\tsb.append(\"()\"); // FIXME - should this have no parens at all?\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsb.append(\"(\");\n\t\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\t\t\tsb.append(\",\");\n\t\t\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsb.append(\")\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tisFormula = resultIsFormula;\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(ISymbol e) throws IVisitor.VisitorException {\n\t\t\t// FIXME - need to check what characters are allowed in a CVC name\n\t\t\tString oldName = e.value();\n\t\t\tif (!isFormula) {\n\t\t\t\tif (\"true\".equals(oldName)) return \"$_TRUE\";\n\t\t\t\tif (\"false\".equals(oldName)) return \"$_FALSE\";\n\t\t\t}\n\t\t\tString newName = fcnNames.get(oldName);\n\t\t\tif (newName != null) {\n\t\t\t\t// There is a direct translation of a pre-defined SMT-LIB name\n\t\t\t\t// into a simplify equivalent - use it.\n\t\t\t} else {\n\t\t\t\t// Use the ? character as an escape\n\t\t\t\tnewName = oldName;\n\t\t\t}\n\t\t\treturn newName;\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IKeyword e) throws IVisitor.VisitorException {\n\t\t\tthrow new VisitorException(\"Did not expect a Keyword in an expression to be translated\",pos(e));\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IError e) throws IVisitor.VisitorException {\n\t\t\tthrow new VisitorException(\"Did not expect a Error token in an expression to be translated\",pos(e));\n\t\t}\n\t\t\n\t\tprivate final static String zeros = \"00000000000000000000000000000000000000000000000000\";\n\n\t\t@Override\n\t\tpublic String visit(IParameterizedIdentifier e) throws IVisitor.VisitorException {\n\t\t\tString s = e.headSymbol().toString();\n\t\t\tif (s.matches(\"bv[0-9]+\")) {\n\t\t\t\tint length = e.numerals().get(0).intValue();\n\t\t\t\tBigInteger value = new BigInteger(s.substring(2));\n\t\t\t\tString bits = value.toString(2);\n\t\t\t\twhile (bits.length() \u003c length) {\n\t\t\t\t\tint n = zeros.length() - (length - bits.length());\n\t\t\t\t\tif (n \u003c 0) n = 0;\n\t\t\t\t\tbits = zeros.substring(n) + bits;\n\t\t\t\t}\n\t\t\t\treturn \"0bin\" + bits;\n\t\t\t}\n\t\t\t// FIXME - use default printer properly to print Symbol\n\t\t\tthrow new IVisitor.VisitorException(\"Unsupported parameterized function symbol: \" + e.headSymbol().toString(),e.pos());\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IForall e) throws IVisitor.VisitorException {\n\t\t\t// FIXME - I think CVC only allows this in formulas\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(\"(FORALL (\");\n\t\t\tboolean first = true;\n\t\t\tfor (IDeclaration d: e.parameters()) {\n\t\t\t\tif (first) first = false; else sb.append(\", \");\n\t\t\t\tsb.append(d.parameter().accept(this));\n\t\t\t\tsb.append(\":\");\n\t\t\t\tsb.append(d.sort().accept(this));\n\t\t\t}\n\t\t\tsb.append(\"): \");\n\t\t\tsb.append(e.expr().accept(this));\n\t\t\tsb.append(\")\");\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IExists e) throws IVisitor.VisitorException {\n\t\t\t// FIXME - I think CVC only allows this in formulas\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(\"(EXISTS (\");\n\t\t\tboolean first = true;\n\t\t\tfor (IDeclaration d: e.parameters()) {\n\t\t\t\tif (first) first = false; else sb.append(\", \");\n\t\t\t\tsb.append(d.parameter().accept(this));\n\t\t\t\tsb.append(\":\");\n\t\t\t\tsb.append(d.sort().accept(this));\n\t\t\t}\n\t\t\tsb.append(\"): \");\n\t\t\tsb.append(e.expr().accept(this));\n\t\t\tsb.append(\")\");\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(ILet e) throws IVisitor.VisitorException {\n\t\t\t// FIXME - only in formulas?\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(\"(LET \");\n\t\t\tboolean first = true;\n\t\t\tfor (IBinding d: e.bindings()) {\n\t\t\t\tif (first) first = false; else sb.append(\", \");\n\t\t\t\tsb.append(d.parameter().accept(this));\n\t\t\t\tsb.append(\" = \");\n\t\t\t\tsb.append(d.expr().accept(this));\n\t\t\t}\n\t\t\tsb.append(\" IN \");\n\t\t\tsb.append(e.expr().accept(this));\n\t\t\tsb.append(\")\");\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic String visit(ISort.IFamily s) throws IVisitor.VisitorException {\n\t\t\treturn s.identifier().accept(this);\n\t\t}\n\t\t\n\t\tpublic String visit(ISort.IAbbreviation s) throws IVisitor.VisitorException {\n\t\t\tthrow new UnsupportedOperationException(\"CVC visit-ISort.IAbbreviation\");\n\t\t}\n\t\t\n\t\tpublic String visit(ISort.IApplication s) throws IVisitor.VisitorException {\n\t\t\tif (s.isBool()) return \"BOOLEAN\";\n\t\t\tif (s.parameters().size() == 0) {\n\t\t\t\tString sort = encodeSort(s.family());\n\t\t\t\tif (\"Int\".equals(sort)) return \"INT\";\n\t\t\t\tif (\"Real\".equals(sort)) return \"REAL\";\n\t\t\t\treturn sort; // FIXME - Array, BitVector\n\t\t\t} else if (s.parameters().size() == 2) {\n\t\t\t\tString sort = encodeSort(s.family());\n\t\t\t\tif (\"ARRAY\".equals(sort)) {\n\t\t\t\t\tList\u003cISort\u003e args = s.parameters();\n\t\t\t\t\treturn \"(ARRAY \" + args.get(0).accept(this) + \" OF \" + args.get(1).accept(this) +\")\";\n\t\t\t\t} else {\n\t\t\t\t\treturn \"UNKNOWN\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\treturn \"UNKNOWN\"; // FIXME\n\t\t\t\t//throw new UnsupportedOperationException(\"CVC visit-ISort.IExpression\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic String visit(ISort.IFcnSort s) {\n\t\t\tthrow new UnsupportedOperationException(\"CVC visit-ISort.IFcnSort\");\n\t\t}\n\t\tpublic String visit(ISort.IParameter s) {\n\t\t\tthrow new UnsupportedOperationException(\"CVC visit-ISort.IParameter\");\n\t\t}\n\t}\n}\n",
        "name": "Solver_cvc.java",
        "path": "SMT/src/org/smtlib/solvers/Solver_cvc.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMT/src/org/smtlib/solvers/Solver_cvc.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 726,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();"
        },
        {
          "limitHit": false,
          "lineNumber": 744,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();"
        },
        {
          "limitHit": false,
          "lineNumber": 745,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires length \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 762,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();"
        },
        {
          "limitHit": false,
          "lineNumber": 763,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires length \u003e 0;"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\n * This file is part of the SMT project.\n * Copyright 2010 David R. Cok\n * Created August 2010\n */\npackage org.smtlib;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.Reader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\n\n/** This class implements a CharSequence that obtains its characters from a ServerSocket.  The characters \n * read are held in an internal char array, whose size grows as needed; it starts as initialSize and\n * is expanded to currentSize*sizeMultiple + sizeIncrease whenever needed.\n * \u003cP\u003e\n * The CharSequenceReader is an unconventional CharSequence in that its length() is not known; \n * whether this will cause problems\n * in some uses of the CharSequenceReader is unknown.  The user should not use the value of length()\n * directly; it seems to work in the ways it is called from Pattern.matcher.\n * @author David R. Cok\n *\n */\npublic class CharSequenceSocket extends CharSequenceInfinite {\n\n\t/** The socket from which characters are read */\n\tprotected ServerSocket serverSocket;\n\n\t/** The configuration for this instance of SMT */\n\tprotected SMT.Configuration smtConfig;\n\t\n\t/** Constructor for a new instance\n\t * \n\t * @param serverSocket the ServerSocket that supplies characters on demand\n\t * @param initialSize the beginning size of the internal char array\n\t * @param sizeIncrease the amount to add to the current size of the internal char array when the array needs expanding\n\t * @param sizeMultiple the factor by which to multiply the current size of the internal char array when it needs expanding\n\t */\n\t//@ requires initialSize \u003e 0 \u0026\u0026 sizeIncrease \u003e= 0 \u0026\u0026 sizeMultiple \u003e= 1;\n\t//@ requires !(sizeIncrease == 0 \u0026\u0026 sizeMultiple == 1)\n\tpublic CharSequenceSocket(SMT.Configuration smtConfig, ServerSocket serverSocket, int initialSize, int sizeIncrease, double sizeMultiple) {\n\t\tsuper(initialSize, sizeIncrease, sizeMultiple);\n\t\tthis.serverSocket = serverSocket;\n\t\tthis.smtConfig = smtConfig;\n\t}\n\n\t/** Internal state - if true then we need to create a new connection before reading characters */\n\tprivate boolean needsNewConnection = true;\n\t\n\t/** Internal state - the client socket on which we are reading */\n\tprivate /*@Nullable*/ Socket clientSocket = null;\n\t\n\t/** Internal state - the current Reader for fetching characters */\n\tprivate /*@Nullable*/ Reader rdr = null;\n\t\n\t//@ requires !needsNewConnection =\u003e rdr != null;\n\t@Override\n\tprotected boolean readChars() throws java.io.IOException {\n\t\twhile (true) {\n\t\t\tif (needsNewConnection) {\n\t\t\t\tif (rdr != null) rdr.close();\n\t\t\t\tif (clientSocket != null) clientSocket.close();\n\n\t\t\t\t// Wait for a client to initiate a call\n\t\t\t\tclientSocket = serverSocket.accept();\n\n\t\t\t\t// Create the input and output streams\n\t\t\t\t// FIXME - use a listener?\n\t\t\t\t// FIXME - are there any other exceptions?  what if the connection is unexpectedly broken\n\t\t\t\tsmtConfig.log.out = new PrintStream(clientSocket.getOutputStream(),true);\n\t\t\t\trdr = new BufferedReader(\n\t\t\t\t\t\tnew InputStreamReader(\n\t\t\t\t\t\t\t\tclientSocket.getInputStream()));\n\t\t\t\tneedsNewConnection = false;\n\t\t\t}\n\t\t\t/*@SuppressWarnings(\"nullness\")*/\n\t\t\t/*@NonNull*/ Reader nnrdr = rdr;\n\t\t\tint nread = 0;\n\t\t\tdo {\n\t\t\t\tnread = nnrdr.read(buf,amountRead,buf.length-amountRead);\n\t\t\t\tif (nread == -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"SOCKET READ \" + nread + \":\" + new String(buf,amountRead,nread));\n\t\t\t\tamountRead += nread;\n\t\t\t} while (amountRead \u003c buf.length \u0026\u0026 nnrdr.ready());\n\n\t\t\tif (nread == -1) {\n\t\t\t\tneedsNewConnection = true;\n\t\t\t\t// end of file so no characters read - go read some more\n\t\t\t} else if (buf[amountRead-1] == 0) {\n\t\t\t\tamountRead--;\n\t\t\t\tneedsNewConnection = true;\n\t\t\t\tif (nread \u003e 1) return true;\n\t\t\t\t// read only the 0 so no characters read - go read some more\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
        "name": "CharSequenceSocket.java",
        "path": "SMT/src/org/smtlib/CharSequenceSocket.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMT/src/org/smtlib/CharSequenceSocket.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 41,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires initialSize \u003e 0 \u0026\u0026 sizeIncrease \u003e= 0 \u0026\u0026 sizeMultiple \u003e= 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 42,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires !(sizeIncrease == 0 \u0026\u0026 sizeMultiple == 1)"
        },
        {
          "limitHit": false,
          "lineNumber": 58,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires !needsNewConnection =\u003e rdr != null;"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\n * This file is part of the SMT project.\n * Copyright 2010 David R. Cok\n * Created August 2010\n */\npackage org.smtlib;\n\nimport java.io.Reader;\n\n/** This class implements a CharSequence that obtains its characters from a Reader.  The characters \n * read are held in an internal char array, whose size grows as needed; it starts as initialSize and\n * is expanded to currentSize*sizeMultiple + sizeIncrease whenever needed.\n * \n * The CharSequenceReader is an unconventional CharSequence in that its length() is not known; \n * whether this will cause problems\n * in some uses of the CharSequenceReader is unknown.  The user should not use the value of length()\n * directly; it seems to work in the ways it is called from Pattern.matcher.\n * @author David R. Cok\n *\n */\npublic class CharSequenceReader extends CharSequenceInfinite implements CharSequence {\n\n\t/** Constructor for a new instance\n\t * \n\t * @param rdr the Reader that supplies characters on demand\n\t * @param initialSize the beginning size of the internal char array\n\t * @param sizeIncrease the amount to add to the current size of the internal char array when the array needs expanding\n\t * @param sizeMultiple the factor by which to multiply the current size of the internal char array when it needs expanding\n\t */\n\t//@ requires initialSize \u003e 0 \u0026\u0026 sizeIncrease \u003e= 0 \u0026\u0026 sizeMultiple \u003e= 1;\n\t//@ requires !(sizeIncrease == 0 \u0026\u0026 sizeMultiple == 1)\n\tpublic CharSequenceReader(/*@NonNull*/Reader rdr, int initialSize, int sizeIncrease, double sizeMultiple) {\n\t\tsuper(initialSize, sizeIncrease, sizeMultiple);\n\t\tthis.rdr = rdr;\n\t}\n\t\n\t/** Constructor for a new instance\n\t * \n\t * @param rdr the Reader that supplies characters on demand\n\t */\n\tpublic CharSequenceReader(/*@NonNull*/Reader rdr) {\n\t\tthis(rdr, 100000, 100, 2);\n\t}\n\t\n\t/** The Reader that supplies characters for the CharSequence */\n\tprotected /*@NonNull*/ Reader rdr;\n\t\n\t@Override\n\tprotected boolean readChars() throws java.io.IOException {\n\t\tint nread;\n\t\t// It appears that rdr.ready() can be false when a file has been completely\n\t\t// read and the next read will return -1 - there does not appear to be a way\n\t\t// to determine that the reader is at the end of file without issuing the\n\t\t// final read (which might block if we are interactive)\n\t\tif (!rdr.ready() \u0026\u0026 prompter != null) {\n\t\t\tprompter.prompt();\n\t\t}\n\t\tdo {\n\t\t\tnread = rdr.read(buf,amountRead,buf.length-amountRead);\n\t\t\tif (nread == -1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tamountRead += nread;\n\t\t} while (amountRead \u003c buf.length \u0026\u0026 rdr.ready());\n\t\treturn true;\n\t}\n}\n",
        "name": "CharSequenceReader.java",
        "path": "SMT/src/org/smtlib/CharSequenceReader.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMT/src/org/smtlib/CharSequenceReader.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 29,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires initialSize \u003e 0 \u0026\u0026 sizeIncrease \u003e= 0 \u0026\u0026 sizeMultiple \u003e= 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 30,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires !(sizeIncrease == 0 \u0026\u0026 sizeMultiple == 1)"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\n * This file is part of the SMT project.\n * Copyright 2010 David R. Cok\n * Created August 2010\n */\npackage org.smtlib.solvers;\n\nimport java.io.FileOutputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.smtlib.*;\nimport org.smtlib.ICommand.Ideclare_fun;\nimport org.smtlib.ICommand.Ideclare_sort;\nimport org.smtlib.ICommand.Idefine_fun;\nimport org.smtlib.ICommand.Idefine_sort;\nimport org.smtlib.IExpr.IAsIdentifier;\nimport org.smtlib.IExpr.IAttribute;\nimport org.smtlib.IExpr.IAttributedExpr;\nimport org.smtlib.IExpr.IBinaryLiteral;\nimport org.smtlib.IExpr.IBinding;\nimport org.smtlib.IExpr.IDecimal;\nimport org.smtlib.IExpr.IDeclaration;\nimport org.smtlib.IExpr.IError;\nimport org.smtlib.IExpr.IExists;\nimport org.smtlib.IExpr.IFcnExpr;\nimport org.smtlib.IExpr.IForall;\nimport org.smtlib.IExpr.IHexLiteral;\nimport org.smtlib.IExpr.IKeyword;\nimport org.smtlib.IExpr.ILet;\nimport org.smtlib.IExpr.INumeral;\nimport org.smtlib.IExpr.IParameterizedIdentifier;\nimport org.smtlib.IExpr.IQualifiedIdentifier;\nimport org.smtlib.IExpr.IStringLiteral;\nimport org.smtlib.IExpr.ISymbol;\nimport org.smtlib.IVisitor.VisitorException;\nimport org.smtlib.impl.Response;\nimport org.smtlib.impl.SMTExpr.ParameterizedIdentifier;\n\n// FIXME - in some commands, like assert, push, pop, the effect in solver_test happens even if the effect in the \n// solver itself causes an error, putting the two out of synch; also, push and pop can happen partially\n/** This class is the adapter for the Yices SMT solver */\npublic class Solver_yices extends Solver_test implements ISolver {\n\t/** This holds the command-line arguments used to launch the solver;\n\t * the path to the executable is inserted in cmds[0]. */\n\tString cmds[] = new String[]{\"\",\"-i\"};\n\t\n\t/** Holds the driver for external processes */\n\tprivate SolverProcess solverProcess;\n\t\n\t/** The string that indicates an Error in the solver reply */\n\tstatic public final String errorIndication = \"Error\";\n\n\t/** Records the values of options */\n\tprotected Map\u003cString,IAttributeValue\u003e options = new HashMap\u003cString,IAttributeValue\u003e();\n\t{ \n\t\toptions.putAll(smtConfig.utils.defaults);\n\t}\n\t\n\t/** Creates but does not start a solver instance */\n\tpublic Solver_yices(SMT.Configuration smtConfig, String executable) {\n\t\tsuper(smtConfig,\"\");\n\t\tcmds[0] = executable;\n\t\tsolverProcess = new SolverProcess(cmds,\"yices \u003e \",smtConfig.logfile);\n\t}\n\t\n\t@Override\n\tpublic IResponse start() {\n\t\tsuper.start();\n\t\ttry {\n\t\t\tsolverProcess.start(true);\n\t\t\tsolverProcess.sendAndListen(\"(define mod :: (-\u003e int int int))\\n\");\n\t\t\tsolverProcess.sendAndListen(\"(define div :: (-\u003e int int int))\\n\");\n\t\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Started yices \" + (solverProcess!=null));\n\t\t\treturn smtConfig.responseFactory.success();\n\t\t} catch (Exception e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to start process \" + cmds[0] + \" : \" + e.getMessage());\n\t\t}\n\t}\n\t\n\tprotected /*@Nullable*/ IResponse send(IPos pos, String... solverCmds) {\n\t\ttry {\n\t\t\tfor (String s: solverCmds) solverProcess.sendNoListen(s);\n\t\t\tString response = solverProcess.sendAndListen(\"\\n\");\n\t\t\tif (response.contains(errorIndication)) {\n\t\t\t\treturn smtConfig.responseFactory.error(response,pos);\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(e.getMessage(),pos);\n\t\t}\n\t}\n\n\t// FIXME - are we capturing errors from the solver?\n\t\n\t@Override\n\tpublic IResponse exit() {\n\t\tIResponse r = send(null,\"(exit)\");\n\t\tif (r != null) return r;\n\t\tsolverProcess.exit();\n\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Ended yices \");\n\t\treturn smtConfig.responseFactory.success();\n\t}\n\t\n\t@Override public void comment(String comment) {\n\t\ttry {\n\t\t\tsolverProcess.sendNoListen(comment);\n\t\t} catch (IOException e) {\n\t\t\t// FIXME;\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse assertExpr(IExpr sexpr) {\n\t\ttry {\n\t\t\tIResponse status = super.assertExpr(sexpr);\n\t\t\tif (!status.isOK()) return status;\n\n\t\t\tIResponse response = send(sexpr.pos(),\"(assert+ \",translate(sexpr),\" )\");\n\t\t\tif (response != null) return response;\n\t\t\treturn status;\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Yices assert command failed: \" + e.getMessage());\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic IResponse check_sat() {\n\t\tIResponse res = super.check_sat();\n\t\tif (res.isError()) return res;\n\n\t\ttry {\n\t\t\tString s = solverProcess.sendAndListen(\"(check)\\r\\n\");\n\t\t\tif (s.contains(errorIndication)) {\n\t\t\t\treturn smtConfig.responseFactory.error(s);\n\t\t\t}\n\t\t\t//System.out.println(\"HEARD: \" + s);\n\t\t\tif (s.contains(\"unsat\")) res = smtConfig.responseFactory.unsat();\n\t\t\telse if (s.contains(\"sat\")) res = smtConfig.responseFactory.sat();\n\t\t\telse res = smtConfig.responseFactory.unknown();\n\t\t\tcheckSatStatus = res;\n\t\t} catch (IOException e) {\n\t\t\tres = smtConfig.responseFactory.error(\"Failed to check-sat\");\n\t\t}\n\t\treturn res;\n\t}\n\n\t@Override\n\tpublic IResponse pop(int number) {\n\t\tIResponse status = super.pop(number);\n\t\tif (status.isError()) return status;\n\t\twhile (number-- \u003e 0) {\n\t\t\tIResponse response = send(null,\"(pop)\");\n\t\t\tif (response != null) return response;\n\t\t}\n\t\treturn smtConfig.responseFactory.success();\n\t}\n\n\t@Override\n\tpublic IResponse push(int number) {\n\t\tIResponse status = super.push(number);\n\t\tif (status.isError()) return status;\n\t\twhile (number-- \u003e 0) {\n\t\t\tIResponse response = send(null,\"(push)\");\n\t\t\tif (response != null) return response;\n\t\t}\n\t\treturn smtConfig.responseFactory.success();\n\t}\n\n\t@Override\n\tpublic IResponse set_logic(String logicName, /*@Nullable*/ IPos pos) {\n\t\tboolean lSet = logicSet != null;\n\t\tIResponse status = super.set_logic(logicName,pos);\n\t\tif (!status.isOK()) return status;\n\n\t\t// FIXME - discrimninate among logics\n\n\t\tif (lSet) {\n\t\t\tif (!smtConfig.relax) return smtConfig.responseFactory.error(\"Logic is already set\");\n\t\t\tIResponse response = send(pos,\"(reset)\");\n\t\t\tif (response != null) return response;\n\t\t}\n\t\treturn status;\n\t}\n\n\t@Override\n\tpublic IResponse set_option(IKeyword key, IAttributeValue value) {\n\t\tString option = key.value();\n\t\tif (Utils.PRINT_SUCCESS.equals(option)) {\n\t\t\tif (!(Utils.TRUE.equals(value) || Utils.FALSE.equals(value))) {\n\t\t\t\treturn smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be 'true' or 'false'\");\n\t\t\t}\n\t\t\t((Response.Factory)smtConfig.responseFactory).printSuccess = !Utils.FALSE.equals(value);\n\t\t}\n\t\tif (logicSet != null \u0026\u0026 (Utils.INTERACTIVE_MODE.equals(option)|| Utils.PRODUCE_ASSERTIONS.equals(option))) {\n\t\t\treturn smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be set before the set-logic command\");\n\t\t}\n\t\tif (Utils.PRODUCE_ASSIGNMENTS.equals(option) || \n\t\t\t\tUtils.PRODUCE_MODELS.equals(option) || \n\t\t\t\tUtils.PRODUCE_PROOFS.equals(option) ||\n\t\t\t\tUtils.PRODUCE_UNSAT_CORES.equals(option)) {\n\t\t\tif (logicSet != null) return smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be set before the set-logic command\");\n\t\t\treturn smtConfig.responseFactory.unsupported();\n\t\t}\n\t\tif (Utils.VERBOSITY.equals(option)) {\n\t\t\tIAttributeValue v = options.get(option);\n\t\t\tsmtConfig.verbose = (v instanceof INumeral) ? ((INumeral)v).intValue() : 0;\n\t\t} else if (Utils.DIAGNOSTIC_OUTPUT_CHANNEL.equals(option)) {\n\t\t\t// Actually, v should never be anything but IStringLiteral - that should\n\t\t\t// be checked during parsing\n\t\t\tString name = (value instanceof IStringLiteral)? ((IStringLiteral)value).value() : \"stderr\";\n\t\t\tif (name.equals(\"stdout\")) {\n\t\t\t\tsmtConfig.log.diag = System.out;\n\t\t\t} else if (name.equals(\"stderr\")) {\n\t\t\t\tsmtConfig.log.diag = System.err;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tFileOutputStream f = new FileOutputStream(name,true); // append\n\t\t\t\t\tsmtConfig.log.diag = new PrintStream(f);\n\t\t\t\t} catch (java.io.IOException e) {\n\t\t\t\t\treturn smtConfig.responseFactory.error(\"Failed to open or write to the diagnostic output \" + e.getMessage(),value.pos());\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Utils.REGULAR_OUTPUT_CHANNEL.equals(option)) {\n\t\t\t// Actually, v should never be anything but IStringLiteral - that should\n\t\t\t// be checked during parsing\n\t\t\tString name = (value instanceof IStringLiteral)?((IStringLiteral)value).value() : \"stdout\";\n\t\t\tif (name.equals(\"stdout\")) {\n\t\t\t\tsmtConfig.log.out = System.out;\n\t\t\t} else if (name.equals(\"stderr\")) {\n\t\t\t\tsmtConfig.log.out = System.err;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tFileOutputStream f = new FileOutputStream(name,true); // append\n\t\t\t\t\tsmtConfig.log.out = new PrintStream(f);\n\t\t\t\t} catch (java.io.IOException e) {\n\t\t\t\t\treturn smtConfig.responseFactory.error(\"Failed to open or write to the regular output \" + e.getMessage(),value.pos());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\toptions.put(option,value);\n\t\treturn smtConfig.responseFactory.success();\n\t}\n\n\t@Override\n\tpublic IResponse get_option(IKeyword key) {\n\t\tString option = key.value();\n\t\tIAttributeValue value = options.get(option);\n\t\tif (value == null) return smtConfig.responseFactory.unsupported();\n\t\treturn value;\n\t}\n\n\t@Override\n\tpublic IResponse get_info(IKeyword key) {\n\t\tString option = key.value();\n\t\tIAttributeValue lit;\n\t\tif (\":error-behavior\".equals(option)) {\n\t\t\tlit = smtConfig.exprFactory.symbol(Utils.CONTINUED_EXECUTION); // FIXME\n\t\t} else if (\":status\".equals(option)) {\n\t\t\treturn checkSatStatus==null ? smtConfig.responseFactory.unsupported() : checkSatStatus; \n\t\t} else if (\":all-statistics\".equals(option)) {\n\t\t\treturn smtConfig.responseFactory.unsupported(); // FIXME\n\t\t} else if (\":reason-unknown\".equals(option)) {\n\t\t\treturn smtConfig.responseFactory.unsupported(); // FIXME\n\t\t} else if (\":authors\".equals(option)) {\n\t\t\tlit = smtConfig.exprFactory.unquotedString(\"SRI\");\n\t\t} else if (\":version\".equals(option)) {\n\t\t\tlit = smtConfig.exprFactory.unquotedString(\"1.0.28\");\n\t\t} else if (\":name\".equals(option)) {\n\t\t\tlit = smtConfig.exprFactory.unquotedString(\"yices\");\n\t\t} else {\n\t\t\treturn smtConfig.responseFactory.unsupported();\n\t\t}\n\t\tIAttribute\u003c?\u003e attr = smtConfig.exprFactory.attribute(key,lit);\n\t\treturn smtConfig.responseFactory.get_info_response(attr);\n\t}\n\t\n\t@Override\n\tpublic IResponse declare_fun(Ideclare_fun cmd) {\n\t\ttry {\n\t\t\tIResponse status = super.declare_fun(cmd);\n\t\t\tif (!status.isOK()) return status;\n\n\t\t\tString name = translate(cmd.symbol());\n\t\t\tString yicescmd;\n\t\t\tif (cmd.argSorts().size() == 0) {\n\t\t\t\tyicescmd = \"(define \" + name + \"::\" + translate(cmd.resultSort()) + \")\";\n\t\t\t} else {\n\t\t\t\tyicescmd = \"(define \" + name + \"::(-\u003e\";\n\t\t\t\tfor (ISort s: cmd.argSorts()) {\n\t\t\t\t\tyicescmd = yicescmd + \" \" + translate(s);\n\t\t\t\t}\n\t\t\t\tyicescmd = yicescmd + \" \" + translate(cmd.resultSort()) + \"))\";\n\t\t\t\t\n\t\t\t}\n\t\t\tIResponse response = send(null,yicescmd);\n\t\t\tif (response != null) return response;\n\t\t\treturn status;\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"declare-fun command failed: \" + e.getMessage());\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse define_fun(Idefine_fun cmd) {\n\t\ttry {\n\t\t\tIResponse status = super.define_fun(cmd);\n\t\t\tif (!status.isOK()) return status;\n\t\t\t\n\t\t\tString name = translate(cmd.symbol());\n\t\t\tStringBuilder yicescmd = new StringBuilder();;\n\t\t\tif (cmd.parameters().size() == 0) {\n\t\t\t\tyicescmd.append(\"(define \" + name + \"::\" + translate(cmd.resultSort()) + \" \" \n\t\t\t\t\t\t\t\t+ translate(cmd.expression()));\n\t\t\t} else {\n\t\t\t\tyicescmd.append(\"(define \" + name + \"::(-\u003e\");\n\t\t\t\tfor (IDeclaration d: cmd.parameters()) {\n\t\t\t\t\tyicescmd.append(\" \" + translate(d.sort()));\n\t\t\t\t}\n\t\t\t\tyicescmd.append(\" \" + translate(cmd.resultSort()) + \") \");\n\t\t\t\tyicescmd.append(\"(lambda (\");\n\t\t\t\tfor (IDeclaration d: cmd.parameters()) {\n\t\t\t\t\tyicescmd.append(translate(d.parameter()));\n\t\t\t\t\tyicescmd.append(\"::\");\n\t\t\t\t\tyicescmd.append(translate(d.sort()));\n\t\t\t\t\tyicescmd.append(\" \");\n\t\t\t\t}\n\t\t\t\tyicescmd.append(\") \");\n\t\t\t\tyicescmd.append(translate(cmd.expression()));\n\t\t\t\tyicescmd.append(\")\");\n\t\t\t}\n\t\t\tyicescmd.append(\")\");\n\t\t\tIResponse response = send(null,yicescmd.toString());\n\t\t\tif (response != null) return response;\n\t\t\treturn status;\n\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"assert command failed: \" + e.getMessage());\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic IResponse declare_sort(Ideclare_sort cmd) {\n\t\ttry {\n\t\t\tIResponse status = super.declare_sort(cmd);\n\t\t\tif (!status.isOK()) return status;\n\t\t\t\n\t\t\tif (cmd.arity().intValue() == 0) {\n\t\t\t\tIResponse response = send(cmd.sortSymbol().pos(),\"(define-type \" + translate(cmd.sortSymbol()) + \")\");\n\t\t\t\tif (response != null) return response;\n\t\t\t} else {\n\t\t\t\tthrow new IVisitor.VisitorException(\"Yices does not support defining parameterized types\",null);\n\t\t\t}\n\t\t\treturn status;\n\t\t\t\n\t\t\t// FIXME - Yices does not seem to allow creating arbitrary new types\n\t\t\t// Besides Yices uses structural equivalence.\n\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Yices declare-sort command failed: \" + e.getMessage(),e.pos());\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic IResponse define_sort(Idefine_sort cmd) {\n\t\ttry {\n\t\t\tIResponse status = super.define_sort(cmd);\n\t\t\tif (!status.isOK()) return status;\n\n\t\t\tif (cmd.parameters().size() == 0) {\n\t\t\t\tString msg = \"(define-type \" + translate(cmd.sortSymbol()) + \" \";\n\t\t\t\tmsg = msg + translate(cmd.expression()) + \")\";\n\t\t\t\tIResponse response = send(cmd.sortSymbol().pos(),msg);\n\t\t\t\tif (response != null) return response;\n\t\t\t} else {\n\t\t\t\tthrow new IVisitor.VisitorException(\"Yices does not support defining parameterized types\",null);\n\t\t\t}\n\t\t\treturn status;\n\n\t\t\t// FIXME - Yices does not seem to allow creating arbitrary new types\n\t\t\t\t// Besides Yices uses structural equivalence.\n\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Yices define-sort command failed: \" + e.getMessage(),e.pos());\n\t\t}\n\n\t}\n\n\t@Override \n\tpublic IResponse get_proof() {\n\t\tIResponse status = super.get_proof();\n\t\tif (status.isError()) return status;\n\t\ttry {\n\t\t\tString response = solverProcess.sendAndListen(\"(get-proof)\\n\");\n\t\t\tif (response.contains(errorIndication)) {\n\t\t\t\treturn smtConfig.responseFactory.error(response);\n\t\t\t}\n\t\t\treturn smtConfig.responseFactory.unsupported(); // FIXME - need to return the proof\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\n\t@Override \n\tpublic IResponse get_unsat_core() {\n\t\tIResponse status = super.get_unsat_core();\n\t\tif (status.isError()) return status;\n\t\ttry {\n\t\t\tString response = solverProcess.sendAndListen(\"(get-unsat-core)\\n\");\n\t\t\tif (response.contains(errorIndication)) {\n\t\t\t\treturn smtConfig.responseFactory.error(response);\n\t\t\t}\n\t\t\treturn smtConfig.responseFactory.unsupported(); // FIXME - need to return the unsat core\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\n\t@Override \n\tpublic IResponse get_assignment() {\n\t\tIResponse status = super.get_assignment();\n\t\tif (status.isError()) return status;\n\t\ttry {\n\t\t\tString response = solverProcess.sendAndListen(\"(get-assignment)\\n\");\n\t\t\tif (response.contains(errorIndication)) {\n\t\t\t\treturn smtConfig.responseFactory.error(response);\n\t\t\t}\n\t\t\treturn smtConfig.responseFactory.unsupported(); // FIXME - need to return the assignment\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\n\t@Override \n\tpublic IResponse get_value(IExpr... terms) {\n\t\tIResponse status = super.get_value(terms);\n\t\tif (status.isError()) return status;\n\t\ttry {\n\t\t\tsolverProcess.sendNoListen(\"(get-value\");\n\t\t\tfor (IExpr e: terms) {\n\t\t\t\tsolverProcess.sendNoListen(\" \",translate(e));\n\t\t\t}\n\t\t\tString response = solverProcess.sendAndListen(\"\\n\");\n\t\t\tif (response.contains(errorIndication)) {\n\t\t\t\treturn smtConfig.responseFactory.error(response);\n\t\t\t}\n\t\t\treturn smtConfig.responseFactory.unsupported(); // FIXME - need to return the results\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Yices solver: \" + e);\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error translating for Yices: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\tpublic /*@Nullable*/ String translate(IExpr expr) throws IVisitor.VisitorException {\n\t\treturn expr.accept(new Translator());\n\t}\n\t\n\tpublic /*@Nullable*/ String translate(ISort expr) throws IVisitor.VisitorException {\n\t\treturn expr.accept(new Translator());\n\t}\n\t\n\t/* Yices does not distinguish formulas and terms, so the mapping\n\t * from SMT-LIB is simpler.\n\t */\n\t\n\tstatic Map\u003cString,String\u003e fcnNames = new HashMap\u003cString,String\u003e();\n\tstatic Set\u003cString\u003e logicNames = new HashSet\u003cString\u003e();\n\tstatic {\n\t\t/* SMTLIB\t\t\tYICES\n\t\t * (or p q r ...)\t(or p q r ...)\n\t\t * (and p q r ...)\t(and p q r ...)\n\t\t * (not p)\t\t\t(not p)\n\t\t * (=\u003e p q r ...)\t(=\u003e p (=\u003e q r...))\n\t\t * (xor p q r ...)\t(/= (/= p q)) r )) ...\n\t\t * (= p q r ...)\t(and (= p q) (= q r) ... ) \n\t\t * (distinct p q r)\t conjunction of /= \n\t\t * true\t\t\t\ttrue\n\t\t * false\t\t\tfalse\n\t\t * (ite b p q)\t\t(if b p q)\n\t\t * (forall ...\t\t(forall (a::Bool b::Int) expr)\n\t\t * (exists ...\t\t(exists (a::Bool b::Int) expr)\n\t\t * (let ...\t\t\t(let ((aux::int (f (f x)))) (g aux aux))\n\t\t * \n\t\t * \u003c \u003c= \u003e \u003e=\t\t\u003c \u003c= \u003e \u003e=  : no chaining allowed\n\t\t *\n\t\t * TERMS\n\t\t * + - *\t\t\t+ - * : left associative\n\t\t * \t    \t\t\tselect store  - for arrays\n\t\t * \n\t\t * \n\t\t * Yices has / mod div\n\t\t */\n\t\t\n\t}\n\t\n\n\t/* Yices ids:\n\t * \t\tFIXME - not  defined what Yices ids can be made of\n\t */\n\t\n\tstatic Map\u003cString,String\u003e bvfcns = new HashMap\u003cString,String\u003e();\n\tstatic {\n\t\tbvfcns.put(\"bvadd\",\"bv-add\");\n\t\tbvfcns.put(\"bvand\",\"bv-and\");\n\t\tbvfcns.put(\"bvor\",\"bv-or\");\n\t\tbvfcns.put(\"bvmul\",\"bv-mul\");\n\t\tbvfcns.put(\"bvshl\",\"bv-shift-left0\"); // second argument is an integer\n\t\tbvfcns.put(\"bvlshr\",\"bv-shift-right0\"); // second argument is an integer\n\t\tbvfcns.put(\"bvneg\",\"bv-neg\");\n\t\tbvfcns.put(\"bvnot\",\"bv-not\");\n\t\tbvfcns.put(\"bvudiv\",\"\");\n\t\tbvfcns.put(\"bvurem\",\"\");\n\t\tbvfcns.put(\"concat\",\"bv-concat\");\n\t\tbvfcns.put(\"extract\",\"bv-extract\");\n\t\tbvfcns.put(\"bvult\",\"bv-lt\");\n\t\tbvfcns.put(\"bvnand\",\"\");\n\t\tbvfcns.put(\"bvnor\",\"\");\n\t\tbvfcns.put(\"bvxor\",\"\");\n\t\tbvfcns.put(\"bvxnor\",\"\");\n\t\tbvfcns.put(\"bvcomp\",\"\");\n\t\tbvfcns.put(\"bvsub\",\"\");\n\t\tbvfcns.put(\"bvsdiv\",\"\");\n\t\tbvfcns.put(\"bvsrem\",\"\");\n\t\tbvfcns.put(\"bvsmod\",\"\");\n\t\tbvfcns.put(\"bvashr\",\"\");\n\t\tbvfcns.put(\"bvule\",\"\");\n\t\tbvfcns.put(\"bvugt\",\"\");\n\t\tbvfcns.put(\"bvuge\",\"\");\n\t\tbvfcns.put(\"bvslt\",\"\");\n\t\tbvfcns.put(\"bvsle\",\"\");\n\t\tbvfcns.put(\"bvsgt\",\"\");\n\t\tbvfcns.put(\"bvsge\",\"\");\n\t}\n\n\t\n\tpublic class Translator extends IVisitor.NullVisitor\u003cString\u003e {\n\t\t\n\t\tpublic Translator() {}\n\t\t\n\t\tprotected String encode(IAttributeValue sym) {\n\t\t\treturn org.smtlib.sexpr.Printer.write(sym); // FIXME - is this OK?\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IDecimal e) throws IVisitor.VisitorException {\n\t\t\tthrow new VisitorException(\"The yices solver cannot handle decimal literals\",e.pos());\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IStringLiteral e) throws IVisitor.VisitorException {\n\t\t\tthrow new VisitorException(\"The yices solver cannot handle string literals\",e.pos());\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(INumeral e) throws IVisitor.VisitorException {\n\t\t\treturn e.value().toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IBinaryLiteral e) throws IVisitor.VisitorException {\n\t\t\treturn \"0b\" + e.value();\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IHexLiteral e) throws IVisitor.VisitorException {\n\t\t\t// Convert to binary literal\n\t\t\tfinal String[] bits = { \"0000\", \"1000\", \"0100\", \"1100\", \"0010\", \"1010\", \"0110\", \"1110\", \"0001\", \"1001\", \"0101\", \"1101\", \"0011\", \"1011\", \"0111\", \"1111\" };\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\tfor (int i = 0; i \u003c e.value().length(); i++) {\n\t\t\t\tchar c = e.value().charAt(i);\n\t\t\t\tint k = c \u003c= '9' ? (c-'0') : c \u003c= 'Z' ? (c - 'A' + 10) : (c - 'a' + 10);\n\t\t\t\ts.append(bits[k]);\n\t\t\t}\n\t\t\treturn s.toString();\n\t\t}\n\t\t\n\n\t\t@Override\n\t\tpublic String visit(IFcnExpr e) throws IVisitor.VisitorException {\n\t\t\tIterator\u003cIExpr\u003e iter = e.args().iterator();\n\t\t\tif (!iter.hasNext()) throw new VisitorException(\"Did not expect an empty argument list\",e.pos());\n\t\t\tIQualifiedIdentifier fcn = e.head();\n\t\t\tString fcnname = fcn.headSymbol().accept(this);\n\t\t\t// FIXME - should we be doing these comparisons with strings?\n\t\t\tif (fcn instanceof ParameterizedIdentifier \u0026\u0026 fcn.headSymbol().toString().equals(fcnname)) {\n\t\t\t\tthrow new VisitorException(\"Unknown parameterized function symbol: \" + fcnname, e.pos());\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint length  = e.args().size();\n\t\t\tif (fcnname.equals(\"or\") || fcnname.equals(\"and\")) {\n\t\t\t\t// operators that are still multi-arity\n\t\t\t\tsb.append(\"( \");\n\t\t\t\tsb.append(fcnname);\n\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t}\n\t\t\t\tsb.append(\" )\");\n\t\t\t\treturn sb.toString();\n\t\t\t} else if (fcnname.equals(\"=\") || fcnname.equals(\"\u003c\") || fcnname.equals(\"\u003e\") || fcnname.equals(\"\u003c=\") || fcnname.equals(\"\u003e=\")) {\n\t\t\t\t// chainable\n\t\t\t\treturn remove_chainable(fcnname,iter);\n\t\t\t} else if (fcnname.equals(\"xor\")) {\n\t\t\t\tfcnname = \"/=\";\n\t\t\t\t// left-associative operators that need grouping\n\t\t\t\treturn remove_leftassoc(fcnname,length,iter);\n\t\t\t} else if (fcnname.equals(\"=\u003e\")) {\n\t\t\t\t// right-associative operators that need grouping\n\t\t\t\tif (!iter.hasNext()) {\n\t\t\t\t\tthrow new VisitorException(\"=\u003e operation without arguments\",e.pos());\n\t\t\t\t}\n\t\t\t\treturn remove_rightassoc(fcnname,iter);\n\t\t\t} else if (fcnname.equals(\"distinct\")) {\n\t\t\t\tif (length == 2) {\n\t\t\t\t\tsb.append(\"(/=\");\n\t\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(\")\");\n\t\t\t\t} else {\n\t\t\t\t\tint j = 0;\n\t\t\t\t\tsb.append(\"(and\");\n\t\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\t\tIExpr n = iter.next();\n\t\t\t\t\t\tfor (int k = 0; k\u003cj; k++) {\n\t\t\t\t\t\t\tsb.append(\" (/= \");\n\t\t\t\t\t\t\tsb.append(n.accept(this));\n\t\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t\t\tsb.append(e.args().get(k).accept(this));\n\t\t\t\t\t\t\tsb.append(\")\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++j;\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(\")\");\n\t\t\t\t}\n\t\t\t\treturn sb.toString();\n\t\t\t} else if (length == 1 \u0026\u0026 fcnname.equals(\"-\")) {\n\t\t\t\t// In yices there is no negation: (- x) is just x\n\t\t\t\t// We express negation with (- 0 x)\n\t\t\t\tsb.append(\"(- 0 \");\n\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\tsb.append(\" )\");\n\t\t\t\treturn sb.toString();\n\t\t\t} else if (length == 2 \u0026\u0026 symTable.arrayTheorySet \u0026\u0026 fcnname.equals(\"select\")) {\n\t\t\t\tsb.append(\"(\");\n\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\tsb.append(\")\");\n\t\t\t\treturn sb.toString();\n\t\t\t} else if (length == 3 \u0026\u0026 symTable.arrayTheorySet \u0026\u0026 fcnname.equals(\"store\")) {\n\t\t\t\tsb.append(\"(update \");\n\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\tsb.append(\" (\");\n\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\tsb.append(\") \");\n\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\tsb.append(\")\");\n\t\t\t\treturn sb.toString();\n\t\t\t} else {\n\t\t\t\tif (symTable.bitVectorTheorySet) {\n\t\t\t\t\t// Predefined: bvadd, bvmul, bvneg, bvnot, bvshl, bvlshr, concat, extract, bvult, bvudiv, bvurem, bvand, bvor\n\t\t\t\t\tString newname = bvfcns.get(fcnname);\n\t\t\t\t\tif (newname == null) {\n\t\t\t\t\t\t// continue\n\t\t\t\t\t} else if (newname.isEmpty()) {\n\t\t\t\t\t\tthrow new VisitorException(\"The BitVector function \" + fcnname + \" is not implemented in yices\",e.pos());\n\t\t\t\t\t} else if (fcnname.equals(\"extract\")) {\n\t\t\t\t\t\tsb.append(\"(bv-extract \");\n\t\t\t\t\t\tIParameterizedIdentifier pid = (IParameterizedIdentifier)fcn;\n\t\t\t\t\t\tsb.append(pid.numerals().get(1).intValue());\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t\tsb.append(pid.numerals().get(0).intValue());\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\t\tsb.append(\")\");\n\t\t\t\t\t\treturn sb.toString();\n\t\t\t\t\t} else if (fcnname.equals(\"bvshl\") || fcnname.equals(\"bvlshr\")) {\n\t\t\t\t\t\tthrow new VisitorException(\"The BitVector function \" + fcnname + \" is not implementetd in yices\",e.pos());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfcnname = newname;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// no associativity \n\t\t\t\tsb.append(\"( \");\n\t\t\t\tsb.append(fcnname);\n\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t}\n\t\t\t\tsb.append(\" )\");\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\t\t}\n\t\t\t\n\t\t//@ requires iter.hasNext();\n\t\tprivate \u003cT extends IExpr\u003e String remove_rightassoc(String fcnname, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\n\t\t\tT n = iter.next();\n\t\t\tif (!iter.hasNext()) {\n\t\t\t\treturn n.accept(this);\n\t\t\t} else {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tsb.append(\"(\");\n\t\t\t\tsb.append(fcnname);\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(n.accept(this));\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(remove_rightassoc(fcnname,iter));\n\t\t\t\tsb.append(\")\");\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\t\t}\n\n\t\t//@ requires iter.hasNext();\n\t\t//@ requires length \u003e 0;\n\t\tprivate \u003cT extends IExpr\u003e String remove_leftassoc(String fcnname, int length, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\n\t\t\tif (length == 1) {\n\t\t\t\treturn iter.next().accept(this);\n\t\t\t} else {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tsb.append(\"(\");\n\t\t\t\tsb.append(fcnname);\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(remove_leftassoc(fcnname,length-1,iter));\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\tsb.append(\")\");\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\t\t}\n\t\t\n\t\t//@ requires iter.hasNext();\n\t\t//@ requires length \u003e 0;\n\t\tprivate \u003cT extends IAccept\u003e String remove_chainable(String fcnname, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(\"(and \");\n\t\t\tT left = iter.next();\n\t\t\twhile (iter.hasNext()) {\n\t\t\t\tsb.append(\"(\");\n\t\t\t\tsb.append(fcnname);\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(left.accept(this));\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append((left=iter.next()).accept(this));\n\t\t\t\tsb.append(\")\");\n\t\t\t}\n\t\t\tsb.append(\")\");\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(ISymbol e) throws IVisitor.VisitorException {\n\t\t\treturn e.value(); // FIXME - translate\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IKeyword e) throws IVisitor.VisitorException {\n\t\t\tthrow new VisitorException(\"Did not expect a Keyword in an expression to be translated\",e.pos());\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IError e) throws IVisitor.VisitorException {\n\t\t\tthrow new VisitorException(\"Did not expect a Error token in an expression to be translated\", e.pos());\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IParameterizedIdentifier e) throws IVisitor.VisitorException {\n\t\t\t// FIXME - use default printer properly to print Symbol\n\t\t\tthrow new IVisitor.VisitorException(\"Unsupported parameterized function symbol: \" + e.headSymbol().toString(),e.pos());\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IAsIdentifier e) throws IVisitor.VisitorException {\n\t\t\tthrow new UnsupportedOperationException(\"visit-IAsIdentifier\");\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IForall e) throws IVisitor.VisitorException {\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\tsb.append(\"(forall (\");\n\t\t\tfor (IDeclaration d: e.parameters()) {\n\t\t\t\tsb.append(d.parameter().accept(this));\n\t\t\t\tsb.append(\"::\");\n\t\t\t\tsb.append(d.sort().accept(this));\n\t\t\t\tsb.append(\" \");\n\t\t\t}\n\t\t\tsb.append(\") \");\n\t\t\tsb.append(e.expr().accept(this));\n\t\t\tsb.append(\")\");\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IExists e) throws IVisitor.VisitorException {\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\tsb.append(\"(exists (\");\n\t\t\tfor (IDeclaration d: e.parameters()) {\n\t\t\t\tsb.append(d.parameter().accept(this));\n\t\t\t\tsb.append(\"::\");\n\t\t\t\tsb.append(d.sort().accept(this));\n\t\t\t\tsb.append(\" \");\n\t\t\t}\n\t\t\tsb.append(\") \");\n\t\t\tsb.append(e.expr().accept(this));\n\t\t\tsb.append(\")\");\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(ILet e) throws IVisitor.VisitorException {\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\tsb.append(\"(let (\");\n\t\t\tfor (IBinding d: e.bindings()) {\n\t\t\t\tsb.append(\"(\");\n\t\t\t\tsb.append(d.parameter().accept(this));\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(d.expr().accept(this));\n\t\t\t\tsb.append(\")\");\n\t\t\t}\n\t\t\tsb.append(\") \");\n\t\t\tsb.append(e.expr().accept(this));\n\t\t\tsb.append(\")\");\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IAttribute\u003c?\u003e e) throws IVisitor.VisitorException {\n\t\t\tthrow new UnsupportedOperationException(\"visit-IAttribute\");\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IAttributedExpr e) throws IVisitor.VisitorException {\n\t\t\tIExpr expr = e.expr();\n\t\t\tIAttribute\u003c?\u003e attr = e.attributes().get(0);\n\t\t\tif (attr.keyword().toString().equals(\":named\")) {\n\t\t\t\tString name = encode(attr.attrValue());\n\t\t\t\tString ex = expr.accept(this);\n\t\t\t\tString sort = typemap.get(expr).accept(this);\n\t\t\t\tString def = \"(define \" + name + \"::\" + sort + \" \" + ex + \")\";\n\t\t\t\tIResponse response = send(e.pos(),def);\n\t\t\t\tif (response != null) {\n\t\t\t\t\tthrow new VisitorException(\"Failed to define attributed expression: \" + response, e.pos()); // FIXME - error message format?\n\t\t\t\t}\n\t\t\t\treturn ex;\n\t\t\t} else {\n\t\t\t\tthrow new VisitorException(\"Unexpected kind of keyword: \" + smtConfig.defaultPrinter.toString(attr.keyword()),attr.pos());\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IDeclaration e) throws IVisitor.VisitorException {\n\t\t\tthrow new UnsupportedOperationException(\"visit-IDeclaration\");\n\t\t}\n\n\t\tpublic String visit(ISort.IFamily s) throws IVisitor.VisitorException {\n\t\t\treturn s.identifier().accept(this);\n\t\t}\n\t\t\n\t\tpublic String visit(ISort.IAbbreviation s) throws IVisitor.VisitorException {\n\t\t\tthrow new UnsupportedOperationException(\"visit-ISort.IAbbreviation\");\n\t\t}\n\t\t\n\t\tpublic String visit(ISort.IApplication s) throws IVisitor.VisitorException {\n\t\t\tif (s.isBool()) return \"bool\";\n\t\t\tString sort = s.family().headSymbol().accept(this);\n\t\t\tif (s.parameters().size() == 0) {\n\t\t\t\tif (\"Int\".equals(sort)) return \"int\";\n\t\t\t\tif (\"Real\".equals(sort)) return \"real\";\n\t\t\t\tif (symTable.bitVectorTheorySet \u0026\u0026 \"BitVec\".equals(sort)) {\n\t\t\t\t\tString sbv = \"(bitvector \";\n\t\t\t\t\tint k = ((IParameterizedIdentifier)s.family()).numerals().get(0).intValue();\n\t\t\t\t\tsbv = sbv + k + \")\";\n\t\t\t\t\treturn sbv;\n\t\t\t\t}\n\t\t\t\treturn sort;\n\t\t\t} else {\n\t\t\t\tif (symTable.arrayTheorySet \u0026\u0026 \"Array\".equals(sort)) {\n\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\tsb.append(\"(-\u003e \");\n\t\t\t\t\tsb.append(s.parameters().get(0).accept(this));\n\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\tsb.append(s.parameters().get(1).accept(this));\n\t\t\t\t\tsb.append(\")\");\n\t\t\t\t\treturn sb.toString();\n\t\t\t\t}\n\t\t\t\tthrow new VisitorException(\"Yices does not support user-defined parameterized sorts: \" + s, s.pos());\n\t\t\t}\n\t\t}\n\t\tpublic String visit(ISort.IFcnSort s) {\n\t\t\tthrow new UnsupportedOperationException(\"visit-ISort.IFcnSort\");\n\t\t}\n\t\tpublic String visit(ISort.IParameter s) {\n\t\t\tthrow new UnsupportedOperationException(\"visit-ISort.IParameter\");\n\t\t}\n\t\t\n\t\t\n\t}\n}\n",
        "name": "Solver_yices.java",
        "path": "SMT/src/org/smtlib/solvers/Solver_yices.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMT/src/org/smtlib/solvers/Solver_yices.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 706,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();"
        },
        {
          "limitHit": false,
          "lineNumber": 724,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();"
        },
        {
          "limitHit": false,
          "lineNumber": 725,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires length \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 742,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();"
        },
        {
          "limitHit": false,
          "lineNumber": 743,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires length \u003e 0;"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\n * This file is part of the SMT project.\n * Copyright 2010 David R. Cok\n * Created August 2010\n */\npackage org.smtlib;\n\nimport java.io.IOException;\nimport java.nio.CharBuffer;\n\n/** This class implements a CharSequence that obtains its characters from a source of characters\n * of unknown length; it also provides some functionality to retain the characters and compute line numbers.  \n * \u003cP\u003e\n * The characters \n * read are held in an internal char array, whose size grows as needed; it starts as initialSize and\n * is expanded to currentSize*sizeMultiple + sizeIncrease whenever needed.\n * \u003cP\u003e\n * The CharSequenceReader is an unconventional CharSequence in that its length() is not known; \n * whether this will cause problems\n * in some uses of the CharSequenceReader is unknown.  The user should not use the value of length()\n * directly; it seems to work in the ways it is called from Pattern.matcher.\n * @author David R. Cok\n *\n */\npublic abstract class CharSequenceInfinite implements CharSequence {\n\n\t/** This interface is used to create prompters.  A CharSequenceInfinite object needs on occasion to\n\t * obtain new input, which it does by calling readChars().  readChars() invokes the prompter to \n\t * communicate to the source of input that more data is needed.  As an example, if the input comes from\n\t * interactive input, the prompter may print out prompt characters.\n\t */\n\tpublic static interface IPrompter {\n\t\t/** Implement this call-back to do whatever user actions are needed to\n\t\t * cause more input to be available.\n\t\t */\n\t\tvoid prompt();\n\t}\n\t\n\t/** The prompter object */\n\tpublic /*@Nullable*/ IPrompter prompter = null;\n\t\n\t/** Constructor for a new instance\n\t * \n\t * @param initialSize the beginning size of the internal char array\n\t * @param sizeIncrease the amount to add to the current size of the internal char array when the array needs expanding\n\t * @param sizeMultiple the factor by which to multiply the current size of the internal char array when it needs expanding\n\t */\n\t//@ requires initialSize \u003e 0 \u0026\u0026 sizeIncrease \u003e= 0 \u0026\u0026 sizeMultiple \u003e= 1;\n\t//@ requires !(sizeIncrease == 0 \u0026\u0026 sizeMultiple == 1)\n\tpublic CharSequenceInfinite(int initialSize, int sizeIncrease, double sizeMultiple) {\n\t\tthis.sizeIncrease = sizeIncrease;\n\t\tthis.sizeMultiple = sizeMultiple;\n\t\tbuf = new char[initialSize];\n\t\tthis.amountRead = 0;\n\t\tthis.length = Integer.MAX_VALUE;\n\t}\n\n\t/** The amount by which to increase the internal char array when needed */\n\t//@ invariant sizeIncrease \u003e= 0;\n\tprotected int sizeIncrease;\n\n\t/** The factor by which to increase the size of the internal char array when needed */\n\t//@ invariant sizeMultiple \u003e= 1 \u0026\u0026 (sizeIncrease==0 ==\u003e sizeMultiple \u003e 1);\n\tprotected double sizeMultiple;\n\n\t/** The internal char array that holds characters as they are read */\n\tprotected char /*@NonNull*/[] buf;\n\n\t/** The number of characters read so far (and in the char array) */\n\t//@ invariant amountRead \u003e= 0 \u0026\u0026 amountRead \u003c= buf.length;\n\tprotected int amountRead;\n\n\t/** The implicit length of the CharSequence; note that this length may change as characters are read */\n\t//@ invariant length \u003e= 0 \u0026\u0026 length \u003e= amountRead;\n\tprotected int length;\n\n\t/** The character to use to mark the end of input */\n\tfinal public static char endChar = (char)25;\n\n\t//@ constraint (\\forall int i; 0 \u003c= i \u003c \\old(amountRead); \\old(buf[i]) == buf[i]);\n\t//@ constraint amountRead \u003e= \\old(amountRead);\n\t\n\t/** Returns the char at the given index; this may block while input is read if the char has\n\t * not been read before.  An IOException that occurs while reading input is converted to an\n\t * undeclared RuntimeException. \n\t */\n\t//@ requires index \u003e= 0;\n\t//@ assigns buf, buf[amountRead..], amountRead, length;\n\t//@ ensures index \u003c amountRead;\n\t@Override\n\tpublic char charAt(int index) {\n\t\tif (index \u003e= amountRead) {\n\t\t\tif (index \u003e= buf.length) {\n\t\t\t\t// We need +1 because one needs a buffer of at least size 2 to include index=1\n\t\t\t\t// We add an additional +1 so that there is room to hold an End-of-input character if necessary\n\t\t\t\texpandBuffer(index+2);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\twhile (amountRead \u003c= index) {\n\t\t\t\t\tif (!readChars()){\n\t\t\t\t\t\t//SMT.out.println(\"END OF INPUT READ\");\n\t\t\t\t\t\tbuf[amountRead++] = endChar;\n\t\t\t\t\t\tlength = amountRead;\n\t\t\t\t\t\treturn endChar;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Note: we catch IOException and turn it into a RuntimeException\n\t\t\t\t// (so it does not have to be declared) because the inherited \n\t\t\t\t// signature for charAt(int) does not declare any thrown exceptions\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn buf[index];\n\t}\n\t\n\t/** Reads more characters into the buffer; may block until some are read;\n\t * returns false if end of input has been reached,\n\t * in which case no additional chars should have been read.  Does not expand the\n\t * buffer, so the buffer must have extra space in it when readChars() is called.\n\t * @return true if characters were read, false if no chars were read and end of input was reached\n\t */\n\t//@ requires buf.length \u003e amountRead;\n\t//@ modifies buf,buf[amountRead..],amountRead;\n\t//@ ensures \\result =\u003e amountRead \u003e \\old(amountRead);\n\t//@ ensures !\\result ==\u003e amountRead == \\old(amountRead);\n\t//@ ensures buf[0..\\old(amountRead)-1] == \\old(buf[0..amountRead-1]);\n\tabstract protected boolean readChars() throws java.io.IOException ;\n\t\n\t/** This expands the buffer to be at least as large as the argument; the buffer is expanded\n\t * even if it is already of adequate size.\n\t * \n\t * @param newSize minimum size of the expanded buffer\n\t */\n\t//@ requires newSize \u003e 0;\n\t//@ modifies buf;\n\t//@ ensures buf.length \u003e= newSize \u0026\u0026 buf.length \u003e \\old(buf.length);\n\t//@ ensures (\\forall int i; 0\u003c=i \u0026\u0026 i\u003camountRead; buf[i] == \\old(buf[i]));\n\tprivate void expandBuffer(int newSize) {\n\t\tint newlength = buf.length;\n\t\tdo {\n\t\t\tint k = (int) Math.ceil(newlength*sizeMultiple+sizeIncrease);\n\t\t\tnewlength = (k \u003c= newlength) ? newlength+100 : k; // check for both bad parameters and for integer overflow\n\t\t} while (newSize \u003e newlength);\n\t\tchar[] nbuf = new char[newlength];\n\t\tSystem.arraycopy(buf,0,nbuf,0,amountRead);\n\t\tbuf = nbuf;\n\t}\n\n\t/** Returns the length of the CharSequence; for this implementation, the return value is at\n\t * least as great as the unknown length of the CharSequence.  The value is correct once the\n\t * end of input has been reached.\n\t * @return the length of the CharSequence\n\t */\n\t@Override\n\tpublic int length() {\n\t\treturn this.length;\n\t}\n\n\t/** Returns a subsequence of this CharSequence, of length end-start.\n\t * CAUTION: This method can wrap a portion of the internal char array, but then\n\t * the char array can be expanded, allocating a new char array - so just don't rely on\n\t * changes to the sub-sequence to be reflected in the parent array.\n\t * @param start the starting index of the subsequence\n\t * @param end one past the last character included in the subsequence\n\t * \n\t */\n\t@Override\n\tpublic CharSequence subSequence(int start, int end) {\n\t\tcharAt(end-1); // Just to be sure it has been read\n\t\treturn CharBuffer.wrap(buf,start,end-start);\n\t}\n\t\n}\n",
        "name": "CharSequenceInfinite.java",
        "path": "SMT/src/org/smtlib/CharSequenceInfinite.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMT/src/org/smtlib/CharSequenceInfinite.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 47,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires initialSize \u003e 0 \u0026\u0026 sizeIncrease \u003e= 0 \u0026\u0026 sizeMultiple \u003e= 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 48,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires !(sizeIncrease == 0 \u0026\u0026 sizeMultiple == 1)"
        },
        {
          "limitHit": false,
          "lineNumber": 86,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires index \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 88,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures index \u003c amountRead;"
        },
        {
          "limitHit": false,
          "lineNumber": 122,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires buf.length \u003e amountRead;"
        },
        {
          "limitHit": false,
          "lineNumber": 124,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result =\u003e amountRead \u003e \\old(amountRead);"
        },
        {
          "limitHit": false,
          "lineNumber": 125,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures !\\result ==\u003e amountRead == \\old(amountRead);"
        },
        {
          "limitHit": false,
          "lineNumber": 126,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures buf[0..\\old(amountRead)-1] == \\old(buf[0..amountRead-1]);"
        },
        {
          "limitHit": false,
          "lineNumber": 134,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires newSize \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 136,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures buf.length \u003e= newSize \u0026\u0026 buf.length \u003e \\old(buf.length);"
        },
        {
          "limitHit": false,
          "lineNumber": 137,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures (\\forall int i; 0\u003c=i \u0026\u0026 i\u003camountRead; buf[i] == \\old(buf[i]));"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\n * This file is part of the SMT project.\n * Copyright 2010 David R. Cok\n * Created August 2010\n */\npackage org.smtlib.solvers;\n\n// Items not implemented:\n//   attributed expressions\n//   get-values get-assignment get-proof get-unsat-core\n//   some error detection and handling\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.smtlib.*;\nimport org.smtlib.ICommand.Ideclare_fun;\nimport org.smtlib.ICommand.Ideclare_sort;\nimport org.smtlib.ICommand.Idefine_fun;\nimport org.smtlib.ICommand.Idefine_sort;\nimport org.smtlib.IExpr.IAttribute;\nimport org.smtlib.IExpr.IFcnExpr;\nimport org.smtlib.IExpr.IIdentifier;\nimport org.smtlib.IExpr.IKeyword;\nimport org.smtlib.IExpr.INumeral;\nimport org.smtlib.IExpr.IQualifiedIdentifier;\nimport org.smtlib.IExpr.IStringLiteral;\nimport org.smtlib.IParser.ParserException;\nimport org.smtlib.SMT.Configuration.SMTLIB;\nimport org.smtlib.impl.Pos;\nimport org.smtlib.sexpr.Printer;\nimport org.smtlib.sexpr.Utils;\n\n/** This class is an adapter that takes the SMT-LIB ASTs and translates them into Z3 commands */\npublic class Solver_z3_4_3 extends AbstractSolver implements ISolver {\n\t\n\tprotected String NAME_VALUE = \"z3-4.3\";\n\tprotected String AUTHORS_VALUE = \"Leonardo de Moura and Nikolaj Bjorner\";\n\tprotected String VERSION_VALUE = \"4.3\";\n\t\n\n\tprotected int linesOffset = 0;\n\t\n\t/** A reference to the SMT configuration */\n\tprotected SMT.Configuration smtConfig;\n\n\t/** A reference to the SMT configuration */\n\tpublic SMT.Configuration smt() { return smtConfig; }\n\t\n\t/** The command-line arguments for launching the Z3 solver */\n\tprotected String cmds[];\n\tprotected String cmds_win[] = new String[]{ \"\", \"/smt2\",\"/in\",\"SMTLIB2_COMPLIANT=true\"};//,\"/rs:42\"}; \n\tprotected String cmds_mac[] = new String[]{ \"\", \"-smt2\",\"-in\",\"SMTLIB2_COMPLIANT=true\"}; \n\tprotected String cmds_unix[] = new String[]{ \"\", \"-smt2\",\"-in\"}; \n\t\n\t/** The parser that parses responses from the solver */\n\tprotected org.smtlib.sexpr.Parser responseParser;\n\t\n\t/** Set to true once a set-logic command has been executed */\n\tprotected boolean logicSet = false;\n\t\n\t/** The checkSatStatus returned by check-sat, if sufficiently recent, otherwise null */\n\tprotected /*@Nullable*/ IResponse checkSatStatus = null;\n\t\n\t@Override\n\tpublic /*@Nullable*/IResponse checkSatStatus() { return checkSatStatus; }\n\n\t/** The number of pushes less the number of pops so far */\n\tprotected int pushesDepth = 0;\n\t\n\t/** Map that keeps current values of options */\n\tprotected Map\u003cString,IAttributeValue\u003e options = new HashMap\u003cString,IAttributeValue\u003e();\n\t\n\t/** Creates an instance of the Z3 solver */\n\tpublic Solver_z3_4_3(SMT.Configuration smtConfig, /*@NonNull*/ String executable) {\n\t\tthis.smtConfig = smtConfig;\n\t\tif (isWindows) {\n\t\t\tcmds = cmds_win;\n\t\t} else if (isMac) {\n\t\t\tcmds = cmds_mac;\n\t\t\tif (smtConfig.seed != 0) {\n\t\t\t    cmds = Utils.cat(cmds,\"-rs:\"+smtConfig.seed);\n\t\t\t}\n\t\t} else {\n\t\t\tcmds = cmds_unix;\n            if (smtConfig.seed != 0) {\n                cmds = Utils.cat(cmds,\"-rs:\"+smtConfig.seed);\n            }\n\t\t}\n\t\tcmds[0] = executable;\n\t\toptions.putAll(smtConfig.utils.defaults);\n\t\tdouble timeout = smtConfig.timeout;\n\t\tif (timeout \u003e 0) {\n\t\t\tList\u003cString\u003e args = new java.util.ArrayList\u003cString\u003e(cmds.length+1);\n\t\t\targs.addAll(Arrays.asList(cmds));\n\t\t\tif (isWindows) args.add(\"/t:\" + Integer.toString((int)timeout));\n\t\t\telse           args.add(\"-t:\" + Integer.toString((int)timeout));\n\t\t\tcmds = args.toArray(new String[args.size()]);\n\t\t}\n\t\tsolverProcess = new SolverProcess(cmds,\"\\n\",smtConfig.logfile);\n\t\tresponseParser = new org.smtlib.sexpr.Parser(smt(),new Pos.Source(\"\",null));\n\t}\n\n\t/** Creates an instance of the Z3 solver */\n\tpublic Solver_z3_4_3(SMT.Configuration smtConfig, /*@NonNull*/ String[] command) {\n\t\tthis.smtConfig = smtConfig;\n\t\tcmds = command;\n\t\toptions.putAll(smtConfig.utils.defaults);\n        if (smtConfig.seed != 0) {\n            if (isWindows) {}//cmds = Utils.cat(cmds,\"/rs:\"+smtConfig.seed);\n            else           cmds = Utils.cat(cmds,\"-rs:\"+smtConfig.seed);\n        }\n\t\tdouble timeout = smtConfig.timeout;\n\t\tif (timeout \u003e 0) {\n\t\t\tList\u003cString\u003e args = new java.util.ArrayList\u003cString\u003e(cmds.length+1);\n\t\t\targs.addAll(Arrays.asList(cmds));\n\t\t\tif (isWindows) args.add(\"/t:\" + Integer.toString((int)timeout));\n\t\t\telse           args.add(\"-t:\" + Integer.toString((int)timeout));\n\t\t\tcmds = args.toArray(new String[args.size()]);\n\t\t}\n\t\tsolverProcess = new SolverProcess(cmds,\"\\n\",smtConfig.logfile);\n\t\tresponseParser = new org.smtlib.sexpr.Parser(smt(),new Pos.Source(\"\",null));\n\t}\n\n\tpublic IResponse sendCommand(ICommand cmd) {\n\t\tString translatedCmd = null;\n\t\ttry {\n\t\t\ttranslatedCmd = translate(cmd);\n\t\t\treturn parseResponse(solverProcess.sendAndListen(translatedCmd,\"\\n\"));\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to solver: \" + translatedCmd + \" \" + e);\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to solver: \" + translatedCmd + \" \" + e);\n\t\t}\n\t}\n\t\n\tpublic IResponse sendCommand(String cmd) {\n\t\ttry {\n\t\t\treturn parseResponse(solverProcess.sendAndListen(cmd,\"\\n\"));\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to solver: \" + cmd + \" \" + e);\n\t\t}\n\t}\n\t\n\n\t@Override\n\tpublic IResponse start() {\n\t\ttry {\n\t\t\tsolverProcess.start(false);\n\t\t\t// FIXME - enable the following lines when the Z3 solver supports them\n//\t\t\tif (smtConfig.solverVerbosity \u003e 0) solverProcess.sendNoListen(\"(set-option :verbosity \",Integer.toString(smtConfig.solverVerbosity),\")\");\n//\t\t\tif (!smtConfig.batch) solverProcess.sendNoListen(\"(set-option :interactive-mode true)\"); // FIXME - not sure we can do this - we'll lose the feedback\n\t\t\t// Can't turn off printing success, or we get no feedback\n\t\t\tsolverProcess.sendAndListen(\"(set-option :print-success true)\\n\"); // Z3 4.3.0 needs this because it mistakenly has the default for :print-success as false\n\t\t\tlinesOffset ++; \n\t\t\t//if (smtConfig.nosuccess) solverProcess.sendAndListen(\"(set-option :print-success false)\");\n\t\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Started \"+NAME_VALUE+\" \");\n\t\t\treturn smtConfig.responseFactory.success();\n\t\t} catch (Exception e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to start process \" + cmds[0] + \" : \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic IResponse exit() {\n\t\ttry {\n\t\t\tsolverProcess.sendAndListen(\"(exit)\\n\");\n\t\t\tsolverProcess.exit();\n\t\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Ended Z3 \");\n\t\t\treturn successOrEmpty(smtConfig);\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic void forceExit() {\n\t\tif (solverProcess != null) solverProcess.exit();\n\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Ended Z3 forcibly\");\n\t}\n\n\t@Override \n\tpublic void comment(String comment) {\n\t\ttry {\n\t\t\tsolverProcess.sendNoListen(comment);\n\t\t} catch (IOException e) {\n\t\t\t// FIXME;\n\t\t}\n\t}\n\n\t/** Translates an S-expression into Z3 syntax */\n\tprotected String translate(IAccept sexpr) throws IVisitor.VisitorException {\n\t\t// The z3 solver uses the standard S-expression concrete syntax, but not quite\n\t\t// so we have to use our own translator\n\t\tStringWriter sw = new StringWriter();\n\t\tsexpr.accept(new Translator(sw));\n\t\treturn sw.toString();\n\t}\n\t\n\t/** Translates an S-expression into standard SMT syntax */\n\tprotected String translateSMT(IAccept sexpr) throws IVisitor.VisitorException {\n\t\t// The z3 solver uses the standard S-expression concrete syntax, but not quite\n\t\tStringWriter sw = new StringWriter();\n\t\torg.smtlib.sexpr.Printer.write(sw,sexpr);\n\t\treturn sw.toString();\n\t}\n\t\n\tprotected IResponse parseResponse(String response) {\n\t\ttry {\n\t\t\tPattern oldbv = Pattern.compile(\"bv([0-9]+)\\\\[([0-9]+)\\\\]\");\n\t\t\tMatcher mm = oldbv.matcher(response);\n\t\t\twhile (mm.find()) {\n\t\t\t\tlong val = Long.parseLong(mm.group(1));\n\t\t\t\tint base = Integer.parseInt(mm.group(2));\n\t\t\t\tString bits = \"\";\n\t\t\t\tfor (int i=0; i\u003cbase; i++) { bits = ((val\u00261)==0 ? \"0\" : \"1\") + bits; val = val \u003e\u003e\u003e 1; }\n\t\t\t\tresponse = response.substring(0,mm.start()) + \"#b\" + bits + response.substring(mm.end(),response.length());\n\t\t\t\tmm = oldbv.matcher(response);\n\t\t\t}\n\t\t\tif (isMac \u0026\u0026 response.startsWith(\"success\")) return smtConfig.responseFactory.success(); // IFXME - this is just to avoid a problem with the Mac Z3 implementation\n\t\t\tif (response.contains(\"error\")) {\n\t\t\t\t// Z3 returns an s-expr (always?)\n\t\t\t\t// FIXME - (1) the {Print} also needs {Space}; (2) err_getValueTypes.tst returns a non-error s-expr and then an error s-expr - this fails for that case\n\t\t\t\t//Pattern p = Pattern.compile(\"\\\\p{Space}*\\\\(\\\\p{Blank}*error\\\\p{Blank}+\\\"(([\\\\p{Space}\\\\p{Print}^[\\\\\\\"\\\\\\\\]]|\\\\\\\\\\\")*)\\\"\\\\p{Blank}*\\\\)\\\\p{Space}*\");\n\t\t\t\tPattern p = Pattern.compile(\"\\\\p{Space}*\\\\(\\\\p{Blank}*error\\\\p{Blank}+\\\"(([\\\\p{Print}\\\\p{Space}\u0026\u0026[^\\\"\\\\\\\\]]|\\\\\\\\\\\")*)\\\"\\\\p{Blank}*\\\\)\");\n\t\t\t\tMatcher m = p.matcher(response);\n\t\t\t\tString concat = \"\";\n\t\t\t\twhile (m.lookingAt()) {\n\t\t\t\t\tif (!concat.isEmpty()) concat = concat + \"; \";\n\t\t\t\t\tString matched = m.group(1);\n\t\t\t\t\tString prefix = \"line \";\n\t\t\t\t\tint offset = prefix.length();\n\t\t\t\t\tif (matched.startsWith(prefix)) {\n\t\t\t\t\t\tint k = matched.indexOf(' ',offset);\n\t\t\t\t\t\tString number = matched.substring(offset, k);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tint n = Integer.parseInt(number);\n\t\t\t\t\t\t\tmatched = prefix + (n-linesOffset) + matched.substring(k);\n\t\t\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t\t\t// Just continue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconcat = concat + matched;\n\t\t\t\t\tm.region(m.end(0),m.regionEnd());\n\t\t\t\t}\n\t\t\t\tif (!concat.isEmpty()) response = concat;\n\t\t\t\treturn smtConfig.responseFactory.error(response);\n\t\t\t}\n\t\t\tresponseParser = new org.smtlib.sexpr.Parser(smt(),new Pos.Source(response,null));\n\t\t\treturn responseParser.parseResponse(response);\n\t\t} catch (ParserException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"ParserException while parsing response: \" + response + \" \" + e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse assertExpr(IExpr sexpr) {\n\t\tIResponse response;\n\t\tif (pushesDepth \u003c= 0) {\n\t\t\treturn smtConfig.responseFactory.error(\"All assertion sets have been popped from the stack\");\n\t\t}\n\t\tif (!logicSet) {\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before an assert command is issued\");\n\t\t}\n\t\ttry {\n\t\t\tString s = solverProcess.sendAndListen(\"(assert \",translate(sexpr),\")\\n\");\n\t\t\tresponse = parseResponse(s);\n\t\t\tcheckSatStatus = null;\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to assert expression: \" + e + \" \" + sexpr);\n\t\t} catch (Exception e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to assert expression: \" + e + \" \" + sexpr);\n\t\t}\n\t\treturn response;\n\t}\n\t\n\t@Override\n\tpublic IResponse get_assertions() {\n\t\tif (!logicSet) {\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a get-assertions command is issued\");\n\t\t}\n\t\t// FIXME - do we really want to call get-option here? it involves going to the solver?\n\t\tif (!smtConfig.relax \u0026\u0026 !Utils.TRUE.equals(get_option(smtConfig.exprFactory.keyword(Utils.PRODUCE_ASSERTIONS)))) {\n\t\t\treturn smtConfig.responseFactory.error(\"The get-assertions command is only valid if :interactive-mode has been enabled\");\n\t\t}\n\t\ttry {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tString s;\n\t\t\tint parens = 0;\n\t\t\tdo {\n\t\t\t\ts = solverProcess.sendAndListen(\"(get-assertions)\\n\");\n\t\t\t\tint p = -1;\n\t\t\t\twhile (( p = s.indexOf('(',p+1)) != -1) parens++;\n\t\t\t\tp = -1;\n\t\t\t\twhile (( p = s.indexOf(')',p+1)) != -1) parens--;\n\t\t\t\tsb.append(s.replace('\\n',' ').replace(\"\\r\",\"\"));\n\t\t\t} while (parens \u003e 0);\n\t\t\ts = sb.toString();\n\t\t\torg.smtlib.sexpr.Parser p = new org.smtlib.sexpr.Parser(smtConfig,new org.smtlib.impl.Pos.Source(s,null));\n\t\t\tList\u003cIExpr\u003e exprs = new LinkedList\u003cIExpr\u003e();\n\t\t\ttry {\n\t\t\t\tif (p.isLP()) {\n\t\t\t\t\tp.parseLP();\n\t\t\t\t\twhile (!p.isRP() \u0026\u0026 !p.isEOD()) {\n\t\t\t\t\t\tIExpr e = p.parseExpr();\n\t\t\t\t\t\texprs.add(e);\n\t\t\t\t\t}\n\t\t\t\t\tif (p.isRP()) {\n\t\t\t\t\t\tp.parseRP();\n\t\t\t\t\t\tif (p.isEOD()) return smtConfig.responseFactory.get_assertions_response(exprs); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (Exception e ) {\n\t\t\t\t// continue - fall through\n\t\t\t}\n\t\t\treturn smtConfig.responseFactory.error(\"Unexpected output from the Z3 solver: \" + s);\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"IOException while reading Z3 reponse\");\n\t\t}\n\t}\n\t\n\n\n\t@Override\n\tpublic IResponse check_sat() {\n\t\tIResponse res;\n\t\ttry {\n\t\t\tif (!logicSet) {\n\t\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a check-sat command is issued\");\n\t\t\t}\n\t\t\tString s = solverProcess.sendAndListen(\"(check-sat)\\n\");\n\t\t\t//smtConfig.log.logDiag(\"HEARD: \" + s);  // FIXME - detect errors - parseResponse?\n\t\t\t\n\t\t\tif (solverProcess.isRunning(false)) {\n\t\t\t\tif (s.contains(\"unsat\")) res = smtConfig.responseFactory.unsat();\n\t\t\t\telse if (s.contains(\"sat\")) res = smtConfig.responseFactory.sat();\n\t\t\t\telse res = smtConfig.responseFactory.unknown();\n\t\t\t} else {\n\t\t\t\tres = smtConfig.responseFactory.error(\"Solver has unexpectedly terminated\");\n\t\t\t}\n\n\t\t\tcheckSatStatus = res;\n\t\t} catch (IOException e) {\n\t\t\tres = smtConfig.responseFactory.error(\"Failed to check-sat\");\n\t\t}\n\t\treturn res;\n\t}\n\t\n\t@Override\n\tpublic IResponse reset() {\n\t\tlogicSet = false;\n\t    return sendCommand(\"(reset)\");\n\t}\n\n\t@Override\n\tpublic IResponse reset_assertions() {\n\t    return sendCommand(\"(reset-assertions)\");\n\t}\n\n\t@Override\n\tpublic IResponse pop(int number) {\n\t\tif (!logicSet) {\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a pop command is issued\");\n\t\t}\n\t\tif (number \u003c 0) throw new SMT.InternalException(\"Internal bug: A pop command called with a negative argument: \" + number);\n\t\tif (number \u003e pushesDepth) return smtConfig.responseFactory.error(\"The argument to a pop command is too large: \" + number + \" vs. a maximum of \" + (pushesDepth));\n\t\tif (number == 0) return  successOrEmpty(smtConfig);\n\t\ttry {\n\t\t\tcheckSatStatus = null;\n\t\t\tpushesDepth -= number;\n\t\t\treturn parseResponse(solverProcess.sendAndListen(\"(pop \",Integer.toString(number),\")\\n\"));\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse push(int number) {\n\t\tif (!logicSet) {\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a push command is issued\");\n\t\t}\n\t\tif (number \u003c 0) throw new SMT.InternalException(\"Internal bug: A push command called with a negative argument: \" + number);\n\t\tcheckSatStatus = null;\n\t\tif (number == 0) return smtConfig.responseFactory.success();\n\t\ttry {\n\t\t\tpushesDepth += number;\n\t\t\tIResponse r = parseResponse(solverProcess.sendAndListen(\"(push \",Integer.toString(number),\")\\n\"));\n\t\t\t// FIXME - actually only see this problem on Linux\n\t\t\tif (r.isError() \u0026\u0026 !isWindows) return successOrEmpty(smtConfig);\n\t\t\treturn r;\n\t\t} catch (Exception e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse set_logic(String logicName, /*@Nullable*/ IPos pos) {\n\t\t// FIXME - discriminate among logics\n\t\t\n\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"#set-logic \" + logicName);\n\t\tif (logicSet) {\n\t\t\tif (!smtConfig.relax) return smtConfig.responseFactory.error(\"Logic is already set\");\n\t\t\tpop(pushesDepth);\n\t\t}\n\t\tpushesDepth++;\n\t\tlogicSet = true;\n\t\tif (logicName.equals(\"ALL\")) {\n\t\t\treturn smtConfig.responseFactory.success();\n\t\t} else try {\n\t\t\treturn parseResponse(solverProcess.sendAndListen(\"(set-logic \",logicName,\")\\n\"));\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e,pos);\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse set_option(IKeyword key, IAttributeValue value) {\n\t\tString option = key.value();\n\t\tif (Utils.PRINT_SUCCESS.equals(option)) {\n\t\t\tif (!(Utils.TRUE.equals(value) || Utils.FALSE.equals(value))) {\n\t\t\t\treturn smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be 'true' or 'false'\");\n\t\t\t}\n\t\t}\n\t\tif (logicSet \u0026\u0026 (Utils.INTERACTIVE_MODE.equals(option)|| Utils.PRODUCE_ASSERTIONS.equals(option))) {\n\t\t\treturn smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be set before the set-logic command\");\n\t\t}\n\t\tif (Utils.PRODUCE_ASSIGNMENTS.equals(option) || \n\t\t\t\tUtils.PRODUCE_PROOFS.equals(option) ||\n\t\t\t\tUtils.PRODUCE_UNSAT_CORES.equals(option)) {\n\t\t\tif (logicSet) return smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be set before the set-logic command\");\n\t\t\treturn smtConfig.responseFactory.unsupported();\n\t\t}\n\t\tif (Utils.PRODUCE_MODELS.equals(option)) {\n\t\t\tif (logicSet) return smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be set before the set-logic command\");\n\t\t}\n\t\tif (Utils.VERBOSITY.equals(option)) {\n\t\t\tIAttributeValue v = options.get(option);\n\t\t\tsmtConfig.verbose = (v instanceof INumeral) ? ((INumeral)v).intValue() : 0;\n\t\t} else if (Utils.DIAGNOSTIC_OUTPUT_CHANNEL.equals(option)) {\n\t\t\t// Actually, v should never be anything but IStringLiteral - that should\n\t\t\t// be checked during parsing\n\t\t\tString name = (value instanceof IStringLiteral)? ((IStringLiteral)value).value() : \"stderr\";\n\t\t\tif (name.equals(\"stdout\")) {\n\t\t\t\tsmtConfig.log.diag = System.out;\n\t\t\t} else if (name.equals(\"stderr\")) {\n\t\t\t\tsmtConfig.log.diag = System.err;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tFileOutputStream f = new FileOutputStream(name,true); // true -\u003e append\n\t\t\t\t\tsmtConfig.log.diag = new PrintStream(f);\n\t\t\t\t} catch (java.io.IOException e) {\n\t\t\t\t\treturn smtConfig.responseFactory.error(\"Failed to open or write to the diagnostic output \" + e.getMessage(),value.pos());\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Utils.REGULAR_OUTPUT_CHANNEL.equals(option)) {\n\t\t\t// Actually, v should never be anything but IStringLiteral - that should\n\t\t\t// be checked during parsing\n\t\t\tString name = (value instanceof IStringLiteral)?((IStringLiteral)value).value() : \"stdout\";\n\t\t\tif (name.equals(\"stdout\")) {\n\t\t\t\tsmtConfig.log.out = System.out;\n\t\t\t} else if (name.equals(\"stderr\")) {\n\t\t\t\tsmtConfig.log.out = System.err;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tFileOutputStream f = new FileOutputStream(name,true); // append\n\t\t\t\t\tsmtConfig.log.out = new PrintStream(f);\n\t\t\t\t} catch (java.io.IOException e) {\n\t\t\t\t\treturn smtConfig.responseFactory.error(\"Failed to open or write to the regular output \" + e.getMessage(),value.pos());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Save the options on our side as well\n\t\toptions.put(Utils.INTERACTIVE_MODE.equals(option) \u0026\u0026 !smtConfig.isVersion(SMTLIB.V20) ? Utils.PRODUCE_ASSERTIONS : option,value);\n\t\tIResponse r = checkPrintSuccess(smtConfig,key,value);\n\t\tif (r != null) return r;\n\n\t\ttry {\n\t\t\tsolverProcess.sendAndListen(\"(set-option \",option,\" \",value.toString(),\")\\n\");// FIXME - detect errors\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t\t\n\t\treturn successOrEmpty(smtConfig);\n\t}\n\n\t@Override\n\tpublic IResponse get_option(IKeyword key) { // FIXME - use the solver?\n\t\tString option = key.value();\n\t\tIAttributeValue value = options.get(Utils.INTERACTIVE_MODE.equals(option) \u0026\u0026 !smtConfig.isVersion(SMTLIB.V20)? Utils.PRODUCE_ASSERTIONS : option);\n\t\tif (value == null) return smtConfig.responseFactory.unsupported();\n\t\treturn value;\n\t}\n\n\t@Override\n\tpublic IResponse get_info(IKeyword key) {\n\t\treturn sendCommand(\"(get-info \" + key + \")\");\n\t}\n\t\n\t@Override\n\tpublic IResponse set_info(IKeyword key, IAttributeValue value) {\n\t\tif (Utils.infoKeywords.contains(key)) {\n\t\t\treturn smtConfig.responseFactory.error(\"Setting the value of a pre-defined keyword is not permitted: \"+ \n\t\t\t\t\tsmtConfig.defaultPrinter.toString(key),key.pos());\n\t\t}\n\t\treturn sendCommand(new org.smtlib.command.C_set_info(key,value));\n\t}\n\n\n\t@Override\n\tpublic IResponse declare_fun(Ideclare_fun cmd) {\n\t\tif (!logicSet) {\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a declare-fun command is issued\");\n\t\t}\n\t\ttry {\n\t\t\tcheckSatStatus = null;\n\t\t\treturn parseResponse(solverProcess.sendAndListen(translate(cmd),\"\\n\"));\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse define_fun(Idefine_fun cmd) {\n\t\tif (!logicSet) {\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a define-fun command is issued\");\n\t\t}\n\t\ttry {\n\t\t\tcheckSatStatus = null;\n\t\t\treturn parseResponse(solverProcess.sendAndListen(translate(cmd),\"\\n\"));\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse declare_sort(Ideclare_sort cmd) {\n\t\tif (!logicSet) {\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a declare-sort command is issued\");\n\t\t}\n\t\ttry {\n\t\t\tcheckSatStatus = null;\n\t\t\treturn parseResponse(solverProcess.sendAndListen(translate(cmd),\"\\n\"));\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse define_sort(Idefine_sort cmd) {\n\t\tif (!logicSet) {\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a define-sort command is issued\");\n\t\t}\n\t\ttry {\n\t\t\tcheckSatStatus = null;\n\t\t\treturn parseResponse(solverProcess.sendAndListen(translate(cmd),\"\\n\"));\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\t\n\t@Override \n\tpublic IResponse get_proof() {\n\t\tif (!Utils.TRUE.equals(get_option(smtConfig.exprFactory.keyword(Utils.PRODUCE_PROOFS)))) {\n\t\t\treturn smtConfig.responseFactory.error(\"The get-proof command is only valid if :produce-proofs has been enabled\");\n\t\t}\n\t\tif (checkSatStatus != smtConfig.responseFactory.unsat()) {\n\t\t\treturn smtConfig.responseFactory.error(\"The get-proof command is only valid immediately after check-sat returned unsat\");\n\t\t}\n\t\ttry {\n\t\t\treturn parseResponse(solverProcess.sendAndListen(\"(get-proof)\\n\"));\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\n\t@Override \n\tpublic IResponse get_unsat_core() {\n\t\tif (!Utils.TRUE.equals(get_option(smtConfig.exprFactory.keyword(Utils.PRODUCE_UNSAT_CORES)))) {\n\t\t\treturn smtConfig.responseFactory.error(\"The get-unsat-core command is only valid if :produce-unsat-cores has been enabled\");\n\t\t}\n\t\tif (checkSatStatus != smtConfig.responseFactory.unsat()) {\n\t\t\treturn smtConfig.responseFactory.error(\"The get-unsat-core command is only valid immediately after check-sat returned unsat\");\n\t\t}\n\t\ttry {\n\t\t\treturn parseResponse(solverProcess.sendAndListen(\"(get-unsat-core)\\n\"));\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\n\t@Override \n\tpublic IResponse get_assignment() {\n\t\t// FIXME - do we really want to call get-option here? it involves going to the solver?\n\t\tif (!Utils.TRUE.equals(get_option(smtConfig.exprFactory.keyword(Utils.PRODUCE_ASSIGNMENTS)))) {\n\t\t\treturn smtConfig.responseFactory.error(\"The get-assignment command is only valid if :produce-assignments has been enabled\");\n\t\t}\n\t\tif (checkSatStatus != smtConfig.responseFactory.sat() \u0026\u0026 checkSatStatus != smtConfig.responseFactory.unknown()) {\n\t\t\treturn smtConfig.responseFactory.error(\"The get-assignment command is only valid immediately after check-sat returned sat or unknown\");\n\t\t}\n\t\ttry {\n\t\t\treturn parseResponse(solverProcess.sendAndListen(\"(get-assignment)\\n\"));\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\n\t@Override \n\tpublic IResponse get_value(IExpr... terms) {\n\t\t// FIXME - do we really want to call get-option here? it involves going to the solver?\n\t\tif (!Utils.TRUE.equals(get_option(smtConfig.exprFactory.keyword(Utils.PRODUCE_MODELS)))) {\n\t\t\treturn smtConfig.responseFactory.error(\"The get-value command is only valid if :produce-models has been enabled\");\n\t\t}\n\t\tif (!smtConfig.responseFactory.sat().equals(checkSatStatus) \u0026\u0026 !smtConfig.responseFactory.unknown().equals(checkSatStatus)) {\n\t\t\treturn smtConfig.responseFactory.error(\"A get-value command is valid only after check-sat has returned sat or unknown\");\n\t\t}\n\t\ttry {\n\t\t\tsolverProcess.sendNoListen(\"(get-value (\");\n\t\t\tfor (IExpr e: terms) {\n\t\t\t\tsolverProcess.sendNoListen(\" \",translate(e));\n\t\t\t}\n\t\t\tString r = solverProcess.sendAndListen(\"))\\n\");\n\t\t\tIResponse response = parseResponse(r);\n//\t\t\tif (response instanceof ISeq) {\n//\t\t\t\tList\u003cISexpr\u003e valueslist = new LinkedList\u003cISexpr\u003e();\n//\t\t\t\tIterator\u003cISexpr\u003e iter = ((ISeq)response).sexprs().iterator();\n//\t\t\t\tfor (IExpr e: terms) {\n//\t\t\t\t\tif (!iter.hasNext()) break;\n//\t\t\t\t\tList\u003cISexpr\u003e values = new LinkedList\u003cISexpr\u003e();\n//\t\t\t\t\tvalues.add(new Sexpr.Expr(e));\n//\t\t\t\t\tvalues.add(iter.next());\n//\t\t\t\t\tvalueslist.add(new Sexpr.Seq(values));\n//\t\t\t\t}\t\n//\t\t\t\treturn new Sexpr.Seq(valueslist);\n//\t\t\t}\n\t\t\treturn response;\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\n\tpublic class Translator extends Printer { //extends IVisitor.NullVisitor\u003cString\u003e {\n\t\t\n\t\tpublic Translator(Writer w) { super(w); }\n\n//\t\t@Override\n//\t\tpublic String visit(IDecimal e) throws IVisitor.VisitorException {\n//\t\t\treturn translateSMT(e);\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IStringLiteral e) throws IVisitor.VisitorException {\n//\t\t\tthrow new VisitorException(\"The Z3 solver cannot handle string literals\",e.pos());\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(INumeral e) throws IVisitor.VisitorException {\n//\t\t\treturn e.value().toString();\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IBinaryLiteral e) throws IVisitor.VisitorException {\n//\t\t\treturn \"#b\" + e.value();\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IHexLiteral e) throws IVisitor.VisitorException {\n//\t\t\treturn \"#x\" + e.value();\n//\t\t}\n\n\t\t@Override\n\t\tpublic Void visit(IFcnExpr e) throws IVisitor.VisitorException {\n\t\t\t// Only - for \u003e=2 args is not correctly done, but we can't delegate to translateSMT because it might be a sub-expression.\n\t\t\tIterator\u003cIExpr\u003e iter = e.args().iterator();\n\t\t\tif (!iter.hasNext()) throw new VisitorException(\"Did not expect an empty argument list\",e.pos());\n\t\t\tIQualifiedIdentifier fcn = e.head();\n\t\t\tint length = e.args().size();\n\t\t\tif (length \u003e 2 \u0026\u0026 (fcn instanceof IIdentifier) \u0026\u0026 fcn.toString().equals(\"-\")) {\n\t\t\t\tleftassoc(fcn.toString(),length,iter);\n\t\t\t} else {\n\t\t\t\tsuper.visit(e);\n\t\t\t}\n\t\t\treturn null;\n//\t\t\tString fcnname = fcn.accept(this);\n//\t\t\tStringBuilder sb = new StringBuilder();\n//\t\t\tint length = e.args().size();\n//\t\t\tif (length \u003e 2 \u0026\u0026 (fcnname.equals(\"=\") || fcnname.equals(\"\u003c\") || fcnname.equals(\"\u003e\") || fcnname.equals(\"\u003c=\") || fcnname.equals(\"\u003e=\"))) {\n//\t\t\t\t// chainable\n//\t\t\t\treturn chainable(fcnname,iter);\n//\t\t\t} else if (fcnname.equals(\"xor\")) {\n//\t\t\t\t// left-associative operators that need grouping\n//\t\t\t\treturn leftassoc(fcnname,length,iter);\n//\t\t\t} else if (length \u003e 1 \u0026\u0026 fcnname.equals(\"-\")) {\n//\t\t\t\t// left-associative operators that need grouping\n//\t\t\t\treturn leftassoc(fcnname,length,iter);\n//\t\t\t} else if (fcnname.equals(\"=\u003e\")) {\n//\t\t\t\t// right-associative operators that need grouping\n//\t\t\t\tif (!iter.hasNext()) {\n//\t\t\t\t\tthrow new VisitorException(\"=\u003e operation without arguments\",e.pos());\n//\t\t\t\t}\n//\t\t\t\treturn rightassoc(fcnname,iter);\n//\t\t\t} else {\n//\t\t\t\t// no associativity \n//\t\t\t\tsb.append(\"(\");\n//\t\t\t\tsb.append(fcnname);\n//\t\t\t\twhile (iter.hasNext()) {\n//\t\t\t\t\tsb.append(\" \");\n//\t\t\t\t\tsb.append(iter.next().accept(this));\n//\t\t\t\t}\n//\t\t\t\tsb.append(\")\");\n//\t\t\t\treturn sb.toString();\n//\t\t\t}\n\t\t}\n\n\t\t//@ requires iter.hasNext();\n\t\t//@ requires length \u003e 0;\n\t\tprotected \u003cT extends IExpr\u003e void leftassoc(String fcnname, int length, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\n\t\t\tif (length == 1) {\n\t\t\t\titer.next().accept(this);\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tw.append(\"(\");\n\t\t\t\t\tw.append(fcnname);\n\t\t\t\t\tw.append(\" \");\n\t\t\t\t\tleftassoc(fcnname,length-1,iter);\n\t\t\t\t\tw.append(\" \");\n\t\t\t\t\titer.next().accept(this);\n\t\t\t\t\tw.append(\")\");\n\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\tthrow new IVisitor.VisitorException(ex,null); // FIXME - null ?\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//@ requires iter.hasNext();\n\t\tprotected \u003cT extends IExpr\u003e void rightassoc(String fcnname, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\n\t\t\tT n = iter.next();\n\t\t\tif (!iter.hasNext()) {\n\t\t\t\tn.accept(this);\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tw.append(\"(\");\n\t\t\t\t\tw.append(fcnname);\n\t\t\t\t\tw.append(\" \");\n\t\t\t\t\tn.accept(this);\n\t\t\t\t\tw.append(\" \");\n\t\t\t\t\trightassoc(fcnname,iter);\n\t\t\t\t\tw.append(\")\");\n\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\tthrow new IVisitor.VisitorException(ex,null); // FIXME - null ?\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\t//@ requires iter.hasNext();\n\t\t//@ requires length \u003e 0;\n\t\tprotected \u003cT extends IAccept\u003e void chainable(String fcnname, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\n\t\t\ttry {\n\t\t\t\tw.append(\"(and \");\n\t\t\t\tT left = iter.next();\n\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\tw.append(\"(\");\n\t\t\t\t\tw.append(fcnname);\n\t\t\t\t\tw.append(\" \");\n\t\t\t\t\tleft.accept(this);\n\t\t\t\t\tw.append(\" \");\n\t\t\t\t\t(left=iter.next()).accept(this);\n\t\t\t\t\tw.append(\")\");\n\t\t\t\t}\n\t\t\t\tw.append(\")\");\n\t\t\t} catch (IOException ex) {\n\t\t\t\tthrow new IVisitor.VisitorException(ex,null); // FIXME - null ?\n\t\t\t}\n\t\t}\n\n\n//\t\t@Override\n//\t\tpublic String visit(ISymbol e) throws IVisitor.VisitorException {\n//\t\t\treturn translateSMT(e);\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IKeyword e) throws IVisitor.VisitorException {\n//\t\t\tthrow new VisitorException(\"Did not expect a Keyword in an expression to be translated\",e.pos());\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IError e) throws IVisitor.VisitorException {\n//\t\t\tthrow new VisitorException(\"Did not expect a Error token in an expression to be translated\", e.pos());\n//\t\t}\n//\n//\t\tprivate final String zeros = \"00000000000000000000000000000000000000000000000000\";\n//\t\t@Override\n//\t\tpublic String visit(IParameterizedIdentifier e) throws IVisitor.VisitorException {\n//\t\t\treturn translateSMT(e);\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IAsIdentifier e) throws IVisitor.VisitorException {\n//\t\t\treturn translateSMT(e);\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IForall e) throws IVisitor.VisitorException {\n//\t\t\treturn translateSMT(e);\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IExists e) throws IVisitor.VisitorException {\n//\t\t\treturn translateSMT(e);\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(ILet e) throws IVisitor.VisitorException {\n//\t\t\treturn translateSMT(e);\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IAttribute\u003c?\u003e e) throws IVisitor.VisitorException {\n//\t\t\tthrow new UnsupportedOperationException(\"visit-IAttribute\");\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IAttributedExpr e) throws IVisitor.VisitorException {\n//\t\t\treturn translateSMT(e);\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IDeclaration e) throws IVisitor.VisitorException {\n//\t\t\tthrow new UnsupportedOperationException(\"visit-IDeclaration\");\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(ISort.IFamily s) throws IVisitor.VisitorException {\n//\t\t\treturn s.identifier().accept(this);\n//\t\t}\n//\t\t\n//\t\t@Override\n//\t\tpublic String visit(ISort.IAbbreviation s) throws IVisitor.VisitorException {\n//\t\t\tthrow new UnsupportedOperationException(\"visit-ISort.IAbbreviation\");\n//\t\t}\n//\t\t\n//\t\t@Override\n//\t\tpublic String visit(ISort.IApplication s) throws IVisitor.VisitorException {\n//\t\t\treturn translateSMT(s);\n//\t\t}\n//\t\t\n//\t\t@Override\n//\t\tpublic String visit(ISort.IFcnSort s) throws IVisitor.VisitorException {\n//\t\t\tthrow new UnsupportedOperationException(\"visit-ISort.IFcnSort\");\n//\t\t}\n//\t\t\n//\t\t@Override\n//\t\tpublic String visit(ISort.IParameter s) throws IVisitor.VisitorException {\n//\t\t\tthrow new UnsupportedOperationException(\"visit-ISort.IParameter\");\n//\t\t}\n//\t\t\n//\t\t@Override\n//\t\tpublic String visit(ICommand command) throws IVisitor.VisitorException {\n//\t\t\tif (command instanceof ICommand.Iassert) {\n//\t\t\t\treturn \"(assert \" + ((ICommand.Iassert)command).expr().accept(this) + \")\";\n//\t\t\t} else {\n//\t\t\t\treturn translateSMT(command);\n//\t\t\t}\n//\t\t}\n\t}\n}\n",
        "name": "Solver_z3_4_3.java",
        "path": "SMT/src/org/smtlib/solvers/Solver_z3_4_3.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMT/src/org/smtlib/solvers/Solver_z3_4_3.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 735,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();"
        },
        {
          "limitHit": false,
          "lineNumber": 736,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires length \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 755,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();"
        },
        {
          "limitHit": false,
          "lineNumber": 776,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();"
        },
        {
          "limitHit": false,
          "lineNumber": 777,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires length \u003e 0;"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\n * This file is part of the SMT project.\n * Copyright 2010 David R. Cok\n * Created August 2010\n */\npackage org.smtlib.solvers;\n\n// Items not implemented:\n//   attributed expressions\n//   get-values get-assignment get-proof get-unsat-core\n//   some error detection and handling\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.smtlib.*;\nimport org.smtlib.ICommand.Ideclare_fun;\nimport org.smtlib.ICommand.Ideclare_sort;\nimport org.smtlib.ICommand.Idefine_fun;\nimport org.smtlib.ICommand.Idefine_sort;\nimport org.smtlib.IExpr.IAttribute;\nimport org.smtlib.IExpr.IFcnExpr;\nimport org.smtlib.IExpr.IIdentifier;\nimport org.smtlib.IExpr.IKeyword;\nimport org.smtlib.IExpr.INumeral;\nimport org.smtlib.IExpr.IQualifiedIdentifier;\nimport org.smtlib.IExpr.IStringLiteral;\nimport org.smtlib.IParser.ParserException;\nimport org.smtlib.SMT.Configuration.SMTLIB;\nimport org.smtlib.impl.Pos;\nimport org.smtlib.sexpr.Printer;\n\n/** This class is an adapter that takes the SMT-LIB ASTs and translates them into Z3 commands */\npublic class Solver_z3_4_5 extends AbstractSolver implements ISolver {\n\t\n\tprotected String NAME_VALUE = \"z3-4.3\"; // FIXME - should get rid of this\n\t\n\n\tprotected int linesOffset = 0;\n\t\n\t/** A reference to the SMT configuration */\n\tprotected SMT.Configuration smtConfig;\n\n\t/** A reference to the SMT configuration */\n\tpublic SMT.Configuration smt() { return smtConfig; }\n\t\n\t/** The command-line arguments for launching the Z3 solver */\n\tprotected String cmds[];\n\tprotected String cmds_win[] = new String[]{ \"\", \"/smt2\",\"/in\",\"SMTLIB2_COMPLIANT=true\"}; \n\tprotected String cmds_mac[] = new String[]{ \"\", \"-smt2\",\"-in\",\"SMTLIB2_COMPLIANT=true\"}; \n\tprotected String cmds_unix[] = new String[]{ \"\", \"-smt2\",\"-in\"}; \n\n\t/** The object that interacts with external processes */\n\tprotected SolverProcess solverProcess;\n\t\n\t/** The parser that parses responses from the solver */\n\tprotected org.smtlib.sexpr.Parser responseParser;\n\t\n\t/** Set to true once a set-logic command has been executed */\n\tprotected boolean logicSet = false;\n\t\n\t/** The checkSatStatus returned by check-sat, if sufficiently recent, otherwise null */\n\tprotected /*@Nullable*/ IResponse checkSatStatus = null;\n\t\n\t@Override\n\tpublic /*@Nullable*/IResponse checkSatStatus() { return checkSatStatus; }\n\n\t/** The number of pushes less the number of pops so far */\n\tprotected int pushesDepth = 0;\n\t\n\t/** Map that keeps current values of options */\n\tprotected Map\u003cString,IAttributeValue\u003e options = new HashMap\u003cString,IAttributeValue\u003e();\n\t\n\t/** Creates an instance of the Z3 solver */\n\tpublic Solver_z3_4_5(SMT.Configuration smtConfig, /*@NonNull*/ String executable) {\n\t\tthis.smtConfig = smtConfig;\n\t\tif (isWindows) {\n\t\t\tcmds = cmds_win;\n\t\t} else if (isMac) {\n\t\t\tcmds = cmds_mac;\n\t\t} else {\n\t\t\tcmds = cmds_unix;\n\t\t}\n\t\tcmds[0] = executable;\n\t\toptions.putAll(smtConfig.utils.defaults);\n\t\tdouble timeout = smtConfig.timeout;\n\t\tif (timeout \u003e 0) {\n\t\t\tList\u003cString\u003e args = new java.util.ArrayList\u003cString\u003e(cmds.length+1);\n\t\t\targs.addAll(Arrays.asList(cmds));\n\t\t\tif (isWindows) args.add(\"/t:\" + Integer.toString((int)timeout));\n\t\t\telse           args.add(\"-t:\" + Integer.toString((int)timeout));\n\t\t\tcmds = args.toArray(new String[args.size()]);\n\t\t}\n\t\tsolverProcess = new SolverProcess(cmds,\"\\n\",smtConfig.logfile);\n\t\tresponseParser = new org.smtlib.sexpr.Parser(smt(),new Pos.Source(\"\",null));\n\t}\n\n\t/** Creates an instance of the Z3 solver */\n\tpublic Solver_z3_4_5(SMT.Configuration smtConfig, /*@NonNull*/ String[] command) {\n\t\tthis.smtConfig = smtConfig;\n\t\tcmds = command;\n\t\toptions.putAll(smtConfig.utils.defaults);\n\t\tdouble timeout = smtConfig.timeout;\n\t\tif (timeout \u003e 0) {\n\t\t\tList\u003cString\u003e args = new java.util.ArrayList\u003cString\u003e(cmds.length+1);\n\t\t\targs.addAll(Arrays.asList(cmds));\n\t\t\tif (isWindows) args.add(\"/t:\" + Integer.toString((int)timeout));\n\t\t\telse           args.add(\"-t:\" + Integer.toString((int)timeout));\n\t\t\tcmds = args.toArray(new String[args.size()]);\n\t\t}\n\t\tsolverProcess = new SolverProcess(cmds,\"\\n\",smtConfig.logfile);\n\t\tresponseParser = new org.smtlib.sexpr.Parser(smt(),new Pos.Source(\"\",null));\n\t}\n\n\tpublic IResponse sendCommand(ICommand cmd) {\n\t\tString translatedCmd = null;\n\t\ttry {\n\t\t\ttranslatedCmd = translate(cmd);\n\t\t\treturn parseResponse(solverProcess.sendAndListen(translatedCmd,\"\\n\"));\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to solver: \" + translatedCmd + \" \" + e);\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to solver: \" + translatedCmd + \" \" + e);\n\t\t}\n\t}\n\t\n\tpublic IResponse sendCommand(String cmd) {\n\t\ttry {\n\t\t\treturn parseResponse(solverProcess.sendAndListen(cmd,\"\\n\"));\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to solver: \" + cmd + \" \" + e);\n\t\t}\n\t}\n\t\n\n\t@Override\n\tpublic IResponse start() {\n\t\ttry {\n\t\t\tsolverProcess.start(false);\n\t\t\t// FIXME - enable the following lines when the Z3 solver supports them\n//\t\t\tif (smtConfig.solverVerbosity \u003e 0) solverProcess.sendNoListen(\"(set-option :verbosity \",Integer.toString(smtConfig.solverVerbosity),\")\");\n//\t\t\tif (!smtConfig.batch) solverProcess.sendNoListen(\"(set-option :interactive-mode true)\"); // FIXME - not sure we can do this - we'll lose the feedback\n\t\t\t// Can't turn off printing success, or we get no feedback\n\t\t\tsolverProcess.sendAndListen(\"(set-option :print-success true)\\n\"); // Z3 4.3.0 needs this because it mistakenly has the default for :print-success as false\n\t\t\tlinesOffset ++; \n\t\t\t//if (smtConfig.nosuccess) solverProcess.sendAndListen(\"(set-option :print-success false)\");\n\t\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Started \"+NAME_VALUE+\" \");\n\t\t\treturn smtConfig.responseFactory.success();\n\t\t} catch (Exception e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to start process \" + cmds[0] + \" : \" + e.getMessage());\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic IResponse exit() {\n\t\ttry {\n\t\t\tsolverProcess.sendAndListen(\"(exit)\\n\");\n\t\t\tsolverProcess.exit();\n\t\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Ended Z3 \");\n\t\t\treturn successOrEmpty(smtConfig);\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic void forceExit() {\n\t\tif (solverProcess != null) solverProcess.exit();\n\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Ended Z3 forcibly\");\n\t}\n\n\n\n\t@Override \n\tpublic void comment(String comment) {\n\t\ttry {\n\t\t\tsolverProcess.sendNoListen(comment);\n\t\t} catch (IOException e) {\n\t\t\t// FIXME;\n\t\t}\n\t}\n\n\t/** Translates an S-expression into Z3 syntax */\n\tprotected String translate(IAccept sexpr) throws IVisitor.VisitorException {\n\t\t// The z3 solver uses the standard S-expression concrete syntax, but not quite\n\t\t// so we have to use our own translator\n\t\tStringWriter sw = new StringWriter();\n\t\tsexpr.accept(new Translator(sw));\n\t\treturn sw.toString();\n\t}\n\t\n\t/** Translates an S-expression into standard SMT syntax */\n\tprotected String translateSMT(IAccept sexpr) throws IVisitor.VisitorException {\n\t\t// The z3 solver uses the standard S-expression concrete syntax, but not quite\n\t\tStringWriter sw = new StringWriter();\n\t\torg.smtlib.sexpr.Printer.write(sw,sexpr);\n\t\treturn sw.toString();\n\t}\n\t\n\tprotected IResponse parseResponse(String response) {\n\t\ttry {\n\t\t\tif (response.startsWith(\"stderr\")) response = response.replace(\"stderr\", \"\\\"stderr\\\"\");\n\t\t\telse if (response.startsWith(\"stdout\")) response = response.replace(\"stdout\", \"\\\"stdout\\\"\");\n\t\t\tPattern oldbv = Pattern.compile(\"bv([0-9]+)\\\\[([0-9]+)\\\\]\");\n\t\t\tMatcher mm = oldbv.matcher(response);\n\t\t\twhile (mm.find()) {\n\t\t\t\tlong val = Long.parseLong(mm.group(1));\n\t\t\t\tint base = Integer.parseInt(mm.group(2));\n\t\t\t\tString bits = \"\";\n\t\t\t\tfor (int i=0; i\u003cbase; i++) { bits = ((val\u00261)==0 ? \"0\" : \"1\") + bits; val = val \u003e\u003e\u003e 1; }\n\t\t\t\tresponse = response.substring(0,mm.start()) + \"#b\" + bits + response.substring(mm.end(),response.length());\n\t\t\t\tmm = oldbv.matcher(response);\n\t\t\t}\n\t\t\tif (isMac \u0026\u0026 response.startsWith(\"success\")) return smtConfig.responseFactory.success(); // IFXME - this is just to avoid a problem with the Mac Z3 implementation\n\t\t\tif (response.contains(\"error\")  \u0026\u0026 !response.contains(\":error\")) {\n\t\t\t\t// Z3 returns an s-expr (always?)\n\t\t\t\t// FIXME - (1) the {Print} also needs {Space}; (2) err_getValueTypes.tst returns a non-error s-expr and then an error s-expr - this fails for that case\n\t\t\t\t//Pattern p = Pattern.compile(\"\\\\p{Space}*\\\\(\\\\p{Blank}*error\\\\p{Blank}+\\\"(([\\\\p{Space}\\\\p{Print}^[\\\\\\\"\\\\\\\\]]|\\\\\\\\\\\")*)\\\"\\\\p{Blank}*\\\\)\\\\p{Space}*\");\n\t\t\t\tPattern p = Pattern.compile(\"\\\\p{Space}*\\\\(\\\\p{Blank}*error\\\\p{Blank}+\\\"(([\\\\p{Print}\\\\p{Space}\u0026\u0026[^\\\"\\\\\\\\]]|\\\\\\\\\\\")*)\\\"\\\\p{Blank}*\\\\)\");\n\t\t\t\tMatcher m = p.matcher(response);\n\t\t\t\tString concat = \"\";\n\t\t\t\twhile (m.lookingAt()) {\n\t\t\t\t\tif (!concat.isEmpty()) concat = concat + \"; \";\n\t\t\t\t\tString matched = m.group(1);\n\t\t\t\t\tString prefix = \"line \";\n\t\t\t\t\tint offset = prefix.length();\n\t\t\t\t\tif (matched.startsWith(prefix)) {\n\t\t\t\t\t\tint k = matched.indexOf(' ',offset);\n\t\t\t\t\t\tString number = matched.substring(offset, k);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tint n = Integer.parseInt(number);\n\t\t\t\t\t\t\tmatched = prefix + (n-linesOffset) + matched.substring(k);\n\t\t\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t\t\t// Just continue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconcat = concat + matched;\n\t\t\t\t\tm.region(m.end(0),m.regionEnd());\n\t\t\t\t}\n\t\t\t\tif (!concat.isEmpty()) response = concat;\n\t\t\t\treturn smtConfig.responseFactory.error(response);\n\t\t\t}\n\t\t\tresponseParser = new org.smtlib.sexpr.Parser(smt(),new Pos.Source(response,null));\n\t\t\treturn responseParser.parseResponse(response);\n\t\t} catch (ParserException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"ParserException while parsing response: \" + response + \" \" + e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse assertExpr(IExpr sexpr) {\n\t\tIResponse response;\n\t\tif (pushesDepth \u003c= 0) {\n\t\t\treturn smtConfig.responseFactory.error(\"All assertion sets have been popped from the stack\");\n\t\t}\n\t\tif (!logicSet) {\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before an assert command is issued\");\n\t\t}\n\t\ttry {\n\t\t\tString s = solverProcess.sendAndListen(\"(assert \",translate(sexpr),\")\\n\");\n\t\t\tresponse = parseResponse(s);\n\t\t\tcheckSatStatus = null;\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to assert expression: \" + e + \" \" + sexpr);\n\t\t} catch (Exception e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to assert expression: \" + e + \" \" + sexpr);\n\t\t}\n\t\treturn response;\n\t}\n\t\n\t@Override\n\tpublic IResponse get_assertions() {\n\t\tif (!logicSet) {\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a get-assertions command is issued\");\n\t\t}\n\t\t// FIXME - do we really want to call get-option here? it involves going to the solver?\n\t\tif (!smtConfig.relax \u0026\u0026 !Utils.TRUE.equals(get_option(smtConfig.exprFactory.keyword(Utils.PRODUCE_ASSERTIONS)))) {\n\t\t\treturn smtConfig.responseFactory.error(\"The get-assertions command is only valid if :interactive-mode has been enabled\");\n\t\t}\n\t\ttry {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tString s;\n\t\t\tint parens = 0;\n\t\t\tdo {\n\t\t\t\ts = solverProcess.sendAndListen(\"(get-assertions)\\n\");\n\t\t\t\tint p = -1;\n\t\t\t\twhile (( p = s.indexOf('(',p+1)) != -1) parens++;\n\t\t\t\tp = -1;\n\t\t\t\twhile (( p = s.indexOf(')',p+1)) != -1) parens--;\n\t\t\t\tsb.append(s.replace('\\n',' ').replace(\"\\r\",\"\"));\n\t\t\t} while (parens \u003e 0);\n\t\t\ts = sb.toString();\n\t\t\torg.smtlib.sexpr.Parser p = new org.smtlib.sexpr.Parser(smtConfig,new org.smtlib.impl.Pos.Source(s,null));\n\t\t\tList\u003cIExpr\u003e exprs = new LinkedList\u003cIExpr\u003e();\n\t\t\ttry {\n\t\t\t\tif (p.isLP()) {\n\t\t\t\t\tp.parseLP();\n\t\t\t\t\twhile (!p.isRP() \u0026\u0026 !p.isEOD()) {\n\t\t\t\t\t\tIExpr e = p.parseExpr();\n\t\t\t\t\t\texprs.add(e);\n\t\t\t\t\t}\n\t\t\t\t\tif (p.isRP()) {\n\t\t\t\t\t\tp.parseRP();\n\t\t\t\t\t\tif (p.isEOD()) return smtConfig.responseFactory.get_assertions_response(exprs); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (Exception e ) {\n\t\t\t\t// continue - fall through\n\t\t\t}\n\t\t\treturn smtConfig.responseFactory.error(\"Unexpected output from the Z3 solver: \" + s);\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"IOException while reading Z3 reponse\");\n\t\t}\n\t}\n\t\n\n\n\t@Override\n\tpublic IResponse check_sat() {\n\t\tIResponse res;\n\t\ttry {\n\t\t\tif (!logicSet) {\n\t\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a check-sat command is issued\");\n\t\t\t}\n\t\t\tString s = solverProcess.sendAndListen(\"(check-sat)\\n\");\n\t\t\t//smtConfig.log.logDiag(\"HEARD: \" + s);  // FIXME - detect errors - parseResponse?\n\t\t\t\n\t\t\tif (solverProcess.isRunning(false)) {\n\t\t\t\tif (s.contains(\"unsat\")) res = smtConfig.responseFactory.unsat();\n\t\t\t\telse if (s.contains(\"sat\")) res = smtConfig.responseFactory.sat();\n\t\t\t\telse res = smtConfig.responseFactory.unknown();\n\t\t\t} else {\n\t\t\t\tres = smtConfig.responseFactory.error(\"Solver has unexpectedly terminated\");\n\t\t\t}\n\n\t\t\tcheckSatStatus = res;\n\t\t} catch (IOException e) {\n\t\t\tres = smtConfig.responseFactory.error(\"Failed to check-sat\");\n\t\t}\n\t\treturn res;\n\t}\n\t\n\t@Override\n\tpublic IResponse reset() {\n\t\tlogicSet = false;\n\t    return sendCommand(\"(reset)\");\n\t}\n\n\t@Override\n\tpublic IResponse reset_assertions() {\n\t\treturn smtConfig.responseFactory.unsupported();\n\t    //return sendCommand(\"(reset-assertions)\");\n\t}\n\n\t@Override\n\tpublic IResponse pop(int number) {\n\t\tif (!logicSet) {\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a pop command is issued\");\n\t\t}\n//\t\tif (number \u003c 0) throw new SMT.InternalException(\"Internal bug: A pop command called with a negative argument: \" + number);\n//\t\tif (number \u003e pushesDepth) return smtConfig.responseFactory.error(\"The argument to a pop command is too large: \" + number + \" vs. a maximum of \" + (pushesDepth));\n//\t\tif (number == 0) return  successOrEmpty(smtConfig);\n\t\ttry {\n\t\t\tcheckSatStatus = null;\n\t\t\tpushesDepth -= number;\n\t\t\treturn parseResponse(solverProcess.sendAndListen(\"(pop \",Integer.toString(number),\")\\n\"));\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse push(int number) {\n\t\tif (!logicSet) {\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a push command is issued\");\n\t\t}\n\t\tif (number \u003c 0) throw new SMT.InternalException(\"Internal bug: A push command called with a negative argument: \" + number);\n\t\tcheckSatStatus = null;\n\t\tif (number == 0) return smtConfig.responseFactory.success();\n\t\ttry {\n\t\t\tpushesDepth += number;\n\t\t\tIResponse r = parseResponse(solverProcess.sendAndListen(\"(push \",Integer.toString(number),\")\\n\"));\n\t\t\t// FIXME - actually only see this problem on Linux\n\t\t\tif (r.isError() \u0026\u0026 !isWindows) return successOrEmpty(smtConfig);\n\t\t\treturn r;\n\t\t} catch (Exception e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse set_logic(String logicName, /*@Nullable*/ IPos pos) {\n\t\t// FIXME - discrimninate among logics\n\t\t\n\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"#set-logic \" + logicName);\n\t\tif (logicSet) {\n\t\t\tif (!smtConfig.relax) return smtConfig.responseFactory.error(\"Logic is already set\");\n\t\t\tpop(pushesDepth);\n\t\t}\n\t\tpushesDepth++;\n\t\tlogicSet = true;\n\t\t// Z3 behaves differently if the ALL logic is actually set, as compared to not setting a logic.\n\t\tif (logicName.equals(\"ALL\")) {\n\t\t\treturn smtConfig.responseFactory.success();\n\t\t} else try {\n\t\t\treturn parseResponse(solverProcess.sendAndListen(\"(set-logic \",logicName,\")\\n\"));\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e,pos);\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse set_option(IKeyword key, IAttributeValue value) {\n\t\tString option = key.value();\n\t\tif (Utils.PRINT_SUCCESS.equals(option)) {\n\t\t\tif (!(Utils.TRUE.equals(value) || Utils.FALSE.equals(value))) {\n\t\t\t\treturn smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be 'true' or 'false'\");\n\t\t\t}\n\t\t}\n\t\tif (logicSet \u0026\u0026 (Utils.INTERACTIVE_MODE.equals(option)|| Utils.PRODUCE_ASSERTIONS.equals(option))) {\n\t\t\treturn smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be set before the set-logic command\");\n\t\t}\n\t\tif (Utils.PRODUCE_ASSIGNMENTS.equals(option) || \n\t\t\t\tUtils.PRODUCE_PROOFS.equals(option) ||\n\t\t\t\tUtils.PRODUCE_UNSAT_CORES.equals(option)) {\n\t\t\tif (logicSet) return smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be set before the set-logic command\");\n//\t\t\treturn smtConfig.responseFactory.unsupported();\n\t\t}\n\t\tif (Utils.PRODUCE_MODELS.equals(option)) {\n\t\t\tif (logicSet) return smtConfig.responseFactory.error(\"The value of the \" + option + \" option must be set before the set-logic command\");\n\t\t}\n\t\tif (Utils.VERBOSITY.equals(option)) {\n\t\t\tIAttributeValue v = options.get(option);\n\t\t\tsmtConfig.verbose = (v instanceof INumeral) ? ((INumeral)v).intValue() : 0;\n\t\t} else if (Utils.DIAGNOSTIC_OUTPUT_CHANNEL.equals(option)) {\n\t\t\t// Actually, v should never be anything but IStringLiteral - that should\n\t\t\t// be checked during parsing\n\t\t\tString name = (value instanceof IStringLiteral)? ((IStringLiteral)value).value() : \"stderr\";\n\t\t\tif (name.equals(\"stdout\")) {\n\t\t\t\tsmtConfig.log.diag = System.out;\n\t\t\t} else if (name.equals(\"stderr\")) {\n\t\t\t\tsmtConfig.log.diag = System.err;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tFileOutputStream f = new FileOutputStream(name,true); // true -\u003e append\n\t\t\t\t\tsmtConfig.log.diag = new PrintStream(f);\n\t\t\t\t} catch (java.io.IOException e) {\n\t\t\t\t\treturn smtConfig.responseFactory.error(\"Failed to open or write to the diagnostic output \" + e.getMessage(),value.pos());\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Utils.REGULAR_OUTPUT_CHANNEL.equals(option)) {\n\t\t\t// Actually, v should never be anything but IStringLiteral - that should\n\t\t\t// be checked during parsing\n\t\t\tString name = (value instanceof IStringLiteral)?((IStringLiteral)value).value() : \"stdout\";\n\t\t\tif (name.equals(\"stdout\")) {\n\t\t\t\tsmtConfig.log.out = System.out;\n\t\t\t} else if (name.equals(\"stderr\")) {\n\t\t\t\tsmtConfig.log.out = System.err;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tFileOutputStream f = new FileOutputStream(name,true); // append\n\t\t\t\t\tsmtConfig.log.out = new PrintStream(f);\n\t\t\t\t} catch (java.io.IOException e) {\n\t\t\t\t\treturn smtConfig.responseFactory.error(\"Failed to open or write to the regular output \" + e.getMessage(),value.pos());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Save the options on our side as well\n\t\toptions.put(Utils.INTERACTIVE_MODE.equals(option) \u0026\u0026 !smtConfig.isVersion(SMTLIB.V20) ? Utils.PRODUCE_ASSERTIONS : option,value);\n\t\tIResponse r = checkPrintSuccess(smtConfig,key,value);\n\t\tif (r != null) return r;\n\n\t\ttry {\n\t\t\tsolverProcess.sendAndListen(\"(set-option \",option,\" \",value.toString(),\")\\n\");// FIXME - detect errors\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t\t\n\t\treturn successOrEmpty(smtConfig);\n\t}\n\n\t@Override\n\tpublic IResponse get_option(IKeyword key) { // FIXME - use the solver?\n\t\tString option = key.value();\n\t\tIAttributeValue value = options.get(Utils.INTERACTIVE_MODE.equals(option) \u0026\u0026 !smtConfig.isVersion(SMTLIB.V20)? Utils.PRODUCE_ASSERTIONS : option);\n\t\tif (value == null) return smtConfig.responseFactory.unsupported();\n\t\treturn value;\n\t}\n\n\t@Override\n\tpublic IResponse get_info(IKeyword key) {\n\t\treturn sendCommand(\"(get-info \" + key + \")\");\n\t}\n\t\n\t@Override\n\tpublic IResponse set_info(IKeyword key, IAttributeValue value) {\n\t\tif (Utils.infoKeywords.contains(key)) {\n\t\t\treturn smtConfig.responseFactory.error(\"Setting the value of a pre-defined keyword is not permitted: \"+ \n\t\t\t\t\tsmtConfig.defaultPrinter.toString(key),key.pos());\n\t\t}\n\t\treturn sendCommand(new org.smtlib.command.C_set_info(key,value));\n\t}\n\n\n\t@Override\n\tpublic IResponse declare_fun(Ideclare_fun cmd) {\n\t\tif (!logicSet) {\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a declare-fun command is issued\");\n\t\t}\n\t\ttry {\n\t\t\tcheckSatStatus = null;\n\t\t\treturn parseResponse(solverProcess.sendAndListen(translate(cmd),\"\\n\"));\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse define_fun(Idefine_fun cmd) {\n\t\tif (!logicSet) {\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a define-fun command is issued\");\n\t\t}\n\t\ttry {\n\t\t\tcheckSatStatus = null;\n\t\t\treturn parseResponse(solverProcess.sendAndListen(translate(cmd),\"\\n\"));\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse declare_sort(Ideclare_sort cmd) {\n\t\tif (!logicSet) {\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a declare-sort command is issued\");\n\t\t}\n\t\ttry {\n\t\t\tcheckSatStatus = null;\n\t\t\treturn parseResponse(solverProcess.sendAndListen(translate(cmd),\"\\n\"));\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse define_sort(Idefine_sort cmd) {\n\t\tif (!logicSet) {\n\t\t\treturn smtConfig.responseFactory.error(\"The logic must be set before a define-sort command is issued\");\n\t\t}\n\t\ttry {\n\t\t\tcheckSatStatus = null;\n\t\t\treturn parseResponse(solverProcess.sendAndListen(translate(cmd),\"\\n\"));\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\t\n\t@Override \n\tpublic IResponse get_proof() {\n//\t\tif (!Utils.TRUE.equals(get_option(smtConfig.exprFactory.keyword(Utils.PRODUCE_PROOFS)))) {\n//\t\t\treturn smtConfig.responseFactory.error(\"The get-proof command is only valid if :produce-proofs has been enabled\");\n//\t\t}\n//\t\tif (checkSatStatus != smtConfig.responseFactory.unsat()) {\n//\t\t\treturn smtConfig.responseFactory.error(\"The get-proof command is only valid immediately after check-sat returned unsat\");\n//\t\t}\n\t\ttry {\n\t\t\treturn parseResponse(solverProcess.sendAndListen(\"(get-proof)\\n\"));\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\n\t@Override \n\tpublic IResponse get_unsat_core() {\n//\t\tif (!Utils.TRUE.equals(get_option(smtConfig.exprFactory.keyword(Utils.PRODUCE_UNSAT_CORES)))) {\n//\t\t\treturn smtConfig.responseFactory.error(\"The get-unsat-core command is only valid if :produce-unsat-cores has been enabled\");\n//\t\t}\n//\t\tif (checkSatStatus != smtConfig.responseFactory.unsat()) {\n//\t\t\treturn smtConfig.responseFactory.error(\"The get-unsat-core command is only valid immediately after check-sat returned unsat\");\n//\t\t}\n\t\ttry {\n\t\t\treturn parseResponse(solverProcess.sendAndListen(\"(get-unsat-core)\\n\"));\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\n\t@Override \n\tpublic IResponse get_assignment() {\n//\t\t// FIXME - do we really want to call get-option here? it involves going to the solver?\n//\t\tif (!Utils.TRUE.equals(get_option(smtConfig.exprFactory.keyword(Utils.PRODUCE_ASSIGNMENTS)))) {\n//\t\t\treturn smtConfig.responseFactory.error(\"The get-assignment command is only valid if :produce-assignments has been enabled\");\n//\t\t}\n//\t\tif (checkSatStatus != smtConfig.responseFactory.sat() \u0026\u0026 checkSatStatus != smtConfig.responseFactory.unknown()) {\n//\t\t\treturn smtConfig.responseFactory.error(\"The get-assignment command is only valid immediately after check-sat returned sat or unknown\");\n//\t\t}\n\t\ttry {\n\t\t\treturn parseResponse(solverProcess.sendAndListen(\"(get-assignment)\\n\"));\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\n\t@Override \n\tpublic IResponse get_value(IExpr... terms) {\n//\t\t// FIXME - do we really want to call get-option here? it involves going to the solver?\n//\t\tif (!Utils.TRUE.equals(get_option(smtConfig.exprFactory.keyword(Utils.PRODUCE_MODELS)))) {\n//\t\t\treturn smtConfig.responseFactory.error(\"The get-value command is only valid if :produce-models has been enabled\");\n//\t\t}\n//\t\tif (!smtConfig.responseFactory.sat().equals(checkSatStatus) \u0026\u0026 !smtConfig.responseFactory.unknown().equals(checkSatStatus)) {\n//\t\t\treturn smtConfig.responseFactory.error(\"A get-value command is valid only after check-sat has returned sat or unknown\");\n//\t\t}\n\t\ttry {\n\t\t\tsolverProcess.sendNoListen(\"(get-value (\");\n\t\t\tfor (IExpr e: terms) {\n\t\t\t\tsolverProcess.sendNoListen(\" \",translate(e));\n\t\t\t}\n\t\t\tString r = solverProcess.sendAndListen(\"))\\n\");\n\t\t\tIResponse response = parseResponse(r);\n//\t\t\tif (response instanceof ISeq) {\n//\t\t\t\tList\u003cISexpr\u003e valueslist = new LinkedList\u003cISexpr\u003e();\n//\t\t\t\tIterator\u003cISexpr\u003e iter = ((ISeq)response).sexprs().iterator();\n//\t\t\t\tfor (IExpr e: terms) {\n//\t\t\t\t\tif (!iter.hasNext()) break;\n//\t\t\t\t\tList\u003cISexpr\u003e values = new LinkedList\u003cISexpr\u003e();\n//\t\t\t\t\tvalues.add(new Sexpr.Expr(e));\n//\t\t\t\t\tvalues.add(iter.next());\n//\t\t\t\t\tvalueslist.add(new Sexpr.Seq(values));\n//\t\t\t\t}\t\n//\t\t\t\treturn new Sexpr.Seq(valueslist);\n//\t\t\t}\n\t\t\treturn response;\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Error writing to Z3 solver: \" + e);\n\t\t}\n\t}\n\n\tpublic class Translator extends Printer { //extends IVisitor.NullVisitor\u003cString\u003e {\n\t\t\n\t\tpublic Translator(Writer w) { super(w); }\n\n//\t\t@Override\n//\t\tpublic String visit(IDecimal e) throws IVisitor.VisitorException {\n//\t\t\treturn translateSMT(e);\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IStringLiteral e) throws IVisitor.VisitorException {\n//\t\t\tthrow new VisitorException(\"The Z3 solver cannot handle string literals\",e.pos());\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(INumeral e) throws IVisitor.VisitorException {\n//\t\t\treturn e.value().toString();\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IBinaryLiteral e) throws IVisitor.VisitorException {\n//\t\t\treturn \"#b\" + e.value();\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IHexLiteral e) throws IVisitor.VisitorException {\n//\t\t\treturn \"#x\" + e.value();\n//\t\t}\n\n\t\t@Override\n\t\tpublic Void visit(IFcnExpr e) throws IVisitor.VisitorException {\n\t\t\t// Only - for \u003e=2 args is not correctly done, but we can't delegate to translateSMT because it might be a sub-expression.\n\t\t\tIterator\u003cIExpr\u003e iter = e.args().iterator();\n\t\t\tif (!iter.hasNext()) throw new VisitorException(\"Did not expect an empty argument list\",e.pos());\n\t\t\tIQualifiedIdentifier fcn = e.head();\n\t\t\tint length = e.args().size();\n\t\t\tif (length \u003e 2 \u0026\u0026 (fcn instanceof IIdentifier) \u0026\u0026 fcn.toString().equals(\"-\")) {\n\t\t\t\tleftassoc(fcn.toString(),length,iter);\n\t\t\t} else {\n\t\t\t\tsuper.visit(e);\n\t\t\t}\n\t\t\treturn null;\n//\t\t\tString fcnname = fcn.accept(this);\n//\t\t\tStringBuilder sb = new StringBuilder();\n//\t\t\tint length = e.args().size();\n//\t\t\tif (length \u003e 2 \u0026\u0026 (fcnname.equals(\"=\") || fcnname.equals(\"\u003c\") || fcnname.equals(\"\u003e\") || fcnname.equals(\"\u003c=\") || fcnname.equals(\"\u003e=\"))) {\n//\t\t\t\t// chainable\n//\t\t\t\treturn chainable(fcnname,iter);\n//\t\t\t} else if (fcnname.equals(\"xor\")) {\n//\t\t\t\t// left-associative operators that need grouping\n//\t\t\t\treturn leftassoc(fcnname,length,iter);\n//\t\t\t} else if (length \u003e 1 \u0026\u0026 fcnname.equals(\"-\")) {\n//\t\t\t\t// left-associative operators that need grouping\n//\t\t\t\treturn leftassoc(fcnname,length,iter);\n//\t\t\t} else if (fcnname.equals(\"=\u003e\")) {\n//\t\t\t\t// right-associative operators that need grouping\n//\t\t\t\tif (!iter.hasNext()) {\n//\t\t\t\t\tthrow new VisitorException(\"=\u003e operation without arguments\",e.pos());\n//\t\t\t\t}\n//\t\t\t\treturn rightassoc(fcnname,iter);\n//\t\t\t} else {\n//\t\t\t\t// no associativity \n//\t\t\t\tsb.append(\"(\");\n//\t\t\t\tsb.append(fcnname);\n//\t\t\t\twhile (iter.hasNext()) {\n//\t\t\t\t\tsb.append(\" \");\n//\t\t\t\t\tsb.append(iter.next().accept(this));\n//\t\t\t\t}\n//\t\t\t\tsb.append(\")\");\n//\t\t\t\treturn sb.toString();\n//\t\t\t}\n\t\t}\n\n\t\t//@ requires iter.hasNext();\n\t\t//@ requires length \u003e 0;\n\t\tprotected \u003cT extends IExpr\u003e void leftassoc(String fcnname, int length, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\n\t\t\tif (length == 1) {\n\t\t\t\titer.next().accept(this);\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tw.append(\"(\");\n\t\t\t\t\tw.append(fcnname);\n\t\t\t\t\tw.append(\" \");\n\t\t\t\t\tleftassoc(fcnname,length-1,iter);\n\t\t\t\t\tw.append(\" \");\n\t\t\t\t\titer.next().accept(this);\n\t\t\t\t\tw.append(\")\");\n\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\tthrow new IVisitor.VisitorException(ex,null); // FIXME - null ?\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//@ requires iter.hasNext();\n\t\tprotected \u003cT extends IExpr\u003e void rightassoc(String fcnname, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\n\t\t\tT n = iter.next();\n\t\t\tif (!iter.hasNext()) {\n\t\t\t\tn.accept(this);\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tw.append(\"(\");\n\t\t\t\t\tw.append(fcnname);\n\t\t\t\t\tw.append(\" \");\n\t\t\t\t\tn.accept(this);\n\t\t\t\t\tw.append(\" \");\n\t\t\t\t\trightassoc(fcnname,iter);\n\t\t\t\t\tw.append(\")\");\n\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\tthrow new IVisitor.VisitorException(ex,null); // FIXME - null ?\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\t//@ requires iter.hasNext();\n\t\t//@ requires length \u003e 0;\n\t\tprotected \u003cT extends IAccept\u003e void chainable(String fcnname, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\n\t\t\ttry {\n\t\t\t\tw.append(\"(and \");\n\t\t\t\tT left = iter.next();\n\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\tw.append(\"(\");\n\t\t\t\t\tw.append(fcnname);\n\t\t\t\t\tw.append(\" \");\n\t\t\t\t\tleft.accept(this);\n\t\t\t\t\tw.append(\" \");\n\t\t\t\t\t(left=iter.next()).accept(this);\n\t\t\t\t\tw.append(\")\");\n\t\t\t\t}\n\t\t\t\tw.append(\")\");\n\t\t\t} catch (IOException ex) {\n\t\t\t\tthrow new IVisitor.VisitorException(ex,null); // FIXME - null ?\n\t\t\t}\n\t\t}\n\n\n//\t\t@Override\n//\t\tpublic String visit(ISymbol e) throws IVisitor.VisitorException {\n//\t\t\treturn translateSMT(e);\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IKeyword e) throws IVisitor.VisitorException {\n//\t\t\tthrow new VisitorException(\"Did not expect a Keyword in an expression to be translated\",e.pos());\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IError e) throws IVisitor.VisitorException {\n//\t\t\tthrow new VisitorException(\"Did not expect a Error token in an expression to be translated\", e.pos());\n//\t\t}\n//\n//\t\tprivate final String zeros = \"00000000000000000000000000000000000000000000000000\";\n//\t\t@Override\n//\t\tpublic String visit(IParameterizedIdentifier e) throws IVisitor.VisitorException {\n//\t\t\treturn translateSMT(e);\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IAsIdentifier e) throws IVisitor.VisitorException {\n//\t\t\treturn translateSMT(e);\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IForall e) throws IVisitor.VisitorException {\n//\t\t\treturn translateSMT(e);\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IExists e) throws IVisitor.VisitorException {\n//\t\t\treturn translateSMT(e);\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(ILet e) throws IVisitor.VisitorException {\n//\t\t\treturn translateSMT(e);\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IAttribute\u003c?\u003e e) throws IVisitor.VisitorException {\n//\t\t\tthrow new UnsupportedOperationException(\"visit-IAttribute\");\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IAttributedExpr e) throws IVisitor.VisitorException {\n//\t\t\treturn translateSMT(e);\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(IDeclaration e) throws IVisitor.VisitorException {\n//\t\t\tthrow new UnsupportedOperationException(\"visit-IDeclaration\");\n//\t\t}\n//\n//\t\t@Override\n//\t\tpublic String visit(ISort.IFamily s) throws IVisitor.VisitorException {\n//\t\t\treturn s.identifier().accept(this);\n//\t\t}\n//\t\t\n//\t\t@Override\n//\t\tpublic String visit(ISort.IAbbreviation s) throws IVisitor.VisitorException {\n//\t\t\tthrow new UnsupportedOperationException(\"visit-ISort.IAbbreviation\");\n//\t\t}\n//\t\t\n//\t\t@Override\n//\t\tpublic String visit(ISort.IApplication s) throws IVisitor.VisitorException {\n//\t\t\treturn translateSMT(s);\n//\t\t}\n//\t\t\n//\t\t@Override\n//\t\tpublic String visit(ISort.IFcnSort s) throws IVisitor.VisitorException {\n//\t\t\tthrow new UnsupportedOperationException(\"visit-ISort.IFcnSort\");\n//\t\t}\n//\t\t\n//\t\t@Override\n//\t\tpublic String visit(ISort.IParameter s) throws IVisitor.VisitorException {\n//\t\t\tthrow new UnsupportedOperationException(\"visit-ISort.IParameter\");\n//\t\t}\n//\t\t\n//\t\t@Override\n//\t\tpublic String visit(ICommand command) throws IVisitor.VisitorException {\n//\t\t\tif (command instanceof ICommand.Iassert) {\n//\t\t\t\treturn \"(assert \" + ((ICommand.Iassert)command).expr().accept(this) + \")\";\n//\t\t\t} else {\n//\t\t\t\treturn translateSMT(command);\n//\t\t\t}\n//\t\t}\n\t}\n}\n",
        "name": "Solver_z3_4_5.java",
        "path": "SMT/src/org/smtlib/solvers/Solver_z3_4_5.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMT/src/org/smtlib/solvers/Solver_z3_4_5.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 731,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();"
        },
        {
          "limitHit": false,
          "lineNumber": 732,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires length \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 751,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();"
        },
        {
          "limitHit": false,
          "lineNumber": 772,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();"
        },
        {
          "limitHit": false,
          "lineNumber": 773,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires length \u003e 0;"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\n * This file is part of the SMT project.\n * Copyright 2010 David R. Cok\n * Created August 2010\n */\npackage org.smtlib.solvers;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.smtlib.ICommand.IScript;\nimport org.smtlib.ICommand.Ideclare_fun;\nimport org.smtlib.*;\nimport org.smtlib.ICommand.Idefine_fun;\nimport org.smtlib.IResponse.IAssertionsResponse;\nimport org.smtlib.IResponse.IAssignmentResponse;\nimport org.smtlib.IResponse.IAttributeList;\nimport org.smtlib.IResponse.IProofResponse;\nimport org.smtlib.IResponse.IUnsatCoreResponse;\nimport org.smtlib.IResponse.IValueResponse;\nimport org.smtlib.ISort.IAbbreviation;\nimport org.smtlib.ISort.IApplication;\nimport org.smtlib.ISort.IFamily;\nimport org.smtlib.ISort.IFcnSort;\nimport org.smtlib.ISort.IParameter;\nimport org.smtlib.IExpr.*;\nimport org.smtlib.IVisitor.VisitorException;\nimport org.smtlib.SMT.Configuration.SMTLIB;\n\n// Note - simplify appears to have problems if the set of assertions pushed\n// via BG_PUSH are not consistent.  At least, it does not produce counterexample\n// information in that case.\n\n/** The adapter that drives the Simplify solver.\n * \u003cP\u003e\n * Note on implementation.  Simplify allows only either pushing an assertion to\n * the background or checking that it is valid.  Assertions that are pushed (via BG_PUSH)\n * appear to be filtered out of counterexamples.  Thus for now we will only use\n * BG_PUSH for background theory axioms; for the rest we will accumulate all assertions\n * into one giant AND (in the conjunction field) and then assert them all at once to Simplify\n * when check-sat is called.  The usual push and pop will not be sent to Simplify - rather\n * we save the state of 'conjunction' ourselves.  This implements the letter if not the\n * spirit of push and pop, and it may have performance implications.  If it does, we'll\n * optimize the implementation then. */\npublic class Solver_simplify extends Solver_test implements ISolver {\n\t\n\t/** Just to hold the command line to launch Simplify */\n\tString cmds[] = new String[1]; \n\t\n\t/** The external process driver, initialized in start() */\n\tprotected SolverProcess solverProcess;\n\t\n\t/** Accumulates the translated expressions from various asserts, in order\n\t * to send them all at once with a check-sat command.\n\t */\n\tprivate String conjunction = \"\";\n\n\t/** The stack on which to save instances of 'conjunction' */\n\tprivate List\u003cString\u003e pushesStack = new LinkedList\u003cString\u003e();\n\t{\n\t\tpushesStack.add(\"\");\n\t}\n\t\n\t/** Constructor with standard signature for invocation through reflection */\n\tpublic Solver_simplify(SMT.Configuration smtConfig, String executable) {\n\t\tsuper(smtConfig,\"\");\n\t\tcmds[0] = executable;\n\t\tsolverProcess = new SolverProcess(cmds,\"\u003e\\t\",smtConfig.logfile);\n\t}\n\t\n\t@Override\n\tpublic IResponse start() {\n\t\tsuper.start();\n\t\tsolverProcess.start(true);\n\t\ttry {\n\t\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Started simplify\");\n\t\t\tsolverProcess.sendAndListen(\"(BG_PUSH (FORALL (B X Y) (IMPLIES (EQ B |@true|) (EQ (\" + ite_term + \" B X Y) X))))\\n\");\n\t\t\tsolverProcess.sendAndListen(\"(BG_PUSH (FORALL (B X Y) (IMPLIES (NEQ B |@true|) (EQ (\" + ite_term + \" B X Y) Y))))\\n\");\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to assert background formulae at start\");\n\t\t}\n\t\treturn smtConfig.responseFactory.success();\n\t}\n\t\n\t@Override\n\tpublic IResponse exit() {\n\t\tsolverProcess.exit();\n\t\tif (smtConfig.verbose != 0) smtConfig.log.logDiag(\"Ended simplify \");\n\t\t//process = null;\n\t\treturn super.exit();\n\t}\n\n\t@Override\n\tpublic IResponse assertExpr(IExpr sexpr) {\n\t\tIResponse res = super.assertExpr(sexpr);\n\t\tif (!res.isOK()) return res;\n\t\ttry {\n\t\t\tString translatedSexpr = translate(sexpr);\n\t\t\tif (translatedSexpr == null) {\n\t\t\t\treturn smtConfig.responseFactory.error(\"Failure in translating expression: \" + smtConfig.defaultPrinter.toString(sexpr), sexpr.pos());\n\t\t\t}\n\t\t\tconjunction = conjunction + \" \\n\" + translatedSexpr;\n\t\t\t//String s = solverProcess.sendAndListen(\"(BG_PUSH \",translatedSexpr,\" )\\r\\n\");\n\t\t\t//System.out.println(\"HEARD: \" + s);\n\t\t} catch (VisitorException e) {\n\t\t\treturn smtConfig.responseFactory.error(e.getMessage(),e.pos);\n\t\t}\n\t\treturn smtConfig.responseFactory.success();\n\t}\n\n\t@Override\n\tpublic IResponse get_assertions() {\n\t\treturn super.get_assertions();\n\t}\n\t\n\t@Override\n\tpublic IResponse check_sat() {\n\t\tIResponse res = super.check_sat();\n\t\tif (res.isError()) return res;\n\t\ttry {\n//\t\t\tString s = solverProcess.sendAndListen(\"(BG_PUSH (EQ 0 0))\\r\\n\");\n//\t\t\ts = solverProcess.sendAndListen(\"(EQ 0 1)\\r\\n\");\n//\t\t\tif (s.contains(\"Valid.\")) res = smtConfig.responseFactory.unsat();\n//\t\t\telse if (s.contains(\"Invalid.\")) res = smtConfig.responseFactory.sat();\n//\t\t\telse res = smtConfig.responseFactory.unknown();\n\t\t\t\n\t\t\tString msg = \"(NOT (AND TRUE \" + conjunction + \"\\n))\\n\";\n\t\t\tString s = solverProcess.sendAndListen(msg);\n\t\t\t// FIXME - what about errors in SImplify\n\t\t\t//smtConfig.log.logOut(\"HEARD: \" + s);\n\t\t\tif (s.contains(\"Valid.\")) res = smtConfig.responseFactory.unsat();\n\t\t\telse if (s.contains(\"Invalid.\")) res = smtConfig.responseFactory.sat();\n\t\t\telse res = smtConfig.responseFactory.unknown();\n\t\t\tcheckSatStatus = res;\n//\t\t\ts = solverProcess.sendAndListen(\"(BG_POP)\\r\\n\");\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\tres = smtConfig.responseFactory.error(\"Failed to check-sat\");\n\t\t}\n\t\treturn res;\n\t}\n\n\t@Override\n\tpublic IResponse declare_fun(Ideclare_fun cmd) {\n\t\tIResponse res = super.declare_fun(cmd);\n\t\tif (res.isError()) return res;\n\t\ttry {\n\t\t\tif (cmd.resultSort().isBool() \u0026\u0026 cmd.argSorts().size() \u003e 0) {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tsb.append(\"(DEFPRED (\");\n\t\t\t\tsb.append(translate(cmd.symbol()));\n\t\t\t\tint n = cmd.argSorts().size();\n\t\t\t\tfor (int i = 0; i\u003cn; i++) {\n\t\t\t\t\tsb.append(\" X\");  // FIXME - fix this\n\t\t\t\t\tsb.append(i);\n\t\t\t\t}\n\t\t\t\tsb.append(\"))\\n\");\n\t\t\t\tString s = solverProcess.sendAndListen(sb.toString());\n\t\t\t\t// FIXME - check for error in s -- System.out.println(\"HEARD \" + s);\n\t\t\t\tres = smtConfig.responseFactory.success();\n\t\t\t} else {\n\t\t\t\tres = smtConfig.responseFactory.success();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tres = smtConfig.responseFactory.error(\"Failed to declare-fun: \" + e.getMessage(),null); // FIXME - position?\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\tres = smtConfig.responseFactory.error(\"Failed to declare-fun: \" + e.getMessage(),null);\n\t\t}\n\t\treturn res;\n\t}\n\n\t@Override\n\tpublic IResponse define_fun(Idefine_fun cmd) {\n\t\tIResponse res = super.define_fun(cmd);\n\t\tif (res.isError()) return res;\n\t\ttry {\n\t\t\tif (cmd.resultSort().isBool() \u0026\u0026 cmd.parameters().size() \u003e 0) {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tsb.append(\"(DEFPRED (\");\n\t\t\t\tsb.append(translate(cmd.symbol()));\n\t\t\t\tint n = cmd.parameters().size();\n\t\t\t\tfor (int i = 0; i\u003cn; i++) {\n\t\t\t\t\tsb.append(\" X\");\n\t\t\t\t\tsb.append(i);\n\t\t\t\t}\n\t\t\t\tsb.append(\"))\\n\");\n\t\t\t\tString s = solverProcess.sendAndListen(sb.toString());\n\t\t\t\t// FIXME - check for error in s -- System.out.println(\"HEARD \" + s);\n\t\t\t\tres = smtConfig.responseFactory.success();\n\t\t\t} else {\n\t\t\t\tres = smtConfig.responseFactory.success();\n\t\t\t}\n\t\t\tIExpr.IFactory f = smtConfig.exprFactory;\n\t\t\tassertExpr(f.fcn(f.symbol(\"=\"),cmd.symbol(),cmd.expression()));\n\t\t\t\t\t\n\t\t} catch (IOException e) {\n\t\t\tres = smtConfig.responseFactory.error(\"Failed to declare-fun: \" + e.getMessage(),null); // FIXME - position?\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\tres = smtConfig.responseFactory.error(\"Failed to declare-fun: \" + e.getMessage(),null);\n\t\t}\n\t\treturn res;\n\t}\n\n\t//@ requires number \u003e= 0;\n\t@Override\n\tpublic IResponse pop(int number) {\n\t\tIResponse status = super.pop(number);\n\t\tif (!status.isOK()) return status;\n\t\ttry {\n\t\t\twhile (--number \u003e= 0) { \n\t\t\t\tconjunction = pushesStack.remove(0);\n\t\t\t\tString s = solverProcess.sendAndListen(\"(BG_POP)\");\n\t\t\t\t// FIXME - check for error in s -- System.out.println(\"HEARD \" + s);\n\t\t\t}\n\t\t\treturn smtConfig.responseFactory.success();\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to push\");\n\t\t}\n\t}\n\n\t//@ requires number \u003e= 0;\n\t@Override\n\tpublic IResponse push(int number) {\n\t\tIResponse status = super.push(number);\n\t\tif (!status.isOK()) return status;\n\t\ttry {\n\t\t\twhile (--number \u003e= 0) { \n\t\t\t\tpushesStack.add(0,conjunction);\n\t\t\t\tString s = solverProcess.sendAndListen(\"(BG_PUSH (EQ 0 0))\");\n\t\t\t\t// FIXME - check for error in s -- System.out.println(\"HEARD \" + s);\n\t\t\t}\n\t\t\treturn smtConfig.responseFactory.success();\n\t\t} catch (IOException e) {\n\t\t\treturn smtConfig.responseFactory.error(\"Failed to push\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic IResponse set_logic(String logicName, /*@Nullable*/ IPos pos) {\n\t\t// FIXME - discrimninate among logics\n\t\tboolean lSet = logicSet != null;\n\t\tIResponse status = super.set_logic(logicName,pos);\n\t\tif (!status.isOK()) return status;\n\t\tif (logicName.contains(\"BV\")) {\n\t\t\treturn smtConfig.responseFactory.error(\"The simplify solver does not yet support the bit-vector theory\",pos);\n\t\t}\n\t\tif (lSet) {\n\t\t\tpushesStack.clear();\n\t\t\tpush(1);\n\t\t}\n\t\treturn smtConfig.responseFactory.success();\n\n\t}\n\n\t@Override\n\tpublic IResponse set_option(IKeyword option, IAttributeValue value) {\n\t\tif (option.value().equals(Utils.PRODUCE_ASSIGNMENTS)) return smtConfig.responseFactory.unsupported();\n\t\tif (option.value().equals(Utils.PRODUCE_MODELS)) return smtConfig.responseFactory.unsupported();\n\t\tif (option.value().equals(Utils.PRODUCE_PROOFS)) return smtConfig.responseFactory.unsupported();\n\t\tif (option.value().equals(Utils.PRODUCE_UNSAT_CORES)) return smtConfig.responseFactory.unsupported();\n//\t\tif (option.value().equals(\":expand-definitions\") \u0026\u0026 smtConfig.atLeastVersion(SMTLIB.V25)) return smtConfig.responseFactory.unsupported();\n\n\t\treturn super.set_option(option,value);\n\t}\n\n\t@Override\n\tpublic IResponse set_info(IKeyword option, IAttributeValue value) {\n\t\treturn super.set_info(option,value);\n\t}\n\n\t@Override\n\tpublic IResponse get_option(IKeyword key) {\n\t\tString option = key.value();\n\t\tif (Utils.INTERACTIVE_MODE.equals(option) \u0026\u0026 !smtConfig.isVersion(SMTLIB.V20)) option = Utils.PRODUCE_ASSERTIONS;\n\t\tIAttributeValue value = options.get(option);\n\t\tif (value == null) return smtConfig.responseFactory.unsupported();\n\t\treturn value;\n\t}\n\n\t@Override\n\tpublic IResponse get_info(IKeyword key) {\n\t\tsuper.get_info(key);\n\t\tIKeyword option = key;\n\t\tIAttributeValue lit;\n\t\tif (Utils.ERROR_BEHAVIOR.equals(option)) {\n\t\t\tlit = smtConfig.exprFactory.symbol(Utils.CONTINUED_EXECUTION);\n\t\t} else if (Utils.AUTHORS.equals(option)) {\n\t\t\tlit = smtConfig.exprFactory.unquotedString(\"David Detlefs and Greg Nelson and James B. Saxe\");\n\t\t} else if (Utils.VERSION.equals(option)) {\n\t\t\tlit = smtConfig.exprFactory.unquotedString(\"1.5.4\");\n\t\t} else if (Utils.NAME.equals(option)) {\n\t\t\tlit = smtConfig.exprFactory.unquotedString(\"simplify\");\n\t\t} else if (Utils.REASON_UNKNOWN.equals(option)) {\n\t\t\treturn smtConfig.responseFactory.unsupported();\n\t\t} else if (Utils.ALL_STATISTICS.equals(option)) {\n\t\t\treturn smtConfig.responseFactory.unsupported();\n\t\t} else {\n\t\t\treturn smtConfig.responseFactory.unsupported();\n\t\t}\n\t\tIAttribute\u003c?\u003e attr = smtConfig.exprFactory.attribute(key,lit);\n\t\treturn smtConfig.responseFactory.get_info_response(attr);\n\t}\n\n// Pure overrides are redundant\n//\t@Override\n//\tpublic IResponse declare_sort(Ideclare_sort cmd) {\n//\t\treturn super.declare_sort(cmd);\n//\t}\n//\n//\t@Override\n//\tpublic IResponse define_fun(Idefine_fun cmd){\n//\t\treturn super.define_fun(cmd);\n//\t}\n//\n//\t@Override\n//\tpublic IResponse define_sort(Idefine_sort cmd){\n//\t\treturn super.define_sort(cmd);\n//\t}\n\t\n\t// These are all currently unsupported\n//\t@Override\n//\tpublic IResponse get_proof() {\n//\t\treturn smtConfig.responseFactory.error(\"The get-proof command is not implemented for simplify\"); // FIXME - get-proof for simplify\n//\t}\n//\t\n//\t@Override\n//\tpublic IResponse get_value(IExpr ... terms) {\n//\t\treturn smtConfig.responseFactory.error(\"The get-value command is not implemented for simplify\"); // FIXME - get-value for simplify\n//\t}\n//\t\n//\t@Override\n//\tpublic IResponse get_assignment() {\n//\t\treturn smtConfig.responseFactory.error(\"The get-assignment command is not implemented for simplify\"); // FIXME - get-assignment for simplify\n//\t}\n//\t\n//\t@Override\n//\tpublic IResponse get_unsat_core() {\n//\t\treturn smtConfig.responseFactory.error(\"The get-proof command is not implemented for simplify\"); // FIXME - get-proof for simplify\n//\t}\n\n\t@Override\n\tpublic IResponse get_value(IExpr... terms) {\n\t\tTypeChecker tc = new TypeChecker(symTable);\n\t\ttry {\n\t\t\tfor (IExpr term: terms) {\n\t\t\t\tterm.accept(tc);\n\t\t\t}\n\t\t} catch (IVisitor.VisitorException e) {\n\t\t\ttc.result.add(smtConfig.responseFactory.error(e.getMessage()));\n\t\t} finally {\n\t\t\tif (!tc.result.isEmpty()) return tc.result.get(0); // FIXME - report all errors?\n\t\t}\n\t\t// FIXME - do we really want to call get-option here? it involves going to the solver?\n\t\tif (!Utils.TRUE.equals(get_option(smtConfig.exprFactory.keyword(Utils.PRODUCE_MODELS)))) {\n\t\t\treturn smtConfig.responseFactory.error(\"The get-value command is only valid if :produce-models has been enabled\");\n\t\t}\n\t\tif (!smtConfig.responseFactory.sat().equals(checkSatStatus) \u0026\u0026 !smtConfig.responseFactory.unknown().equals(checkSatStatus)) {\n\t\t\treturn smtConfig.responseFactory.error(\"A get-value command is valid only after check-sat has returned sat or unknown\");\n\t\t}\n\t\treturn smtConfig.responseFactory.unsupported();\n\t}\n\n\n\n\t\n\tpublic /*@Nullable*/String translate(IExpr expr) throws IVisitor.VisitorException {\n\t\tTranslator t = new Translator(typemap,smtConfig);\n\t\tString r = expr.accept(t);\n\t\tif (t.conjuncts.isEmpty()) return r;\n\t\tString and = \"(AND \";\n\t\tfor (String c: t.conjuncts) {\n\t\t\tand = and + c + \" \";\n\t\t}\n\t\tand = and + r + \" )\";\n\t\treturn and;\n\t}\n\t/* Translating simplify:\n\t *  Simplify has no type definitions\n\t *  It does not require declaring symbols before use - it presumes\n\t *  a symbol is a term or a predicate constant or a function when it\n\t *  first sees one.  \n\t *  New predicates are defined with DEFPRED\n\t *  It has a strict distinction between terms and formulas, so\n\t *  \t- there are different symbols for equality (EQ and IFF)\n\t *  \t- there are different symbols for inequality (NEQ and (IFF p (NOT q)))\n\t *  \t- DISTINCT operates only on terms (and the result is a formula)\n\t *  \n\t *  \n\t *  QUESTIONS: what about overloaded functions\n\t */\n\t/*    SMTLIB\t\t\tSIMPLIFY\n\t * FORMULAE:\n\t * (or p q r ...)\t(OR p q r ...)\n\t * (and p q r ...)\t(AND p q r ...)\n\t * (not p)\t\t\t(NOT p)\n\t * (=\u003e p q r ...)\t(IMPLIES p (IMPLIES q r...))\n\t * (xor p q r ...)\t(NOT ( IFF ( NOT (IFF p q)) r )) ...\n\t * (= p q r ...)\t(IFF (IFF p q) r)  -- formulas\n\t * (= p q r ...)\t(AND (EQ p q ) ( EQ q r) ...)  -- terms\n\t * (distinct p q r)\t-- does not make sense for more than 2 arguments if the arguments are boolean \n\t * (distinct x y z)\t(DISTINCT x y z)  -- x,y,z are terms, result is a formula\n\t * true\t\t\t\tTRUE - when used as a formula\n\t * false\t\t\tFALSE - when used as a formula\n\t * (ite b p q)\t\t_ITEB for formula arguments; _ITET for term arguments\n\t * \n\t * \u003c \u003c= \u003e \u003e=\t\t\u003c \u003c= \u003e \u003e= - arguments are terms, result is a formula\n\t *\n\t * TERMS\n\t * + - *\t\t\t+ - *\n\t * \t    \t\t\tselect store  - for arrays\n\t * \n\t * In simplify EQ NEQ \u003c \u003c= \u003e \u003e= DISTINCT take terms as arguments, produce formulas\n\t * how to handle boolean terms???\n\t */\n\n\t/* Simplify ids:\n\t * \t\ta) sequence of alpha, digits, underscore, beginning with alpha\n\t * \t\tb) sequence of ! # $ % \u0026 * + - . / : \u003c = \u003e ? @ [ ] ^ _ { } ~\n\t *               excludes | ( ) ` \\ ; \" ' , \n\t * \t\tc) printable characters and space except \\ |, surrounded by |\n\t *           - also allows undocumented 'escape sequences'\n\t *  To translate from SMT-LIB use form (c), but have to remove\n\t *  explicit tabs, newlines, crs; also any \\-escape sequences\n\t */\n\t\n\n\t/** Name of an if-then-else construct on term arguments */ \n\tstatic private String ite_term = \"_ITE\";\n\t\n\tstatic Map\u003cString,String\u003e fcnNames = new HashMap\u003cString,String\u003e();\n\tstatic Set\u003cString\u003e logicNames = new HashSet\u003cString\u003e();\n\tstatic Set\u003cString\u003e reservedWords  = new HashSet\u003cString\u003e();\n\tstatic Set\u003cString\u003e nonchainables  = new HashSet\u003cString\u003e();\n\tstatic {\n\t\t// FIXME - this builds in the theories - we should abstract both the naming and the mappings for arbitrary arguments\n\t\t// Translations of SMT-LIB standard concrete names to Simplify names\n\t\t// Anything not here is considered to be uninterpreted and the\n\t\t// SMT-LIB name will be encoded into a unique Simplify name\n\t\tfcnNames.put(\"or\",\"OR\");  // \u003e2 arguments OK for simplify (left-assoc)\n\t\tfcnNames.put(\"not\",\"NOT\");\n\t\tfcnNames.put(\"and\",\"AND\");  // \u003e2 arguments OK for simplify (left-assoc)\n\t\tfcnNames.put(\"=\",\"EQ\");\t\t  // \u003e2 arguments NOT OK for simplify (chainable)\n\t\tfcnNames.put(\"=\u003e\",\"IMPLIES\"); // \u003e2 arguments NOT OK for simplify (right-assoc)\n\t\tfcnNames.put(\"distinct\",\"DISTINCT\"); // \u003e2 arguments OK for simplify (pairwise)\n\t\tfcnNames.put(\"xor\",\"NEQ\");\t\t\t// \u003e2 arguments NOT OK for simplify (left-assoc)\n\t\tfcnNames.put(\"+\",\"+\");\t\t\t\t// \u003e2 arguments  OK for simplify (left-assoc)\n\t\tfcnNames.put(\"-\",\"-\");\t\t\t\t// \u003e2 arguments NOT OK for simplify (left-assoc)\n\t\tfcnNames.put(\"*\",\"*\");\t\t\t\t// \u003e2 arguments  OK for simplify (left-assoc)\n\t\tfcnNames.put(\"\u003e\",\"\u003e\");\t\t\t\t// \u003e2 arguments NOT OK for simplify\t(left-assoc)\t\t\n\t\tfcnNames.put(\"\u003e=\",\"\u003e=\");\t\t\t// \u003e2 arguments NOT OK for simplify (chainable)\n\t\tfcnNames.put(\"\u003c\",\"\u003c\");\t\t\t\t// \u003e2 arguments NOT OK for simplify (chainable)\n\t\tfcnNames.put(\"\u003c=\",\"\u003c=\");\t\t\t// \u003e2 arguments NOT OK for simplify (chainable)\n\t\tfcnNames.put(\"true\",\"TRUE\");\n\t\tfcnNames.put(\"false\",\"FALSE\");\n\t\tfcnNames.put(\"ite\",ite_term);\n\t\t\n\t\tfcnNames.put(\"select\",\"select\");\n\t\tfcnNames.put(\"store\",\"store\");\n\n\t\tnonchainables.addAll(Arrays.asList(new String[]{ \"EQ\", \"\u003e\", \"\u003c\", \"\u003e=\", \"\u003c=\", \"IFF\" }));\n\t\t\n\t\treservedWords.addAll(Arrays.asList(new String[]\n\t\t  { \"FORALL\",\"EXISTS\",\"LET\",\n\t\t\t\"OR\",\"AND\",\"IMPLIES\",\"EXPLIES\",\"XOR\",\"DISTINCT\",\"IFF\",\"NOT\",\"TRUE\",\"FALSE\",\n\t\t\t\"EQ\",\"NEQ\",\"DISTINCT\",\"PATS\",\n\t\t\t\"+\",\"-\",\"*\",\"\u003e\",\"\u003e=\",\"\u003c\",\"\u003c=\",\"store\",\"select\",\"@true\",\n\t\t\t\"LBLPOS\",\"LBLNEG\",\"LBL\",\"ORDER\",\n\t\t\t\"BG_PUSH\",\"BG_POP\",\"DEFPRED\",\"DEFPREDMAP\",\n\t\t\tite_term,\n\t\t\t}\n\t\t));\n\t\t\n\t\t// These are formulas and take formulas as arguments\n\t\tlogicNames.addAll(Arrays.asList(new String[]\n\t\t   { \"OR\",\"AND\",\"IMPLIES\",\"EXPLIES\",\"XOR\",\"IFF\",\"NOT\",\"FORALL\",\"EXISTS\"}));\n\t}\n\t\n\tstatic public class Translator implements IVisitor\u003cString\u003e {\n\t\tboolean isFormula = true;\n\t\tfinal private Map\u003cIExpr,ISort\u003e typemap;\n\t\tfinal private SMT.Configuration smtConfig;\n\t\tprivate List\u003cString\u003e conjuncts = new LinkedList\u003cString\u003e();\n\t\t\n\t\tpublic Translator(Map\u003cIExpr,ISort\u003e typemap, SMT.Configuration smtConfig) {\n\t\t\tthis.typemap = typemap;\n\t\t\tthis.smtConfig = smtConfig;\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IDecimal e) throws IVisitor.VisitorException {\n\t\t\tthrow new VisitorException(\"The simplify solver cannot handle decimal literals\",e.pos());\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IStringLiteral e) throws IVisitor.VisitorException {\n\t\t\tthrow new VisitorException(\"The simplify solver cannot handle string literals\",e.pos());\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(INumeral e) throws IVisitor.VisitorException {\n\t\t\treturn e.value().toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IBinaryLiteral e) throws IVisitor.VisitorException {\n\t\t\tthrow new VisitorException(\"Did not expect a Binary literal in an expression to be translated\",e.pos());\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IHexLiteral e) throws IVisitor.VisitorException {\n\t\t\tthrow new VisitorException(\"Did not expect a Hex literal in an expression to be translated\",e.pos());\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IFcnExpr e) throws IVisitor.VisitorException {\n\t\t\tboolean resultIsFormula = this.isFormula;\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\ttry {\n\t\t\t\tIterator\u003cIExpr\u003e iter = e.args().iterator();\n\t\t\t\tif (!iter.hasNext()) throw new VisitorException(\"Did not expect an empty argument list\",e.pos());\n\t\t\t\tif (!(e.head() instanceof ISymbol)) {\n\t\t\t\t\tthrow new VisitorException(\"Have not yet implemented parameterized bit-vector functions\",e.pos());\n\t\t\t\t}\n\t\t\t\tISymbol fcn = (ISymbol)e.head();\n\t\t\t\tString newName = fcn.accept(this);\n\t\t\t\t\n\t\t\t\t// Determine if the arguments are formulas or terms\n\t\t\t\tif (resultIsFormula) {\n\t\t\t\t\tif (newName != null \u0026\u0026 logicNames.contains(newName)) {\n\t\t\t\t\t\t// Propositional boolean item\n\t\t\t\t\t\tthis.isFormula = true;\n\t\t\t\t\t} else if (e.args().size() \u003c= 1) {\n\t\t\t\t\t\tthis.isFormula = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tIExpr arg = e.args().get(1); // Use argument 1 for ite's sake\n\t\t\t\t\t\tISort sort = typemap.get(arg);\n\t\t\t\t\t\tif (sort == null) {\n\t\t\t\t\t\t\tthrow new VisitorException(\"INTERNAL ERROR: Encountered an un-sorted expression node: \" + smtConfig.defaultPrinter.toString(arg),arg.pos());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sort.isBool()) {\n\t\t\t\t\t\t\t// Some functions can take both bool and non-bool arguments:\n\t\t\t\t\t\t\t//   EQ NEQ DISTINCT ite\n\t\t\t\t\t\t\tthis.isFormula = resultIsFormula;\n\t\t\t\t\t\t\tif (\"EQ\".equals(newName)) newName = \"IFF\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Arguments must be terms\n\t\t\t\t\t\t\tthis.isFormula = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.isFormula = false;\n\t\t\t\t}\n\n\t\t\t\tISort s = typemap.get(e);\n\t\t\t\tif (s == null) {\n\t\t\t\t\tthrow new VisitorException(\"INTERNAL ERROR: Encountered an un-sorted expression node: \" + smtConfig.defaultPrinter.toString(e),e.pos());\n\t\t\t\t}\n\t\t\t\tif (s.isBool() \u0026\u0026 !resultIsFormula) {\n\t\t\t\t\tthrow new VisitorException(\"Use of boolean in a term position is not yet implemented in the Simplify adapter\",e.pos()); // FIXME - booleans as terms\n\t\t\t\t}\n\n\t\t\t\tif (isFormula \u0026\u0026 newName.equals(\"NEQ\")) {\n\t\t\t\t\t// for formulas, NEQ is (NOT (IFF p q ...))\n\t\t\t\t\t// In simplify, IFF is not implicitly chainable\n\t\t\t\t\tint length = e.args().size();\n\t\t\t\t\tif ((length\u00261)==0) sb.append(\"(NOT \");\n\t\t\t\t\tsb.append(leftassoc(\"IFF\",length,iter));\n\t\t\t\t\tif ((length\u00261)==0) sb.append(\")\");\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t} else if (newName.equals(\"IMPLIES\")) {\n\t\t\t\t\t// right-associative operators that need grouping\n\t\t\t\t\tif (!iter.hasNext()) {\n\t\t\t\t\t\tthrow new VisitorException(\"implies (=\u003e) operation without arguments\",e.pos());\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(rightassoc(newName,iter));\n\n\t\t\t\t} else if (newName.equals(\"DISTINCT\")) {\n\t\t\t\t\t// in simplify, DISTINCT is just for term arguments but the result is a formula\n\t\t\t\t\tif (isFormula) {\n\t\t\t\t\t\t// arguments are formulas, result is formula\n\t\t\t\t\t\tif (e.args().size() \u003e 2) {\n\t\t\t\t\t\t\t// More than two distinct boolean values?\n\t\t\t\t\t\t\tsb.append(\"FALSE\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsb.append(\"(NOT (IFF\");\n\t\t\t\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsb.append(\" ))\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (resultIsFormula) {\n\t\t\t\t\t\t// arguments are terms, result is formula - standard use in Simplify\n\t\t\t\t\t\tsb.append(\"(DISTINCT\");\n\t\t\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsb.append(\")\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// used in a term position\n\t\t\t\t\t\tthrow new VisitorException(\"Use of DISTINCT in a term position is not yet implemented in the Simplify adapter\",e.pos()); // FIXME - distinact as a term\n\t\t\t\t\t}\n\t\t\t\t} else if (ite_term.equals(newName)) {\n\t\t\t\t\tif (isFormula) {\n\t\t\t\t\t\tsb.append(\"(AND (IMPLIES \");\n\t\t\t\t\t\tsb.append(e.args().get(0).accept(this));\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t\tsb.append(e.args().get(1).accept(this));\n\t\t\t\t\t\tsb.append(\")\");\n\t\t\t\t\t\tsb.append(\"(IMPLIES (NOT \");\n\t\t\t\t\t\tsb.append(e.args().get(0).accept(this));\n\t\t\t\t\t\tsb.append(\") \");\n\t\t\t\t\t\tsb.append(e.args().get(2).accept(this));\n\t\t\t\t\t\tsb.append(\"))\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (e.args().size() \u003e 2 \u0026\u0026 nonchainables.contains(newName)) {\n\t\t\t\t\tIterator\u003cIExpr\u003e iter2 = e.args().iterator();\n\t\t\t\t\tsb.append(\"(AND \");\n\n\t\t\t\t\tIExpr left = iter2.next();\n\t\t\t\t\twhile (iter2.hasNext()) {\n\t\t\t\t\t\tIExpr right = iter2.next();\n\t\t\t\t\t\tsb.append(\"(\" + newName + \" \");\n\t\t\t\t\t\tsb.append(left.accept(this));\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t\tsb.append(right.accept(this));\n\t\t\t\t\t\tsb.append(\")\");\n\t\t\t\t\t\tleft = right;\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(\")\");\n\t\t\t\t}\n\t\t\t\tif (e.args().size() \u003e 2 \u0026\u0026 (newName.equals(\"-\") || newName.equals(\"/\"))) {\n\t\t\t\t\tIterator\u003cIExpr\u003e iter2 = e.args().iterator();\n\t\t\t\t\tsb.append(leftassoc(newName,e.args().size(),iter2));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (sb.length() == 0) {\n\t\t\t\t\tsb.append(\"( \");\n\t\t\t\t\tsb.append(newName);\n\t\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(\" )\");\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tthis.isFormula = resultIsFormula;\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\t\n\t\t//@ requires iter.hasNext();\n\t\tprivate \u003cT extends IExpr\u003e String rightassoc(String fcnname, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\n\t\t\tT n = iter.next();\n\t\t\tif (!iter.hasNext()) {\n\t\t\t\treturn n.accept(this);\n\t\t\t} else {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tsb.append(\"(\");\n\t\t\t\tsb.append(fcnname);\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(n.accept(this));\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(rightassoc(fcnname,iter));\n\t\t\t\tsb.append(\")\");\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\t\t}\n\n\t\t//@ requires iter.hasNext();\n\t\t//@ requires length \u003e 0;\n\t\tprivate \u003cT extends IExpr\u003e String leftassoc(String fcnname, int length, Iterator\u003cT\u003e iter ) throws IVisitor.VisitorException {\n\t\t\tif (length == 1) {\n\t\t\t\treturn iter.next().accept(this);\n\t\t\t} else {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tsb.append(\"(\");\n\t\t\t\tsb.append(fcnname);\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(leftassoc(fcnname,length-1,iter));\n\t\t\t\tsb.append(\" \");\n\t\t\t\tsb.append(iter.next().accept(this));\n\t\t\t\tsb.append(\")\");\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(ISymbol e) throws IVisitor.VisitorException {\n\t\t\t// Symbols do not necessarily have sorts - e.g. if they are function names\n\t\t\tISort sort = typemap.get(e);\n\t\t\tif (!isFormula \u0026\u0026 sort != null \u0026\u0026 sort.isBool()) {\n\t\t\t\tthrow new VisitorException(\"Use of boolean in a term position is not yet implemented in the Simplify adapter\",e.pos()); // FIXME - booleans as terms\n\t\t\t}\n\t\t\t// Simplify does not allow tab, newline, cr in identifiers;\n\t\t\t// these are allowed by SMTLIB.\n\t\t\t// Note that neither simplify nor SMTLIB allows \\ or |\n\t\t\t// All other printable characters are allowed in both.\n\t\t\tString oldName = e.value();\n\t\t\tString newName = fcnNames.get(oldName);\n\t\t\tif (newName != null) {\n\t\t\t\t// There is a direct translation of a pre-defined SMT-LIB name\n\t\t\t\t// into a simplify equivalent - use it.\n\t\t\t} else {\n\t\t\t\t// Use the ? character as an escape\n\t\t\t\tnewName = oldName.replace(\"?\",\"??\").replace(\"\\n\",\"?n\").replace(\"\\r\",\"?r\").replace(\"\\t\",\"?t\");\n\t\t\t\tif (reservedWords.contains(newName)) {\n\t\t\t\t\tnewName = newName + \"?!\";\n\t\t\t\t}\n\t\t\t\tnewName = \"|\" + newName + \"|\";\n\t\t\t}\n\t\t\treturn newName;\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IKeyword e) throws IVisitor.VisitorException {\n\t\t\tthrow new VisitorException(\"Did not expect a Keyword in an expression to be translated\",e.pos());\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IError e) throws IVisitor.VisitorException {\n\t\t\tthrow new VisitorException(\"Did not expect a Error token in an expression to be translated\",e.pos());\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IParameterizedIdentifier e) throws IVisitor.VisitorException {\n\t\t\tif (!isFormula \u0026\u0026 typemap.get(e).isBool()) {\n\t\t\t\tthrow new VisitorException(\"Use of boolean in a term position is not yet implemented in the Simplify adapter\",e.pos()); // FIXME - booleans as terms\n\t\t\t}\n\t\t\t// Since there is no overloading, the head will be a new symbol\n\t\t\t// and we don't need to worry that it collides with a pre- or user-defined\n\t\t\t// function name\n\t\t\tString v = e.headSymbol().accept(this); // This will come back with bars\n\t\t\tif (v.charAt(0) != '|') {\n\t\t\t\tthrow new VisitorException(\"INTERNAL ERROR: Do not expect to ever have a pre-defined name within a parameterized identifier\",e.headSymbol().pos());\n\t\t\t}\n\t\t\tv = v.substring(0,v.length()-1);\n\t\t\tfor (INumeral n: e.numerals()) {\n\t\t\t\tv = v + \"?\" + n.toString();\n\t\t\t}\n\t\t\treturn v + \"|\";\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IForall e) throws IVisitor.VisitorException {\n\t\t\tif (!isFormula) {\n\t\t\t\tthrow new VisitorException(\"Use of forall in a term position is not yet implemented in the Simplify adapter\",e.pos()); // FIXME - booleans as terms\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(\"(FORALL (\");\n\t\t\tfor (IDeclaration d: e.parameters()) {\n\t\t\t\tif (d.sort().isBool()) {\n\t\t\t\t\tthrow new VisitorException(\"Boolean quantifiers are not implemented in the Simplify adapter\",e.pos()); // FIXME - booleans as terms\n\t\t\t\t}\n\t\t\t\tsb.append(d.parameter().accept(this));\n\t\t\t\tsb.append(\" \");\n\t\t\t}\n\t\t\tsb.append(\") \");\n\t\t\tsb.append(e.expr().accept(this));\n\t\t\tsb.append(\")\");\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IExists e) throws IVisitor.VisitorException {\n\t\t\tif (!isFormula) {\n\t\t\t\tthrow new VisitorException(\"Use of exists in a term position is not yet implemented in the Simplify adapter\",e.pos()); // FIXME - booleans as terms\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(\"(EXISTS (\");\n\t\t\tfor (IDeclaration d: e.parameters()) {\n\t\t\t\tif (d.sort().isBool()) {\n\t\t\t\t\tthrow new VisitorException(\"Boolean quantifiers are not implemented in the Simplify adapter\",e.pos()); // FIXME - booleans as terms\n\t\t\t\t}\n\t\t\t\tsb.append(d.accept(this));\n\t\t\t\tsb.append(\" \");\n\t\t\t}\n\t\t\tsb.append(\") \");\n\t\t\tsb.append(e.expr().accept(this));\n\t\t\tsb.append(\")\");\n\t\t\treturn sb.toString();\n\t\t}\n\t\t\n\t\t@Override \n\t\tpublic String visit(IDeclaration e) throws IVisitor.VisitorException {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(e.parameter().accept(this));\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(ILet e) throws IVisitor.VisitorException {\n\t\t\t// Simplify does not have let\n\t\t\t// We can create a new temp variable (or function of any quantified parameters)\n\t\t\t// and then use that.\n\t\t\tfor (IBinding b : e.bindings()) {\n\t\t\t\tString r = b.expr().accept(this);\n\t\t\t\tISort s = typemap.get(b.expr());\n\t\t\t\t// FIXME - don't use toString - also need to map to a unique new temporary\n\t\t\t\tr = (s.isBool()? \"(IFF \" : \"(EQ \") + b.parameter().accept(this) + \" \" + r + \" )\";\n\t\t\t\tconjuncts.add(r);\n\t\t\t}\n\t\t\treturn e.expr().accept(this);\n\t\t\t//throw new VisitorException(\"Use of let is not yet implemented in the Simplify adapter\",e.pos()); // FIXME - let in Simplify\n\t\t}\n\n\t\t@Override \n\t\tpublic String visit(IBinding e) throws IVisitor.VisitorException {\n//\t\t\tStringBuilder sb = new StringBuilder();\n//\t\t\tsb.append(e.parameter().accept(this));\n//\t\t\treturn sb.toString();\n\t\t\tthrow new VisitorException(\"Use of bindings is not yet implemented in the Simplify adapter\",e.pos()); // FIXME - let in Simplify\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IAttribute\u003c?\u003e e) throws VisitorException {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IAttributedExpr e) throws VisitorException {\n\t\t\t// FIXME - ignoring the name - should use a LBL expression\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(\"(LBL \");\n\t\t\tsb.append(e.attributes().get(0).attrValue().toString()); // Use the standard printer FIXME\n\t\t\tsb.append(\" \");\n\t\t\tsb.append(e.expr().accept(this));\n\t\t\tsb.append(\")\");\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(org.smtlib.IResponse.IError e)\n\t\t\t\tthrows VisitorException {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IAsIdentifier e) throws VisitorException {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IScript e) throws VisitorException {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(ICommand e) throws VisitorException {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IFamily s) throws VisitorException {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IAbbreviation s) throws VisitorException {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IApplication s) throws VisitorException {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IFcnSort s) throws VisitorException {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IParameter s) throws VisitorException {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(ILogic s) throws VisitorException {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(ITheory s) throws VisitorException {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IResponse e) throws VisitorException {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IAssertionsResponse e) throws VisitorException {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IAssignmentResponse e) throws VisitorException {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IProofResponse e) throws VisitorException {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IValueResponse e) throws VisitorException {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IUnsatCoreResponse e) throws VisitorException {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String visit(IAttributeList e) throws VisitorException {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\n//\t\t@Override\n//\t\tpublic String visit(IScript e) throws IVisitor.VisitorException {\n//\t\t\tthrow new VisitorException(e,\"Did not expect a Script in an expression to be translated\");\n//\t\t}\n\n//\t\t@Override\n//\t\tpublic String visit(IResponse e) throws IVisitor.VisitorException {\n//\t\t\tthrow new VisitorException(e,\"Did not expect a IResponse in an expression to be translated\");\n//\t\t}\n//\t\t\n\t}\n\n\n}\n",
        "name": "Solver_simplify.java",
        "path": "SMT/src/org/smtlib/solvers/Solver_simplify.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMT/src/org/smtlib/solvers/Solver_simplify.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 210,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires number \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 227,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires number \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 660,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();"
        },
        {
          "limitHit": false,
          "lineNumber": 678,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires iter.hasNext();"
        },
        {
          "limitHit": false,
          "lineNumber": 679,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "\t\t//@ requires length \u003e 0;"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\r\n * This file is part of the SMT plug-in project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.plugin;\r\n\r\n// FIXME implement logic, out, diag, port, relax -- check all options\r\n\r\nimport java.io.File;\r\nimport java.util.Enumeration;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\n\r\nimport org.eclipse.core.runtime.Platform;\r\nimport org.eclipse.jface.preference.IPreferenceStore;\r\nimport org.eclipse.swt.SWT;\r\nimport org.eclipse.swt.custom.CTabFolder;\r\nimport org.eclipse.swt.custom.CTabItem;\r\nimport org.eclipse.swt.widgets.Composite;\r\nimport org.eclipse.swt.widgets.Control;\r\nimport org.eclipse.swt.widgets.Label;\r\nimport org.eclipse.ui.IWorkbench;\r\nimport org.eclipse.ui.IWorkbenchPreferencePage;\r\nimport org.osgi.framework.Bundle;\r\nimport org.smtlib.SMT.Configuration;\r\n\r\n/**\r\n * @author David Cok\r\n * \r\n * This class implements the preference page for the plugin.\r\n * To add a new Preference:\r\n *  - add a String to POptions -- this is the key used in the preference database\r\n *  - add an AbstractPreference for that key to POptions - this specifies the kind of preference (Boolean, String, Choice, ...)\r\n *  - add a PreferenceWidget linked to the AbstractPreference to one of the PreferenceWidget arrays (e.g. options, pluginOptions)\r\n *  - if you create a new array, alter createContents, performOK, performDefaults\r\n */\r\npublic class Preferences extends org.eclipse.jface.preference.PreferencePage \r\nimplements IWorkbenchPreferencePage {\r\n\r\n\t/* (non-Javadoc)\r\n\t * @see org.eclipse.ui.IWorkbenchPreferencePage#init(org.eclipse.ui.IWorkbench)\r\n\t */\r\n\t// FIXME _ what might go in here?\r\n\tpublic void init(IWorkbench workbench) {\r\n\t}\r\n\r\n\t/** This class defines all the items that have a persistent\r\n\t * presence in the Preferences store. */\r\n\tstatic public class POptions {\r\n\t\t/** The prefix to be put on each key. */\r\n\t\tfinal static public String prefix = \"org.smtlib.plugin.\";\r\n\r\n\t\t/** The preference store key for the verbose option. */\r\n\t\tfinal static public String verbosePluginKey = prefix + \"verbosePlugin\";\r\n\r\n\t\t/** The preference store key for the verbose SMT app option. */\r\n\t\tfinal static public String verboseKey = prefix + \"verbose\";\r\n\r\n\t\t/** The preference store key for the verbose SMT solver option. */\r\n\t\tfinal static public String solverVerbosityKey = prefix + \"solverVerbosity\";\r\n\r\n\t\t/** The preference store key for the print-success option. */\r\n\t\tfinal static public String printSuccessKey = prefix + \"printSuccess\";\r\n\r\n\t\t/** The preference store key for the abort-on-error option. */\r\n\t\tfinal static public String abortKey = prefix + \"abort\";\r\n\r\n\t\t/** The preference store key for the print-success option. */\r\n\t\tfinal static public String relaxKey = prefix + \"relax\";\r\n\r\n\t\t/** The preference store key for the print-success option. */\r\n\t\tfinal static public String echoKey = prefix + \"echo\";\r\n\r\n\t\t/** The preference store key for the logic option. */\r\n\t\tfinal static public String logicKey = prefix + \"logic\";\r\n\r\n\t\t/** The preference store key for the logics option. */\r\n\t\tfinal static public String logicsKey = prefix + \"logics\";\r\n\r\n\t\t/** The preference store key for the default solver choice option. */\r\n\t\tfinal static public String defaultSolverKey = prefix + \"defaultSolver\";\r\n\r\n\t\t/** The preference store key for option storing the path to the given solver's executable. */\r\n\t\tfinal static public String execKey(String solver) {\r\n\t\t\treturn prefix + \"execKey_\" + solver;\r\n\t\t}\r\n\t\t// The various option objects\r\n\t\t\r\n\t\tpublic AbstractPreference.BooleanOption verbosePlugin = \r\n\t\t\tnew AbstractPreference.BooleanOption(verbosePluginKey, false, \"verbose plug-in?\", \"If true, progress and debugging information from the plug-in is printed.\");\r\n\r\n\t\tpublic AbstractPreference.BooleanOption verbose = \r\n\t\t\tnew AbstractPreference.BooleanOption(verboseKey, false, \"verbose SMT app?\", \"If true, diagnostic information from the SMT app is printed.\");\r\n\r\n\t\tpublic AbstractPreference.IntOption solverVerbosity = \r\n\t\t\tnew AbstractPreference.IntOption(solverVerbosityKey, 0, \"SMT solver verbosity\", \"Verbosity level of the SMT solver, 0 for quiet\");\r\n\r\n\t\tpublic AbstractPreference.BooleanOption printSuccess = \r\n\t\t\tnew AbstractPreference.BooleanOption(printSuccessKey, true, \"print success?\", \"If true, all command results are printed; if false, all except success are printed.\");\r\n\r\n\t\tpublic AbstractPreference.BooleanOption abort = \r\n\t\t\tnew AbstractPreference.BooleanOption(abortKey, false, \"abort on error?\", \"If true, an error aborts further processing.\");\r\n\r\n\t\tpublic AbstractPreference.BooleanOption echo = \r\n\t\t\tnew AbstractPreference.BooleanOption(echoKey, false, \"echo batch commands?\", \"If true, batch commands are echoed to the output as they are executed\");\r\n\t\tpublic AbstractPreference.BooleanOption relax = \r\n\t\t\tnew AbstractPreference.BooleanOption(relaxKey, false, \"relax conformity?\", \"If true, some not-strictlyu-SMT-LIB enahancements are allowed; if false, SMT-LIB is strictly enforced.\");\r\n\r\n\t\tpublic AbstractPreference.StringOption logics = \r\n\t\t\tnew AbstractPreference.StringOption(logicsKey,\"\",\"Directory containing logic files (if empty, built-in logic files are used)\",\"Directory that contains the files defining SMT-LIB logics and theories\");\r\n\r\n\t\tpublic String[] logicNames = new String[]{};\r\n\t\t{\r\n\t\t\tString logicsDir = logics.getValue();\r\n\t\t\tList\u003cString\u003e logicList = new LinkedList\u003cString\u003e();\r\n\t\t\tif (logicsDir.trim().length() != 0) {\r\n\t\t\t\tFile dir = new File(logicsDir);\r\n\t\t\t\tlogicList.add(\"\");\r\n\t\t\t\tif (dir.isDirectory()) {\r\n\t\t\t\t\tfor (String f : dir.list()) {\r\n\t\t\t\t\t\tif (f.endsWith(org.smtlib.Utils.SUFFIX)) {\r\n\t\t\t\t\t\t\tf = f.substring(0,f.length() - org.smtlib.Utils.SUFFIX.length());\r\n\t\t\t\t\t\t\tif (f.charAt(1) \u003c= 'Z') {\r\n\t\t\t\t\t\t\t\tlogicList.add(f);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else { // FIXME - unify this with findLogic in Activator\r\n\t\t\t\tBundle b = Platform.getBundle(org.smtlib.Utils.PLUGIN_ID);\r\n\t\t\t\t@SuppressWarnings(\"unchecked\")\r\n\t\t\t\tEnumeration\u003cString\u003e e = (Enumeration\u003cString\u003e)b.getEntryPaths(\"logics/\");\r\n\t\t\t\twhile (e.hasMoreElements()) {\r\n\t\t\t\t\tString p = e.nextElement();\r\n\t\t\t\t\tint n = 1 + p.indexOf('/');\r\n\t\t\t\t\tint nn = p.indexOf('.');\r\n\t\t\t\t\tif (nn != -1) logicList.add(p.substring(n,nn));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlogicNames = logicList.toArray(logicNames);\r\n\t\t}\r\n\t\t\r\n\t\t// FIXME - This gets set dynamically when the plugin first starts; changes in the logic path are not\r\n\t\t// changed until the plug-in restarts\r\n\t\t\r\n\t\tpublic AbstractPreference.ChoiceOption logic = dynamicLogicList(logicKey, logics.getValue());\r\n\r\n\t\t/** Names of solvers to include; test must be first */\r\n\t\tpublic static final String[] solverNames = new String[]{org.smtlib.Utils.TEST_SOLVER,\"simplify\",\"yices2\",\"cvc4\",\"z3_4_4\",\"z3_4_3\"};\r\n\t\t\r\n\t\tpublic AbstractPreference.ChoiceOption defaultSolver = \r\n\t\t\tnew AbstractPreference.ChoiceOption(defaultSolverKey,\r\n\t\t\t\t\tsolverNames,\r\n\t\t\t\t\t0,\r\n\t\t\t\t\t\"Default solver to use\",\r\n\t\t\t\"The default solver to use in response to menu commands\");\r\n\r\n\t\tpublic List\u003cAbstractPreference.StringOption\u003e execOptions = new LinkedList\u003cAbstractPreference.StringOption\u003e();\r\n\t\t\r\n\t\tpublic POptions() {\r\n\t\t\t// Skip solverNames[0] (\"test\")\r\n\t\t\tfor (int i = 1; i\u003csolverNames.length; ++i) {\r\n\t\t\t\tString name = solverNames[i];\r\n\t\t\t\texecOptions.add(new AbstractPreference.StringOption(execKey(name),\"\",name + \" executable\",\"File system path to the executable for the \"+name+\" solver\"));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\tpublic static AbstractPreference.ChoiceOption dynamicLogicList(String logicKey, String logicsDir) {\r\n\t\tString[] logicNames = new String[]{};\r\n\t\tFile dir = new File(logicsDir);\r\n\t\tList\u003cString\u003e logicList = new LinkedList\u003cString\u003e();\r\n\t\tlogicList.add(\"\");\r\n\t\tif (dir.isDirectory()) {\r\n\t\t\tfor (String f : dir.list()) {\r\n\t\t\t\tif (f.endsWith(org.smtlib.Utils.SUFFIX)) {\r\n\t\t\t\t\tf = f.substring(0,f.length() - org.smtlib.Utils.SUFFIX.length());\r\n\t\t\t\t\tif (f.charAt(1) \u003c= 'Z') {\r\n\t\t\t\t\t\tlogicList.add(f);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tlogicNames = logicList.toArray(logicNames);\r\n\t\t\r\n\t\treturn\r\n\t\t\tnew AbstractPreference.ChoiceOption(logicKey, logicNames, 0, \"implicit logic:\", \"If set, the logic to set implicitly for each SMT execution.\");\r\n\r\n\t}\r\n\t\r\n\t/** An instance of the object that holds all of the preference store items being used. */\r\n\tstatic POptions poptions = new POptions();\r\n\r\n\t/** This method fills in a Configuration structure whose values are set from\r\n\t * the current preference store settings (which should match those in the UI).\r\n\t * We use the preference store instead of the UI widgets so that this method\r\n\t * works even if the preference page has not yet been generated.  If the \r\n\t * argument is null, a new Configuration structure is allocated; otherwise the\r\n\t * fields of the argument are filled in.  The argument or newly allocated \r\n\t * object is returned.\r\n\t * @param options if not null, the structure to fill in\r\n\t * @return An Configuration structure initialized to the current preference store settings.\r\n\t */\r\n\tstatic public Configuration extractOptions(Configuration smtConfig) {\r\n\t\tif (smtConfig == null) {\r\n\t\t\tsmtConfig = new Configuration();\r\n\t\t}\r\n\t\tActivator.verbose = poptions.verbosePlugin.getValue();\r\n\t\tsmtConfig.verbose = poptions.verbose.getValue() ? 1 : 0;\r\n\t\tsmtConfig.solverVerbosity = poptions.solverVerbosity.getValue();\r\n\t\tsmtConfig.nosuccess = !poptions.printSuccess.getValue();\r\n\t\tsmtConfig.abort = poptions.abort.getValue();\r\n\t\tsmtConfig.echo = poptions.echo.getValue();\r\n\t\tsmtConfig.relax = poptions.relax.getValue();\r\n\t\t\r\n\t\tsmtConfig.logic = null;\r\n//\t\tif (poptions.logic.getIndexValue() == 0) options.logic = null; // FIXME - implement implicit logic?\r\n//\t\telse options.logic = poptions.logic.getStringValue();\r\n\t\t\r\n\t\tsmtConfig.solvername = poptions.defaultSolver.getStringValue();\r\n\t\tsmtConfig.logicPath = poptions.logics.getValue();\r\n\t\tif (smtConfig.logicPath.trim().isEmpty()) smtConfig.logicPath = null;\r\n\t\tif (Activator.verbose) Activator.log.logln(\"Extracted options\");\r\n\t\treturn smtConfig;\r\n\t}\r\n\r\n\r\n\tstatic PreferenceWidget.ChoiceWidget logicChoiceWidget;\r\n\tstatic PreferenceWidget.DirectoryWidget logicPathWidget;\r\n\t/**\r\n\t * An array of the SMT option widgets.\r\n\t */\r\n\tstatic private PreferenceWidget[] options = {\r\n\t\tnew PreferenceWidget.BooleanWidget(poptions.verbose),\r\n\t\tnew PreferenceWidget.IntWidget(poptions.solverVerbosity, new String[]{\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"}),\r\n\t\tnew PreferenceWidget.BooleanWidget(poptions.printSuccess),\r\n\t\tnew PreferenceWidget.BooleanWidget(poptions.abort),\r\n\t\tnew PreferenceWidget.BooleanWidget(poptions.echo),\r\n\t\tnew PreferenceWidget.BooleanWidget(poptions.relax),\r\n\t\tnew PreferenceWidget.ChoiceWidget(poptions.defaultSolver),\r\n\t\tlogicChoiceWidget=new PreferenceWidget.ChoiceWidget(poptions.logic),\r\n\t\tlogicPathWidget=new PreferenceWidget.DirectoryWidget(poptions.logics),\r\n\t};\r\n\t\r\n\tstatic private PreferenceWidget[] solverConfig = new PreferenceWidget[poptions.execOptions.size()];\r\n\r\n\t\r\n\tstatic {\r\n\t\tList\u003cPreferenceWidget\u003e list = new LinkedList\u003cPreferenceWidget\u003e();\r\n\t\tfor (AbstractPreference.StringOption s: poptions.execOptions) {\r\n\t\t\tlist.add(new PreferenceWidget.FileWidget(s));\r\n\t\t}\r\n\t\tsolverConfig = list.toArray(solverConfig);\r\n\t\t// FIXME _ have not been able to get this to work\r\n//\t\tlogicPathWidget.addModifyListener( new ModifyListener() {\r\n//\t\t\tpublic void modifyText(ModifyEvent e) {\r\n//\t\t\t\tif (logicPathWidget != null \u0026\u0026 logicChoiceWidget != null \u0026\u0026 poptions != null \u0026\u0026 poptions.logic != null) {\r\n//\t\t\t\tpoptions.logic = dynamicLogicList(POptions.logicKey,logicPathWidget.value());\r\n//\t\t\t\tlogicChoiceWidget.setChoices(poptions.logic.choices());\r\n//\t\t\t\t}\r\n//\t\t\t}\r\n//\t\t});\r\n\t}\r\n\t\r\n\tstatic final public String getExec(String solver) throws java.lang.Exception {\r\n\t\tString key = POptions.execKey(solver);\r\n\t\tfor (AbstractPreference.StringOption p: poptions.execOptions) {\r\n\t\t\tif (p.key().equals(key)) return p.getValue();\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/**\r\n\t * An array of widgets for plugin options.\r\n\t */\r\n\tstatic final private PreferenceWidget[] pluginOptions = {\r\n\t\tnew PreferenceWidget.BooleanWidget(poptions.verbosePlugin),\r\n\t};\r\n\t\r\n//\tstatic final private PreferenceWidget[] execOptions = new PreferenceWidget[poptions.execOptions.size()];\r\n//\t{\r\n//\t\tint i = 0;;\r\n//\t\tfor (AbstractPreference.StringOption p: poptions.execOptions) {\r\n//\t\t\texecOptions[i++] = new PreferenceWidget.StringWidget(p);\r\n//\t\t}\r\n//\t}\r\n\r\n\t/**\r\n\t * Creates the property page controls and initializes them.\r\n\t * \r\n\t * @param parent The UI object into which to insert the controls\r\n\t * @return The new control that is added to 'parent'\r\n\t */\r\n\tprotected Control createContents(Composite parent) {\r\n\r\n\t\t// Creates the contents of the property page view.\r\n\r\n\t\tCTabFolder tf = new CTabFolder(parent, SWT.TOP|SWT.MULTI|SWT.FLAT);\r\n\t\tCTabItem mainTab = new CTabItem(tf,SWT.NONE,0);\r\n\t\tmainTab.setText(\"General\");\r\n\t\tCTabItem solverTab = new CTabItem(tf,SWT.NONE,1);\r\n\t\tsolverTab.setText(\"Solvers\");\r\n\t\tComposite generalComposite = new Widgets.VComposite(tf);\r\n\t\tmainTab.setControl(generalComposite);\r\n\t\tComposite solverComposite = new Widgets.VComposite(tf);\r\n\t\tsolverTab.setControl(solverComposite);\r\n\t\taddWidgets(solverConfig,solverComposite);\r\n\r\n\t\tComposite composite0 = generalComposite;\r\n\t\tnew Label(composite0, SWT.CENTER).setText(\"SMT version: \" + org.smtlib.Version.version());\r\n\t\tnew Label(composite0, SWT.CENTER)\r\n\t\t.setText(\"These choices are workspace options that apply to every SMT-LIB project.\");\r\n\r\n\t\tnew Widgets.LabeledSeparator(composite0, \"Configuration relating to the plugin\");\r\n\t\taddWidgets(pluginOptions, composite0);\r\n\t\tnew Widgets.LabeledSeparator(composite0, \"Configuration relating to SMT\");\r\n\t\taddWidgets(options, composite0);\r\n\r\n\t\ttf.showItem(mainTab);\r\n\t\ttf.setSelection(mainTab);\r\n\t\treturn composite0;\r\n\r\n\t}\r\n\r\n//\t/**\r\n//\t * Constructs the view of the property page by adding different features like\r\n//\t * labels, and setting the layout. Just a helper to \u003ccode\u003ecreateContents()\r\n//\t * \u003c/code\u003e.\r\n//\t * \r\n//\t * @param parent The parent composite to which the controls are added\r\n//\t * @return The resulting control that defined the looking of the property page\r\n//\t */\r\n//\tprivate Control addControl(Composite parent) {\r\n//\t\tComposite composite0 = new Widgets.VComposite(parent);\r\n//\r\n//\t\tnew Label(composite0, SWT.CENTER).setText(\"SMT version: \" + org.smtlib.Utils.SW_VERSION);\r\n//\t\tnew Label(composite0, SWT.CENTER)\r\n//\t\t.setText(\"These options are workspace options that apply to every SMT-LIB project.\");\r\n//\t\t//  Composite composite0 = new Widgets.HComposite(composite0a, 2);\r\n//\t\t//  Composite composite1 = new Widgets.VComposite(composite0);\r\n//\t\t//  Composite composite2a = new Widgets.VComposite(composite0);\r\n//\t\t//  Composite composite2 = new Widgets.HComposite(composite2a, 2);\r\n//\t\t//  Composite composite3 = new Widgets.VComposite(composite2);\r\n//\t\t//  Composite composite4 = new Widgets.VComposite(composite2);\r\n//\r\n//\t\t//    new Widgets.LabeledSeparator(composite0, \"Configuration relating to Eclipse\");\r\n//\t\t//    addWidgets(eclipseOptions, composite0);\r\n//\t\t//    new Widgets.LabeledSeparator(composite0, \"Configuration relating to Java\");\r\n//\t\t//    addWidgets(javaOptions, composite0);\r\n//\t\tnew Widgets.LabeledSeparator(composite0, \"Configuration relating to the plugin\");\r\n//\t\taddWidgets(pluginOptions, composite0);\r\n//\t\tnew Widgets.LabeledSeparator(composite0, \"Configuration relating to SMT\");\r\n//\t\taddWidgets(options, composite0);\r\n//\t\t//    new Widgets.LabeledSeparator(composite0, \"Configuration for debugging\");\r\n//\t\t//    addWidgets(debugOptions, composite0);\r\n//\r\n//\t\treturn composite0;\r\n//\t}\r\n\r\n\t/**\r\n\t * @see org.eclipse.jface.preference.IPreferencePage#performOk()\r\n\t */\r\n\tpublic boolean performOk() {\r\n\t\t// When OK is pressed, set all the options selected.\r\n\t\tsetOptionValue(pluginOptions);\r\n\t\tsetOptionValue(options);\r\n\t\tsetOptionValue(solverConfig);\r\n\r\n\t\tif (false) {\r\n\t\t\t// FIXME _ hard coded array positions is fragile\r\n\t\t\tpoptions.logic = dynamicLogicList(POptions.logicKey,logicPathWidget.value());\r\n\t\t\tlogicChoiceWidget.setChoices(poptions.logic.choices());\r\n\t\t}\r\n\t\tAbstractPreference.notifyListeners();\r\n\t\treturn true;\r\n\t}\r\n\r\n\tpublic void performDefaults() {\r\n\t\t// When OK is pressed, set all the options selected.    \r\n\t\tsetDefaults(pluginOptions);\r\n\t\tsetDefaults(options);\r\n\t\tsetDefaults(solverConfig);\r\n\t}\r\n\r\n\t/** Calls setDefault for each widget in the list\r\n\t * \r\n\t * @param ws an array of widgets to be processed\r\n\t */\r\n\t//@ requires ws != null;\r\n\t//@ requires \\nonnullelements(ws);\r\n\tpublic void setDefaults(PreferenceWidget[] ws) {\r\n\t\tfor (int i = 0; i\u003cws.length; ++i) {\r\n\t\t\tws[i].setDefault();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Calls 'setOptionValue' on all the items in the array,\r\n\t * so that the stored options are set from the UI\r\n\t * @param ws An array of PreferenceWidget items \r\n\t */\r\n\t//@ requires ws != null;\r\n\t//@ requires \\nonnullelements(ws);\r\n\tpublic void setOptionValue(PreferenceWidget[] ws) {\r\n\t\tfor (int i=0; i\u003cws.length; ++i) {\r\n\t\t\tws[i].setOptionValue();\r\n\t\t}\r\n\t}\r\n\r\n\t// Inherited method\r\n\tprotected IPreferenceStore doGetPreferenceStore() {\r\n\t\treturn Activator.getDefault().getPreferenceStore();\r\n\t}\r\n\r\n\t// Default implementation does a performOk()\r\n\t//public void performApply();\r\n\r\n\t// Default implementation does nothing and returns true\r\n\t//public boolean performCancel();\r\n\r\n\t/* (non-Javadoc)\r\n\t * @see org.eclipse.jface.dialogs.IDialogPage#performHelp()\r\n\t */\r\n\tpublic void performHelp() {}\r\n\r\n\t/**\r\n\t * Calls 'addWidget' on all the items in the list of PreferenceWidgets, in\r\n\t * order to add them to the given composite.\r\n\t * @param ws    The list of widgets to be added\r\n\t * @param composite The composite to add them to\r\n\t */\r\n\t//@ requires ws != null \u0026\u0026 composite != null;\r\n\t//@ requires \\nonnullelements(ws);\r\n\tpublic void addWidgets(PreferenceWidget[] ws, Composite composite) {\r\n\t\taddWidgets(ws,0,ws.length,composite);\r\n\t}\r\n\r\n\t/**\r\n\t * Calls 'addWidget' on some of the items in the list of PreferenceWidgets, in\r\n\t * order to add them to the given composite.\r\n\t * @param ws    The list of widgets to be added\r\n\t * @param offset The index in the array at which to begin\r\n\t * @param num The number of widgets to add\r\n\t * @param composite The composite to add them to\r\n\t */\r\n\t//@ requires ws != null \u0026\u0026 composite != null;\r\n\t//@ requires offset \u003e= 0 \u0026\u0026 offset \u003c ws.length;\r\n\t//@ requires num \u003e= 0 \u0026\u0026 offset + num \u003c ws.length;\r\n\t//@ requires \\nonnullelements(ws);\r\n\tpublic void addWidgets(PreferenceWidget[] ws, int offset, int num, Composite composite) {\r\n\t\tfor (int i=0; i\u003cnum; ++i) {\r\n\t\t\tws[offset+i].addWidget(composite);\r\n\t\t}\r\n\t}\r\n}\r\n",
        "name": "Preferences.java",
        "path": "SMTPlugin/src/org/smtlib/plugin/Preferences.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMTPlugin/src/org/smtlib/plugin/Preferences.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 390,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires ws != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 391,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires \\nonnullelements(ws);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 403,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires ws != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 404,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires \\nonnullelements(ws);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 433,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires ws != null \u0026\u0026 composite != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 434,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires \\nonnullelements(ws);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 447,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires ws != null \u0026\u0026 composite != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 448,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires offset \u003e= 0 \u0026\u0026 offset \u003c ws.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 449,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires num \u003e= 0 \u0026\u0026 offset + num \u003c ws.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 450,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires \\nonnullelements(ws);\r"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\r\n * This file is part of the SMT plugin project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.plugin;\r\n\r\nimport java.io.IOException;\r\nimport java.io.PrintStream;\r\n\r\nimport org.eclipse.core.runtime.ILog;\r\nimport org.eclipse.core.runtime.Plugin;\r\nimport org.eclipse.core.runtime.Status;\r\nimport org.eclipse.swt.graphics.Color;\r\nimport org.eclipse.ui.console.ConsolePlugin;\r\nimport org.eclipse.ui.console.IConsole;\r\nimport org.eclipse.ui.console.IConsoleManager;\r\nimport org.eclipse.ui.console.MessageConsole;\r\nimport org.eclipse.ui.console.MessageConsoleStream;\r\nimport org.smtlib.IResponse;\r\n\r\n/** This class provides Log.IListener implementation that listens\r\n * to messages written through methods in the plug-in Log and sends them to the Eclipse console;\r\n * also listens to messages written through the application log.\r\n */\r\npublic class ConsoleLogger implements org.smtlib.plugin.Log.IListener, org.smtlib.Log.IListener {\r\n\r\n\t/** Creates a new ConsoleLogger utility object\r\n\t * \r\n\t * @param consoleName The name of the console to be logged to\r\n\t */\r\n\t//@ requires consoleName != null;\r\n\t//@ requires Activator.plugin != null;\r\n\t//@ modifies \\nothing;\r\n\t//@ ensures \\result.consoleName == consoleName;\r\n\tpublic ConsoleLogger(/*@NonNull*/ String consoleName) {\r\n\t\tthis.consoleName = consoleName;\r\n\t\tPlugin plugin = Activator.getDefault();\r\n\t\tthis.pluginLog = plugin.getLog();\r\n\t\tthis.pluginID = plugin.getBundle().getSymbolicName();\r\n\t}\r\n\r\n\t// This model variable models the content of the material\r\n\t// sent to the log.\r\n\t//@ model public String content;\r\n\r\n\t/** The name of the console that this plugin writes to. */\r\n\t//@ constraint \\not_modified(consoleName);\r\n\t//@ spec_public\r\n\t//@ non_null\r\n\t/*@NonNull*/\r\n\tfinal private String consoleName;\r\n\r\n\t/** The ILog of the plugin that this ConsoleLogger object connects to */\r\n\t//@ constraint \\not_modified(pluginLog);\r\n\t//@ invariant pluginLog != null;\r\n\t//@ spec_public\r\n\tfinal private ILog pluginLog;\r\n\r\n\t/** The id of the plugin using this log */\r\n\t//@ constraint \\not_modified(pluginID);\r\n\t//@ invariant pluginID != null;\r\n\t//@ spec_public\r\n\t/*@NonNull*/\r\n\tfinal private String pluginID;\r\n\r\n\t/** Cached value of the stream to use to write to the console */\r\n\t/*@Nullable*/\r\n\tprivate MessageConsoleStream stream = null;\r\n\t//@ private constraint \\old(stream) != null ==\u003e \\not_modified(stream);\r\n\r\n\t/** The associated PrintStream, lazily initialized */\r\n\t/*@Nullable*/\r\n\tprivate PrintStream printStream = null;\r\n\r\n\t/** Creates, if necessary, and returns an instance of\r\n\t *  the stream to use to write to the console\r\n\t * @return The stream value to use\r\n\t */\r\n\t//@ modifies stream;\r\n\t//@ ensures \\result != null;\r\n\t//@ ensures \\result == stream;\r\n\tpublic MessageConsoleStream getConsoleStream() {\r\n\t\tif (stream == null) {\r\n\t\t\t/*@Mutable*/ MessageConsole console = null;\r\n\t\t\tIConsoleManager consoleManager = ConsolePlugin.getDefault().getConsoleManager();\r\n\t\t\t/*@Mutable*/ IConsole[] existing = consoleManager.getConsoles();\r\n\t\t\tfor (int i=0; i\u003cexisting.length; ++i) {\r\n\t\t\t\tif (existing[i].getName().equals(consoleName)) {\r\n\t\t\t\t\tconsole = (/*@Mutable*/ MessageConsole)existing[i];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (console == null) {\r\n\t\t\t\tconsole = new MessageConsole(consoleName,null);\r\n\t\t\t\tconsoleManager.addConsoles(new IConsole[]{console});\r\n\t\t\t}\r\n\t\t\tstream = console.newMessageStream();\r\n\t\t}\r\n\t\treturn stream;\r\n\t}\r\n\r\n\t/** Color to use for error messages */\r\n\t// TODO - should get this color from the system preferences\r\n\tstatic final private Color errorColor = new Color(null,255,0,0);\r\n\tstatic final private Color diagColor = new Color(null,0,0,255);\r\n\r\n\t/**\r\n\t * Records an informational message\r\n\t * @param msg The message to log\r\n\t */\r\n\t//@ requires msg != null;\r\n\t//@ modifies content, stream;\r\n\t@Override\r\n\tpublic void log(String msg) {\r\n\t\tgetConsoleStream().print(msg);\r\n\t}\r\n\r\n\t/**\r\n\t * Records an informational message, adding a newline\r\n\t * @param msg The message to log\r\n\t */\r\n\t//@ requires msg != null;\r\n\t//@ modifies content, stream;\r\n\t@Override\r\n\tpublic void logln(String msg) {\r\n\t\tgetConsoleStream().println(msg);\r\n\t}\r\n\r\n\t/**\r\n\t * Records an error message, writing it to the console and the plug-in error log;\r\n\t * adds line separator\r\n\t * @param msg The message to log\r\n\t * @param e An associated exception (may be null)\r\n\t */\r\n\t// TODO - must this be called from the UI thread (because it sets the color)?\r\n\t//@ modifies content;\r\n\t@Override\r\n\tpublic void errorlog(/*@NonNull*/String msg, /*@Nullable*/ Throwable e) {\r\n\t\t// Always put errors in the plug-in Error log\r\n\t\tpluginLog.log(\r\n\t\t\t\tnew Status(Status.ERROR, \r\n\t\t\t\t\t\tpluginID,\r\n\t\t\t\t\t\tStatus.OK, msg, e));\r\n\t\tMessageConsoleStream cs = getConsoleStream();\r\n\t\tColor c = cs.getColor();\r\n\t\tcs.setColor(errorColor);\r\n\t\tcs.println(msg);\r\n\t\tif (e != null) e.printStackTrace(this.stream());\r\n\t\tcs.setColor(c);\r\n\t}\r\n\r\n\t/** Flushes the associated console stream */\r\n\tpublic void flush() throws IOException {\r\n\t\tgetConsoleStream().flush();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Creates a PrintStream that, when written to, writes to the Eclipse Console\r\n\t * of the current log object\r\n\t * \r\n\t * @return a PrintStream connected to the Eclipse Console\r\n\t */\r\n\t//@ modifies printStream, stream;\r\n\t//@ ensures \\result != null;\r\n\t//@ ensures \\result == printStream;\r\n\tpublic PrintStream stream() {\r\n\t\tif (printStream == null) printStream = new PrintStream(getConsoleStream());\r\n\t\treturn printStream;\r\n\t}\r\n\r\n\r\n\t/** This listens to and echos to the console regular log messages from the SMT application;\r\n\t *  no additional line separators added. */\r\n\t@Override\r\n\tpublic void logOut(String msg) {\r\n\t\tlog(msg);\r\n\t}\r\n\r\n\t/** This listens to and echos to the console regular log messages from the SMT application;\r\n\t *  adds a line separator */\r\n\t@Override\r\n\tpublic void logOut(IResponse response) {\r\n\t\tlogln(Activator.smtConfiguration.defaultPrinter.toString(response));\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void indent(String prompt) {\r\n\t}\r\n\r\n\r\n\t/** This listens to messages from the SMT application - errors are caught by the Problem listener,\r\n\t * so they are not logged here, unless verbose is requested.  Also SMT-LIB errors are not turned into\r\n\t * Error log entries either. */\r\n\t@Override\r\n\tpublic void logError(IResponse.IError response) {\r\n\t\tlogError(Activator.smtConfiguration.defaultPrinter.toString(response));\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void logError(String msg) {\r\n\t\tif (Activator.verbose) {\r\n\t\t\tMessageConsoleStream cs = getConsoleStream();\r\n//\t\t\tColor c = cs.getColor();\r\n//\t\t\tcs.setColor(errorColor);\r\n\t\t\tcs.println(msg);\r\n//\t\t\tcs.setColor(c); // FIXME - causes \"Invalid Thread access\" errors when logging errors from a computational thread\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/** This listens to and echos to the console diagnostic messages from the SMT application.\r\n\t *  Adds a line separator */\r\n\t@Override\r\n\tpublic void logDiag(String msg) {\r\n\t\tMessageConsoleStream cs = getConsoleStream();\r\n//\t\tColor c = cs.getColor();\r\n//\t\tcs.setColor(diagColor);\r\n\t\tcs.println(msg);\r\n//\t\tcs.setColor(c); // FIXME - causes \"Invalid Thread access\" errors when logging errors from a computational thread\r\n\t}\r\n}\r\n\r\n",
        "name": "ConsoleLogger.java",
        "path": "SMTPlugin/src/org/smtlib/plugin/ConsoleLogger.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMTPlugin/src/org/smtlib/plugin/ConsoleLogger.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 31,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires consoleName != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 32,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires Activator.plugin != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 34,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result.consoleName == consoleName;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 80,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 81,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result == stream;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 111,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires msg != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 122,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires msg != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 165,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 166,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures \\result == printStream;\r"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a109b104f3c294d322de0aa12d2b70b96dcf51f4"
        },
        "content": "/*\r\n * This file is part of the SMT plugin project.\r\n * Copyright 2010 David R. Cok\r\n * Created August 2010\r\n */\r\npackage org.smtlib.plugin;\r\nimport java.util.List;\r\n\r\nimport org.eclipse.core.resources.IFile;\r\nimport org.eclipse.jface.action.IAction;\r\nimport org.eclipse.jface.viewers.ISelection;\r\nimport org.eclipse.swt.widgets.Shell;\r\nimport org.eclipse.ui.IActionDelegate;\r\nimport org.eclipse.ui.IObjectActionDelegate;\r\nimport org.eclipse.ui.IWorkbenchPart;\r\n\r\n/** This class is an abstract base class for implementing popup menu item actions.\r\n * @author David R. Cok\r\n */\r\nabstract public class ContextAction implements IObjectActionDelegate {\r\n    /** A cached value of the most recent selection */\r\n\t/*@Nullable*/ protected ISelection selection;\r\n\r\n    /** A cached value of the shell that holds the most recent editor (actually IWorkbenchPart) */\r\n    /*@Nullable*/ protected Shell shell;\r\n\t\r\n\t/**\r\n\t * Constructor, with no initialization\r\n\t */\r\n\tpublic ContextAction() {\r\n\t\tsuper();\r\n\t}\r\n\r\n\t/**\r\n\t * @see IObjectActionDelegate#setActivePart(IAction, IWorkbenchPart)\r\n\t */\r\n\t//@ ensures this.shell != null;\r\n    @Override\r\n\tpublic void setActivePart(IAction action, IWorkbenchPart targetPart) {\r\n\t\tshell = targetPart.getSite().getShell();\r\n\t}\r\n\r\n\t/**\r\n\t * @see IActionDelegate#run(IAction)\r\n\t */\r\n    @Override\r\n\tabstract public void run(IAction action);\r\n\r\n\t/**\r\n\t * @see IActionDelegate#selectionChanged(IAction, ISelection)\r\n\t */\r\n\t//@ ensures this.selection != null;\r\n    @Override\r\n\tpublic void selectionChanged(IAction action, ISelection selection) {\r\n        this.selection = selection;\r\n\t}\r\n\r\n\t/** Runs the default solver on the selected files */\r\n\tstatic public class RunSolver extends ContextAction {\r\n\t\t/**\r\n\t\t * @see IActionDelegate#run(IAction)\r\n\t\t */\r\n\t    @Override\r\n\t\tpublic void run(IAction action) {\r\n    \t\ttry {\r\n    \t\t\tfinal List\u003cString\u003e solvers = Activator.utils.getSolvers(action.getId());\r\n    \t\t\tList\u003cIFile\u003e files = Activator.utils.getSelectedFiles(selection,null,shell);\r\n    \t\t\tActivator.utils.text = null; // TODO - setting 'text' through side-effects is a bad design\r\n        \t\tif (files.isEmpty()) files = Activator.utils.resources(selection,null,shell); // sets Activator.utils.text also\r\n        \t\tif (files.isEmpty()) {\r\n        \t\t\tActivator.utils.showMessageInUI(shell,\"SMT Run Solver\",\r\n        \t\t\t\t\t\"Failed to find a resource on which to run a solver (select one or more files or an editor)\");\r\n        \t\t\treturn;\r\n        \t\t}\r\n    \t\t\tActivator.utils.runJobs(solvers,files);\r\n    \t\t} catch (Exception e) {\r\n    \t\t\tActivator.utils.topLevelException(shell,\"ContextAction.RunSolver\",e);\r\n    \t\t}\r\n        }\r\n\t}\r\n\t\r\n\t\r\n\t/** Deletes SMT markers on selected resources */\r\n\tstatic public class DeleteMarkers extends ContextAction {\r\n\t\t/**\r\n\t\t * @see IActionDelegate#run(IAction)\r\n\t\t */\r\n\t    @Override\r\n\t\tpublic void run(IAction action) {\r\n            try {\r\n                Activator.utils.deleteMarkersInSelection(selection,null,shell);\r\n            } catch (Exception e) {\r\n                Activator.utils.topLevelException(shell,\"ContextAction.DeleteMarkers\",e);\r\n            }\r\n\t\t}\r\n\t}\r\n\r\n// Not included because the ViewLogic command uses selected text; it does not make sense\r\n// to run it on a file.\r\n//\t/** Shows the content of the SMT logic or theory whose name is selected */\r\n//\tstatic public class ViewLogic extends ContextAction {\r\n//\t\t/**\r\n//\t\t * @see IActionDelegate#run(IAction)\r\n//\t\t */\r\n//\t\tpublic void run(IAction action) {\r\n//        \tActivator.utils.viewLogic(shell,selection);\r\n//\t\t}\r\n//\t}\r\n\r\n}\r\n\r\n",
        "name": "ContextAction.java",
        "path": "SMTPlugin/src/org/smtlib/plugin/ContextAction.java",
        "url": "/github.com/smtlib/jSMTLIB/-/blob/SMTPlugin/src/org/smtlib/plugin/ContextAction.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 36,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures this.shell != null;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 51,
          "offsetAndLengths": [
            [
              1,
              12
            ]
          ],
          "preview": "\t//@ ensures this.selection != null;\r"
        }
      ],
      "repository": {
        "name": "github.com/smtlib/jSMTLIB",
        "url": "/github.com/smtlib/jSMTLIB"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 164,
  "ElapsedMilliseconds": 65,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
