{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/sdujicun/FastShapeletSelection lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23f09e63981f603a63dcb243669b6c2b25b6d850"
        },
        "content": "/*\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n/*\n *    Utils.java\n *    Copyright (C) 1999-2012 University of Waikato, Hamilton, New Zealand\n *\n */\n\npackage weka.core;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.lang.reflect.Array;\nimport java.net.URL;\nimport java.text.BreakIterator;\nimport java.util.Enumeration;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Vector;\n\n/**\n * Class implementing some simple utility methods.\n *\n * @author Eibe Frank \n * @author Yong Wang \n * @author Len Trigg \n * @author Julien Prados\n * @version $Revision: 9736 $\n */\npublic final class Utils\n  implements RevisionHandler {\n\n  /** The natural logarithm of 2. */\n  public static double log2 = Math.log(2);\n\n  /** The small deviation allowed in double comparisons. */\n  public static double SMALL = 1e-6;\n  \n  /**\n   * Tests if the given value codes \"missing\".\n   *\n   * @param val the value to be tested\n   * @return true if val codes \"missing\"\n   */\n  public static boolean isMissingValue(double val) {\n\n    return Double.isNaN(val);\n  }\n\n  /**\n   * Returns the value used to code a missing value.  Note that\n   * equality tests on this value will always return false, so use\n   * isMissingValue(double val) for testing..\n   *\n   * @return the value used as missing value.\n   */\n  public static double missingValue() {\n    \n    return Double.NaN;\n  }\n\n  /**\n   * Casting an object without \"unchecked\" compile-time warnings.\n   * Use only when absolutely necessary (e.g. when using clone()).\n   */\n  @SuppressWarnings(\"unchecked\")\n    public static \u003cT\u003e T cast(Object x) {\n    return (T) x;\n  }\n  \n  /**\n   * Reads properties that inherit from three locations. Properties\n   * are first defined in the system resource location (i.e. in the\n   * CLASSPATH).  These default properties must exist. Properties optionally\n   * defined in the user properties location (WekaPackageManager.PROPERTIES_DIR) \n   * override default settings. Properties defined in the current directory (optional)\n   * override all these settings.\n   *\n   * @param resourceName the location of the resource that should be\n   * loaded.  e.g.: \"weka/core/Utils.props\". (The use of hardcoded\n   * forward slashes here is OK - see\n   * jdk1.1/docs/guide/misc/resources.html) This routine will also\n   * look for the file (in this case) \"Utils.props\" in the users home\n   * directory and the current directory.\n   * @return the Properties\n   * @exception Exception if no default properties are defined, or if\n   * an error occurs reading the properties files.  \n   */\n  public static Properties readProperties(String resourceName)\n    throws Exception {\n\n    Properties defaultProps = new Properties();\n    try {\n      // Apparently hardcoded slashes are OK here\n      // jdk1.1/docs/guide/misc/resources.html\n      Utils utils = new Utils();\n      Enumeration\u003cURL\u003e urls = utils.getClass().getClassLoader().getResources(resourceName);\n      boolean first = true;\n      while (urls.hasMoreElements()) {\n\tURL url = urls.nextElement();\n\tif (first) {\n\t  defaultProps.load(url.openStream());\n\t  first = false;\n\t}\n\telse {\n\t  Properties props = new Properties(defaultProps);\n\t  props.load(url.openStream());\n\t  defaultProps = props;\n\t}\n      }\n    } catch (Exception ex) {\n      System.err.println(\"Warning, unable to load properties file(s) from \"\n\t\t\t +\"system resource (Utils.java): \" + resourceName);\n    }\n\n    // Hardcoded slash is OK here\n    // eg: see jdk1.1/docs/guide/misc/resources.html\n    int slInd = resourceName.lastIndexOf('/');\n    if (slInd != -1) {\n      resourceName = resourceName.substring(slInd + 1);\n    }\n\n    /* Allow a properties file in the WekaPackageManager.PROPERTIES_DIR to override\n    Properties userProps = new Properties(defaultProps);\n    if (!WekaPackageManager.PROPERTIES_DIR.exists()) {\n      WekaPackageManager.PROPERTIES_DIR.mkdir();\n    }\n    File propFile = new File(WekaPackageManager.PROPERTIES_DIR.toString()\n                             + File.separator\n                             + resourceName);\n\n    if (propFile.exists()) {\n      try {\n        userProps.load(new FileInputStream(propFile));\n      } catch (Exception ex) {\n        throw new Exception(\"Problem reading user properties: \" + propFile);\n      }\n    }\n\n    // Allow a properties file in the current directory to override\n    Properties localProps = new Properties(userProps);\n    propFile = new File(resourceName);\n    if (propFile.exists()) {\n      try {\n        localProps.load(new FileInputStream(propFile));\n      } catch (Exception ex) {\n        throw new Exception(\"Problem reading local properties: \" + propFile);\n      }\n    }\n    */\n    return defaultProps;\n  }\n\n  /**\n   * Returns the correlation coefficient of two double vectors.\n   *\n   * @param y1 double vector 1\n   * @param y2 double vector 2\n   * @param n the length of two double vectors\n   * @return the correlation coefficient\n   */\n  public static final double correlation(double y1[],double y2[],int n) {\n\n    int i;\n    double av1 = 0.0, av2 = 0.0, y11 = 0.0, y22 = 0.0, y12 = 0.0, c;\n    \n    if (n \u003c= 1) {\n      return 1.0;\n    }\n    for (i = 0; i \u003c n; i++) {\n      av1 += y1[i];\n      av2 += y2[i];\n    }\n    av1 /= (double) n;\n    av2 /= (double) n;\n    for (i = 0; i \u003c n; i++) {\n      y11 += (y1[i] - av1) * (y1[i] - av1);\n      y22 += (y2[i] - av2) * (y2[i] - av2);\n      y12 += (y1[i] - av1) * (y2[i] - av2);\n    }\n    if (y11 * y22 == 0.0) {\n      c=1.0;\n    } else {\n      c = y12 / Math.sqrt(Math.abs(y11 * y22));\n    }\n    \n    return c;\n  }\n\n  /**\n   * Removes all occurrences of a string from another string.\n   *\n   * @param inString the string to remove substrings from.\n   * @param substring the substring to remove.\n   * @return the input string with occurrences of substring removed.\n   */\n  public static String removeSubstring(String inString, String substring) {\n\n    StringBuffer result = new StringBuffer();\n    int oldLoc = 0, loc = 0;\n    while ((loc = inString.indexOf(substring, oldLoc))!= -1) {\n      result.append(inString.substring(oldLoc, loc));\n      oldLoc = loc + substring.length();\n    }\n    result.append(inString.substring(oldLoc));\n    return result.toString();\n  }\n\n  /**\n   * Replaces with a new string, all occurrences of a string from \n   * another string.\n   *\n   * @param inString the string to replace substrings in.\n   * @param subString the substring to replace.\n   * @param replaceString the replacement substring\n   * @return the input string with occurrences of substring replaced.\n   */\n  public static String replaceSubstring(String inString, String subString,\n\t\t\t\t\tString replaceString) {\n\n    StringBuffer result = new StringBuffer();\n    int oldLoc = 0, loc = 0;\n    while ((loc = inString.indexOf(subString, oldLoc))!= -1) {\n      result.append(inString.substring(oldLoc, loc));\n      result.append(replaceString);\n      oldLoc = loc + subString.length();\n    }\n    result.append(inString.substring(oldLoc));\n    return result.toString();\n  }\n\n\n  /**\n   * Pads a string to a specified length, inserting spaces on the left\n   * as required. If the string is too long, characters are removed (from\n   * the right).\n   *\n   * @param inString the input string\n   * @param length the desired length of the output string\n   * @return the output string\n   */\n  public static String padLeft(String inString, int length) {\n\n    return fixStringLength(inString, length, false);\n  }\n  \n  /**\n   * Pads a string to a specified length, inserting spaces on the right\n   * as required. If the string is too long, characters are removed (from\n   * the right).\n   *\n   * @param inString the input string\n   * @param length the desired length of the output string\n   * @return the output string\n   */\n  public static String padRight(String inString, int length) {\n\n    return fixStringLength(inString, length, true);\n  }\n  \n  /**\n   * Pads a string to a specified length, inserting spaces as\n   * required. If the string is too long, characters are removed (from\n   * the right).\n   *\n   * @param inString the input string\n   * @param length the desired length of the output string\n   * @param right true if inserted spaces should be added to the right\n   * @return the output string\n   */\n  private static /*@pure@*/ String fixStringLength(String inString, int length,\n\t\t\t\t\tboolean right) {\n\n    if (inString.length() \u003c length) {\n      while (inString.length() \u003c length) {\n\tinString = (right ? inString.concat(\" \") : \" \".concat(inString));\n      }\n    } else if (inString.length() \u003e length) {\n      inString = inString.substring(0, length);\n    }\n    return inString;\n  }\n \n  /**\n   * Rounds a double and converts it into String.\n   *\n   * @param value the double value\n   * @param afterDecimalPoint the (maximum) number of digits permitted\n   * after the decimal point\n   * @return the double as a formatted string\n   */\n  public static /*@pure@*/ String doubleToString(double value, int afterDecimalPoint) {\n    \n    StringBuffer stringBuffer;\n    double temp;\n    int dotPosition;\n    long precisionValue;\n    \n    temp = value * Math.pow(10.0, afterDecimalPoint);\n    if (Math.abs(temp) \u003c Long.MAX_VALUE) {\n      precisionValue = \t(temp \u003e 0) ? (long)(temp + 0.5) \n                                   : -(long)(Math.abs(temp) + 0.5);\n      if (precisionValue == 0) {\n\tstringBuffer = new StringBuffer(String.valueOf(0));\n      } else {\n\tstringBuffer = new StringBuffer(String.valueOf(precisionValue));\n      }\n      if (afterDecimalPoint == 0) {\n\treturn stringBuffer.toString();\n      }\n      dotPosition = stringBuffer.length() - afterDecimalPoint;\n      while (((precisionValue \u003c 0) \u0026\u0026 (dotPosition \u003c 1)) ||\n\t     (dotPosition \u003c 0)) {\n\tif (precisionValue \u003c 0) {\n\t  stringBuffer.insert(1, '0');\n\t} else {\n\t  stringBuffer.insert(0, '0');\n\t}\n\tdotPosition++;\n      }\n      stringBuffer.insert(dotPosition, '.');\n      if ((precisionValue \u003c 0) \u0026\u0026 (stringBuffer.charAt(1) == '.')) {\n\tstringBuffer.insert(1, '0');\n      } else if (stringBuffer.charAt(0) == '.') {\n\tstringBuffer.insert(0, '0');\n      }\n      int currentPos = stringBuffer.length() - 1;\n      while ((currentPos \u003e dotPosition) \u0026\u0026\n\t     (stringBuffer.charAt(currentPos) == '0')) {\n\tstringBuffer.setCharAt(currentPos--, ' ');\n      }\n      if (stringBuffer.charAt(currentPos) == '.') {\n\tstringBuffer.setCharAt(currentPos, ' ');\n      }\n      \n      return stringBuffer.toString().trim();\n    }\n    return new String(\"\" + value);\n  }\n\n  /**\n   * Rounds a double and converts it into a formatted decimal-justified String.\n   * Trailing 0's are replaced with spaces.\n   *\n   * @param value the double value\n   * @param width the width of the string\n   * @param afterDecimalPoint the number of digits after the decimal point\n   * @return the double as a formatted string\n   */\n  public static /*@pure@*/ String doubleToString(double value, int width,\n\t\t\t\t      int afterDecimalPoint) {\n    \n    String tempString = doubleToString(value, afterDecimalPoint);\n    char[] result;\n    int dotPosition;\n\n    if ((afterDecimalPoint \u003e= width) \n        || (tempString.indexOf('E') != -1)) { // Protects sci notation\n      return tempString;\n    }\n\n    // Initialize result\n    result = new char[width];\n    for (int i = 0; i \u003c result.length; i++) {\n      result[i] = ' ';\n    }\n\n    if (afterDecimalPoint \u003e 0) {\n      // Get position of decimal point and insert decimal point\n      dotPosition = tempString.indexOf('.');\n      if (dotPosition == -1) {\n\tdotPosition = tempString.length();\n      } else {\n\tresult[width - afterDecimalPoint - 1] = '.';\n      }\n    } else {\n      dotPosition = tempString.length();\n    }\n    \n\n    int offset = width - afterDecimalPoint - dotPosition;\n    if (afterDecimalPoint \u003e 0) {\n      offset--;\n    }\n\n    // Not enough room to decimal align within the supplied width\n    if (offset \u003c 0) {\n      return tempString;\n    }\n\n    // Copy characters before decimal point\n    for (int i = 0; i \u003c dotPosition; i++) {\n      result[offset + i] = tempString.charAt(i);\n    }\n\n    // Copy characters after decimal point\n    for (int i = dotPosition + 1; i \u003c tempString.length(); i++) {\n      result[offset + i] = tempString.charAt(i);\n    }\n\n    return new String(result);\n  }\n\n  /**\n   * Returns the basic class of an array class (handles multi-dimensional\n   * arrays).\n   * @param c        the array to inspect\n   * @return         the class of the innermost elements\n   */\n  public static Class getArrayClass(Class c) {\n     if (c.getComponentType().isArray())\n        return getArrayClass(c.getComponentType());\n     else\n        return c.getComponentType();\n  }\n\n  /**\n   * Returns the dimensions of the given array. Even though the\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\n   * int[3] or double[2][4].\n   *\n   * @param array       the array to determine the dimensions for\n   * @return            the dimensions of the array\n   */\n  public static int getArrayDimensions(Class array) {\n    if (array.getComponentType().isArray())\n      return 1 + getArrayDimensions(array.getComponentType());\n    else\n      return 1;\n  }\n\n  /**\n   * Returns the dimensions of the given array. Even though the\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\n   * int[3] or double[2][4].\n   *\n   * @param array       the array to determine the dimensions for\n   * @return            the dimensions of the array\n   */\n  public static int getArrayDimensions(Object array) {\n    return getArrayDimensions(array.getClass());\n  }\n\n  /**\n   * Returns the given Array in a string representation. Even though the\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\n   * int[3] or double[2][4].\n   * \n   * @param array       the array to return in a string representation\n   * @return            the array as string\n   */\n  public static String arrayToString(Object array) {\n    String        result;\n    int           dimensions;\n    int           i;       \n\n    result     = \"\";\n    dimensions = getArrayDimensions(array);\n    \n    if (dimensions == 0) {\n      result = \"null\";\n    }\n    else if (dimensions == 1) {\n      for (i = 0; i \u003c Array.getLength(array); i++) {\n        if (i \u003e 0)\n          result += \",\";\n        if (Array.get(array, i) == null)\n          result += \"null\";\n        else\n          result += Array.get(array, i).toString();\n      }\n    }\n    else {\n      for (i = 0; i \u003c Array.getLength(array); i++) {\n        if (i \u003e 0)\n          result += \",\";\n        result += \"[\" + arrayToString(Array.get(array, i)) + \"]\";\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * Tests if a is equal to b.\n   *\n   * @param a a double\n   * @param b a double\n   */\n  public static /*@pure@*/ boolean eq(double a, double b){\n    \n    return (a == b) || ((a - b \u003c SMALL) \u0026\u0026 (b - a \u003c SMALL)); \n  }\n\n  /**\n   * Checks if the given array contains any non-empty options.\n   *\n   * @param options an array of strings\n   * @exception Exception if there are any non-empty options\n   */\n  public static void checkForRemainingOptions(String[] options) \n    throws Exception {\n    \n    int illegalOptionsFound = 0;\n    StringBuffer text = new StringBuffer();\n\n    if (options == null) {\n      return;\n    }\n    for (int i = 0; i \u003c options.length; i++) {\n      if (options[i].length() \u003e 0) {\n\tillegalOptionsFound++;\n\ttext.append(options[i] + ' ');\n      }\n    }\n    if (illegalOptionsFound \u003e 0) {\n      throw new Exception(\"Illegal options: \" + text);\n    }\n  }\n  \n  /**\n   * Checks if the given array contains the flag \"-Char\". Stops\n   * searching at the first marker \"--\". If the flag is found,\n   * it is replaced with the empty string.\n   *\n   * @param flag the character indicating the flag.\n   * @param options the array of strings containing all the options.\n   * @return true if the flag was found\n   * @exception Exception if an illegal option was found\n   */\n  public static boolean getFlag(char flag, String[] options) \n    throws Exception {\n    \n    return getFlag(\"\" + flag, options);\n  }\n  \n  /**\n   * Checks if the given array contains the flag \"-String\". Stops\n   * searching at the first marker \"--\". If the flag is found,\n   * it is replaced with the empty string.\n   *\n   * @param flag the String indicating the flag.\n   * @param options the array of strings containing all the options.\n   * @return true if the flag was found\n   * @exception Exception if an illegal option was found\n   */\n  public static boolean getFlag(String flag, String[] options) \n    throws Exception {\n    \n    int pos = getOptionPos(flag, options);\n\n    if (pos \u003e -1)\n      options[pos] = \"\";\n    \n    return (pos \u003e -1);\n  }\n\n  /**\n   * Gets an option indicated by a flag \"-Char\" from the given array\n   * of strings. Stops searching at the first marker \"--\". Replaces \n   * flag and option with empty strings.\n   *\n   * @param flag the character indicating the option.\n   * @param options the array of strings containing all the options.\n   * @return the indicated option or an empty string\n   * @exception Exception if the option indicated by the flag can't be found\n   */\n  public static /*@non_null@*/ String getOption(char flag, String[] options) \n    throws Exception {\n    \n    return getOption(\"\" + flag, options);\n  }\n\n  /**\n   * Gets an option indicated by a flag \"-String\" from the given array\n   * of strings. Stops searching at the first marker \"--\". Replaces \n   * flag and option with empty strings.\n   *\n   * @param flag the String indicating the option.\n   * @param options the array of strings containing all the options.\n   * @return the indicated option or an empty string\n   * @exception Exception if the option indicated by the flag can't be found\n   */\n  public static /*@non_null@*/ String getOption(String flag, String[] options) \n    throws Exception {\n\n    String newString;\n    int i = getOptionPos(flag, options);\n\n    if (i \u003e -1) {\n      if (options[i].equals(\"-\" + flag)) {\n\tif (i + 1 == options.length) {\n\t  throw new Exception(\"No value given for -\" + flag + \" option.\");\n\t}\n\toptions[i] = \"\";\n\tnewString = new String(options[i + 1]);\n\toptions[i + 1] = \"\";\n\treturn newString;\n      }\n      if (options[i].charAt(1) == '-') {\n\treturn \"\";\n      }\n    }\n    \n    return \"\";\n  }\n\n  /**\n   * Gets the index of an option or flag indicated by a flag \"-Char\" from \n   * the given array of strings. Stops searching at the first marker \"--\".\n   *\n   * @param flag \tthe character indicating the option.\n   * @param options \tthe array of strings containing all the options.\n   * @return \t\tthe position if found, or -1 otherwise\n   */\n  public static int getOptionPos(char flag, String[] options) {\n     return getOptionPos(\"\" + flag, options);\n  }\n\n  /**\n   * Gets the index of an option or flag indicated by a flag \"-String\" from \n   * the given array of strings. Stops searching at the first marker \"--\".\n   *\n   * @param flag \tthe String indicating the option.\n   * @param options \tthe array of strings containing all the options.\n   * @return \t\tthe position if found, or -1 otherwise\n   */\n  public static int getOptionPos(String flag, String[] options) {\n    if (options == null)\n      return -1;\n    \n    for (int i = 0; i \u003c options.length; i++) {\n      if ((options[i].length() \u003e 0) \u0026\u0026 (options[i].charAt(0) == '-')) {\n\t// Check if it is a negative number\n\ttry {\n\t  Double.valueOf(options[i]);\n\t} \n\tcatch (NumberFormatException e) {\n\t  // found?\n\t  if (options[i].equals(\"-\" + flag))\n\t    return i;\n\t  // did we reach \"--\"?\n\t  if (options[i].charAt(1) == '-')\n\t    return -1;\n\t}\n      }\n    }\n    \n    return -1;\n  }\n\n  /**\n   * Quotes a string if it contains special characters.\n   * \n   * The following rules are applied:\n   *\n   * A character is backquoted version of it is one \n   * of \u003ctt\u003e\" ' % \\ \\n \\r \\t\u003c/tt\u003e.\n   *\n   * A string is enclosed within single quotes if a character has been\n   * backquoted using the previous rule above or contains \n   * \u003ctt\u003e{ }\u003c/tt\u003e or is exactly equal to the strings \n   * \u003ctt\u003e, ? space or \"\"\u003c/tt\u003e (empty string).\n   *\n   * A quoted question mark distinguishes it from the missing value which\n   * is represented as an unquoted question mark in arff files.\n   *\n   * @param string \tthe string to be quoted\n   * @return \t\tthe string (possibly quoted)\n   * @see\t\t#unquote(String)\n   */\n  public static /*@pure@*/ String quote(String string) {\n      boolean quote = false;\n\n      // backquote the following characters \n      if ((string.indexOf('\\n') != -1) || (string.indexOf('\\r') != -1) || \n\t  (string.indexOf('\\'') != -1) || (string.indexOf('\"') != -1) || \n\t  (string.indexOf('\\\\') != -1) || \n\t  (string.indexOf('\\t') != -1) || (string.indexOf('%') != -1) ||\n\t  (string.indexOf('\\u001E') != -1)) {\n\t  string = backQuoteChars(string);\n\t  quote = true;\n      }\n\n      // Enclose the string in 's if the string contains a recently added\n      // backquote or contains one of the following characters.\n      if((quote == true) || \n\t (string.indexOf('{') != -1) || (string.indexOf('}') != -1) ||\n\t (string.indexOf(',') != -1) || (string.equals(\"?\")) ||\n\t (string.indexOf(' ') != -1) || (string.equals(\"\"))) {\n\t  string = (\"'\".concat(string)).concat(\"'\");\n      }\n\n      return string;\n  }\n\n  /**\n   * unquotes are previously quoted string (but only if necessary), i.e., it\n   * removes the single quotes around it. Inverse to quote(String).\n   * \n   * @param string\tthe string to process\n   * @return\t\tthe unquoted string\n   * @see\t\t#quote(String)\n   */\n  public static String unquote(String string) {\n    if (string.startsWith(\"'\") \u0026\u0026 string.endsWith(\"'\")) {\n      string = string.substring(1, string.length() - 1);\n      \n      if ((string.indexOf(\"\\\\n\") != -1) || (string.indexOf(\"\\\\r\") != -1) || \n\t  (string.indexOf(\"\\\\'\") != -1) || (string.indexOf(\"\\\\\\\"\") != -1) || \n\t  (string.indexOf(\"\\\\\\\\\") != -1) || \n\t  (string.indexOf(\"\\\\t\") != -1) || (string.indexOf(\"\\\\%\") != -1) ||\n\t  (string.indexOf(\"\\\\u001E\") != -1)) {\n\tstring = unbackQuoteChars(string);\n      }\n    }\n\n    return string;\n  }\n\n  /**\n   * Converts carriage returns and new lines in a string into \\r and \\n.\n   * Backquotes the following characters: ` \" \\ \\t and %\n   * \n   * @param string \tthe string\n   * @return \t\tthe converted string\n   * @see\t\t#unbackQuoteChars(String)\n   */\n  public static /*@pure@*/ String backQuoteChars(String string) {\n\n    int index;\n    StringBuffer newStringBuffer;\n\n    // replace each of the following characters with the backquoted version\n    char   charsFind[] =    {'\\\\',   '\\'',  '\\t',  '\\n',  '\\r',  '\"',    '%', \n        '\\u001E'};\n    String charsReplace[] = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\n\", \"\\\\r\", \"\\\\\\\"\", \"\\\\%\",\n        \"\\\\u001E\"};\n    for (int i = 0; i \u003c charsFind.length; i++) {\n      if (string.indexOf(charsFind[i]) != -1 ) {\n\tnewStringBuffer = new StringBuffer();\n\twhile ((index = string.indexOf(charsFind[i])) != -1) {\n\t  if (index \u003e 0) {\n\t    newStringBuffer.append(string.substring(0, index));\n\t  }\n\t  newStringBuffer.append(charsReplace[i]);\n\t  if ((index + 1) \u003c string.length()) {\n\t    string = string.substring(index + 1);\n\t  } else {\n\t    string = \"\";\n\t  }\n\t}\n\tnewStringBuffer.append(string);\n\tstring = newStringBuffer.toString();\n      }\n    }\n\n    return string;\n  }\n\n  /**\n   * Converts carriage returns and new lines in a string into \\r and \\n.\n   *\n   * @param string the string\n   * @return the converted string\n   */\n  public static String convertNewLines(String string) {\n    int index;\n\n    // Replace with \\n\n    StringBuffer newStringBuffer = new StringBuffer();\n    while ((index = string.indexOf('\\n')) != -1) {\n      if (index \u003e 0) {\n\tnewStringBuffer.append(string.substring(0, index));\n      }\n      newStringBuffer.append('\\\\');\n      newStringBuffer.append('n');\n      if ((index + 1) \u003c string.length()) {\n\tstring = string.substring(index + 1);\n      } else {\n\tstring = \"\";\n      }\n    }\n    newStringBuffer.append(string);\n    string = newStringBuffer.toString();\n\n    // Replace with \\r\n    newStringBuffer = new StringBuffer();\n    while ((index = string.indexOf('\\r')) != -1) {\n      if (index \u003e 0) {\n\tnewStringBuffer.append(string.substring(0, index));\n      }\n      newStringBuffer.append('\\\\');\n      newStringBuffer.append('r');\n      if ((index + 1) \u003c string.length()){\n\tstring = string.substring(index + 1);\n      } else {\n\tstring = \"\";\n      }\n    }\n    newStringBuffer.append(string);\n    return newStringBuffer.toString();\n  }\n\n  /**\n   * Reverts \\r and \\n in a string into carriage returns and new lines.\n   * \n   * @param string the string\n   * @return the converted string\n   */\n  public static String revertNewLines(String string) {\n    int index;\n\n    // Replace with \\n\n    StringBuffer newStringBuffer = new StringBuffer();\n    while ((index = string.indexOf(\"\\\\n\")) != -1) {\n      if (index \u003e 0) {\n\tnewStringBuffer.append(string.substring(0, index));\n      }\n      newStringBuffer.append('\\n');\n      if ((index + 2) \u003c string.length()) {\n\tstring = string.substring(index + 2);\n      } else {\n\tstring = \"\";\n      }\n    }\n    newStringBuffer.append(string);\n    string = newStringBuffer.toString();\n\n    // Replace with \\r\n    newStringBuffer = new StringBuffer();\n    while ((index = string.indexOf(\"\\\\r\")) != -1) {\n      if (index \u003e 0) {\n\tnewStringBuffer.append(string.substring(0, index));\n      }\n      newStringBuffer.append('\\r');\n      if ((index + 2) \u003c string.length()){\n\tstring = string.substring(index + 2);\n      } else {\n\tstring = \"\";\n      }\n    }\n    newStringBuffer.append(string);\n    \n    return newStringBuffer.toString();\n  }\n\n  /**\n   * Returns the secondary set of options (if any) contained in\n   * the supplied options array. The secondary set is defined to\n   * be any options after the first \"--\". These options are removed from\n   * the original options array.\n   *\n   * @param options the input array of options\n   * @return the array of secondary options\n   */\n  public static String[] partitionOptions(String[] options) {\n\n    for (int i = 0; i \u003c options.length; i++) {\n      if (options[i].equals(\"--\")) {\n\toptions[i++] = \"\";\n\tString[] result = new String [options.length - i];\n\tfor (int j = i; j \u003c options.length; j++) {\n\t  result[j - i] = options[j];\n\t  options[j] = \"\";\n\t}\n\treturn result;\n      }\n    }\n    return new String [0];\n  }\n    \n  /**\n   * The inverse operation of backQuoteChars().\n   * Converts back-quoted carriage returns and new lines in a string \n   * to the corresponding character ('\\r' and '\\n').\n   * Also \"un\"-back-quotes the following characters: ` \" \\ \\t and %\n   *\n   * @param string \tthe string\n   * @return \t\tthe converted string\n   * @see\t\t#backQuoteChars(String)\n   */\n  public static String unbackQuoteChars(String string) {\n\n    int index;\n    StringBuffer newStringBuffer;\n    \n    // replace each of the following characters with the backquoted version\n    String charsFind[]    = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\n\", \"\\\\r\", \"\\\\\\\"\", \"\\\\%\",\n        \"\\\\u001E\"};\n    char   charsReplace[] = {'\\\\',   '\\'',  '\\t',  '\\n',  '\\r',  '\"',    '%',\n        '\\u001E'};\n    int pos[] = new int[charsFind.length];\n    int\tcurPos;\n    \n    String str = new String(string);\n    newStringBuffer = new StringBuffer();\n    while (str.length() \u003e 0) {\n      // get positions and closest character to replace\n      curPos = str.length();\n      index  = -1;\n      for (int i = 0; i \u003c pos.length; i++) {\n\tpos[i] = str.indexOf(charsFind[i]);\n\tif ( (pos[i] \u003e -1) \u0026\u0026 (pos[i] \u003c curPos) ) {\n\t  index  = i;\n\t  curPos = pos[i];\n\t}\n      }\n      \n      // replace character if found, otherwise finished\n      if (index == -1) {\n\tnewStringBuffer.append(str);\n\tstr = \"\";\n      }\n      else {\n\tnewStringBuffer.append(str.substring(0, pos[index]));\n\tnewStringBuffer.append(charsReplace[index]);\n\tstr = str.substring(pos[index] + charsFind[index].length());\n      }\n    }\n\n    return newStringBuffer.toString();\n  }    \n  \n  /**\n   * Split up a string containing options into an array of strings,\n   * one for each option.\n   *\n   * @param \t\tquotedOptionString the string containing the options\n   * @return \t\tthe array of options\n   * @throws Exception \tin case of an unterminated string, unknown character or\n   * \t\t\ta parse error\n   */\n  public static String[] splitOptions(String quotedOptionString) throws Exception{\n\n    Vector\u003cString\u003e optionsVec = new Vector\u003cString\u003e();\n    String str = new String(quotedOptionString);\n    int i;\n    \n    while (true){\n\n      //trimLeft \n      i = 0;\n      while ((i \u003c str.length()) \u0026\u0026 (Character.isWhitespace(str.charAt(i)))) i++;\n      str = str.substring(i);\n      \n      //stop when str is empty\n      if (str.length() == 0) break;\n      \n      //if str start with a double quote\n      if (str.charAt(0) == '\"'){\n\t\n\t//find the first not anti-slached double quote\n\ti = 1;\n\twhile(i \u003c str.length()){\n\t  if (str.charAt(i) == str.charAt(0)) break;\n\t  if (str.charAt(i) == '\\\\'){\n\t    i += 1;\n\t    if (i \u003e= str.length()) \n\t      throw new Exception(\"String should not finish with \\\\\");\n\t  }\n\t  i += 1;\n\t}\n\tif (i \u003e= str.length()) throw new Exception(\"Quote parse error.\");\n\t\n\t//add the founded string to the option vector (without quotes)\n\tString optStr = str.substring(1,i);\n\toptStr = unbackQuoteChars(optStr);\n\toptionsVec.addElement(optStr);\n\tstr = str.substring(i+1);\n      } else {\n\t//find first whiteSpace\n\ti=0;\n\twhile((i \u003c str.length()) \u0026\u0026 (!Character.isWhitespace(str.charAt(i)))) i++;\n\t\n\t//add the founded string to the option vector\n\tString optStr = str.substring(0,i);\n\toptionsVec.addElement(optStr);\n\tstr = str.substring(i);\n      }\n    }\n    \n    //convert optionsVec to an array of String\n    String[] options = new String[optionsVec.size()];\n    for (i = 0; i \u003c optionsVec.size(); i++) {\n      options[i] = (String)optionsVec.elementAt(i);\n    }\n    return options;\n  }    \n\n  /**\n   * Joins all the options in an option array into a single string,\n   * as might be used on the command line.\n   *\n   * @param optionArray the array of options\n   * @return the string containing all options.\n   */\n  public static String joinOptions(String[] optionArray) {\n\n    String optionString = \"\";\n    for (int i = 0; i \u003c optionArray.length; i++) {\n      if (optionArray[i].equals(\"\")) {\n\tcontinue;\n      }\n      boolean escape = false;\n      for (int n = 0; n \u003c optionArray[i].length(); n++) {\n\tif (Character.isWhitespace(optionArray[i].charAt(n))) {\n\t  escape = true;\n\t  break;\n\t}\n      }\n      if (escape) {\n\toptionString += '\"' + backQuoteChars(optionArray[i]) + '\"';\n      } else {\n\toptionString += optionArray[i];\n      }\n      optionString += \" \";\n    }\n    return optionString.trim();\n  }\n  \n  /**\n   * Creates a new instance of an object given it's class name and\n   * (optional) arguments to pass to it's setOptions method. If the\n   * object implements OptionHandler and the options parameter is\n   * non-null, the object will have it's options set. Example use:\u003cp\u003e\n   *\n   * \u003ccode\u003e \u003cpre\u003e\n   * String classifierName = Utils.getOption('W', options);\n   * Classifier c = (Classifier)Utils.forName(Classifier.class,\n   *                                          classifierName,\n   *                                          options);\n   * setClassifier(c);\n   * \u003c/pre\u003e\u003c/code\u003e\n   *\n   * @param classType the class that the instantiated object should\n   * be assignable to -- an exception is thrown if this is not the case\n   * @param className the fully qualified class name of the object\n   * @param options an array of options suitable for passing to setOptions. May\n   * be null. Any options accepted by the object will be removed from the\n   * array.\n   * @return the newly created object, ready for use.\n   * @exception Exception if the class name is invalid, or if the\n   * class is not assignable to the desired class type, or the options\n   * supplied are not acceptable to the object\n   */\n  public static Object forName(Class\u003c?\u003e classType,\n\t\t\t       String className,\n\t\t\t       String[] options) throws Exception {\n\n    Class\u003c?\u003e c = null;\n    try {\n      c = Class.forName(className);\n    } catch (Exception ex) {\n      throw new Exception(\"Can't find class called: \" + className);\n    }\n    if (!classType.isAssignableFrom(c)) {\n      throw new Exception(classType.getName() + \" is not assignable from \"\n\t\t\t  + className);\n    }\n    Object o = c.newInstance();\n    if ((o instanceof OptionHandler)\n\t\u0026\u0026 (options != null)) {\n      ((OptionHandler)o).setOptions(options);\n      Utils.checkForRemainingOptions(options);\n    }\n    return o;\n  }\n\n  /**\n   * Generates a commandline of the given object. If the object is not \n   * implementing OptionHandler, then it will only return the classname,\n   * otherwise also the options.\n   * \n   * @param obj\t\tthe object to turn into a commandline\n   * @return\t\tthe commandline\n   */\n  public static String toCommandLine(Object obj) {\n    StringBuffer\tresult;\n    \n    result = new StringBuffer();\n    \n    if (obj != null) {\n      result.append(obj.getClass().getName());\n      if (obj instanceof OptionHandler)\n\tresult.append(\" \" + joinOptions(((OptionHandler) obj).getOptions()));\n    }\n    \n    return result.toString().trim();\n  }\n  \n  /**\n   * Computes entropy for an array of integers.\n   *\n   * @param counts array of counts\n   * @return - a log2 a - b log2 b - c log2 c + (a+b+c) log2 (a+b+c)\n   * when given array [a b c]\n   */\n  public static /*@pure@*/ double info(int counts[]) {\n    \n    int total = 0;\n    double x = 0;\n    for (int j = 0; j \u003c counts.length; j++) {\n      x -= xlogx(counts[j]);\n      total += counts[j];\n    }\n    return x + xlogx(total);\n  }\n\n  /**\n   * Tests if a is smaller or equal to b.\n   *\n   * @param a a double\n   * @param b a double\n   */\n  public static /*@pure@*/ boolean smOrEq(double a,double b) {\n    \n    return (a-b \u003c SMALL) || (a \u003c= b);\n  }\n\n  /**\n   * Tests if a is greater or equal to b.\n   *\n   * @param a a double\n   * @param b a double\n   */\n  public static /*@pure@*/ boolean grOrEq(double a,double b) {\n    \n    return (b-a \u003c SMALL) || (a \u003e= b);\n  }\n  \n  /**\n   * Tests if a is smaller than b.\n   *\n   * @param a a double\n   * @param b a double\n   */\n  public static /*@pure@*/ boolean sm(double a,double b) {\n    \n    return (b-a \u003e SMALL);\n  }\n\n  /**\n   * Tests if a is greater than b.\n   *\n   * @param a a double\n   * @param b a double \n   */\n  public static /*@pure@*/ boolean gr(double a,double b) {\n    \n    return (a-b \u003e SMALL);\n  }\n\n  /**\n   * Returns the kth-smallest value in the array.\n   *\n   * @param array the array of integers\n   * @param k the value of k\n   * @return the kth-smallest value\n   */\n  public static int kthSmallestValue(int[] array, int k) {\n\n    int[] index = initialIndex(array.length);\n    return array[index[select(array, index, 0, array.length - 1, k)]];\n  }\n\n  /**\n   * Returns the kth-smallest value in the array\n   *\n   * @param array the array of double\n   * @param k the value of k\n   * @return the kth-smallest value\n   */\n  public static double kthSmallestValue(double[] array, int k) {\n\n    int[] index = initialIndex(array.length);\n    return array[index[select(array, index, 0, array.length - 1, k)]];\n  }\n\n  /**\n   * Returns the logarithm of a for base 2.\n   *\n   * @param a \ta double\n   * @return\tthe logarithm for base 2\n   */\n  public static /*@pure@*/ double log2(double a) {\n    \n    return Math.log(a) / log2;\n  }\n\n  /**\n   * Returns index of maximum element in a given\n   * array of doubles. First maximum is returned.\n   *\n   * @param doubles the array of doubles\n   * @return the index of the maximum element\n   */\n  public static /*@pure@*/ int maxIndex(double[] doubles) {\n\n    double maximum = 0;\n    int maxIndex = 0;\n\n    for (int i = 0; i \u003c doubles.length; i++) {\n      if ((i == 0) || (doubles[i] \u003e maximum)) {\n\tmaxIndex = i;\n\tmaximum = doubles[i];\n      }\n    }\n\n    return maxIndex;\n  }\n\n  /**\n   * Returns index of maximum element in a given\n   * array of integers. First maximum is returned.\n   *\n   * @param ints the array of integers\n   * @return the index of the maximum element\n   */\n  public static /*@pure@*/ int maxIndex(int[] ints) {\n\n    int maximum = 0;\n    int maxIndex = 0;\n\n    for (int i = 0; i \u003c ints.length; i++) {\n      if ((i == 0) || (ints[i] \u003e maximum)) {\n\tmaxIndex = i;\n\tmaximum = ints[i];\n      }\n    }\n\n    return maxIndex;\n  }\n\n  /**\n   * Computes the mean for an array of doubles.\n   *\n   * @param vector the array\n   * @return the mean\n   */\n  public static /*@pure@*/ double mean(double[] vector) {\n  \n    double sum = 0;\n\n    if (vector.length == 0) {\n      return 0;\n    }\n    for (int i = 0; i \u003c vector.length; i++) {\n      sum += vector[i];\n    }\n    return sum / (double) vector.length;\n  }\n\n  /**\n   * Returns index of minimum element in a given\n   * array of integers. First minimum is returned.\n   *\n   * @param ints the array of integers\n   * @return the index of the minimum element\n   */\n  public static /*@pure@*/ int minIndex(int[] ints) {\n\n    int minimum = 0;\n    int minIndex = 0;\n\n    for (int i = 0; i \u003c ints.length; i++) {\n      if ((i == 0) || (ints[i] \u003c minimum)) {\n\tminIndex = i;\n\tminimum = ints[i];\n      }\n    }\n\n    return minIndex;\n  }\n\n  /**\n   * Returns index of minimum element in a given\n   * array of doubles. First minimum is returned.\n   *\n   * @param doubles the array of doubles\n   * @return the index of the minimum element\n   */\n  public static /*@pure@*/ int minIndex(double[] doubles) {\n\n    double minimum = 0;\n    int minIndex = 0;\n\n    for (int i = 0; i \u003c doubles.length; i++) {\n      if ((i == 0) || (doubles[i] \u003c minimum)) {\n\tminIndex = i;\n\tminimum = doubles[i];\n      }\n    }\n\n    return minIndex;\n  }\n\n  /**\n   * Normalizes the doubles in the array by their sum.\n   *\n   * @param doubles the array of double\n   * @exception IllegalArgumentException if sum is Zero or NaN\n   */\n  public static void normalize(double[] doubles) {\n\n    double sum = 0;\n    for (int i = 0; i \u003c doubles.length; i++) {\n      sum += doubles[i];\n    }\n    normalize(doubles, sum);\n  }\n\n  /**\n   * Normalizes the doubles in the array using the given value.\n   *\n   * @param doubles the array of double\n   * @param sum the value by which the doubles are to be normalized\n   * @exception IllegalArgumentException if sum is zero or NaN\n   */\n  public static void normalize(double[] doubles, double sum) {\n\n    if (Double.isNaN(sum)) {\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is NaN.\");\n    }\n    if (sum == 0) {\n      // Maybe this should just be a return.\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is zero.\");\n    }\n    for (int i = 0; i \u003c doubles.length; i++) {\n      doubles[i] /= sum;\n    }\n  }\n\n  /**\n   * Converts an array containing the natural logarithms of\n   * probabilities stored in a vector back into probabilities.\n   * The probabilities are assumed to sum to one.\n   *\n   * @param a an array holding the natural logarithms of the probabilities\n   * @return the converted array \n   */\n  public static double[] logs2probs(double[] a) {\n\n    double max = a[maxIndex(a)];\n    double sum = 0.0;\n\n    double[] result = new double[a.length];\n    for(int i = 0; i \u003c a.length; i++) {\n      result[i] = Math.exp(a[i] - max);\n      sum += result[i];\n    }\n\n    normalize(result, sum);\n\n    return result;\n  } \n\n  /**\n   * Returns the log-odds for a given probabilitiy.\n   *\n   * @param prob the probabilitiy\n   *\n   * @return the log-odds after the probability has been mapped to\n   * [Utils.SMALL, 1-Utils.SMALL]\n   */\n  public static /*@pure@*/ double probToLogOdds(double prob) {\n\n    if (gr(prob, 1) || (sm(prob, 0))) {\n      throw new IllegalArgumentException(\"probToLogOdds: probability must \" +\n\t\t\t\t     \"be in [0,1] \"+prob);\n    }\n    double p = SMALL + (1.0 - 2 * SMALL) * prob;\n    return Math.log(p / (1 - p));\n  }\n\n  /**\n   * Rounds a double to the next nearest integer value. The JDK version\n   * of it doesn't work properly.\n   *\n   * @param value the double value\n   * @return the resulting integer value\n   */\n  public static /*@pure@*/ int round(double value) {\n\n    int roundedValue = value \u003e 0\n      ? (int)(value + 0.5)\n      : -(int)(Math.abs(value) + 0.5);\n    \n    return roundedValue;\n  }\n\n  /**\n   * Rounds a double to the next nearest integer value in a probabilistic\n   * fashion (e.g. 0.8 has a 20% chance of being rounded down to 0 and a\n   * 80% chance of being rounded up to 1). In the limit, the average of\n   * the rounded numbers generated by this procedure should converge to\n   * the original double.\n   *\n   * @param value the double value\n   * @param rand the random number generator\n   * @return the resulting integer value\n   */\n  public static int probRound(double value, Random rand) {\n\n    if (value \u003e= 0) {\n      double lower = Math.floor(value);\n      double prob = value - lower;\n      if (rand.nextDouble() \u003c prob) {\n\treturn (int)lower + 1;\n      } else {\n\treturn (int)lower;\n      }\n    } else {\n      double lower = Math.floor(Math.abs(value));\n      double prob = Math.abs(value) - lower;\n      if (rand.nextDouble() \u003c prob) {\n\treturn -((int)lower + 1);\n      } else {\n\treturn -(int)lower;\n      }\n    }\n  }\n\n  /**\n   * Replaces all \"missing values\" in the given array of double values with\n   * MAX_VALUE.\n   *\n   * @param array the array to be modified.\n   */\n  public static void replaceMissingWithMAX_VALUE(double[] array) {\n\n    for (int i = 0; i \u003c array.length; i++) {\n      if (isMissingValue(array[i])) {\n        array[i] = Double.MAX_VALUE;\n      }\n    }\n  }\n\n  /**\n   * Rounds a double to the given number of decimal places.\n   *\n   * @param value the double value\n   * @param afterDecimalPoint the number of digits after the decimal point\n   * @return the double rounded to the given precision\n   */\n  public static /*@pure@*/ double roundDouble(double value,int afterDecimalPoint) {\n\n    double mask = Math.pow(10.0, (double)afterDecimalPoint);\n\n    return (double)(Math.round(value * mask)) / mask;\n  }\n\n  /**\n   * Sorts a given array of integers in ascending order and returns an \n   * array of integers with the positions of the elements of the original \n   * array in the sorted array. The sort is stable. (Equal elements remain\n   * in their original order.)\n   *\n   * @param array this array is not changed by the method!\n   * @return an array of integers with the positions in the sorted\n   * array.\n   */\n  public static /*@pure@*/ int[] sort(int[] array) {\n\n    int[] index = initialIndex(array.length);\n    int[] newIndex = new int[array.length];\n    int[] helpIndex;\n    int numEqual;\n\n    quickSort(array, index, 0, array.length - 1);\n\n    // Make sort stable\n    int i = 0;\n    while (i \u003c index.length) {\n      numEqual = 1;\n      for (int j = i + 1; ((j \u003c index.length)\n\t\t\t   \u0026\u0026 (array[index[i]] == array[index[j]]));\n\t   j++) {\n\tnumEqual++;\n      }\n      if (numEqual \u003e 1) {\n\thelpIndex = new int[numEqual];\n\tfor (int j = 0; j \u003c numEqual; j++) {\n\t  helpIndex[j] = i + j;\n\t}\n\tquickSort(index, helpIndex, 0, numEqual - 1);\n\tfor (int j = 0; j \u003c numEqual; j++) {\n\t  newIndex[i + j] = index[helpIndex[j]];\n\t}\n\ti += numEqual;\n      } else {\n\tnewIndex[i] = index[i];\n\ti++;\n      }\n    }\n    return newIndex;\n  }\n\n  /**\n   * Sorts a given array of doubles in ascending order and returns an\n   * array of integers with the positions of the elements of the\n   * original array in the sorted array. NOTE THESE CHANGES: the sort\n   * is no longer stable and it doesn't use safe floating-point\n   * comparisons anymore. Occurrences of Double.NaN are treated as \n   * Double.MAX_VALUE.\n   *\n   * @param array this array is not changed by the method!\n   * @return an array of integers with the positions in the sorted\n   * array.  \n   */\n  public static /*@pure@*/ int[] sort(/*@non_null@*/ double[] array) {\n\n    int[] index = initialIndex(array.length);\n    if (array.length \u003e 1) {\n      array = (double[])array.clone();\n      replaceMissingWithMAX_VALUE(array);\n      quickSort(array, index, 0, array.length - 1);\n    }\n    return index;\n  }\n\n  /**\n   * Sorts a given array of doubles in ascending order and returns an\n   * array of integers with the positions of the elements of the\n   * original array in the sorted array. Missing values in the given\n   * array are replaced by Double.MAX_VALUE, so the array is modified in that case! \n   *\n   * @param array the array to be sorted, which is modified if it has missing values\n   * @return an array of integers with the positions in the sorted\n   * array.  \n   */\n  public static /*@pure@*/ int[] sortWithNoMissingValues(/*@non_null@*/ double[] array) {\n\n    int[] index = initialIndex(array.length);\n    if (array.length \u003e 1) {\n      quickSort(array, index, 0, array.length - 1);\n    }\n    return index;\n  }\n\n  /**\n   * Sorts a given array of doubles in ascending order and returns an \n   * array of integers with the positions of the elements of the original \n   * array in the sorted array. The sort is stable (Equal elements remain\n   * in their original order.) Occurrences of Double.NaN are treated as \n   * Double.MAX_VALUE\n   *\n   * @param array this array is not changed by the method!\n   * @return an array of integers with the positions in the sorted\n   * array.\n   */\n  public static /*@pure@*/ int[] stableSort(double[] array){\n\n    int[] index = initialIndex(array.length);\n    \n    if (array.length \u003e 1) {\n\n      int[] newIndex = new int[array.length];\n      int[] helpIndex;\n      int numEqual;\n\n      array = (double[])array.clone();\n      replaceMissingWithMAX_VALUE(array);\n      quickSort(array, index, 0, array.length-1);\n      \n      // Make sort stable\n      \n      int i = 0;\n      while (i \u003c index.length) {\n        numEqual = 1;\n        for (int j = i+1; ((j \u003c index.length) \u0026\u0026 Utils.eq(array[index[i]],\n                                                          array[index[j]])); j++)\n          numEqual++;\n        if (numEqual \u003e 1) {\n          helpIndex = new int[numEqual];\n          for (int j = 0; j \u003c numEqual; j++)\n            helpIndex[j] = i+j;\n          quickSort(index, helpIndex, 0, numEqual-1);\n          for (int j = 0; j \u003c numEqual; j++) \n            newIndex[i+j] = index[helpIndex[j]];\n          i += numEqual;\n        } else {\n          newIndex[i] = index[i];\n          i++;\n        }\n      }\n      return newIndex;\n    } else {\n      return index;\n    }\n  }\n\n  /**\n   * Computes the variance for an array of doubles.\n   *\n   * @param vector the array\n   * @return the variance\n   */\n  public static /*@pure@*/ double variance(double[] vector) {\n  \n    double sum = 0, sumSquared = 0;\n\n    if (vector.length \u003c= 1) {\n      return 0;\n    }\n    for (int i = 0; i \u003c vector.length; i++) {\n      sum += vector[i];\n      sumSquared += (vector[i] * vector[i]);\n    }\n    double result = (sumSquared - (sum * sum / (double) vector.length)) / \n      (double) (vector.length - 1);\n\n    // We don't like negative variance\n    if (result \u003c 0) {\n      return 0;\n    } else {\n      return result;\n    }\n  }\n\n  /**\n   * Computes the sum of the elements of an array of doubles.\n   *\n   * @param doubles the array of double\n   * @return the sum of the elements\n   */\n  public static /*@pure@*/ double sum(double[] doubles) {\n\n    double sum = 0;\n\n    for (int i = 0; i \u003c doubles.length; i++) {\n      sum += doubles[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Computes the sum of the elements of an array of integers.\n   *\n   * @param ints the array of integers\n   * @return the sum of the elements\n   */\n  public static /*@pure@*/ int sum(int[] ints) {\n\n    int sum = 0;\n\n    for (int i = 0; i \u003c ints.length; i++) {\n      sum += ints[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns c*log2(c) for a given integer value c.\n   *\n   * @param c an integer value\n   * @return c*log2(c) (but is careful to return 0 if c is 0)\n   */\n  public static /*@pure@*/ double xlogx(int c) {\n    \n    if (c == 0) {\n      return 0.0;\n    }\n    return c * Utils.log2((double) c);\n  }\n\n  /**\n   * Initial index, filled with values from 0 to size - 1.\n   */\n  private static int[] initialIndex(int size) {\n   \n    int[] index = new int[size];\n    for (int i = 0; i \u003c size; i++) {\n      index[i] = i;\n    }\n    return index;\n  }\n\n  /**\n   * Sorts left, right, and center elements only, returns resulting center as pivot.\n   */\n  private static int sortLeftRightAndCenter(double[] array, int[] index, int l, int r) {\n\n    int c = (l + r) / 2;\n    conditionalSwap(array, index, l, c);\n    conditionalSwap(array, index, l, r);\n    conditionalSwap(array, index, c, r);\n    return c;\n  }\n\n  /**\n   * Swaps two elements in the given integer array.\n   */\n  private static void swap(int[] index, int l, int r) {\n    \n    int help = index[l];\n    index[l] = index[r];\n    index[r] = help;\n  }\n  \n  /**\n   * Conditional swap for quick sort.\n   */\n  private static void conditionalSwap(double[] array, int[] index, int left, int right) {\n\n    if (array[index[left]] \u003e array[index[right]]) {\n      int help = index[left];\n      index[left] = index[right];\n      index[right] = help;\n    }\n  }\n\n  /**\n   * Partitions the instances around a pivot. Used by quicksort and\n   * kthSmallestValue.\n   *\n   * @param array the array of doubles to be sorted\n   * @param index the index into the array of doubles\n   * @param l the first index of the subset \n   * @param r the last index of the subset \n   *\n   * @return the index of the middle element\n   */\n  private static int partition(double[] array, int[] index, int l, int r,\n                               double pivot) {\n\n    r--;\n    while (true) {\n      while ((array[index[++l]] \u003c pivot));\n      while ((array[index[--r]] \u003e pivot));\n      if (l \u003e= r) {\n        return l;\n      }\n      swap(index, l, r);\n    }\n  }\n\n  /**\n   * Partitions the instances around a pivot. Used by quicksort and\n   * kthSmallestValue.\n   *\n   * @param array the array of integers to be sorted\n   * @param index the index into the array of integers\n   * @param l the first index of the subset \n   * @param r the last index of the subset \n   *\n   * @return the index of the middle element\n   */\n  private static int partition(int[] array, int[] index, int l, int r) {\n    \n    double pivot = array[index[(l + r) / 2]];\n    int help;\n\n    while (l \u003c r) {\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\n        l++;\n      }\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\n        r--;\n      }\n      if (l \u003c r) {\n        help = index[l];\n        index[l] = index[r];\n        index[r] = help;\n        l++;\n        r--;\n      }\n    }\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\n      r--;\n    } \n\n    return r;\n  }\n\n  /**\n   * Implements quicksort with median-of-three method and explicit sort for\n   * problems of size three or less. \n   *\n   * @param array the array of doubles to be sorted\n   * @param index the index into the array of doubles\n   * @param left the first index of the subset to be sorted\n   * @param right the last index of the subset to be sorted\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\n  //@ requires array != index;\n  //  assignable index;\n  private static void quickSort(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \n                               int left, int right) {\n\n    int diff = right - left;\n\n    switch (diff) {\n    case 0 :\n      \n      // No need to do anything\n      return;\n    case 1 :\n      \n      // Swap two elements if necessary\n      conditionalSwap(array, index, left, right);\n      return;\n    case 2 :\n\n      // Just need to sort three elements\n      conditionalSwap(array, index, left, left + 1);\n      conditionalSwap(array, index, left, right);\n      conditionalSwap(array, index, left + 1, right);\n      return;\n    default :\n      \n      // Establish pivot\n      int pivotLocation = sortLeftRightAndCenter(array, index, left, right);\n      \n      // Move pivot to the right, partition, and restore pivot\n      swap(index, pivotLocation, right - 1); \n      int center = partition(array, index, left, right, array[index[right - 1]]);\n      swap(index, center, right - 1);\n      \n      // Sort recursively\n      quickSort(array, index, left, center - 1);\n      quickSort(array, index, center + 1, right);\n    }\n  }\n\n  /**\n   * Implements quicksort according to Manber's \"Introduction to\n   * Algorithms\".\n   *\n   * @param array the array of integers to be sorted\n   * @param index the index into the array of integers\n   * @param left the first index of the subset to be sorted\n   * @param right the last index of the subset to be sorted\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\n  //@ requires array != index;\n  //  assignable index;\n  private static void quickSort(/*@non_null@*/ int[] array, /*@non_null@*/  int[] index, \n                                int left, int right) {\n\n    if (left \u003c right) {\n      int middle = partition(array, index, left, right);\n      quickSort(array, index, left, middle);\n      quickSort(array, index, middle + 1, right);\n    }\n  }\n  \n  /**\n   * Implements computation of the kth-smallest element according\n   * to Manber's \"Introduction to Algorithms\".\n   *\n   * @param array the array of double\n   * @param index the index into the array of doubles\n   * @param left the first index of the subset \n   * @param right the last index of the subset \n   * @param k the value of k\n   *\n   * @return the index of the kth-smallest element\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n  private static int select(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \n                            int left, int right, int k) {\n\n    int diff = right - left;\n    switch (diff) {\n    case 0 :\n\n      // Nothing to be done\n      return left;\n    case 1 :\n\n      // Swap two elements if necessary\n      conditionalSwap(array, index, left, right);\n      return left + k - 1;\n    case 2 :\n\n      // Just need to sort three elements\n      conditionalSwap(array, index, left, left + 1);\n      conditionalSwap(array, index, left, right);\n      conditionalSwap(array, index, left + 1, right);\n      return left + k - 1;\n    default :\n    \n      // Establish pivot\n      int pivotLocation = sortLeftRightAndCenter(array, index, left, right);\n      \n      // Move pivot to the right, partition, and restore pivot\n      swap(index, pivotLocation, right - 1); \n      int center = partition(array, index, left, right, array[index[right - 1]]);\n      swap(index, center, right - 1);\n      \n      // Proceed recursively\n      if ((center - left + 1) \u003e= k) {\n        return select(array, index, left, center, k);\n      } else {\n        return select(array, index, center + 1, right, k - (center - left + 1));\n      }\n    }\n  }\n\n  /**\n   * Converts a File's absolute path to a path relative to the user\n   * (ie start) directory. Includes an additional workaround for Cygwin, which\n   * doesn't like upper case drive letters.\n   * @param absolute the File to convert to relative path\n   * @return a File with a path that is relative to the user's directory\n   * @exception Exception if the path cannot be constructed\n   */\n  public static File convertToRelativePath(File absolute) throws Exception {\n    File        result;\n    String      fileStr;\n    \n    result = null;\n    \n    // if we're running windows, it could be Cygwin\n    if (File.separator.equals(\"\\\\\")) {\n      // Cygwin doesn't like upper case drives -\u003e try lower case drive\n      try {\n        fileStr = absolute.getPath();\n        fileStr =   fileStr.substring(0, 1).toLowerCase() \n                  + fileStr.substring(1);\n        result = createRelativePath(new File(fileStr));\n      }\n      catch (Exception e) {\n        // no luck with Cygwin workaround, convert it like it is\n        result = createRelativePath(absolute);\n      }\n    }\n    else {\n      result = createRelativePath(absolute);\n    }\n\n    return result;\n  }\n\n  /**\n   * Converts a File's absolute path to a path relative to the user\n   * (ie start) directory.\n   * \n   * @param absolute the File to convert to relative path\n   * @return a File with a path that is relative to the user's directory\n   * @exception Exception if the path cannot be constructed\n   */\n  protected static File createRelativePath(File absolute) throws Exception {\n    File userDir = new File(System.getProperty(\"user.dir\"));\n    String userPath = userDir.getAbsolutePath() + File.separator;\n    String targetPath = (new File(absolute.getParent())).getPath() \n      + File.separator;\n    String fileName = absolute.getName();\n    StringBuffer relativePath = new StringBuffer();\n    //    relativePath.append(\".\"+File.separator);\n    //    System.err.println(\"User dir \"+userPath);\n    //    System.err.println(\"Target path \"+targetPath);\n    \n    // file is in user dir (or subdir)\n    int subdir = targetPath.indexOf(userPath);\n    if (subdir == 0) {\n      if (userPath.length() == targetPath.length()) {\n\trelativePath.append(fileName);\n      } else {\n\tint ll = userPath.length();\n\trelativePath.append(targetPath.substring(ll));\n\trelativePath.append(fileName);\n      }\n    } else {\n      int sepCount = 0;\n      String temp = new String(userPath);\n      while (temp.indexOf(File.separator) != -1) {\n\tint ind = temp.indexOf(File.separator);\n\tsepCount++;\n\ttemp = temp.substring(ind+1, temp.length());\n      }\n      \n      String targetTemp = new String(targetPath);\n      String userTemp = new String(userPath);\n      int tcount = 0;\n      while (targetTemp.indexOf(File.separator) != -1) {\n\tint ind = targetTemp.indexOf(File.separator);\n\tint ind2 = userTemp.indexOf(File.separator);\n\tString tpart = targetTemp.substring(0,ind+1);\n\tString upart = userTemp.substring(0,ind2+1);\n\tif (tpart.compareTo(upart) != 0) {\n\t  if (tcount == 0) {\n\t    tcount = -1;\n\t  }\n\t  break;\n\t}\n\ttcount++;\n\ttargetTemp = targetTemp.substring(ind+1, targetTemp.length());\n\tuserTemp = userTemp.substring(ind2+1, userTemp.length());\n      }\n      if (tcount == -1) {\n\t// then target file is probably on another drive (under windows)\n\tthrow new Exception(\"Can't construct a path to file relative to user \"\n\t\t\t    +\"dir.\");\n      }\n      if (targetTemp.indexOf(File.separator) == -1) {\n\ttargetTemp = \"\";\n      }\n      for (int i = 0; i \u003c sepCount - tcount; i++) {\n\trelativePath.append(\"..\"+File.separator);\n      }\n      relativePath.append(targetTemp + fileName);\n    }\n    //    System.err.println(\"new path : \"+relativePath.toString());\n    return new File(relativePath.toString());\n  }\n  \n  /**\n   * Implements computation of the kth-smallest element according\n   * to Manber's \"Introduction to Algorithms\".\n   *\n   * @param array the array of integers\n   * @param index the index into the array of integers\n   * @param left the first index of the subset \n   * @param right the last index of the subset \n   * @param k the value of k\n   *\n   * @return the index of the kth-smallest element\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n  private static int select(/*@non_null@*/ int[] array, /*@non_null@*/ int[] index, \n                            int left, int right, int k) {\n    \n    if (left == right) {\n      return left;\n    } else {\n      int middle = partition(array, index, left, right);\n      if ((middle - left + 1) \u003e= k) {\n        return select(array, index, left, middle, k);\n      } else {\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\n      }\n    }\n  }\n  \n  /**\n   * For a named dialog, returns true if the user has opted not to view\n   * it again in the future.\n   * \n   * @param dialogName the name of the dialog to check (e.g.\n   * weka.gui.GUICHooser.HowToFindPackageManager).\n   * @return true if the user has opted not to view the named dialog\n   * in the future.\n  public static boolean getDontShowDialog(String dialogName) {\n    File wekaHome = WekaPackageManager.WEKA_HOME;\n    \n    if (!wekaHome.exists()) {\n      return false;\n    }\n    \n    File dialogSubDir = new File(wekaHome.toString() + File.separator + \"systemDialogs\");\n    if (!dialogSubDir.exists()) {\n      return false;\n    }\n    \n    File dialogFile = new File(dialogSubDir.toString() + File.separator + dialogName);\n    \n    return dialogFile.exists();\n  }\n   */\n  \n  /**\n   * Specify that the named dialog is not to be displayed in the future.\n   * \n   * @param dialogName the name of the dialog not to show again (e.g.\n   * weka.gui.GUIChooser.HowToFindPackageManager).\n   * @throws Exception if the marker file that is used to indicate that\n   * a named dialog is not to be shown can't be created. This file lives\n   * in $WEKA_HOME/systemDialogs\n\n  public static void setDontShowDialog(String dialogName) throws Exception {\n    File wekaHome = WekaPackageManager.WEKA_HOME;\n    \n    if (!wekaHome.exists()) {\n      return;\n    }\n    \n    File dialogSubDir = new File(wekaHome.toString() + File.separator + \"systemDialogs\");\n    if (!dialogSubDir.exists()) {\n      if (!dialogSubDir.mkdir()) {\n        return;\n      }\n    }\n    \n    File dialogFile = new File(dialogSubDir.toString() + File.separator + dialogName);\n    dialogFile.createNewFile();\n  }\n   */  \n  /**\n   * For a named dialog, if the user has opted not to view it again, \n   * returns the answer the answer the user supplied when they\n   * closed the dialog. Returns null if the user did opt to view\n   * the dialog again.\n   * \n   * @param dialogName the name of the dialog to check (e.g.\n   * weka.gui.GUICHooser.HowToFindPackageManager).\n   * @return the answer the user supplied the last time they\n   * viewed the named dialog (if they opted not to view it again\n   * in the future) or null if the user opted to view the dialog\n   * again in the future.\n  public static String getDontShowDialogResponse(String dialogName) throws Exception {\n    if (!getDontShowDialog(dialogName)) {\n      return null; // This must be the first time - no file recorded yet.\n    }\n    \n    File wekaHome = WekaPackageManager.WEKA_HOME;\n    File dialogSubDir = new File(wekaHome.toString() + File.separator \n        + \"systemDialogs\" + File.separator + dialogName);\n\n    \n    BufferedReader br = new BufferedReader(new FileReader(dialogSubDir));\n    String response = br.readLine();\n    \n    br.close();\n    return response;\n  }\n   */\n  \n  /**\n   * Specify that the named dialog is not to be shown again in the future. \n   * Also records the answer that the user chose when closing the dialog.\n   * \n   * @param dialogName the name of the dialog to no longer display\n   * @param response the user selected response when they closed the dialog\n   * @throws Exception if there is a problem saving the information\n  public static void setDontShowDialogResponse(String dialogName, String response) \n    throws Exception {\n    \n    File wekaHome = WekaPackageManager.WEKA_HOME;\n    \n    if (!wekaHome.exists()) {\n      return;\n    }\n    \n    File dialogSubDir = new File(wekaHome.toString() + File.separator + \"systemDialogs\");\n    if (!dialogSubDir.exists()) {\n      if (!dialogSubDir.mkdir()) {\n        return;\n      }\n    }\n    \n    File dialogFile = new File(dialogSubDir.toString() + File.separator + dialogName);\n    BufferedWriter br = new BufferedWriter(new FileWriter(dialogFile));\n    br.write(response + \"\\n\");\n    br.flush();\n    br.close();\n  }\n   */\n\n  /**\n   * Breaks up the string, if wider than \"columns\" characters.\n   *\n   * @param s\t\tthe string to process\n   * @param columns\tthe width in columns\n   * @return\t\tthe processed string\n   */\n  public static String[] breakUp(String s, int columns) {\n    Vector\u003cString\u003e\tresult;\n    String\t\tline;\n    BreakIterator\tboundary;\n    int\t\t\tboundaryStart;\n    int\t\t\tboundaryEnd;\n    String\t\tword;\n    String\t\tpunctuation;\n    int\t\t\ti;\n    String[]\t\tlines;\n\n    result      = new Vector\u003cString\u003e();\n    punctuation = \" .,;:!?'\\\"\";\n    lines       = s.split(\"\\n\");\n\n    for (i = 0; i \u003c lines.length; i++) {\n      boundary      = BreakIterator.getWordInstance();\n      boundary.setText(lines[i]);\n      boundaryStart = boundary.first();\n      boundaryEnd   = boundary.next();\n      line          = \"\";\n\n      while (boundaryEnd != BreakIterator.DONE) {\n\tword = lines[i].substring(boundaryStart, boundaryEnd);\n\tif (line.length() \u003e= columns) {\n\t  if (word.length() == 1) {\n\t    if (punctuation.indexOf(word.charAt(0)) \u003e -1) {\n\t      line += word;\n\t      word = \"\";\n\t    }\n\t  }\n\t  result.add(line);\n\t  line = \"\";\n\t}\n\tline          += word;\n\tboundaryStart  = boundaryEnd;\n\tboundaryEnd    = boundary.next();\n      }\n      if (line.length() \u003e 0)\n\tresult.add(line);\n    }\n\n    return result.toArray(new String[result.size()]);\n  }\n\n  /**\n   * Returns the revision string.\n   * \n   * @return\t\tthe revision\n   */\n  public String getRevision() {\n    return RevisionUtils.extract(\"$Revision: 9736 $\");\n  }\n\n  /**\n   * Main method for testing this class.\n   *\n   * @param ops some dummy options\n   */\n  public static void main(String[] ops) {\n\n    double[] doublesWithNaN = {4.5, 6.7, Double.NaN, 3.4, 4.8, 1.2, 3.4};\n    double[] doubles = {4.5, 6.7, 6.7, 3.4, 4.8, 1.2, 3.4, 6.7, 6.7, 3.4};\n    int[] ints = {12, 6, 2, 18, 16, 6, 7, 5, 18, 18, 17};\n\n    try {\n\n      // Option handling\n      System.out.println(\"First option split up:\");\n      if (ops.length \u003e 0) {\n\tString[] firstOptionSplitUp = Utils.splitOptions(ops[0]);\n\tfor (int i = 0; i \u003c firstOptionSplitUp.length; i ++) {\n\t  System.out.println(firstOptionSplitUp[i]);\n\t}\n      }\t\t\t\t\t       \n      System.out.println(\"Partitioned options: \");\n      String[] partitionedOptions = Utils.partitionOptions(ops);\n      for (int i  = 0; i \u003c partitionedOptions.length; i++) {\n\tSystem.out.println(partitionedOptions[i]);\n      }\n      System.out.println(\"Get position of flag -f: \" + Utils.getOptionPos('f', ops));\n      System.out.println(\"Get flag -f: \" + Utils.getFlag('f', ops));\n      System.out.println(\"Get position of option -o: \" + Utils.getOptionPos('o', ops));\n      System.out.println(\"Get option -o: \" + Utils.getOption('o', ops));\n      System.out.println(\"Checking for remaining options... \");\n      Utils.checkForRemainingOptions(ops);\n      \n      // Statistics\n      System.out.println(\"Original array with NaN (doubles): \");\n      for (int i = 0; i \u003c doublesWithNaN.length; i++) {\n\tSystem.out.print(doublesWithNaN[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Original array (doubles): \");\n      for (int i = 0; i \u003c doubles.length; i++) {\n\tSystem.out.print(doubles[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Original array (ints): \");\n      for (int i = 0; i \u003c ints.length; i++) {\n\tSystem.out.print(ints[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Correlation: \" + Utils.correlation(doubles, doubles, \n\t\t\t\t\t\t\t     doubles.length));\n      System.out.println(\"Mean: \" + Utils.mean(doubles));\n      System.out.println(\"Variance: \" + Utils.variance(doubles));\n      System.out.println(\"Sum (doubles): \" + Utils.sum(doubles));\n      System.out.println(\"Sum (ints): \" + Utils.sum(ints));\n      System.out.println(\"Max index (doubles): \" + Utils.maxIndex(doubles));\n      System.out.println(\"Max index (ints): \" + Utils.maxIndex(ints));\n      System.out.println(\"Min index (doubles): \" + Utils.minIndex(doubles));\n      System.out.println(\"Min index (ints): \" + Utils.minIndex(ints));\n      System.out.println(\"Median (doubles): \" + \n                         Utils.kthSmallestValue(doubles, doubles.length / 2));\n      System.out.println(\"Median (ints): \" + \n      Utils.kthSmallestValue(ints, ints.length / 2));\n\n      // Sorting and normalizing\n      System.out.println(\"Sorted array with NaN (doubles): \");\n      int[] sorted = Utils.sort(doublesWithNaN);\n      for (int i = 0; i \u003c doublesWithNaN.length; i++) {\n\tSystem.out.print(doublesWithNaN[sorted[i]] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Sorted array (doubles): \");\n      sorted = Utils.sort(doubles);\n      for (int i = 0; i \u003c doubles.length; i++) {\n\tSystem.out.print(doubles[sorted[i]] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Sorted array (ints): \");\n      sorted = Utils.sort(ints);\n      for (int i = 0; i \u003c ints.length; i++) {\n\tSystem.out.print(ints[sorted[i]] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Indices from stable sort (doubles): \");\n      sorted = Utils.stableSort(doubles);\n      for (int i = 0; i \u003c doubles.length; i++) {\n\tSystem.out.print(sorted[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Indices from sort (ints): \");\n      sorted = Utils.sort(ints);\n      for (int i = 0; i \u003c ints.length; i++) {\n\tSystem.out.print(sorted[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Normalized array (doubles): \");\n      Utils.normalize(doubles);\n      for (int i = 0; i \u003c doubles.length; i++) {\n\tSystem.out.print(doubles[i] + \" \");\n      }\n      System.out.println();\n      System.out.println(\"Normalized again (doubles): \");\n      Utils.normalize(doubles, Utils.sum(doubles));\n      for (int i = 0; i \u003c doubles.length; i++) {\n\tSystem.out.print(doubles[i] + \" \");\n      }\n      System.out.println();\n      \n      // Pretty-printing\n      System.out.println(\"-4.58: \" + Utils.doubleToString(-4.57826535, 2));\n      System.out.println(\"-6.78: \" + Utils.doubleToString(-6.78214234, 6,2));\n      \n      // Comparisons\n      System.out.println(\"5.70001 == 5.7 ? \" + Utils.eq(5.70001, 5.7));\n      System.out.println(\"5.70001 \u003e 5.7 ? \" + Utils.gr(5.70001, 5.7));\n      System.out.println(\"5.70001 \u003e= 5.7 ? \" + Utils.grOrEq(5.70001, 5.7));\n      System.out.println(\"5.7 \u003c 5.70001 ? \" + Utils.sm(5.7, 5.70001));\n      System.out.println(\"5.7 \u003c= 5.70001 ? \" + Utils.smOrEq(5.7, 5.70001));\n      \n      // Math\n      System.out.println(\"Info (ints): \" + Utils.info(ints));\n      System.out.println(\"log2(4.6): \" + Utils.log2(4.6));\n      System.out.println(\"5 * log(5): \" + Utils.xlogx(5));\n      System.out.println(\"5.5 rounded: \" + Utils.round(5.5));\n      System.out.println(\"5.55555 rounded to 2 decimal places: \" + \n\t\t\t Utils.roundDouble(5.55555, 2));\n      \n      // Arrays\n      System.out.println(\"Array-Dimensions of 'new int[][]': \" + Utils.getArrayDimensions(new int[][]{}));\n      System.out.println(\"Array-Dimensions of 'new int[][]{{1,2,3},{4,5,6}}': \" + Utils.getArrayDimensions(new int[][]{{1,2,3},{4,5,6}}));\n      String[][][] s = new String[3][4][];\n      System.out.println(\"Array-Dimensions of 'new String[3][4][]': \" + Utils.getArrayDimensions(s));\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n  \n",
        "name": "Utils.java",
        "path": "src/weka/core/Utils.java",
        "url": "/github.com/sdujicun/FastShapeletSelection/-/blob/src/weka/core/Utils.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 1801,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 1802,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);"
        },
        {
          "limitHit": false,
          "lineNumber": 1803,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1852,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 1853,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);"
        },
        {
          "limitHit": false,
          "lineNumber": 1854,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1878,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 2039,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        }
      ],
      "repository": {
        "name": "github.com/sdujicun/FastShapeletSelection",
        "url": "/github.com/sdujicun/FastShapeletSelection"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23f09e63981f603a63dcb243669b6c2b25b6d850"
        },
        "content": "/*\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n/*\n *    Queue.java\n *    Copyright (C) 1999-2012 University of Waikato, Hamilton, New Zealand\n *\n *    Modified March-May 2004 by Mark Utting to add JML specs\n *    (this was done as the example solution of an assignment for a\n *     software engineering course, so the specifications are more precise\n *     and complete than one would normally do).\n *    Passed a static analysis using ESC/Java-2.0a6 with no warnings.\n */\n\npackage weka.core;\n\nimport java.io.Serializable;\n\n/** \n * Class representing a FIFO queue.\n *\n * @author Len Trigg (trigg@cs.waikato.ac.nz)\n * @version $Revision: 8034 $\n */\npublic class Queue\n  extends Object\n  implements Serializable, RevisionHandler {\n\n  /** for serialization */\n  private static final long serialVersionUID = -1141282001146389780L;\n\n  /**\n   * Represents one node in the queue.\n   */\n  protected class QueueNode\n    implements Serializable, RevisionHandler {\n\n    /** for serialization */\n    private static final long serialVersionUID = -5119358279412097455L;\n\n    /** The next node in the queue */\n    protected /*@ spec_public @*/ QueueNode m_Next;\n\n    /** The nodes contents\n     */\n    protected /*@ non_null spec_public @*/ Object m_Contents;\n\n    /** \n     * Creates a queue node with the given contents \n     */\n    //@ requires contents != null;\n    //@ assignable m_Contents, m_Next;\n    //@ ensures m_Contents == contents;\n    //@ ensures m_Next == null;\n    public QueueNode(Object contents) {\n      m_Contents = contents;\n      next(null);\n    }\n\n    /**\n     * Sets the next node in the queue, and returns it.\n     */\n    //@ requires next != this ;\n    //@ assignable m_Next;\n    //@ ensures m_Next==next \u0026\u0026 \\result==next;\n    public QueueNode next(QueueNode next) {\n      return m_Next = next;\n    } //@ nowarn Invariant; // Because it stupidly checks the Queue invariant!\n\n    /**\n     * Gets the next node in the queue. \n     */\n    //@ ensures \\result == m_Next;\n    public /*@ pure @*/ QueueNode next() {\n      return m_Next;\n    }\n\n    /**\n     * Sets the contents of the node.\n     */\n    //@ requires contents != null;\n    //@ assignable m_Contents;\n    //@ ensures  m_Contents == contents \u0026\u0026 \\result == contents;\n    public Object contents(Object contents) {\n      return m_Contents = contents;\n    }\n\n    /**\n     * Returns the contents in the node.\n     */\n      //@ ensures \\result == m_Contents;\n    public /*@ pure @*/ Object contents() {\n      return m_Contents;\n    }\n    \n    /**\n     * Returns the revision string.\n     * \n     * @return\t\tthe revision\n     */\n    public String getRevision() {\n      return RevisionUtils.extract(\"$Revision: 8034 $\");\n    }\n  }\n\n  /** Store a reference to the head of the queue */\n  protected /*@ spec_public @*/ QueueNode m_Head = null;\n\n  /** Store a reference to the tail of the queue */\n  protected /*@ spec_public @*/ QueueNode m_Tail = null;\n\n  /** Store the c m_Tail.m_Nexturrent number of elements in the queue */\n  protected /*@ spec_public @*/ int m_Size = 0;\n\n  //@ public invariant m_Head == null \u003c==\u003e m_Tail == null;\n  //@public invariant m_Tail != null ==\u003e m_Tail.m_Next == null;\n  //@ public invariant m_Size \u003e= 0;\n  //@ public invariant m_Size == 0 \u003c==\u003e m_Head == null;\n  //@ public invariant m_Size == 1 \u003c==\u003e m_Head != null \u0026\u0026 m_Head == m_Tail;\n  //@ public invariant m_Size \u003e 1 ==\u003e m_Head != m_Tail;\n  //@ public invariant m_Size \u003e 1 \u003c== m_Head != m_Tail;\n\n\n\n  /**\n   * Removes all objects from the queue m_Tail.m_Next.\n   */\n  //@ assignable m_Size, m_Head, m_Tail;\n  //@ ensures m_Size == 0;\n  //@ ensures m_Head == null;\n  //@ ensures m_Tail == null;\n  public final synchronized void removeAllElements() {\n    m_Size = 0;\n    m_Head = null;\n    m_Tail = null;\n  }\n\n  /**\n   * Appends an object to the back of the queue.\n   *\n   * @param item the object to be appended\n   * @return the object appended\n   */\n  //@ requires item != null;\n  //@ assignable m_Head, m_Tail, m_Tail.m_Next, m_Head.m_Next, m_Size;\n  //@ ensures m_Head != null;\n  //@ ensures m_Tail != \\old(m_Tail);\n  //@ ensures m_Size == \\old(m_Size) + 1;\n  //@ ensures \\old(m_Size) == 0 ==\u003e m_Head == m_Tail; \n  //@ ensures \\old(m_Size) != 0 ==\u003e m_Head == \\old(m_Head);\n  //@ ensures m_Tail.contents() == \\old(item);\n  //@ ensures \\result == item;\n  public synchronized Object push(Object item) {\n    QueueNode newNode = new QueueNode(item);\n    \n    if (m_Head == null) {\n      m_Head = m_Tail = newNode;\n    } else {\n      m_Tail = m_Tail.next(newNode);\n    }\n    m_Size++;\n    return item;\n  }\n\n  /**\n   * Pops an object from the front of the queue.\n   *\n   * @return the object at the front of the queue\n   * @exception RuntimeException if the queue is empty\n   */\n  //@ assignable m_Head, m_Tail, m_Size;\n  //@ ensures m_Size == \\old(m_Size) - 1;\n  //@ ensures m_Head == \\old(m_Head.m_Next);\n  //@ ensures m_Head != null ==\u003e m_Tail == \\old(m_Tail);\n  //@ ensures \\result == \\old(m_Head.m_Contents);\n  //@ signals (RuntimeException) \\old(m_Head) == null;\n  public synchronized Object pop() \n      throws RuntimeException   // REDUNDANT, BUT ESCJAVA REQUIRES THIS\n  {\n    if (m_Head == null) {\n\tthrow new RuntimeException(\"Queue is empty\");\n    }\n    Object retval = m_Head.contents();\n    m_Size--;\n    m_Head = m_Head.next();\n    // Here we need to either tell ESC/Java some facts about\n    // the contents of the list after popping off the head,\n    // or turn off the 'invariant' warnings.\n    //\n    //@ assume m_Size == 0 \u003c==\u003e m_Head == null;\n    //@ assume m_Size == 1 \u003c==\u003e m_Head == m_Tail;\n    if (m_Head == null) {\n      m_Tail = null;\n    }\n    return retval;\n  }\n\n  /**\n   * Gets object from the front of the queue.\n   *\n   * @return the object at the front of the queue\n   * @exception RuntimeException if the queue is empty\n   */\n  //@ ensures \\result == \\old(m_Head.m_Contents);\n  //@ signals (RuntimeException) \\old(m_Head) == null;\n  public /*@ pure @*/ synchronized Object peek() \n    throws RuntimeException\n  { \n    if (m_Head == null) {\n      throw new RuntimeException(\"Queue is empty\");\n    }\n    return m_Head.contents();\n  }\n\n  /**\n   * Checks if queue is empty.\n   * \n   * @return true if queue is empty\n   */\n  //@ ensures \\result \u003c==\u003e m_Head == null;\n  public /*@ pure @*/ boolean empty() {\n    return m_Head == null;\n  }\n\n  /**\n   * Gets queue's size.\n   *\n   * @return size of queue\n   */\n  //@ ensures \\result == m_Size;\n  public /*@ pure @*/ int size() {\n    return m_Size;\n  }\n\n  /**\n   * Produces textual description of queue.\n   *\n   * @return textual description of queue\n   */\n  //@ also\n  //@ ensures \\result != null;\n  //@ ensures (* \\result == textual description of the queue *);\n  public  /*@ pure @*/ String toString() {\n\n    String retval = \"Queue Contents \"+m_Size+\" elements\\n\";\n    QueueNode current = m_Head;\n    if (current == null) {\n      return retval + \"Empty\\n\";\n    } else {\n      while (current != null) {\n        retval += current.contents().toString()+\"\\n\"; //@nowarn Modifies;\n\tcurrent = current.next();\n      }\n    }\n    return retval;\n  } //@ nowarn Post;\n  \n  /**\n   * Returns the revision string.\n   * \n   * @return\t\tthe revision\n   */\n  public String getRevision() {\n    return RevisionUtils.extract(\"$Revision: 8034 $\");\n  }\n\n  /**\n   * Main method for testing this class.\n   *\n   * @param argv a set of strings that are pushed on a test queue\n   */\n  //@ requires argv.length \u003e= 0;\n  //@ requires argv != null;\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c argv.length; argv[i] != null);\n  public static void main(String [] argv) {\n\n    try {\n      Queue queue = new Queue();\n      for(int i = 0; i \u003c argv.length; i++) {\n\tqueue.push(argv[i]);\n      }\n      System.out.println(\"After pushing command line arguments\");\n      System.out.println(queue.toString());\n      while (!queue.empty()) {\n\tSystem.out.println(\"Pop: \" + queue.pop().toString());\n      }\n      // try one more pop, to make sure we get an exception\n      try \n\t{\n\t  queue.pop();\n\t  System.out.println(\"ERROR: pop did not throw exception!\");\n\t}\n      catch (RuntimeException ex)\n        {\n\t  System.out.println(\"Pop on empty queue correctly gave exception.\");\n\t}\n    } catch (Exception ex) {\n      System.out.println(ex.getMessage());\n    }\n  }\n}\n",
        "name": "Queue.java",
        "path": "src/weka/core/Queue.java",
        "url": "/github.com/sdujicun/FastShapeletSelection/-/blob/src/weka/core/Queue.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 62,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires contents != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 64,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures m_Contents == contents;"
        },
        {
          "limitHit": false,
          "lineNumber": 65,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures m_Next == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 74,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires next != this ;"
        },
        {
          "limitHit": false,
          "lineNumber": 76,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures m_Next==next \u0026\u0026 \\result==next;"
        },
        {
          "limitHit": false,
          "lineNumber": 84,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result == m_Next;"
        },
        {
          "limitHit": false,
          "lineNumber": 92,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires contents != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 102,
          "offsetAndLengths": [
            [
              6,
              12
            ]
          ],
          "preview": "      //@ ensures \\result == m_Contents;"
        },
        {
          "limitHit": false,
          "lineNumber": 140,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Size == 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 141,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 142,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Tail == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 155,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires item != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 157,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 158,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Tail != \\old(m_Tail);"
        },
        {
          "limitHit": false,
          "lineNumber": 159,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Size == \\old(m_Size) + 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 160,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\old(m_Size) == 0 ==\u003e m_Head == m_Tail; "
        },
        {
          "limitHit": false,
          "lineNumber": 161,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\old(m_Size) != 0 ==\u003e m_Head == \\old(m_Head);"
        },
        {
          "limitHit": false,
          "lineNumber": 162,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Tail.contents() == \\old(item);"
        },
        {
          "limitHit": false,
          "lineNumber": 163,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == item;"
        },
        {
          "limitHit": false,
          "lineNumber": 183,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Size == \\old(m_Size) - 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 184,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head == \\old(m_Head.m_Next);"
        },
        {
          "limitHit": false,
          "lineNumber": 185,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head != null ==\u003e m_Tail == \\old(m_Tail);"
        },
        {
          "limitHit": false,
          "lineNumber": 186,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == \\old(m_Head.m_Contents);"
        },
        {
          "limitHit": false,
          "lineNumber": 215,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == \\old(m_Head.m_Contents);"
        },
        {
          "limitHit": false,
          "lineNumber": 231,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e m_Head == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 241,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Size;"
        },
        {
          "limitHit": false,
          "lineNumber": 252,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 253,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures (* \\result == textual description of the queue *);"
        },
        {
          "limitHit": false,
          "lineNumber": 283,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires argv.length \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 284,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires argv != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 285,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c argv.length; argv[i] != null);"
        },
        {
          "limitHit": false,
          "lineNumber": 94,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  m_Contents == contents \u0026\u0026 \\result == contents;"
        }
      ],
      "repository": {
        "name": "github.com/sdujicun/FastShapeletSelection",
        "url": "/github.com/sdujicun/FastShapeletSelection"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23f09e63981f603a63dcb243669b6c2b25b6d850"
        },
        "content": "/*\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n/*\n *    Attribute.java\n *    Copyright (C) 1999-2012 University of Waikato, Hamilton, New Zealand\n *\n */\n\npackage weka.core;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.io.StreamTokenizer;\nimport java.io.StringReader;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Properties;\n\n/** \n * Class for handling an attribute. Once an attribute has been created,\n * it can't be changed. \u003cp\u003e\n *\n * The following attribute types are supported:\n * \u003cul\u003e\n *    \u003cli\u003e numeric: \u003cbr/\u003e\n *         This type of attribute represents a floating-point number.\n *    \u003c/li\u003e\n *    \u003cli\u003e nominal: \u003cbr/\u003e\n *         This type of attribute represents a fixed set of nominal values.\n *    \u003c/li\u003e\n *    \u003cli\u003e string: \u003cbr/\u003e\n *         This type of attribute represents a dynamically expanding set of\n *         nominal values. Usually used in text classification.\n *    \u003c/li\u003e\n *    \u003cli\u003e date: \u003cbr/\u003e\n *         This type of attribute represents a date, internally represented as \n *         floating-point number storing the milliseconds since January 1, \n *         1970, 00:00:00 GMT. The string representation of the date must be\n *         \u003ca href=\"http://www.iso.org/iso/en/prods-services/popstds/datesandtime.html\" target=\"_blank\"\u003e\n *         ISO-8601\u003c/a\u003e compliant, the default is \u003ccode\u003eyyyy-MM-dd'T'HH:mm:ss\u003c/code\u003e.\n *    \u003c/li\u003e\n *    \u003cli\u003e relational: \u003cbr/\u003e\n *         This type of attribute can contain other attributes and is, e.g., \n *         used for representing Multi-Instance data. (Multi-Instance data\n *         consists of a nominal attribute containing the bag-id, then a \n *         relational attribute with all the attributes of the bag, and \n *         finally the class attribute.)\n *    \u003c/li\u003e\n * \u003c/ul\u003e\n * \n * Typical usage (code from the main() method of this class): \u003cp\u003e\n *\n * \u003ccode\u003e\n * ... \u003cbr\u003e\n *\n * // Create numeric attributes \"length\" and \"weight\" \u003cbr\u003e\n * Attribute length = new Attribute(\"length\"); \u003cbr\u003e\n * Attribute weight = new Attribute(\"weight\"); \u003cbr\u003e\u003cbr\u003e\n * \n * // Create list to hold nominal values \"first\", \"second\", \"third\" \u003cbr\u003e\n * List\u003cString\u003e my_nominal_values = new ArrayList\u003cString\u003e(3); \u003cbr\u003e\n * my_nominal_values.add(\"first\"); \u003cbr\u003e\n * my_nominal_values.add(\"second\"); \u003cbr\u003e\n * my_nominal_values.add(\"third\"); \u003cbr\u003e\u003cbr\u003e\n *\n * // Create nominal attribute \"position\" \u003cbr\u003e\n * Attribute position = new Attribute(\"position\", my_nominal_values);\u003cbr\u003e\n *\n * ... \u003cbr\u003e\n * \u003c/code\u003e\u003cp\u003e\n *\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\n * @version $Revision: 9515 $\n */\npublic class Attribute\n  implements Copyable, Serializable, RevisionHandler {\n\n  /** for serialization */\n  static final long serialVersionUID = -742180568732916383L;\n  \n  /** Constant set for numeric attributes. */\n  public static final int NUMERIC = 0;\n\n  /** Constant set for nominal attributes. */\n  public static final int NOMINAL = 1;\n\n  /** Constant set for attributes with string values. */\n  public static final int STRING = 2;\n\n  /** Constant set for attributes with date values. */\n  public static final int DATE = 3;\n\n  /** Constant set for relation-valued attributes. */\n  public static final int RELATIONAL = 4;\n\n  /** Constant set for symbolic attributes. */\n  public static final int ORDERING_SYMBOLIC = 0;\n\n  /** Constant set for ordered attributes. */\n  public static final int ORDERING_ORDERED  = 1;\n\n  /** Constant set for modulo-ordered attributes. */\n  public static final int ORDERING_MODULO   = 2;\n\n  /** The keyword used to denote the start of an arff attribute declaration */\n  public final static String ARFF_ATTRIBUTE = \"@attribute\";\n\n  /** A keyword used to denote a numeric attribute */\n  public final static String ARFF_ATTRIBUTE_INTEGER = \"integer\";\n\n  /** A keyword used to denote a numeric attribute */\n  public final static String ARFF_ATTRIBUTE_REAL = \"real\";\n\n  /** A keyword used to denote a numeric attribute */\n  public final static String ARFF_ATTRIBUTE_NUMERIC = \"numeric\";\n\n  /** The keyword used to denote a string attribute */\n  public final static String ARFF_ATTRIBUTE_STRING = \"string\";\n\n  /** The keyword used to denote a date attribute */\n  public final static String ARFF_ATTRIBUTE_DATE = \"date\";\n\n  /** The keyword used to denote a relation-valued attribute */\n  public final static String ARFF_ATTRIBUTE_RELATIONAL = \"relational\";\n\n  /** The keyword used to denote the end of the declaration of a subrelation */\n  public final static String ARFF_END_SUBRELATION = \"@end\";\n\n  /** Dummy first value for String attributes (useful for sparse instances) */\n  public final static String DUMMY_STRING_VAL = \"*WEKA*DUMMY*STRING*FOR*STRING*ATTRIBUTES*\";\n\n  /** Strings longer than this will be stored compressed. */\n  private static final int STRING_COMPRESS_THRESHOLD = 200;\n\n  /** The attribute's name. */\n  private /*@ spec_public non_null @*/ String m_Name;\n\n  /** The attribute's type. */\n  private /*@ spec_public @*/ int m_Type;\n  /*@ invariant m_Type == NUMERIC || \n                m_Type == DATE || \n                m_Type == STRING || \n                m_Type == NOMINAL ||\n                m_Type == RELATIONAL;\n  */\n\n  /** The attribute's values (if nominal or string). */\n  private /*@ spec_public @*/ ArrayList\u003cObject\u003e m_Values;\n\n  /** Mapping of values to indices (if nominal or string). */\n  private Hashtable\u003cObject,Integer\u003e m_Hashtable;\n\n  /** The header information for a relation-valued attribute. */\n  private Instances m_Header;\n\n  /** Date format specification for date attributes */\n  private SimpleDateFormat m_DateFormat;\n\n  /** The attribute's index. */\n  private /*@ spec_public @*/ int m_Index;\n\n  /** The attribute's metadata. */\n  private ProtectedProperties m_Metadata;\n\n  /** The attribute's ordering. */\n  private int m_Ordering;\n\n  /** Whether the attribute is regular. */\n  private boolean m_IsRegular;\n\n  /** Whether the attribute is averagable. */\n  private boolean m_IsAveragable;\n\n  /** Whether the attribute has a zeropoint. */\n  private boolean m_HasZeropoint;\n\n  /** The attribute's weight. */\n  private double m_Weight;\n\n  /** The attribute's lower numeric bound. */\n  private double m_LowerBound;\n\n  /** Whether the lower bound is open. */\n  private boolean m_LowerBoundIsOpen;\n\n  /** The attribute's upper numeric bound. */\n  private double m_UpperBound;\n\n  /** Whether the upper bound is open */\n  private boolean m_UpperBoundIsOpen;\n\n  /**\n   * Constructor for a numeric attribute.\n   *\n   * @param attributeName the name for the attribute\n   */\n  //@ requires attributeName != null;\n  //@ ensures  m_Name == attributeName;\n  public Attribute(String attributeName) {\n\n    this(attributeName, new ProtectedProperties(new Properties()));\n  }\n\n  /**\n   * Constructor for a numeric attribute, where metadata is supplied.\n   *\n   * @param attributeName the name for the attribute\n   * @param metadata the attribute's properties\n   */\n  //@ requires attributeName != null;\n  //@ requires metadata != null;\n  //@ ensures  m_Name == attributeName;\n  public Attribute(String attributeName, ProtectedProperties metadata) {\n\n    m_Name = attributeName;\n    m_Index = -1;\n    m_Values = null;\n    m_Hashtable = null;\n    m_Header = null;\n    m_Type = NUMERIC;\n    setMetadata(metadata);\n  }\n\n  /**\n   * Constructor for a date attribute.\n   *\n   * @param attributeName the name for the attribute\n   * @param dateFormat a string suitable for use with\n   * SimpleDateFormatter for parsing dates.\n   */\n  //@ requires attributeName != null;\n  //@ requires dateFormat != null;\n  //@ ensures  m_Name == attributeName;\n  public Attribute(String attributeName, String dateFormat) {\n\n    this(attributeName, dateFormat,\n\t new ProtectedProperties(new Properties()));\n  }\n\n  /**\n   * Constructor for a date attribute, where metadata is supplied.\n   *\n   * @param attributeName the name for the attribute\n   * @param dateFormat a string suitable for use with\n   * SimpleDateFormatter for parsing dates.\n   * @param metadata the attribute's properties\n   */\n  //@ requires attributeName != null;\n  //@ requires dateFormat != null;\n  //@ requires metadata != null;\n  //@ ensures  m_Name == attributeName;\n  public Attribute(String attributeName, String dateFormat,\n\t\t   ProtectedProperties metadata) {\n\n    m_Name = attributeName;\n    m_Index = -1;\n    m_Values = null;\n    m_Hashtable = null;\n    m_Header = null;\n    m_Type = DATE;\n    if (dateFormat != null) {\n      m_DateFormat = new SimpleDateFormat(dateFormat);\n    } else {\n      m_DateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n    }\n    m_DateFormat.setLenient(false);\n    setMetadata(metadata);\n  }\n\n  /**\n   * Constructor for nominal attributes and string attributes.\n   * If a null vector of attribute values is passed to the method,\n   * the attribute is assumed to be a string.\n   *\n   * @param attributeName the name for the attribute\n   * @param attributeValues a vector of strings denoting the \n   * attribute values. Null if the attribute is a string attribute.\n   */\n  //@ requires attributeName != null;\n  //@ ensures  m_Name == attributeName;\n  public Attribute(String attributeName, \n\t\t   List\u003cString\u003e attributeValues) {\n\n    this(attributeName, attributeValues,\n\t new ProtectedProperties(new Properties()));\n  }\n\n  /**\n   * Constructor for nominal attributes and string attributes, where\n   * metadata is supplied. If a null vector of attribute values is passed\n   * to the method, the attribute is assumed to be a string.\n   *\n   * @param attributeName the name for the attribute\n   * @param attributeValues a vector of strings denoting the \n   * attribute values. Null if the attribute is a string attribute.\n   * @param metadata the attribute's properties\n   */\n  //@ requires attributeName != null;\n  //@ requires metadata != null;\n  /*@ ensures  m_Name == attributeName;\n      ensures  m_Index == -1;\n      ensures  attributeValues == null \u0026\u0026 m_Type == STRING\n            || attributeValues != null \u0026\u0026 m_Type == NOMINAL \n                  \u0026\u0026 m_Values.size() == attributeValues.size();\n      signals (IllegalArgumentException ex) \n                 (* if duplicate strings in attributeValues *);\n  */\n  public Attribute(String attributeName, \n\t\t   List\u003cString\u003e attributeValues,\n\t\t   ProtectedProperties metadata) {\n\n    m_Name = attributeName;\n    m_Index = -1;\n    if (attributeValues == null) {\n      m_Values = new ArrayList\u003cObject\u003e();\n      m_Hashtable = new Hashtable\u003cObject,Integer\u003e();\n      m_Header = null;\n      m_Type = STRING;\n\n      // Make sure there is at least one value so that string attribute\n      // values are always represented when output as part of a sparse instance.\n      addStringValue(DUMMY_STRING_VAL);\n    } else {\n      m_Values = new ArrayList\u003cObject\u003e(attributeValues.size());\n      m_Hashtable = new Hashtable\u003cObject,Integer\u003e(attributeValues.size());\n      m_Header = null;\n      for (int i = 0; i \u003c attributeValues.size(); i++) {\n\tObject store = attributeValues.get(i);\n\tif (((String)store).length() \u003e STRING_COMPRESS_THRESHOLD) {\n\t  try {\n\t    store = new SerializedObject(attributeValues.get(i), true);\n\t  } catch (Exception ex) {\n\t    System.err.println(\"Couldn't compress nominal attribute value -\"\n\t\t\t       + \" storing uncompressed.\");\n\t  }\n\t}\n\tif (m_Hashtable.containsKey(store)) {\n\t  throw new IllegalArgumentException(\"A nominal attribute (\" +\n\t\t\t\t\t     attributeName + \") cannot\"\n\t\t\t\t\t     + \" have duplicate labels (\" + store + \").\");\n\t}\n\tm_Values.add(store);\n\tm_Hashtable.put(store, new Integer(i));\n      }\n      m_Type = NOMINAL;\n    }\n    setMetadata(metadata);\n  }\n\n  /**\n   * Constructor for relation-valued attributes.\n   *\n   * @param attributeName the name for the attribute\n   * @param header an Instances object specifying the header of the relation.\n   */\n  public Attribute(String attributeName, Instances header) {\n\n    this(attributeName, header,\n\t new ProtectedProperties(new Properties()));\n  }\n\n  /**\n   * Constructor for relation-valued attributes.\n   *\n   * @param attributeName the name for the attribute\n   * @param header an Instances object specifying the header of the relation.\n   * @param metadata the attribute's properties\n   */\n  public Attribute(String attributeName, \n\t\t   Instances header,\n\t\t   ProtectedProperties metadata) {\n\n    if (header.numInstances() \u003e 0) {\n      throw new IllegalArgumentException(\"Header for relation-valued \" +\n                                         \"attribute should not contain \" +\n                                         \"any instances\");\n    }\n    m_Name = attributeName;\n    m_Index = -1;\n    m_Values = new ArrayList\u003cObject\u003e();\n    m_Hashtable = new Hashtable\u003cObject,Integer\u003e();\n    m_Header = header;\n    m_Type = RELATIONAL;\n    setMetadata(metadata);\n  }\n\n  /**\n   * Produces a shallow copy of this attribute.\n   *\n   * @return a copy of this attribute with the same index\n   */\n  //@ also ensures \\result instanceof Attribute;\n  public /*@ pure non_null @*/ Object copy() {\n\n    Attribute copy = new Attribute(m_Name);\n\n    copy.m_Index = m_Index;\n    copy.m_Type = m_Type;\n    copy.m_Values = m_Values;\n    copy.m_Hashtable = m_Hashtable;\n    copy.m_DateFormat = m_DateFormat;\n    copy.m_Header = m_Header;\n    copy.setMetadata(m_Metadata);\n \n    return copy;\n  }\n\n  /**\n   * Returns an enumeration of all the attribute's values if the\n   * attribute is nominal, string, or relation-valued, null otherwise.\n   *\n   * @return enumeration of all the attribute's values\n   */\n  public final /*@ pure @*/ Enumeration enumerateValues() {\n\n    if (isNominal() || isString()) {\n      final Enumeration ee = new WekaEnumeration(m_Values);\n      return new Enumeration () {\n          public boolean hasMoreElements() {\n            return ee.hasMoreElements();\n          }\n          public Object nextElement() {\n            Object oo = ee.nextElement();\n            if (oo instanceof SerializedObject) {\n              return ((SerializedObject)oo).getObject();\n            } else {\n              return oo;\n            }\n          }\n        };\n    }\n    return null;\n  }\n\n  /**\n   * Tests if given attribute is equal to this attribute.\n   *\n   * @param other the Object to be compared to this attribute\n   * @return true if the given attribute is equal to this attribute\n   */\n  public final /*@ pure @*/ boolean equals(Object other) {\n    return (equalsMsg(other) == null);\n  }\n\n  /**\n   * Tests if given attribute is equal to this attribute. If they're not\n   * the same a message detailing why they differ will be returned, otherwise\n   * null.\n   *\n   * @param other \tthe Object to be compared to this attribute\n   * @return \t\tnull if the given attribute is equal to this attribute\n   */\n  public final String equalsMsg(Object other) {\n    if (other == null)\n      return \"Comparing with null object\";\n    \n    if (!(other.getClass().equals(this.getClass())))\n      return \"Object has wrong class\";\n    \n    Attribute att = (Attribute) other;\n    if (!m_Name.equals(att.m_Name))\n      return \"Names differ: \" + m_Name + \" != \" + att.m_Name;\n\n    if (isNominal() \u0026\u0026 att.isNominal()) {\n      if (m_Values.size() != att.m_Values.size())\n        return \"Different number of labels: \" + m_Values.size() + \" != \" + att.m_Values.size();\n      \n      for (int i = 0; i \u003c m_Values.size(); i++) {\n        if (!m_Values.get(i).equals(att.m_Values.get(i)))\n          return \"Labels differ at position \" + (i+1) + \": \" + m_Values.get(i) + \" != \" + att.m_Values.get(i);\n      }\n      \n      return null;\n    } \n    \n    if (isRelationValued() \u0026\u0026 att.isRelationValued())\n      return m_Header.equalHeadersMsg(att.m_Header);\n    \n    if ((type() != att.type()))\n      return \"Types differ: \" + typeToString(this) + \" != \" + typeToString(att);\n    \n    return null;\n  }\n  \n  /**\n   * Returns a string representation of the attribute type.\n   * \n   * @param att\t\tthe attribute to return the type string for\n   * @return\t\tthe string representation of the attribute type\n   */\n  public static String typeToString(Attribute att) {\n    return typeToString(att.type());\n  }\n  \n  /**\n   * Returns a string representation of the attribute type.\n   * \n   * @param type\tthe type of the attribute\n   * @return\t\tthe string representation of the attribute type\n   */\n  public static String typeToString(int type) {\n    String\tresult;\n    \n    switch(type) {\n      case NUMERIC:\n\tresult = \"numeric\";\n\tbreak;\n\t\n      case NOMINAL:\n\tresult = \"nominal\";\n\tbreak;\n\t\n      case STRING:\n\tresult = \"string\";\n\tbreak;\n\t\n      case DATE:\n\tresult = \"date\";\n\tbreak;\n\t\n      case RELATIONAL:\n\tresult = \"relational\";\n\tbreak;\n\t\n      default:\n\tresult = \"unknown(\" + type + \")\";\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Returns a short string representation of the attribute type.\n   * \n   * @param att\t\tthe attribute to return the type string for\n   * @return\t\tthe string representation of the attribute type\n   */\n  public static String typeToStringShort(Attribute att) {\n    return typeToStringShort(att.type());\n  }\n  \n  /**\n   * Returns a short string representation of the attribute type.\n   * \n   * @param type\tthe type of the attribute\n   * @return\t\tthe string representation of the attribute type\n   */\n  public static String typeToStringShort(int type) {\n    String\tresult;\n    \n    switch(type) {\n      case NUMERIC:\n\tresult = \"Num\";\n\tbreak;\n\t\n      case NOMINAL:\n\tresult = \"Nom\";\n\tbreak;\n\t\n      case STRING:\n\tresult = \"Str\";\n\tbreak;\n\t\n      case DATE:\n\tresult = \"Dat\";\n\tbreak;\n\t\n      case RELATIONAL:\n\tresult = \"Rel\";\n\tbreak;\n\t\n      default:\n\tresult = \"???\";\n    }\n    \n    return result;\n  }\n\n  /**\n   * Returns the index of this attribute.\n   *\n   * @return the index of this attribute\n   */\n  //@ ensures \\result == m_Index;\n  public final /*@ pure @*/ int index() {\n\n    return m_Index;\n  }\n\n  /**\n   * Returns the index of a given attribute value. (The index of\n   * the first occurence of this value.)\n   *\n   * @param value the value for which the index is to be returned\n   * @return the index of the given attribute value if attribute\n   * is nominal or a string, -1 if it is not or the value \n   * can't be found\n   */\n  public final int indexOfValue(String value) {\n\n    if (!isNominal() \u0026\u0026 !isString())\n      return -1;\n    Object store = value;\n    if (value.length() \u003e STRING_COMPRESS_THRESHOLD) {\n      try {\n        store = new SerializedObject(value, true);\n      } catch (Exception ex) {\n        System.err.println(\"Couldn't compress string attribute value -\"\n                           + \" searching uncompressed.\");\n      }\n    }\n    Integer val = (Integer)m_Hashtable.get(store);\n    if (val == null) return -1;\n    else return val.intValue();\n  }\n\n  /**\n   * Test if the attribute is nominal.\n   *\n   * @return true if the attribute is nominal\n   */\n  //@ ensures \\result \u003c==\u003e (m_Type == NOMINAL);\n  public final /*@ pure @*/ boolean isNominal() {\n\n    return (m_Type == NOMINAL);\n  }\n\n  /**\n   * Tests if the attribute is numeric.\n   *\n   * @return true if the attribute is numeric\n   */\n  //@ ensures \\result \u003c==\u003e ((m_Type == NUMERIC) || (m_Type == DATE));\n  public final /*@ pure @*/ boolean isNumeric() {\n\n    return ((m_Type == NUMERIC) || (m_Type == DATE));\n  }\n\n  /**\n   * Tests if the attribute is relation valued.\n   *\n   * @return true if the attribute is relation valued\n   */\n  //@ ensures \\result \u003c==\u003e (m_Type == RELATIONAL);\n  public final /*@ pure @*/ boolean isRelationValued() {\n\n    return (m_Type == RELATIONAL);\n  }\n\n  /**\n   * Tests if the attribute is a string.\n   *\n   * @return true if the attribute is a string\n   */\n  //@ ensures \\result \u003c==\u003e (m_Type == STRING);\n  public final /*@ pure @*/ boolean isString() {\n\n    return (m_Type == STRING);\n  }\n\n  /**\n   * Tests if the attribute is a date type.\n   *\n   * @return true if the attribute is a date type\n   */\n  //@ ensures \\result \u003c==\u003e (m_Type == DATE);\n  public final /*@ pure @*/ boolean isDate() {\n\n    return (m_Type == DATE);\n  }\n\n  /**\n   * Returns the attribute's name.\n   *\n   * @return the attribute's name as a string\n   */\n  //@ ensures \\result == m_Name;\n  public final /*@ pure @*/ String name() {\n\n    return m_Name;\n  }\n  \n  /**\n   * Returns the number of attribute values. Returns 0 for \n   * attributes that are not either nominal, string, or\n   * relation-valued.\n   *\n   * @return the number of attribute values\n   */\n  public final /*@ pure @*/ int numValues() {\n\n    if (!isNominal() \u0026\u0026 !isString() \u0026\u0026 !isRelationValued()) {\n      return 0;\n    } else {\n      return m_Values.size();\n    }\n  }\n\n  /**\n   * Returns a description of this attribute in ARFF format. Quotes\n   * strings if they contain whitespace characters, or if they\n   * are a question mark.\n   *\n   * @return a description of this attribute as a string\n   */\n  public final String toString() {\n    \n    StringBuffer text = new StringBuffer();\n    \n    text.append(ARFF_ATTRIBUTE).append(\" \").append(Utils.quote(m_Name)).append(\" \");\n    switch (m_Type) {\n    case NOMINAL:\n      text.append('{');\n      Enumeration enu = enumerateValues();\n      while (enu.hasMoreElements()) {\n\ttext.append(Utils.quote((String) enu.nextElement()));\n\tif (enu.hasMoreElements())\n\t  text.append(',');\n      }\n      text.append('}');\n      break;\n    case NUMERIC:\n      text.append(ARFF_ATTRIBUTE_NUMERIC);\n      break;\n    case STRING:\n      text.append(ARFF_ATTRIBUTE_STRING);\n      break;\n    case DATE:\n      text.append(ARFF_ATTRIBUTE_DATE).append(\" \").append(Utils.quote(m_DateFormat.toPattern()));\n      break;\n    case RELATIONAL:\n      text.append(ARFF_ATTRIBUTE_RELATIONAL).append(\"\\n\");\n      Enumeration enm = m_Header.enumerateAttributes();\n      while (enm.hasMoreElements()) {\n        text.append(enm.nextElement()).append(\"\\n\");\n      }\n      text.append(ARFF_END_SUBRELATION).append(\" \").append(Utils.quote(m_Name));\n      break;\n    default:\n      text.append(\"UNKNOWN\");\n      break;\n    }\n    return text.toString();\n  }\n\n  /**\n   * Returns the attribute's type as an integer.\n   *\n   * @return the attribute's type.\n   */\n  //@ ensures \\result == m_Type;\n  public final /*@ pure @*/ int type() {\n\n    return m_Type;\n  }\n  \n  /**\n   * Returns the Date format pattern in case this attribute is of type DATE,\n   * otherwise an empty string.\n   * \n   * @return the date format pattern\n   * @see SimpleDateFormat\n   */\n  public final String getDateFormat() {\n    if (isDate())\n      return m_DateFormat.toPattern();\n    else\n      return \"\";\n  }\n\n  /**\n   * Returns a value of a nominal or string attribute.  Returns an\n   * empty string if the attribute is neither a string nor a nominal\n   * attribute.\n   *\n   * @param valIndex the value's index\n   * @return the attribute's value as a string\n   */\n  public final /*@ non_null pure @*/ String value(int valIndex) {\n    \n    if (!isNominal() \u0026\u0026 !isString()) {\n      return \"\";\n    } else {\n      Object val = m_Values.get(valIndex);\n      \n      // If we're storing strings compressed, uncompress it.\n      if (val instanceof SerializedObject) {\n        val = ((SerializedObject)val).getObject();\n      }\n      return (String) val;\n    }\n  }\n\n  /**\n   * Returns the header info for a relation-valued attribute,\n   * null if the attribute is not relation-valued.\n   *\n   * @return the attribute's value as an Instances object\n   */\n  public final /*@ non_null pure @*/ Instances relation() {\n    \n    if (!isRelationValued()) {\n      return null;\n    } else {\n      return m_Header;\n    }\n  }\n\n  /**\n   * Returns a value of a relation-valued attribute. Returns\n   * null if the attribute is not relation-valued.\n   *\n   * @param valIndex the value's index\n   * @return the attribute's value as an Instances object\n   */\n  public final /*@ non_null pure @*/ Instances relation(int valIndex) {\n    \n    if (!isRelationValued()) {\n      return null;\n    } else {\n      return (Instances) m_Values.get(valIndex);\n    }\n  }\n\n  /**\n   * Constructor for a numeric attribute with a particular index.\n   *\n   * @param attributeName the name for the attribute\n   * @param index the attribute's index\n   */\n  //@ requires attributeName != null;\n  //@ requires index \u003e= 0;\n  //@ ensures  m_Name == attributeName;\n  //@ ensures  m_Index == index;\n  public Attribute(String attributeName, int index) {\n\n    this(attributeName);\n    m_Index = index;\n  }\n\n  /**\n   * Constructor for date attributes with a particular index.\n   *\n   * @param attributeName the name for the attribute\n   * @param dateFormat a string suitable for use with\n   * SimpleDateFormatter for parsing dates.  Null for a default format\n   * string.\n   * @param index the attribute's index\n   */\n  //@ requires attributeName != null;\n  //@ requires index \u003e= 0;\n  //@ ensures  m_Name == attributeName;\n  //@ ensures  m_Index == index;\n  public Attribute(String attributeName, String dateFormat, \n\t    int index) {\n\n    this(attributeName, dateFormat);\n    m_Index = index;\n  }\n\n  /**\n   * Constructor for nominal attributes and string attributes with\n   * a particular index.\n   * If a null vector of attribute values is passed to the method,\n   * the attribute is assumed to be a string.\n   *\n   * @param attributeName the name for the attribute\n   * @param attributeValues a vector of strings denoting the attribute values.\n   * Null if the attribute is a string attribute.\n   * @param index the attribute's index\n   */\n  //@ requires attributeName != null;\n  //@ requires index \u003e= 0;\n  //@ ensures  m_Name == attributeName;\n  //@ ensures  m_Index == index;\n  public Attribute(String attributeName, List\u003cString\u003e attributeValues, \n\t    int index) {\n\n    this(attributeName, attributeValues);\n    m_Index = index;\n  }\n\n  /**\n   * Constructor for a relation-valued attribute with a particular index.\n   *\n   * @param attributeName the name for the attribute\n   * @param header the header information for this attribute\n   * @param index the attribute's index\n   */\n  //@ requires attributeName != null;\n  //@ requires index \u003e= 0;\n  //@ ensures  m_Name == attributeName;\n  //@ ensures  m_Index == index;\n  public Attribute(String attributeName, Instances header,\n\t    int index) {\n\n    this(attributeName, header);\n    m_Index = index;\n  }\n\n  /**\n   * Adds a string value to the list of valid strings for attributes\n   * of type STRING and returns the index of the string.\n   *\n   * @param value The string value to add\n   * @return the index assigned to the string, or -1 if the attribute is not\n   * of type Attribute.STRING \n   */\n  /*@ requires value != null;\n      ensures  isString() \u0026\u0026 0 \u003c= \\result \u0026\u0026 \\result \u003c m_Values.size() ||\n             ! isString() \u0026\u0026 \\result == -1;\n  */\n  public int addStringValue(String value) {\n\n    if (!isString()) {\n      return -1;\n    }\n    Object store = value;\n\n    if (value.length() \u003e STRING_COMPRESS_THRESHOLD) {\n      try {\n        store = new SerializedObject(value, true);\n      } catch (Exception ex) {\n        System.err.println(\"Couldn't compress string attribute value -\"\n                           + \" storing uncompressed.\");\n      }\n    }\n    Integer index = (Integer)m_Hashtable.get(store);\n    if (index != null) {\n      return index.intValue();\n    } else {\n      int intIndex = m_Values.size();\n      m_Values.add(store);\n      m_Hashtable.put(store, new Integer(intIndex));\n      return intIndex;\n    }\n  }\n  \n  /**\n   * Clear the map and list of values and set them to contain\n   * just the supplied value\n   * \n   * @param value the current (and only) value of this String attribute\n   */\n  public void setStringValue(String value) {\n    if (!isString()) {\n      return;\n    }\n    \n    m_Hashtable.clear();\n    m_Values.clear();\n    addStringValue(value);\n  }\n\n  /**\n   * Adds a string value to the list of valid strings for attributes\n   * of type STRING and returns the index of the string. This method is\n   * more efficient than addStringValue(String) for long strings.\n   *\n   * @param src The Attribute containing the string value to add.\n   * @param index the index of the string value in the source attribute.\n   * @return the index assigned to the string, or -1 if the attribute is not\n   * of type Attribute.STRING \n   */\n  /*@ requires src != null;\n      requires 0 \u003c= index \u0026\u0026 index \u003c src.m_Values.size();\n      ensures  isString() \u0026\u0026 0 \u003c= \\result \u0026\u0026 \\result \u003c m_Values.size() ||\n             ! isString() \u0026\u0026 \\result == -1;\n  */\n  public int addStringValue(Attribute src, int index) {\n\n    if (!isString()) {\n      return -1;\n    }\n    Object store = src.m_Values.get(index);\n    Integer oldIndex = (Integer)m_Hashtable.get(store);\n    if (oldIndex != null) {\n      return oldIndex.intValue();\n    } else {\n      int intIndex = m_Values.size();\n      m_Values.add(store);\n      m_Hashtable.put(store, new Integer(intIndex));\n      return intIndex;\n    }\n  }\n\n  /**\n   * Adds a relation to a relation-valued attribute.\n   *\n   * @param value The value to add\n   * @return the index assigned to the value, or -1 if the attribute is not\n   * of type Attribute.RELATIONAL \n   */\n  public int addRelation(Instances value) {\n\n    if (!isRelationValued()) {\n      return -1;\n    }\n    if (!m_Header.equalHeaders(value)) {\n      throw new IllegalArgumentException(\"Incompatible value for \" +\n                                         \"relation-valued attribute.\\n\" + \n                                         m_Header.equalHeadersMsg(value));\n    }\n    Integer index = (Integer)m_Hashtable.get(value);\n    if (index != null) {\n      return index.intValue();\n    } else {\n      int intIndex = m_Values.size();\n      m_Values.add(value);\n      m_Hashtable.put(value, new Integer(intIndex));\n      return intIndex;\n    }\n  }\n\n  /**\n   * Adds an attribute value. Creates a fresh list of attribute\n   * values before adding it.\n   *\n   * @param value the attribute value\n   */\n  final void addValue(String value) {\n\n    m_Values = Utils.cast(m_Values.clone());\n    m_Hashtable = Utils.cast(m_Hashtable.clone());\n    forceAddValue(value);\n  }\n\n  /**\n   * Produces a shallow copy of this attribute with a new name.\n   *\n   * @param newName the name of the new attribute\n   * @return a copy of this attribute with the same index\n   */\n  //@ requires newName != null;\n  //@ ensures \\result.m_Name  == newName;\n  //@ ensures \\result.m_Index == m_Index;\n  //@ ensures \\result.m_Type  == m_Type;\n  public final /*@ pure non_null @*/ Attribute copy(String newName) {\n\n    Attribute copy = new Attribute(newName);\n\n    copy.m_Index = m_Index;\n    copy.m_DateFormat = m_DateFormat;\n    copy.m_Type = m_Type;\n    copy.m_Values = m_Values;\n    copy.m_Hashtable = m_Hashtable;\n    copy.m_Header = m_Header;\n    copy.setMetadata(m_Metadata);\n \n    return copy;\n  }\n\n  /**\n   * Removes a value of a nominal, string, or relation-valued\n   * attribute. Creates a fresh list of attribute values before\n   * removing it.\n   *\n   * @param index the value's index\n   * @throws IllegalArgumentException if the attribute is not \n   * of the correct type\n   */\n  //@ requires isNominal() || isString() || isRelationValued();\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Values.size();\n  final void delete(int index) {\n    \n    if (!isNominal() \u0026\u0026 !isString() \u0026\u0026 !isRelationValued()) \n      throw new IllegalArgumentException(\"Can only remove value of \" +\n                                         \"nominal, string or relation-\" +\n                                         \" valued attribute!\");\n    else {\n      m_Values = Utils.cast(m_Values.clone());\n      m_Values.remove(index);\n      if (!isRelationValued()) {\n        Hashtable\u003cObject,Integer\u003e hash = new Hashtable\u003cObject,Integer\u003e(m_Hashtable.size());\n        Enumeration enu = m_Hashtable.keys();\n        while (enu.hasMoreElements()) {\n          Object string = enu.nextElement();\n          Integer valIndexObject = (Integer)m_Hashtable.get(string);\n          int valIndex = valIndexObject.intValue();\n          if (valIndex \u003e index) {\n            hash.put(string, new Integer(valIndex - 1));\n          } else if (valIndex \u003c index) {\n            hash.put(string, valIndexObject);\n          }\n        }\n        m_Hashtable = hash;\n      }\n    }\n  }\n\n  /**\n   * Adds an attribute value.\n   *\n   * @param value the attribute value\n   */\n  //@ requires value != null;\n  //@ ensures  m_Values.size() == \\old(m_Values.size()) + 1;\n  final void forceAddValue(String value) {\n\n    Object store = value;\n    if (value.length() \u003e STRING_COMPRESS_THRESHOLD) {\n      try {\n        store = new SerializedObject(value, true);\n      } catch (Exception ex) {\n        System.err.println(\"Couldn't compress string attribute value -\"\n                           + \" storing uncompressed.\");\n      }\n    }\n    m_Values.add(store);\n    m_Hashtable.put(store, new Integer(m_Values.size() - 1));\n  }\n\n  /**\n   * Sets the index of this attribute.\n   *\n   * @param index the index of this attribute\n   */\n  //@ requires 0 \u003c= index;\n  //@ assignable m_Index;\n  //@ ensures m_Index == index;\n  final void setIndex(int index) {\n\n    m_Index = index;\n  }\n\n  /**\n   * Sets a value of a nominal attribute or string attribute.\n   * Creates a fresh list of attribute values before it is set.\n   *\n   * @param index the value's index\n   * @param string the value\n   * @throws IllegalArgumentException if the attribute is not nominal or \n   * string.\n   */\n  //@ requires string != null;\n  //@ requires isNominal() || isString();\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Values.size();\n  final void setValue(int index, String string) {\n    \n    switch (m_Type) {\n    case NOMINAL:\n    case STRING:\n      m_Values = Utils.cast(m_Values.clone());\n      m_Hashtable = Utils.cast(m_Hashtable.clone());\n      Object store = string;\n      if (string.length() \u003e STRING_COMPRESS_THRESHOLD) {\n        try {\n          store = new SerializedObject(string, true);\n        } catch (Exception ex) {\n          System.err.println(\"Couldn't compress string attribute value -\"\n                             + \" storing uncompressed.\");\n        }\n      }\n      m_Hashtable.remove(m_Values.get(index));\n      m_Values.set(index, store);\n      m_Hashtable.put(store, new Integer(index));\n      break;\n    default:\n      throw new IllegalArgumentException(\"Can only set values for nominal\"\n                                         + \" or string attributes!\");\n    }\n  }\n\n  /**\n   * Sets a value of a relation-valued attribute.\n   * Creates a fresh list of attribute values before it is set.\n   *\n   * @param index the value's index\n   * @param data the value\n   * @throws IllegalArgumentException if the attribute is not \n   * relation-valued.\n   */\n  final void setValue(int index, Instances data) {\n    \n    if (isRelationValued()) { \n      if (!data.equalHeaders(m_Header)) {\n        throw new IllegalArgumentException(\"Can't set relational value. \" +\n                                           \"Headers not compatible.\\n\" +\n                                           data.equalHeadersMsg(m_Header));\n      }\n      m_Values = Utils.cast(m_Values.clone());\n      m_Values.set(index, data);\n    } else {\n      throw new IllegalArgumentException(\"Can only set value for\"\n                                         + \" relation-valued attributes!\");\n    }\n  }\n\n  /**\n   * Returns the given amount of milliseconds formatted according to the\n   * current Date format.\n   * \n   * @param date \tthe date, represented in milliseconds since \n   * \t\t\tJanuary 1, 1970, 00:00:00 GMT, to return as string\n   * @return \t\tthe formatted date\n   */\n  //@ requires isDate();\n  public /*@pure@*/ String formatDate(double date) {\n    switch (m_Type) {\n    case DATE:\n      return m_DateFormat.format(new Date((long)date));\n    default:\n      throw new IllegalArgumentException(\"Can only format date values for date\"\n                                         + \" attributes!\");\n    }\n  }\n\n  /**\n   * Parses the given String as Date, according to the current format and\n   * returns the corresponding amount of milliseconds.\n   * \n   * @param string the date to parse\n   * @return the date in milliseconds since January 1, 1970, 00:00:00 GMT\n   * @throws ParseException if parsing fails\n   */\n  //@ requires isDate();\n  //@ requires string != null;\n  public double parseDate(String string) throws ParseException {\n    switch (m_Type) {\n    case DATE:\n      long time = m_DateFormat.parse(string).getTime();\n      // TODO put in a safety check here if we can't store the value in a double.\n      return (double)time;\n    default:\n      throw new IllegalArgumentException(\"Can only parse date values for date\"\n                                         + \" attributes!\");\n    }\n  }\n\n  /**\n   * Returns the properties supplied for this attribute.\n   *\n   * @return metadata for this attribute\n   */  \n  public final /*@ pure @*/ ProtectedProperties getMetadata() {\n\n    return m_Metadata;\n  }\n\n  /**\n   * Returns the ordering of the attribute. One of the following:\n   * \n   * ORDERING_SYMBOLIC - attribute values should be treated as symbols.\n   * ORDERING_ORDERED  - attribute values have a global ordering.\n   * ORDERING_MODULO   - attribute values have an ordering which wraps.\n   *\n   * @return the ordering type of the attribute\n   */\n  public final /*@ pure @*/ int ordering() {\n\n    return m_Ordering;\n  }\n\n  /**\n   * Returns whether the attribute values are equally spaced.\n   *\n   * @return whether the attribute is regular or not\n   */\n  public final /*@ pure @*/ boolean isRegular() {\n\n    return m_IsRegular;\n  }\n\n  /**\n   * Returns whether the attribute can be averaged meaningfully.\n   *\n   * @return whether the attribute can be averaged or not\n   */\n  public final /*@ pure @*/ boolean isAveragable() {\n\n    return m_IsAveragable;\n  }\n\n  /**\n   * Returns whether the attribute has a zeropoint and may be\n   * added meaningfully.\n   *\n   * @return whether the attribute has a zeropoint or not\n   */\n  public final /*@ pure @*/ boolean hasZeropoint() {\n\n    return m_HasZeropoint;\n  }\n\n  /**\n   * Returns the attribute's weight.\n   *\n   * @return the attribute's weight as a double\n   */\n  public final /*@ pure @*/ double weight() {\n\n    return m_Weight;\n  }\n\n  /**\n   * Sets the new attribute's weight\n   * \n   * @param value\tthe new weight\n   */\n  public void setWeight(double value) {\n    Properties\tprops;\n    Enumeration names;\n    String\tname;\n    \n    m_Weight = value;\n\n    // generate new metadata object\n    props = new Properties();\n    names = m_Metadata.propertyNames();\n    while (names.hasMoreElements()) {\n      name = (String) names.nextElement();\n      if (!name.equals(\"weight\"))\n\tprops.setProperty(name, m_Metadata.getProperty(name));\n    }\n    props.setProperty(\"weight\", \"\" + m_Weight);\n    m_Metadata = new ProtectedProperties(props);\n  }\n  \n  /**\n   * Returns the lower bound of a numeric attribute.\n   *\n   * @return the lower bound of the specified numeric range\n   */\n  public final /*@ pure @*/ double getLowerNumericBound() {\n\n    return m_LowerBound;\n  }\n\n  /**\n   * Returns whether the lower numeric bound of the attribute is open.\n   *\n   * @return whether the lower numeric bound is open or not (closed)\n   */\n  public final /*@ pure @*/ boolean lowerNumericBoundIsOpen() {\n\n    return m_LowerBoundIsOpen;\n  }\n\n  /**\n   * Returns the upper bound of a numeric attribute.\n   *\n   * @return the upper bound of the specified numeric range\n   */\n  public final /*@ pure @*/ double getUpperNumericBound() {\n\n    return m_UpperBound;\n  }\n\n  /**\n   * Returns whether the upper numeric bound of the attribute is open.\n   *\n   * @return whether the upper numeric bound is open or not (closed)\n   */\n  public final /*@ pure @*/ boolean upperNumericBoundIsOpen() {\n\n    return m_UpperBoundIsOpen;\n  }\n\n  /**\n   * Determines whether a value lies within the bounds of the attribute.\n   *\n   * @param value the value to check\n   * @return whether the value is in range\n   */\n  public final /*@ pure @*/ boolean isInRange(double value) {\n\n    // dates and missing values are a special case \n    if (m_Type == DATE || Utils.isMissingValue(value)) return true;\n    if (m_Type != NUMERIC) {\n      // do label range check\n      int intVal = (int) value;\n      if (intVal \u003c 0 || intVal \u003e= m_Hashtable.size()) return false;\n    } else {\n      // do numeric bounds check\n      if (m_LowerBoundIsOpen) {\n\tif (value \u003c= m_LowerBound) return false;\n      } else {\n\tif (value \u003c m_LowerBound) return false;\n      }\n      if (m_UpperBoundIsOpen) {\n\tif (value \u003e= m_UpperBound) return false;\n      } else {\n\tif (value \u003e m_UpperBound) return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Sets the metadata for the attribute. Processes the strings stored in the\n   * metadata of the attribute so that the properties can be set up for the\n   * easy-access metadata methods. Any strings sought that are omitted will\n   * cause default values to be set.\n   * \n   * The following properties are recognised:\n   * ordering, averageable, zeropoint, regular, weight, and range.\n   *\n   * All other properties can be queried and handled appropriately by classes\n   * calling the getMetadata() method.\n   *\n   * @param metadata the metadata\n   * @throws IllegalArgumentException if the properties are not consistent\n   */\n  //@ requires metadata != null;\n  private void setMetadata(ProtectedProperties metadata) {\n    \n    m_Metadata = metadata;\n\n    if (m_Type == DATE) {\n      m_Ordering = ORDERING_ORDERED;\n      m_IsRegular = true;\n      m_IsAveragable = false;\n      m_HasZeropoint = false;\n    } else {\n\n      // get ordering\n      String orderString = m_Metadata.getProperty(\"ordering\",\"\");\n      \n      // numeric ordered attributes are averagable and zeropoint by default\n      String def;\n      if (m_Type == NUMERIC\n\t  \u0026\u0026 orderString.compareTo(\"modulo\") != 0\n\t  \u0026\u0026 orderString.compareTo(\"symbolic\") != 0)\n\tdef = \"true\";\n      else def = \"false\";\n      \n      // determine boolean states\n      m_IsAveragable =\n\t(m_Metadata.getProperty(\"averageable\",def).compareTo(\"true\") == 0);\n      m_HasZeropoint =\n\t(m_Metadata.getProperty(\"zeropoint\",def).compareTo(\"true\") == 0);\n      // averagable or zeropoint implies regular\n      if (m_IsAveragable || m_HasZeropoint) def = \"true\";\n      m_IsRegular =\n\t(m_Metadata.getProperty(\"regular\",def).compareTo(\"true\") == 0);\n      \n      // determine ordering\n      if (orderString.compareTo(\"symbolic\") == 0)\n\tm_Ordering = ORDERING_SYMBOLIC;\n      else if (orderString.compareTo(\"ordered\") == 0)\n\tm_Ordering = ORDERING_ORDERED;\n      else if (orderString.compareTo(\"modulo\") == 0)\n\tm_Ordering = ORDERING_MODULO;\n      else {\n\tif (m_Type == NUMERIC || m_IsAveragable || m_HasZeropoint)\n\t  m_Ordering = ORDERING_ORDERED;\n\telse m_Ordering = ORDERING_SYMBOLIC;\n      }\n    }\n\n    // consistency checks\n    if (m_IsAveragable \u0026\u0026 !m_IsRegular)\n      throw new IllegalArgumentException(\"An averagable attribute must be\"\n\t\t\t\t\t + \" regular\");\n    if (m_HasZeropoint \u0026\u0026 !m_IsRegular)\n      throw new IllegalArgumentException(\"A zeropoint attribute must be\"\n\t\t\t\t\t + \" regular\");\n    if (m_IsRegular \u0026\u0026 m_Ordering == ORDERING_SYMBOLIC)\n      throw new IllegalArgumentException(\"A symbolic attribute cannot be\"\n\t\t\t\t\t + \" regular\");\n    if (m_IsAveragable \u0026\u0026 m_Ordering != ORDERING_ORDERED)\n      throw new IllegalArgumentException(\"An averagable attribute must be\"\n\t\t\t\t\t + \" ordered\");\n    if (m_HasZeropoint \u0026\u0026 m_Ordering != ORDERING_ORDERED)\n      throw new IllegalArgumentException(\"A zeropoint attribute must be\"\n\t\t\t\t\t + \" ordered\");\n\n    // determine weight\n    m_Weight = 1.0;\n    String weightString = m_Metadata.getProperty(\"weight\");\n    if (weightString != null) {\n      try{\n\tm_Weight = Double.valueOf(weightString).doubleValue();\n      } catch (NumberFormatException e) {\n\t// Check if value is really a number\n\tthrow new IllegalArgumentException(\"Not a valid attribute weight: '\" \n\t\t\t\t\t   + weightString + \"'\");\n      }\n    }\n\n    // determine numeric range\n    if (m_Type == NUMERIC) setNumericRange(m_Metadata.getProperty(\"range\"));\n  }\n\n  /**\n   * Sets the numeric range based on a string. If the string is null the range\n   * will default to [-inf,+inf]. A square brace represents a closed interval, a\n   * curved brace represents an open interval, and 'inf' represents infinity.\n   * Examples of valid range strings: \"[-inf,20)\",\"(-13.5,-5.2)\",\"(5,inf]\"\n   *\n   * @param rangeString the string to parse as the attribute's numeric range\n   * @throws IllegalArgumentException if the range is not valid\n   */\n  //@ requires rangeString != null;\n  private void setNumericRange(String rangeString)\n  {\n    // set defaults\n    m_LowerBound = Double.NEGATIVE_INFINITY;\n    m_LowerBoundIsOpen = false;\n    m_UpperBound = Double.POSITIVE_INFINITY;\n    m_UpperBoundIsOpen = false;\n\n    if (rangeString == null) return;\n\n    // set up a tokenzier to parse the string\n    StreamTokenizer tokenizer =\n      new StreamTokenizer(new StringReader(rangeString));\n    tokenizer.resetSyntax();         \n    tokenizer.whitespaceChars(0, ' ');    \n    tokenizer.wordChars(' '+1,'\\u00FF');\n    tokenizer.ordinaryChar('[');\n    tokenizer.ordinaryChar('(');\n    tokenizer.ordinaryChar(',');\n    tokenizer.ordinaryChar(']');\n    tokenizer.ordinaryChar(')');\n\n    try {\n\n      // get opening brace\n      tokenizer.nextToken();\n    \n      if (tokenizer.ttype == '[') m_LowerBoundIsOpen = false;\n      else if (tokenizer.ttype == '(') m_LowerBoundIsOpen = true;\n      else throw new IllegalArgumentException(\"Expected opening brace on range,\"\n\t\t\t\t\t      + \" found: \"\n\t\t\t\t\t      + tokenizer.toString());\n\n      // get lower bound\n      tokenizer.nextToken();\n      if (tokenizer.ttype != tokenizer.TT_WORD)\n\tthrow new IllegalArgumentException(\"Expected lower bound in range,\"\n\t\t\t\t\t   + \" found: \"\n\t\t\t\t\t   + tokenizer.toString());\n      if (tokenizer.sval.compareToIgnoreCase(\"-inf\") == 0)\n\tm_LowerBound = Double.NEGATIVE_INFINITY;\n      else if (tokenizer.sval.compareToIgnoreCase(\"+inf\") == 0)\n\tm_LowerBound = Double.POSITIVE_INFINITY;\n      else if (tokenizer.sval.compareToIgnoreCase(\"inf\") == 0)\n\tm_LowerBound = Double.NEGATIVE_INFINITY;\n      else try {\n\tm_LowerBound = Double.valueOf(tokenizer.sval).doubleValue();\n      } catch (NumberFormatException e) {\n\tthrow new IllegalArgumentException(\"Expected lower bound in range,\"\n\t\t\t\t\t   + \" found: '\" + tokenizer.sval + \"'\");\n      }\n\n      // get separating comma\n      if (tokenizer.nextToken() != ',')\n\tthrow new IllegalArgumentException(\"Expected comma in range,\"\n\t\t\t\t\t   + \" found: \"\n\t\t\t\t\t   + tokenizer.toString());\n\n      // get upper bound\n      tokenizer.nextToken();\n      if (tokenizer.ttype != tokenizer.TT_WORD)\n\tthrow new IllegalArgumentException(\"Expected upper bound in range,\"\n\t\t\t\t\t   + \" found: \"\n\t\t\t\t\t   + tokenizer.toString());\n      if (tokenizer.sval.compareToIgnoreCase(\"-inf\") == 0)\n\tm_UpperBound = Double.NEGATIVE_INFINITY;\n      else if (tokenizer.sval.compareToIgnoreCase(\"+inf\") == 0)\n\tm_UpperBound = Double.POSITIVE_INFINITY;\n      else if (tokenizer.sval.compareToIgnoreCase(\"inf\") == 0)\n\tm_UpperBound = Double.POSITIVE_INFINITY;\n      else try {\n\tm_UpperBound = Double.valueOf(tokenizer.sval).doubleValue();\n      } catch (NumberFormatException e) {\n\tthrow new IllegalArgumentException(\"Expected upper bound in range,\"\n\t\t\t\t\t   + \" found: '\" + tokenizer.sval + \"'\");\n      }\n\n      // get closing brace\n      tokenizer.nextToken();\n    \n      if (tokenizer.ttype == ']') m_UpperBoundIsOpen = false;\n      else if (tokenizer.ttype == ')') m_UpperBoundIsOpen = true;\n      else throw new IllegalArgumentException(\"Expected closing brace on range,\"\n\t\t\t\t\t      + \" found: \"\n\t\t\t\t\t      + tokenizer.toString());\n\n      // check for rubbish on end\n      if (tokenizer.nextToken() != tokenizer.TT_EOF)\n\tthrow new IllegalArgumentException(\"Expected end of range string,\"\n\t\t\t\t\t   + \" found: \"\n\t\t\t\t\t   + tokenizer.toString());\n\n    } catch (IOException e) {\n      throw new IllegalArgumentException(\"IOException reading attribute range\"\n\t\t\t\t\t + \" string: \" + e.getMessage());\n    }\n\n    if (m_UpperBound \u003c m_LowerBound)\n      throw new IllegalArgumentException(\"Upper bound (\" + m_UpperBound\n\t\t\t\t\t + \") on numeric range is\"\n\t\t\t\t\t + \" less than lower bound (\"\n\t\t\t\t\t + m_LowerBound + \")!\");\n  }\n  \n  /**\n   * Returns the revision string.\n   * \n   * @return\t\tthe revision\n   */\n  public String getRevision() {\n    return RevisionUtils.extract(\"$Revision: 9515 $\");\n  }\n\n  /**\n   * Simple main method for testing this class.\n   * \n   * @param ops the commandline options\n   */\n  //@ requires ops != null;\n  //@ requires \\nonnullelements(ops);\n  public static void main(String[] ops) {\n\n    try {\n      \n      // Create numeric attributes \"length\" and \"weight\"\n      Attribute length = new Attribute(\"length\");\n      Attribute weight = new Attribute(\"weight\");\n\n      // Create date attribute \"date\"\n      Attribute date = new Attribute(\"date\", \"yyyy-MM-dd HH:mm:ss\");\n\n      System.out.println(date);\n      double dd = date.parseDate(\"2001-04-04 14:13:55\");\n      System.out.println(\"Test date = \" + dd);\n      System.out.println(date.formatDate(dd));\n\n      dd = new Date().getTime();\n      System.out.println(\"Date now = \" + dd);\n      System.out.println(date.formatDate(dd));\n      \n      // Create vector to hold nominal values \"first\", \"second\", \"third\" \n      List\u003cString\u003e my_nominal_values = new ArrayList\u003cString\u003e(3); \n      my_nominal_values.add(\"first\"); \n      my_nominal_values.add(\"second\"); \n      my_nominal_values.add(\"third\"); \n      \n      // Create nominal attribute \"position\" \n      Attribute position = new Attribute(\"position\", my_nominal_values);\n\n      // Print the name of \"position\"\n      System.out.println(\"Name of \\\"position\\\": \" + position.name());\n\n      // Print the values of \"position\"\n      Enumeration attValues = position.enumerateValues();\n      while (attValues.hasMoreElements()) {\n\tString string = (String)attValues.nextElement();\n\tSystem.out.println(\"Value of \\\"position\\\": \" + string);\n      }\n\n      // Shallow copy attribute \"position\"\n      Attribute copy = (Attribute) position.copy();\n\n      // Test if attributes are the same\n      System.out.println(\"Copy is the same as original: \" + copy.equals(position));\n\n      // Print index of attribute \"weight\" (should be unset: -1)\n      System.out.println(\"Index of attribute \\\"weight\\\" (should be -1): \" + \n\t\t\t weight.index());\n\n      // Print index of value \"first\" of attribute \"position\"\n      System.out.println(\"Index of value \\\"first\\\" of \\\"position\\\" (should be 0): \" +\n\t\t\t position.indexOfValue(\"first\"));\n\n      // Tests type of attribute \"position\"\n      System.out.println(\"\\\"position\\\" is numeric: \" + position.isNumeric());\n      System.out.println(\"\\\"position\\\" is nominal: \" + position.isNominal());\n      System.out.println(\"\\\"position\\\" is string: \" + position.isString());\n\n      // Prints name of attribute \"position\"\n      System.out.println(\"Name of \\\"position\\\": \" + position.name());\n    \n      // Prints number of values of attribute \"position\"\n      System.out.println(\"Number of values for \\\"position\\\": \" + position.numValues());\n\n      // Prints the values (againg)\n      for (int i = 0; i \u003c position.numValues(); i++) {\n\tSystem.out.println(\"Value \" + i + \": \" + position.value(i));\n      }\n\n      // Prints the attribute \"position\" in ARFF format\n      System.out.println(position);\n\n      // Checks type of attribute \"position\" using constants\n      switch (position.type()) {\n      case Attribute.NUMERIC:\n\tSystem.out.println(\"\\\"position\\\" is numeric\");\n\tbreak;\n      case Attribute.NOMINAL:\n\tSystem.out.println(\"\\\"position\\\" is nominal\");\n\tbreak;\n      case Attribute.STRING:\n\tSystem.out.println(\"\\\"position\\\" is string\");\n\tbreak;\n      case Attribute.DATE:\n\tSystem.out.println(\"\\\"position\\\" is date\");\n\tbreak;\n      case Attribute.RELATIONAL:\n\tSystem.out.println(\"\\\"position\\\" is relation-valued\");\n\tbreak;\n      default:\n\tSystem.out.println(\"\\\"position\\\" has unknown type\");\n      }\n\n      ArrayList\u003cAttribute\u003e atts = new ArrayList\u003cAttribute\u003e(1);\n      atts.add(position);\n      Instances relation = new Instances(\"Test\", atts, 0);\n      Attribute relationValuedAtt = new Attribute(\"test\", relation);\n      System.out.println(relationValuedAtt);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n  \n",
        "name": "Attribute.java",
        "path": "src/weka/core/Attribute.java",
        "url": "/github.com/sdujicun/FastShapeletSelection/-/blob/src/weka/core/Attribute.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 214,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 227,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 228,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires metadata != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 248,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 249,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires dateFormat != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 265,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 266,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires dateFormat != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 267,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires metadata != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 296,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 315,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 316,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires metadata != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 601,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Index;"
        },
        {
          "limitHit": false,
          "lineNumber": 639,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e (m_Type == NOMINAL);"
        },
        {
          "limitHit": false,
          "lineNumber": 650,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e ((m_Type == NUMERIC) || (m_Type == DATE));"
        },
        {
          "limitHit": false,
          "lineNumber": 661,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e (m_Type == RELATIONAL);"
        },
        {
          "limitHit": false,
          "lineNumber": 672,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e (m_Type == STRING);"
        },
        {
          "limitHit": false,
          "lineNumber": 683,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e (m_Type == DATE);"
        },
        {
          "limitHit": false,
          "lineNumber": 694,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Name;"
        },
        {
          "limitHit": false,
          "lineNumber": 768,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Type;"
        },
        {
          "limitHit": false,
          "lineNumber": 848,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 849,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 867,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 868,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 889,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 890,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 907,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 908,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 1051,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires newName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1052,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result.m_Name  == newName;"
        },
        {
          "limitHit": false,
          "lineNumber": 1053,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result.m_Index == m_Index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1054,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result.m_Type  == m_Type;"
        },
        {
          "limitHit": false,
          "lineNumber": 1079,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires isNominal() || isString() || isRelationValued();"
        },
        {
          "limitHit": false,
          "lineNumber": 1080,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Values.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 1113,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires value != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1135,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1137,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Index == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1152,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires string != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1153,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires isNominal() || isString();"
        },
        {
          "limitHit": false,
          "lineNumber": 1154,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Values.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 1214,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires isDate();"
        },
        {
          "limitHit": false,
          "lineNumber": 1233,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires isDate();"
        },
        {
          "limitHit": false,
          "lineNumber": 1234,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires string != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1421,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires metadata != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1511,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires rangeString != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1630,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires ops != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1631,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires \\nonnullelements(ops);"
        },
        {
          "limitHit": false,
          "lineNumber": 215,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 229,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 250,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 268,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 297,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 850,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 851,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Index == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 869,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 870,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Index == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 891,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 892,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Index == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 909,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 910,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Index == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1114,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Values.size() == \\old(m_Values.size()) + 1;"
        }
      ],
      "repository": {
        "name": "github.com/sdujicun/FastShapeletSelection",
        "url": "/github.com/sdujicun/FastShapeletSelection"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23f09e63981f603a63dcb243669b6c2b25b6d850"
        },
        "content": "/*\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n/*\n *    SingleIndex.java\n *    Copyright (C) 2003-2012 University of Waikato, Hamilton, New Zealand\n *\n */\n\npackage weka.core;\n\nimport java.io.Serializable;\n\n/** \n * Class representing a single cardinal number. The number is set by a \n * string representation such as: \u003cP\u003e\n *\n * \u003ccode\u003e\n *   first\n *   last\n *   1\n *   3\n * \u003c/code\u003e \u003cP\u003e\n * The number is internally converted from 1-based to 0-based (so methods that \n * set or get numbers not in string format should use 0-based numbers).\n *\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\n * @version $Revision: 8034 $\n */\npublic class SingleIndex\n  implements Serializable, RevisionHandler, CustomDisplayStringProvider {\n  \n  /** for serialization. */\n  static final long serialVersionUID = 5285169134430839303L;\n\n  /** Record the string representation of the number. */\n  protected /*@non_null spec_public@*/ String m_IndexString = \"\";\n\n  /** The selected index. */\n  protected /*@ spec_public @*/ int m_SelectedIndex = -1;\n\n  /** Store the maximum value permitted. -1 indicates that no upper\n      value has been set */\n  protected /*@ spec_public @*/ int m_Upper = -1;\n\n  /**\n   * Default constructor.\n   *\n   */\n  //@ assignable m_IndexString, m_SelectedIndex, m_Upper;\n  //@ ensures m_SelectedIndex == -1;\n  //@ ensures m_Upper == -1;\n  public SingleIndex() {\n  }\n\n  /**\n   * Constructor to set initial index.\n   *\n   * @param index the initial index\n   * @throws IllegalArgumentException if the index is invalid\n   */\n  //@ assignable m_IndexString, m_SelectedIndex, m_Upper;\n  //@ ensures m_IndexString == index;\n  //@ ensures m_SelectedIndex == -1;\n  //@ ensures m_Upper == -1;\n  public SingleIndex(/*@non_null@*/ String index) {\n\n    setSingleIndex(index);\n  }\n\n  /**\n   * Sets the value of \"last\".\n   *\n   * @param newUpper the value of \"last\"\n   */\n  //@ assignable m_Upper, m_IndexString, m_SelectedIndex;\n  //@ ensures newUpper \u003c 0 ==\u003e m_Upper == \\old(m_Upper);\n  //@ ensures newUpper \u003e= 0 ==\u003e m_Upper == newUpper;\n  public void setUpper(int newUpper) {\n\n    if (newUpper \u003e= 0) {\n      m_Upper = newUpper;\n      setValue();\n    }\n  }\n\n  /**\n   * Gets the string representing the selected range of values.\n   *\n   * @return the range selection string\n   */\n  //@ ensures \\result == m_IndexString;\n  public /*@pure@*/ String getSingleIndex() {\n\n    return m_IndexString;\n  }\n\n  /**\n   * Sets the index from a string representation. Note that setUpper()\n   * must be called for the value to be actually set\n   *\n   * @param index the index set\n   * @throws IllegalArgumentException if the index was not well formed\n   */\n  //@ assignable m_IndexString, m_SelectedIndex;\n  //@ ensures m_IndexString == index;\n  //@ ensures m_SelectedIndex == -1;\n  public void setSingleIndex(/*@non_null@*/ String index) {\n\n    m_IndexString = index;\n    m_SelectedIndex = -1;\n  }\n\n  /**\n   * Constructs a representation of the current range. Being a string\n   * representation, the numbers are based from 1.\n   * \n   * @return the string representation of the current range\n   */\n  //@ also signals (RuntimeException e) \\old(m_Upper) \u003c 0;\n  //@ ensures \\result != null;\n  public /*@pure@*/ String toString() {\n\n    if (m_IndexString.equals(\"\")) {\n      return \"No index set\";\n    }\n    if (m_Upper == -1) {\n      throw new RuntimeException(\"Upper limit has not been specified\");\n    }\n    return m_IndexString;\n  }\n\n  /**\n   * Gets the selected index.\n   *\n   * @return the selected index\n   * @throws RuntimeException if the upper limit of the index hasn't been defined\n   */\n  //@ requires m_Upper \u003e= 0;\n  //@ requires m_IndexString.length() \u003e 0;\n  //@ ensures \\result == m_SelectedIndex;\n  public /*@pure@*/ int getIndex() {\n\n    if (m_IndexString.equals(\"\")) {\n      throw new RuntimeException(\"No index set\");\n    }\n    if (m_Upper == -1) {\n      throw new RuntimeException(\"No upper limit has been specified for index\");\n    }\n    return m_SelectedIndex;\n  }\n\n  /**\n   * Creates a string representation of the given index.\n   *\n   * @param index the index to turn into a string.\n   * Since the index will typically come from a program, indices are assumed\n   * from 0, and thus will have 1 added in the String representation.\n   * @return the string representation\n   */\n  //@ requires index \u003e= 0;\n  public static /*@pure non_null@*/ String indexToString(int index) {\n\n    return \"\" + (index + 1);\n  }\n\n  /**\n   * Translates a single string selection into it's internal 0-based equivalent.\n   */\n  //@ assignable m_SelectedIndex, m_IndexString;\n  protected void setValue() {\n\n    if (m_IndexString.equals(\"\")) {\n      throw new RuntimeException(\"No index set\");\n    }\n    if (m_IndexString.toLowerCase().equals(\"first\")) {\n      m_SelectedIndex = 0;\n    } else if (m_IndexString.toLowerCase().equals(\"last\")) {\n      m_SelectedIndex = m_Upper;\n    } else {\n      m_SelectedIndex = Integer.parseInt(m_IndexString) - 1;\n      if (m_SelectedIndex \u003c 0) {\n\tm_IndexString = \"\";\n\tthrow new IllegalArgumentException(\"Index must be greater than zero\");\n      }\n      if (m_SelectedIndex \u003e m_Upper) {\n\tm_IndexString = \"\";\n\tthrow new IllegalArgumentException(\"Index is too large\");\n      }\n    }\n  }\n  \n  /**\n   * Returns the revision string.\n   * \n   * @return\t\tthe revision\n   */\n  public String getRevision() {\n    return RevisionUtils.extract(\"$Revision: 8034 $\");\n  }\n\n  /**\n   * Returns the custom display string.\n   * \n   * @return\t\tthe string\n   */\n  public String toDisplay() {\n    return getSingleIndex();\n  }\n\n  /**\n   * Main method for testing this class.\n   *\n   * @param argv one parameter: a test index specification\n   */\n  //@ requires \\nonnullelements(argv);\n  public static void main(/*@non_null@*/ String [] argv) {\n\n    try {\n      if (argv.length == 0) {\n\tthrow new Exception(\"Usage: SingleIndex \u003cindexspec\u003e\");\n      }\n      SingleIndex singleIndex = new SingleIndex();\n      singleIndex.setSingleIndex(argv[0]);\n      singleIndex.setUpper(9);\n      System.out.println(\"Input: \" + argv[0] + \"\\n\"\n\t\t\t + singleIndex.toString());\n      int selectedIndex = singleIndex.getIndex();\n      System.out.println(selectedIndex + \"\");\n    } catch (Exception ex) {\n      ex.printStackTrace();\n      System.out.println(ex.getMessage());\n    }\n  }\n}\n",
        "name": "SingleIndex.java",
        "path": "src/weka/core/SingleIndex.java",
        "url": "/github.com/sdujicun/FastShapeletSelection/-/blob/src/weka/core/SingleIndex.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 62,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_SelectedIndex == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 63,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Upper == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 74,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_IndexString == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 75,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_SelectedIndex == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 76,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Upper == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 88,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures newUpper \u003c 0 ==\u003e m_Upper == \\old(m_Upper);"
        },
        {
          "limitHit": false,
          "lineNumber": 89,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures newUpper \u003e= 0 ==\u003e m_Upper == newUpper;"
        },
        {
          "limitHit": false,
          "lineNumber": 103,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_IndexString;"
        },
        {
          "limitHit": false,
          "lineNumber": 117,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_IndexString == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 118,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_SelectedIndex == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 132,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 150,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Upper \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 151,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_IndexString.length() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 152,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_SelectedIndex;"
        },
        {
          "limitHit": false,
          "lineNumber": 172,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 227,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires \\nonnullelements(argv);"
        }
      ],
      "repository": {
        "name": "github.com/sdujicun/FastShapeletSelection",
        "url": "/github.com/sdujicun/FastShapeletSelection"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23f09e63981f603a63dcb243669b6c2b25b6d850"
        },
        "content": "/*\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n/*\n *    OptionHandler.java\n *    Copyright (C) 1999-2012 University of Waikato, Hamilton, New Zealand\n *\n */\n\npackage weka.core;\n\nimport java.util.Enumeration;\n\n/** \n * Interface to something that understands options.\n *\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\n * @author Len Trigg (trigg@cs.waikato.ac.nz)\n * @version $Revision: 8034 $\n */\npublic interface OptionHandler {\n\n  /**\n   * Returns an enumeration of all the available options..\n   *\n   * @return an enumeration of all available options.\n   */\n  Enumeration listOptions();\n\n  /**\n   * Sets the OptionHandler's options using the given list. All options\n   * will be set (or reset) during this call (i.e. incremental setting\n   * of options is not possible).\n   *\n   * @param options the list of options as an array of strings\n   * @exception Exception if an option is not supported\n   */\n  //@ requires options != null;\n  //@ requires \\nonnullelements(options);\n  void setOptions(String[] options) throws Exception;\n\n  /**\n   * Gets the current option settings for the OptionHandler.\n   *\n   * @return the list of current option settings as an array of strings\n   */\n  //@ ensures \\result != null;\n  //@ ensures \\nonnullelements(\\result);\n  /*@pure@*/ String[] getOptions();\n}\n\n\n\n\n\n\n\n\n",
        "name": "OptionHandler.java",
        "path": "src/weka/core/OptionHandler.java",
        "url": "/github.com/sdujicun/FastShapeletSelection/-/blob/src/weka/core/OptionHandler.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 49,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires options != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 50,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires \\nonnullelements(options);"
        },
        {
          "limitHit": false,
          "lineNumber": 58,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 59,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\nonnullelements(\\result);"
        }
      ],
      "repository": {
        "name": "github.com/sdujicun/FastShapeletSelection",
        "url": "/github.com/sdujicun/FastShapeletSelection"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "23f09e63981f603a63dcb243669b6c2b25b6d850"
        },
        "content": "/*\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n/*\n *    WekaEnumeration.java\n *    Copyright (C) 2009-2012 University of Waikato, Hamilton, New Zealand\n *\n */\npackage weka.core;\n\nimport java.util.Enumeration;\nimport java.util.List;\n\n/**\n * Class for enumerating an array list's elements.\n */\npublic class WekaEnumeration\n  implements Enumeration, RevisionHandler {\n  \n  /** The counter. */\n  private int m_Counter;\n  // These JML commands say how m_Counter implements Enumeration\n  //@ in moreElements;\n  //@ private represents moreElements = m_Counter \u003c m_Vector.size();\n  //@ private invariant 0 \u003c= m_Counter \u0026\u0026 m_Counter \u003c= m_Vector.size();\n  \n  /** The vector. */\n  private /*@non_null@*/ List m_Vector;\n  \n  /** Special element. Skipped during enumeration. */\n  private int m_SpecialElement;\n  //@ private invariant -1 \u003c= m_SpecialElement;\n  //@ private invariant m_SpecialElement \u003c m_Vector.size();\n  //@ private invariant m_SpecialElement\u003e=0 ==\u003e m_Counter!=m_SpecialElement;\n  \n  /**\n   * Constructs an enumeration.\n   *\n   * @param vector the vector which is to be enumerated\n   */\n  public WekaEnumeration(/*@non_null@*/List vector) {\n    \n    m_Counter = 0;\n    m_Vector = vector;\n    m_SpecialElement = -1;\n  }\n  \n  /**\n   * Constructs an enumeration with a special element.\n   * The special element is skipped during the enumeration.\n   *\n   * @param vector the vector which is to be enumerated\n   * @param special the index of the special element\n   */\n  //@ requires 0 \u003c= special \u0026\u0026 special \u003c vector.size();\n  public WekaEnumeration(/*@non_null@*/List vector, int special){\n    \n    m_Vector = vector;\n    m_SpecialElement = special;\n    if (special == 0) {\n      m_Counter = 1;\n    } else {\n      m_Counter = 0;\n    }\n  }\n  \n  \n  /**\n   * Tests if there are any more elements to enumerate.\n   *\n   * @return true if there are some elements left\n   */\n  public final /*@pure@*/ boolean hasMoreElements() {\n    \n    if (m_Counter \u003c m_Vector.size()) {\n      return true;\n    }\n    return false;\n  }\n  \n  /**\n   * Returns the next element.\n   *\n   * @return the next element to be enumerated\n   */\n  //@ also requires hasMoreElements();\n  public final Object nextElement() {\n    \n    Object result = m_Vector.get(m_Counter);\n    \n    m_Counter++;\n    if (m_Counter == m_SpecialElement) {\n      m_Counter++;\n    }\n    return result;\n  }\n  \n  /**\n   * Returns the revision string.\n   * \n   * @return\t\tthe revision\n   */\n  public String getRevision() {\n    return RevisionUtils.extract(\"$Revision: 8034 $\");\n  }\n}\n",
        "name": "WekaEnumeration.java",
        "path": "src/weka/core/WekaEnumeration.java",
        "url": "/github.com/sdujicun/FastShapeletSelection/-/blob/src/weka/core/WekaEnumeration.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 66,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= special \u0026\u0026 special \u003c vector.size();"
        }
      ],
      "repository": {
        "name": "github.com/sdujicun/FastShapeletSelection",
        "url": "/github.com/sdujicun/FastShapeletSelection"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 121,
  "ElapsedMilliseconds": 995,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
