{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/andrecamara/weka-android lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "4eef1b0916c85e8339cd32d672affca3d58e4c3f"
        },
        "content": "/*\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n/*\n *    Queue.java\n *    Copyright (C) 1999-2012 University of Waikato, Hamilton, New Zealand\n *\n *    Modified March-May 2004 by Mark Utting to add JML specs\n *    (this was done as the example solution of an assignment for a\n *     software engineering course, so the specifications are more precise\n *     and complete than one would normally do).\n *    Passed a static analysis using ESC/Java-2.0a6 with no warnings.\n */\n\npackage weka.core;\n\nimport java.io.Serializable;\n\n/** \n * Class representing a FIFO queue.\n *\n * @author Len Trigg (trigg@cs.waikato.ac.nz)\n * @version $Revision: 8034 $\n */\npublic class Queue\n  extends Object\n  implements Serializable, RevisionHandler {\n\n  /** for serialization */\n  private static final long serialVersionUID = -1141282001146389780L;\n\n  /**\n   * Represents one node in the queue.\n   */\n  protected class QueueNode\n    implements Serializable, RevisionHandler {\n\n    /** for serialization */\n    private static final long serialVersionUID = -5119358279412097455L;\n\n    /** The next node in the queue */\n    protected /*@ spec_public @*/ QueueNode m_Next;\n\n    /** The nodes contents\n     */\n    protected /*@ non_null spec_public @*/ Object m_Contents;\n\n    /** \n     * Creates a queue node with the given contents \n     */\n    //@ requires contents != null;\n    //@ assignable m_Contents, m_Next;\n    //@ ensures m_Contents == contents;\n    //@ ensures m_Next == null;\n    public QueueNode(Object contents) {\n      m_Contents = contents;\n      next(null);\n    }\n\n    /**\n     * Sets the next node in the queue, and returns it.\n     */\n    //@ requires next != this ;\n    //@ assignable m_Next;\n    //@ ensures m_Next==next \u0026\u0026 \\result==next;\n    public QueueNode next(QueueNode next) {\n      return m_Next = next;\n    } //@ nowarn Invariant; // Because it stupidly checks the Queue invariant!\n\n    /**\n     * Gets the next node in the queue. \n     */\n    //@ ensures \\result == m_Next;\n    public /*@ pure @*/ QueueNode next() {\n      return m_Next;\n    }\n\n    /**\n     * Sets the contents of the node.\n     */\n    //@ requires contents != null;\n    //@ assignable m_Contents;\n    //@ ensures  m_Contents == contents \u0026\u0026 \\result == contents;\n    public Object contents(Object contents) {\n      return m_Contents = contents;\n    }\n\n    /**\n     * Returns the contents in the node.\n     */\n      //@ ensures \\result == m_Contents;\n    public /*@ pure @*/ Object contents() {\n      return m_Contents;\n    }\n    \n    /**\n     * Returns the revision string.\n     * \n     * @return\t\tthe revision\n     */\n    public String getRevision() {\n      return RevisionUtils.extract(\"$Revision: 8034 $\");\n    }\n  }\n\n  /** Store a reference to the head of the queue */\n  protected /*@ spec_public @*/ QueueNode m_Head = null;\n\n  /** Store a reference to the tail of the queue */\n  protected /*@ spec_public @*/ QueueNode m_Tail = null;\n\n  /** Store the c m_Tail.m_Nexturrent number of elements in the queue */\n  protected /*@ spec_public @*/ int m_Size = 0;\n\n  //@ public invariant m_Head == null \u003c==\u003e m_Tail == null;\n  //@public invariant m_Tail != null ==\u003e m_Tail.m_Next == null;\n  //@ public invariant m_Size \u003e= 0;\n  //@ public invariant m_Size == 0 \u003c==\u003e m_Head == null;\n  //@ public invariant m_Size == 1 \u003c==\u003e m_Head != null \u0026\u0026 m_Head == m_Tail;\n  //@ public invariant m_Size \u003e 1 ==\u003e m_Head != m_Tail;\n  //@ public invariant m_Size \u003e 1 \u003c== m_Head != m_Tail;\n\n\n\n  /**\n   * Removes all objects from the queue m_Tail.m_Next.\n   */\n  //@ assignable m_Size, m_Head, m_Tail;\n  //@ ensures m_Size == 0;\n  //@ ensures m_Head == null;\n  //@ ensures m_Tail == null;\n  public final synchronized void removeAllElements() {\n    m_Size = 0;\n    m_Head = null;\n    m_Tail = null;\n  }\n\n  /**\n   * Appends an object to the back of the queue.\n   *\n   * @param item the object to be appended\n   * @return the object appended\n   */\n  //@ requires item != null;\n  //@ assignable m_Head, m_Tail, m_Tail.m_Next, m_Head.m_Next, m_Size;\n  //@ ensures m_Head != null;\n  //@ ensures m_Tail != \\old(m_Tail);\n  //@ ensures m_Size == \\old(m_Size) + 1;\n  //@ ensures \\old(m_Size) == 0 ==\u003e m_Head == m_Tail; \n  //@ ensures \\old(m_Size) != 0 ==\u003e m_Head == \\old(m_Head);\n  //@ ensures m_Tail.contents() == \\old(item);\n  //@ ensures \\result == item;\n  public synchronized Object push(Object item) {\n    QueueNode newNode = new QueueNode(item);\n    \n    if (m_Head == null) {\n      m_Head = m_Tail = newNode;\n    } else {\n      m_Tail = m_Tail.next(newNode);\n    }\n    m_Size++;\n    return item;\n  }\n\n  /**\n   * Pops an object from the front of the queue.\n   *\n   * @return the object at the front of the queue\n   * @exception RuntimeException if the queue is empty\n   */\n  //@ assignable m_Head, m_Tail, m_Size;\n  //@ ensures m_Size == \\old(m_Size) - 1;\n  //@ ensures m_Head == \\old(m_Head.m_Next);\n  //@ ensures m_Head != null ==\u003e m_Tail == \\old(m_Tail);\n  //@ ensures \\result == \\old(m_Head.m_Contents);\n  //@ signals (RuntimeException) \\old(m_Head) == null;\n  public synchronized Object pop() \n      throws RuntimeException   // REDUNDANT, BUT ESCJAVA REQUIRES THIS\n  {\n    if (m_Head == null) {\n\tthrow new RuntimeException(\"Queue is empty\");\n    }\n    Object retval = m_Head.contents();\n    m_Size--;\n    m_Head = m_Head.next();\n    // Here we need to either tell ESC/Java some facts about\n    // the contents of the list after popping off the head,\n    // or turn off the 'invariant' warnings.\n    //\n    //@ assume m_Size == 0 \u003c==\u003e m_Head == null;\n    //@ assume m_Size == 1 \u003c==\u003e m_Head == m_Tail;\n    if (m_Head == null) {\n      m_Tail = null;\n    }\n    return retval;\n  }\n\n  /**\n   * Gets object from the front of the queue.\n   *\n   * @return the object at the front of the queue\n   * @exception RuntimeException if the queue is empty\n   */\n  //@ ensures \\result == \\old(m_Head.m_Contents);\n  //@ signals (RuntimeException) \\old(m_Head) == null;\n  public /*@ pure @*/ synchronized Object peek() \n    throws RuntimeException\n  { \n    if (m_Head == null) {\n      throw new RuntimeException(\"Queue is empty\");\n    }\n    return m_Head.contents();\n  }\n\n  /**\n   * Checks if queue is empty.\n   * \n   * @return true if queue is empty\n   */\n  //@ ensures \\result \u003c==\u003e m_Head == null;\n  public /*@ pure @*/ boolean empty() {\n    return m_Head == null;\n  }\n\n  /**\n   * Gets queue's size.\n   *\n   * @return size of queue\n   */\n  //@ ensures \\result == m_Size;\n  public /*@ pure @*/ int size() {\n    return m_Size;\n  }\n\n  /**\n   * Produces textual description of queue.\n   *\n   * @return textual description of queue\n   */\n  //@ also\n  //@ ensures \\result != null;\n  //@ ensures (* \\result == textual description of the queue *);\n  public  /*@ pure @*/ String toString() {\n\n    String retval = \"Queue Contents \"+m_Size+\" elements\\n\";\n    QueueNode current = m_Head;\n    if (current == null) {\n      return retval + \"Empty\\n\";\n    } else {\n      while (current != null) {\n        retval += current.contents().toString()+\"\\n\"; //@nowarn Modifies;\n\tcurrent = current.next();\n      }\n    }\n    return retval;\n  } //@ nowarn Post;\n  \n  /**\n   * Returns the revision string.\n   * \n   * @return\t\tthe revision\n   */\n  public String getRevision() {\n    return RevisionUtils.extract(\"$Revision: 8034 $\");\n  }\n\n  /**\n   * Main method for testing this class.\n   *\n   * @param argv a set of strings that are pushed on a test queue\n   */\n  //@ requires argv.length \u003e= 0;\n  //@ requires argv != null;\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c argv.length; argv[i] != null);\n  public static void main(String [] argv) {\n\n    try {\n      Queue queue = new Queue();\n      for(int i = 0; i \u003c argv.length; i++) {\n\tqueue.push(argv[i]);\n      }\n      System.out.println(\"After pushing command line arguments\");\n      System.out.println(queue.toString());\n      while (!queue.empty()) {\n\tSystem.out.println(\"Pop: \" + queue.pop().toString());\n      }\n      // try one more pop, to make sure we get an exception\n      try \n\t{\n\t  queue.pop();\n\t  System.out.println(\"ERROR: pop did not throw exception!\");\n\t}\n      catch (RuntimeException ex)\n        {\n\t  System.out.println(\"Pop on empty queue correctly gave exception.\");\n\t}\n    } catch (Exception ex) {\n      System.out.println(ex.getMessage());\n    }\n  }\n}\n",
        "name": "Queue.java",
        "path": "weka-android/src/main/java/weka/core/Queue.java",
        "url": "/github.com/andrecamara/weka-android/-/blob/weka-android/src/main/java/weka/core/Queue.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 62,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires contents != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 64,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures m_Contents == contents;"
        },
        {
          "limitHit": false,
          "lineNumber": 65,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures m_Next == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 74,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires next != this ;"
        },
        {
          "limitHit": false,
          "lineNumber": 76,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures m_Next==next \u0026\u0026 \\result==next;"
        },
        {
          "limitHit": false,
          "lineNumber": 84,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result == m_Next;"
        },
        {
          "limitHit": false,
          "lineNumber": 92,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires contents != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 102,
          "offsetAndLengths": [
            [
              6,
              12
            ]
          ],
          "preview": "      //@ ensures \\result == m_Contents;"
        },
        {
          "limitHit": false,
          "lineNumber": 140,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Size == 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 141,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 142,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Tail == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 155,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires item != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 157,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 158,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Tail != \\old(m_Tail);"
        },
        {
          "limitHit": false,
          "lineNumber": 159,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Size == \\old(m_Size) + 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 160,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\old(m_Size) == 0 ==\u003e m_Head == m_Tail; "
        },
        {
          "limitHit": false,
          "lineNumber": 161,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\old(m_Size) != 0 ==\u003e m_Head == \\old(m_Head);"
        },
        {
          "limitHit": false,
          "lineNumber": 162,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Tail.contents() == \\old(item);"
        },
        {
          "limitHit": false,
          "lineNumber": 163,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == item;"
        },
        {
          "limitHit": false,
          "lineNumber": 183,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Size == \\old(m_Size) - 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 184,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head == \\old(m_Head.m_Next);"
        },
        {
          "limitHit": false,
          "lineNumber": 185,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head != null ==\u003e m_Tail == \\old(m_Tail);"
        },
        {
          "limitHit": false,
          "lineNumber": 186,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == \\old(m_Head.m_Contents);"
        },
        {
          "limitHit": false,
          "lineNumber": 215,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == \\old(m_Head.m_Contents);"
        },
        {
          "limitHit": false,
          "lineNumber": 231,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e m_Head == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 241,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Size;"
        },
        {
          "limitHit": false,
          "lineNumber": 252,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 253,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures (* \\result == textual description of the queue *);"
        },
        {
          "limitHit": false,
          "lineNumber": 283,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires argv.length \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 284,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires argv != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 285,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c argv.length; argv[i] != null);"
        },
        {
          "limitHit": false,
          "lineNumber": 94,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  m_Contents == contents \u0026\u0026 \\result == contents;"
        }
      ],
      "repository": {
        "name": "github.com/andrecamara/weka-android",
        "url": "/github.com/andrecamara/weka-android"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "4eef1b0916c85e8339cd32d672affca3d58e4c3f"
        },
        "content": "/*\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n/*\n *    Attribute.java\n *    Copyright (C) 1999-2012 University of Waikato, Hamilton, New Zealand\n *\n */\n\npackage weka.core;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.io.StreamTokenizer;\nimport java.io.StringReader;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Properties;\n\n/** \n * Class for handling an attribute. Once an attribute has been created,\n * it can't be changed. \u003cp\u003e\n *\n * The following attribute types are supported:\n * \u003cul\u003e\n *    \u003cli\u003e numeric: \u003cbr/\u003e\n *         This type of attribute represents a floating-point number.\n *    \u003c/li\u003e\n *    \u003cli\u003e nominal: \u003cbr/\u003e\n *         This type of attribute represents a fixed set of nominal values.\n *    \u003c/li\u003e\n *    \u003cli\u003e string: \u003cbr/\u003e\n *         This type of attribute represents a dynamically expanding set of\n *         nominal values. Usually used in text classification.\n *    \u003c/li\u003e\n *    \u003cli\u003e date: \u003cbr/\u003e\n *         This type of attribute represents a date, internally represented as \n *         floating-point number storing the milliseconds since January 1, \n *         1970, 00:00:00 GMT. The string representation of the date must be\n *         \u003ca href=\"http://www.iso.org/iso/en/prods-services/popstds/datesandtime.html\" target=\"_blank\"\u003e\n *         ISO-8601\u003c/a\u003e compliant, the default is \u003ccode\u003eyyyy-MM-dd'T'HH:mm:ss\u003c/code\u003e.\n *    \u003c/li\u003e\n *    \u003cli\u003e relational: \u003cbr/\u003e\n *         This type of attribute can contain other attributes and is, e.g., \n *         used for representing Multi-Instance data. (Multi-Instance data\n *         consists of a nominal attribute containing the bag-id, then a \n *         relational attribute with all the attributes of the bag, and \n *         finally the class attribute.)\n *    \u003c/li\u003e\n * \u003c/ul\u003e\n * \n * Typical usage (code from the main() method of this class): \u003cp\u003e\n *\n * \u003ccode\u003e\n * ... \u003cbr\u003e\n *\n * // Create numeric attributes \"length\" and \"weight\" \u003cbr\u003e\n * Attribute length = new Attribute(\"length\"); \u003cbr\u003e\n * Attribute weight = new Attribute(\"weight\"); \u003cbr\u003e\u003cbr\u003e\n * \n * // Create list to hold nominal values \"first\", \"second\", \"third\" \u003cbr\u003e\n * List\u003cString\u003e my_nominal_values = new ArrayList\u003cString\u003e(3); \u003cbr\u003e\n * my_nominal_values.add(\"first\"); \u003cbr\u003e\n * my_nominal_values.add(\"second\"); \u003cbr\u003e\n * my_nominal_values.add(\"third\"); \u003cbr\u003e\u003cbr\u003e\n *\n * // Create nominal attribute \"position\" \u003cbr\u003e\n * Attribute position = new Attribute(\"position\", my_nominal_values);\u003cbr\u003e\n *\n * ... \u003cbr\u003e\n * \u003c/code\u003e\u003cp\u003e\n *\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\n * @version $Revision: 9515 $\n */\npublic class Attribute\n  implements Copyable, Serializable, RevisionHandler {\n\n  /** for serialization */\n  static final long serialVersionUID = -742180568732916383L;\n  \n  /** Constant set for numeric attributes. */\n  public static final int NUMERIC = 0;\n\n  /** Constant set for nominal attributes. */\n  public static final int NOMINAL = 1;\n\n  /** Constant set for attributes with string values. */\n  public static final int STRING = 2;\n\n  /** Constant set for attributes with date values. */\n  public static final int DATE = 3;\n\n  /** Constant set for relation-valued attributes. */\n  public static final int RELATIONAL = 4;\n\n  /** Constant set for symbolic attributes. */\n  public static final int ORDERING_SYMBOLIC = 0;\n\n  /** Constant set for ordered attributes. */\n  public static final int ORDERING_ORDERED  = 1;\n\n  /** Constant set for modulo-ordered attributes. */\n  public static final int ORDERING_MODULO   = 2;\n\n  /** The keyword used to denote the start of an arff attribute declaration */\n  public final static String ARFF_ATTRIBUTE = \"@attribute\";\n\n  /** A keyword used to denote a numeric attribute */\n  public final static String ARFF_ATTRIBUTE_INTEGER = \"integer\";\n\n  /** A keyword used to denote a numeric attribute */\n  public final static String ARFF_ATTRIBUTE_REAL = \"real\";\n\n  /** A keyword used to denote a numeric attribute */\n  public final static String ARFF_ATTRIBUTE_NUMERIC = \"numeric\";\n\n  /** The keyword used to denote a string attribute */\n  public final static String ARFF_ATTRIBUTE_STRING = \"string\";\n\n  /** The keyword used to denote a date attribute */\n  public final static String ARFF_ATTRIBUTE_DATE = \"date\";\n\n  /** The keyword used to denote a relation-valued attribute */\n  public final static String ARFF_ATTRIBUTE_RELATIONAL = \"relational\";\n\n  /** The keyword used to denote the end of the declaration of a subrelation */\n  public final static String ARFF_END_SUBRELATION = \"@end\";\n\n  /** Dummy first value for String attributes (useful for sparse instances) */\n  public final static String DUMMY_STRING_VAL = \"*WEKA*DUMMY*STRING*FOR*STRING*ATTRIBUTES*\";\n\n  /** Strings longer than this will be stored compressed. */\n  private static final int STRING_COMPRESS_THRESHOLD = 200;\n\n  /** The attribute's name. */\n  private /*@ spec_public non_null @*/ String m_Name;\n\n  /** The attribute's type. */\n  private /*@ spec_public @*/ int m_Type;\n  /*@ invariant m_Type == NUMERIC || \n                m_Type == DATE || \n                m_Type == STRING || \n                m_Type == NOMINAL ||\n                m_Type == RELATIONAL;\n  */\n\n  /** The attribute's values (if nominal or string). */\n  private /*@ spec_public @*/ ArrayList\u003cObject\u003e m_Values;\n\n  /** Mapping of values to indices (if nominal or string). */\n  private Hashtable\u003cObject,Integer\u003e m_Hashtable;\n\n  /** The header information for a relation-valued attribute. */\n  private Instances m_Header;\n\n  /** Date format specification for date attributes */\n  private SimpleDateFormat m_DateFormat;\n\n  /** The attribute's index. */\n  private /*@ spec_public @*/ int m_Index;\n\n  /** The attribute's metadata. */\n  private ProtectedProperties m_Metadata;\n\n  /** The attribute's ordering. */\n  private int m_Ordering;\n\n  /** Whether the attribute is regular. */\n  private boolean m_IsRegular;\n\n  /** Whether the attribute is averagable. */\n  private boolean m_IsAveragable;\n\n  /** Whether the attribute has a zeropoint. */\n  private boolean m_HasZeropoint;\n\n  /** The attribute's weight. */\n  private double m_Weight;\n\n  /** The attribute's lower numeric bound. */\n  private double m_LowerBound;\n\n  /** Whether the lower bound is open. */\n  private boolean m_LowerBoundIsOpen;\n\n  /** The attribute's upper numeric bound. */\n  private double m_UpperBound;\n\n  /** Whether the upper bound is open */\n  private boolean m_UpperBoundIsOpen;\n\n  /**\n   * Constructor for a numeric attribute.\n   *\n   * @param attributeName the name for the attribute\n   */\n  //@ requires attributeName != null;\n  //@ ensures  m_Name == attributeName;\n  public Attribute(String attributeName) {\n\n    this(attributeName, new ProtectedProperties(new Properties()));\n  }\n\n  /**\n   * Constructor for a numeric attribute, where metadata is supplied.\n   *\n   * @param attributeName the name for the attribute\n   * @param metadata the attribute's properties\n   */\n  //@ requires attributeName != null;\n  //@ requires metadata != null;\n  //@ ensures  m_Name == attributeName;\n  public Attribute(String attributeName, ProtectedProperties metadata) {\n\n    m_Name = attributeName;\n    m_Index = -1;\n    m_Values = null;\n    m_Hashtable = null;\n    m_Header = null;\n    m_Type = NUMERIC;\n    setMetadata(metadata);\n  }\n\n  /**\n   * Constructor for a date attribute.\n   *\n   * @param attributeName the name for the attribute\n   * @param dateFormat a string suitable for use with\n   * SimpleDateFormatter for parsing dates.\n   */\n  //@ requires attributeName != null;\n  //@ requires dateFormat != null;\n  //@ ensures  m_Name == attributeName;\n  public Attribute(String attributeName, String dateFormat) {\n\n    this(attributeName, dateFormat,\n\t new ProtectedProperties(new Properties()));\n  }\n\n  /**\n   * Constructor for a date attribute, where metadata is supplied.\n   *\n   * @param attributeName the name for the attribute\n   * @param dateFormat a string suitable for use with\n   * SimpleDateFormatter for parsing dates.\n   * @param metadata the attribute's properties\n   */\n  //@ requires attributeName != null;\n  //@ requires dateFormat != null;\n  //@ requires metadata != null;\n  //@ ensures  m_Name == attributeName;\n  public Attribute(String attributeName, String dateFormat,\n\t\t   ProtectedProperties metadata) {\n\n    m_Name = attributeName;\n    m_Index = -1;\n    m_Values = null;\n    m_Hashtable = null;\n    m_Header = null;\n    m_Type = DATE;\n    if (dateFormat != null) {\n      m_DateFormat = new SimpleDateFormat(dateFormat);\n    } else {\n      m_DateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n    }\n    m_DateFormat.setLenient(false);\n    setMetadata(metadata);\n  }\n\n  /**\n   * Constructor for nominal attributes and string attributes.\n   * If a null vector of attribute values is passed to the method,\n   * the attribute is assumed to be a string.\n   *\n   * @param attributeName the name for the attribute\n   * @param attributeValues a vector of strings denoting the \n   * attribute values. Null if the attribute is a string attribute.\n   */\n  //@ requires attributeName != null;\n  //@ ensures  m_Name == attributeName;\n  public Attribute(String attributeName, \n\t\t   List\u003cString\u003e attributeValues) {\n\n    this(attributeName, attributeValues,\n\t new ProtectedProperties(new Properties()));\n  }\n\n  /**\n   * Constructor for nominal attributes and string attributes, where\n   * metadata is supplied. If a null vector of attribute values is passed\n   * to the method, the attribute is assumed to be a string.\n   *\n   * @param attributeName the name for the attribute\n   * @param attributeValues a vector of strings denoting the \n   * attribute values. Null if the attribute is a string attribute.\n   * @param metadata the attribute's properties\n   */\n  //@ requires attributeName != null;\n  //@ requires metadata != null;\n  /*@ ensures  m_Name == attributeName;\n      ensures  m_Index == -1;\n      ensures  attributeValues == null \u0026\u0026 m_Type == STRING\n            || attributeValues != null \u0026\u0026 m_Type == NOMINAL \n                  \u0026\u0026 m_Values.size() == attributeValues.size();\n      signals (IllegalArgumentException ex) \n                 (* if duplicate strings in attributeValues *);\n  */\n  public Attribute(String attributeName, \n\t\t   List\u003cString\u003e attributeValues,\n\t\t   ProtectedProperties metadata) {\n\n    m_Name = attributeName;\n    m_Index = -1;\n    if (attributeValues == null) {\n      m_Values = new ArrayList\u003cObject\u003e();\n      m_Hashtable = new Hashtable\u003cObject,Integer\u003e();\n      m_Header = null;\n      m_Type = STRING;\n\n      // Make sure there is at least one value so that string attribute\n      // values are always represented when output as part of a sparse instance.\n      addStringValue(DUMMY_STRING_VAL);\n    } else {\n      m_Values = new ArrayList\u003cObject\u003e(attributeValues.size());\n      m_Hashtable = new Hashtable\u003cObject,Integer\u003e(attributeValues.size());\n      m_Header = null;\n      for (int i = 0; i \u003c attributeValues.size(); i++) {\n\tObject store = attributeValues.get(i);\n\tif (((String)store).length() \u003e STRING_COMPRESS_THRESHOLD) {\n\t  try {\n\t    store = new SerializedObject(attributeValues.get(i), true);\n\t  } catch (Exception ex) {\n\t    System.err.println(\"Couldn't compress nominal attribute value -\"\n\t\t\t       + \" storing uncompressed.\");\n\t  }\n\t}\n\tif (m_Hashtable.containsKey(store)) {\n\t  throw new IllegalArgumentException(\"A nominal attribute (\" +\n\t\t\t\t\t     attributeName + \") cannot\"\n\t\t\t\t\t     + \" have duplicate labels (\" + store + \").\");\n\t}\n\tm_Values.add(store);\n\tm_Hashtable.put(store, new Integer(i));\n      }\n      m_Type = NOMINAL;\n    }\n    setMetadata(metadata);\n  }\n\n  /**\n   * Constructor for relation-valued attributes.\n   *\n   * @param attributeName the name for the attribute\n   * @param header an Instances object specifying the header of the relation.\n   */\n  public Attribute(String attributeName, Instances header) {\n\n    this(attributeName, header,\n\t new ProtectedProperties(new Properties()));\n  }\n\n  /**\n   * Constructor for relation-valued attributes.\n   *\n   * @param attributeName the name for the attribute\n   * @param header an Instances object specifying the header of the relation.\n   * @param metadata the attribute's properties\n   */\n  public Attribute(String attributeName, \n\t\t   Instances header,\n\t\t   ProtectedProperties metadata) {\n\n    if (header.numInstances() \u003e 0) {\n      throw new IllegalArgumentException(\"Header for relation-valued \" +\n                                         \"attribute should not contain \" +\n                                         \"any instances\");\n    }\n    m_Name = attributeName;\n    m_Index = -1;\n    m_Values = new ArrayList\u003cObject\u003e();\n    m_Hashtable = new Hashtable\u003cObject,Integer\u003e();\n    m_Header = header;\n    m_Type = RELATIONAL;\n    setMetadata(metadata);\n  }\n\n  /**\n   * Produces a shallow copy of this attribute.\n   *\n   * @return a copy of this attribute with the same index\n   */\n  //@ also ensures \\result instanceof Attribute;\n  public /*@ pure non_null @*/ Object copy() {\n\n    Attribute copy = new Attribute(m_Name);\n\n    copy.m_Index = m_Index;\n    copy.m_Type = m_Type;\n    copy.m_Values = m_Values;\n    copy.m_Hashtable = m_Hashtable;\n    copy.m_DateFormat = m_DateFormat;\n    copy.m_Header = m_Header;\n    copy.setMetadata(m_Metadata);\n \n    return copy;\n  }\n\n  /**\n   * Returns an enumeration of all the attribute's values if the\n   * attribute is nominal, string, or relation-valued, null otherwise.\n   *\n   * @return enumeration of all the attribute's values\n   */\n  public final /*@ pure @*/ Enumeration enumerateValues() {\n\n    if (isNominal() || isString()) {\n      final Enumeration ee = new WekaEnumeration(m_Values);\n      return new Enumeration () {\n          public boolean hasMoreElements() {\n            return ee.hasMoreElements();\n          }\n          public Object nextElement() {\n            Object oo = ee.nextElement();\n            if (oo instanceof SerializedObject) {\n              return ((SerializedObject)oo).getObject();\n            } else {\n              return oo;\n            }\n          }\n        };\n    }\n    return null;\n  }\n\n  /**\n   * Tests if given attribute is equal to this attribute.\n   *\n   * @param other the Object to be compared to this attribute\n   * @return true if the given attribute is equal to this attribute\n   */\n  public final /*@ pure @*/ boolean equals(Object other) {\n    return (equalsMsg(other) == null);\n  }\n\n  /**\n   * Tests if given attribute is equal to this attribute. If they're not\n   * the same a message detailing why they differ will be returned, otherwise\n   * null.\n   *\n   * @param other \tthe Object to be compared to this attribute\n   * @return \t\tnull if the given attribute is equal to this attribute\n   */\n  public final String equalsMsg(Object other) {\n    if (other == null)\n      return \"Comparing with null object\";\n    \n    if (!(other.getClass().equals(this.getClass())))\n      return \"Object has wrong class\";\n    \n    Attribute att = (Attribute) other;\n    if (!m_Name.equals(att.m_Name))\n      return \"Names differ: \" + m_Name + \" != \" + att.m_Name;\n\n    if (isNominal() \u0026\u0026 att.isNominal()) {\n      if (m_Values.size() != att.m_Values.size())\n        return \"Different number of labels: \" + m_Values.size() + \" != \" + att.m_Values.size();\n      \n      for (int i = 0; i \u003c m_Values.size(); i++) {\n        if (!m_Values.get(i).equals(att.m_Values.get(i)))\n          return \"Labels differ at position \" + (i+1) + \": \" + m_Values.get(i) + \" != \" + att.m_Values.get(i);\n      }\n      \n      return null;\n    } \n    \n    if (isRelationValued() \u0026\u0026 att.isRelationValued())\n      return m_Header.equalHeadersMsg(att.m_Header);\n    \n    if ((type() != att.type()))\n      return \"Types differ: \" + typeToString(this) + \" != \" + typeToString(att);\n    \n    return null;\n  }\n  \n  /**\n   * Returns a string representation of the attribute type.\n   * \n   * @param att\t\tthe attribute to return the type string for\n   * @return\t\tthe string representation of the attribute type\n   */\n  public static String typeToString(Attribute att) {\n    return typeToString(att.type());\n  }\n  \n  /**\n   * Returns a string representation of the attribute type.\n   * \n   * @param type\tthe type of the attribute\n   * @return\t\tthe string representation of the attribute type\n   */\n  public static String typeToString(int type) {\n    String\tresult;\n    \n    switch(type) {\n      case NUMERIC:\n\tresult = \"numeric\";\n\tbreak;\n\t\n      case NOMINAL:\n\tresult = \"nominal\";\n\tbreak;\n\t\n      case STRING:\n\tresult = \"string\";\n\tbreak;\n\t\n      case DATE:\n\tresult = \"date\";\n\tbreak;\n\t\n      case RELATIONAL:\n\tresult = \"relational\";\n\tbreak;\n\t\n      default:\n\tresult = \"unknown(\" + type + \")\";\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Returns a short string representation of the attribute type.\n   * \n   * @param att\t\tthe attribute to return the type string for\n   * @return\t\tthe string representation of the attribute type\n   */\n  public static String typeToStringShort(Attribute att) {\n    return typeToStringShort(att.type());\n  }\n  \n  /**\n   * Returns a short string representation of the attribute type.\n   * \n   * @param type\tthe type of the attribute\n   * @return\t\tthe string representation of the attribute type\n   */\n  public static String typeToStringShort(int type) {\n    String\tresult;\n    \n    switch(type) {\n      case NUMERIC:\n\tresult = \"Num\";\n\tbreak;\n\t\n      case NOMINAL:\n\tresult = \"Nom\";\n\tbreak;\n\t\n      case STRING:\n\tresult = \"Str\";\n\tbreak;\n\t\n      case DATE:\n\tresult = \"Dat\";\n\tbreak;\n\t\n      case RELATIONAL:\n\tresult = \"Rel\";\n\tbreak;\n\t\n      default:\n\tresult = \"???\";\n    }\n    \n    return result;\n  }\n\n  /**\n   * Returns the index of this attribute.\n   *\n   * @return the index of this attribute\n   */\n  //@ ensures \\result == m_Index;\n  public final /*@ pure @*/ int index() {\n\n    return m_Index;\n  }\n\n  /**\n   * Returns the index of a given attribute value. (The index of\n   * the first occurence of this value.)\n   *\n   * @param value the value for which the index is to be returned\n   * @return the index of the given attribute value if attribute\n   * is nominal or a string, -1 if it is not or the value \n   * can't be found\n   */\n  public final int indexOfValue(String value) {\n\n    if (!isNominal() \u0026\u0026 !isString())\n      return -1;\n    Object store = value;\n    if (value.length() \u003e STRING_COMPRESS_THRESHOLD) {\n      try {\n        store = new SerializedObject(value, true);\n      } catch (Exception ex) {\n        System.err.println(\"Couldn't compress string attribute value -\"\n                           + \" searching uncompressed.\");\n      }\n    }\n    Integer val = (Integer)m_Hashtable.get(store);\n    if (val == null) return -1;\n    else return val.intValue();\n  }\n\n  /**\n   * Test if the attribute is nominal.\n   *\n   * @return true if the attribute is nominal\n   */\n  //@ ensures \\result \u003c==\u003e (m_Type == NOMINAL);\n  public final /*@ pure @*/ boolean isNominal() {\n\n    return (m_Type == NOMINAL);\n  }\n\n  /**\n   * Tests if the attribute is numeric.\n   *\n   * @return true if the attribute is numeric\n   */\n  //@ ensures \\result \u003c==\u003e ((m_Type == NUMERIC) || (m_Type == DATE));\n  public final /*@ pure @*/ boolean isNumeric() {\n\n    return ((m_Type == NUMERIC) || (m_Type == DATE));\n  }\n\n  /**\n   * Tests if the attribute is relation valued.\n   *\n   * @return true if the attribute is relation valued\n   */\n  //@ ensures \\result \u003c==\u003e (m_Type == RELATIONAL);\n  public final /*@ pure @*/ boolean isRelationValued() {\n\n    return (m_Type == RELATIONAL);\n  }\n\n  /**\n   * Tests if the attribute is a string.\n   *\n   * @return true if the attribute is a string\n   */\n  //@ ensures \\result \u003c==\u003e (m_Type == STRING);\n  public final /*@ pure @*/ boolean isString() {\n\n    return (m_Type == STRING);\n  }\n\n  /**\n   * Tests if the attribute is a date type.\n   *\n   * @return true if the attribute is a date type\n   */\n  //@ ensures \\result \u003c==\u003e (m_Type == DATE);\n  public final /*@ pure @*/ boolean isDate() {\n\n    return (m_Type == DATE);\n  }\n\n  /**\n   * Returns the attribute's name.\n   *\n   * @return the attribute's name as a string\n   */\n  //@ ensures \\result == m_Name;\n  public final /*@ pure @*/ String name() {\n\n    return m_Name;\n  }\n  \n  /**\n   * Returns the number of attribute values. Returns 0 for \n   * attributes that are not either nominal, string, or\n   * relation-valued.\n   *\n   * @return the number of attribute values\n   */\n  public final /*@ pure @*/ int numValues() {\n\n    if (!isNominal() \u0026\u0026 !isString() \u0026\u0026 !isRelationValued()) {\n      return 0;\n    } else {\n      return m_Values.size();\n    }\n  }\n\n  /**\n   * Returns a description of this attribute in ARFF format. Quotes\n   * strings if they contain whitespace characters, or if they\n   * are a question mark.\n   *\n   * @return a description of this attribute as a string\n   */\n  public final String toString() {\n    \n    StringBuffer text = new StringBuffer();\n    \n    text.append(ARFF_ATTRIBUTE).append(\" \").append(Utils.quote(m_Name)).append(\" \");\n    switch (m_Type) {\n    case NOMINAL:\n      text.append('{');\n      Enumeration enu = enumerateValues();\n      while (enu.hasMoreElements()) {\n\ttext.append(Utils.quote((String) enu.nextElement()));\n\tif (enu.hasMoreElements())\n\t  text.append(',');\n      }\n      text.append('}');\n      break;\n    case NUMERIC:\n      text.append(ARFF_ATTRIBUTE_NUMERIC);\n      break;\n    case STRING:\n      text.append(ARFF_ATTRIBUTE_STRING);\n      break;\n    case DATE:\n      text.append(ARFF_ATTRIBUTE_DATE).append(\" \").append(Utils.quote(m_DateFormat.toPattern()));\n      break;\n    case RELATIONAL:\n      text.append(ARFF_ATTRIBUTE_RELATIONAL).append(\"\\n\");\n      Enumeration enm = m_Header.enumerateAttributes();\n      while (enm.hasMoreElements()) {\n        text.append(enm.nextElement()).append(\"\\n\");\n      }\n      text.append(ARFF_END_SUBRELATION).append(\" \").append(Utils.quote(m_Name));\n      break;\n    default:\n      text.append(\"UNKNOWN\");\n      break;\n    }\n    return text.toString();\n  }\n\n  /**\n   * Returns the attribute's type as an integer.\n   *\n   * @return the attribute's type.\n   */\n  //@ ensures \\result == m_Type;\n  public final /*@ pure @*/ int type() {\n\n    return m_Type;\n  }\n  \n  /**\n   * Returns the Date format pattern in case this attribute is of type DATE,\n   * otherwise an empty string.\n   * \n   * @return the date format pattern\n   * @see SimpleDateFormat\n   */\n  public final String getDateFormat() {\n    if (isDate())\n      return m_DateFormat.toPattern();\n    else\n      return \"\";\n  }\n\n  /**\n   * Returns a value of a nominal or string attribute.  Returns an\n   * empty string if the attribute is neither a string nor a nominal\n   * attribute.\n   *\n   * @param valIndex the value's index\n   * @return the attribute's value as a string\n   */\n  public final /*@ non_null pure @*/ String value(int valIndex) {\n    \n    if (!isNominal() \u0026\u0026 !isString()) {\n      return \"\";\n    } else {\n      Object val = m_Values.get(valIndex);\n      \n      // If we're storing strings compressed, uncompress it.\n      if (val instanceof SerializedObject) {\n        val = ((SerializedObject)val).getObject();\n      }\n      return (String) val;\n    }\n  }\n\n  /**\n   * Returns the header info for a relation-valued attribute,\n   * null if the attribute is not relation-valued.\n   *\n   * @return the attribute's value as an Instances object\n   */\n  public final /*@ non_null pure @*/ Instances relation() {\n    \n    if (!isRelationValued()) {\n      return null;\n    } else {\n      return m_Header;\n    }\n  }\n\n  /**\n   * Returns a value of a relation-valued attribute. Returns\n   * null if the attribute is not relation-valued.\n   *\n   * @param valIndex the value's index\n   * @return the attribute's value as an Instances object\n   */\n  public final /*@ non_null pure @*/ Instances relation(int valIndex) {\n    \n    if (!isRelationValued()) {\n      return null;\n    } else {\n      return (Instances) m_Values.get(valIndex);\n    }\n  }\n\n  /**\n   * Constructor for a numeric attribute with a particular index.\n   *\n   * @param attributeName the name for the attribute\n   * @param index the attribute's index\n   */\n  //@ requires attributeName != null;\n  //@ requires index \u003e= 0;\n  //@ ensures  m_Name == attributeName;\n  //@ ensures  m_Index == index;\n  public Attribute(String attributeName, int index) {\n\n    this(attributeName);\n    m_Index = index;\n  }\n\n  /**\n   * Constructor for date attributes with a particular index.\n   *\n   * @param attributeName the name for the attribute\n   * @param dateFormat a string suitable for use with\n   * SimpleDateFormatter for parsing dates.  Null for a default format\n   * string.\n   * @param index the attribute's index\n   */\n  //@ requires attributeName != null;\n  //@ requires index \u003e= 0;\n  //@ ensures  m_Name == attributeName;\n  //@ ensures  m_Index == index;\n  public Attribute(String attributeName, String dateFormat, \n\t    int index) {\n\n    this(attributeName, dateFormat);\n    m_Index = index;\n  }\n\n  /**\n   * Constructor for nominal attributes and string attributes with\n   * a particular index.\n   * If a null vector of attribute values is passed to the method,\n   * the attribute is assumed to be a string.\n   *\n   * @param attributeName the name for the attribute\n   * @param attributeValues a vector of strings denoting the attribute values.\n   * Null if the attribute is a string attribute.\n   * @param index the attribute's index\n   */\n  //@ requires attributeName != null;\n  //@ requires index \u003e= 0;\n  //@ ensures  m_Name == attributeName;\n  //@ ensures  m_Index == index;\n  public Attribute(String attributeName, List\u003cString\u003e attributeValues, \n\t    int index) {\n\n    this(attributeName, attributeValues);\n    m_Index = index;\n  }\n\n  /**\n   * Constructor for a relation-valued attribute with a particular index.\n   *\n   * @param attributeName the name for the attribute\n   * @param header the header information for this attribute\n   * @param index the attribute's index\n   */\n  //@ requires attributeName != null;\n  //@ requires index \u003e= 0;\n  //@ ensures  m_Name == attributeName;\n  //@ ensures  m_Index == index;\n  public Attribute(String attributeName, Instances header,\n\t    int index) {\n\n    this(attributeName, header);\n    m_Index = index;\n  }\n\n  /**\n   * Adds a string value to the list of valid strings for attributes\n   * of type STRING and returns the index of the string.\n   *\n   * @param value The string value to add\n   * @return the index assigned to the string, or -1 if the attribute is not\n   * of type Attribute.STRING \n   */\n  /*@ requires value != null;\n      ensures  isString() \u0026\u0026 0 \u003c= \\result \u0026\u0026 \\result \u003c m_Values.size() ||\n             ! isString() \u0026\u0026 \\result == -1;\n  */\n  public int addStringValue(String value) {\n\n    if (!isString()) {\n      return -1;\n    }\n    Object store = value;\n\n    if (value.length() \u003e STRING_COMPRESS_THRESHOLD) {\n      try {\n        store = new SerializedObject(value, true);\n      } catch (Exception ex) {\n        System.err.println(\"Couldn't compress string attribute value -\"\n                           + \" storing uncompressed.\");\n      }\n    }\n    Integer index = (Integer)m_Hashtable.get(store);\n    if (index != null) {\n      return index.intValue();\n    } else {\n      int intIndex = m_Values.size();\n      m_Values.add(store);\n      m_Hashtable.put(store, new Integer(intIndex));\n      return intIndex;\n    }\n  }\n  \n  /**\n   * Clear the map and list of values and set them to contain\n   * just the supplied value\n   * \n   * @param value the current (and only) value of this String attribute\n   */\n  public void setStringValue(String value) {\n    if (!isString()) {\n      return;\n    }\n    \n    m_Hashtable.clear();\n    m_Values.clear();\n    addStringValue(value);\n  }\n\n  /**\n   * Adds a string value to the list of valid strings for attributes\n   * of type STRING and returns the index of the string. This method is\n   * more efficient than addStringValue(String) for long strings.\n   *\n   * @param src The Attribute containing the string value to add.\n   * @param index the index of the string value in the source attribute.\n   * @return the index assigned to the string, or -1 if the attribute is not\n   * of type Attribute.STRING \n   */\n  /*@ requires src != null;\n      requires 0 \u003c= index \u0026\u0026 index \u003c src.m_Values.size();\n      ensures  isString() \u0026\u0026 0 \u003c= \\result \u0026\u0026 \\result \u003c m_Values.size() ||\n             ! isString() \u0026\u0026 \\result == -1;\n  */\n  public int addStringValue(Attribute src, int index) {\n\n    if (!isString()) {\n      return -1;\n    }\n    Object store = src.m_Values.get(index);\n    Integer oldIndex = (Integer)m_Hashtable.get(store);\n    if (oldIndex != null) {\n      return oldIndex.intValue();\n    } else {\n      int intIndex = m_Values.size();\n      m_Values.add(store);\n      m_Hashtable.put(store, new Integer(intIndex));\n      return intIndex;\n    }\n  }\n\n  /**\n   * Adds a relation to a relation-valued attribute.\n   *\n   * @param value The value to add\n   * @return the index assigned to the value, or -1 if the attribute is not\n   * of type Attribute.RELATIONAL \n   */\n  public int addRelation(Instances value) {\n\n    if (!isRelationValued()) {\n      return -1;\n    }\n    if (!m_Header.equalHeaders(value)) {\n      throw new IllegalArgumentException(\"Incompatible value for \" +\n                                         \"relation-valued attribute.\\n\" + \n                                         m_Header.equalHeadersMsg(value));\n    }\n    Integer index = (Integer)m_Hashtable.get(value);\n    if (index != null) {\n      return index.intValue();\n    } else {\n      int intIndex = m_Values.size();\n      m_Values.add(value);\n      m_Hashtable.put(value, new Integer(intIndex));\n      return intIndex;\n    }\n  }\n\n  /**\n   * Adds an attribute value. Creates a fresh list of attribute\n   * values before adding it.\n   *\n   * @param value the attribute value\n   */\n  final void addValue(String value) {\n\n    m_Values = Utils.cast(m_Values.clone());\n    m_Hashtable = Utils.cast(m_Hashtable.clone());\n    forceAddValue(value);\n  }\n\n  /**\n   * Produces a shallow copy of this attribute with a new name.\n   *\n   * @param newName the name of the new attribute\n   * @return a copy of this attribute with the same index\n   */\n  //@ requires newName != null;\n  //@ ensures \\result.m_Name  == newName;\n  //@ ensures \\result.m_Index == m_Index;\n  //@ ensures \\result.m_Type  == m_Type;\n  public final /*@ pure non_null @*/ Attribute copy(String newName) {\n\n    Attribute copy = new Attribute(newName);\n\n    copy.m_Index = m_Index;\n    copy.m_DateFormat = m_DateFormat;\n    copy.m_Type = m_Type;\n    copy.m_Values = m_Values;\n    copy.m_Hashtable = m_Hashtable;\n    copy.m_Header = m_Header;\n    copy.setMetadata(m_Metadata);\n \n    return copy;\n  }\n\n  /**\n   * Removes a value of a nominal, string, or relation-valued\n   * attribute. Creates a fresh list of attribute values before\n   * removing it.\n   *\n   * @param index the value's index\n   * @throws IllegalArgumentException if the attribute is not \n   * of the correct type\n   */\n  //@ requires isNominal() || isString() || isRelationValued();\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Values.size();\n  final void delete(int index) {\n    \n    if (!isNominal() \u0026\u0026 !isString() \u0026\u0026 !isRelationValued()) \n      throw new IllegalArgumentException(\"Can only remove value of \" +\n                                         \"nominal, string or relation-\" +\n                                         \" valued attribute!\");\n    else {\n      m_Values = Utils.cast(m_Values.clone());\n      m_Values.remove(index);\n      if (!isRelationValued()) {\n        Hashtable\u003cObject,Integer\u003e hash = new Hashtable\u003cObject,Integer\u003e(m_Hashtable.size());\n        Enumeration enu = m_Hashtable.keys();\n        while (enu.hasMoreElements()) {\n          Object string = enu.nextElement();\n          Integer valIndexObject = (Integer)m_Hashtable.get(string);\n          int valIndex = valIndexObject.intValue();\n          if (valIndex \u003e index) {\n            hash.put(string, new Integer(valIndex - 1));\n          } else if (valIndex \u003c index) {\n            hash.put(string, valIndexObject);\n          }\n        }\n        m_Hashtable = hash;\n      }\n    }\n  }\n\n  /**\n   * Adds an attribute value.\n   *\n   * @param value the attribute value\n   */\n  //@ requires value != null;\n  //@ ensures  m_Values.size() == \\old(m_Values.size()) + 1;\n  final void forceAddValue(String value) {\n\n    Object store = value;\n    if (value.length() \u003e STRING_COMPRESS_THRESHOLD) {\n      try {\n        store = new SerializedObject(value, true);\n      } catch (Exception ex) {\n        System.err.println(\"Couldn't compress string attribute value -\"\n                           + \" storing uncompressed.\");\n      }\n    }\n    m_Values.add(store);\n    m_Hashtable.put(store, new Integer(m_Values.size() - 1));\n  }\n\n  /**\n   * Sets the index of this attribute.\n   *\n   * @param index the index of this attribute\n   */\n  //@ requires 0 \u003c= index;\n  //@ assignable m_Index;\n  //@ ensures m_Index == index;\n  final void setIndex(int index) {\n\n    m_Index = index;\n  }\n\n  /**\n   * Sets a value of a nominal attribute or string attribute.\n   * Creates a fresh list of attribute values before it is set.\n   *\n   * @param index the value's index\n   * @param string the value\n   * @throws IllegalArgumentException if the attribute is not nominal or \n   * string.\n   */\n  //@ requires string != null;\n  //@ requires isNominal() || isString();\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Values.size();\n  final void setValue(int index, String string) {\n    \n    switch (m_Type) {\n    case NOMINAL:\n    case STRING:\n      m_Values = Utils.cast(m_Values.clone());\n      m_Hashtable = Utils.cast(m_Hashtable.clone());\n      Object store = string;\n      if (string.length() \u003e STRING_COMPRESS_THRESHOLD) {\n        try {\n          store = new SerializedObject(string, true);\n        } catch (Exception ex) {\n          System.err.println(\"Couldn't compress string attribute value -\"\n                             + \" storing uncompressed.\");\n        }\n      }\n      m_Hashtable.remove(m_Values.get(index));\n      m_Values.set(index, store);\n      m_Hashtable.put(store, new Integer(index));\n      break;\n    default:\n      throw new IllegalArgumentException(\"Can only set values for nominal\"\n                                         + \" or string attributes!\");\n    }\n  }\n\n  /**\n   * Sets a value of a relation-valued attribute.\n   * Creates a fresh list of attribute values before it is set.\n   *\n   * @param index the value's index\n   * @param data the value\n   * @throws IllegalArgumentException if the attribute is not \n   * relation-valued.\n   */\n  final void setValue(int index, Instances data) {\n    \n    if (isRelationValued()) { \n      if (!data.equalHeaders(m_Header)) {\n        throw new IllegalArgumentException(\"Can't set relational value. \" +\n                                           \"Headers not compatible.\\n\" +\n                                           data.equalHeadersMsg(m_Header));\n      }\n      m_Values = Utils.cast(m_Values.clone());\n      m_Values.set(index, data);\n    } else {\n      throw new IllegalArgumentException(\"Can only set value for\"\n                                         + \" relation-valued attributes!\");\n    }\n  }\n\n  /**\n   * Returns the given amount of milliseconds formatted according to the\n   * current Date format.\n   * \n   * @param date \tthe date, represented in milliseconds since \n   * \t\t\tJanuary 1, 1970, 00:00:00 GMT, to return as string\n   * @return \t\tthe formatted date\n   */\n  //@ requires isDate();\n  public /*@pure@*/ String formatDate(double date) {\n    switch (m_Type) {\n    case DATE:\n      return m_DateFormat.format(new Date((long)date));\n    default:\n      throw new IllegalArgumentException(\"Can only format date values for date\"\n                                         + \" attributes!\");\n    }\n  }\n\n  /**\n   * Parses the given String as Date, according to the current format and\n   * returns the corresponding amount of milliseconds.\n   * \n   * @param string the date to parse\n   * @return the date in milliseconds since January 1, 1970, 00:00:00 GMT\n   * @throws ParseException if parsing fails\n   */\n  //@ requires isDate();\n  //@ requires string != null;\n  public double parseDate(String string) throws ParseException {\n    switch (m_Type) {\n    case DATE:\n      long time = m_DateFormat.parse(string).getTime();\n      // TODO put in a safety check here if we can't store the value in a double.\n      return (double)time;\n    default:\n      throw new IllegalArgumentException(\"Can only parse date values for date\"\n                                         + \" attributes!\");\n    }\n  }\n\n  /**\n   * Returns the properties supplied for this attribute.\n   *\n   * @return metadata for this attribute\n   */  \n  public final /*@ pure @*/ ProtectedProperties getMetadata() {\n\n    return m_Metadata;\n  }\n\n  /**\n   * Returns the ordering of the attribute. One of the following:\n   * \n   * ORDERING_SYMBOLIC - attribute values should be treated as symbols.\n   * ORDERING_ORDERED  - attribute values have a global ordering.\n   * ORDERING_MODULO   - attribute values have an ordering which wraps.\n   *\n   * @return the ordering type of the attribute\n   */\n  public final /*@ pure @*/ int ordering() {\n\n    return m_Ordering;\n  }\n\n  /**\n   * Returns whether the attribute values are equally spaced.\n   *\n   * @return whether the attribute is regular or not\n   */\n  public final /*@ pure @*/ boolean isRegular() {\n\n    return m_IsRegular;\n  }\n\n  /**\n   * Returns whether the attribute can be averaged meaningfully.\n   *\n   * @return whether the attribute can be averaged or not\n   */\n  public final /*@ pure @*/ boolean isAveragable() {\n\n    return m_IsAveragable;\n  }\n\n  /**\n   * Returns whether the attribute has a zeropoint and may be\n   * added meaningfully.\n   *\n   * @return whether the attribute has a zeropoint or not\n   */\n  public final /*@ pure @*/ boolean hasZeropoint() {\n\n    return m_HasZeropoint;\n  }\n\n  /**\n   * Returns the attribute's weight.\n   *\n   * @return the attribute's weight as a double\n   */\n  public final /*@ pure @*/ double weight() {\n\n    return m_Weight;\n  }\n\n  /**\n   * Sets the new attribute's weight\n   * \n   * @param value\tthe new weight\n   */\n  public void setWeight(double value) {\n    Properties\tprops;\n    Enumeration names;\n    String\tname;\n    \n    m_Weight = value;\n\n    // generate new metadata object\n    props = new Properties();\n    names = m_Metadata.propertyNames();\n    while (names.hasMoreElements()) {\n      name = (String) names.nextElement();\n      if (!name.equals(\"weight\"))\n\tprops.setProperty(name, m_Metadata.getProperty(name));\n    }\n    props.setProperty(\"weight\", \"\" + m_Weight);\n    m_Metadata = new ProtectedProperties(props);\n  }\n  \n  /**\n   * Returns the lower bound of a numeric attribute.\n   *\n   * @return the lower bound of the specified numeric range\n   */\n  public final /*@ pure @*/ double getLowerNumericBound() {\n\n    return m_LowerBound;\n  }\n\n  /**\n   * Returns whether the lower numeric bound of the attribute is open.\n   *\n   * @return whether the lower numeric bound is open or not (closed)\n   */\n  public final /*@ pure @*/ boolean lowerNumericBoundIsOpen() {\n\n    return m_LowerBoundIsOpen;\n  }\n\n  /**\n   * Returns the upper bound of a numeric attribute.\n   *\n   * @return the upper bound of the specified numeric range\n   */\n  public final /*@ pure @*/ double getUpperNumericBound() {\n\n    return m_UpperBound;\n  }\n\n  /**\n   * Returns whether the upper numeric bound of the attribute is open.\n   *\n   * @return whether the upper numeric bound is open or not (closed)\n   */\n  public final /*@ pure @*/ boolean upperNumericBoundIsOpen() {\n\n    return m_UpperBoundIsOpen;\n  }\n\n  /**\n   * Determines whether a value lies within the bounds of the attribute.\n   *\n   * @param value the value to check\n   * @return whether the value is in range\n   */\n  public final /*@ pure @*/ boolean isInRange(double value) {\n\n    // dates and missing values are a special case \n    if (m_Type == DATE || Utils.isMissingValue(value)) return true;\n    if (m_Type != NUMERIC) {\n      // do label range check\n      int intVal = (int) value;\n      if (intVal \u003c 0 || intVal \u003e= m_Hashtable.size()) return false;\n    } else {\n      // do numeric bounds check\n      if (m_LowerBoundIsOpen) {\n\tif (value \u003c= m_LowerBound) return false;\n      } else {\n\tif (value \u003c m_LowerBound) return false;\n      }\n      if (m_UpperBoundIsOpen) {\n\tif (value \u003e= m_UpperBound) return false;\n      } else {\n\tif (value \u003e m_UpperBound) return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Sets the metadata for the attribute. Processes the strings stored in the\n   * metadata of the attribute so that the properties can be set up for the\n   * easy-access metadata methods. Any strings sought that are omitted will\n   * cause default values to be set.\n   * \n   * The following properties are recognised:\n   * ordering, averageable, zeropoint, regular, weight, and range.\n   *\n   * All other properties can be queried and handled appropriately by classes\n   * calling the getMetadata() method.\n   *\n   * @param metadata the metadata\n   * @throws IllegalArgumentException if the properties are not consistent\n   */\n  //@ requires metadata != null;\n  private void setMetadata(ProtectedProperties metadata) {\n    \n    m_Metadata = metadata;\n\n    if (m_Type == DATE) {\n      m_Ordering = ORDERING_ORDERED;\n      m_IsRegular = true;\n      m_IsAveragable = false;\n      m_HasZeropoint = false;\n    } else {\n\n      // get ordering\n      String orderString = m_Metadata.getProperty(\"ordering\",\"\");\n      \n      // numeric ordered attributes are averagable and zeropoint by default\n      String def;\n      if (m_Type == NUMERIC\n\t  \u0026\u0026 orderString.compareTo(\"modulo\") != 0\n\t  \u0026\u0026 orderString.compareTo(\"symbolic\") != 0)\n\tdef = \"true\";\n      else def = \"false\";\n      \n      // determine boolean states\n      m_IsAveragable =\n\t(m_Metadata.getProperty(\"averageable\",def).compareTo(\"true\") == 0);\n      m_HasZeropoint =\n\t(m_Metadata.getProperty(\"zeropoint\",def).compareTo(\"true\") == 0);\n      // averagable or zeropoint implies regular\n      if (m_IsAveragable || m_HasZeropoint) def = \"true\";\n      m_IsRegular =\n\t(m_Metadata.getProperty(\"regular\",def).compareTo(\"true\") == 0);\n      \n      // determine ordering\n      if (orderString.compareTo(\"symbolic\") == 0)\n\tm_Ordering = ORDERING_SYMBOLIC;\n      else if (orderString.compareTo(\"ordered\") == 0)\n\tm_Ordering = ORDERING_ORDERED;\n      else if (orderString.compareTo(\"modulo\") == 0)\n\tm_Ordering = ORDERING_MODULO;\n      else {\n\tif (m_Type == NUMERIC || m_IsAveragable || m_HasZeropoint)\n\t  m_Ordering = ORDERING_ORDERED;\n\telse m_Ordering = ORDERING_SYMBOLIC;\n      }\n    }\n\n    // consistency checks\n    if (m_IsAveragable \u0026\u0026 !m_IsRegular)\n      throw new IllegalArgumentException(\"An averagable attribute must be\"\n\t\t\t\t\t + \" regular\");\n    if (m_HasZeropoint \u0026\u0026 !m_IsRegular)\n      throw new IllegalArgumentException(\"A zeropoint attribute must be\"\n\t\t\t\t\t + \" regular\");\n    if (m_IsRegular \u0026\u0026 m_Ordering == ORDERING_SYMBOLIC)\n      throw new IllegalArgumentException(\"A symbolic attribute cannot be\"\n\t\t\t\t\t + \" regular\");\n    if (m_IsAveragable \u0026\u0026 m_Ordering != ORDERING_ORDERED)\n      throw new IllegalArgumentException(\"An averagable attribute must be\"\n\t\t\t\t\t + \" ordered\");\n    if (m_HasZeropoint \u0026\u0026 m_Ordering != ORDERING_ORDERED)\n      throw new IllegalArgumentException(\"A zeropoint attribute must be\"\n\t\t\t\t\t + \" ordered\");\n\n    // determine weight\n    m_Weight = 1.0;\n    String weightString = m_Metadata.getProperty(\"weight\");\n    if (weightString != null) {\n      try{\n\tm_Weight = Double.valueOf(weightString).doubleValue();\n      } catch (NumberFormatException e) {\n\t// Check if value is really a number\n\tthrow new IllegalArgumentException(\"Not a valid attribute weight: '\" \n\t\t\t\t\t   + weightString + \"'\");\n      }\n    }\n\n    // determine numeric range\n    if (m_Type == NUMERIC) setNumericRange(m_Metadata.getProperty(\"range\"));\n  }\n\n  /**\n   * Sets the numeric range based on a string. If the string is null the range\n   * will default to [-inf,+inf]. A square brace represents a closed interval, a\n   * curved brace represents an open interval, and 'inf' represents infinity.\n   * Examples of valid range strings: \"[-inf,20)\",\"(-13.5,-5.2)\",\"(5,inf]\"\n   *\n   * @param rangeString the string to parse as the attribute's numeric range\n   * @throws IllegalArgumentException if the range is not valid\n   */\n  //@ requires rangeString != null;\n  private void setNumericRange(String rangeString)\n  {\n    // set defaults\n    m_LowerBound = Double.NEGATIVE_INFINITY;\n    m_LowerBoundIsOpen = false;\n    m_UpperBound = Double.POSITIVE_INFINITY;\n    m_UpperBoundIsOpen = false;\n\n    if (rangeString == null) return;\n\n    // set up a tokenzier to parse the string\n    StreamTokenizer tokenizer =\n      new StreamTokenizer(new StringReader(rangeString));\n    tokenizer.resetSyntax();         \n    tokenizer.whitespaceChars(0, ' ');    \n    tokenizer.wordChars(' '+1,'\\u00FF');\n    tokenizer.ordinaryChar('[');\n    tokenizer.ordinaryChar('(');\n    tokenizer.ordinaryChar(',');\n    tokenizer.ordinaryChar(']');\n    tokenizer.ordinaryChar(')');\n\n    try {\n\n      // get opening brace\n      tokenizer.nextToken();\n    \n      if (tokenizer.ttype == '[') m_LowerBoundIsOpen = false;\n      else if (tokenizer.ttype == '(') m_LowerBoundIsOpen = true;\n      else throw new IllegalArgumentException(\"Expected opening brace on range,\"\n\t\t\t\t\t      + \" found: \"\n\t\t\t\t\t      + tokenizer.toString());\n\n      // get lower bound\n      tokenizer.nextToken();\n      if (tokenizer.ttype != tokenizer.TT_WORD)\n\tthrow new IllegalArgumentException(\"Expected lower bound in range,\"\n\t\t\t\t\t   + \" found: \"\n\t\t\t\t\t   + tokenizer.toString());\n      if (tokenizer.sval.compareToIgnoreCase(\"-inf\") == 0)\n\tm_LowerBound = Double.NEGATIVE_INFINITY;\n      else if (tokenizer.sval.compareToIgnoreCase(\"+inf\") == 0)\n\tm_LowerBound = Double.POSITIVE_INFINITY;\n      else if (tokenizer.sval.compareToIgnoreCase(\"inf\") == 0)\n\tm_LowerBound = Double.NEGATIVE_INFINITY;\n      else try {\n\tm_LowerBound = Double.valueOf(tokenizer.sval).doubleValue();\n      } catch (NumberFormatException e) {\n\tthrow new IllegalArgumentException(\"Expected lower bound in range,\"\n\t\t\t\t\t   + \" found: '\" + tokenizer.sval + \"'\");\n      }\n\n      // get separating comma\n      if (tokenizer.nextToken() != ',')\n\tthrow new IllegalArgumentException(\"Expected comma in range,\"\n\t\t\t\t\t   + \" found: \"\n\t\t\t\t\t   + tokenizer.toString());\n\n      // get upper bound\n      tokenizer.nextToken();\n      if (tokenizer.ttype != tokenizer.TT_WORD)\n\tthrow new IllegalArgumentException(\"Expected upper bound in range,\"\n\t\t\t\t\t   + \" found: \"\n\t\t\t\t\t   + tokenizer.toString());\n      if (tokenizer.sval.compareToIgnoreCase(\"-inf\") == 0)\n\tm_UpperBound = Double.NEGATIVE_INFINITY;\n      else if (tokenizer.sval.compareToIgnoreCase(\"+inf\") == 0)\n\tm_UpperBound = Double.POSITIVE_INFINITY;\n      else if (tokenizer.sval.compareToIgnoreCase(\"inf\") == 0)\n\tm_UpperBound = Double.POSITIVE_INFINITY;\n      else try {\n\tm_UpperBound = Double.valueOf(tokenizer.sval).doubleValue();\n      } catch (NumberFormatException e) {\n\tthrow new IllegalArgumentException(\"Expected upper bound in range,\"\n\t\t\t\t\t   + \" found: '\" + tokenizer.sval + \"'\");\n      }\n\n      // get closing brace\n      tokenizer.nextToken();\n    \n      if (tokenizer.ttype == ']') m_UpperBoundIsOpen = false;\n      else if (tokenizer.ttype == ')') m_UpperBoundIsOpen = true;\n      else throw new IllegalArgumentException(\"Expected closing brace on range,\"\n\t\t\t\t\t      + \" found: \"\n\t\t\t\t\t      + tokenizer.toString());\n\n      // check for rubbish on end\n      if (tokenizer.nextToken() != tokenizer.TT_EOF)\n\tthrow new IllegalArgumentException(\"Expected end of range string,\"\n\t\t\t\t\t   + \" found: \"\n\t\t\t\t\t   + tokenizer.toString());\n\n    } catch (IOException e) {\n      throw new IllegalArgumentException(\"IOException reading attribute range\"\n\t\t\t\t\t + \" string: \" + e.getMessage());\n    }\n\n    if (m_UpperBound \u003c m_LowerBound)\n      throw new IllegalArgumentException(\"Upper bound (\" + m_UpperBound\n\t\t\t\t\t + \") on numeric range is\"\n\t\t\t\t\t + \" less than lower bound (\"\n\t\t\t\t\t + m_LowerBound + \")!\");\n  }\n  \n  /**\n   * Returns the revision string.\n   * \n   * @return\t\tthe revision\n   */\n  public String getRevision() {\n    return RevisionUtils.extract(\"$Revision: 9515 $\");\n  }\n\n  /**\n   * Simple main method for testing this class.\n   * \n   * @param ops the commandline options\n   */\n  //@ requires ops != null;\n  //@ requires \\nonnullelements(ops);\n  public static void main(String[] ops) {\n\n    try {\n      \n      // Create numeric attributes \"length\" and \"weight\"\n      Attribute length = new Attribute(\"length\");\n      Attribute weight = new Attribute(\"weight\");\n\n      // Create date attribute \"date\"\n      Attribute date = new Attribute(\"date\", \"yyyy-MM-dd HH:mm:ss\");\n\n      System.out.println(date);\n      double dd = date.parseDate(\"2001-04-04 14:13:55\");\n      System.out.println(\"Test date = \" + dd);\n      System.out.println(date.formatDate(dd));\n\n      dd = new Date().getTime();\n      System.out.println(\"Date now = \" + dd);\n      System.out.println(date.formatDate(dd));\n      \n      // Create vector to hold nominal values \"first\", \"second\", \"third\" \n      List\u003cString\u003e my_nominal_values = new ArrayList\u003cString\u003e(3); \n      my_nominal_values.add(\"first\"); \n      my_nominal_values.add(\"second\"); \n      my_nominal_values.add(\"third\"); \n      \n      // Create nominal attribute \"position\" \n      Attribute position = new Attribute(\"position\", my_nominal_values);\n\n      // Print the name of \"position\"\n      System.out.println(\"Name of \\\"position\\\": \" + position.name());\n\n      // Print the values of \"position\"\n      Enumeration attValues = position.enumerateValues();\n      while (attValues.hasMoreElements()) {\n\tString string = (String)attValues.nextElement();\n\tSystem.out.println(\"Value of \\\"position\\\": \" + string);\n      }\n\n      // Shallow copy attribute \"position\"\n      Attribute copy = (Attribute) position.copy();\n\n      // Test if attributes are the same\n      System.out.println(\"Copy is the same as original: \" + copy.equals(position));\n\n      // Print index of attribute \"weight\" (should be unset: -1)\n      System.out.println(\"Index of attribute \\\"weight\\\" (should be -1): \" + \n\t\t\t weight.index());\n\n      // Print index of value \"first\" of attribute \"position\"\n      System.out.println(\"Index of value \\\"first\\\" of \\\"position\\\" (should be 0): \" +\n\t\t\t position.indexOfValue(\"first\"));\n\n      // Tests type of attribute \"position\"\n      System.out.println(\"\\\"position\\\" is numeric: \" + position.isNumeric());\n      System.out.println(\"\\\"position\\\" is nominal: \" + position.isNominal());\n      System.out.println(\"\\\"position\\\" is string: \" + position.isString());\n\n      // Prints name of attribute \"position\"\n      System.out.println(\"Name of \\\"position\\\": \" + position.name());\n    \n      // Prints number of values of attribute \"position\"\n      System.out.println(\"Number of values for \\\"position\\\": \" + position.numValues());\n\n      // Prints the values (againg)\n      for (int i = 0; i \u003c position.numValues(); i++) {\n\tSystem.out.println(\"Value \" + i + \": \" + position.value(i));\n      }\n\n      // Prints the attribute \"position\" in ARFF format\n      System.out.println(position);\n\n      // Checks type of attribute \"position\" using constants\n      switch (position.type()) {\n      case Attribute.NUMERIC:\n\tSystem.out.println(\"\\\"position\\\" is numeric\");\n\tbreak;\n      case Attribute.NOMINAL:\n\tSystem.out.println(\"\\\"position\\\" is nominal\");\n\tbreak;\n      case Attribute.STRING:\n\tSystem.out.println(\"\\\"position\\\" is string\");\n\tbreak;\n      case Attribute.DATE:\n\tSystem.out.println(\"\\\"position\\\" is date\");\n\tbreak;\n      case Attribute.RELATIONAL:\n\tSystem.out.println(\"\\\"position\\\" is relation-valued\");\n\tbreak;\n      default:\n\tSystem.out.println(\"\\\"position\\\" has unknown type\");\n      }\n\n      ArrayList\u003cAttribute\u003e atts = new ArrayList\u003cAttribute\u003e(1);\n      atts.add(position);\n      Instances relation = new Instances(\"Test\", atts, 0);\n      Attribute relationValuedAtt = new Attribute(\"test\", relation);\n      System.out.println(relationValuedAtt);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n  \n",
        "name": "Attribute.java",
        "path": "weka-android/src/main/java/weka/core/Attribute.java",
        "url": "/github.com/andrecamara/weka-android/-/blob/weka-android/src/main/java/weka/core/Attribute.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 214,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 227,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 228,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires metadata != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 248,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 249,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires dateFormat != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 265,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 266,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires dateFormat != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 267,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires metadata != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 296,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 315,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 316,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires metadata != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 601,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Index;"
        },
        {
          "limitHit": false,
          "lineNumber": 639,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e (m_Type == NOMINAL);"
        },
        {
          "limitHit": false,
          "lineNumber": 650,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e ((m_Type == NUMERIC) || (m_Type == DATE));"
        },
        {
          "limitHit": false,
          "lineNumber": 661,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e (m_Type == RELATIONAL);"
        },
        {
          "limitHit": false,
          "lineNumber": 672,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e (m_Type == STRING);"
        },
        {
          "limitHit": false,
          "lineNumber": 683,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e (m_Type == DATE);"
        },
        {
          "limitHit": false,
          "lineNumber": 694,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Name;"
        },
        {
          "limitHit": false,
          "lineNumber": 768,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Type;"
        },
        {
          "limitHit": false,
          "lineNumber": 848,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 849,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 867,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 868,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 889,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 890,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 907,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attributeName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 908,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 1051,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires newName != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1052,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result.m_Name  == newName;"
        },
        {
          "limitHit": false,
          "lineNumber": 1053,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result.m_Index == m_Index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1054,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result.m_Type  == m_Type;"
        },
        {
          "limitHit": false,
          "lineNumber": 1079,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires isNominal() || isString() || isRelationValued();"
        },
        {
          "limitHit": false,
          "lineNumber": 1080,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Values.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 1113,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires value != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1135,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1137,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Index == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1152,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires string != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1153,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires isNominal() || isString();"
        },
        {
          "limitHit": false,
          "lineNumber": 1154,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c m_Values.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 1214,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires isDate();"
        },
        {
          "limitHit": false,
          "lineNumber": 1233,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires isDate();"
        },
        {
          "limitHit": false,
          "lineNumber": 1234,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires string != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1421,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires metadata != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1511,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires rangeString != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1630,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires ops != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1631,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires \\nonnullelements(ops);"
        },
        {
          "limitHit": false,
          "lineNumber": 215,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 229,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 250,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 268,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 297,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 850,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 851,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Index == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 869,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 870,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Index == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 891,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 892,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Index == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 909,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Name == attributeName;"
        },
        {
          "limitHit": false,
          "lineNumber": 910,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Index == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1114,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures  m_Values.size() == \\old(m_Values.size()) + 1;"
        }
      ],
      "repository": {
        "name": "github.com/andrecamara/weka-android",
        "url": "/github.com/andrecamara/weka-android"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "4eef1b0916c85e8339cd32d672affca3d58e4c3f"
        },
        "content": "/*\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n/*\n *    Instances.java\n *    Copyright (C) 1999-2012 University of Waikato, Hamilton, New Zealand\n *\n */\n\npackage weka.core;\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Random;\n\nimport weka.core.converters.ArffLoader.ArffReader;\nimport weka.core.converters.ConverterUtils.DataSource;\n\n/**\n * Class for handling an ordered set of weighted instances. \u003cp\u003e\n *\n * Typical usage: \u003cp\u003e\n * \u003cpre\u003e\n * import weka.core.converters.ConverterUtils.DataSource;\n * ...\n * \n * // Read all the instances in the file (ARFF, CSV, XRFF, ...)\n * DataSource source = new DataSource(filename);\n * Instances instances = source.getDataSet();\n *\n * // Make the last attribute be the class\n * instances.setClassIndex(instances.numAttributes() - 1);\n * \n * // Print header and instances.\n * System.out.println(\"\\nDataset:\\n\");\n * System.out.println(instances);\n * \n * ...\n * \u003c/pre\u003e\u003cp\u003e\n *\n * All methods that change a set of instances are safe, ie. a change\n * of a set of instances does not affect any other sets of\n * instances. All methods that change a datasets's attribute\n * information clone the dataset before it is changed.\n *\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\n * @author Len Trigg (trigg@cs.waikato.ac.nz)\n * @author FracPete (fracpete at waikato dot ac dot nz)\n * @version $Revision: 9378 $ \n */\npublic class Instances extends AbstractList\u003cInstance\u003e\n  implements Serializable, RevisionHandler {\n  \n  /** for serialization */\n  static final long serialVersionUID = -19412345060742748L;\n  \n  /** The filename extension that should be used for arff files */\n  public final static String FILE_EXTENSION = \".arff\";\n\n  /** The filename extension that should be used for bin. serialized instances files */\n  public final static String SERIALIZED_OBJ_FILE_EXTENSION = \".bsi\";\n\n  /** The keyword used to denote the start of an arff header */\n  public final static String ARFF_RELATION = \"@relation\";\n\n  /** The keyword used to denote the start of the arff data section */\n  public final static String ARFF_DATA = \"@data\";\n\n  /** The dataset's name. */\n  protected /*@spec_public non_null@*/ String m_RelationName;         \n\n  /** The attribute information. */\n  protected /*@spec_public non_null@*/ ArrayList\u003cAttribute\u003e m_Attributes;\n  /*  public invariant (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c m_Attributes.size(); \n                    m_Attributes.get(i) != null);\n  */\n\n  /** The instances. */\n  protected /*@spec_public non_null@*/ ArrayList\u003cInstance\u003e m_Instances;\n\n  /** The class attribute's index */\n  protected int m_ClassIndex;\n  //@ protected invariant classIndex() == m_ClassIndex;\n\n  /** The lines read so far in case of incremental loading. Since the \n   * StreamTokenizer will be re-initialized with every instance that is read,\n   * we have to keep track of the number of lines read so far. \n   * @see #readInstance(Reader) */\n  protected int m_Lines = 0;\n  \n  /**\n   * Reads an ARFF file from a reader, and assigns a weight of\n   * one to each instance. Lets the index of the class \n   * attribute be undefined (negative).\n   *\n   * @param reader the reader\n   * @throws IOException if the ARFF file is not read \n   * successfully\n   */\n  public Instances(/*@non_null@*/Reader reader) throws IOException {\n    ArffReader arff = new ArffReader(reader);\n    Instances dataset = arff.getData();\n    initialize(dataset, dataset.numInstances());\n    dataset.copyInstances(0, this, dataset.numInstances());\n    compactify();\n  }\n \n  /**\n   * Reads the header of an ARFF file from a reader and \n   * reserves space for the given number of instances. Lets\n   * the class index be undefined (negative).\n   *\n   * @param reader the reader\n   * @param capacity the capacity\n   * @throws IllegalArgumentException if the header is not read successfully\n   * or the capacity is negative.\n   * @throws IOException if there is a problem with the reader.\n   * @deprecated instead of using this method in conjunction with the\n   * \u003ccode\u003ereadInstance(Reader)\u003c/code\u003e method, one should use the \n   * \u003ccode\u003eArffLoader\u003c/code\u003e or \u003ccode\u003eDataSource\u003c/code\u003e class instead.\n   * @see weka.core.converters.ArffLoader\n   * @see weka.core.converters.ConverterUtils.DataSource\n   */\n  //@ requires capacity \u003e= 0;\n  //@ ensures classIndex() == -1;\n  @Deprecated public Instances(/*@non_null@*/Reader reader, int capacity)\n    throws IOException {\n\n    ArffReader arff = new ArffReader(reader, 0);\n    Instances header = arff.getStructure();\n    initialize(header, capacity);\n    m_Lines = arff.getLineNo();\n  }\n\n  /**\n   * Constructor copying all instances and references to\n   * the header information from the given set of instances.\n   *\n   * @param dataset the set to be copied\n   */\n  public Instances(/*@non_null@*/Instances dataset) {\n\n    this(dataset, dataset.numInstances());\n\n    dataset.copyInstances(0, this, dataset.numInstances());\n  }\n\n  /**\n   * Constructor creating an empty set of instances. Copies references\n   * to the header information from the given set of instances. Sets\n   * the capacity of the set of instances to 0 if its negative.\n   *\n   * @param dataset the instances from which the header \n   * information is to be taken\n   * @param capacity the capacity of the new dataset \n   */\n  public Instances(/*@non_null@*/Instances dataset, int capacity) {\n    initialize(dataset, capacity);\n  }\n\n  /**\n   * initializes with the header information of the given dataset and sets\n   * the capacity of the set of instances.\n   * \n   * @param dataset the dataset to use as template\n   * @param capacity the number of rows to reserve\n   */\n  protected void initialize(Instances dataset, int capacity) {\n    if (capacity \u003c 0)\n      capacity = 0;\n    \n    // Strings only have to be \"shallow\" copied because\n    // they can't be modified.\n    m_ClassIndex   = dataset.m_ClassIndex;\n    m_RelationName = dataset.m_RelationName;\n    m_Attributes   = dataset.m_Attributes;\n    m_Instances    = new ArrayList\u003cInstance\u003e(capacity);\n  }\n  \n  /**\n   * Creates a new set of instances by copying a \n   * subset of another set.\n   *\n   * @param source the set of instances from which a subset \n   * is to be created\n   * @param first the index of the first instance to be copied\n   * @param toCopy the number of instances to be copied\n   * @throws IllegalArgumentException if first and toCopy are out of range\n   */\n  //@ requires 0 \u003c= first;\n  //@ requires 0 \u003c= toCopy;\n  //@ requires first + toCopy \u003c= source.numInstances();\n  public Instances(/*@non_null@*/Instances source, int first, int toCopy) {\n    \n    this(source, toCopy);\n\n    if ((first \u003c 0) || ((first + toCopy) \u003e source.numInstances())) {\n      throw new IllegalArgumentException(\"Parameters first and/or toCopy out \"+\n                                         \"of range\");\n    }\n    source.copyInstances(first, this, toCopy);\n  }\n\n  /**\n   * Creates an empty set of instances. Uses the given\n   * attribute information. Sets the capacity of the set of \n   * instances to 0 if its negative. Given attribute information\n   * must not be changed after this constructor has been used.\n   *\n   * @param name the name of the relation\n   * @param attInfo the attribute information\n   * @param capacity the capacity of the set\n   * @throws IllegalArgumentException if attribute names are not unique\n   */\n  public Instances(/*@non_null@*/String name, \n\t\t   /*@non_null@*/ArrayList\u003cAttribute\u003e attInfo, int capacity) {\n\n    // check whether the attribute names are unique\n    HashSet\u003cString\u003e names = new HashSet\u003cString\u003e();\n    StringBuffer nonUniqueNames = new StringBuffer();\n    for (Attribute att: attInfo) {\n      if (names.contains(att.name())) {\n        nonUniqueNames.append(\"'\" + att.name() +\"' \");\n      }\n      names.add(att.name());\n    }\n    if (names.size() != attInfo.size())\n      throw new IllegalArgumentException(\"Attribute names are not unique!\" +\n      \t\t\" Causes: \" + nonUniqueNames.toString());\n    names.clear();\n    \n    m_RelationName = name;\n    m_ClassIndex = -1;\n    m_Attributes = attInfo;\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      attribute(i).setIndex(i);\n    }\n    m_Instances = new ArrayList\u003cInstance\u003e(capacity);\n  }\n\n  /**\n   * Create a copy of the structure if the data has string or\n   * relational attributes, \"cleanses\" string types (i.e. doesn't\n   * contain references to the strings seen in the past) and all\n   * relational attributes.\n   *\n   * @return a copy of the instance structure.\n   */\n  public Instances stringFreeStructure() {\n\n    ArrayList\u003cAttribute\u003e newAtts = new ArrayList\u003cAttribute\u003e();\n    for (int i = 0 ; i \u003c m_Attributes.size(); i++) {\n      Attribute att = (Attribute)m_Attributes.get(i);\n      if (att.type() == Attribute.STRING) {\n        newAtts.add(new Attribute(att.name(), (List\u003cString\u003e)null, i));\n      } else if (att.type() == Attribute.RELATIONAL) {\n        newAtts.add(new Attribute(att.name(), new Instances(att.relation(), 0), i));\n      }\n    }\n    if (newAtts.size() == 0) {\n      return new Instances(this, 0);\n    }\n    ArrayList\u003cAttribute\u003e atts = Utils.cast(m_Attributes.clone());\n    for (int i = 0; i \u003c newAtts.size(); i++) {\n      atts.set(((Attribute)newAtts.get(i)).index(), newAtts.get(i));\n    }\n    Instances result = new Instances(this, 0);\n    result.m_Attributes = atts;\n    return result;\n  }\n\n  /**\n   * Adds one instance to the end of the set. \n   * Shallow copies instance before it is added. Increases the\n   * size of the dataset if it is not large enough. Does not\n   * check if the instance is compatible with the dataset.\n   * Note: String or relational values are not transferred.\n   *\n   * @param instance the instance to be added\n   */\n  public boolean add(/*@non_null@*/ Instance instance) {\n\n    Instance newInstance = (Instance)instance.copy();\n\n    newInstance.setDataset(this);\n    m_Instances.add(newInstance);\n\n    return true;\n  }\n\n  /**\n   * Adds one instance to the end of the set. \n   * Shallow copies instance before it is added. Increases the\n   * size of the dataset if it is not large enough. Does not\n   * check if the instance is compatible with the dataset.\n   * Note: String or relational values are not transferred.\n   *\n   * @param index position where instance is to be inserted\n   * @param instance the instance to be added\n   */\n  //@ requires 0 \u003c= index;\n  //@ requires index \u003c m_Instances.size();\n  public void add(int index, /*@non_null@*/ Instance instance) {\n\n    Instance newInstance = (Instance)instance.copy();\n\n    newInstance.setDataset(this);\n    m_Instances.add(index, newInstance);\n  }\n\n  /**\n   * Returns an attribute.\n   *\n   * @param index the attribute's index (index starts with 0)\n   * @return the attribute at the given position\n   */\n  //@ requires 0 \u003c= index;\n  //@ requires index \u003c m_Attributes.size();\n  //@ ensures \\result != null;\n  public /*@pure@*/ Attribute attribute(int index) {\n    \n    return (Attribute) m_Attributes.get(index);\n  }\n\n  /**\n   * Returns an attribute given its name. If there is more than\n   * one attribute with the same name, it returns the first one.\n   * Returns null if the attribute can't be found.\n   *\n   * @param name the attribute's name\n   * @return the attribute with the given name, null if the\n   * attribute can't be found\n   */ \n  public /*@pure@*/ Attribute attribute(String name) {\n    \n    for (int i = 0; i \u003c numAttributes(); i++) {\n      if (attribute(i).name().equals(name)) {\n\treturn attribute(i);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Checks for attributes of the given type in the dataset\n   *\n   * @param attType  the attribute type to look for\n   * @return         true if attributes of the given type are present\n   */\n  public boolean checkForAttributeType(int attType) {\n    \n    int i = 0;\n    \n    while (i \u003c m_Attributes.size()) {\n      if (attribute(i++).type() == attType) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Checks for string attributes in the dataset\n   *\n   * @return true if string attributes are present, false otherwise\n   */\n  public /*@pure@*/ boolean checkForStringAttributes() {\n    return checkForAttributeType(Attribute.STRING);\n  }\n\n  /**\n   * Checks if the given instance is compatible\n   * with this dataset. Only looks at the size of\n   * the instance and the ranges of the values for \n   * nominal and string attributes.\n   *\n   * @param instance the instance to check\n   * @return true if the instance is compatible with the dataset \n   */\n  public /*@pure@*/ boolean checkInstance(Instance instance) {\n\n    if (instance.numAttributes() != numAttributes()) {\n      return false;\n    }\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      if (instance.isMissing(i)) {\n\tcontinue;\n      } else if (attribute(i).isNominal() ||\n\t\t attribute(i).isString()) {\n\tif (!(Utils.eq(instance.value(i),\n\t\t       (double)(int)instance.value(i)))) {\n\t  return false;\n\t} else if (Utils.sm(instance.value(i), 0) ||\n\t\t   Utils.gr(instance.value(i),\n\t\t\t    attribute(i).numValues())) {\n\t  return false;\n\t}\n      }\n    }\n    return true;\n  }\n\t\n  /**\n   * Returns the class attribute.\n   *\n   * @return the class attribute\n   * @throws UnassignedClassException if the class is not set\n   */\n  //@ requires classIndex() \u003e= 0;\n  public /*@pure@*/ Attribute classAttribute() {\n\n    if (m_ClassIndex \u003c 0) {\n      throw new UnassignedClassException(\"Class index is negative (not set)!\");\n    }\n    return attribute(m_ClassIndex);\n  }\n\n  /**\n   * Returns the class attribute's index. Returns negative number\n   * if it's undefined.\n   *\n   * @return the class index as an integer\n   */\n  // ensures \\result == m_ClassIndex;\n  public /*@pure@*/ int classIndex() {\n    \n    return m_ClassIndex;\n  }\n \n  /**\n   * Compactifies the set of instances. Decreases the capacity of\n   * the set so that it matches the number of instances in the set.\n   */\n  public void compactify() {\n\n    m_Instances.trimToSize();\n  }\n\n  /**\n   * Removes all instances from the set.\n   */\n  public void delete() {\n    \n    m_Instances = new ArrayList\u003cInstance\u003e();\n  }\n\n  /**\n   * Removes an instance at the given position from the set.\n   *\n   * @param index the instance's position (index starts with 0)\n   */\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numInstances();\n  public void delete(int index) {\n    \n    m_Instances.remove(index);\n  }\n\n  /**\n   * Deletes an attribute at the given position \n   * (0 to numAttributes() - 1). A deep copy of the attribute\n   * information is performed before the attribute is deleted.\n   *\n   * @param position the attribute's position (position starts with 0)\n   * @throws IllegalArgumentException if the given index is out of range \n   *            or the class attribute is being deleted\n   */\n  //@ requires 0 \u003c= position \u0026\u0026 position \u003c numAttributes();\n  //@ requires position != classIndex();\n  public void deleteAttributeAt(int position) {\n\t \n    if ((position \u003c 0) || (position \u003e= m_Attributes.size())) {\n      throw new IllegalArgumentException(\"Index out of range\");\n    }\n    if (position == m_ClassIndex) {\n      throw new IllegalArgumentException(\"Can't delete class attribute\");\n    }\n    freshAttributeInfo();\n    if (m_ClassIndex \u003e position) {\n      m_ClassIndex--;\n    }\n    m_Attributes.remove(position);\n    for (int i = position; i \u003c m_Attributes.size(); i++) {\n      Attribute current = (Attribute)m_Attributes.get(i);\n      current.setIndex(current.index() - 1);\n    }\n    for (int i = 0; i \u003c numInstances(); i++) {\n      instance(i).setDataset(null);\n      instance(i).deleteAttributeAt(position); \n      instance(i).setDataset(this);\n    }\n  }\n\n  /**\n   * Deletes all attributes of the given type in the dataset. A deep copy of \n   * the attribute information is performed before an attribute is deleted.\n   *\n   * @param attType the attribute type to delete\n   * @throws IllegalArgumentException if attribute couldn't be \n   * successfully deleted (probably because it is the class attribute).\n   */\n  public void deleteAttributeType(int attType) {\n    int i = 0;\n    while (i \u003c m_Attributes.size()) {\n      if (attribute(i).type() == attType) {\n        deleteAttributeAt(i);\n      } else {\n        i++;\n      }\n    }\n  }\n\n  /**\n   * Deletes all string attributes in the dataset. A deep copy of the attribute\n   * information is performed before an attribute is deleted.\n   *\n   * @throws IllegalArgumentException if string attribute couldn't be \n   * successfully deleted (probably because it is the class attribute).\n   * @see #deleteAttributeType(int)\n   */\n  public void deleteStringAttributes() {\n    deleteAttributeType(Attribute.STRING);\n  }\n\n  /**\n   * Removes all instances with missing values for a particular\n   * attribute from the dataset.\n   *\n   * @param attIndex the attribute's index (index starts with 0)\n   */\n  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();\n  public void deleteWithMissing(int attIndex) {\n\n    ArrayList\u003cInstance\u003e newInstances = new ArrayList\u003cInstance\u003e(numInstances());\n\n    for (int i = 0; i \u003c numInstances(); i++) {\n      if (!instance(i).isMissing(attIndex)) {\n\tnewInstances.add(instance(i));\n      }\n    }\n    m_Instances = newInstances;\n  }\n\n  /**\n   * Removes all instances with missing values for a particular\n   * attribute from the dataset.\n   *\n   * @param att the attribute\n   */\n  public void deleteWithMissing(/*@non_null@*/ Attribute att) {\n\n    deleteWithMissing(att.index());\n  }\n\n  /**\n   * Removes all instances with a missing class value\n   * from the dataset.\n   *\n   * @throws UnassignedClassException if class is not set\n   */\n  public void deleteWithMissingClass() {\n\n    if (m_ClassIndex \u003c 0) {\n      throw new UnassignedClassException(\"Class index is negative (not set)!\");\n    }\n    deleteWithMissing(m_ClassIndex);\n  }\n\n  /**\n   * Returns an enumeration of all the attributes.\n   *\n   * @return enumeration of all the attributes.\n   */\n  public /*@non_null pure@*/ Enumeration enumerateAttributes() {\n\n    return new WekaEnumeration(m_Attributes, m_ClassIndex);\n  }\n\n  /**\n   * Returns an enumeration of all instances in the dataset.\n   *\n   * @return enumeration of all instances in the dataset\n   */\n  public /*@non_null pure@*/ Enumeration enumerateInstances() {\n\n    return new WekaEnumeration(m_Instances);\n  }\n\n  /**\n   * Checks if two headers are equivalent. If not, then returns a message why\n   * they differ.\n   *\n   * @param dataset \tanother dataset\n   * @return \t\tnull if the header of the given dataset is equivalent \n   * \t\t\tto this header, otherwise a message with details on\n   * \t\t\twhy they differ\n   */\n  public String equalHeadersMsg(Instances dataset) {\n    // Check class and all attributes\n    if (m_ClassIndex != dataset.m_ClassIndex)\n      return \"Class index differ: \" + (m_ClassIndex+1) + \" != \" + (dataset.m_ClassIndex+1);\n\n    if (m_Attributes.size() != dataset.m_Attributes.size())\n      return \"Different number of attributes: \" + m_Attributes.size() + \" != \" + dataset.m_Attributes.size();\n    \n    for (int i = 0; i \u003c m_Attributes.size(); i++) {\n      String msg = attribute(i).equalsMsg(dataset.attribute(i));\n      if (msg != null)\n\treturn \"Attributes differ at position \" + (i+1) + \":\\n\" + msg;\n    }\n    \n    return null;\n  }\n\n  /**\n   * Checks if two headers are equivalent.\n   *\n   * @param dataset another dataset\n   * @return true if the header of the given dataset is equivalent \n   * to this header\n   */\n  public /*@pure@*/ boolean equalHeaders(Instances dataset){\n    return (equalHeadersMsg(dataset) == null);\n  }\n \n  /**\n   * Returns the first instance in the set.\n   *\n   * @return the first instance in the set\n   */\n  //@ requires numInstances() \u003e 0;\n  public /*@non_null pure@*/ Instance firstInstance() {\n    \n    return (Instance)m_Instances.get(0);\n  }\n\n  /**\n   * Returns a random number generator. The initial seed of the random\n   * number generator depends on the given seed and the hash code of\n   * a string representation of a instances chosen based on the given\n   * seed. \n   *\n   * @param seed the given seed\n   * @return the random number generator\n   */\n  public Random getRandomNumberGenerator(long seed) {\n\n    Random r = new Random(seed);\n    r.setSeed(instance(r.nextInt(numInstances())).toStringNoWeight().hashCode() + seed);\n    return r;\n  }\n \n  /**\n   * Inserts an attribute at the given position (0 to \n   * numAttributes()) and sets all values to be missing.\n   * Shallow copies the attribute before it is inserted, and performs\n   * a deep copy of the existing attribute information.\n   *\n   * @param att the attribute to be inserted\n   * @param position the attribute's position (position starts with 0)\n   * @throws IllegalArgumentException if the given index is out of range\n   */\n  //@ requires 0 \u003c= position;\n  //@ requires position \u003c= numAttributes();\n  public void insertAttributeAt(/*@non_null@*/ Attribute att, int position) {\n\t \n    if ((position \u003c 0) ||\n\t(position \u003e m_Attributes.size())) {\n      throw new IllegalArgumentException(\"Index out of range\");\n    }\n    if (attribute(att.name()) != null) {\n      throw new IllegalArgumentException(\n\t  \"Attribute name '\" + att.name() + \"' already in use at position #\" + attribute(att.name()).index());\n    }\n    att = (Attribute)att.copy();\n    freshAttributeInfo();\n    att.setIndex(position);\n    m_Attributes.add(position, att);\n    for (int i = position + 1; i \u003c m_Attributes.size(); i++) {\n      Attribute current = (Attribute)m_Attributes.get(i);\n      current.setIndex(current.index() + 1);\n    }\n    for (int i = 0; i \u003c numInstances(); i++) {\n      instance(i).setDataset(null);\n      instance(i).insertAttributeAt(position);\n      instance(i).setDataset(this);\n    }\n    if (m_ClassIndex \u003e= position) {\n      m_ClassIndex++;\n    }\n  }\n\n  /**\n   * Returns the instance at the given position.\n   *\n   * @param index the instance's index (index starts with 0)\n   * @return the instance at the given position\n   */\n  //@ requires 0 \u003c= index;\n  //@ requires index \u003c numInstances();\n  public /*@non_null pure@*/ Instance instance(int index) {\n\n    return m_Instances.get(index);\n  }\n\n  /**\n   * Returns the instance at the given position.\n   *\n   * @param index the instance's index (index starts with 0)\n   * @return the instance at the given position\n   */\n  //@ requires 0 \u003c= index;\n  //@ requires index \u003c numInstances();\n  public /*@non_null pure@*/ Instance get(int index) {\n\n    return m_Instances.get(index);\n  }\n\n  /**\n   * Returns the kth-smallest attribute value of a numeric attribute.\n   *\n   * @param att the Attribute object\n   * @param k the value of k\n   * @return the kth-smallest value\n   */\n  public double kthSmallestValue(Attribute att, int k) {\n\n    return kthSmallestValue(att.index(), k);\n  }\n\n  /**\n   * Returns the kth-smallest attribute value of a numeric attribute.\n   * NOTE CHANGE: Missing values (NaN values) are now treated as Double.MAX_VALUE.\n   * Also, the order of the instances in the data is no longer affected.\n   *\n   * @param attIndex the attribute's index\n   * @param k the value of k\n   * @return the kth-smallest value\n   */\n  public double kthSmallestValue(int attIndex, int k) {\n    \n    if (!attribute(attIndex).isNumeric()) {\n      throw new IllegalArgumentException(\"Instances: attribute must be numeric to compute kth-smallest value.\");\n    }\n \n    if ((k \u003c 1) || (k \u003e numInstances())) {\n      throw new IllegalArgumentException(\"Instances: value for k for computing kth-smallest value too large.\");\n    }\n    \n\n    double[] vals = new double[numInstances()];\n    for (int i = 0; i \u003c vals.length; i++) {\n      double val = instance(i).value(attIndex);\n      if (Utils.isMissingValue(val)) {\n        vals[i] = Double.MAX_VALUE;\n      } else {\n        vals[i] = val;\n      }\n    }\n    return Utils.kthSmallestValue(vals, k);\n  }\n\n  /**\n   * Returns the last instance in the set.\n   *\n   * @return the last instance in the set\n   */\n  //@ requires numInstances() \u003e 0;\n  public /*@non_null pure@*/ Instance lastInstance() {\n    \n    return (Instance)m_Instances.get(m_Instances.size() - 1);\n  }\n\n  /**\n   * Returns the mean (mode) for a numeric (nominal) attribute as\n   * a floating-point value. Returns 0 if the attribute is neither nominal nor \n   * numeric. If all values are missing it returns zero.\n   *\n   * @param attIndex the attribute's index (index starts with 0)\n   * @return the mean or the mode\n   */\n  public /*@pure@*/ double meanOrMode(int attIndex) {\n\n    double result, found;\n    int [] counts;\n\n    if (attribute(attIndex).isNumeric()) {\n      result = found = 0;\n      for (int j = 0; j \u003c numInstances(); j++) {\n\tif (!instance(j).isMissing(attIndex)) {\n\t  found += instance(j).weight();\n\t  result += instance(j).weight()*instance(j).value(attIndex);\n\t}\n      }\n      if (found \u003c= 0) {\n\treturn 0;\n      } else {\n\treturn result / found;\n      }\n    } else if (attribute(attIndex).isNominal()) {\n      counts = new int[attribute(attIndex).numValues()];\n      for (int j = 0; j \u003c numInstances(); j++) {\n\tif (!instance(j).isMissing(attIndex)) {\n\t  counts[(int) instance(j).value(attIndex)] += instance(j).weight();\n\t}\n      }\n      return (double)Utils.maxIndex(counts);\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n   * Returns the mean (mode) for a numeric (nominal) attribute as a\n   * floating-point value.  Returns 0 if the attribute is neither\n   * nominal nor numeric.  If all values are missing it returns zero.\n   *\n   * @param att the attribute\n   * @return the mean or the mode \n   */\n  public /*@pure@*/ double meanOrMode(Attribute att) {\n\n    return meanOrMode(att.index());\n  }\n\n  /**\n   * Returns the number of attributes.\n   *\n   * @return the number of attributes as an integer\n   */\n  //@ ensures \\result == m_Attributes.size();\n  public /*@pure@*/ int numAttributes() {\n\n    return m_Attributes.size();\n  }\n\n  /**\n   * Returns the number of class labels.\n   *\n   * @return the number of class labels as an integer if the class \n   * attribute is nominal, 1 otherwise.\n   * @throws UnassignedClassException if the class is not set\n   */\n  //@ requires classIndex() \u003e= 0;\n  public /*@pure@*/ int numClasses() {\n    \n    if (m_ClassIndex \u003c 0) {\n      throw new UnassignedClassException(\"Class index is negative (not set)!\");\n    }\n    if (!classAttribute().isNominal()) {\n      return 1;\n    } else {\n      return classAttribute().numValues();\n    }\n  }\n\n  /**\n   * Returns the number of distinct values of a given attribute.\n   * Returns the number of instances if the attribute is a\n   * string attribute. The value 'missing' is not counted.\n   *\n   * @param attIndex the attribute (index starts with 0)\n   * @return the number of distinct values of a given attribute\n   */\n  //@ requires 0 \u003c= attIndex;\n  //@ requires attIndex \u003c numAttributes();\n  public /*@pure@*/ int numDistinctValues(int attIndex) {\n\n    if (attribute(attIndex).isNumeric()) {\n      double [] attVals = attributeToDoubleArray(attIndex);\n      int [] sorted = Utils.sort(attVals);\n      double prev = 0;\n      int counter = 0;\n      for (int i = 0; i \u003c sorted.length; i++) {\n\tInstance current = instance(sorted[i]);\n\tif (current.isMissing(attIndex)) {\n\t  break;\n\t}\n\tif ((i == 0) || \n\t    (current.value(attIndex) \u003e prev)) {\n\t  prev = current.value(attIndex);\n\t  counter++;\n\t}\n      }\n      return counter;\n    } else {\n      return attribute(attIndex).numValues();\n    }\n  }\n\n  /**\n   * Returns the number of distinct values of a given attribute.\n   * Returns the number of instances if the attribute is a\n   * string attribute. The value 'missing' is not counted.\n   *\n   * @param att the attribute\n   * @return the number of distinct values of a given attribute\n   */\n  public /*@pure@*/ int numDistinctValues(/*@non_null@*/Attribute att) {\n\n    return numDistinctValues(att.index());\n  }\n  \n  /**\n   * Returns the number of instances in the dataset.\n   *\n   * @return the number of instances in the dataset as an integer\n   */\n  //@ ensures \\result == m_Instances.size();\n  public /*@pure@*/ int numInstances() {\n\n    return m_Instances.size();\n  }\n  \n  /**\n   * Returns the number of instances in the dataset.\n   *\n   * @return the number of instances in the dataset as an integer\n   */\n  //@ ensures \\result == m_Instances.size();\n  public /*@pure@*/ int size() {\n\n    return m_Instances.size();\n  }\n\n  /**\n   * Shuffles the instances in the set so that they are ordered \n   * randomly.\n   *\n   * @param random a random number generator\n   */\n  public void randomize(Random random) {\n\n    for (int j = numInstances() - 1; j \u003e 0; j--)\n      swap(j, random.nextInt(j+1));\n  }\n  \n  /**\n   * Reads a single instance from the reader and appends it\n   * to the dataset.  Automatically expands the dataset if it\n   * is not large enough to hold the instance. This method does\n   * not check for carriage return at the end of the line.\n   *\n   * @param reader the reader \n   * @return false if end of file has been reached\n   * @throws IOException if the information is not read \n   * successfully\n   * @deprecated instead of using this method in conjunction with the\n   * \u003ccode\u003ereadInstance(Reader)\u003c/code\u003e method, one should use the \n   * \u003ccode\u003eArffLoader\u003c/code\u003e or \u003ccode\u003eDataSource\u003c/code\u003e class instead.\n   * @see weka.core.converters.ArffLoader\n   * @see weka.core.converters.ConverterUtils.DataSource\n   */ \n  @Deprecated public boolean readInstance(Reader reader) throws IOException {\n\n    ArffReader arff = new ArffReader(reader, this, m_Lines, 1);\n    Instance inst = arff.readInstance(arff.getData(), false);\n    m_Lines = arff.getLineNo();\n    if (inst != null) {\n      add(inst);\n      return true;\n    }\n    else {\n      return false;\n    }\n  }    \n\n  /**\n   * Returns the relation's name.\n   *\n   * @return the relation's name as a string\n   */\n  //@ ensures \\result == m_RelationName;\n  public /*@pure@*/ String relationName() {\n\n    return m_RelationName;\n  }\n\n  /**\n   * Removes the instance at the given position.\n   *\n   * @param index the instance's index (index starts with 0)\n   * @return the instance at the given position\n   */\n  //@ requires 0 \u003c= index;\n  //@ requires index \u003c numInstances();\n  public Instance remove(int index) {\n\n    return m_Instances.remove(index);\n  }\n\n  /**\n   * Renames an attribute. This change only affects this\n   * dataset.\n   *\n   * @param att the attribute's index (index starts with 0)\n   * @param name the new name\n   */\n  public void renameAttribute(int att, String name) {\n    // name already present?\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      if (i == att)\n\tcontinue;\n      if (attribute(i).name().equals(name)) {\n\tthrow new IllegalArgumentException(\n\t    \"Attribute name '\" + name + \"' already present at position #\" + i);\n      }\n    }\n    \n    Attribute newAtt = attribute(att).copy(name);\n    ArrayList\u003cAttribute\u003e newVec = new ArrayList\u003cAttribute\u003e(numAttributes());\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      if (i == att) {\n\tnewVec.add(newAtt);\n      } else {\n\tnewVec.add(attribute(i));\n      }\n    }\n    m_Attributes = newVec;\n  }\n\n  /**\n   * Renames an attribute. This change only affects this\n   * dataset.\n   *\n   * @param att the attribute\n   * @param name the new name\n   */\n  public void renameAttribute(Attribute att, String name) {\n\n    renameAttribute(att.index(), name);\n  }\n\n  /**\n   * Renames the value of a nominal (or string) attribute value. This\n   * change only affects this dataset.\n   *\n   * @param att the attribute's index (index starts with 0)\n   * @param val the value's index (index starts with 0)\n   * @param name the new name \n   */\n  public void renameAttributeValue(int att, int val, String name) {\n\n    Attribute newAtt = (Attribute)attribute(att).copy();\n    ArrayList\u003cAttribute\u003e newVec = new ArrayList\u003cAttribute\u003e(numAttributes());\n\n    newAtt.setValue(val, name);\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      if (i == att) {\n\tnewVec.add(newAtt);\n      } else {\n\tnewVec.add(attribute(i));\n      }\n    }\n    m_Attributes = newVec;\n  }\n\n  /**\n   * Renames the value of a nominal (or string) attribute value. This\n   * change only affects this dataset.\n   *\n   * @param att the attribute\n   * @param val the value\n   * @param name the new name\n   */\n  public void renameAttributeValue(Attribute att, String val, \n                                         String name) {\n\n    int v = att.indexOfValue(val);\n    if (v == -1) throw new IllegalArgumentException(val + \" not found\");\n    renameAttributeValue(att.index(), v, name);\n  }\n\n  /**\n   * Creates a new dataset of the same size using random sampling\n   * with replacement.\n   *\n   * @param random a random number generator\n   * @return the new dataset\n   */\n  public Instances resample(Random random) {\n\n    Instances newData = new Instances(this, numInstances());\n    while (newData.numInstances() \u003c numInstances()) {\n      newData.add(instance(random.nextInt(numInstances())));\n    }\n    return newData;\n  }\n\n  /**\n   * Creates a new dataset of the same size using random sampling\n   * with replacement according to the current instance weights. The\n   * weights of the instances in the new dataset are set to one.\n   * See also resampleWithWeights(Random, double[], boolean[]).\n   *\n   * @param random a random number generator\n   * @return the new dataset\n   */\n  public Instances resampleWithWeights(Random random) {\n\n    double [] weights = new double[numInstances()];\n    for (int i = 0; i \u003c weights.length; i++) {\n      weights[i] = instance(i).weight();\n    }\n    return resampleWithWeights(random, weights, null);\n  }\n\n  /**\n   * Creates a new dataset of the same size using random sampling\n   * with replacement according to the current instance weights. The\n   * weights of the instances in the new dataset are set to one.\n   * See also resampleWithWeights(Random, double[], boolean[]).\n   *\n   * @param random a random number generator\n   * @param sampled an array indicating what has been sampled\n   * @return the new dataset\n   */\n  public Instances resampleWithWeights(Random random, boolean[] sampled) {\n\n    double [] weights = new double[numInstances()];\n    for (int i = 0; i \u003c weights.length; i++) {\n      weights[i] = instance(i).weight();\n    }\n    return resampleWithWeights(random, weights, sampled);\n  }\n\n  /**\n   * Creates a new dataset of the same size using random sampling\n   * with replacement according to the given weight vector.\n   * See also resampleWithWeights(Random, double[], boolean[]).\n   *\n   * @param random a random number generator\n   * @param weights the weight vector\n   * @return the new dataset\n   * @throws IllegalArgumentException if the weights array is of the wrong\n   * length or contains negative weights.\n   */\n  public Instances resampleWithWeights(Random random, double[] weights) {\n\n    return resampleWithWeights(random, weights, null);\n  }\n\n  /**\n   * Creates a new dataset of the same size using random sampling\n   * with replacement according to the given weight vector. The\n   * weights of the instances in the new dataset are set to one.\n   * The length of the weight vector has to be the same as the\n   * number of instances in the dataset, and all weights have to\n   * be positive. Uses Walker's method, see \n   * pp. 232 of \"Stochastic Simulation\" by B.D. Ripley (1987).\n   *\n   * @param random a random number generator\n   * @param weights the weight vector\n   * @param sampled an array indicating what has been sampled, can be null\n   * @return the new dataset\n   * @throws IllegalArgumentException if the weights array is of the wrong\n   * length or contains negative weights.\n   */\n  public Instances resampleWithWeights(Random random, double[] weights,\n                                       boolean[] sampled) {\n\n    if (weights.length != numInstances()) {\n      throw new IllegalArgumentException(\"weights.length != numInstances.\");\n    }\n\n    Instances newData = new Instances(this, numInstances());\n    if (numInstances() == 0) {\n      return newData;\n    }\n\n    // Walker's method, see pp. 232 of \"Stochastic Simulation\" by B.D. Ripley\n    double[] P = new double[weights.length];\n    System.arraycopy(weights, 0, P, 0, weights.length);\n    Utils.normalize(P);\n    double[] Q = new double[weights.length];\n    int[] A = new int[weights.length];\n    int[] W = new int[weights.length];\n    int M = weights.length;\n    int NN = -1;\n    int NP = M;\n    for (int I = 0; I \u003c M; I++) { \n      if (P[I] \u003c 0) {\n\tthrow new IllegalArgumentException(\"Weights have to be positive.\");\n      }\n      Q[I] = M * P[I]; \n      if (Q[I] \u003c 1.0) {\n        W[++NN] = I;\n      } else {\n        W[--NP] = I;\n      }\n    }\n    if (NN \u003e -1 \u0026\u0026 NP \u003c M) {\n      for (int S = 0; S \u003c M - 1; S++) {\n        int I = W[S];\n        int J = W[NP];\n        A[I] = J;\n        Q[J] += Q[I] - 1.0;\n        if (Q[J] \u003c 1.0) {\n          NP++;\n        }\n        if (NP \u003e= M) {\n          break;\n        }\n      }\n      //      A[W[M]] = W[M];\n    }\n\n    for (int I = 0; I \u003c M; I++) {\n      Q[I] += I;\n    }\n\n    for (int i = 0; i \u003c numInstances(); i++) {\n      int ALRV;\n      double U = M * random.nextDouble();\n      int I = (int)U;\n      if (U \u003c Q[I]) {\n        ALRV = I;\n      } else {\n        ALRV = A[I];\n      }\n      newData.add(instance(ALRV));\n      if (sampled != null) {\n        sampled[ALRV] = true;\n      }\n      newData.instance(newData.numInstances() - 1).setWeight(1);\n    }\n    \n    return newData;\n  }\n\n  /**\n   * Replaces the instance at the given position.\n   * Shallow copies instance before it is added. Does not\n   * check if the instance is compatible with the dataset.\n   * Note: String or relational values are not transferred.\n   *\n   * @param index position where instance is to be inserted\n   * @param instance the instance to be inserted\n   * @return the instance previously at that position\n   */\n  //@ requires 0 \u003c= index;\n  //@ requires index \u003c m_Instances.size();\n  public Instance set(int index, /*@non_null@*/ Instance instance) {\n\n    Instance newInstance = (Instance)instance.copy();\n    Instance oldInstance = m_Instances.get(index);\n\n    newInstance.setDataset(this);\n    m_Instances.set(index, newInstance);\n\n    return oldInstance;\n  }\n\n  /** \n   * Sets the class attribute.\n   *\n   * @param att attribute to be the class\n   */\n  public void setClass(Attribute att) {\n\n    m_ClassIndex = att.index();\n  }\n\n  /** \n   * Sets the class index of the set.\n   * If the class index is negative there is assumed to be no class.\n   * (ie. it is undefined)\n   *\n   * @param classIndex the new class index (index starts with 0)\n   * @throws IllegalArgumentException if the class index is too big or \u003c 0\n   */\n  public void setClassIndex(int classIndex) {\n\n    if (classIndex \u003e= numAttributes()) {\n      throw new IllegalArgumentException(\"Invalid class index: \" + classIndex);\n    }\n    m_ClassIndex = classIndex;\n  }\n\n  /**\n   * Sets the relation's name.\n   *\n   * @param newName the new relation name.\n   */\n  public void setRelationName(/*@non_null@*/String newName) {\n    \n    m_RelationName = newName;\n  }\n\n  /**\n   * Sorts the instances based on an attribute. For numeric attributes, \n   * instances are sorted in ascending order. For nominal attributes, \n   * instances are sorted based on the attribute label ordering \n   * specified in the header. Instances with missing values for the \n   * attribute are placed at the end of the dataset.\n   *\n   * @param attIndex the attribute's index (index starts with 0)\n   */\n  public void sort(int attIndex) {\n\n    double[] vals = new double[numInstances()];\n    for (int i = 0; i \u003c vals.length; i++) {\n      double val = instance(i).value(attIndex);\n      if (Utils.isMissingValue(val)) {\n        vals[i] = Double.MAX_VALUE;\n      } else {\n        vals[i] = val;\n      }\n    }\n    \n    int[] sortOrder = Utils.sortWithNoMissingValues(vals);\n    Instance[] backup = new Instance[vals.length];\n    for (int i = 0; i \u003c vals.length; i++) {\n      backup[i] = instance(i);\n    }\n    for (int i = 0; i \u003c vals.length; i++) {\n      m_Instances.set(i, backup[sortOrder[i]]);\n    }\n  }\n\n  /**\n   * Sorts the instances based on an attribute. For numeric attributes, \n   * instances are sorted into ascending order. For nominal attributes, \n   * instances are sorted based on the attribute label ordering \n   * specified in the header. Instances with missing values for the \n   * attribute are placed at the end of the dataset.\n   *\n   * @param att the attribute\n   */\n  public void sort(Attribute att) {\n\n    sort(att.index());\n  }\n\n  /**\n   * Stratifies a set of instances according to its class values \n   * if the class attribute is nominal (so that afterwards a \n   * stratified cross-validation can be performed).\n   *\n   * @param numFolds the number of folds in the cross-validation\n   * @throws UnassignedClassException if the class is not set\n   */\n  public void stratify(int numFolds) {\n    \n    if (numFolds \u003c= 1) {\n      throw new IllegalArgumentException(\"Number of folds must be greater than 1\");\n    }\n    if (m_ClassIndex \u003c 0) {\n      throw new UnassignedClassException(\"Class index is negative (not set)!\");\n    }\n    if (classAttribute().isNominal()) {\n\n      // sort by class\n      int index = 1;\n      while (index \u003c numInstances()) {\n\tInstance instance1 = instance(index - 1);\n\tfor (int j = index; j \u003c numInstances(); j++) {\n\t  Instance instance2 = instance(j);\n\t  if ((instance1.classValue() == instance2.classValue()) ||\n\t      (instance1.classIsMissing() \u0026\u0026 \n\t       instance2.classIsMissing())) {\n\t    swap(index,j);\n\t    index++;\n\t  }\n\t}\n\tindex++;\n      }\n      stratStep(numFolds);\n    }\n  }\n \n  /**\n   * Computes the sum of all the instances' weights.\n   *\n   * @return the sum of all the instances' weights as a double\n   */\n  public /*@pure@*/ double sumOfWeights() {\n    \n    double sum = 0;\n\n    for (int i = 0; i \u003c numInstances(); i++) {\n      sum += instance(i).weight();\n    }\n    return sum;\n  }\n\n  /**\n   * Creates the test set for one fold of a cross-validation on \n   * the dataset.\n   *\n   * @param numFolds the number of folds in the cross-validation. Must\n   * be greater than 1.\n   * @param numFold 0 for the first fold, 1 for the second, ...\n   * @return the test set as a set of weighted instances\n   * @throws IllegalArgumentException if the number of folds is less than 2\n   * or greater than the number of instances.\n   */\n  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\n  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\n  public Instances testCV(int numFolds, int numFold) {\n\n    int numInstForFold, first, offset;\n    Instances test;\n    \n    if (numFolds \u003c 2) {\n      throw new IllegalArgumentException(\"Number of folds must be at least 2!\");\n    }\n    if (numFolds \u003e numInstances()) {\n      throw new IllegalArgumentException(\"Can't have more folds than instances!\");\n    }\n    numInstForFold = numInstances() / numFolds;\n    if (numFold \u003c numInstances() % numFolds){\n      numInstForFold++;\n      offset = numFold;\n    }else\n      offset = numInstances() % numFolds;\n    test = new Instances(this, numInstForFold);\n    first = numFold * (numInstances() / numFolds) + offset;\n    copyInstances(first, test, numInstForFold);\n    return test;\n  }\n \n  /**\n   * Returns the dataset as a string in ARFF format. Strings\n   * are quoted if they contain whitespace characters, or if they\n   * are a question mark.\n   *\n   * @return the dataset in ARFF format as a string\n   */\n  public String toString() {\n    \n    StringBuffer text = new StringBuffer();\n    \n    text.append(ARFF_RELATION).append(\" \").\n      append(Utils.quote(m_RelationName)).append(\"\\n\\n\");\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      text.append(attribute(i)).append(\"\\n\");\n    }\n    text.append(\"\\n\").append(ARFF_DATA).append(\"\\n\");\n\n    text.append(stringWithoutHeader());\n    return text.toString();\n  }\n\n  /**\n   * Returns the instances in the dataset as a string in ARFF format. Strings\n   * are quoted if they contain whitespace characters, or if they\n   * are a question mark.\n   *\n   * @return the dataset in ARFF format as a string\n   */\n  protected String stringWithoutHeader() {\n    \n    StringBuffer text = new StringBuffer();\n\n    for (int i = 0; i \u003c numInstances(); i++) {\n      text.append(instance(i));\n      if (i \u003c numInstances() - 1) {\n\ttext.append('\\n');\n      }\n    }\n    return text.toString();\n  }\n\n  /**\n   * Creates the training set for one fold of a cross-validation \n   * on the dataset. \n   *\n   * @param numFolds the number of folds in the cross-validation. Must\n   * be greater than 1.\n   * @param numFold 0 for the first fold, 1 for the second, ...\n   * @return the training set \n   * @throws IllegalArgumentException if the number of folds is less than 2\n   * or greater than the number of instances.\n   */\n  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\n  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\n  public Instances trainCV(int numFolds, int numFold) {\n\n    int numInstForFold, first, offset;\n    Instances train;\n \n    if (numFolds \u003c 2) {\n      throw new IllegalArgumentException(\"Number of folds must be at least 2!\");\n    }\n    if (numFolds \u003e numInstances()) {\n      throw new IllegalArgumentException(\"Can't have more folds than instances!\");\n    }\n    numInstForFold = numInstances() / numFolds;\n    if (numFold \u003c numInstances() % numFolds) {\n      numInstForFold++;\n      offset = numFold;\n    }else\n      offset = numInstances() % numFolds;\n    train = new Instances(this, numInstances() - numInstForFold);\n    first = numFold * (numInstances() / numFolds) + offset;\n    copyInstances(0, train, first);\n    copyInstances(first + numInstForFold, train,\n\t\t  numInstances() - first - numInstForFold);\n\n    return train;\n  }\n\n  /**\n   * Creates the training set for one fold of a cross-validation \n   * on the dataset. The data is subsequently randomized based\n   * on the given random number generator.\n   *\n   * @param numFolds the number of folds in the cross-validation. Must\n   * be greater than 1.\n   * @param numFold 0 for the first fold, 1 for the second, ...\n   * @param random the random number generator\n   * @return the training set \n   * @throws IllegalArgumentException if the number of folds is less than 2\n   * or greater than the number of instances.\n   */\n  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();\n  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;\n  public Instances trainCV(int numFolds, int numFold, Random random) {\n\n    Instances train = trainCV(numFolds, numFold);\n    train.randomize(random);\n    return train;\n  }\n\n  /**\n   * Computes the variance for a numeric attribute.\n   *\n   * @param attIndex the numeric attribute (index starts with 0)\n   * @return the variance if the attribute is numeric\n   * @throws IllegalArgumentException if the attribute is not numeric\n   */\n  public /*@pure@*/ double variance(int attIndex) {\n  \n    double sum = 0, sumSquared = 0, sumOfWeights = 0;\n\n    if (!attribute(attIndex).isNumeric()) {\n      throw new IllegalArgumentException(\"Can't compute variance because attribute is \" +\n\t\t\t  \"not numeric!\");\n    }\n    for (int i = 0; i \u003c numInstances(); i++) {\n      if (!instance(i).isMissing(attIndex)) {\n\tsum += instance(i).weight() * \n\t  instance(i).value(attIndex);\n\tsumSquared += instance(i).weight() * \n\t  instance(i).value(attIndex) *\n\t  instance(i).value(attIndex);\n\tsumOfWeights += instance(i).weight();\n      }\n    }\n    if (sumOfWeights \u003c= 1) {\n      return 0;\n    }\n    double result = (sumSquared - (sum * sum / sumOfWeights)) / \n      (sumOfWeights - 1);\n\n    // We don't like negative variance\n    if (result \u003c 0) {\n      return 0;\n    } else {\n      return result;\n    }\n  }\n\n  /**\n   * Computes the variance for a numeric attribute.\n   *\n   * @param att the numeric attribute\n   * @return the variance if the attribute is numeric\n   * @throws IllegalArgumentException if the attribute is not numeric\n   */\n  public /*@pure@*/ double variance(Attribute att) {\n    \n    return variance(att.index());\n  }\n  \n  /**\n   * Calculates summary statistics on the values that appear in this\n   * set of instances for a specified attribute.\n   *\n   * @param index the index of the attribute to summarize (index starts with 0)\n   * @return an AttributeStats object with it's fields calculated.\n   */\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numAttributes();\n  public AttributeStats attributeStats(int index) {\n\n    AttributeStats result = new AttributeStats();\n    if (attribute(index).isNominal()) {\n      result.nominalCounts = new int [attribute(index).numValues()];\n      result.nominalWeights = new double[attribute(index).numValues()];\n    }\n    if (attribute(index).isNumeric()) {\n      result.numericStats = new weka.experiment.Stats();\n    }\n    result.totalCount = numInstances();\n\n    double [] attVals = attributeToDoubleArray(index);\n    int [] sorted = Utils.sort(attVals);\n    int currentCount = 0;\n    double currentWeight = 0;\n    double prev = Double.NaN;\n    for (int j = 0; j \u003c numInstances(); j++) {\n      Instance current = instance(sorted[j]);\n      if (current.isMissing(index)) {\n\tresult.missingCount = numInstances() - j;\n\tbreak;\n      }\n      if (current.value(index) == prev) {\n\tcurrentCount++;\n\tcurrentWeight += current.weight();\n      } else {\n\tresult.addDistinct(prev, currentCount, currentWeight);\n\tcurrentCount = 1;\n\tcurrentWeight = current.weight();\n\tprev = current.value(index);\n      }\n    }\n    result.addDistinct(prev, currentCount, currentWeight);\n    result.distinctCount--; // So we don't count \"missing\" as a value \n    return result;\n  }\n  \n  /**\n   * Gets the value of all instances in this dataset for a particular\n   * attribute. Useful in conjunction with Utils.sort to allow iterating\n   * through the dataset in sorted order for some attribute.\n   *\n   * @param index the index of the attribute.\n   * @return an array containing the value of the desired attribute for\n   * each instance in the dataset. \n   */\n  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numAttributes();\n  public /*@pure@*/ double [] attributeToDoubleArray(int index) {\n\n    double [] result = new double[numInstances()];\n    for (int i = 0; i \u003c result.length; i++) {\n      result[i] = instance(i).value(index);\n    }\n    return result;\n  }\n\n  /**\n   * Generates a string summarizing the set of instances. Gives a breakdown\n   * for each attribute indicating the number of missing/discrete/unique\n   * values and other information.\n   *\n   * @return a string summarizing the dataset\n   */\n  public String toSummaryString() {\n\n    StringBuffer result = new StringBuffer();\n    result.append(\"Relation Name:  \").append(relationName()).append('\\n');\n    result.append(\"Num Instances:  \").append(numInstances()).append('\\n');\n    result.append(\"Num Attributes: \").append(numAttributes()).append('\\n');\n    result.append('\\n');\n\n    result.append(Utils.padLeft(\"\", 5)).append(Utils.padRight(\"Name\", 25));\n    result.append(Utils.padLeft(\"Type\", 5)).append(Utils.padLeft(\"Nom\", 5));\n    result.append(Utils.padLeft(\"Int\", 5)).append(Utils.padLeft(\"Real\", 5));\n    result.append(Utils.padLeft(\"Missing\", 12));\n    result.append(Utils.padLeft(\"Unique\", 12));\n    result.append(Utils.padLeft(\"Dist\", 6)).append('\\n');\n    for (int i = 0; i \u003c numAttributes(); i++) {\n      Attribute a = attribute(i);\n      AttributeStats as = attributeStats(i);\n      result.append(Utils.padLeft(\"\" + (i + 1), 4)).append(' ');\n      result.append(Utils.padRight(a.name(), 25)).append(' ');\n      long percent;\n      switch (a.type()) {\n      case Attribute.NOMINAL:\n\tresult.append(Utils.padLeft(\"Nom\", 4)).append(' ');\n\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tbreak;\n      case Attribute.NUMERIC:\n\tresult.append(Utils.padLeft(\"Num\", 4)).append(' ');\n\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tbreak;\n      case Attribute.DATE:\n\tresult.append(Utils.padLeft(\"Dat\", 4)).append(' ');\n\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tbreak;\n      case Attribute.STRING:\n\tresult.append(Utils.padLeft(\"Str\", 4)).append(' ');\n\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tbreak;\n      case Attribute.RELATIONAL:\n\tresult.append(Utils.padLeft(\"Rel\", 4)).append(' ');\n\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tbreak;\n      default:\n\tresult.append(Utils.padLeft(\"???\", 4)).append(' ');\n\tresult.append(Utils.padLeft(\"\" + 0, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.intCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tpercent = Math.round(100.0 * as.realCount / as.totalCount);\n\tresult.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n\tbreak;\n      }\n      result.append(Utils.padLeft(\"\" + as.missingCount, 5)).append(\" /\");\n      percent = Math.round(100.0 * as.missingCount / as.totalCount);\n      result.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n      result.append(Utils.padLeft(\"\" + as.uniqueCount, 5)).append(\" /\");\n      percent = Math.round(100.0 * as.uniqueCount / as.totalCount);\n      result.append(Utils.padLeft(\"\" + percent, 3)).append(\"% \");\n      result.append(Utils.padLeft(\"\" + as.distinctCount, 5)).append(' ');\n      result.append('\\n');\n    }\n    return result.toString();\n  }\n\n  /**\n   * Copies instances from one set to the end of another \n   * one.\n   *\n   * @param from the position of the first instance to be copied\n   * @param dest the destination for the instances\n   * @param num the number of instances to be copied\n   */\n  //@ requires 0 \u003c= from \u0026\u0026 from \u003c= numInstances() - num;\n  //@ requires 0 \u003c= num;\n  protected void copyInstances(int from, /*@non_null@*/ Instances dest, int num) {\n    \n    for (int i = 0; i \u003c num; i++) {\n      dest.add(instance(from + i));\n    }\n  }\n  \n  /**\n   * Replaces the attribute information by a clone of\n   * itself.\n   */\n  protected void freshAttributeInfo() {\n\n    ArrayList\u003cAttribute\u003e newList = new ArrayList\u003cAttribute\u003e(m_Attributes.size());\n    for (Attribute att : m_Attributes) {\n      newList.add((Attribute)att.copy());\n    }\n    m_Attributes = newList;\n  }\n \n  /**\n   * Returns string including all instances, their weights and\n   * their indices in the original dataset.\n   *\n   * @return description of instance and its weight as a string\n   */\n  protected /*@pure@*/ String instancesAndWeights(){\n\n    StringBuffer text = new StringBuffer();\n\n    for (int i = 0; i \u003c numInstances(); i++) {\n      text.append(instance(i) + \" \" + instance(i).weight());\n      if (i \u003c numInstances() - 1) {\n\ttext.append(\"\\n\");\n      }\n    }\n    return text.toString();\n  }\n\n  /**\n   * Help function needed for stratification of set.\n   *\n   * @param numFolds the number of folds for the stratification\n   */\n  protected void stratStep (int numFolds){\n    \n    ArrayList\u003cInstance\u003e newVec = new ArrayList\u003cInstance\u003e(m_Instances.size());\n    int start = 0, j;\n\n    // create stratified batch\n    while (newVec.size() \u003c numInstances()) {\n      j = start;\n      while (j \u003c numInstances()) {\n\tnewVec.add(instance(j));\n\tj = j + numFolds;\n      }\n      start++;\n    }\n    m_Instances = newVec;\n  }\n  \n  /**\n   * Swaps two instances in the set.\n   *\n   * @param i the first instance's index (index starts with 0)\n   * @param j the second instance's index (index starts with 0)\n   */\n  //@ requires 0 \u003c= i \u0026\u0026 i \u003c numInstances();\n  //@ requires 0 \u003c= j \u0026\u0026 j \u003c numInstances();\n  public void swap(int i, int j){\n    \n    Instance in = m_Instances.get(i);\n    m_Instances.set(i, m_Instances.get(j));\n    m_Instances.set(j, in);\n  }\n\n  /**\n   * Merges two sets of Instances together. The resulting set will have\n   * all the attributes of the first set plus all the attributes of the \n   * second set. The number of instances in both sets must be the same.\n   *\n   * @param first the first set of Instances\n   * @param second the second set of Instances\n   * @return the merged set of Instances\n   * @throws IllegalArgumentException if the datasets are not the same size\n   */\n  public static Instances mergeInstances(Instances first, Instances second) {\n\n    if (first.numInstances() != second.numInstances()) {\n      throw new IllegalArgumentException(\"Instance sets must be of the same size\");\n    }\n\n    // Create the vector of merged attributes\n    ArrayList\u003cAttribute\u003e newAttributes = new ArrayList\u003cAttribute\u003e();\n    for (int i = 0; i \u003c first.numAttributes(); i++) {\n      newAttributes.add(first.attribute(i));\n    }\n    for (int i = 0; i \u003c second.numAttributes(); i++) {\n      newAttributes.add(second.attribute(i));\n    }\n    \n    // Create the set of Instances\n    Instances merged = new Instances(first.relationName() + '_'\n\t\t\t\t     + second.relationName(), \n\t\t\t\t     newAttributes, \n\t\t\t\t     first.numInstances());\n    // Merge each instance\n    for (int i = 0; i \u003c first.numInstances(); i++) {\n      merged.add(first.instance(i).mergeInstance(second.instance(i)));\n    }\n    return merged;\n  }\n\n  /**\n   * Method for testing this class.\n   *\n   * @param argv should contain one element: the name of an ARFF file\n   */\n  //@ requires argv != null;\n  //@ requires argv.length == 1;\n  //@ requires argv[0] != null;\n  public static void test(String [] argv) {\n\n    Instances instances, secondInstances, train, test, empty;\n    Random random = new Random(2);\n    Reader reader;\n    int start, num;\n    ArrayList\u003cAttribute\u003e testAtts;\n    ArrayList\u003cString\u003e testVals;\n    int i,j;\n    \n    try{\n      if (argv.length \u003e 1) {\n\tthrow (new Exception(\"Usage: Instances [\u003cfilename\u003e]\"));\n      }\n      \n      // Creating set of instances from scratch\n      testVals = new ArrayList\u003cString\u003e(2);\n      testVals.add(\"first_value\");\n      testVals.add(\"second_value\");\n      testAtts = new ArrayList\u003cAttribute\u003e(2);\n      testAtts.add(new Attribute(\"nominal_attribute\", testVals));\n      testAtts.add(new Attribute(\"numeric_attribute\"));\n      instances = new Instances(\"test_set\", testAtts, 10);\n      instances.add(new DenseInstance(instances.numAttributes()));\n      instances.add(new DenseInstance(instances.numAttributes()));\n      instances.add(new DenseInstance(instances.numAttributes()));\n      instances.setClassIndex(0);\n      System.out.println(\"\\nSet of instances created from scratch:\\n\");\n      System.out.println(instances);\n      \n      if (argv.length == 1) {\n\tString filename = argv[0];\n\treader = new FileReader(filename);\n\t\n\t// Read first five instances and print them\n\tSystem.out.println(\"\\nFirst five instances from file:\\n\");\n\tinstances = new Instances(reader, 1);\n\tinstances.setClassIndex(instances.numAttributes() - 1);\n\ti = 0;\n\twhile ((i \u003c 5) \u0026\u0026 (instances.readInstance(reader))) {\n\t  i++;\n\t}\n\tSystem.out.println(instances);\n\n\t// Read all the instances in the file\n\treader = new FileReader(filename);\n\tinstances = new Instances(reader);\n\n\t// Make the last attribute be the class \n\tinstances.setClassIndex(instances.numAttributes() - 1);\n\t\n\t// Print header and instances.\n\tSystem.out.println(\"\\nDataset:\\n\");\n\tSystem.out.println(instances);\n\tSystem.out.println(\"\\nClass index: \"+instances.classIndex());\n      }\n      \n      // Test basic methods based on class index.\n      System.out.println(\"\\nClass name: \"+instances.classAttribute().name());\n      System.out.println(\"\\nClass index: \"+instances.classIndex());\n      System.out.println(\"\\nClass is nominal: \" +\n\t\t\t instances.classAttribute().isNominal());\n      System.out.println(\"\\nClass is numeric: \" +\n\t\t\t instances.classAttribute().isNumeric());\n      System.out.println(\"\\nClasses:\\n\");\n      for (i = 0; i \u003c instances.numClasses(); i++) {\n\tSystem.out.println(instances.classAttribute().value(i));\n      }\n      System.out.println(\"\\nClass values and labels of instances:\\n\");\n      for (i = 0; i \u003c instances.numInstances(); i++) {\n\tInstance inst = instances.instance(i);\n\tSystem.out.print(inst.classValue() + \"\\t\");\n\tSystem.out.print(inst.toString(inst.classIndex()));\n\tif (instances.instance(i).classIsMissing()) {\n\t  System.out.println(\"\\tis missing\");\n\t} else {\n\t  System.out.println();\n\t}\n      }\n      \n      // Create random weights.\n      System.out.println(\"\\nCreating random weights for instances.\");\n      for (i = 0; i \u003c instances.numInstances(); i++) {\n\tinstances.instance(i).setWeight(random.nextDouble()); \n      }\n      \n      // Print all instances and their weights (and the sum of weights).\n      System.out.println(\"\\nInstances and their weights:\\n\");\n      System.out.println(instances.instancesAndWeights());\n      System.out.print(\"\\nSum of weights: \");\n      System.out.println(instances.sumOfWeights());\n      \n      // Insert an attribute\n      secondInstances = new Instances(instances);\n      Attribute testAtt = new Attribute(\"Inserted\");\n      secondInstances.insertAttributeAt(testAtt, 0);\n      System.out.println(\"\\nSet with inserted attribute:\\n\");\n      System.out.println(secondInstances);\n      System.out.println(\"\\nClass name: \"\n\t\t\t + secondInstances.classAttribute().name());\n      \n      // Delete the attribute\n      secondInstances.deleteAttributeAt(0);\n      System.out.println(\"\\nSet with attribute deleted:\\n\");\n      System.out.println(secondInstances);\n      System.out.println(\"\\nClass name: \"\n\t\t\t + secondInstances.classAttribute().name());\n      \n      // Test if headers are equal\n      System.out.println(\"\\nHeaders equal: \"+\n\t\t\t instances.equalHeaders(secondInstances) + \"\\n\");\n      \n      // Print data in internal format.\n      System.out.println(\"\\nData (internal values):\\n\");\n      for (i = 0; i \u003c instances.numInstances(); i++) {\n\tfor (j = 0; j \u003c instances.numAttributes(); j++) {\n\t  if (instances.instance(i).isMissing(j)) {\n\t    System.out.print(\"? \");\n\t  } else {\n\t    System.out.print(instances.instance(i).value(j) + \" \");\n\t  }\n\t}\n\tSystem.out.println();\n      }\n      \n      // Just print header\n      System.out.println(\"\\nEmpty dataset:\\n\");\n      empty = new Instances(instances, 0);\n      System.out.println(empty);\n      System.out.println(\"\\nClass name: \"+empty.classAttribute().name());\n\n      // Create copy and rename an attribute and a value (if possible)\n      if (empty.classAttribute().isNominal()) {\n\tInstances copy = new Instances(empty, 0);\n\tcopy.renameAttribute(copy.classAttribute(), \"new_name\");\n\tcopy.renameAttributeValue(copy.classAttribute(), \n\t\t\t\t  copy.classAttribute().value(0), \n\t\t\t\t  \"new_val_name\");\n\tSystem.out.println(\"\\nDataset with names changed:\\n\" + copy);\n\tSystem.out.println(\"\\nOriginal dataset:\\n\" + empty);\n      }\n\n      // Create and prints subset of instances.\n      start = instances.numInstances() / 4;\n      num = instances.numInstances() / 2;\n      System.out.print(\"\\nSubset of dataset: \");\n      System.out.println(num + \" instances from \" + (start + 1) \n\t\t\t + \". instance\");\n      secondInstances = new Instances(instances, start, num);\n      System.out.println(\"\\nClass name: \"\n\t\t\t + secondInstances.classAttribute().name());\n\n      // Print all instances and their weights (and the sum of weights).\n      System.out.println(\"\\nInstances and their weights:\\n\");\n      System.out.println(secondInstances.instancesAndWeights());\n      System.out.print(\"\\nSum of weights: \");\n      System.out.println(secondInstances.sumOfWeights());\n      \n      // Create and print training and test sets for 3-fold\n      // cross-validation.\n      System.out.println(\"\\nTrain and test folds for 3-fold CV:\");\n      if (instances.classAttribute().isNominal()) {\n\tinstances.stratify(3);\n      }\n      for (j = 0; j \u003c 3; j++) {\n        train = instances.trainCV(3,j, new Random(1));\n\ttest = instances.testCV(3,j);\n                      \n\t// Print all instances and their weights (and the sum of weights).\n\tSystem.out.println(\"\\nTrain: \");\n\tSystem.out.println(\"\\nInstances and their weights:\\n\");\n\tSystem.out.println(train.instancesAndWeights());\n\tSystem.out.print(\"\\nSum of weights: \");\n\tSystem.out.println(train.sumOfWeights());\n\tSystem.out.println(\"\\nClass name: \"+train.classAttribute().name());\n\tSystem.out.println(\"\\nTest: \");\n\tSystem.out.println(\"\\nInstances and their weights:\\n\");\n\tSystem.out.println(test.instancesAndWeights());\n\tSystem.out.print(\"\\nSum of weights: \");\n\tSystem.out.println(test.sumOfWeights());\n\tSystem.out.println(\"\\nClass name: \"+test.classAttribute().name());\n      }\n\n      // Randomize instances and print them.\n      System.out.println(\"\\nRandomized dataset:\");\n      instances.randomize(random);\n      \n      // Print all instances and their weights (and the sum of weights).\n      System.out.println(\"\\nInstances and their weights:\\n\");\n      System.out.println(instances.instancesAndWeights());\n      System.out.print(\"\\nSum of weights: \");\n      System.out.println(instances.sumOfWeights());\n\n      // Sort instances according to first attribute and\n      // print them.\n      System.out.print(\"\\nInstances sorted according to first attribute:\\n \");\n      instances.sort(0);\n        \n      // Print all instances and their weights (and the sum of weights).\n      System.out.println(\"\\nInstances and their weights:\\n\");\n      System.out.println(instances.instancesAndWeights());\n      System.out.print(\"\\nSum of weights: \");\n      System.out.println(instances.sumOfWeights());\n    } catch (Exception e) {\n      e.printStackTrace(); \n    }\n  }\n\n  /**\n   * Main method for this class. The following calls are possible:\n   * \u003cul\u003e\n   *   \u003cli\u003e\n   *     \u003ccode\u003eweka.core.Instances\u003c/code\u003e help\u003cbr/\u003e\n   *     prints a short list of possible commands.\n   *   \u003c/li\u003e\n   *   \u003cli\u003e\n   *     \u003ccode\u003eweka.core.Instances\u003c/code\u003e \u0026lt;filename\u0026gt;\u003cbr/\u003e\n   *     prints a summary of a set of instances.\n   *   \u003c/li\u003e\n   *   \u003cli\u003e\n   *     \u003ccode\u003eweka.core.Instances\u003c/code\u003e merge \u0026lt;filename1\u0026gt; \u0026lt;filename2\u0026gt;\u003cbr/\u003e\n   *     merges the two datasets (must have same number of instances) and\n   *     outputs the results on stdout.\n   *   \u003c/li\u003e\n   *   \u003cli\u003e\n   *     \u003ccode\u003eweka.core.Instances\u003c/code\u003e append \u0026lt;filename1\u0026gt; \u0026lt;filename2\u0026gt;\u003cbr/\u003e\n   *     appends the second dataset to the first one (must have same headers) and\n   *     outputs the results on stdout.\n   *   \u003c/li\u003e\n   *   \u003cli\u003e\n   *     \u003ccode\u003eweka.core.Instances\u003c/code\u003e headers \u0026lt;filename1\u0026gt; \u0026lt;filename2\u0026gt;\u003cbr/\u003e\n   *     Compares the headers of the two datasets and prints whether they match\n   *     or not.\n   *   \u003c/li\u003e\n   *   \u003cli\u003e\n   *     \u003ccode\u003eweka.core.Instances\u003c/code\u003e randomize \u0026lt;seed\u0026gt; \u0026lt;filename\u0026gt;\u003cbr/\u003e\n   *     randomizes the dataset with the given seed and outputs the result on stdout.\n   *   \u003c/li\u003e\n   * \u003c/ul\u003e\n   *\n   * @param args \tthe commandline parameters\n   */\n  public static void main(String[] args) {\n\n    try {\n      Instances i;\n      // read from stdin and print statistics\n      if (args.length == 0) {\n\tDataSource source = new DataSource(System.in);\n\ti = source.getDataSet();\n\tSystem.out.println(i.toSummaryString());\n      }\n      // read file and print statistics\n      else if ((args.length == 1) \u0026\u0026 (!args[0].equals(\"-h\")) \u0026\u0026 (!args[0].equals(\"help\"))) {\n\tDataSource source = new DataSource(args[0]);\n\ti = source.getDataSet();\n\tSystem.out.println(i.toSummaryString());\n      }\n      // read two files, merge them and print result to stdout\n      else if ((args.length == 3) \u0026\u0026 (args[0].toLowerCase().equals(\"merge\"))) {\n\tDataSource source1 = new DataSource(args[1]);\n\tDataSource source2 = new DataSource(args[2]);\n\ti = Instances.mergeInstances(source1.getDataSet(), source2.getDataSet());\n\tSystem.out.println(i);\n      }\n      // read two files, append them and print result to stdout\n      else if ((args.length == 3) \u0026\u0026 (args[0].toLowerCase().equals(\"append\"))) {\n\tDataSource source1 = new DataSource(args[1]);\n\tDataSource source2 = new DataSource(args[2]);\n\tString msg = source1.getStructure().equalHeadersMsg(source2.getStructure());\n\tif (msg != null)\n\t  throw new Exception(\"The two datasets have different headers:\\n\" + msg);\n\tInstances structure = source1.getStructure();\n\tSystem.out.println(source1.getStructure());\n\twhile (source1.hasMoreElements(structure))\n\t  System.out.println(source1.nextElement(structure));\n\tstructure = source2.getStructure();\n\twhile (source2.hasMoreElements(structure))\n\t  System.out.println(source2.nextElement(structure));\n      }\n      // read two files and compare their headers\n      else if ((args.length == 3) \u0026\u0026 (args[0].toLowerCase().equals(\"headers\"))) {\n\tDataSource source1 = new DataSource(args[1]);\n\tDataSource source2 = new DataSource(args[2]);\n\tString msg = source1.getStructure().equalHeadersMsg(source2.getStructure());\n\tif (msg == null)\n\t  System.out.println(\"Headers match\");\n\telse\n\t  System.out.println(\"Headers don't match:\\n\" + msg);\n      }\n      // read file and seed value, randomize data and print result to stdout\n      else if ((args.length == 3) \u0026\u0026 (args[0].toLowerCase().equals(\"randomize\"))) {\n\tDataSource source = new DataSource(args[2]);\n\ti = source.getDataSet();\n\ti.randomize(new Random(Integer.parseInt(args[1])));\n\tSystem.out.println(i);\n      }\n      // wrong parameters or help\n      else {\n\tSystem.err.println(\n\t    \"\\nUsage:\\n\"\n\t    // help\n\t    + \"\\tweka.core.Instances help\\n\"\n\t    + \"\\t\\tPrints this help\\n\"\n\t    // stats\n\t    + \"\\tweka.core.Instances \u003cfilename\u003e\\n\"\n\t    + \"\\t\\tOutputs dataset statistics\\n\"\n\t    // merge\n\t    + \"\\tweka.core.Instances merge \u003cfilename1\u003e \u003cfilename2\u003e\\n\"\n\t    + \"\\t\\tMerges the datasets (must have same number of rows).\\n\"\n\t    + \"\\t\\tGenerated dataset gets output on stdout.\\n\"\n\t    // append\n\t    + \"\\tweka.core.Instances append \u003cfilename1\u003e \u003cfilename2\u003e\\n\"\n\t    + \"\\t\\tAppends the second dataset to the first (must have same number of attributes).\\n\"\n\t    + \"\\t\\tGenerated dataset gets output on stdout.\\n\"\n\t    // headers\n\t    + \"\\tweka.core.Instances headers \u003cfilename1\u003e \u003cfilename2\u003e\\n\"\n\t    + \"\\t\\tCompares the structure of the two datasets and outputs whether they\\n\"\n\t    + \"\\t\\tdiffer or not.\\n\"\n\t    // randomize\n\t    + \"\\tweka.core.Instances randomize \u003cseed\u003e \u003cfilename\u003e\\n\"\n\t    + \"\\t\\tRandomizes the dataset and outputs it on stdout.\\n\"\n\t);\n      }\n    }\n    catch (Exception ex) {\n      ex.printStackTrace();\n      System.err.println(ex.getMessage());\n    }\n  }\n  \n  /**\n   * Returns the revision string.\n   * \n   * @return\t\tthe revision\n   */\n  public String getRevision() {\n    return RevisionUtils.extract(\"$Revision: 9378 $\");\n  }\n}\n",
        "name": "Instances.java",
        "path": "weka-android/src/main/java/weka/core/Instances.java",
        "url": "/github.com/andrecamara/weka-android/-/blob/weka-android/src/main/java/weka/core/Instances.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 142,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires capacity \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 143,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures classIndex() == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 208,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first;"
        },
        {
          "limitHit": false,
          "lineNumber": 209,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= toCopy;"
        },
        {
          "limitHit": false,
          "lineNumber": 210,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires first + toCopy \u003c= source.numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 319,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;"
        },
        {
          "limitHit": false,
          "lineNumber": 320,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003c m_Instances.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 335,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;"
        },
        {
          "limitHit": false,
          "lineNumber": 336,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003c m_Attributes.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 337,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 427,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 470,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 485,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= position \u0026\u0026 position \u003c numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 486,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires position != classIndex();"
        },
        {
          "limitHit": false,
          "lineNumber": 548,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= attIndex \u0026\u0026 attIndex \u003c numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 648,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires numInstances() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 680,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= position;"
        },
        {
          "limitHit": false,
          "lineNumber": 681,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires position \u003c= numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 716,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;"
        },
        {
          "limitHit": false,
          "lineNumber": 717,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 729,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;"
        },
        {
          "limitHit": false,
          "lineNumber": 730,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 785,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires numInstances() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 848,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Attributes.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 861,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires classIndex() \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 882,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= attIndex;"
        },
        {
          "limitHit": false,
          "lineNumber": 883,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires attIndex \u003c numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 926,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Instances.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 937,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Instances.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 990,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_RelationName;"
        },
        {
          "limitHit": false,
          "lineNumber": 1002,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1003,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 1258,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1259,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003c m_Instances.size();"
        },
        {
          "limitHit": false,
          "lineNumber": 1415,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 1416,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;"
        },
        {
          "limitHit": false,
          "lineNumber": 1493,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 1494,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;"
        },
        {
          "limitHit": false,
          "lineNumber": 1534,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 2 \u003c= numFolds \u0026\u0026 numFolds \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 1535,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= numFold \u0026\u0026 numFold \u003c numFolds;"
        },
        {
          "limitHit": false,
          "lineNumber": 1601,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 1649,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= index \u0026\u0026 index \u003c numAttributes();"
        },
        {
          "limitHit": false,
          "lineNumber": 1756,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= from \u0026\u0026 from \u003c= numInstances() - num;"
        },
        {
          "limitHit": false,
          "lineNumber": 1757,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= num;"
        },
        {
          "limitHit": false,
          "lineNumber": 1825,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= i \u0026\u0026 i \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 1826,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= j \u0026\u0026 j \u003c numInstances();"
        },
        {
          "limitHit": false,
          "lineNumber": 1876,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires argv != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 1877,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires argv.length == 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 1878,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires argv[0] != null;"
        }
      ],
      "repository": {
        "name": "github.com/andrecamara/weka-android",
        "url": "/github.com/andrecamara/weka-android"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "4eef1b0916c85e8339cd32d672affca3d58e4c3f"
        },
        "content": "/*\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n/*\n *    SingleIndex.java\n *    Copyright (C) 2003-2012 University of Waikato, Hamilton, New Zealand\n *\n */\n\npackage weka.core;\n\nimport java.io.Serializable;\n\n/** \n * Class representing a single cardinal number. The number is set by a \n * string representation such as: \u003cP\u003e\n *\n * \u003ccode\u003e\n *   first\n *   last\n *   1\n *   3\n * \u003c/code\u003e \u003cP\u003e\n * The number is internally converted from 1-based to 0-based (so methods that \n * set or get numbers not in string format should use 0-based numbers).\n *\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\n * @version $Revision: 8034 $\n */\npublic class SingleIndex\n  implements Serializable, RevisionHandler, CustomDisplayStringProvider {\n  \n  /** for serialization. */\n  static final long serialVersionUID = 5285169134430839303L;\n\n  /** Record the string representation of the number. */\n  protected /*@non_null spec_public@*/ String m_IndexString = \"\";\n\n  /** The selected index. */\n  protected /*@ spec_public @*/ int m_SelectedIndex = -1;\n\n  /** Store the maximum value permitted. -1 indicates that no upper\n      value has been set */\n  protected /*@ spec_public @*/ int m_Upper = -1;\n\n  /**\n   * Default constructor.\n   *\n   */\n  //@ assignable m_IndexString, m_SelectedIndex, m_Upper;\n  //@ ensures m_SelectedIndex == -1;\n  //@ ensures m_Upper == -1;\n  public SingleIndex() {\n  }\n\n  /**\n   * Constructor to set initial index.\n   *\n   * @param index the initial index\n   * @throws IllegalArgumentException if the index is invalid\n   */\n  //@ assignable m_IndexString, m_SelectedIndex, m_Upper;\n  //@ ensures m_IndexString == index;\n  //@ ensures m_SelectedIndex == -1;\n  //@ ensures m_Upper == -1;\n  public SingleIndex(/*@non_null@*/ String index) {\n\n    setSingleIndex(index);\n  }\n\n  /**\n   * Sets the value of \"last\".\n   *\n   * @param newUpper the value of \"last\"\n   */\n  //@ assignable m_Upper, m_IndexString, m_SelectedIndex;\n  //@ ensures newUpper \u003c 0 ==\u003e m_Upper == \\old(m_Upper);\n  //@ ensures newUpper \u003e= 0 ==\u003e m_Upper == newUpper;\n  public void setUpper(int newUpper) {\n\n    if (newUpper \u003e= 0) {\n      m_Upper = newUpper;\n      setValue();\n    }\n  }\n\n  /**\n   * Gets the string representing the selected range of values.\n   *\n   * @return the range selection string\n   */\n  //@ ensures \\result == m_IndexString;\n  public /*@pure@*/ String getSingleIndex() {\n\n    return m_IndexString;\n  }\n\n  /**\n   * Sets the index from a string representation. Note that setUpper()\n   * must be called for the value to be actually set\n   *\n   * @param index the index set\n   * @throws IllegalArgumentException if the index was not well formed\n   */\n  //@ assignable m_IndexString, m_SelectedIndex;\n  //@ ensures m_IndexString == index;\n  //@ ensures m_SelectedIndex == -1;\n  public void setSingleIndex(/*@non_null@*/ String index) {\n\n    m_IndexString = index;\n    m_SelectedIndex = -1;\n  }\n\n  /**\n   * Constructs a representation of the current range. Being a string\n   * representation, the numbers are based from 1.\n   * \n   * @return the string representation of the current range\n   */\n  //@ also signals (RuntimeException e) \\old(m_Upper) \u003c 0;\n  //@ ensures \\result != null;\n  public /*@pure@*/ String toString() {\n\n    if (m_IndexString.equals(\"\")) {\n      return \"No index set\";\n    }\n    if (m_Upper == -1) {\n      throw new RuntimeException(\"Upper limit has not been specified\");\n    }\n    return m_IndexString;\n  }\n\n  /**\n   * Gets the selected index.\n   *\n   * @return the selected index\n   * @throws RuntimeException if the upper limit of the index hasn't been defined\n   */\n  //@ requires m_Upper \u003e= 0;\n  //@ requires m_IndexString.length() \u003e 0;\n  //@ ensures \\result == m_SelectedIndex;\n  public /*@pure@*/ int getIndex() {\n\n    if (m_IndexString.equals(\"\")) {\n      throw new RuntimeException(\"No index set\");\n    }\n    if (m_Upper == -1) {\n      throw new RuntimeException(\"No upper limit has been specified for index\");\n    }\n    return m_SelectedIndex;\n  }\n\n  /**\n   * Creates a string representation of the given index.\n   *\n   * @param index the index to turn into a string.\n   * Since the index will typically come from a program, indices are assumed\n   * from 0, and thus will have 1 added in the String representation.\n   * @return the string representation\n   */\n  //@ requires index \u003e= 0;\n  public static /*@pure non_null@*/ String indexToString(int index) {\n\n    return \"\" + (index + 1);\n  }\n\n  /**\n   * Translates a single string selection into it's internal 0-based equivalent.\n   */\n  //@ assignable m_SelectedIndex, m_IndexString;\n  protected void setValue() {\n\n    if (m_IndexString.equals(\"\")) {\n      throw new RuntimeException(\"No index set\");\n    }\n    if (m_IndexString.toLowerCase().equals(\"first\")) {\n      m_SelectedIndex = 0;\n    } else if (m_IndexString.toLowerCase().equals(\"last\")) {\n      m_SelectedIndex = m_Upper;\n    } else {\n      m_SelectedIndex = Integer.parseInt(m_IndexString) - 1;\n      if (m_SelectedIndex \u003c 0) {\n\tm_IndexString = \"\";\n\tthrow new IllegalArgumentException(\"Index must be greater than zero\");\n      }\n      if (m_SelectedIndex \u003e m_Upper) {\n\tm_IndexString = \"\";\n\tthrow new IllegalArgumentException(\"Index is too large\");\n      }\n    }\n  }\n  \n  /**\n   * Returns the revision string.\n   * \n   * @return\t\tthe revision\n   */\n  public String getRevision() {\n    return RevisionUtils.extract(\"$Revision: 8034 $\");\n  }\n\n  /**\n   * Returns the custom display string.\n   * \n   * @return\t\tthe string\n   */\n  public String toDisplay() {\n    return getSingleIndex();\n  }\n\n  /**\n   * Main method for testing this class.\n   *\n   * @param argv one parameter: a test index specification\n   */\n  //@ requires \\nonnullelements(argv);\n  public static void main(/*@non_null@*/ String [] argv) {\n\n    try {\n      if (argv.length == 0) {\n\tthrow new Exception(\"Usage: SingleIndex \u003cindexspec\u003e\");\n      }\n      SingleIndex singleIndex = new SingleIndex();\n      singleIndex.setSingleIndex(argv[0]);\n      singleIndex.setUpper(9);\n      System.out.println(\"Input: \" + argv[0] + \"\\n\"\n\t\t\t + singleIndex.toString());\n      int selectedIndex = singleIndex.getIndex();\n      System.out.println(selectedIndex + \"\");\n    } catch (Exception ex) {\n      ex.printStackTrace();\n      System.out.println(ex.getMessage());\n    }\n  }\n}\n",
        "name": "SingleIndex.java",
        "path": "weka-android/src/main/java/weka/core/SingleIndex.java",
        "url": "/github.com/andrecamara/weka-android/-/blob/weka-android/src/main/java/weka/core/SingleIndex.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 62,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_SelectedIndex == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 63,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Upper == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 74,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_IndexString == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 75,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_SelectedIndex == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 76,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Upper == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 88,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures newUpper \u003c 0 ==\u003e m_Upper == \\old(m_Upper);"
        },
        {
          "limitHit": false,
          "lineNumber": 89,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures newUpper \u003e= 0 ==\u003e m_Upper == newUpper;"
        },
        {
          "limitHit": false,
          "lineNumber": 103,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_IndexString;"
        },
        {
          "limitHit": false,
          "lineNumber": 117,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_IndexString == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 118,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_SelectedIndex == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 132,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 150,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Upper \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 151,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_IndexString.length() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 152,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_SelectedIndex;"
        },
        {
          "limitHit": false,
          "lineNumber": 172,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 227,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires \\nonnullelements(argv);"
        }
      ],
      "repository": {
        "name": "github.com/andrecamara/weka-android",
        "url": "/github.com/andrecamara/weka-android"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "4eef1b0916c85e8339cd32d672affca3d58e4c3f"
        },
        "content": "/*\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n/*\n *    OptionHandler.java\n *    Copyright (C) 1999-2012 University of Waikato, Hamilton, New Zealand\n *\n */\n\npackage weka.core;\n\nimport java.util.Enumeration;\n\n/** \n * Interface to something that understands options.\n *\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\n * @author Len Trigg (trigg@cs.waikato.ac.nz)\n * @version $Revision: 8034 $\n */\npublic interface OptionHandler {\n\n  /**\n   * Returns an enumeration of all the available options..\n   *\n   * @return an enumeration of all available options.\n   */\n  Enumeration listOptions();\n\n  /**\n   * Sets the OptionHandler's options using the given list. All options\n   * will be set (or reset) during this call (i.e. incremental setting\n   * of options is not possible).\n   *\n   * @param options the list of options as an array of strings\n   * @exception Exception if an option is not supported\n   */\n  //@ requires options != null;\n  //@ requires \\nonnullelements(options);\n  void setOptions(String[] options) throws Exception;\n\n  /**\n   * Gets the current option settings for the OptionHandler.\n   *\n   * @return the list of current option settings as an array of strings\n   */\n  //@ ensures \\result != null;\n  //@ ensures \\nonnullelements(\\result);\n  /*@pure@*/ String[] getOptions();\n}\n\n\n\n\n\n\n\n\n",
        "name": "OptionHandler.java",
        "path": "weka-android/src/main/java/weka/core/OptionHandler.java",
        "url": "/github.com/andrecamara/weka-android/-/blob/weka-android/src/main/java/weka/core/OptionHandler.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 49,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires options != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 50,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires \\nonnullelements(options);"
        },
        {
          "limitHit": false,
          "lineNumber": 58,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 59,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\nonnullelements(\\result);"
        }
      ],
      "repository": {
        "name": "github.com/andrecamara/weka-android",
        "url": "/github.com/andrecamara/weka-android"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "4eef1b0916c85e8339cd32d672affca3d58e4c3f"
        },
        "content": "/*\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n/*\n *    WekaEnumeration.java\n *    Copyright (C) 2009-2012 University of Waikato, Hamilton, New Zealand\n *\n */\npackage weka.core;\n\nimport java.util.Enumeration;\nimport java.util.List;\n\n/**\n * Class for enumerating an array list's elements.\n */\npublic class WekaEnumeration\n  implements Enumeration, RevisionHandler {\n  \n  /** The counter. */\n  private int m_Counter;\n  // These JML commands say how m_Counter implements Enumeration\n  //@ in moreElements;\n  //@ private represents moreElements = m_Counter \u003c m_Vector.size();\n  //@ private invariant 0 \u003c= m_Counter \u0026\u0026 m_Counter \u003c= m_Vector.size();\n  \n  /** The vector. */\n  private /*@non_null@*/ List m_Vector;\n  \n  /** Special element. Skipped during enumeration. */\n  private int m_SpecialElement;\n  //@ private invariant -1 \u003c= m_SpecialElement;\n  //@ private invariant m_SpecialElement \u003c m_Vector.size();\n  //@ private invariant m_SpecialElement\u003e=0 ==\u003e m_Counter!=m_SpecialElement;\n  \n  /**\n   * Constructs an enumeration.\n   *\n   * @param vector the vector which is to be enumerated\n   */\n  public WekaEnumeration(/*@non_null@*/List vector) {\n    \n    m_Counter = 0;\n    m_Vector = vector;\n    m_SpecialElement = -1;\n  }\n  \n  /**\n   * Constructs an enumeration with a special element.\n   * The special element is skipped during the enumeration.\n   *\n   * @param vector the vector which is to be enumerated\n   * @param special the index of the special element\n   */\n  //@ requires 0 \u003c= special \u0026\u0026 special \u003c vector.size();\n  public WekaEnumeration(/*@non_null@*/List vector, int special){\n    \n    m_Vector = vector;\n    m_SpecialElement = special;\n    if (special == 0) {\n      m_Counter = 1;\n    } else {\n      m_Counter = 0;\n    }\n  }\n  \n  \n  /**\n   * Tests if there are any more elements to enumerate.\n   *\n   * @return true if there are some elements left\n   */\n  public final /*@pure@*/ boolean hasMoreElements() {\n    \n    if (m_Counter \u003c m_Vector.size()) {\n      return true;\n    }\n    return false;\n  }\n  \n  /**\n   * Returns the next element.\n   *\n   * @return the next element to be enumerated\n   */\n  //@ also requires hasMoreElements();\n  public final Object nextElement() {\n    \n    Object result = m_Vector.get(m_Counter);\n    \n    m_Counter++;\n    if (m_Counter == m_SpecialElement) {\n      m_Counter++;\n    }\n    return result;\n  }\n  \n  /**\n   * Returns the revision string.\n   * \n   * @return\t\tthe revision\n   */\n  public String getRevision() {\n    return RevisionUtils.extract(\"$Revision: 8034 $\");\n  }\n}\n",
        "name": "WekaEnumeration.java",
        "path": "weka-android/src/main/java/weka/core/WekaEnumeration.java",
        "url": "/github.com/andrecamara/weka-android/-/blob/weka-android/src/main/java/weka/core/WekaEnumeration.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 66,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= special \u0026\u0026 special \u003c vector.size();"
        }
      ],
      "repository": {
        "name": "github.com/andrecamara/weka-android",
        "url": "/github.com/andrecamara/weka-android"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "4eef1b0916c85e8339cd32d672affca3d58e4c3f"
        },
        "content": "/*\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n/*\n *    Utils.java\n *    Copyright (C) 1999-2012 University of Waikato, Hamilton, New Zealand\n *\n */\n\npackage weka.core;\n\nimport java.io.File;\nimport java.lang.reflect.Array;\nimport java.net.URL;\nimport java.text.BreakIterator;\nimport java.util.Enumeration;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Vector;\n\n/**\n * Class implementing some simple utility methods.\n * \n * @author Eibe Frank\n * @author Yong Wang\n * @author Len Trigg\n * @author Julien Prados\n * @version $Revision: 9736 $\n */\npublic final class Utils implements RevisionHandler {\n\n\t/** The natural logarithm of 2. */\n\tpublic static double log2 = Math.log(2);\n\n\t/** The small deviation allowed in double comparisons. */\n\tpublic static double SMALL = 1e-6;\n\n\t/**\n\t * Tests if the given value codes \"missing\".\n\t * \n\t * @param val\n\t *            the value to be tested\n\t * @return true if val codes \"missing\"\n\t */\n\tpublic static boolean isMissingValue(double val) {\n\n\t\treturn Double.isNaN(val);\n\t}\n\n\t/**\n\t * Returns the value used to code a missing value. Note that equality tests on this value will always return false, so use isMissingValue(double val) for testing..\n\t * \n\t * @return the value used as missing value.\n\t */\n\tpublic static double missingValue() {\n\n\t\treturn Double.NaN;\n\t}\n\n\t/**\n\t * Casting an object without \"unchecked\" compile-time warnings. Use only when absolutely necessary (e.g. when using clone()).\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static \u003cT\u003e T cast(Object x) {\n\t\treturn (T) x;\n\t}\n\n\t/**\n\t * Reads properties that inherit from three locations. Properties are first defined in the system resource location (i.e. in the CLASSPATH). These default properties must exist. Properties optionally defined in the user properties location (WekaPackageManager.PROPERTIES_DIR) override default settings. Properties defined in the current directory (optional) override all these settings.\n\t * \n\t * @param resourceName\n\t *            the location of the resource that should be loaded. e.g.: \"weka/core/Utils.props\". (The use of hardcoded forward slashes here is OK - see jdk1.1/docs/guide/misc/resources.html) This routine will also look for the file (in this case) \"Utils.props\" in the users home directory and the current directory.\n\t * @return the Properties\n\t * @exception Exception\n\t *                if no default properties are defined, or if an error occurs reading the properties files.\n\t */\n\tpublic static Properties readProperties(String resourceName) throws Exception {\n\n\t\tProperties defaultProps = new Properties();\n\t\ttry {\n\t\t\t// Apparently hardcoded slashes are OK here\n\t\t\t// jdk1.1/docs/guide/misc/resources.html\n\t\t\tUtils utils = new Utils();\n\t\t\tEnumeration\u003cURL\u003e urls = utils.getClass().getClassLoader().getResources(resourceName);\n\t\t\tboolean first = true;\n\t\t\twhile (urls.hasMoreElements()) {\n\t\t\t\tURL url = urls.nextElement();\n\t\t\t\tif (first) {\n\t\t\t\t\tdefaultProps.load(url.openStream());\n\t\t\t\t\tfirst = false;\n\t\t\t\t} else {\n\t\t\t\t\tProperties props = new Properties(defaultProps);\n\t\t\t\t\tprops.load(url.openStream());\n\t\t\t\t\tdefaultProps = props;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tSystem.err.println(\"Warning, unable to load properties file(s) from \" + \"system resource (Utils.java): \" + resourceName);\n\t\t}\n\n\t\t// Hardcoded slash is OK here\n\t\t// eg: see jdk1.1/docs/guide/misc/resources.html\n\t\tint slInd = resourceName.lastIndexOf('/');\n\t\tif (slInd != -1) {\n\t\t\tresourceName = resourceName.substring(slInd + 1);\n\t\t}\n\n\t\t// Allow a properties file in the WekaPackageManager.PROPERTIES_DIR to override\n\t\tProperties userProps = new Properties(defaultProps);\n\t\t/*if (!WekaPackageManager.PROPERTIES_DIR.exists()) {\n\t\t\tWekaPackageManager.PROPERTIES_DIR.mkdir();\n\t\t}\n\t\tFile propFile = new File(WekaPackageManager.PROPERTIES_DIR.toString() + File.separator + resourceName);\n\n\t\tif (propFile.exists()) {\n\t\t\ttry {\n\t\t\t\tuserProps.load(new FileInputStream(propFile));\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new Exception(\"Problem reading user properties: \" + propFile);\n\t\t\t}\n\t\t}*/\n\n\t\t// Allow a properties file in the current directory to override\n\t\tProperties localProps = new Properties(userProps);\n\t\t/*propFile = new File(resourceName);\n\t\tif (propFile.exists()) {\n\t\t\ttry {\n\t\t\t\tlocalProps.load(new FileInputStream(propFile));\n\t\t\t} catch (Exception ex) {\n\t\t\t\tthrow new Exception(\"Problem reading local properties: \" + propFile);\n\t\t\t}\n\t\t}*/\n\n\t\treturn localProps;\n\t}\n\n\t/**\n\t * Returns the correlation coefficient of two double vectors.\n\t * \n\t * @param y1\n\t *            double vector 1\n\t * @param y2\n\t *            double vector 2\n\t * @param n\n\t *            the length of two double vectors\n\t * @return the correlation coefficient\n\t */\n\tpublic static final double correlation(double y1[], double y2[], int n) {\n\n\t\tint i;\n\t\tdouble av1 = 0.0, av2 = 0.0, y11 = 0.0, y22 = 0.0, y12 = 0.0, c;\n\n\t\tif (n \u003c= 1) {\n\t\t\treturn 1.0;\n\t\t}\n\t\tfor (i = 0; i \u003c n; i++) {\n\t\t\tav1 += y1[i];\n\t\t\tav2 += y2[i];\n\t\t}\n\t\tav1 /= (double) n;\n\t\tav2 /= (double) n;\n\t\tfor (i = 0; i \u003c n; i++) {\n\t\t\ty11 += (y1[i] - av1) * (y1[i] - av1);\n\t\t\ty22 += (y2[i] - av2) * (y2[i] - av2);\n\t\t\ty12 += (y1[i] - av1) * (y2[i] - av2);\n\t\t}\n\t\tif (y11 * y22 == 0.0) {\n\t\t\tc = 1.0;\n\t\t} else {\n\t\t\tc = y12 / Math.sqrt(Math.abs(y11 * y22));\n\t\t}\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * Removes all occurrences of a string from another string.\n\t * \n\t * @param inString\n\t *            the string to remove substrings from.\n\t * @param substring\n\t *            the substring to remove.\n\t * @return the input string with occurrences of substring removed.\n\t */\n\tpublic static String removeSubstring(String inString, String substring) {\n\n\t\tStringBuffer result = new StringBuffer();\n\t\tint oldLoc = 0, loc = 0;\n\t\twhile ((loc = inString.indexOf(substring, oldLoc)) != -1) {\n\t\t\tresult.append(inString.substring(oldLoc, loc));\n\t\t\toldLoc = loc + substring.length();\n\t\t}\n\t\tresult.append(inString.substring(oldLoc));\n\t\treturn result.toString();\n\t}\n\n\t/**\n\t * Replaces with a new string, all occurrences of a string from another string.\n\t * \n\t * @param inString\n\t *            the string to replace substrings in.\n\t * @param subString\n\t *            the substring to replace.\n\t * @param replaceString\n\t *            the replacement substring\n\t * @return the input string with occurrences of substring replaced.\n\t */\n\tpublic static String replaceSubstring(String inString, String subString, String replaceString) {\n\n\t\tStringBuffer result = new StringBuffer();\n\t\tint oldLoc = 0, loc = 0;\n\t\twhile ((loc = inString.indexOf(subString, oldLoc)) != -1) {\n\t\t\tresult.append(inString.substring(oldLoc, loc));\n\t\t\tresult.append(replaceString);\n\t\t\toldLoc = loc + subString.length();\n\t\t}\n\t\tresult.append(inString.substring(oldLoc));\n\t\treturn result.toString();\n\t}\n\n\t/**\n\t * Pads a string to a specified length, inserting spaces on the left as required. If the string is too long, characters are removed (from the right).\n\t * \n\t * @param inString\n\t *            the input string\n\t * @param length\n\t *            the desired length of the output string\n\t * @return the output string\n\t */\n\tpublic static String padLeft(String inString, int length) {\n\n\t\treturn fixStringLength(inString, length, false);\n\t}\n\n\t/**\n\t * Pads a string to a specified length, inserting spaces on the right as required. If the string is too long, characters are removed (from the right).\n\t * \n\t * @param inString\n\t *            the input string\n\t * @param length\n\t *            the desired length of the output string\n\t * @return the output string\n\t */\n\tpublic static String padRight(String inString, int length) {\n\n\t\treturn fixStringLength(inString, length, true);\n\t}\n\n\t/**\n\t * Pads a string to a specified length, inserting spaces as required. If the string is too long, characters are removed (from the right).\n\t * \n\t * @param inString\n\t *            the input string\n\t * @param length\n\t *            the desired length of the output string\n\t * @param right\n\t *            true if inserted spaces should be added to the right\n\t * @return the output string\n\t */\n\tprivate static/*@pure@*/String fixStringLength(String inString, int length, boolean right) {\n\n\t\tif (inString.length() \u003c length) {\n\t\t\twhile (inString.length() \u003c length) {\n\t\t\t\tinString = (right ? inString.concat(\" \") : \" \".concat(inString));\n\t\t\t}\n\t\t} else if (inString.length() \u003e length) {\n\t\t\tinString = inString.substring(0, length);\n\t\t}\n\t\treturn inString;\n\t}\n\n\t/**\n\t * Rounds a double and converts it into String.\n\t * \n\t * @param value\n\t *            the double value\n\t * @param afterDecimalPoint\n\t *            the (maximum) number of digits permitted after the decimal point\n\t * @return the double as a formatted string\n\t */\n\tpublic static/*@pure@*/String doubleToString(double value, int afterDecimalPoint) {\n\n\t\tStringBuffer stringBuffer;\n\t\tdouble temp;\n\t\tint dotPosition;\n\t\tlong precisionValue;\n\n\t\ttemp = value * Math.pow(10.0, afterDecimalPoint);\n\t\tif (Math.abs(temp) \u003c Long.MAX_VALUE) {\n\t\t\tprecisionValue = (temp \u003e 0) ? (long) (temp + 0.5) : -(long) (Math.abs(temp) + 0.5);\n\t\t\tif (precisionValue == 0) {\n\t\t\t\tstringBuffer = new StringBuffer(String.valueOf(0));\n\t\t\t} else {\n\t\t\t\tstringBuffer = new StringBuffer(String.valueOf(precisionValue));\n\t\t\t}\n\t\t\tif (afterDecimalPoint == 0) {\n\t\t\t\treturn stringBuffer.toString();\n\t\t\t}\n\t\t\tdotPosition = stringBuffer.length() - afterDecimalPoint;\n\t\t\twhile (((precisionValue \u003c 0) \u0026\u0026 (dotPosition \u003c 1)) || (dotPosition \u003c 0)) {\n\t\t\t\tif (precisionValue \u003c 0) {\n\t\t\t\t\tstringBuffer.insert(1, '0');\n\t\t\t\t} else {\n\t\t\t\t\tstringBuffer.insert(0, '0');\n\t\t\t\t}\n\t\t\t\tdotPosition++;\n\t\t\t}\n\t\t\tstringBuffer.insert(dotPosition, '.');\n\t\t\tif ((precisionValue \u003c 0) \u0026\u0026 (stringBuffer.charAt(1) == '.')) {\n\t\t\t\tstringBuffer.insert(1, '0');\n\t\t\t} else if (stringBuffer.charAt(0) == '.') {\n\t\t\t\tstringBuffer.insert(0, '0');\n\t\t\t}\n\t\t\tint currentPos = stringBuffer.length() - 1;\n\t\t\twhile ((currentPos \u003e dotPosition) \u0026\u0026 (stringBuffer.charAt(currentPos) == '0')) {\n\t\t\t\tstringBuffer.setCharAt(currentPos--, ' ');\n\t\t\t}\n\t\t\tif (stringBuffer.charAt(currentPos) == '.') {\n\t\t\t\tstringBuffer.setCharAt(currentPos, ' ');\n\t\t\t}\n\n\t\t\treturn stringBuffer.toString().trim();\n\t\t}\n\t\treturn new String(\"\" + value);\n\t}\n\n\t/**\n\t * Rounds a double and converts it into a formatted decimal-justified String. Trailing 0's are replaced with spaces.\n\t * \n\t * @param value\n\t *            the double value\n\t * @param width\n\t *            the width of the string\n\t * @param afterDecimalPoint\n\t *            the number of digits after the decimal point\n\t * @return the double as a formatted string\n\t */\n\tpublic static/*@pure@*/String doubleToString(double value, int width, int afterDecimalPoint) {\n\n\t\tString tempString = doubleToString(value, afterDecimalPoint);\n\t\tchar[] result;\n\t\tint dotPosition;\n\n\t\tif ((afterDecimalPoint \u003e= width) || (tempString.indexOf('E') != -1)) { // Protects sci notation\n\t\t\treturn tempString;\n\t\t}\n\n\t\t// Initialize result\n\t\tresult = new char[width];\n\t\tfor (int i = 0; i \u003c result.length; i++) {\n\t\t\tresult[i] = ' ';\n\t\t}\n\n\t\tif (afterDecimalPoint \u003e 0) {\n\t\t\t// Get position of decimal point and insert decimal point\n\t\t\tdotPosition = tempString.indexOf('.');\n\t\t\tif (dotPosition == -1) {\n\t\t\t\tdotPosition = tempString.length();\n\t\t\t} else {\n\t\t\t\tresult[width - afterDecimalPoint - 1] = '.';\n\t\t\t}\n\t\t} else {\n\t\t\tdotPosition = tempString.length();\n\t\t}\n\n\t\tint offset = width - afterDecimalPoint - dotPosition;\n\t\tif (afterDecimalPoint \u003e 0) {\n\t\t\toffset--;\n\t\t}\n\n\t\t// Not enough room to decimal align within the supplied width\n\t\tif (offset \u003c 0) {\n\t\t\treturn tempString;\n\t\t}\n\n\t\t// Copy characters before decimal point\n\t\tfor (int i = 0; i \u003c dotPosition; i++) {\n\t\t\tresult[offset + i] = tempString.charAt(i);\n\t\t}\n\n\t\t// Copy characters after decimal point\n\t\tfor (int i = dotPosition + 1; i \u003c tempString.length(); i++) {\n\t\t\tresult[offset + i] = tempString.charAt(i);\n\t\t}\n\n\t\treturn new String(result);\n\t}\n\n\t/**\n\t * Returns the basic class of an array class (handles multi-dimensional arrays).\n\t * \n\t * @param c\n\t *            the array to inspect\n\t * @return the class of the innermost elements\n\t */\n\tpublic static Class getArrayClass(Class c) {\n\t\tif (c.getComponentType().isArray())\n\t\t\treturn getArrayClass(c.getComponentType());\n\t\telse\n\t\t\treturn c.getComponentType();\n\t}\n\n\t/**\n\t * Returns the dimensions of the given array. Even though the parameter is of type \"Object\" one can hand over primitve arrays, e.g. int[3] or double[2][4].\n\t * \n\t * @param array\n\t *            the array to determine the dimensions for\n\t * @return the dimensions of the array\n\t */\n\tpublic static int getArrayDimensions(Class array) {\n\t\tif (array.getComponentType().isArray())\n\t\t\treturn 1 + getArrayDimensions(array.getComponentType());\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\t/**\n\t * Returns the dimensions of the given array. Even though the parameter is of type \"Object\" one can hand over primitve arrays, e.g. int[3] or double[2][4].\n\t * \n\t * @param array\n\t *            the array to determine the dimensions for\n\t * @return the dimensions of the array\n\t */\n\tpublic static int getArrayDimensions(Object array) {\n\t\treturn getArrayDimensions(array.getClass());\n\t}\n\n\t/**\n\t * Returns the given Array in a string representation. Even though the parameter is of type \"Object\" one can hand over primitve arrays, e.g. int[3] or double[2][4].\n\t * \n\t * @param array\n\t *            the array to return in a string representation\n\t * @return the array as string\n\t */\n\tpublic static String arrayToString(Object array) {\n\t\tString result;\n\t\tint dimensions;\n\t\tint i;\n\n\t\tresult = \"\";\n\t\tdimensions = getArrayDimensions(array);\n\n\t\tif (dimensions == 0) {\n\t\t\tresult = \"null\";\n\t\t} else if (dimensions == 1) {\n\t\t\tfor (i = 0; i \u003c Array.getLength(array); i++) {\n\t\t\t\tif (i \u003e 0)\n\t\t\t\t\tresult += \",\";\n\t\t\t\tif (Array.get(array, i) == null)\n\t\t\t\t\tresult += \"null\";\n\t\t\t\telse\n\t\t\t\t\tresult += Array.get(array, i).toString();\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i \u003c Array.getLength(array); i++) {\n\t\t\t\tif (i \u003e 0)\n\t\t\t\t\tresult += \",\";\n\t\t\t\tresult += \"[\" + arrayToString(Array.get(array, i)) + \"]\";\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Tests if a is equal to b.\n\t * \n\t * @param a\n\t *            a double\n\t * @param b\n\t *            a double\n\t */\n\tpublic static/*@pure@*/boolean eq(double a, double b) {\n\n\t\treturn (a == b) || ((a - b \u003c SMALL) \u0026\u0026 (b - a \u003c SMALL));\n\t}\n\n\t/**\n\t * Checks if the given array contains any non-empty options.\n\t * \n\t * @param options\n\t *            an array of strings\n\t * @exception Exception\n\t *                if there are any non-empty options\n\t */\n\tpublic static void checkForRemainingOptions(String[] options) throws Exception {\n\n\t\tint illegalOptionsFound = 0;\n\t\tStringBuffer text = new StringBuffer();\n\n\t\tif (options == null) {\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i \u003c options.length; i++) {\n\t\t\tif (options[i].length() \u003e 0) {\n\t\t\t\tillegalOptionsFound++;\n\t\t\t\ttext.append(options[i] + ' ');\n\t\t\t}\n\t\t}\n\t\tif (illegalOptionsFound \u003e 0) {\n\t\t\tthrow new Exception(\"Illegal options: \" + text);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given array contains the flag \"-Char\". Stops searching at the first marker \"--\". If the flag is found, it is replaced with the empty string.\n\t * \n\t * @param flag\n\t *            the character indicating the flag.\n\t * @param options\n\t *            the array of strings containing all the options.\n\t * @return true if the flag was found\n\t * @exception Exception\n\t *                if an illegal option was found\n\t */\n\tpublic static boolean getFlag(char flag, String[] options) throws Exception {\n\n\t\treturn getFlag(\"\" + flag, options);\n\t}\n\n\t/**\n\t * Checks if the given array contains the flag \"-String\". Stops searching at the first marker \"--\". If the flag is found, it is replaced with the empty string.\n\t * \n\t * @param flag\n\t *            the String indicating the flag.\n\t * @param options\n\t *            the array of strings containing all the options.\n\t * @return true if the flag was found\n\t * @exception Exception\n\t *                if an illegal option was found\n\t */\n\tpublic static boolean getFlag(String flag, String[] options) throws Exception {\n\n\t\tint pos = getOptionPos(flag, options);\n\n\t\tif (pos \u003e -1)\n\t\t\toptions[pos] = \"\";\n\n\t\treturn (pos \u003e -1);\n\t}\n\n\t/**\n\t * Gets an option indicated by a flag \"-Char\" from the given array of strings. Stops searching at the first marker \"--\". Replaces flag and option with empty strings.\n\t * \n\t * @param flag\n\t *            the character indicating the option.\n\t * @param options\n\t *            the array of strings containing all the options.\n\t * @return the indicated option or an empty string\n\t * @exception Exception\n\t *                if the option indicated by the flag can't be found\n\t */\n\tpublic static/*@non_null@*/String getOption(char flag, String[] options) throws Exception {\n\n\t\treturn getOption(\"\" + flag, options);\n\t}\n\n\t/**\n\t * Gets an option indicated by a flag \"-String\" from the given array of strings. Stops searching at the first marker \"--\". Replaces flag and option with empty strings.\n\t * \n\t * @param flag\n\t *            the String indicating the option.\n\t * @param options\n\t *            the array of strings containing all the options.\n\t * @return the indicated option or an empty string\n\t * @exception Exception\n\t *                if the option indicated by the flag can't be found\n\t */\n\tpublic static/*@non_null@*/String getOption(String flag, String[] options) throws Exception {\n\n\t\tString newString;\n\t\tint i = getOptionPos(flag, options);\n\n\t\tif (i \u003e -1) {\n\t\t\tif (options[i].equals(\"-\" + flag)) {\n\t\t\t\tif (i + 1 == options.length) {\n\t\t\t\t\tthrow new Exception(\"No value given for -\" + flag + \" option.\");\n\t\t\t\t}\n\t\t\t\toptions[i] = \"\";\n\t\t\t\tnewString = new String(options[i + 1]);\n\t\t\t\toptions[i + 1] = \"\";\n\t\t\t\treturn newString;\n\t\t\t}\n\t\t\tif (options[i].charAt(1) == '-') {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Gets the index of an option or flag indicated by a flag \"-Char\" from the given array of strings. Stops searching at the first marker \"--\".\n\t * \n\t * @param flag\n\t *            the character indicating the option.\n\t * @param options\n\t *            the array of strings containing all the options.\n\t * @return the position if found, or -1 otherwise\n\t */\n\tpublic static int getOptionPos(char flag, String[] options) {\n\t\treturn getOptionPos(\"\" + flag, options);\n\t}\n\n\t/**\n\t * Gets the index of an option or flag indicated by a flag \"-String\" from the given array of strings. Stops searching at the first marker \"--\".\n\t * \n\t * @param flag\n\t *            the String indicating the option.\n\t * @param options\n\t *            the array of strings containing all the options.\n\t * @return the position if found, or -1 otherwise\n\t */\n\tpublic static int getOptionPos(String flag, String[] options) {\n\t\tif (options == null)\n\t\t\treturn -1;\n\n\t\tfor (int i = 0; i \u003c options.length; i++) {\n\t\t\tif ((options[i].length() \u003e 0) \u0026\u0026 (options[i].charAt(0) == '-')) {\n\t\t\t\t// Check if it is a negative number\n\t\t\t\ttry {\n\t\t\t\t\tDouble.valueOf(options[i]);\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t// found?\n\t\t\t\t\tif (options[i].equals(\"-\" + flag))\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t// did we reach \"--\"?\n\t\t\t\t\tif (options[i].charAt(1) == '-')\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Quotes a string if it contains special characters.\n\t * \n\t * The following rules are applied:\n\t * \n\t * A character is backquoted version of it is one of \u003ctt\u003e\" ' % \\ \\n \\r \\t\u003c/tt\u003e.\n\t * \n\t * A string is enclosed within single quotes if a character has been backquoted using the previous rule above or contains \u003ctt\u003e{ }\u003c/tt\u003e or is exactly equal to the strings \u003ctt\u003e, ? space or \"\"\u003c/tt\u003e (empty string).\n\t * \n\t * A quoted question mark distinguishes it from the missing value which is represented as an unquoted question mark in arff files.\n\t * \n\t * @param string\n\t *            the string to be quoted\n\t * @return the string (possibly quoted)\n\t * @see #unquote(String)\n\t */\n\tpublic static/*@pure@*/String quote(String string) {\n\t\tboolean quote = false;\n\n\t\t// backquote the following characters \n\t\tif ((string.indexOf('\\n') != -1) || (string.indexOf('\\r') != -1) || (string.indexOf('\\'') != -1) || (string.indexOf('\"') != -1) || (string.indexOf('\\\\') != -1) || (string.indexOf('\\t') != -1) || (string.indexOf('%') != -1) || (string.indexOf('\\u001E') != -1)) {\n\t\t\tstring = backQuoteChars(string);\n\t\t\tquote = true;\n\t\t}\n\n\t\t// Enclose the string in 's if the string contains a recently added\n\t\t// backquote or contains one of the following characters.\n\t\tif ((quote == true) || (string.indexOf('{') != -1) || (string.indexOf('}') != -1) || (string.indexOf(',') != -1) || (string.equals(\"?\")) || (string.indexOf(' ') != -1) || (string.equals(\"\"))) {\n\t\t\tstring = (\"'\".concat(string)).concat(\"'\");\n\t\t}\n\n\t\treturn string;\n\t}\n\n\t/**\n\t * unquotes are previously quoted string (but only if necessary), i.e., it removes the single quotes around it. Inverse to quote(String).\n\t * \n\t * @param string\n\t *            the string to process\n\t * @return the unquoted string\n\t * @see #quote(String)\n\t */\n\tpublic static String unquote(String string) {\n\t\tif (string.startsWith(\"'\") \u0026\u0026 string.endsWith(\"'\")) {\n\t\t\tstring = string.substring(1, string.length() - 1);\n\n\t\t\tif ((string.indexOf(\"\\\\n\") != -1) || (string.indexOf(\"\\\\r\") != -1) || (string.indexOf(\"\\\\'\") != -1) || (string.indexOf(\"\\\\\\\"\") != -1) || (string.indexOf(\"\\\\\\\\\") != -1) || (string.indexOf(\"\\\\t\") != -1) || (string.indexOf(\"\\\\%\") != -1) || (string.indexOf(\"\\\\u001E\") != -1)) {\n\t\t\t\tstring = unbackQuoteChars(string);\n\t\t\t}\n\t\t}\n\n\t\treturn string;\n\t}\n\n\t/**\n\t * Converts carriage returns and new lines in a string into \\r and \\n. Backquotes the following characters: ` \" \\ \\t and %\n\t * \n\t * @param string\n\t *            the string\n\t * @return the converted string\n\t * @see #unbackQuoteChars(String)\n\t */\n\tpublic static/*@pure@*/String backQuoteChars(String string) {\n\n\t\tint index;\n\t\tStringBuffer newStringBuffer;\n\n\t\t// replace each of the following characters with the backquoted version\n\t\tchar charsFind[] = { '\\\\', '\\'', '\\t', '\\n', '\\r', '\"', '%', '\\u001E' };\n\t\tString charsReplace[] = { \"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\n\", \"\\\\r\", \"\\\\\\\"\", \"\\\\%\", \"\\\\u001E\" };\n\t\tfor (int i = 0; i \u003c charsFind.length; i++) {\n\t\t\tif (string.indexOf(charsFind[i]) != -1) {\n\t\t\t\tnewStringBuffer = new StringBuffer();\n\t\t\t\twhile ((index = string.indexOf(charsFind[i])) != -1) {\n\t\t\t\t\tif (index \u003e 0) {\n\t\t\t\t\t\tnewStringBuffer.append(string.substring(0, index));\n\t\t\t\t\t}\n\t\t\t\t\tnewStringBuffer.append(charsReplace[i]);\n\t\t\t\t\tif ((index + 1) \u003c string.length()) {\n\t\t\t\t\t\tstring = string.substring(index + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstring = \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnewStringBuffer.append(string);\n\t\t\t\tstring = newStringBuffer.toString();\n\t\t\t}\n\t\t}\n\n\t\treturn string;\n\t}\n\n\t/**\n\t * Converts carriage returns and new lines in a string into \\r and \\n.\n\t * \n\t * @param string\n\t *            the string\n\t * @return the converted string\n\t */\n\tpublic static String convertNewLines(String string) {\n\t\tint index;\n\n\t\t// Replace with \\n\n\t\tStringBuffer newStringBuffer = new StringBuffer();\n\t\twhile ((index = string.indexOf('\\n')) != -1) {\n\t\t\tif (index \u003e 0) {\n\t\t\t\tnewStringBuffer.append(string.substring(0, index));\n\t\t\t}\n\t\t\tnewStringBuffer.append('\\\\');\n\t\t\tnewStringBuffer.append('n');\n\t\t\tif ((index + 1) \u003c string.length()) {\n\t\t\t\tstring = string.substring(index + 1);\n\t\t\t} else {\n\t\t\t\tstring = \"\";\n\t\t\t}\n\t\t}\n\t\tnewStringBuffer.append(string);\n\t\tstring = newStringBuffer.toString();\n\n\t\t// Replace with \\r\n\t\tnewStringBuffer = new StringBuffer();\n\t\twhile ((index = string.indexOf('\\r')) != -1) {\n\t\t\tif (index \u003e 0) {\n\t\t\t\tnewStringBuffer.append(string.substring(0, index));\n\t\t\t}\n\t\t\tnewStringBuffer.append('\\\\');\n\t\t\tnewStringBuffer.append('r');\n\t\t\tif ((index + 1) \u003c string.length()) {\n\t\t\t\tstring = string.substring(index + 1);\n\t\t\t} else {\n\t\t\t\tstring = \"\";\n\t\t\t}\n\t\t}\n\t\tnewStringBuffer.append(string);\n\t\treturn newStringBuffer.toString();\n\t}\n\n\t/**\n\t * Reverts \\r and \\n in a string into carriage returns and new lines.\n\t * \n\t * @param string\n\t *            the string\n\t * @return the converted string\n\t */\n\tpublic static String revertNewLines(String string) {\n\t\tint index;\n\n\t\t// Replace with \\n\n\t\tStringBuffer newStringBuffer = new StringBuffer();\n\t\twhile ((index = string.indexOf(\"\\\\n\")) != -1) {\n\t\t\tif (index \u003e 0) {\n\t\t\t\tnewStringBuffer.append(string.substring(0, index));\n\t\t\t}\n\t\t\tnewStringBuffer.append('\\n');\n\t\t\tif ((index + 2) \u003c string.length()) {\n\t\t\t\tstring = string.substring(index + 2);\n\t\t\t} else {\n\t\t\t\tstring = \"\";\n\t\t\t}\n\t\t}\n\t\tnewStringBuffer.append(string);\n\t\tstring = newStringBuffer.toString();\n\n\t\t// Replace with \\r\n\t\tnewStringBuffer = new StringBuffer();\n\t\twhile ((index = string.indexOf(\"\\\\r\")) != -1) {\n\t\t\tif (index \u003e 0) {\n\t\t\t\tnewStringBuffer.append(string.substring(0, index));\n\t\t\t}\n\t\t\tnewStringBuffer.append('\\r');\n\t\t\tif ((index + 2) \u003c string.length()) {\n\t\t\t\tstring = string.substring(index + 2);\n\t\t\t} else {\n\t\t\t\tstring = \"\";\n\t\t\t}\n\t\t}\n\t\tnewStringBuffer.append(string);\n\n\t\treturn newStringBuffer.toString();\n\t}\n\n\t/**\n\t * Returns the secondary set of options (if any) contained in the supplied options array. The secondary set is defined to be any options after the first \"--\". These options are removed from the original options array.\n\t * \n\t * @param options\n\t *            the input array of options\n\t * @return the array of secondary options\n\t */\n\tpublic static String[] partitionOptions(String[] options) {\n\n\t\tfor (int i = 0; i \u003c options.length; i++) {\n\t\t\tif (options[i].equals(\"--\")) {\n\t\t\t\toptions[i++] = \"\";\n\t\t\t\tString[] result = new String[options.length - i];\n\t\t\t\tfor (int j = i; j \u003c options.length; j++) {\n\t\t\t\t\tresult[j - i] = options[j];\n\t\t\t\t\toptions[j] = \"\";\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn new String[0];\n\t}\n\n\t/**\n\t * The inverse operation of backQuoteChars(). Converts back-quoted carriage returns and new lines in a string to the corresponding character ('\\r' and '\\n'). Also \"un\"-back-quotes the following characters: ` \" \\ \\t and %\n\t * \n\t * @param string\n\t *            the string\n\t * @return the converted string\n\t * @see #backQuoteChars(String)\n\t */\n\tpublic static String unbackQuoteChars(String string) {\n\n\t\tint index;\n\t\tStringBuffer newStringBuffer;\n\n\t\t// replace each of the following characters with the backquoted version\n\t\tString charsFind[] = { \"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\n\", \"\\\\r\", \"\\\\\\\"\", \"\\\\%\", \"\\\\u001E\" };\n\t\tchar charsReplace[] = { '\\\\', '\\'', '\\t', '\\n', '\\r', '\"', '%', '\\u001E' };\n\t\tint pos[] = new int[charsFind.length];\n\t\tint curPos;\n\n\t\tString str = new String(string);\n\t\tnewStringBuffer = new StringBuffer();\n\t\twhile (str.length() \u003e 0) {\n\t\t\t// get positions and closest character to replace\n\t\t\tcurPos = str.length();\n\t\t\tindex = -1;\n\t\t\tfor (int i = 0; i \u003c pos.length; i++) {\n\t\t\t\tpos[i] = str.indexOf(charsFind[i]);\n\t\t\t\tif ((pos[i] \u003e -1) \u0026\u0026 (pos[i] \u003c curPos)) {\n\t\t\t\t\tindex = i;\n\t\t\t\t\tcurPos = pos[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// replace character if found, otherwise finished\n\t\t\tif (index == -1) {\n\t\t\t\tnewStringBuffer.append(str);\n\t\t\t\tstr = \"\";\n\t\t\t} else {\n\t\t\t\tnewStringBuffer.append(str.substring(0, pos[index]));\n\t\t\t\tnewStringBuffer.append(charsReplace[index]);\n\t\t\t\tstr = str.substring(pos[index] + charsFind[index].length());\n\t\t\t}\n\t\t}\n\n\t\treturn newStringBuffer.toString();\n\t}\n\n\t/**\n\t * Split up a string containing options into an array of strings, one for each option.\n\t * \n\t * @param quotedOptionString\n\t *            the string containing the options\n\t * @return the array of options\n\t * @throws Exception\n\t *             in case of an unterminated string, unknown character or a parse error\n\t */\n\tpublic static String[] splitOptions(String quotedOptionString) throws Exception {\n\n\t\tVector\u003cString\u003e optionsVec = new Vector\u003cString\u003e();\n\t\tString str = new String(quotedOptionString);\n\t\tint i;\n\n\t\twhile (true) {\n\n\t\t\t//trimLeft \n\t\t\ti = 0;\n\t\t\twhile ((i \u003c str.length()) \u0026\u0026 (Character.isWhitespace(str.charAt(i))))\n\t\t\t\ti++;\n\t\t\tstr = str.substring(i);\n\n\t\t\t//stop when str is empty\n\t\t\tif (str.length() == 0)\n\t\t\t\tbreak;\n\n\t\t\t//if str start with a double quote\n\t\t\tif (str.charAt(0) == '\"') {\n\n\t\t\t\t//find the first not anti-slached double quote\n\t\t\t\ti = 1;\n\t\t\t\twhile (i \u003c str.length()) {\n\t\t\t\t\tif (str.charAt(i) == str.charAt(0))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (str.charAt(i) == '\\\\') {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tif (i \u003e= str.length())\n\t\t\t\t\t\t\tthrow new Exception(\"String should not finish with \\\\\");\n\t\t\t\t\t}\n\t\t\t\t\ti += 1;\n\t\t\t\t}\n\t\t\t\tif (i \u003e= str.length())\n\t\t\t\t\tthrow new Exception(\"Quote parse error.\");\n\n\t\t\t\t//add the founded string to the option vector (without quotes)\n\t\t\t\tString optStr = str.substring(1, i);\n\t\t\t\toptStr = unbackQuoteChars(optStr);\n\t\t\t\toptionsVec.addElement(optStr);\n\t\t\t\tstr = str.substring(i + 1);\n\t\t\t} else {\n\t\t\t\t//find first whiteSpace\n\t\t\t\ti = 0;\n\t\t\t\twhile ((i \u003c str.length()) \u0026\u0026 (!Character.isWhitespace(str.charAt(i))))\n\t\t\t\t\ti++;\n\n\t\t\t\t//add the founded string to the option vector\n\t\t\t\tString optStr = str.substring(0, i);\n\t\t\t\toptionsVec.addElement(optStr);\n\t\t\t\tstr = str.substring(i);\n\t\t\t}\n\t\t}\n\n\t\t//convert optionsVec to an array of String\n\t\tString[] options = new String[optionsVec.size()];\n\t\tfor (i = 0; i \u003c optionsVec.size(); i++) {\n\t\t\toptions[i] = (String) optionsVec.elementAt(i);\n\t\t}\n\t\treturn options;\n\t}\n\n\t/**\n\t * Joins all the options in an option array into a single string, as might be used on the command line.\n\t * \n\t * @param optionArray\n\t *            the array of options\n\t * @return the string containing all options.\n\t */\n\tpublic static String joinOptions(String[] optionArray) {\n\n\t\tString optionString = \"\";\n\t\tfor (int i = 0; i \u003c optionArray.length; i++) {\n\t\t\tif (optionArray[i].equals(\"\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean escape = false;\n\t\t\tfor (int n = 0; n \u003c optionArray[i].length(); n++) {\n\t\t\t\tif (Character.isWhitespace(optionArray[i].charAt(n))) {\n\t\t\t\t\tescape = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (escape) {\n\t\t\t\toptionString += '\"' + backQuoteChars(optionArray[i]) + '\"';\n\t\t\t} else {\n\t\t\t\toptionString += optionArray[i];\n\t\t\t}\n\t\t\toptionString += \" \";\n\t\t}\n\t\treturn optionString.trim();\n\t}\n\n\t/**\n\t * Creates a new instance of an object given it's class name and (optional) arguments to pass to it's setOptions method. If the object implements OptionHandler and the options parameter is non-null, the object will have it's options set. Example use:\n\t * \u003cp\u003e\n\t * \n\t * \u003ccode\u003e \u003cpre\u003e\n\t * String classifierName = Utils.getOption('W', options);\n\t * Classifier c = (Classifier)Utils.forName(Classifier.class,\n\t *                                          classifierName,\n\t *                                          options);\n\t * setClassifier(c);\n\t * \u003c/pre\u003e\u003c/code\u003e\n\t * \n\t * @param classType\n\t *            the class that the instantiated object should be assignable to -- an exception is thrown if this is not the case\n\t * @param className\n\t *            the fully qualified class name of the object\n\t * @param options\n\t *            an array of options suitable for passing to setOptions. May be null. Any options accepted by the object will be removed from the array.\n\t * @return the newly created object, ready for use.\n\t * @exception Exception\n\t *                if the class name is invalid, or if the class is not assignable to the desired class type, or the options supplied are not acceptable to the object\n\t */\n\tpublic static Object forName(Class\u003c?\u003e classType, String className, String[] options) throws Exception {\n\n\t\tClass\u003c?\u003e c = null;\n\t\ttry {\n\t\t\tc = Class.forName(className);\n\t\t} catch (Exception ex) {\n\t\t\tthrow new Exception(\"Can't find class called: \" + className);\n\t\t}\n\t\tif (!classType.isAssignableFrom(c)) {\n\t\t\tthrow new Exception(classType.getName() + \" is not assignable from \" + className);\n\t\t}\n\t\tObject o = c.newInstance();\n\t\tif ((o instanceof OptionHandler) \u0026\u0026 (options != null)) {\n\t\t\t((OptionHandler) o).setOptions(options);\n\t\t\tUtils.checkForRemainingOptions(options);\n\t\t}\n\t\treturn o;\n\t}\n\n\t/**\n\t * Generates a commandline of the given object. If the object is not implementing OptionHandler, then it will only return the classname, otherwise also the options.\n\t * \n\t * @param obj\n\t *            the object to turn into a commandline\n\t * @return the commandline\n\t */\n\tpublic static String toCommandLine(Object obj) {\n\t\tStringBuffer result;\n\n\t\tresult = new StringBuffer();\n\n\t\tif (obj != null) {\n\t\t\tresult.append(obj.getClass().getName());\n\t\t\tif (obj instanceof OptionHandler)\n\t\t\t\tresult.append(\" \" + joinOptions(((OptionHandler) obj).getOptions()));\n\t\t}\n\n\t\treturn result.toString().trim();\n\t}\n\n\t/**\n\t * Computes entropy for an array of integers.\n\t * \n\t * @param counts\n\t *            array of counts\n\t * @return - a log2 a - b log2 b - c log2 c + (a+b+c) log2 (a+b+c) when given array [a b c]\n\t */\n\tpublic static/*@pure@*/double info(int counts[]) {\n\n\t\tint total = 0;\n\t\tdouble x = 0;\n\t\tfor (int j = 0; j \u003c counts.length; j++) {\n\t\t\tx -= xlogx(counts[j]);\n\t\t\ttotal += counts[j];\n\t\t}\n\t\treturn x + xlogx(total);\n\t}\n\n\t/**\n\t * Tests if a is smaller or equal to b.\n\t * \n\t * @param a\n\t *            a double\n\t * @param b\n\t *            a double\n\t */\n\tpublic static/*@pure@*/boolean smOrEq(double a, double b) {\n\n\t\treturn (a - b \u003c SMALL) || (a \u003c= b);\n\t}\n\n\t/**\n\t * Tests if a is greater or equal to b.\n\t * \n\t * @param a\n\t *            a double\n\t * @param b\n\t *            a double\n\t */\n\tpublic static/*@pure@*/boolean grOrEq(double a, double b) {\n\n\t\treturn (b - a \u003c SMALL) || (a \u003e= b);\n\t}\n\n\t/**\n\t * Tests if a is smaller than b.\n\t * \n\t * @param a\n\t *            a double\n\t * @param b\n\t *            a double\n\t */\n\tpublic static/*@pure@*/boolean sm(double a, double b) {\n\n\t\treturn (b - a \u003e SMALL);\n\t}\n\n\t/**\n\t * Tests if a is greater than b.\n\t * \n\t * @param a\n\t *            a double\n\t * @param b\n\t *            a double\n\t */\n\tpublic static/*@pure@*/boolean gr(double a, double b) {\n\n\t\treturn (a - b \u003e SMALL);\n\t}\n\n\t/**\n\t * Returns the kth-smallest value in the array.\n\t * \n\t * @param array\n\t *            the array of integers\n\t * @param k\n\t *            the value of k\n\t * @return the kth-smallest value\n\t */\n\tpublic static int kthSmallestValue(int[] array, int k) {\n\n\t\tint[] index = initialIndex(array.length);\n\t\treturn array[index[select(array, index, 0, array.length - 1, k)]];\n\t}\n\n\t/**\n\t * Returns the kth-smallest value in the array\n\t * \n\t * @param array\n\t *            the array of double\n\t * @param k\n\t *            the value of k\n\t * @return the kth-smallest value\n\t */\n\tpublic static double kthSmallestValue(double[] array, int k) {\n\n\t\tint[] index = initialIndex(array.length);\n\t\treturn array[index[select(array, index, 0, array.length - 1, k)]];\n\t}\n\n\t/**\n\t * Returns the logarithm of a for base 2.\n\t * \n\t * @param a\n\t *            a double\n\t * @return the logarithm for base 2\n\t */\n\tpublic static/*@pure@*/double log2(double a) {\n\n\t\treturn Math.log(a) / log2;\n\t}\n\n\t/**\n\t * Returns index of maximum element in a given array of doubles. First maximum is returned.\n\t * \n\t * @param doubles\n\t *            the array of doubles\n\t * @return the index of the maximum element\n\t */\n\tpublic static/*@pure@*/int maxIndex(double[] doubles) {\n\n\t\tdouble maximum = 0;\n\t\tint maxIndex = 0;\n\n\t\tfor (int i = 0; i \u003c doubles.length; i++) {\n\t\t\tif ((i == 0) || (doubles[i] \u003e maximum)) {\n\t\t\t\tmaxIndex = i;\n\t\t\t\tmaximum = doubles[i];\n\t\t\t}\n\t\t}\n\n\t\treturn maxIndex;\n\t}\n\n\t/**\n\t * Returns index of maximum element in a given array of integers. First maximum is returned.\n\t * \n\t * @param ints\n\t *            the array of integers\n\t * @return the index of the maximum element\n\t */\n\tpublic static/*@pure@*/int maxIndex(int[] ints) {\n\n\t\tint maximum = 0;\n\t\tint maxIndex = 0;\n\n\t\tfor (int i = 0; i \u003c ints.length; i++) {\n\t\t\tif ((i == 0) || (ints[i] \u003e maximum)) {\n\t\t\t\tmaxIndex = i;\n\t\t\t\tmaximum = ints[i];\n\t\t\t}\n\t\t}\n\n\t\treturn maxIndex;\n\t}\n\n\t/**\n\t * Computes the mean for an array of doubles.\n\t * \n\t * @param vector\n\t *            the array\n\t * @return the mean\n\t */\n\tpublic static/*@pure@*/double mean(double[] vector) {\n\n\t\tdouble sum = 0;\n\n\t\tif (vector.length == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (int i = 0; i \u003c vector.length; i++) {\n\t\t\tsum += vector[i];\n\t\t}\n\t\treturn sum / (double) vector.length;\n\t}\n\n\t/**\n\t * Returns index of minimum element in a given array of integers. First minimum is returned.\n\t * \n\t * @param ints\n\t *            the array of integers\n\t * @return the index of the minimum element\n\t */\n\tpublic static/*@pure@*/int minIndex(int[] ints) {\n\n\t\tint minimum = 0;\n\t\tint minIndex = 0;\n\n\t\tfor (int i = 0; i \u003c ints.length; i++) {\n\t\t\tif ((i == 0) || (ints[i] \u003c minimum)) {\n\t\t\t\tminIndex = i;\n\t\t\t\tminimum = ints[i];\n\t\t\t}\n\t\t}\n\n\t\treturn minIndex;\n\t}\n\n\t/**\n\t * Returns index of minimum element in a given array of doubles. First minimum is returned.\n\t * \n\t * @param doubles\n\t *            the array of doubles\n\t * @return the index of the minimum element\n\t */\n\tpublic static/*@pure@*/int minIndex(double[] doubles) {\n\n\t\tdouble minimum = 0;\n\t\tint minIndex = 0;\n\n\t\tfor (int i = 0; i \u003c doubles.length; i++) {\n\t\t\tif ((i == 0) || (doubles[i] \u003c minimum)) {\n\t\t\t\tminIndex = i;\n\t\t\t\tminimum = doubles[i];\n\t\t\t}\n\t\t}\n\n\t\treturn minIndex;\n\t}\n\n\t/**\n\t * Normalizes the doubles in the array by their sum.\n\t * \n\t * @param doubles\n\t *            the array of double\n\t * @exception IllegalArgumentException\n\t *                if sum is Zero or NaN\n\t */\n\tpublic static void normalize(double[] doubles) {\n\n\t\tdouble sum = 0;\n\t\tfor (int i = 0; i \u003c doubles.length; i++) {\n\t\t\tsum += doubles[i];\n\t\t}\n\t\tnormalize(doubles, sum);\n\t}\n\n\t/**\n\t * Normalizes the doubles in the array using the given value.\n\t * \n\t * @param doubles\n\t *            the array of double\n\t * @param sum\n\t *            the value by which the doubles are to be normalized\n\t * @exception IllegalArgumentException\n\t *                if sum is zero or NaN\n\t */\n\tpublic static void normalize(double[] doubles, double sum) {\n\n\t\tif (Double.isNaN(sum)) {\n\t\t\tthrow new IllegalArgumentException(\"Can't normalize array. Sum is NaN.\");\n\t\t}\n\t\tif (sum == 0) {\n\t\t\t// Maybe this should just be a return.\n\t\t\tthrow new IllegalArgumentException(\"Can't normalize array. Sum is zero.\");\n\t\t}\n\t\tfor (int i = 0; i \u003c doubles.length; i++) {\n\t\t\tdoubles[i] /= sum;\n\t\t}\n\t}\n\n\t/**\n\t * Converts an array containing the natural logarithms of probabilities stored in a vector back into probabilities. The probabilities are assumed to sum to one.\n\t * \n\t * @param a\n\t *            an array holding the natural logarithms of the probabilities\n\t * @return the converted array\n\t */\n\tpublic static double[] logs2probs(double[] a) {\n\n\t\tdouble max = a[maxIndex(a)];\n\t\tdouble sum = 0.0;\n\n\t\tdouble[] result = new double[a.length];\n\t\tfor (int i = 0; i \u003c a.length; i++) {\n\t\t\tresult[i] = Math.exp(a[i] - max);\n\t\t\tsum += result[i];\n\t\t}\n\n\t\tnormalize(result, sum);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns the log-odds for a given probabilitiy.\n\t * \n\t * @param prob\n\t *            the probabilitiy\n\t * \n\t * @return the log-odds after the probability has been mapped to [Utils.SMALL, 1-Utils.SMALL]\n\t */\n\tpublic static/*@pure@*/double probToLogOdds(double prob) {\n\n\t\tif (gr(prob, 1) || (sm(prob, 0))) {\n\t\t\tthrow new IllegalArgumentException(\"probToLogOdds: probability must \" + \"be in [0,1] \" + prob);\n\t\t}\n\t\tdouble p = SMALL + (1.0 - 2 * SMALL) * prob;\n\t\treturn Math.log(p / (1 - p));\n\t}\n\n\t/**\n\t * Rounds a double to the next nearest integer value. The JDK version of it doesn't work properly.\n\t * \n\t * @param value\n\t *            the double value\n\t * @return the resulting integer value\n\t */\n\tpublic static/*@pure@*/int round(double value) {\n\n\t\tint roundedValue = value \u003e 0 ? (int) (value + 0.5) : -(int) (Math.abs(value) + 0.5);\n\n\t\treturn roundedValue;\n\t}\n\n\t/**\n\t * Rounds a double to the next nearest integer value in a probabilistic fashion (e.g. 0.8 has a 20% chance of being rounded down to 0 and a 80% chance of being rounded up to 1). In the limit, the average of the rounded numbers generated by this procedure should converge to the original double.\n\t * \n\t * @param value\n\t *            the double value\n\t * @param rand\n\t *            the random number generator\n\t * @return the resulting integer value\n\t */\n\tpublic static int probRound(double value, Random rand) {\n\n\t\tif (value \u003e= 0) {\n\t\t\tdouble lower = Math.floor(value);\n\t\t\tdouble prob = value - lower;\n\t\t\tif (rand.nextDouble() \u003c prob) {\n\t\t\t\treturn (int) lower + 1;\n\t\t\t} else {\n\t\t\t\treturn (int) lower;\n\t\t\t}\n\t\t} else {\n\t\t\tdouble lower = Math.floor(Math.abs(value));\n\t\t\tdouble prob = Math.abs(value) - lower;\n\t\t\tif (rand.nextDouble() \u003c prob) {\n\t\t\t\treturn -((int) lower + 1);\n\t\t\t} else {\n\t\t\t\treturn -(int) lower;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Replaces all \"missing values\" in the given array of double values with MAX_VALUE.\n\t * \n\t * @param array\n\t *            the array to be modified.\n\t */\n\tpublic static void replaceMissingWithMAX_VALUE(double[] array) {\n\n\t\tfor (int i = 0; i \u003c array.length; i++) {\n\t\t\tif (isMissingValue(array[i])) {\n\t\t\t\tarray[i] = Double.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Rounds a double to the given number of decimal places.\n\t * \n\t * @param value\n\t *            the double value\n\t * @param afterDecimalPoint\n\t *            the number of digits after the decimal point\n\t * @return the double rounded to the given precision\n\t */\n\tpublic static/*@pure@*/double roundDouble(double value, int afterDecimalPoint) {\n\n\t\tdouble mask = Math.pow(10.0, (double) afterDecimalPoint);\n\n\t\treturn (double) (Math.round(value * mask)) / mask;\n\t}\n\n\t/**\n\t * Sorts a given array of integers in ascending order and returns an array of integers with the positions of the elements of the original array in the sorted array. The sort is stable. (Equal elements remain in their original order.)\n\t * \n\t * @param array\n\t *            this array is not changed by the method!\n\t * @return an array of integers with the positions in the sorted array.\n\t */\n\tpublic static/*@pure@*/int[] sort(int[] array) {\n\n\t\tint[] index = initialIndex(array.length);\n\t\tint[] newIndex = new int[array.length];\n\t\tint[] helpIndex;\n\t\tint numEqual;\n\n\t\tquickSort(array, index, 0, array.length - 1);\n\n\t\t// Make sort stable\n\t\tint i = 0;\n\t\twhile (i \u003c index.length) {\n\t\t\tnumEqual = 1;\n\t\t\tfor (int j = i + 1; ((j \u003c index.length) \u0026\u0026 (array[index[i]] == array[index[j]])); j++) {\n\t\t\t\tnumEqual++;\n\t\t\t}\n\t\t\tif (numEqual \u003e 1) {\n\t\t\t\thelpIndex = new int[numEqual];\n\t\t\t\tfor (int j = 0; j \u003c numEqual; j++) {\n\t\t\t\t\thelpIndex[j] = i + j;\n\t\t\t\t}\n\t\t\t\tquickSort(index, helpIndex, 0, numEqual - 1);\n\t\t\t\tfor (int j = 0; j \u003c numEqual; j++) {\n\t\t\t\t\tnewIndex[i + j] = index[helpIndex[j]];\n\t\t\t\t}\n\t\t\t\ti += numEqual;\n\t\t\t} else {\n\t\t\t\tnewIndex[i] = index[i];\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn newIndex;\n\t}\n\n\t/**\n\t * Sorts a given array of doubles in ascending order and returns an array of integers with the positions of the elements of the original array in the sorted array. NOTE THESE CHANGES: the sort is no longer stable and it doesn't use safe floating-point comparisons anymore. Occurrences of Double.NaN are treated as Double.MAX_VALUE.\n\t * \n\t * @param array\n\t *            this array is not changed by the method!\n\t * @return an array of integers with the positions in the sorted array.\n\t */\n\tpublic static/*@pure@*/int[] sort(/*@non_null@*/double[] array) {\n\n\t\tint[] index = initialIndex(array.length);\n\t\tif (array.length \u003e 1) {\n\t\t\tarray = (double[]) array.clone();\n\t\t\treplaceMissingWithMAX_VALUE(array);\n\t\t\tquickSort(array, index, 0, array.length - 1);\n\t\t}\n\t\treturn index;\n\t}\n\n\t/**\n\t * Sorts a given array of doubles in ascending order and returns an array of integers with the positions of the elements of the original array in the sorted array. Missing values in the given array are replaced by Double.MAX_VALUE, so the array is modified in that case!\n\t * \n\t * @param array\n\t *            the array to be sorted, which is modified if it has missing values\n\t * @return an array of integers with the positions in the sorted array.\n\t */\n\tpublic static/*@pure@*/int[] sortWithNoMissingValues(/*@non_null@*/double[] array) {\n\n\t\tint[] index = initialIndex(array.length);\n\t\tif (array.length \u003e 1) {\n\t\t\tquickSort(array, index, 0, array.length - 1);\n\t\t}\n\t\treturn index;\n\t}\n\n\t/**\n\t * Sorts a given array of doubles in ascending order and returns an array of integers with the positions of the elements of the original array in the sorted array. The sort is stable (Equal elements remain in their original order.) Occurrences of Double.NaN are treated as Double.MAX_VALUE\n\t * \n\t * @param array\n\t *            this array is not changed by the method!\n\t * @return an array of integers with the positions in the sorted array.\n\t */\n\tpublic static/*@pure@*/int[] stableSort(double[] array) {\n\n\t\tint[] index = initialIndex(array.length);\n\n\t\tif (array.length \u003e 1) {\n\n\t\t\tint[] newIndex = new int[array.length];\n\t\t\tint[] helpIndex;\n\t\t\tint numEqual;\n\n\t\t\tarray = (double[]) array.clone();\n\t\t\treplaceMissingWithMAX_VALUE(array);\n\t\t\tquickSort(array, index, 0, array.length - 1);\n\n\t\t\t// Make sort stable\n\n\t\t\tint i = 0;\n\t\t\twhile (i \u003c index.length) {\n\t\t\t\tnumEqual = 1;\n\t\t\t\tfor (int j = i + 1; ((j \u003c index.length) \u0026\u0026 Utils.eq(array[index[i]], array[index[j]])); j++)\n\t\t\t\t\tnumEqual++;\n\t\t\t\tif (numEqual \u003e 1) {\n\t\t\t\t\thelpIndex = new int[numEqual];\n\t\t\t\t\tfor (int j = 0; j \u003c numEqual; j++)\n\t\t\t\t\t\thelpIndex[j] = i + j;\n\t\t\t\t\tquickSort(index, helpIndex, 0, numEqual - 1);\n\t\t\t\t\tfor (int j = 0; j \u003c numEqual; j++)\n\t\t\t\t\t\tnewIndex[i + j] = index[helpIndex[j]];\n\t\t\t\t\ti += numEqual;\n\t\t\t\t} else {\n\t\t\t\t\tnewIndex[i] = index[i];\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn newIndex;\n\t\t} else {\n\t\t\treturn index;\n\t\t}\n\t}\n\n\t/**\n\t * Computes the variance for an array of doubles.\n\t * \n\t * @param vector\n\t *            the array\n\t * @return the variance\n\t */\n\tpublic static/*@pure@*/double variance(double[] vector) {\n\n\t\tdouble sum = 0, sumSquared = 0;\n\n\t\tif (vector.length \u003c= 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (int i = 0; i \u003c vector.length; i++) {\n\t\t\tsum += vector[i];\n\t\t\tsumSquared += (vector[i] * vector[i]);\n\t\t}\n\t\tdouble result = (sumSquared - (sum * sum / (double) vector.length)) / (double) (vector.length - 1);\n\n\t\t// We don't like negative variance\n\t\tif (result \u003c 0) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/**\n\t * Computes the sum of the elements of an array of doubles.\n\t * \n\t * @param doubles\n\t *            the array of double\n\t * @return the sum of the elements\n\t */\n\tpublic static/*@pure@*/double sum(double[] doubles) {\n\n\t\tdouble sum = 0;\n\n\t\tfor (int i = 0; i \u003c doubles.length; i++) {\n\t\t\tsum += doubles[i];\n\t\t}\n\t\treturn sum;\n\t}\n\n\t/**\n\t * Computes the sum of the elements of an array of integers.\n\t * \n\t * @param ints\n\t *            the array of integers\n\t * @return the sum of the elements\n\t */\n\tpublic static/*@pure@*/int sum(int[] ints) {\n\n\t\tint sum = 0;\n\n\t\tfor (int i = 0; i \u003c ints.length; i++) {\n\t\t\tsum += ints[i];\n\t\t}\n\t\treturn sum;\n\t}\n\n\t/**\n\t * Returns c*log2(c) for a given integer value c.\n\t * \n\t * @param c\n\t *            an integer value\n\t * @return c*log2(c) (but is careful to return 0 if c is 0)\n\t */\n\tpublic static/*@pure@*/double xlogx(int c) {\n\n\t\tif (c == 0) {\n\t\t\treturn 0.0;\n\t\t}\n\t\treturn c * Utils.log2((double) c);\n\t}\n\n\t/**\n\t * Initial index, filled with values from 0 to size - 1.\n\t */\n\tprivate static int[] initialIndex(int size) {\n\n\t\tint[] index = new int[size];\n\t\tfor (int i = 0; i \u003c size; i++) {\n\t\t\tindex[i] = i;\n\t\t}\n\t\treturn index;\n\t}\n\n\t/**\n\t * Sorts left, right, and center elements only, returns resulting center as pivot.\n\t */\n\tprivate static int sortLeftRightAndCenter(double[] array, int[] index, int l, int r) {\n\n\t\tint c = (l + r) / 2;\n\t\tconditionalSwap(array, index, l, c);\n\t\tconditionalSwap(array, index, l, r);\n\t\tconditionalSwap(array, index, c, r);\n\t\treturn c;\n\t}\n\n\t/**\n\t * Swaps two elements in the given integer array.\n\t */\n\tprivate static void swap(int[] index, int l, int r) {\n\n\t\tint help = index[l];\n\t\tindex[l] = index[r];\n\t\tindex[r] = help;\n\t}\n\n\t/**\n\t * Conditional swap for quick sort.\n\t */\n\tprivate static void conditionalSwap(double[] array, int[] index, int left, int right) {\n\n\t\tif (array[index[left]] \u003e array[index[right]]) {\n\t\t\tint help = index[left];\n\t\t\tindex[left] = index[right];\n\t\t\tindex[right] = help;\n\t\t}\n\t}\n\n\t/**\n\t * Partitions the instances around a pivot. Used by quicksort and kthSmallestValue.\n\t * \n\t * @param array\n\t *            the array of doubles to be sorted\n\t * @param index\n\t *            the index into the array of doubles\n\t * @param l\n\t *            the first index of the subset\n\t * @param r\n\t *            the last index of the subset\n\t * \n\t * @return the index of the middle element\n\t */\n\tprivate static int partition(double[] array, int[] index, int l, int r, double pivot) {\n\n\t\tr--;\n\t\twhile (true) {\n\t\t\twhile ((array[index[++l]] \u003c pivot))\n\t\t\t\t;\n\t\t\twhile ((array[index[--r]] \u003e pivot))\n\t\t\t\t;\n\t\t\tif (l \u003e= r) {\n\t\t\t\treturn l;\n\t\t\t}\n\t\t\tswap(index, l, r);\n\t\t}\n\t}\n\n\t/**\n\t * Partitions the instances around a pivot. Used by quicksort and kthSmallestValue.\n\t * \n\t * @param array\n\t *            the array of integers to be sorted\n\t * @param index\n\t *            the index into the array of integers\n\t * @param l\n\t *            the first index of the subset\n\t * @param r\n\t *            the last index of the subset\n\t * \n\t * @return the index of the middle element\n\t */\n\tprivate static int partition(int[] array, int[] index, int l, int r) {\n\n\t\tdouble pivot = array[index[(l + r) / 2]];\n\t\tint help;\n\n\t\twhile (l \u003c r) {\n\t\t\twhile ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\n\t\t\t\tl++;\n\t\t\t}\n\t\t\twhile ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tif (l \u003c r) {\n\t\t\t\thelp = index[l];\n\t\t\t\tindex[l] = index[r];\n\t\t\t\tindex[r] = help;\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t}\n\t\tif ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\n\t\t\tr--;\n\t\t}\n\n\t\treturn r;\n\t}\n\n\t/**\n\t * Implements quicksort with median-of-three method and explicit sort for problems of size three or less.\n\t * \n\t * @param array\n\t *            the array of doubles to be sorted\n\t * @param index\n\t *            the index into the array of doubles\n\t * @param left\n\t *            the first index of the subset to be sorted\n\t * @param right\n\t *            the last index of the subset to be sorted\n\t */\n\t//@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n\t//@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\n\t//@ requires array != index;\n\t//  assignable index;\n\tprivate static void quickSort(/*@non_null@*/double[] array, /*@non_null@*/int[] index, int left, int right) {\n\n\t\tint diff = right - left;\n\n\t\tswitch (diff) {\n\t\tcase 0:\n\n\t\t\t// No need to do anything\n\t\t\treturn;\n\t\tcase 1:\n\n\t\t\t// Swap two elements if necessary\n\t\t\tconditionalSwap(array, index, left, right);\n\t\t\treturn;\n\t\tcase 2:\n\n\t\t\t// Just need to sort three elements\n\t\t\tconditionalSwap(array, index, left, left + 1);\n\t\t\tconditionalSwap(array, index, left, right);\n\t\t\tconditionalSwap(array, index, left + 1, right);\n\t\t\treturn;\n\t\tdefault:\n\n\t\t\t// Establish pivot\n\t\t\tint pivotLocation = sortLeftRightAndCenter(array, index, left, right);\n\n\t\t\t// Move pivot to the right, partition, and restore pivot\n\t\t\tswap(index, pivotLocation, right - 1);\n\t\t\tint center = partition(array, index, left, right, array[index[right - 1]]);\n\t\t\tswap(index, center, right - 1);\n\n\t\t\t// Sort recursively\n\t\t\tquickSort(array, index, left, center - 1);\n\t\t\tquickSort(array, index, center + 1, right);\n\t\t}\n\t}\n\n\t/**\n\t * Implements quicksort according to Manber's \"Introduction to Algorithms\".\n\t * \n\t * @param array\n\t *            the array of integers to be sorted\n\t * @param index\n\t *            the index into the array of integers\n\t * @param left\n\t *            the first index of the subset to be sorted\n\t * @param right\n\t *            the last index of the subset to be sorted\n\t */\n\t//@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n\t//@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\n\t//@ requires array != index;\n\t//  assignable index;\n\tprivate static void quickSort(/*@non_null@*/int[] array, /*@non_null@*/int[] index, int left, int right) {\n\n\t\tif (left \u003c right) {\n\t\t\tint middle = partition(array, index, left, right);\n\t\t\tquickSort(array, index, left, middle);\n\t\t\tquickSort(array, index, middle + 1, right);\n\t\t}\n\t}\n\n\t/**\n\t * Implements computation of the kth-smallest element according to Manber's \"Introduction to Algorithms\".\n\t * \n\t * @param array\n\t *            the array of double\n\t * @param index\n\t *            the index into the array of doubles\n\t * @param left\n\t *            the first index of the subset\n\t * @param right\n\t *            the last index of the subset\n\t * @param k\n\t *            the value of k\n\t * \n\t * @return the index of the kth-smallest element\n\t */\n\t//@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n\tprivate static int select(/*@non_null@*/double[] array, /*@non_null@*/int[] index, int left, int right, int k) {\n\n\t\tint diff = right - left;\n\t\tswitch (diff) {\n\t\tcase 0:\n\n\t\t\t// Nothing to be done\n\t\t\treturn left;\n\t\tcase 1:\n\n\t\t\t// Swap two elements if necessary\n\t\t\tconditionalSwap(array, index, left, right);\n\t\t\treturn left + k - 1;\n\t\tcase 2:\n\n\t\t\t// Just need to sort three elements\n\t\t\tconditionalSwap(array, index, left, left + 1);\n\t\t\tconditionalSwap(array, index, left, right);\n\t\t\tconditionalSwap(array, index, left + 1, right);\n\t\t\treturn left + k - 1;\n\t\tdefault:\n\n\t\t\t// Establish pivot\n\t\t\tint pivotLocation = sortLeftRightAndCenter(array, index, left, right);\n\n\t\t\t// Move pivot to the right, partition, and restore pivot\n\t\t\tswap(index, pivotLocation, right - 1);\n\t\t\tint center = partition(array, index, left, right, array[index[right - 1]]);\n\t\t\tswap(index, center, right - 1);\n\n\t\t\t// Proceed recursively\n\t\t\tif ((center - left + 1) \u003e= k) {\n\t\t\t\treturn select(array, index, left, center, k);\n\t\t\t} else {\n\t\t\t\treturn select(array, index, center + 1, right, k - (center - left + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Converts a File's absolute path to a path relative to the user (ie start) directory. Includes an additional workaround for Cygwin, which doesn't like upper case drive letters.\n\t * \n\t * @param absolute\n\t *            the File to convert to relative path\n\t * @return a File with a path that is relative to the user's directory\n\t * @exception Exception\n\t *                if the path cannot be constructed\n\t */\n\tpublic static File convertToRelativePath(File absolute) throws Exception {\n\t\tFile result;\n\t\tString fileStr;\n\n\t\tresult = null;\n\n\t\t// if we're running windows, it could be Cygwin\n\t\tif (File.separator.equals(\"\\\\\")) {\n\t\t\t// Cygwin doesn't like upper case drives -\u003e try lower case drive\n\t\t\ttry {\n\t\t\t\tfileStr = absolute.getPath();\n\t\t\t\tfileStr = fileStr.substring(0, 1).toLowerCase() + fileStr.substring(1);\n\t\t\t\tresult = createRelativePath(new File(fileStr));\n\t\t\t} catch (Exception e) {\n\t\t\t\t// no luck with Cygwin workaround, convert it like it is\n\t\t\t\tresult = createRelativePath(absolute);\n\t\t\t}\n\t\t} else {\n\t\t\tresult = createRelativePath(absolute);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Converts a File's absolute path to a path relative to the user (ie start) directory.\n\t * \n\t * @param absolute\n\t *            the File to convert to relative path\n\t * @return a File with a path that is relative to the user's directory\n\t * @exception Exception\n\t *                if the path cannot be constructed\n\t */\n\tprotected static File createRelativePath(File absolute) throws Exception {\n\t\tFile userDir = new File(System.getProperty(\"user.dir\"));\n\t\tString userPath = userDir.getAbsolutePath() + File.separator;\n\t\tString targetPath = (new File(absolute.getParent())).getPath() + File.separator;\n\t\tString fileName = absolute.getName();\n\t\tStringBuffer relativePath = new StringBuffer();\n\t\t//    relativePath.append(\".\"+File.separator);\n\t\t//    System.err.println(\"User dir \"+userPath);\n\t\t//    System.err.println(\"Target path \"+targetPath);\n\n\t\t// file is in user dir (or subdir)\n\t\tint subdir = targetPath.indexOf(userPath);\n\t\tif (subdir == 0) {\n\t\t\tif (userPath.length() == targetPath.length()) {\n\t\t\t\trelativePath.append(fileName);\n\t\t\t} else {\n\t\t\t\tint ll = userPath.length();\n\t\t\t\trelativePath.append(targetPath.substring(ll));\n\t\t\t\trelativePath.append(fileName);\n\t\t\t}\n\t\t} else {\n\t\t\tint sepCount = 0;\n\t\t\tString temp = new String(userPath);\n\t\t\twhile (temp.indexOf(File.separator) != -1) {\n\t\t\t\tint ind = temp.indexOf(File.separator);\n\t\t\t\tsepCount++;\n\t\t\t\ttemp = temp.substring(ind + 1, temp.length());\n\t\t\t}\n\n\t\t\tString targetTemp = new String(targetPath);\n\t\t\tString userTemp = new String(userPath);\n\t\t\tint tcount = 0;\n\t\t\twhile (targetTemp.indexOf(File.separator) != -1) {\n\t\t\t\tint ind = targetTemp.indexOf(File.separator);\n\t\t\t\tint ind2 = userTemp.indexOf(File.separator);\n\t\t\t\tString tpart = targetTemp.substring(0, ind + 1);\n\t\t\t\tString upart = userTemp.substring(0, ind2 + 1);\n\t\t\t\tif (tpart.compareTo(upart) != 0) {\n\t\t\t\t\tif (tcount == 0) {\n\t\t\t\t\t\ttcount = -1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttcount++;\n\t\t\t\ttargetTemp = targetTemp.substring(ind + 1, targetTemp.length());\n\t\t\t\tuserTemp = userTemp.substring(ind2 + 1, userTemp.length());\n\t\t\t}\n\t\t\tif (tcount == -1) {\n\t\t\t\t// then target file is probably on another drive (under windows)\n\t\t\t\tthrow new Exception(\"Can't construct a path to file relative to user \" + \"dir.\");\n\t\t\t}\n\t\t\tif (targetTemp.indexOf(File.separator) == -1) {\n\t\t\t\ttargetTemp = \"\";\n\t\t\t}\n\t\t\tfor (int i = 0; i \u003c sepCount - tcount; i++) {\n\t\t\t\trelativePath.append(\"..\" + File.separator);\n\t\t\t}\n\t\t\trelativePath.append(targetTemp + fileName);\n\t\t}\n\t\t//    System.err.println(\"new path : \"+relativePath.toString());\n\t\treturn new File(relativePath.toString());\n\t}\n\n\t/**\n\t * Implements computation of the kth-smallest element according to Manber's \"Introduction to Algorithms\".\n\t * \n\t * @param array\n\t *            the array of integers\n\t * @param index\n\t *            the index into the array of integers\n\t * @param left\n\t *            the first index of the subset\n\t * @param right\n\t *            the last index of the subset\n\t * @param k\n\t *            the value of k\n\t * \n\t * @return the index of the kth-smallest element\n\t */\n\t//@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n\tprivate static int select(/*@non_null@*/int[] array, /*@non_null@*/int[] index, int left, int right, int k) {\n\n\t\tif (left == right) {\n\t\t\treturn left;\n\t\t} else {\n\t\t\tint middle = partition(array, index, left, right);\n\t\t\tif ((middle - left + 1) \u003e= k) {\n\t\t\t\treturn select(array, index, left, middle, k);\n\t\t\t} else {\n\t\t\t\treturn select(array, index, middle + 1, right, k - (middle - left + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * For a named dialog, returns true if the user has opted not to view it again in the future.\n\t * \n\t * @param dialogName\n\t *            the name of the dialog to check (e.g. weka.gui.GUICHooser.HowToFindPackageManager).\n\t * @return true if the user has opted not to view the named dialog in the future.\n\t */\n\tpublic static boolean getDontShowDialog(String dialogName) {\n\t\t/*\t\tFile wekaHome = WekaPackageManager.WEKA_HOME;\n\n\t\t\t\tif (!wekaHome.exists()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tFile dialogSubDir = new File(wekaHome.toString() + File.separator + \"systemDialogs\");\n\t\t\t\tif (!dialogSubDir.exists()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tFile dialogFile = new File(dialogSubDir.toString() + File.separator + dialogName);\n\n\t\t\t\treturn dialogFile.exists();*/\n\t\treturn false;\n\t}\n\n\t/**\n\t * Specify that the named dialog is not to be displayed in the future.\n\t * \n\t * @param dialogName\n\t *            the name of the dialog not to show again (e.g. weka.gui.GUIChooser.HowToFindPackageManager).\n\t * @throws Exception\n\t *             if the marker file that is used to indicate that a named dialog is not to be shown can't be created. This file lives in $WEKA_HOME/systemDialogs\n\t */\n\tpublic static void setDontShowDialog(String dialogName) throws Exception {\n\t\t/*\t\tFile wekaHome = WekaPackageManager.WEKA_HOME;\n\n\t\t\t\tif (!wekaHome.exists()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tFile dialogSubDir = new File(wekaHome.toString() + File.separator + \"systemDialogs\");\n\t\t\t\tif (!dialogSubDir.exists()) {\n\t\t\t\t\tif (!dialogSubDir.mkdir()) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tFile dialogFile = new File(dialogSubDir.toString() + File.separator + dialogName);\n\t\t\t\tdialogFile.createNewFile();*/\n\t}\n\n\t/**\n\t * For a named dialog, if the user has opted not to view it again, returns the answer the answer the user supplied when they closed the dialog. Returns null if the user did opt to view the dialog again.\n\t * \n\t * @param dialogName\n\t *            the name of the dialog to check (e.g. weka.gui.GUICHooser.HowToFindPackageManager).\n\t * @return the answer the user supplied the last time they viewed the named dialog (if they opted not to view it again in the future) or null if the user opted to view the dialog again in the future.\n\t */\n\tpublic static String getDontShowDialogResponse(String dialogName) throws Exception {\n\t\t/*\tif (!getDontShowDialog(dialogName)) {\n\t\t\t\treturn null; // This must be the first time - no file recorded yet.\n\t\t\t}\n\n\t\t\tFile wekaHome = WekaPackageManager.WEKA_HOME;\n\t\t\tFile dialogSubDir = new File(wekaHome.toString() + File.separator + \"systemDialogs\" + File.separator + dialogName);\n\n\t\t\tBufferedReader br = new BufferedReader(new FileReader(dialogSubDir));\n\t\t\tString response = br.readLine();\n\n\t\t\tbr.close();\n\t\t\treturn response;*/\n\t\treturn null;\n\t}\n\n\t/**\n\t * Specify that the named dialog is not to be shown again in the future. Also records the answer that the user chose when closing the dialog.\n\t * \n\t * @param dialogName\n\t *            the name of the dialog to no longer display\n\t * @param response\n\t *            the user selected response when they closed the dialog\n\t * @throws Exception\n\t *             if there is a problem saving the information\n\t */\n\tpublic static void setDontShowDialogResponse(String dialogName, String response) throws Exception {\n\t\t/*\n\t\t\t\tFile wekaHome = WekaPackageManager.WEKA_HOME;\n\n\t\t\t\tif (!wekaHome.exists()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tFile dialogSubDir = new File(wekaHome.toString() + File.separator + \"systemDialogs\");\n\t\t\t\tif (!dialogSubDir.exists()) {\n\t\t\t\t\tif (!dialogSubDir.mkdir()) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tFile dialogFile = new File(dialogSubDir.toString() + File.separator + dialogName);\n\t\t\t\tBufferedWriter br = new BufferedWriter(new FileWriter(dialogFile));\n\t\t\t\tbr.write(response + \"\\n\");\n\t\t\t\tbr.flush();\n\t\t\t\tbr.close();*/\n\t}\n\n\t/**\n\t * Breaks up the string, if wider than \"columns\" characters.\n\t * \n\t * @param s\n\t *            the string to process\n\t * @param columns\n\t *            the width in columns\n\t * @return the processed string\n\t */\n\tpublic static String[] breakUp(String s, int columns) {\n\t\tVector\u003cString\u003e result;\n\t\tString line;\n\t\tBreakIterator boundary;\n\t\tint boundaryStart;\n\t\tint boundaryEnd;\n\t\tString word;\n\t\tString punctuation;\n\t\tint i;\n\t\tString[] lines;\n\n\t\tresult = new Vector\u003cString\u003e();\n\t\tpunctuation = \" .,;:!?'\\\"\";\n\t\tlines = s.split(\"\\n\");\n\n\t\tfor (i = 0; i \u003c lines.length; i++) {\n\t\t\tboundary = BreakIterator.getWordInstance();\n\t\t\tboundary.setText(lines[i]);\n\t\t\tboundaryStart = boundary.first();\n\t\t\tboundaryEnd = boundary.next();\n\t\t\tline = \"\";\n\n\t\t\twhile (boundaryEnd != BreakIterator.DONE) {\n\t\t\t\tword = lines[i].substring(boundaryStart, boundaryEnd);\n\t\t\t\tif (line.length() \u003e= columns) {\n\t\t\t\t\tif (word.length() == 1) {\n\t\t\t\t\t\tif (punctuation.indexOf(word.charAt(0)) \u003e -1) {\n\t\t\t\t\t\t\tline += word;\n\t\t\t\t\t\t\tword = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresult.add(line);\n\t\t\t\t\tline = \"\";\n\t\t\t\t}\n\t\t\t\tline += word;\n\t\t\t\tboundaryStart = boundaryEnd;\n\t\t\t\tboundaryEnd = boundary.next();\n\t\t\t}\n\t\t\tif (line.length() \u003e 0)\n\t\t\t\tresult.add(line);\n\t\t}\n\n\t\treturn result.toArray(new String[result.size()]);\n\t}\n\n\t/**\n\t * Returns the revision string.\n\t * \n\t * @return the revision\n\t */\n\tpublic String getRevision() {\n\t\treturn RevisionUtils.extract(\"$Revision: 9736 $\");\n\t}\n\n\t/**\n\t * Main method for testing this class.\n\t * \n\t * @param ops\n\t *            some dummy options\n\t */\n\tpublic static void main(String[] ops) {\n\n\t\tdouble[] doublesWithNaN = { 4.5, 6.7, Double.NaN, 3.4, 4.8, 1.2, 3.4 };\n\t\tdouble[] doubles = { 4.5, 6.7, 6.7, 3.4, 4.8, 1.2, 3.4, 6.7, 6.7, 3.4 };\n\t\tint[] ints = { 12, 6, 2, 18, 16, 6, 7, 5, 18, 18, 17 };\n\n\t\ttry {\n\n\t\t\t// Option handling\n\t\t\tSystem.out.println(\"First option split up:\");\n\t\t\tif (ops.length \u003e 0) {\n\t\t\t\tString[] firstOptionSplitUp = Utils.splitOptions(ops[0]);\n\t\t\t\tfor (int i = 0; i \u003c firstOptionSplitUp.length; i++) {\n\t\t\t\t\tSystem.out.println(firstOptionSplitUp[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"Partitioned options: \");\n\t\t\tString[] partitionedOptions = Utils.partitionOptions(ops);\n\t\t\tfor (int i = 0; i \u003c partitionedOptions.length; i++) {\n\t\t\t\tSystem.out.println(partitionedOptions[i]);\n\t\t\t}\n\t\t\tSystem.out.println(\"Get position of flag -f: \" + Utils.getOptionPos('f', ops));\n\t\t\tSystem.out.println(\"Get flag -f: \" + Utils.getFlag('f', ops));\n\t\t\tSystem.out.println(\"Get position of option -o: \" + Utils.getOptionPos('o', ops));\n\t\t\tSystem.out.println(\"Get option -o: \" + Utils.getOption('o', ops));\n\t\t\tSystem.out.println(\"Checking for remaining options... \");\n\t\t\tUtils.checkForRemainingOptions(ops);\n\n\t\t\t// Statistics\n\t\t\tSystem.out.println(\"Original array with NaN (doubles): \");\n\t\t\tfor (int i = 0; i \u003c doublesWithNaN.length; i++) {\n\t\t\t\tSystem.out.print(doublesWithNaN[i] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(\"Original array (doubles): \");\n\t\t\tfor (int i = 0; i \u003c doubles.length; i++) {\n\t\t\t\tSystem.out.print(doubles[i] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(\"Original array (ints): \");\n\t\t\tfor (int i = 0; i \u003c ints.length; i++) {\n\t\t\t\tSystem.out.print(ints[i] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(\"Correlation: \" + Utils.correlation(doubles, doubles, doubles.length));\n\t\t\tSystem.out.println(\"Mean: \" + Utils.mean(doubles));\n\t\t\tSystem.out.println(\"Variance: \" + Utils.variance(doubles));\n\t\t\tSystem.out.println(\"Sum (doubles): \" + Utils.sum(doubles));\n\t\t\tSystem.out.println(\"Sum (ints): \" + Utils.sum(ints));\n\t\t\tSystem.out.println(\"Max index (doubles): \" + Utils.maxIndex(doubles));\n\t\t\tSystem.out.println(\"Max index (ints): \" + Utils.maxIndex(ints));\n\t\t\tSystem.out.println(\"Min index (doubles): \" + Utils.minIndex(doubles));\n\t\t\tSystem.out.println(\"Min index (ints): \" + Utils.minIndex(ints));\n\t\t\tSystem.out.println(\"Median (doubles): \" + Utils.kthSmallestValue(doubles, doubles.length / 2));\n\t\t\tSystem.out.println(\"Median (ints): \" + Utils.kthSmallestValue(ints, ints.length / 2));\n\n\t\t\t// Sorting and normalizing\n\t\t\tSystem.out.println(\"Sorted array with NaN (doubles): \");\n\t\t\tint[] sorted = Utils.sort(doublesWithNaN);\n\t\t\tfor (int i = 0; i \u003c doublesWithNaN.length; i++) {\n\t\t\t\tSystem.out.print(doublesWithNaN[sorted[i]] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(\"Sorted array (doubles): \");\n\t\t\tsorted = Utils.sort(doubles);\n\t\t\tfor (int i = 0; i \u003c doubles.length; i++) {\n\t\t\t\tSystem.out.print(doubles[sorted[i]] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(\"Sorted array (ints): \");\n\t\t\tsorted = Utils.sort(ints);\n\t\t\tfor (int i = 0; i \u003c ints.length; i++) {\n\t\t\t\tSystem.out.print(ints[sorted[i]] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(\"Indices from stable sort (doubles): \");\n\t\t\tsorted = Utils.stableSort(doubles);\n\t\t\tfor (int i = 0; i \u003c doubles.length; i++) {\n\t\t\t\tSystem.out.print(sorted[i] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(\"Indices from sort (ints): \");\n\t\t\tsorted = Utils.sort(ints);\n\t\t\tfor (int i = 0; i \u003c ints.length; i++) {\n\t\t\t\tSystem.out.print(sorted[i] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(\"Normalized array (doubles): \");\n\t\t\tUtils.normalize(doubles);\n\t\t\tfor (int i = 0; i \u003c doubles.length; i++) {\n\t\t\t\tSystem.out.print(doubles[i] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(\"Normalized again (doubles): \");\n\t\t\tUtils.normalize(doubles, Utils.sum(doubles));\n\t\t\tfor (int i = 0; i \u003c doubles.length; i++) {\n\t\t\t\tSystem.out.print(doubles[i] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\n\t\t\t// Pretty-printing\n\t\t\tSystem.out.println(\"-4.58: \" + Utils.doubleToString(-4.57826535, 2));\n\t\t\tSystem.out.println(\"-6.78: \" + Utils.doubleToString(-6.78214234, 6, 2));\n\n\t\t\t// Comparisons\n\t\t\tSystem.out.println(\"5.70001 == 5.7 ? \" + Utils.eq(5.70001, 5.7));\n\t\t\tSystem.out.println(\"5.70001 \u003e 5.7 ? \" + Utils.gr(5.70001, 5.7));\n\t\t\tSystem.out.println(\"5.70001 \u003e= 5.7 ? \" + Utils.grOrEq(5.70001, 5.7));\n\t\t\tSystem.out.println(\"5.7 \u003c 5.70001 ? \" + Utils.sm(5.7, 5.70001));\n\t\t\tSystem.out.println(\"5.7 \u003c= 5.70001 ? \" + Utils.smOrEq(5.7, 5.70001));\n\n\t\t\t// Math\n\t\t\tSystem.out.println(\"Info (ints): \" + Utils.info(ints));\n\t\t\tSystem.out.println(\"log2(4.6): \" + Utils.log2(4.6));\n\t\t\tSystem.out.println(\"5 * log(5): \" + Utils.xlogx(5));\n\t\t\tSystem.out.println(\"5.5 rounded: \" + Utils.round(5.5));\n\t\t\tSystem.out.println(\"5.55555 rounded to 2 decimal places: \" + Utils.roundDouble(5.55555, 2));\n\n\t\t\t// Arrays\n\t\t\tSystem.out.println(\"Array-Dimensions of 'new int[][]': \" + Utils.getArrayDimensions(new int[][] {}));\n\t\t\tSystem.out.println(\"Array-Dimensions of 'new int[][]{{1,2,3},{4,5,6}}': \" + Utils.getArrayDimensions(new int[][] { { 1, 2, 3 }, { 4, 5, 6 } }));\n\t\t\tString[][][] s = new String[3][4][];\n\t\t\tSystem.out.println(\"Array-Dimensions of 'new String[3][4][]': \" + Utils.getArrayDimensions(s));\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n",
        "name": "Utils.java",
        "path": "weka-android/src/main/java/weka/core/Utils.java",
        "url": "/github.com/andrecamara/weka-android/-/blob/weka-android/src/main/java/weka/core/Utils.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 1766,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 1767,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);"
        },
        {
          "limitHit": false,
          "lineNumber": 1768,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires array != index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1819,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 1820,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);"
        },
        {
          "limitHit": false,
          "lineNumber": 1821,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires array != index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1848,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 2009,
          "offsetAndLengths": [
            [
              1,
              13
            ]
          ],
          "preview": "\t//@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        }
      ],
      "repository": {
        "name": "github.com/andrecamara/weka-android",
        "url": "/github.com/andrecamara/weka-android"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 170,
  "ElapsedMilliseconds": 1604,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
