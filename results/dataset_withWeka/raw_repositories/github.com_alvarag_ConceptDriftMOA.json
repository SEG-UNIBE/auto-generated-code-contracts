{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/alvarag/ConceptDriftMOA lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "356497793a5aa5d52768f34b9e1ff3ec3701ba33"
        },
        "content": "package utils;\r\n\r\npublic class Utils {\r\n    \r\n    /** The small deviation allowed in double comparisons */\r\n    public static double SMALL = 1e-6;\r\n    \r\n    /**\r\n     * Tests if a is equal to b.\r\n     *\r\n     * @param a a double\r\n     * @param b a double\r\n     */\r\n    public static /*@pure@*/ boolean eq(double a, double b){\r\n      \r\n      return (a - b \u003c SMALL) \u0026\u0026 (b - a \u003c SMALL); \r\n    }\r\n    \r\n    \r\n    /**\r\n     * Sorts a given array of integers in ascending order and returns an \r\n     * array of integers with the positions of the elements of the original \r\n     * array in the sorted array. The sort is stable. (Equal elements remain\r\n     * in their original order.)\r\n     *\r\n     * @param array this array is not changed by the method!\r\n     * @return an array of integers with the positions in the sorted\r\n     * array.\r\n     */\r\n    public static /*@pure@*/ int[] sort(int [] array) {\r\n\r\n      int [] index = new int[array.length];\r\n      int [] newIndex = new int[array.length];\r\n      int [] helpIndex;\r\n      int numEqual;\r\n      \r\n      for (int i = 0; i \u003c index.length; i++) {\r\n        index[i] = i;\r\n      }\r\n      quickSort(array, index, 0, array.length - 1);\r\n\r\n      // Make sort stable\r\n      int i = 0;\r\n      while (i \u003c index.length) {\r\n        numEqual = 1;\r\n        for (int j = i + 1; ((j \u003c index.length)\r\n               \u0026\u0026 (array[index[i]] == array[index[j]]));\r\n       j++) {\r\n    numEqual++;\r\n        }\r\n        if (numEqual \u003e 1) {\r\n    helpIndex = new int[numEqual];\r\n    for (int j = 0; j \u003c numEqual; j++) {\r\n      helpIndex[j] = i + j;\r\n    }\r\n    quickSort(index, helpIndex, 0, numEqual - 1);\r\n    for (int j = 0; j \u003c numEqual; j++) {\r\n      newIndex[i + j] = index[helpIndex[j]];\r\n    }\r\n    i += numEqual;\r\n        } else {\r\n    newIndex[i] = index[i];\r\n    i++;\r\n        }\r\n      }\r\n      return newIndex;\r\n    }\r\n\r\n    /**\r\n     * Sorts a given array of doubles in ascending order and returns an\r\n     * array of integers with the positions of the elements of the\r\n     * original array in the sorted array. NOTE THESE CHANGES: the sort\r\n     * is no longer stable and it doesn't use safe floating-point\r\n     * comparisons anymore. Occurrences of Double.NaN are treated as \r\n     * Double.MAX_VALUE\r\n     *\r\n     * @param array this array is not changed by the method!\r\n     * @return an array of integers with the positions in the sorted\r\n     * array.  \r\n     */\r\n    public static /*@pure@*/ int[] sort(/*@non_null@*/ double [] array) {\r\n\r\n      int [] index = new int[array.length];\r\n      array = (double [])array.clone();\r\n      for (int i = 0; i \u003c index.length; i++) {\r\n        index[i] = i;\r\n        if (Double.isNaN(array[i])) {\r\n          array[i] = Double.MAX_VALUE;\r\n        }\r\n      }\r\n      quickSort(array, index, 0, array.length - 1);\r\n      return index;\r\n    }\r\n\r\n    /**\r\n     * Sorts a given array of doubles in ascending order and returns an \r\n     * array of integers with the positions of the elements of the original \r\n     * array in the sorted array. The sort is stable (Equal elements remain\r\n     * in their original order.) Occurrences of Double.NaN are treated as \r\n     * Double.MAX_VALUE\r\n     *\r\n     * @param array this array is not changed by the method!\r\n     * @return an array of integers with the positions in the sorted\r\n     * array.\r\n     */\r\n    public static /*@pure@*/ int[] stableSort(double [] array){\r\n\r\n      int [] index = new int[array.length];\r\n      int [] newIndex = new int[array.length];\r\n      int [] helpIndex;\r\n      int numEqual;\r\n      \r\n      array = (double [])array.clone();\r\n      for (int i = 0; i \u003c index.length; i++) {\r\n        index[i] = i;\r\n        if (Double.isNaN(array[i])) {\r\n          array[i] = Double.MAX_VALUE;\r\n        }\r\n      }\r\n      quickSort(array,index,0,array.length-1);\r\n\r\n      // Make sort stable\r\n\r\n      int i = 0;\r\n      while (i \u003c index.length) {\r\n        numEqual = 1;\r\n        for (int j = i+1; ((j \u003c index.length) \u0026\u0026 Utils.eq(array[index[i]],\r\n                            array[index[j]])); j++)\r\n    numEqual++;\r\n        if (numEqual \u003e 1) {\r\n    helpIndex = new int[numEqual];\r\n    for (int j = 0; j \u003c numEqual; j++)\r\n      helpIndex[j] = i+j;\r\n    quickSort(index, helpIndex, 0, numEqual-1);\r\n    for (int j = 0; j \u003c numEqual; j++) \r\n      newIndex[i+j] = index[helpIndex[j]];\r\n    i += numEqual;\r\n        } else {\r\n    newIndex[i] = index[i];\r\n    i++;\r\n        }\r\n      }\r\n\r\n      return newIndex;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Implements quicksort according to Manber's \"Introduction to\r\n     * Algorithms\".\r\n     *\r\n     * @param array the array of doubles to be sorted\r\n     * @param index the index into the array of doubles\r\n     * @param left the first index of the subset to be sorted\r\n     * @param right the last index of the subset to be sorted\r\n     */\r\n    //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n    //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r\n    //@ requires array != index;\r\n    //  assignable index;\r\n    private static void quickSort(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \r\n                                  int left, int right) {\r\n\r\n      if (left \u003c right) {\r\n        int middle = partition(array, index, left, right);\r\n        quickSort(array, index, left, middle);\r\n        quickSort(array, index, middle + 1, right);\r\n      }\r\n    }\r\n    \r\n    /**\r\n     * Implements quicksort according to Manber's \"Introduction to\r\n     * Algorithms\".\r\n     *\r\n     * @param array the array of integers to be sorted\r\n     * @param index the index into the array of integers\r\n     * @param left the first index of the subset to be sorted\r\n     * @param right the last index of the subset to be sorted\r\n     */\r\n    //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r\n    //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r\n    //@ requires array != index;\r\n    //  assignable index;\r\n    private static void quickSort(/*@non_null@*/ int[] array, /*@non_null@*/  int[] index, \r\n                                  int left, int right) {\r\n\r\n      if (left \u003c right) {\r\n        int middle = partition(array, index, left, right);\r\n        quickSort(array, index, left, middle);\r\n        quickSort(array, index, middle + 1, right);\r\n      }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n     * Partitions the instances around a pivot. Used by quicksort and\r\n     * kthSmallestValue.\r\n     *\r\n     * @param array the array of doubles to be sorted\r\n     * @param index the index into the array of doubles\r\n     * @param left the first index of the subset \r\n     * @param right the last index of the subset \r\n     *\r\n     * @return the index of the middle element\r\n     */\r\n    private static int partition(double[] array, int[] index, int l, int r) {\r\n      \r\n      double pivot = array[index[(l + r) / 2]];\r\n      int help;\r\n\r\n      while (l \u003c r) {\r\n        while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\r\n          l++;\r\n        }\r\n        while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\r\n          r--;\r\n        }\r\n        if (l \u003c r) {\r\n          help = index[l];\r\n          index[l] = index[r];\r\n          index[r] = help;\r\n          l++;\r\n          r--;\r\n        }\r\n      }\r\n      if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\r\n        r--;\r\n      } \r\n\r\n      return r;\r\n    }\r\n\r\n    /**\r\n     * Partitions the instances around a pivot. Used by quicksort and\r\n     * kthSmallestValue.\r\n     *\r\n     * @param array the array of integers to be sorted\r\n     * @param index the index into the array of integers\r\n     * @param left the first index of the subset \r\n     * @param right the last index of the subset \r\n     *\r\n     * @return the index of the middle element\r\n     */\r\n    private static int partition(int[] array, int[] index, int l, int r) {\r\n      \r\n      double pivot = array[index[(l + r) / 2]];\r\n      int help;\r\n\r\n      while (l \u003c r) {\r\n        while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\r\n          l++;\r\n        }\r\n        while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\r\n          r--;\r\n        }\r\n        if (l \u003c r) {\r\n          help = index[l];\r\n          index[l] = index[r];\r\n          index[r] = help;\r\n          l++;\r\n          r--;\r\n        }\r\n      }\r\n      if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\r\n        r--;\r\n      } \r\n\r\n      return r;\r\n    }\r\n\r\n}\r\n",
        "name": "Utils.java",
        "path": "src/main/java/utils/Utils.java",
        "url": "/github.com/alvarag/ConceptDriftMOA/-/blob/src/main/java/utils/Utils.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 156,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 157,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 158,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires array != index;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 179,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\r"
        },
        {
          "limitHit": false,
          "lineNumber": 180,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\r"
        },
        {
          "limitHit": false,
          "lineNumber": 181,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires array != index;\r"
        }
      ],
      "repository": {
        "name": "github.com/alvarag/ConceptDriftMOA",
        "url": "/github.com/alvarag/ConceptDriftMOA"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 6,
  "ElapsedMilliseconds": 1105,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
