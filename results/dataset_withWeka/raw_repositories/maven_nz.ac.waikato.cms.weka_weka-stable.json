{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:maven/nz.ac.waikato.cms.weka/weka-stable lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "f4f3a2b1e7ef965b87ced79c892794e5b82d8c8f"
        },
        "content": "/*\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n/*\n *    Queue.java\n *    Copyright (C) 1999-2012 University of Waikato, Hamilton, New Zealand\n *\n *    Modified March-May 2004 by Mark Utting to add JML specs\n *    (this was done as the example solution of an assignment for a\n *     software engineering course, so the specifications are more precise\n *     and complete than one would normally do).\n *    Passed a static analysis using ESC/Java-2.0a6 with no warnings.\n */\n\npackage weka.core;\n\nimport java.io.Serializable;\n\n/** \n * Class representing a FIFO queue.\n *\n * @author Len Trigg (trigg@cs.waikato.ac.nz)\n * @version $Revision: 8034 $\n */\npublic class Queue\n  extends Object\n  implements Serializable, RevisionHandler {\n\n  /** for serialization */\n  private static final long serialVersionUID = -1141282001146389780L;\n\n  /**\n   * Represents one node in the queue.\n   */\n  protected class QueueNode\n    implements Serializable, RevisionHandler {\n\n    /** for serialization */\n    private static final long serialVersionUID = -5119358279412097455L;\n\n    /** The next node in the queue */\n    protected /*@ spec_public @*/ QueueNode m_Next;\n\n    /** The nodes contents\n     */\n    protected /*@ non_null spec_public @*/ Object m_Contents;\n\n    /** \n     * Creates a queue node with the given contents \n     */\n    //@ requires contents != null;\n    //@ assignable m_Contents, m_Next;\n    //@ ensures m_Contents == contents;\n    //@ ensures m_Next == null;\n    public QueueNode(Object contents) {\n      m_Contents = contents;\n      next(null);\n    }\n\n    /**\n     * Sets the next node in the queue, and returns it.\n     */\n    //@ requires next != this ;\n    //@ assignable m_Next;\n    //@ ensures m_Next==next \u0026\u0026 \\result==next;\n    public QueueNode next(QueueNode next) {\n      return m_Next = next;\n    } //@ nowarn Invariant; // Because it stupidly checks the Queue invariant!\n\n    /**\n     * Gets the next node in the queue. \n     */\n    //@ ensures \\result == m_Next;\n    public /*@ pure @*/ QueueNode next() {\n      return m_Next;\n    }\n\n    /**\n     * Sets the contents of the node.\n     */\n    //@ requires contents != null;\n    //@ assignable m_Contents;\n    //@ ensures  m_Contents == contents \u0026\u0026 \\result == contents;\n    public Object contents(Object contents) {\n      return m_Contents = contents;\n    }\n\n    /**\n     * Returns the contents in the node.\n     */\n      //@ ensures \\result == m_Contents;\n    public /*@ pure @*/ Object contents() {\n      return m_Contents;\n    }\n    \n    /**\n     * Returns the revision string.\n     * \n     * @return\t\tthe revision\n     */\n    public String getRevision() {\n      return RevisionUtils.extract(\"$Revision: 8034 $\");\n    }\n  }\n\n  /** Store a reference to the head of the queue */\n  protected /*@ spec_public @*/ QueueNode m_Head = null;\n\n  /** Store a reference to the tail of the queue */\n  protected /*@ spec_public @*/ QueueNode m_Tail = null;\n\n  /** Store the c m_Tail.m_Nexturrent number of elements in the queue */\n  protected /*@ spec_public @*/ int m_Size = 0;\n\n  //@ public invariant m_Head == null \u003c==\u003e m_Tail == null;\n  //@public invariant m_Tail != null ==\u003e m_Tail.m_Next == null;\n  //@ public invariant m_Size \u003e= 0;\n  //@ public invariant m_Size == 0 \u003c==\u003e m_Head == null;\n  //@ public invariant m_Size == 1 \u003c==\u003e m_Head != null \u0026\u0026 m_Head == m_Tail;\n  //@ public invariant m_Size \u003e 1 ==\u003e m_Head != m_Tail;\n  //@ public invariant m_Size \u003e 1 \u003c== m_Head != m_Tail;\n\n\n\n  /**\n   * Removes all objects from the queue m_Tail.m_Next.\n   */\n  //@ assignable m_Size, m_Head, m_Tail;\n  //@ ensures m_Size == 0;\n  //@ ensures m_Head == null;\n  //@ ensures m_Tail == null;\n  public final synchronized void removeAllElements() {\n    m_Size = 0;\n    m_Head = null;\n    m_Tail = null;\n  }\n\n  /**\n   * Appends an object to the back of the queue.\n   *\n   * @param item the object to be appended\n   * @return the object appended\n   */\n  //@ requires item != null;\n  //@ assignable m_Head, m_Tail, m_Tail.m_Next, m_Head.m_Next, m_Size;\n  //@ ensures m_Head != null;\n  //@ ensures m_Tail != \\old(m_Tail);\n  //@ ensures m_Size == \\old(m_Size) + 1;\n  //@ ensures \\old(m_Size) == 0 ==\u003e m_Head == m_Tail; \n  //@ ensures \\old(m_Size) != 0 ==\u003e m_Head == \\old(m_Head);\n  //@ ensures m_Tail.contents() == \\old(item);\n  //@ ensures \\result == item;\n  public synchronized Object push(Object item) {\n    QueueNode newNode = new QueueNode(item);\n    \n    if (m_Head == null) {\n      m_Head = m_Tail = newNode;\n    } else {\n      m_Tail = m_Tail.next(newNode);\n    }\n    m_Size++;\n    return item;\n  }\n\n  /**\n   * Pops an object from the front of the queue.\n   *\n   * @return the object at the front of the queue\n   * @exception RuntimeException if the queue is empty\n   */\n  //@ assignable m_Head, m_Tail, m_Size;\n  //@ ensures m_Size == \\old(m_Size) - 1;\n  //@ ensures m_Head == \\old(m_Head.m_Next);\n  //@ ensures m_Head != null ==\u003e m_Tail == \\old(m_Tail);\n  //@ ensures \\result == \\old(m_Head.m_Contents);\n  //@ signals (RuntimeException) \\old(m_Head) == null;\n  public synchronized Object pop() \n      throws RuntimeException   // REDUNDANT, BUT ESCJAVA REQUIRES THIS\n  {\n    if (m_Head == null) {\n\tthrow new RuntimeException(\"Queue is empty\");\n    }\n    Object retval = m_Head.contents();\n    m_Size--;\n    m_Head = m_Head.next();\n    // Here we need to either tell ESC/Java some facts about\n    // the contents of the list after popping off the head,\n    // or turn off the 'invariant' warnings.\n    //\n    //@ assume m_Size == 0 \u003c==\u003e m_Head == null;\n    //@ assume m_Size == 1 \u003c==\u003e m_Head == m_Tail;\n    if (m_Head == null) {\n      m_Tail = null;\n    }\n    return retval;\n  }\n\n  /**\n   * Gets object from the front of the queue.\n   *\n   * @return the object at the front of the queue\n   * @exception RuntimeException if the queue is empty\n   */\n  //@ ensures \\result == \\old(m_Head.m_Contents);\n  //@ signals (RuntimeException) \\old(m_Head) == null;\n  public /*@ pure @*/ synchronized Object peek() \n    throws RuntimeException\n  { \n    if (m_Head == null) {\n      throw new RuntimeException(\"Queue is empty\");\n    }\n    return m_Head.contents();\n  }\n\n  /**\n   * Checks if queue is empty.\n   * \n   * @return true if queue is empty\n   */\n  //@ ensures \\result \u003c==\u003e m_Head == null;\n  public /*@ pure @*/ boolean empty() {\n    return m_Head == null;\n  }\n\n  /**\n   * Gets queue's size.\n   *\n   * @return size of queue\n   */\n  //@ ensures \\result == m_Size;\n  public /*@ pure @*/ int size() {\n    return m_Size;\n  }\n\n  /**\n   * Produces textual description of queue.\n   *\n   * @return textual description of queue\n   */\n  //@ also\n  //@ ensures \\result != null;\n  //@ ensures (* \\result == textual description of the queue *);\n  public  /*@ pure @*/ String toString() {\n\n    String retval = \"Queue Contents \"+m_Size+\" elements\\n\";\n    QueueNode current = m_Head;\n    if (current == null) {\n      return retval + \"Empty\\n\";\n    } else {\n      while (current != null) {\n        retval += current.contents().toString()+\"\\n\"; //@nowarn Modifies;\n\tcurrent = current.next();\n      }\n    }\n    return retval;\n  } //@ nowarn Post;\n  \n  /**\n   * Returns the revision string.\n   * \n   * @return\t\tthe revision\n   */\n  public String getRevision() {\n    return RevisionUtils.extract(\"$Revision: 8034 $\");\n  }\n\n  /**\n   * Main method for testing this class.\n   *\n   * @param argv a set of strings that are pushed on a test queue\n   */\n  //@ requires argv.length \u003e= 0;\n  //@ requires argv != null;\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c argv.length; argv[i] != null);\n  public static void main(String [] argv) {\n\n    try {\n      Queue queue = new Queue();\n      for(int i = 0; i \u003c argv.length; i++) {\n\tqueue.push(argv[i]);\n      }\n      System.out.println(\"After pushing command line arguments\");\n      System.out.println(queue.toString());\n      while (!queue.empty()) {\n\tSystem.out.println(\"Pop: \" + queue.pop().toString());\n      }\n      // try one more pop, to make sure we get an exception\n      try \n\t{\n\t  queue.pop();\n\t  System.out.println(\"ERROR: pop did not throw exception!\");\n\t}\n      catch (RuntimeException ex)\n        {\n\t  System.out.println(\"Pop on empty queue correctly gave exception.\");\n\t}\n    } catch (Exception ex) {\n      System.out.println(ex.getMessage());\n    }\n  }\n}\n",
        "name": "Queue.java",
        "path": "weka/core/Queue.java",
        "url": "/maven/nz.ac.waikato.cms.weka/weka-stable/-/blob/weka/core/Queue.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 62,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires contents != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 64,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures m_Contents == contents;"
        },
        {
          "limitHit": false,
          "lineNumber": 65,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures m_Next == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 74,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires next != this ;"
        },
        {
          "limitHit": false,
          "lineNumber": 76,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures m_Next==next \u0026\u0026 \\result==next;"
        },
        {
          "limitHit": false,
          "lineNumber": 84,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result == m_Next;"
        },
        {
          "limitHit": false,
          "lineNumber": 92,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires contents != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 102,
          "offsetAndLengths": [
            [
              6,
              12
            ]
          ],
          "preview": "      //@ ensures \\result == m_Contents;"
        },
        {
          "limitHit": false,
          "lineNumber": 140,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Size == 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 141,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 142,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Tail == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 155,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires item != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 157,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 158,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Tail != \\old(m_Tail);"
        },
        {
          "limitHit": false,
          "lineNumber": 159,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Size == \\old(m_Size) + 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 160,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\old(m_Size) == 0 ==\u003e m_Head == m_Tail; "
        },
        {
          "limitHit": false,
          "lineNumber": 161,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\old(m_Size) != 0 ==\u003e m_Head == \\old(m_Head);"
        },
        {
          "limitHit": false,
          "lineNumber": 162,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Tail.contents() == \\old(item);"
        },
        {
          "limitHit": false,
          "lineNumber": 163,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == item;"
        },
        {
          "limitHit": false,
          "lineNumber": 183,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Size == \\old(m_Size) - 1;"
        },
        {
          "limitHit": false,
          "lineNumber": 184,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head == \\old(m_Head.m_Next);"
        },
        {
          "limitHit": false,
          "lineNumber": 185,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Head != null ==\u003e m_Tail == \\old(m_Tail);"
        },
        {
          "limitHit": false,
          "lineNumber": 186,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == \\old(m_Head.m_Contents);"
        },
        {
          "limitHit": false,
          "lineNumber": 215,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == \\old(m_Head.m_Contents);"
        },
        {
          "limitHit": false,
          "lineNumber": 231,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result \u003c==\u003e m_Head == null;"
        },
        {
          "limitHit": false,
          "lineNumber": 241,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_Size;"
        },
        {
          "limitHit": false,
          "lineNumber": 252,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 253,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures (* \\result == textual description of the queue *);"
        },
        {
          "limitHit": false,
          "lineNumber": 283,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires argv.length \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 284,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires argv != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 285,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c argv.length; argv[i] != null);"
        },
        {
          "limitHit": false,
          "lineNumber": 94,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures  m_Contents == contents \u0026\u0026 \\result == contents;"
        }
      ],
      "repository": {
        "name": "maven/nz.ac.waikato.cms.weka/weka-stable",
        "url": "/maven/nz.ac.waikato.cms.weka/weka-stable"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "f4f3a2b1e7ef965b87ced79c892794e5b82d8c8f"
        },
        "content": "/*\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n/*\n *    SingleIndex.java\n *    Copyright (C) 2003-2012 University of Waikato, Hamilton, New Zealand\n *\n */\n\npackage weka.core;\n\nimport java.io.Serializable;\n\n/** \n * Class representing a single cardinal number. The number is set by a \n * string representation such as: \u003cP\u003e\n *\n * \u003ccode\u003e\n *   first\n *   last\n *   1\n *   3\n * \u003c/code\u003e \u003cP\u003e\n * The number is internally converted from 1-based to 0-based (so methods that \n * set or get numbers not in string format should use 0-based numbers).\n *\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\n * @version $Revision: 8034 $\n */\npublic class SingleIndex\n  implements Serializable, RevisionHandler, CustomDisplayStringProvider {\n  \n  /** for serialization. */\n  static final long serialVersionUID = 5285169134430839303L;\n\n  /** Record the string representation of the number. */\n  protected /*@non_null spec_public@*/ String m_IndexString = \"\";\n\n  /** The selected index. */\n  protected /*@ spec_public @*/ int m_SelectedIndex = -1;\n\n  /** Store the maximum value permitted. -1 indicates that no upper\n      value has been set */\n  protected /*@ spec_public @*/ int m_Upper = -1;\n\n  /**\n   * Default constructor.\n   *\n   */\n  //@ assignable m_IndexString, m_SelectedIndex, m_Upper;\n  //@ ensures m_SelectedIndex == -1;\n  //@ ensures m_Upper == -1;\n  public SingleIndex() {\n  }\n\n  /**\n   * Constructor to set initial index.\n   *\n   * @param index the initial index\n   * @throws IllegalArgumentException if the index is invalid\n   */\n  //@ assignable m_IndexString, m_SelectedIndex, m_Upper;\n  //@ ensures m_IndexString == index;\n  //@ ensures m_SelectedIndex == -1;\n  //@ ensures m_Upper == -1;\n  public SingleIndex(/*@non_null@*/ String index) {\n\n    setSingleIndex(index);\n  }\n\n  /**\n   * Sets the value of \"last\".\n   *\n   * @param newUpper the value of \"last\"\n   */\n  //@ assignable m_Upper, m_IndexString, m_SelectedIndex;\n  //@ ensures newUpper \u003c 0 ==\u003e m_Upper == \\old(m_Upper);\n  //@ ensures newUpper \u003e= 0 ==\u003e m_Upper == newUpper;\n  public void setUpper(int newUpper) {\n\n    if (newUpper \u003e= 0) {\n      m_Upper = newUpper;\n      setValue();\n    }\n  }\n\n  /**\n   * Gets the string representing the selected range of values.\n   *\n   * @return the range selection string\n   */\n  //@ ensures \\result == m_IndexString;\n  public /*@pure@*/ String getSingleIndex() {\n\n    return m_IndexString;\n  }\n\n  /**\n   * Sets the index from a string representation. Note that setUpper()\n   * must be called for the value to be actually set\n   *\n   * @param index the index set\n   * @throws IllegalArgumentException if the index was not well formed\n   */\n  //@ assignable m_IndexString, m_SelectedIndex;\n  //@ ensures m_IndexString == index;\n  //@ ensures m_SelectedIndex == -1;\n  public void setSingleIndex(/*@non_null@*/ String index) {\n\n    m_IndexString = index;\n    m_SelectedIndex = -1;\n  }\n\n  /**\n   * Constructs a representation of the current range. Being a string\n   * representation, the numbers are based from 1.\n   * \n   * @return the string representation of the current range\n   */\n  //@ also signals (RuntimeException e) \\old(m_Upper) \u003c 0;\n  //@ ensures \\result != null;\n  public /*@pure@*/ String toString() {\n\n    if (m_IndexString.equals(\"\")) {\n      return \"No index set\";\n    }\n    if (m_Upper == -1) {\n      throw new RuntimeException(\"Upper limit has not been specified\");\n    }\n    return m_IndexString;\n  }\n\n  /**\n   * Gets the selected index.\n   *\n   * @return the selected index\n   * @throws RuntimeException if the upper limit of the index hasn't been defined\n   */\n  //@ requires m_Upper \u003e= 0;\n  //@ requires m_IndexString.length() \u003e 0;\n  //@ ensures \\result == m_SelectedIndex;\n  public /*@pure@*/ int getIndex() {\n\n    if (m_IndexString.equals(\"\")) {\n      throw new RuntimeException(\"No index set\");\n    }\n    if (m_Upper == -1) {\n      throw new RuntimeException(\"No upper limit has been specified for index\");\n    }\n    return m_SelectedIndex;\n  }\n\n  /**\n   * Creates a string representation of the given index.\n   *\n   * @param index the index to turn into a string.\n   * Since the index will typically come from a program, indices are assumed\n   * from 0, and thus will have 1 added in the String representation.\n   * @return the string representation\n   */\n  //@ requires index \u003e= 0;\n  public static /*@pure non_null@*/ String indexToString(int index) {\n\n    return \"\" + (index + 1);\n  }\n\n  /**\n   * Translates a single string selection into it's internal 0-based equivalent.\n   */\n  //@ assignable m_SelectedIndex, m_IndexString;\n  protected void setValue() {\n\n    if (m_IndexString.equals(\"\")) {\n      throw new RuntimeException(\"No index set\");\n    }\n    if (m_IndexString.toLowerCase().equals(\"first\")) {\n      m_SelectedIndex = 0;\n    } else if (m_IndexString.toLowerCase().equals(\"last\")) {\n      m_SelectedIndex = m_Upper;\n    } else {\n      m_SelectedIndex = Integer.parseInt(m_IndexString) - 1;\n      if (m_SelectedIndex \u003c 0) {\n\tm_IndexString = \"\";\n\tthrow new IllegalArgumentException(\"Index must be greater than zero\");\n      }\n      if (m_SelectedIndex \u003e m_Upper) {\n\tm_IndexString = \"\";\n\tthrow new IllegalArgumentException(\"Index is too large\");\n      }\n    }\n  }\n  \n  /**\n   * Returns the revision string.\n   * \n   * @return\t\tthe revision\n   */\n  public String getRevision() {\n    return RevisionUtils.extract(\"$Revision: 8034 $\");\n  }\n\n  /**\n   * Returns the custom display string.\n   * \n   * @return\t\tthe string\n   */\n  public String toDisplay() {\n    return getSingleIndex();\n  }\n\n  /**\n   * Main method for testing this class.\n   *\n   * @param argv one parameter: a test index specification\n   */\n  //@ requires \\nonnullelements(argv);\n  public static void main(/*@non_null@*/ String [] argv) {\n\n    try {\n      if (argv.length == 0) {\n\tthrow new Exception(\"Usage: SingleIndex \u003cindexspec\u003e\");\n      }\n      SingleIndex singleIndex = new SingleIndex();\n      singleIndex.setSingleIndex(argv[0]);\n      singleIndex.setUpper(9);\n      System.out.println(\"Input: \" + argv[0] + \"\\n\"\n\t\t\t + singleIndex.toString());\n      int selectedIndex = singleIndex.getIndex();\n      System.out.println(selectedIndex + \"\");\n    } catch (Exception ex) {\n      ex.printStackTrace();\n      System.out.println(ex.getMessage());\n    }\n  }\n}\n",
        "name": "SingleIndex.java",
        "path": "weka/core/SingleIndex.java",
        "url": "/maven/nz.ac.waikato.cms.weka/weka-stable/-/blob/weka/core/SingleIndex.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 62,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_SelectedIndex == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 63,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Upper == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 74,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_IndexString == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 75,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_SelectedIndex == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 76,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_Upper == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 88,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures newUpper \u003c 0 ==\u003e m_Upper == \\old(m_Upper);"
        },
        {
          "limitHit": false,
          "lineNumber": 89,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures newUpper \u003e= 0 ==\u003e m_Upper == newUpper;"
        },
        {
          "limitHit": false,
          "lineNumber": 103,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_IndexString;"
        },
        {
          "limitHit": false,
          "lineNumber": 117,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_IndexString == index;"
        },
        {
          "limitHit": false,
          "lineNumber": 118,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures m_SelectedIndex == -1;"
        },
        {
          "limitHit": false,
          "lineNumber": 132,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 150,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_Upper \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 151,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires m_IndexString.length() \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 152,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result == m_SelectedIndex;"
        },
        {
          "limitHit": false,
          "lineNumber": 172,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires index \u003e= 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 227,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires \\nonnullelements(argv);"
        }
      ],
      "repository": {
        "name": "maven/nz.ac.waikato.cms.weka/weka-stable",
        "url": "/maven/nz.ac.waikato.cms.weka/weka-stable"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "f4f3a2b1e7ef965b87ced79c892794e5b82d8c8f"
        },
        "content": "/*\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n/*\n *    OptionHandler.java\n *    Copyright (C) 1999-2012 University of Waikato, Hamilton, New Zealand\n *\n */\n\npackage weka.core;\n\nimport java.util.Enumeration;\n\n/** \n * Interface to something that understands options.\n *\n * @author Eibe Frank (eibe@cs.waikato.ac.nz)\n * @author Len Trigg (trigg@cs.waikato.ac.nz)\n * @version $Revision: 15235 $\n */\npublic interface OptionHandler {\n\n  /**\n   * Returns an enumeration of all the available options..\n   *\n   * @return an enumeration of all available options.\n   */\n  Enumeration\u003cOption\u003e listOptions();\n\n  /**\n   * Sets the OptionHandler's options using the given list. All options\n   * will be set (or reset) during this call (i.e. incremental setting\n   * of options is not possible).\n   *\n   * @param options the list of options as an array of strings\n   * @throws Exception if an option is not supported\n   */\n  //@ requires options != null;\n  //@ requires \\nonnullelements(options);\n  void setOptions(String[] options) throws Exception;\n\n  /**\n   * Gets the current option settings for the OptionHandler.\n   *\n   * @return the list of current option settings as an array of strings\n   */\n  //@ ensures \\result != null;\n  //@ ensures \\nonnullelements(\\result);\n  /*@pure@*/ String[] getOptions();\n\n  /**\n   * Creates an instance of the class that the given option handler belongs to and sets the options for this\n   * new instance by taking the option settings from the given option handler.\n   *\n   * If an exception is thrown when this process is performed, the fall back is to take a standard deep copy\n   * of the given option handler object. If that also fails, an exception is thrown by this method.\n   *\n   * A message will be printed to the standard error if the object is deep copied. A stack trace is also output\n   * in this case.\n   *\n   * @param toCopy the option handler to copy\n   *\n   * @exception Exception if the object could not be deep copied either\n   */\n  static OptionHandler makeCopy(OptionHandler toCopy) throws Exception {\n\n    try {\n      return (OptionHandler)Utils.forName(Object.class, toCopy.getClass().getCanonicalName(), toCopy.getOptions());\n    } catch (Exception ex) {\n      System.err.println(\"WARNING: failed to copy option handler \" + toCopy.getClass().getCanonicalName() + \" with \" +\n              \"options \" + String.join(\" \", toCopy.getOptions()) + \" --- trying deep copy instead\");\n      ex.printStackTrace();\n      return (OptionHandler) (new SerializedObject(toCopy)).getObject();\n    }\n  }\n}\n\n\n\n\n\n\n\n\n",
        "name": "OptionHandler.java",
        "path": "weka/core/OptionHandler.java",
        "url": "/maven/nz.ac.waikato.cms.weka/weka-stable/-/blob/weka/core/OptionHandler.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 49,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires options != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 50,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires \\nonnullelements(options);"
        },
        {
          "limitHit": false,
          "lineNumber": 58,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\result != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 59,
          "offsetAndLengths": [
            [
              2,
              12
            ]
          ],
          "preview": "  //@ ensures \\nonnullelements(\\result);"
        }
      ],
      "repository": {
        "name": "maven/nz.ac.waikato.cms.weka/weka-stable",
        "url": "/maven/nz.ac.waikato.cms.weka/weka-stable"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 52,
  "ElapsedMilliseconds": 1587,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
