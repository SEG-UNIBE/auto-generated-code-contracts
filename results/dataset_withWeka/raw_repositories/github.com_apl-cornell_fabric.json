{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/apl-cornell/fabric lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "b6bc62eccce6ff0d867efeb5e7f928d54bcef13f"
        },
        "content": "/**\n * OptimalCodeWriter -- Andrew C. Myers, Sept. 2005\n *   Originally developed for use in Cornell University Computer Science\n *   412/413, April 2001.\n */\n\npackage sif.servlet;\n\nimport java.io.*;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The pretty-printing algorithm is loosely based on the Modula-3\n * pretty-printer, and on notes by Greg Nelson. It was extended to support\n * breaks at multiple levels.\n *\n * OptimalCodeWriter follows the \"break from root\" rule: if a break is broken,\n * breaks of equal or lower level in all containing blocks must also be\n * broken, and breaks of strictly lower level in the same block must also\n * be broken.\n * \n */\npublic class OptimalCodeWriter extends CodeWriter {\n    /**\n     * Create a OptimalCodeWriter object with output stream \u003ccode\u003eo\u003c/code\u003e\n     * and width \u003ccode\u003ewidth_\u003c/code\u003e.\n     * @param o the writer to write to. Must be non-null.\n     * @param width_ the formatting width. Must be positive.\n     */\n    public OptimalCodeWriter(OutputStream o, int width_) {\n        this(new PrintWriter(new OutputStreamWriter(o)), width_);\n    }\n\n    /**\n     * Create a OptimalCodeWriter object.\n     * @param o the writer to write to. Must be non-null.\n     * @param width_ the formatting width. Must be positive.\n     */\n    public OptimalCodeWriter(PrintWriter o, int width_) {\n        output = o;\n        width = width_;\n        current = input = new BlockItem(null, 0);\n        if (OptimalCodeWriter.trace) {\n            trace(\"new OptimalCodeWriter: width = \" + width);\n        }\n    }\n\n    /**\n     * Create a OptimalCodeWriter object.\n     * @param o the writer to write to. Must be non-null.\n     * @param width_ the formatting width. Must be positive.\n     */\n    public OptimalCodeWriter(Writer o, int width_) {\n        this(new PrintWriter(o), width_);\n    }\n        \n    public void write(String s) {\n       if (s.length() \u003e 0) write(s, s.length());\n    }\n\n    public void write(String s, int length) {\n        if (OptimalCodeWriter.trace) {\n            trace(\"write '\" + s + \"' (\" + length + \")\");\n        }\n        current.add(new TextItem(s, length));\n    }\n\n    /**\n     * Start a new block with a relative indentation of \u003ccode\u003en\u003c/code\u003e\n     * characters.\n     * \u003cp\u003e\n     * A block is a formatting unit. The formatting algorithm will try to put\n     * the whole block in one line unless\n     * \u003cul\u003e\n     * \u003cli\u003ethere is a level-0 break in the block, or\u003c/li\u003e\n     * \u003cli\u003ethe block cannot fit in one line.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * If either of the two conditions is satisfied, the formatting algorithm\n     * will break the block into lines by generating newlines for some of the\n     * inserted breaks. The first line is printed at the current cursor\n     * position \u003ccode\u003epos\u003c/code\u003e, all the following lines are printed at the\n     * position \u003ccode\u003epos+n\u003c/code\u003e.\n     * \n     * @param n\n     *            the number of characters increased on indentation (relative\n     *            to the current position) for all lines in the block.\n     *            Requires: n \u003e= 0.\n     */         \n    public void begin(int n) {\n        if (OptimalCodeWriter.trace) {\n            trace(\"begin \" + n);\n            incIndent();\n        }\n        BlockItem b = new BlockItem(current, n);\n        current.add(b);\n        current = b;\n    }\n        \n    /**\n     * Terminate the most recent outstanding \u003ccode\u003ebegin\u003c/code\u003e.\n     */\n    public void end() {\n        if (OptimalCodeWriter.trace) {\n            decIndent();\n            trace(\"end\");\n        }\n        current = current.parent;\n        //@ assert current != null\n        // if (current == null) throw new RuntimeException();\n    }\n\n    public void allowBreak(int n, int level, String alt, int altlen) {\n        if (OptimalCodeWriter.trace) {\n            trace(\"allowBreak \" + n);\n        }\n        current.add(new AllowBreak(n, level, alt, altlen, false));\n    }\n    /** @see CodeWriter.unifiedBreak */\n    public void unifiedBreak(int n, int level, String alt, int altlen) {\n        if (OptimalCodeWriter.trace) {\n            trace(\"unifiedBreak \" + n);\n        }\n        current.add(new AllowBreak(n, level, alt, altlen, true));\n    }\n    \n    /**\n     * This method should be used sparingly; usually a call to\n     * \u003ccode\u003eallowBreak\u003c/code\u003e is preferable because forcing a newline also\n     * causes all breaks in containing blocks to be broken.\n     */\n    public void newline() {\n        newline(0);\n    }\n    /**\n     * Like newline(), but forces a newline with a specified indentation.\n     */\n    public void newline(int n) {\n        if (OptimalCodeWriter.trace) {\n            trace(\"newline \" + n);\n        }\n        current.add(new Newline(n));\n    }\n\n    /**\n     * Send out the current batch of text to be formatted. All outstanding\n     * \u003ccode\u003ebegin\u003c/code\u003e's are closed and the current indentation level is\n     * reset to 0. Returns true if formatting was completely successful (the\n     * margins were obeyed).\n     */\n    public boolean flush() throws IOException {\n        return flush(true);\n    }\n\n    /** Like \u003ccode\u003eflush\u003c/code\u003e, but passing \u003ccode\u003eformat=false\u003c/code\u003e\n     * causes output to be generated in the fastest way possible, with\n     * all breaks broken.\n     * @param format whether to pretty-print the output\n     * @return whether formatting was completely successful.\n     * @throws IOException\n     */\n    public boolean flush(boolean format) throws IOException {\n        if (OptimalCodeWriter.trace) {\n            trace(\"flush\");\n        }\n\tboolean success = true;\n\tformat_calls = 0;\n\tif (format) {\n\t    try {\n\t        top = input;\n\t        Item.format(input, 0, 0, width, width,\n                    new MaxLevels(Integer.MAX_VALUE, Integer.MAX_VALUE), 0, 0);\n\t    } catch (Overrun o) { success = false; }\n\t} else success = false;\n\t\n        input.sendOutput(output, 0, 0, success, null);\n        output.flush();\n        if (OptimalCodeWriter.debug) {\n            System.err.println(\"Total calls to format = \" + format_calls);\n            System.err.flush();\n        }\n        current = input = new BlockItem(null, 0);\n\treturn success;\n    }\n\n    public void close() throws IOException {\n\tflush();\n\toutput.close();\n    }\n\n    /**\n     * Return a readable representation of all the structured input given to\n     * the CodeWriter since the last flush.\n     */\n    public String toString() {\n\treturn input.toString();\n    }\n\n    BlockItem input;\n    BlockItem current;\n    \n    static Item top;\n\n    PrintWriter output;\n    int width;\n    static int format_calls = 0;\n    public static final boolean debug = false; // show everything\n    public static final boolean trace = false;  // show inputs\n    public static final boolean visualize = false; // visualize formatting\n      \t\t\t\t\t\t  // (requires VT100 terminal)\n\n    public static final boolean precompute = true; // use memoization\n\n    // Debugging methods\n\n    /** Amount to indent during tracing. */\n    int trace_indent = 0;\n\n    /** Increment tracing indentation. */\n    void incIndent() { trace_indent++; }\n\n    /** Decrement tracing indentation. */\n    void decIndent() {\n        trace_indent--;\n        if (trace_indent \u003c 0) throw new RuntimeException(\"unmatched end\");\n    }\n\n    /** Print a debug message. */\n    void trace(String s) {\n        for (int i = 0; i \u003c trace_indent; i++) System.out.print(\" \");\n        System.out.println(s);\n    }\n\n}\n\n/**\n * An \u003ccode\u003eOverrun\u003c/code\u003e represents a formatting that failed because the\n * right margin was exceeded by at least \u003ccode\u003eamount\u003c/code\u003e chars. If\n * sameLine, the overrun occurred on the first line of the requested\n * formatting; otherwise, it occurred on a subsequent line.\n */\nclass Overrun extends Exception \n{\n    int amount;\n    int type;\n    final static int POS = 0;\n    final static int WIDTH = 1;\n    final static int FIN = 2;\n\n    private static final Overrun overrun = new Overrun();\n\n    private Overrun() {}\n    static Overrun overrun(Item where, int amount, int type) {\n\tif (OptimalCodeWriter.debug) System.err.println(\"-- Overrun: \" + amount);\n\tif (OptimalCodeWriter.visualize) {\n\t    System.err.print(\"\\033[H\\033[2J\");\n\t    PrintWriter w = new PrintWriter(new OutputStreamWriter(System.err));\n\t    try {\t            \t            \n\t\tOptimalCodeWriter.top.sendOutput(w, 0, 0, true, where);\n\t    }\n\t    catch (IOException e) {  }\n\t    w.flush();\n\t    System.err.println();\n\t    String type_name = \"pos\";\n\t    if (type == 1) type_name = \"width\";\n\t    else if (type == 2) type_name = \"fin\";\n\t    System.err.println(\"Overrun: type \" + type_name + \" amount: \" + amount);\n\t    try { System.in.read(); } catch (IOException e) {}\n\t}\n        overrun.amount = amount;\n        overrun.type = type;\n        return overrun;\n    }\n}\n\n\n/**\n * An \u003ccode\u003eItem\u003c/code\u003e is a piece of input handed to the formatter. It\n * contains a reference to a possibly empty list of items that follow it.\n */\nabstract class Item \n{\n    /** next is null if this is the last item in the list. */\n    Item next;\n\n    protected Item() { next = null; }\n\n    /**\n     * Try to format this and subsequent items.\n     * \n     * @return the final cursor position (which may overrun rmargin, fin, or\n     *         both), and set any contained breaks accordingly.\n     *         \u003c/p\u003e\n     * \n     * @param lmargin\n     *            is the current left margin.\n     * @param pos\n     *            is the current cursor position.\n     * @param rmargin\n     *            is the current right margin.\n     * @param fin\n     *            is a bound on the final cursor position after formatting the\n     *            whole item.\n     * @param maxLevel\n     *            is the maximum level at which breaks may be broken in the\n     *            current block.\n     * @param maxLevelInner\n     *            is the maximum level at which breaks may be broken in nested\n     *            blocks.\n     * @param minLevel\n     *            is the minimum level at which breaks must be broken.\n     * @param minLevelUnified\n     *            is the minimum level at which unified breaks must be broken.\n     * \n     * \u003cp\u003e\n     * Breaks may be broken up to level maxLevel, which is set whenever a break\n     * is not broken. Not breaking an ordinary break means that equal or\n     * higher-level breaks in all contained blocks must not be broken either,\n     * and breaks of strictly higher level in the same block must not be\n     * broken.  Not breaking a unified break means that breaks of the same\n     * level in the same block must not also be broken. The parameter\n     * maxLevelInner controls the maxLevel in nested blocks; it is equal to\n     * either maxLevel or maxLevel-1.\n     * \n     * \u003cp\u003e\n     * \u003cdl\u003e\n     * \u003cdt\u003eExample 1:\n     * \u003cdd\u003eSuppose we have a current maxLevel of 4, and an ordinary,\n     * non-unified break of level 2 is not broken. Then for that block,\n     * maxLevel is set to 2 and maxLevelInner is set to 1. This permits further\n     * breaks of level 1 or 2 in the same block, but only level-1 breaks in\n     * inner blocks.\n     * \n     * \u003cdt\u003eExample 2:\u003c/dt\u003e\n     * \u003cdd\u003eSuppose we have a current maxLevel of 4, and a unified break of\n     * level 2 is not broken. Then for that block, maxLevel and maxLevelInner\n     * are set to 1. This permits no breaks in this block or in any nested\n     * blocks.\u003c/dd\u003e\n     * \u003c/dl\u003e\n     * \n     * \u003cp\u003e\n     * When a break is broken in a nested block, it means that all equal or\n     * higher-level breaks in containing blocks must be broken. However, these\n     * breaks may be encountered after the nested block. The parameter\n     * \u003ccode\u003eminLevel\u003c/code\u003e is used to communicate the level of breaks broken\n     * in nested blocks (and earlier in the current block). Any break of level\n     * \u003c= minLevel \u003cem\u003emust\u003c/em\u003e be broken. The parameter \u003ccode\u003e\n     * minLevelUnified\u003c/code\u003e is the minimum level at which unified breaks must\n     * be broken.  minLevelUnified is equal to either minLevel or minLevel+1.\n     * \u003c/p\u003e\n     * \n     * \u003cdl\u003e\n     * \u003cdt\u003eExample 3:\n     * \u003cdd\u003eSuppose we have a current maxLevel of 4, and a break of level 2 is\n     * broken. Then for its block, minLevel is at least 1, and minLevelUnified\n     * is at least 2. For containing blocks, minLevel is at least 2.\u003c/dd\u003e\n     * \u003c/dl\u003e\n     * \n     * \u003cb\u003eNote: \u003c/b\u003e It is important that formatN not necessarily convert\n     * overruns in its final position into exceptions. This allows the calling\n     * routine to distinguish between 'internal' overruns and ones that it can\n     * tack on a conservative estimate of how much formatting the rest of the\n     * list will make the overrun go up by. Also, it simplifies the coding of\n     * formatN.\n     * \u003c/p\u003e\n     * \n     * Requires: rmargin \u0026lt; lmargin, pos \u0026lt;= rmargin, lmargin \u0026lt; rmargin,\n     * pos \u0026le; rmargin, lmargin \u0026ge; 0\n     */\n    abstract FormatResult formatN(int lmargin, int pos, int rmargin, int fin,\n            MaxLevels m, int minLevel, int minLevelUnified)\n    \tthrows Overrun;\n    /**\n     * Send the output associated with this item to \u003ccode\u003eo\u003c/code\u003e, using the\n     * current break settings.\n     * \n     * @param success\n     */\n    abstract int sendOutput(PrintWriter o, int lmargin, int pos, boolean success, Item last)\n      throws IOException;\n    \n    // XXX\n    // the getminwidth etc. code is starting to duplicate the logic of the main\n    // formatting code. This suggests they should be merged. format can take\n    // two width arguments: one the width left on the current line, and one the\n    // width of subsequent lines. Hmmm -- new blocks start relative to current\n    // position, so knowing the initial width isn't enough.\n\n    /**\n     * Try to format a whole sequence of items in the manner of formatN. Unlike\n     * for formatN, The initial position may be an overrun (this is the only\n     * way that overruns are checked!). The item \u003ccode\u003eit\u003c/code\u003e may be also\n     * null, signifying an empty list. Requires: lmargin \u0026lt; rmargin, pos \u0026le;\n     * rmargin, lmargin \u0026ge; 0.\n     * \n     * @see formatN\n     */\n    static FormatResult format(Item it,\n\t\t\t       int lmargin, int pos, int rmargin, int fin,\n            \t\t       MaxLevels m, int minLevel, int minLevelUnified)\n\tthrows Overrun\n    {\n        OptimalCodeWriter.format_calls++;\n\tif (OptimalCodeWriter.debug) {\n\t    if (it != null \u0026\u0026 it != OptimalCodeWriter.top) {\n\t        System.err.println(\"SNAPSHOT:\");\n\t        PrintWriter w = new PrintWriter(new OutputStreamWriter(System.err));\n\t        try {\t            \t            \n\t            OptimalCodeWriter.top.sendOutput(w, 0, 0, true, it);\n\t        }\n\t        catch (IOException e) {  }\n\t        w.write(\"\u003cEND\u003e\\n\");\n\t        w.flush();\n\t    }\n\t    System.err.println(\"Format: \" + it + \"\\n  lmargin = \" +\n\t\tlmargin + \" pos = \" + pos + \" fin = \" + fin +\n\t\t\" max break levels: \" + m +\n\t\t\" min break levels: \" + minLevel + \"/\" + minLevelUnified);\n\n\t    if (OptimalCodeWriter.debug) {\t    \n\t        System.err.println(\"  MinWidth = \" + getMinWidth(it, m));\n\t        System.err.println(\"  MinPosWidth = \" + getMinPosWidth(it, m));\n\t        System.err.println(\"  MinIndent = \" + getMinIndent(it, m));\n\t    }\n\t\n\t    System.err.flush();\n\t}\n\tif (it == null) { // no items to format. Check against final position.\n\t    if (pos \u003e fin) {\n\t        if (OptimalCodeWriter.debug)\n\t            System.err.println(\"Final position overrun: \" + (pos-fin));\n\t        throw Overrun.overrun(it, pos - fin, Overrun.FIN);\n\t    }\n\t    else return new FormatResult(pos, minLevelUnified);\n\t}\n\t\n\tint amount2 = lmargin + getMinWidth(it, m) - rmargin;\n\t\t\t\t\t\t// lmargin is too far right\n\tif (amount2 \u003e 0) {\n\t    if (OptimalCodeWriter.debug)\n\t        System.err.println(\"Width overrun: \" + amount2);\n\t \n\t    throw Overrun.overrun(it, amount2, Overrun.WIDTH);\n\t}\n\t\n\tint amount = pos + getMinPosWidth(it, m) - rmargin; // overrun on first line\n\tif (amount \u003e 0) {\n\t    if (OptimalCodeWriter.debug)\n\t        System.err.println(\"Position (first line) overrun: \" + amount);\n\n\t    throw Overrun.overrun(it, amount, Overrun.POS);\n\t}\n\t\n\n\tint amount3 = lmargin + getMinIndent(it, m) - fin;   // overrun on last line\n\tif (amount3 \u003e 0) {\n\t    if (OptimalCodeWriter.debug)\n\t        System.err.println(\"Final position (predicted) overrun: \" + amount3);\n\n\t    throw Overrun.overrun(it, amount3, Overrun.FIN);\n\t}\t\n\n\treturn it.formatN(lmargin, pos, rmargin, fin, m, minLevel, minLevelUnified);\n    }\n\n/*\n * The following fields keep track of the tightest formatting that is possible\n * with an item and its following items, if all breaks are broken. The purpose\n * is to more aggressively tighten bounds when an overrun occurs. Formatting is\n * measured relative to both \"lmargin\" and to \"pos\". T\n * \n * lmargin pos\n *       | |\n *       | xxxxx\n *       xxxxxxxx\n *       xxxxxx\n *       \u003c------\u003e min_width (at least min_pos_width):\n * \t\t    distance from lmargin to rightmost char\n *         \u003c---\u003e  min_pos_width: distance from initial pos to end of first line\n *       \u003c----\u003e   min_indent (at most min_width):\n *                  distance from lmargin to final position on last line\n */\n\n    static final int NO_WIDTH = -9999;    \n\n    /** Minimum lmargin-rhs width on second and following lines. \n     * A map from max levels to Integer(width). */\n\n    Map\u003cMaxLevels, Integer\u003e min_widths = new HashMap\u003cMaxLevels, Integer\u003e();\n    \n    /** Minimum lmargin-final offset */\n    Map\u003cMaxLevels, Integer\u003e min_indents = new HashMap\u003cMaxLevels, Integer\u003e();\n\n    /** Minimum pos-rhs width (i.e., min width up to first break) */\n    Map\u003cMaxLevels, Integer\u003e min_pos_width = new HashMap\u003cMaxLevels, Integer\u003e();\n    \n    /** Are there any breaks in this items and following items? */\n    boolean contains_brks;\n    boolean cb_init = false;\n\n    static int getMinWidth(Item it, MaxLevels m) {\n\tif (it == null) return NO_WIDTH;\n\tif (it.min_widths.containsKey(m))\n\t    return it.min_widths.get(m).intValue();\n\tint p1 = it.selfMinWidth(m);\t  \n\tint p2 = it.selfMinIndent(m);\t\n\tint p3 = (p2 != NO_WIDTH) ? getMinPosWidth(it.next, m) + p2 : NO_WIDTH;\t\n\tint p4 = getMinWidth(it.next, m);\n\t\n\tif (OptimalCodeWriter.debug)\n\tSystem.err.println(\"minwidth: item = \" + it + m + \":  p1 = \" + p1 + \", p2 = \" + p2 + \", p3 = \" + p3 + \", p4 = \" + p4);\n\tint result = Math.max(Math.max(p1, p3), p4);\n\tit.min_widths.put(m, Integer.valueOf(result));\n\treturn result;\n    }\n\n    static int getMinPosWidth(Item it, MaxLevels m) {\n\tif (it == null) return 0;\n\tif (it.min_pos_width.containsKey(m)) {\n\t    return it.min_pos_width.get(m).intValue();\n\t}\n\tint p1 = it.selfMinPosWidth(m);\n\tint result;\n\tif (it.next == null || it.selfContainsBreaks(m)) {\n\t    result = p1;\n\t    if (OptimalCodeWriter.debug)\n\t    System.err.println(\"minpos: item = \" + it + m + \":  p1 = \" + p1);\n\t} else {\n\t    result = p1 + getMinPosWidth(it.next, m);\n\t    if (OptimalCodeWriter.debug)\n\t    System.err.println(\"minpos: item = \" + it + m + \":  p1 = \" + p1 + \", next.minpos = \" + getMinPosWidth(it.next, m));\n\t}\n\tit.min_pos_width.put(m, Integer.valueOf(result));\n\treturn result;\n    }\n\n    static int getMinIndent(Item it, MaxLevels m) {\n\tif (it == null) return NO_WIDTH;\n\tif (it.min_indents.containsKey(m)) {\n\t    return it.min_indents.get(m).intValue();\n\t}\n\tint p1 = it.selfMinIndent(m);\n\tif (it.next == null) return p1;\n\tint result;\n\tif (containsBreaks(it.next, m))\n\t    result = getMinIndent(it.next, m);\n\telse \n\t    result = getMinPosWidth(it.next, m);\n\tit.min_indents.put(m, Integer.valueOf(result));\n\treturn result;\n    }\n\n    static boolean containsBreaks(Item it, MaxLevels m) {\n\tif (it == null) return false;\n\tif (it.cb_init) return it.contains_brks;\n\tif (it.selfContainsBreaks(m)) {\n\t    it.contains_brks = true;\n\t    it.cb_init = true;\n\t    return true;\n\t}\n\tif (it.next == null) return false;\n\tit.contains_brks = containsBreaks(it.next, m);\n\tit.cb_init = true;\n\treturn it.contains_brks;\n    }\n\n    public String summarize(String s) {\n\tif (s.length() \u003c= 79) return s;\n\treturn s.substring(0, 76) + \"...\";\n    }\n\n    public String toString() {\n\tif (next == null) return summarize(selfToString());\n\treturn summarize(selfToString() + next.toString());\n    }\n\n    abstract String selfToString();\n    abstract int selfMinIndent(MaxLevels m);\n    abstract int selfMinWidth(MaxLevels m);\n    abstract int selfMinPosWidth(MaxLevels m);\n    abstract boolean selfContainsBreaks(MaxLevels m);\n}\n\n/** A simple string. */\nclass TextItem extends Item {\n    String s;\t\t//@ invariant s != null\n    int length;    \n    \n    TextItem(String s_, int length_) { s = s_; length = length_; }\n        \n    FormatResult formatN(int lmargin, int pos, int rmargin, int fin,\n            MaxLevels m, int minLevel, int minLevelUnified)\n      throws Overrun {\n        return format(next, lmargin, pos + length, rmargin, fin,\n\t\t      m, minLevel, minLevelUnified);\n        // all overruns passed through\n    }\n    int sendOutput(PrintWriter o, int lm, int pos, boolean success, Item last) throws IOException {\n        o.write(s);\n        return pos + length;\n    }\n    boolean selfContainsBreaks(MaxLevels m) { return false; }\n    int selfMinIndent(MaxLevels m) { return NO_WIDTH; }\n    int selfMinWidth(MaxLevels m) { return NO_WIDTH; } // length only counts on s lines\n    int selfMinPosWidth(MaxLevels m) { return length; }\n    String selfToString() {\n\tjava.io.StringWriter sw = new java.io.StringWriter();\n\tfor (int i = 0; i \u003c s.length(); i++) {\n\t    char c = s.charAt(i);\n\t    if (c == ' ') sw.write(\"\\\\ \");\n\t    else sw.write(c);\n\t}\n\treturn sw.toString();\n    }\n\n    /**\n     * @param item\n     */\n    public void appendTextItem(TextItem item) {\n        s += item.s;\n        length += item.length;       \n    }\n}\n\nclass AllowBreak extends Item {\n    final int indent;\n    final int level;\n    final boolean unified;\n    final String alt;\n    final int altlen;\n    boolean broken = false;\n        \n    //@ invariant indent \u003e= 0\n    //@ invariant alt != null\n\n    //@ requires n_ \u003e= 0\n    //@ requires alt_ != null\n    AllowBreak(int n_, int level_, String alt_, int altlen_, boolean u) {\n        indent = n_; alt = alt_; altlen = altlen_;\n        level = level_; unified = u; }\n        \n    FormatResult formatN(int lmargin, int pos, int rmargin, int fin,\n            MaxLevels m, int minLevel, int minLevelUnified) throws Overrun {\n        if (canLeaveUnbroken(minLevel, minLevelUnified)) {\n            // first, we can try not breaking it\n            try {\n                if (OptimalCodeWriter.debug)\n                    System.err.println(\"trying not breaking it.\");\n                broken = false;\n                return format(next, lmargin, pos + altlen, rmargin, fin,\n                    new MaxLevels(\n                            Math.min(unified ? level - 1 : level, m.maxLevel),\n                            Math.min(level - 1, m.maxLevelInner)),\n                    minLevel, minLevelUnified);\n\n            }\n            //  |yyy^xxxx\n            //  |xxxxx\n            //  |xxx\n            // pos overrun: might help by breaking\n            // width overrun: might help by breaking (e.g., if breaking permits nested breaks)\n            // fin overrun: similar\n            catch (Overrun o) {\n                if (OptimalCodeWriter.debug) {\n                    System.err.println(\"not breaking caused overrun of \" + o.amount);\n                }\n                if (level \u003e m.maxLevel) {\n                    if (OptimalCodeWriter.debug) {\n                        System.err.println(\"not breaking failed, but can't break either.\");\n                    }\n                    throw o; // can't break it\n                }\n            }\n        }\n        if (canBreak(m)) { // now, we can try breaking it\n            if (OptimalCodeWriter.debug)\n                System.err.println(\"trying breaking \" + this);\n            broken = true;\n            try {\n                return format(next, lmargin, lmargin + indent, rmargin, fin, m,\n                        Math.max(level-1, minLevel),\n                        Math.max(level, minLevelUnified));\n            }\n            //  |yyy^\n            //  |  xxxx\n            //  |  xxxxxx\n            //  |  xxx\n            // pos overrun: becomes a width overrun?\n            // width overrun: remains\n            // fin overrun: remains? becomes a width overrun?\n            catch (Overrun o) {\n                o.type = Overrun.WIDTH; throw o;\n            }\n        }\n        throw new IllegalArgumentException(\"could not either break or not break\");\n    }\n        \n    int sendOutput(PrintWriter o, int lmargin, int pos, boolean success, Item last)\n        throws IOException {\n        if (broken || !success) {\n            o.println();\n            for (int i = 0; i \u003c lmargin + indent; i++) o.print(\" \");\n            //o.write(\"(\" + (lmargin+indent) + \")\");\n            return lmargin + indent;\n        } else {\n\t    o.print(alt);\n            return pos + altlen;\n        }\n    }\n    boolean canBreak(MaxLevels m) {\n        return level \u003c= m.maxLevel;\n    }\n    boolean canLeaveUnbroken(int minLevel, int minLevelUnified) {\n        return (level \u003e minLevelUnified || !unified \u0026\u0026 level \u003e minLevel);\n    }\n    int selfMinIndent(MaxLevels m) {\n        if (canBreak(m)) return indent;\n        else return NO_WIDTH;\n    }\n    int selfMinPosWidth(MaxLevels m) {\n        if (canBreak(m)) return 0;\n        else return altlen;\n    }\n    int selfMinWidth(MaxLevels m) {\n        if (canBreak(m)) return indent;\n        else return NO_WIDTH;\n    }\n    boolean selfContainsBreaks(MaxLevels m) {\n        return canBreak(m);\n    }\n\n    String selfToString() {\n\tif (indent == 0) return \" \";\n\telse return \"^\" + indent; }\n}\n\n/** A Newline is simply a level-1 break that resists being\n *  left unbroken.\n */\nclass Newline extends AllowBreak {\n    Newline(int n) {\n\tsuper(n, 1, \"\\\\n\", 0, true);\n    }\n    boolean canLeaveUnbroken() { return false; }\n    String selfToString() {\n\tif (indent == 0) return \"\\\\n\";\n\telse return \"\\\\n[\" + indent + \"]\"; }\n    // XXX should not need to override sendOutput\n    int sendOutput(PrintWriter o, int lmargin, int pos, boolean success, Item last)\n        throws IOException {\n            o.println();\n            for (int i = 0; i \u003c lmargin + indent; i++) o.print(\" \");\n            //o.write(\"(\" + (lmargin+indent) + \")\");\n            return lmargin + indent;\n    }\n}\n\n/**\n * A BlockItem is a formatting unit containing a list of other items to be\n * formatted.\n */\nclass BlockItem extends Item {\n    BlockItem parent;\n    Item first;\n    Item last;\n    int indent;\t    //@ invariant indent \u003e= 0\n        \n    BlockItem(BlockItem parent_, int indent_) {\n        parent = parent_;\n        first = last = null;\n        indent = indent_;\n    }\n\n    /**\n     * Add a new item to the end of the block. Successive StringItems are\n     * concatenated together to limit recursion depth when formatting.\n     */\n    void add(Item it) {\n        if (first == null) {\n\t    first = it;\n\t} else {\n\t    if (it instanceof TextItem \u0026\u0026 last instanceof TextItem) {\n\t\tTextItem lasts = (TextItem)last;\n\t\tlasts.appendTextItem(((TextItem)it));\n\t\treturn;\n\t    } else {\n\t\tlast.next = it;\n\t    }\n\t}\n        last = it;\n    }\n\n    FormatResult formatN(int lmargin, int pos, int rmargin, int fin,\n            MaxLevels m, int minLevel, int minLevelUnified) throws Overrun {\n        int childfin = fin;\n        if (childfin + getMinPosWidth(next, m) \u003e rmargin) {\n            childfin = rmargin - getMinPosWidth(next, m);\n        }\n        while (true) {\n            FormatResult fr = format(first, pos + indent, pos, rmargin, childfin,\n                    new MaxLevels(m.maxLevelInner, m.maxLevelInner), 0, 0);\n            int minLevel2 = Math.max(minLevel, fr.minLevel);\n            int minLevelU2 = Math.max(minLevelUnified, fr.minLevel);\n            try {\n                return format(next, lmargin, fr.pos, rmargin, fin,\n                        m, minLevel2, minLevelU2);\n            } catch (Overrun o) {\n                if (o.type == Overrun.WIDTH) {\n                    o.type = Overrun.FIN;\n                    // Idea: doesn't matter where next item started XXX really?\n                    throw o;\n                }\n                childfin -= o.amount;\n            }          \n        }\n    }\n\n    int sendOutput(PrintWriter o, int lmargin, int pos, boolean success, Item last) throws IOException {\n        Item it = first;\n        lmargin = pos + indent;\n\tif (last != this) {\n          while (it != null) {\n            pos = it.sendOutput(o, lmargin, pos, success, last);\n            if (last != null \u0026\u0026 it == last) {\n                throw new IOException();\n            }\n            it = it.next;\n          }\n\t} else {\n\t    o.print(\"...\");\n\t}\n        return pos;\n    }\n\n    int selfMinWidth(MaxLevels m) {\n        return getMinWidth(first,\n                new MaxLevels(m.maxLevelInner, m.maxLevelInner));\n    }\n    int selfMinPosWidth(MaxLevels m) {\n        return getMinPosWidth(first,\n                new MaxLevels(m.maxLevelInner, m.maxLevelInner));\n    }\n    int selfMinIndent(MaxLevels m) {\n        return getMinIndent(first,\n                new MaxLevels(m.maxLevelInner, m.maxLevelInner));\n    }\n    \n    /**\n     * Map from maxlevels to either null or non-null, the latter if it can\n     * contain breaks at those maxlevels.\n     */\n    Map\u003cMaxLevels, MaxLevels\u003e containsBreaks = new HashMap\u003cMaxLevels, MaxLevels\u003e();\n    \n    boolean selfContainsBreaks(MaxLevels m) {\n\tif (containsBreaks.containsKey(m)) {\n\t    return (containsBreaks.get(m) != null);\n\t}\n\tboolean result =\n\t    containsBreaks(first,\n\t                   new MaxLevels(m.maxLevelInner, m.maxLevelInner));\t\n\tcontainsBreaks.put(m, result ? m : null);\n\treturn result;\n    }\n    String selfToString() {\n\tif (indent == 0) return \"[\" + first + \"]\";\n\telse return \"[\" + indent + first + \"]\";\n    }\n}\nclass FormatResult {\n    int pos;\n    int minLevel;\n    FormatResult(int pos_, int minLevel_) {\n        pos = pos_;\n        minLevel = minLevel_;\n    }\n}\n\nclass MaxLevels {\n    int maxLevel;\n    int maxLevelInner;\n    MaxLevels(int ml, int mli) {\n        maxLevel = ml;\n        maxLevelInner = mli;\n    }\n    public int hashCode() {\n        return maxLevel * 17 + maxLevelInner;\n    }\n    public boolean equals(Object o) {\n        if (o instanceof MaxLevels) {\n            MaxLevels m2 = (MaxLevels)o;\n            return (maxLevel == m2.maxLevel \u0026\u0026\n\t            maxLevelInner == m2.maxLevelInner);\n        } else\n            return false;\n    }\n    public String toString() {\n        return \"[\" + maxLevel + \"/\" + maxLevelInner + \"]\";\n    }\n}\n",
        "name": "OptimalCodeWriter.java",
        "path": "src/lib/sif/src/sif/servlet/OptimalCodeWriter.java",
        "url": "/github.com/apl-cornell/fabric/-/blob/src/lib/sif/src/sif/servlet/OptimalCodeWriter.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 636,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires n_ \u003e= 0"
        },
        {
          "limitHit": false,
          "lineNumber": 637,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires alt_ != null"
        }
      ],
      "repository": {
        "name": "github.com/apl-cornell/fabric",
        "url": "/github.com/apl-cornell/fabric"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 2,
  "ElapsedMilliseconds": 898,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
