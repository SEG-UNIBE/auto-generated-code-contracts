{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/STAR-RG/practical_testing_book lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "3372bf612040ff087f3ba2d0de650ceee7196c5a"
        },
        "content": "import java.util.*;\n/*\n * @(#)DoubleLinkedList.java\t1.46 03/01/23\n *\n * Copyright 2003 Sun Microsystems, Inc. All rights reserved.\n * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n */\n\n\n/**\n * Linked list implementation of the \u003ctt\u003eList\u003c/tt\u003e interface. Implements all\n * optional list operations, and permits all elements (including \u003ctt\u003enull\u003c/tt\u003e).\n * In addition to implementing the \u003ctt\u003eList\u003c/tt\u003e interface, the\n * \u003ctt\u003eDoubleLinkedList\u003c/tt\u003e class provides uniformly named methods to\n * \u003ctt\u003eget\u003c/tt\u003e, \u003ctt\u003eremove\u003c/tt\u003e and \u003ctt\u003einsert\u003c/tt\u003e an element at the beginning\n * and end of the list. These operations allow linked lists to be used as a\n * stack, queue, or double-ended queue (deque).\n * \u003cp\u003e\n *\n * All of the stack/queue/deque operations could be easily recast in terms of\n * the standard list operations. They're included here primarily for\n * convenience, though they may run slightly faster than the equivalent List\n * operations.\n * \u003cp\u003e\n *\n * All of the operations perform as could be expected for a doubly-linked list.\n * Operations that index into the list will traverse the list from the begining\n * or the end, whichever is closer to the specified index.\n * \u003cp\u003e\n *\n * \u003cb\u003eNote that this implementation is not synchronized.\u003c/b\u003e If multiple threads\n * access a list concurrently, and at least one of the threads modifies the list\n * structurally, it \u003ci\u003emust\u003c/i\u003e be synchronized externally. (A structural\n * modification is any operation that adds or deletes one or more elements;\n * merely setting the value of an element is not a structural modification.)\n * This is typically accomplished by synchronizing on some object that naturally\n * encapsulates the list. If no such object exists, the list should be \"wrapped\"\n * using the Collections.synchronizedList method. This is best done at creation\n * time, to prevent accidental unsynchronized access to the list:\n *\n * \u003cpre\u003e\n *     List list = Collections.synchronizedList(new DoubleLinkedList(...));\n * \u003c/pre\u003e\n * \u003cp\u003e\n *\n * The iterators returned by the this class's \u003ctt\u003eiterator\u003c/tt\u003e and\n * \u003ctt\u003elistIterator\u003c/tt\u003e methods are \u003ci\u003efail-fast\u003c/i\u003e: if the list is\n * structurally modified at any time after the iterator is created, in any way\n * except through the Iterator's own \u003ctt\u003eremove\u003c/tt\u003e or \u003ctt\u003eadd\u003c/tt\u003e methods,\n * the iterator will throw a \u003ctt\u003eConcurrentModificationException\u003c/tt\u003e. Thus, in\n * the face of concurrent modification, the iterator fails quickly and cleanly,\n * rather than risking arbitrary, non-deterministic behavior at an undetermined\n * time in the future.\n *\n * \u003cp\u003e\n * Note that the fail-fast behavior of an iterator cannot be guaranteed as it\n * is, generally speaking, impossible to make any hard guarantees in the\n * presence of unsynchronized concurrent modification. Fail-fast iterators throw\n * \u003ctt\u003eConcurrentModificationException\u003c/tt\u003e on a best-effort basis. Therefore,\n * it would be wrong to write a program that depended on this exception for its\n * correctness: \u003ci\u003ethe fail-fast behavior of iterators should be used only to\n * detect bugs.\u003c/i\u003e\n * \u003cp\u003e\n *\n * This class is a member of the \u003ca href=\"{@docRoot}\n * /../guide/collections/index.html\"\u003e Java Collections Framework\u003c/a\u003e.\n *\n * @author Josh Bloch\n * @version 1.46, 01/23/03\n * @see List\n * @see ArrayList\n * @see Vector\n * @see Collections#synchronizedList(List)\n * @since 1.2\n */\n\npublic class DoubleLinkedList {\n    //@ invariant repOK();\n\n    protected transient int modCount = 0;\n    private transient Entry header = new Entry(null, null, null);\n    private transient int size = 0;\n\n    /**\n     * Constructs an empty list.\n     */\n    public DoubleLinkedList() {\n        header.next = header.previous = header;\n    }\n\n    /**\n     * Constructs a list containing the elements of the specified collection, in\n     * the order they are returned by the collection's iterator.\n     *\n     * @param c\n     *            the collection whose elements are to be placed into this list.\n     * @throws NullPointerException\n     *             if the specified collection is null.\n     */\n    public DoubleLinkedList(Collection c) {\n        this();\n        addAll(c);\n    }\n\n    boolean repOK() {\n        if (header == null) {\n            return false;\n        }\n        Entry tmp = header;\n        int i = 0;\n        do {\n            if (!tmp.nonNullPointers() || !tmp.repOK()) {\n                return false;\n            }\n            tmp = tmp.next;\n            if (tmp != header) {\n                i++;\n            }\n        } while (tmp != header);\n        tmp = header;\n        return i == size;\n    }\n\n    public boolean test(DoubleLinkedList dll, Object o) {\n        dll.add(o);\n        return dll.getLast() == o;\n    }\n\n    boolean inList(Entry e) {\n        if (header == e) {\n            return true;\n        }\n        Entry tmp = header.next;\n        while (tmp != header) {\n            if (tmp == e) {\n                return true;\n            }\n            tmp = tmp.next;\n        }\n        return false;\n    }\n\n    /**\n     * Returns the first element in this list.\n     *\n     * @return the first element in this list.\n     * @throws NoSuchElementException\n     *             if this list is empty.\n     */\n    //@ requires size \u003e 0;\n    public Object getFirst() {\n        if (size == 0)\n            throw new NoSuchElementException();\n\n        return header.next.element;\n    }\n\n    /**\n     * Returns the last element in this list.\n     *\n     * @return the last element in this list.\n     * @throws NoSuchElementException\n     *             if this list is empty.\n     */\n    public Object getLast() {\n        if (size == 0)\n            throw new NoSuchElementException();\n\n        return header.previous.element;\n    }\n\n    /**\n     * Removes and returns the first element from this list.\n     *\n     * @return the first element from this list.\n     * @throws NoSuchElementException\n     *             if this list is empty.\n     */\n    public Object removeFirst() {\n        Object first = header.next.element;\n        remove(header.next);\n        return first;\n    }\n\n    /**\n     * Removes and returns the last element from this list.\n     *\n     * @return the last element from this list.\n     * @throws NoSuchElementException\n     *             if this list is empty.\n     */\n    public Object removeLast() {\n        Object last = header.previous.element;\n        remove(header.previous);\n        return last;\n    }\n\n    /**\n     * Inserts the given element at the beginning of this list.\n     *\n     * @param o\n     *            the element to be inserted at the beginning of this list.\n     */\n    public void addFirst(Object o) {\n        addBefore(o, header.next);\n    }\n\n    /**\n     * Appends the given element to the end of this list. (Identical in function\n     * to the \u003ctt\u003eadd\u003c/tt\u003e method; included only for consistency.)\n     *\n     * @param o\n     *            the element to be inserted at the end of this list.\n     */\n    public void addLast(Object o) {\n        addBefore(o, header);\n    }\n\n    /**\n     * Returns \u003ctt\u003etrue\u003c/tt\u003e if this list contains the specified element. More\n     * formally, returns \u003ctt\u003etrue\u003c/tt\u003e if and only if this list contains at\n     * least one element \u003ctt\u003ee\u003c/tt\u003e such that \u003ctt\u003e(o==null ? e==null\n     * : o.equals(e))\u003c/tt\u003e.\n     *\n     * @param o\n     *            element whose presence in this list is to be tested.\n     * @return \u003ctt\u003etrue\u003c/tt\u003e if this list contains the specified element.\n     */\n    public boolean contains(Object o) {\n        return indexOf(o) != -1;\n    }\n\n    /**\n     * Returns the number of elements in this list.\n     *\n     * @return the number of elements in this list.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Appends the specified element to the end of this list.\n     *\n     * @param o\n     *            element to be appended to this list.\n     * @return \u003ctt\u003etrue\u003c/tt\u003e (as per the general contract of\n     *         \u003ctt\u003eCollection.add\u003c/tt\u003e).\n     */\n    public boolean add(Object o) {\n        addBefore(o, header);\n        return true;\n    }\n\n    /**\n     * Removes the first occurrence of the specified element in this list. If\n     * the list does not contain the element, it is unchanged. More formally,\n     * removes the element with the lowest index \u003ctt\u003ei\u003c/tt\u003e such that\n     * \u003ctt\u003e(o==null ? get(i)==null : o.equals(get(i)))\u003c/tt\u003e (if such an element\n     * exists).\n     *\n     * @param o\n     *            element to be removed from this list, if present.\n     * @return \u003ctt\u003etrue\u003c/tt\u003e if the list contained the specified element.\n     */\n    public boolean remove(Object o) {\n        if (o == null) {\n            for (Entry e = header.next; e != header; e = e.next) {\n                if (e.element == null) {\n                    remove(e);\n                    return true;\n                }\n            }\n        } else {\n            for (Entry e = header.next; e != header; e = e.next) {\n                if (o == e.element) {\n                    // if (o.equals(e.element)) {\n                    remove(e);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Appends all of the elements in the specified collection to the end of\n     * this list, in the order that they are returned by the specified\n     * collection's iterator. The behavior of this operation is undefined if the\n     * specified collection is modified while the operation is in progress.\n     * (This implies that the behavior of this call is undefined if the\n     * specified Collection is this list, and this list is nonempty.)\n     *\n     * @param c\n     *            the elements to be inserted into this list.\n     * @return \u003ctt\u003etrue\u003c/tt\u003e if this list changed as a result of the call.\n     * @throws NullPointerException\n     *             if the specified collection is null.\n     */\n    public boolean addAll(Collection c) {\n        return addAll(size, c);\n    }\n\n    /**\n     * Inserts all of the elements in the specified collection into this list,\n     * starting at the specified position. Shifts the element currently at that\n     * position (if any) and any subsequent elements to the right (increases\n     * their indices). The new elements will appear in the list in the order\n     * that they are returned by the specified collection's iterator.\n     *\n     * @param index\n     *            index at which to insert first element from the specified\n     *            collection.\n     * @param c\n     *            elements to be inserted into this list.\n     * @return \u003ctt\u003etrue\u003c/tt\u003e if this list changed as a result of the call.\n     * @throws IndexOutOfBoundsException\n     *             if the specified index is out of range (\n     *             \u003ctt\u003eindex \u0026lt; 0 || index \u0026gt; size()\u003c/tt\u003e).\n     * @throws NullPointerException\n     *             if the specified collection is null.\n     */\n    public boolean addAll(int index, Collection c) {\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        if (numNew == 0)\n            return false;\n        modCount++;\n\n        Entry successor = (index == size ? header : entry(index));\n        Entry predecessor = successor.previous;\n        for (int i = 0; i \u003c numNew; i++) {\n            Entry e = new Entry(a[i], successor, predecessor);\n            predecessor.next = e;\n            predecessor = e;\n        }\n        successor.previous = predecessor;\n\n        size += numNew;\n        return true;\n    }\n\n    /**\n     * Removes all of the elements from this list.\n     */\n    //@ ensures size == 0;\n    public void clear() {\n        modCount++;\n        header.next = header.previous = header;\n        size = 0;\n    }\n\n    // Positional Access Operations\n\n    /**\n     * Returns the element at the specified position in this list.\n     *\n     * @param index\n     *            index of element to return.\n     * @return the element at the specified position in this list.\n     *\n     * @throws IndexOutOfBoundsException\n     *             if the specified index is is out of range (\n     *             \u003ctt\u003eindex \u0026lt; 0 || index \u0026gt;= size()\u003c/tt\u003e).\n     */\n    public Object get(int index) {\n        return entry(index).element;\n    }\n\n    /**\n     * Replaces the element at the specified position in this list with the\n     * specified element.\n     *\n     * @param index\n     *            index of element to replace.\n     * @param element\n     *            element to be stored at the specified position.\n     * @return the element previously at the specified position.\n     * @throws IndexOutOfBoundsException\n     *             if the specified index is out of range (\n     *             \u003ctt\u003eindex \u0026lt; 0 || index \u0026gt;= size()\u003c/tt\u003e).\n     */\n    public Object set(int index, Object element) {\n        Entry e = entry(index);\n        Object oldVal = e.element;\n        e.element = element;\n        return oldVal;\n    }\n\n    /**\n     * Inserts the specified element at the specified position in this list.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).\n     *\n     * @param index\n     *            index at which the specified element is to be inserted.\n     * @param element\n     *            element to be inserted.\n     *\n     * @throws IndexOutOfBoundsException\n     *             if the specified index is out of range (\n     *             \u003ctt\u003eindex \u0026lt; 0 || index \u0026gt; size()\u003c/tt\u003e).\n     */\n    public void add(int index, Object element) {\n        addBefore(element, (index == size ? header : entry(index)));\n    }\n\n    /**\n     * Removes the element at the specified position in this list. Shifts any\n     * subsequent elements to the left (subtracts one from their indices).\n     * Returns the element that was removed from the list.\n     *\n     * @param index\n     *            the index of the element to removed.\n     * @return the element previously at the specified position.\n     *\n     * @throws IndexOutOfBoundsException\n     *             if the specified index is out of range (\n     *             \u003ctt\u003eindex \u0026lt; 0 || index \u0026gt;= size()\u003c/tt\u003e).\n     */\n    public Object remove(int index) {\n        Entry e = entry(index);\n        remove(e);\n        return e.element;\n    }\n\n    /**\n     * Return the indexed entry.\n     */\n    private Entry entry(int index) {\n        if (index \u003c 0 || index \u003e= size)\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \"\n                                                + size);\n        Entry e = header;\n        // if (index \u003c (size \u003e\u003e 1)) { // Kiasan can not handle bit shifting\n        // currently.\n        // if (index \u003c (size/2)) {\n        for (int i = 0; i \u003c= index; i++)\n            e = e.next;\n        /*\n         * } else { for (int i = size; i \u003e index; i--) e = e.previous; }\n         */\n        return e;\n    }\n\n    // Search Operations\n\n    /**\n     * Returns the index in this list of the first occurrence of the specified\n     * element, or -1 if the List does not contain this element. More formally,\n     * returns the lowest index i such that\n     * \u003ctt\u003e(o==null ? get(i)==null : o.equals(get(i)))\u003c/tt\u003e, or -1 if there is\n     * no such index.\n     *\n     * @param o\n     *            element to search for.\n     * @return the index in this list of the first occurrence of the specified\n     *         element, or -1 if the list does not contain this element.\n     */\n    public int indexOf(Object o) {\n        int index = 0;\n        if (o == null) {\n            for (Entry e = header.next; e != header; e = e.next) {\n                if (e.element == null)\n                    return index;\n                index++;\n            }\n        } else {\n            for (Entry e = header.next; e != header; e = e.next) {\n                if (o == e.element)\n                    return index;\n                index++;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the index in this list of the last occurrence of the specified\n     * element, or -1 if the list does not contain this element. More formally,\n     * returns the highest index i such that\n     * \u003ctt\u003e(o==null ? get(i)==null : o.equals(get(i)))\u003c/tt\u003e, or -1 if there is\n     * no such index.\n     *\n     * @param o\n     *            element to search for.\n     * @return the index in this list of the last occurrence of the specified\n     *         element, or -1 if the list does not contain this element.\n     */\n    public int lastIndexOf(Object o) {\n        int index = size;\n        if (o == null) {\n            for (Entry e = header.previous; e != header; e = e.previous) {\n                index--;\n                if (e.element == null)\n                    return index;\n            }\n        } else {\n            for (Entry e = header.previous; e != header; e = e.previous) {\n                index--;\n                if (o == e.element)\n                    return index;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns a list-iterator of the elements in this list (in proper\n     * sequence), starting at the specified position in the list. Obeys the\n     * general contract of \u003ctt\u003eList.listIterator(int)\u003c/tt\u003e.\n     * \u003cp\u003e\n     *\n     * The list-iterator is \u003ci\u003efail-fast\u003c/i\u003e: if the list is structurally\n     * modified at any time after the Iterator is created, in any way except\n     * through the list-iterator's own \u003ctt\u003eremove\u003c/tt\u003e or \u003ctt\u003eadd\u003c/tt\u003e methods,\n     * the list-iterator will throw a \u003ctt\u003eConcurrentModificationException\u003c/tt\u003e.\n     * Thus, in the face of concurrent modification, the iterator fails quickly\n     * and cleanly, rather than risking arbitrary, non-deterministic behavior at\n     * an undetermined time in the future.\n     *\n     * @param index\n     *            index of first element to be returned from the list-iterator\n     *            (by a call to \u003ctt\u003enext\u003c/tt\u003e).\n     * @return a ListIterator of the elements in this list (in proper sequence),\n     *         starting at the specified position in the list.\n     * @throws IndexOutOfBoundsException\n     *             if index is out of range (\n     *             \u003ctt\u003eindex \u0026lt; 0 || index \u0026gt; size()\u003c/tt\u003e).\n     * @see List#listIterator(int)\n     */\n    public ListIterator listIterator(int index) {\n        return new ListItr(index);\n    }\n\n    private class ListItr implements ListIterator {\n        private Entry lastReturned = header;\n        private Entry next;\n        private int nextIndex;\n        private int expectedModCount = modCount;\n\n        ListItr(int index) {\n            if (index \u003c 0 || index \u003e size)\n                throw new IndexOutOfBoundsException(\"Index: \" + index\n                                                    + \", Size: \" + size);\n            if (index \u003c (size \u003e\u003e 1)) {\n                next = header.next;\n                for (nextIndex = 0; nextIndex \u003c index; nextIndex++)\n                    next = next.next;\n            } else {\n                next = header;\n                for (nextIndex = size; nextIndex \u003e index; nextIndex--)\n                    next = next.previous;\n            }\n        }\n\n        public boolean hasNext() {\n            return nextIndex != size;\n        }\n\n        public Object next() {\n            checkForComodification();\n            if (nextIndex == size)\n                throw new NoSuchElementException();\n\n            lastReturned = next;\n            next = next.next;\n            nextIndex++;\n            return lastReturned.element;\n        }\n\n        public boolean hasPrevious() {\n            return nextIndex != 0;\n        }\n\n        public Object previous() {\n            if (nextIndex == 0)\n                throw new NoSuchElementException();\n\n            lastReturned = next = next.previous;\n            nextIndex--;\n            checkForComodification();\n            return lastReturned.element;\n        }\n\n        public int nextIndex() {\n            return nextIndex;\n        }\n\n        public int previousIndex() {\n            return nextIndex - 1;\n        }\n\n        public void remove() {\n            checkForComodification();\n            try {\n                DoubleLinkedList.this.remove(lastReturned);\n            } catch (NoSuchElementException e) {\n                throw new IllegalStateException();\n            }\n            if (next == lastReturned)\n                next = lastReturned.next;\n            else\n                nextIndex--;\n            lastReturned = header;\n            expectedModCount++;\n        }\n\n        public void set(Object o) {\n            if (lastReturned == header)\n                throw new IllegalStateException();\n            checkForComodification();\n            lastReturned.element = o;\n        }\n\n        public void add(Object o) {\n            checkForComodification();\n            lastReturned = header;\n            addBefore(o, next);\n            nextIndex++;\n            expectedModCount++;\n        }\n\n        final void checkForComodification() {\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n        }\n    }\n\n    private static class Entry {\n        Object element;\n        Entry next;\n        Entry previous;\n\n        Entry(Object element, Entry next, Entry previous) {\n            this.element = element;\n            this.next = next;\n            this.previous = previous;\n        }\n\n        boolean nonNullPointers() {\n            return next != null \u0026\u0026 previous != null;\n        }\n\n        boolean repOK() {\n            return next.previous == this;\n        }\n    }\n\n    //@ requires inList(e);\n    private Entry addBefore(Object o, Entry e) {\n        Entry newEntry = new Entry(o, e, e.previous);\n        newEntry.previous.next = newEntry;\n        newEntry.next.previous = newEntry;\n        size++;\n        modCount++;\n        return newEntry;\n    }\n\n    private void remove(Entry e) {\n        if (e == header)\n            throw new NoSuchElementException();\n\n        e.previous.next = e.next;\n        e.next.previous = e.previous;\n        size--;\n        modCount++;\n    }\n\n    /**\n     * Returns a shallow copy of this \u003ctt\u003eDoubleLinkedList\u003c/tt\u003e. (The elements\n     * themselves are not cloned.)\n     *\n     * @return a shallow copy of this \u003ctt\u003eDoubleLinkedList\u003c/tt\u003e instance.\n     */\n    public Object clone() {\n        DoubleLinkedList clone = null;\n        try {\n            clone = (DoubleLinkedList) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new InternalError();\n        }\n\n        // Put clone into \"virgin\" state\n        clone.header = new Entry(null, null, null);\n        clone.header.next = clone.header.previous = clone.header;\n        clone.size = 0;\n        clone.modCount = 0;\n\n        // Initialize clone with our elements\n        for (Entry e = header.next; e != header; e = e.next)\n            clone.add(e.element);\n\n        return clone;\n    }\n\n    /**\n     * Returns an array containing all of the elements in this list in the\n     * correct order.\n     *\n     * @return an array containing all of the elements in this list in the\n     *         correct order.\n     */\n    //@ ensures \\result != null \u0026\u0026 \\result.length == size;\n    public Object[] toArray() {\n        Object[] result = new Object[size];\n        int i = 0;\n        for (Entry e = header.next; e != header; e = e.next)\n            result[i++] = e.element;\n        return result;\n    }\n\n    boolean containsAllInOrder(Object[] objs) {\n        for (int i = 0; i \u003c size; i++) {\n            if (get(i) != objs[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns an array containing all of the elements in this list in the\n     * correct order; the runtime type of the returned array is that of the\n     * specified array. If the list fits in the specified array, it is returned\n     * therein. Otherwise, a new array is allocated with the runtime type of the\n     * specified array and the size of this list.\n     * \u003cp\u003e\n     *\n     * If the list fits in the specified array with room to spare (i.e., the\n     * array has more elements than the list), the element in the array\n     * immediately following the end of the collection is set to null. This is\n     * useful in determining the length of the list \u003ci\u003eonly\u003c/i\u003e if the caller\n     * knows that the list does not contain any null elements.\n     *\n     * @param a\n     *            the array into which the elements of the list are to be\n     *            stored, if it is big enough; otherwise, a new array of the\n     *            same runtime type is allocated for this purpose.\n     * @return an array containing the elements of the list.\n     * @throws ArrayStoreException\n     *             if the runtime type of a is not a supertype of the runtime\n     *             type of every element in this list.\n     * @throws NullPointerException\n     *             if the specified array is null.\n     */\n    public Object[] toArray(Object a[]) {\n        if (a.length \u003c size)\n            a = (Object[]) java.lang.reflect.Array.newInstance(a.getClass()\n                    .getComponentType(), size);\n        int i = 0;\n        for (Entry e = header.next; e != header; e = e.next)\n            a[i++] = e.element;\n\n        if (a.length \u003e size)\n            a[size] = null;\n\n        return a;\n    }\n\n    private static final long serialVersionUID = 876323262645176354L;\n\n    /**\n     * Save the state of this \u003ctt\u003eDoubleLinkedList\u003c/tt\u003e instance to a stream\n     * (that is, serialize it).\n     *\n     * @serialData The size of the list (the number of elements it contains) is\n     *             emitted (int), followed by all of its elements (each an\n     *             Object) in the proper order.\n     */\n    private void writeObject(java.io.ObjectOutputStream s)\n    throws java.io.IOException {\n        // Write out any hidden serialization magic\n        s.defaultWriteObject();\n\n        // Write out size\n        s.writeInt(size);\n\n        // Write out all elements in the proper order.\n        for (Entry e = header.next; e != header; e = e.next)\n            s.writeObject(e.element);\n    }\n\n    /**\n     * Reconstitute this \u003ctt\u003eDoubleLinkedList\u003c/tt\u003e instance from a stream (that\n     * is deserialize it).\n     */\n    private void readObject(java.io.ObjectInputStream s)\n    throws java.io.IOException, ClassNotFoundException {\n        // Read in any hidden serialization magic\n        s.defaultReadObject();\n\n        // Read in size\n        int size = s.readInt();\n\n        // Initialize header\n        header = new Entry(null, null, null);\n        header.next = header.previous = header;\n\n        // Read in all elements in the proper order.\n        for (int i = 0; i \u003c size; i++)\n            add(s.readObject());\n    }\n}\n",
        "name": "DoubleLinkedList.java",
        "path": "demos/OLD/demos/basics/doublelinkedlist/src/main/java/DoubleLinkedList.java",
        "url": "/github.com/STAR-RG/practical_testing_book/-/blob/demos/OLD/demos/basics/doublelinkedlist/src/main/java/DoubleLinkedList.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 149,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires size \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 345,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures size == 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 649,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires inList(e);"
        },
        {
          "limitHit": false,
          "lineNumber": 703,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result != null \u0026\u0026 \\result.length == size;"
        }
      ],
      "repository": {
        "name": "github.com/STAR-RG/practical_testing_book",
        "url": "/github.com/STAR-RG/practical_testing_book"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "3372bf612040ff087f3ba2d0de650ceee7196c5a"
        },
        "content": "import java.util.*;\n/*\n * @(#)DoubleLinkedList.java\t1.46 03/01/23\n *\n * Copyright 2003 Sun Microsystems, Inc. All rights reserved.\n * SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n */\n\n\n/**\n * Linked list implementation of the \u003ctt\u003eList\u003c/tt\u003e interface. Implements all\n * optional list operations, and permits all elements (including \u003ctt\u003enull\u003c/tt\u003e).\n * In addition to implementing the \u003ctt\u003eList\u003c/tt\u003e interface, the\n * \u003ctt\u003eDoubleLinkedList\u003c/tt\u003e class provides uniformly named methods to\n * \u003ctt\u003eget\u003c/tt\u003e, \u003ctt\u003eremove\u003c/tt\u003e and \u003ctt\u003einsert\u003c/tt\u003e an element at the beginning\n * and end of the list. These operations allow linked lists to be used as a\n * stack, queue, or double-ended queue (deque).\n * \u003cp\u003e\n *\n * All of the stack/queue/deque operations could be easily recast in terms of\n * the standard list operations. They're included here primarily for\n * convenience, though they may run slightly faster than the equivalent List\n * operations.\n * \u003cp\u003e\n *\n * All of the operations perform as could be expected for a doubly-linked list.\n * Operations that index into the list will traverse the list from the begining\n * or the end, whichever is closer to the specified index.\n * \u003cp\u003e\n *\n * \u003cb\u003eNote that this implementation is not synchronized.\u003c/b\u003e If multiple threads\n * access a list concurrently, and at least one of the threads modifies the list\n * structurally, it \u003ci\u003emust\u003c/i\u003e be synchronized externally. (A structural\n * modification is any operation that adds or deletes one or more elements;\n * merely setting the value of an element is not a structural modification.)\n * This is typically accomplished by synchronizing on some object that naturally\n * encapsulates the list. If no such object exists, the list should be \"wrapped\"\n * using the Collections.synchronizedList method. This is best done at creation\n * time, to prevent accidental unsynchronized access to the list:\n *\n * \u003cpre\u003e\n *     List list = Collections.synchronizedList(new DoubleLinkedList(...));\n * \u003c/pre\u003e\n * \u003cp\u003e\n *\n * The iterators returned by the this class's \u003ctt\u003eiterator\u003c/tt\u003e and\n * \u003ctt\u003elistIterator\u003c/tt\u003e methods are \u003ci\u003efail-fast\u003c/i\u003e: if the list is\n * structurally modified at any time after the iterator is created, in any way\n * except through the Iterator's own \u003ctt\u003eremove\u003c/tt\u003e or \u003ctt\u003eadd\u003c/tt\u003e methods,\n * the iterator will throw a \u003ctt\u003eConcurrentModificationException\u003c/tt\u003e. Thus, in\n * the face of concurrent modification, the iterator fails quickly and cleanly,\n * rather than risking arbitrary, non-deterministic behavior at an undetermined\n * time in the future.\n *\n * \u003cp\u003e\n * Note that the fail-fast behavior of an iterator cannot be guaranteed as it\n * is, generally speaking, impossible to make any hard guarantees in the\n * presence of unsynchronized concurrent modification. Fail-fast iterators throw\n * \u003ctt\u003eConcurrentModificationException\u003c/tt\u003e on a best-effort basis. Therefore,\n * it would be wrong to write a program that depended on this exception for its\n * correctness: \u003ci\u003ethe fail-fast behavior of iterators should be used only to\n * detect bugs.\u003c/i\u003e\n * \u003cp\u003e\n *\n * This class is a member of the \u003ca href=\"{@docRoot}\n * /../guide/collections/index.html\"\u003e Java Collections Framework\u003c/a\u003e.\n *\n * @author Josh Bloch\n * @version 1.46, 01/23/03\n * @see List\n * @see ArrayList\n * @see Vector\n * @see Collections#synchronizedList(List)\n * @since 1.2\n */\n\npublic class DoubleLinkedList {\n    //@ invariant repOK();\n\n    protected transient int modCount = 0;\n    private transient Entry header = new Entry(null, null, null);\n    private transient int size = 0;\n\n    /**\n     * Constructs an empty list.\n     */\n    public DoubleLinkedList() {\n        header.next = header.previous = header;\n    }\n\n    /**\n     * Constructs a list containing the elements of the specified collection, in\n     * the order they are returned by the collection's iterator.\n     *\n     * @param c\n     *            the collection whose elements are to be placed into this list.\n     * @throws NullPointerException\n     *             if the specified collection is null.\n     */\n    public DoubleLinkedList(Collection c) {\n        this();\n        addAll(c);\n    }\n\n    boolean repOK() {\n        if (header == null) {\n            return false;\n        }\n        Entry tmp = header;\n        int i = 0;\n        do {\n            if (!tmp.nonNullPointers() || !tmp.repOK()) {\n                return false;\n            }\n            tmp = tmp.next;\n            if (tmp != header) {\n                i++;\n            }\n        } while (tmp != header);\n        tmp = header;\n        return i == size;\n    }\n\n    public boolean test(DoubleLinkedList dll, Object o) {\n        dll.add(o);\n        return dll.getLast() == o;\n    }\n\n    boolean inList(Entry e) {\n        if (header == e) {\n            return true;\n        }\n        Entry tmp = header.next;\n        while (tmp != header) {\n            if (tmp == e) {\n                return true;\n            }\n            tmp = tmp.next;\n        }\n        return false;\n    }\n\n    /**\n     * Returns the first element in this list.\n     *\n     * @return the first element in this list.\n     * @throws NoSuchElementException\n     *             if this list is empty.\n     */\n    //@ requires size \u003e 0;\n    public Object getFirst() {\n        if (size == 0)\n            throw new NoSuchElementException();\n\n        return header.next.element;\n    }\n\n    /**\n     * Returns the last element in this list.\n     *\n     * @return the last element in this list.\n     * @throws NoSuchElementException\n     *             if this list is empty.\n     */\n    public Object getLast() {\n        if (size == 0)\n            throw new NoSuchElementException();\n\n        return header.previous.element;\n    }\n\n    /**\n     * Removes and returns the first element from this list.\n     *\n     * @return the first element from this list.\n     * @throws NoSuchElementException\n     *             if this list is empty.\n     */\n    public Object removeFirst() {\n        Object first = header.next.element;\n        remove(header.next);\n        return first;\n    }\n\n    /**\n     * Removes and returns the last element from this list.\n     *\n     * @return the last element from this list.\n     * @throws NoSuchElementException\n     *             if this list is empty.\n     */\n    public Object removeLast() {\n        Object last = header.previous.element;\n        remove(header.previous);\n        return last;\n    }\n\n    /**\n     * Inserts the given element at the beginning of this list.\n     *\n     * @param o\n     *            the element to be inserted at the beginning of this list.\n     */\n    public void addFirst(Object o) {\n        addBefore(o, header.next);\n    }\n\n    /**\n     * Appends the given element to the end of this list. (Identical in function\n     * to the \u003ctt\u003eadd\u003c/tt\u003e method; included only for consistency.)\n     *\n     * @param o\n     *            the element to be inserted at the end of this list.\n     */\n    public void addLast(Object o) {\n        addBefore(o, header);\n    }\n\n    /**\n     * Returns \u003ctt\u003etrue\u003c/tt\u003e if this list contains the specified element. More\n     * formally, returns \u003ctt\u003etrue\u003c/tt\u003e if and only if this list contains at\n     * least one element \u003ctt\u003ee\u003c/tt\u003e such that \u003ctt\u003e(o==null ? e==null\n     * : o.equals(e))\u003c/tt\u003e.\n     *\n     * @param o\n     *            element whose presence in this list is to be tested.\n     * @return \u003ctt\u003etrue\u003c/tt\u003e if this list contains the specified element.\n     */\n    public boolean contains(Object o) {\n        return indexOf(o) != -1;\n    }\n\n    /**\n     * Returns the number of elements in this list.\n     *\n     * @return the number of elements in this list.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Appends the specified element to the end of this list.\n     *\n     * @param o\n     *            element to be appended to this list.\n     * @return \u003ctt\u003etrue\u003c/tt\u003e (as per the general contract of\n     *         \u003ctt\u003eCollection.add\u003c/tt\u003e).\n     */\n    public boolean add(Object o) {\n        addBefore(o, header);\n        return true;\n    }\n\n    /**\n     * Removes the first occurrence of the specified element in this list. If\n     * the list does not contain the element, it is unchanged. More formally,\n     * removes the element with the lowest index \u003ctt\u003ei\u003c/tt\u003e such that\n     * \u003ctt\u003e(o==null ? get(i)==null : o.equals(get(i)))\u003c/tt\u003e (if such an element\n     * exists).\n     *\n     * @param o\n     *            element to be removed from this list, if present.\n     * @return \u003ctt\u003etrue\u003c/tt\u003e if the list contained the specified element.\n     */\n    public boolean remove(Object o) {\n        if (o == null) {\n            for (Entry e = header.next; e != header; e = e.next) {\n                if (e.element == null) {\n                    remove(e);\n                    return true;\n                }\n            }\n        } else {\n            for (Entry e = header.next; e != header; e = e.next) {\n                if (o == e.element) {\n                    // if (o.equals(e.element)) {\n                    remove(e);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Appends all of the elements in the specified collection to the end of\n     * this list, in the order that they are returned by the specified\n     * collection's iterator. The behavior of this operation is undefined if the\n     * specified collection is modified while the operation is in progress.\n     * (This implies that the behavior of this call is undefined if the\n     * specified Collection is this list, and this list is nonempty.)\n     *\n     * @param c\n     *            the elements to be inserted into this list.\n     * @return \u003ctt\u003etrue\u003c/tt\u003e if this list changed as a result of the call.\n     * @throws NullPointerException\n     *             if the specified collection is null.\n     */\n    public boolean addAll(Collection c) {\n        return addAll(size, c);\n    }\n\n    /**\n     * Inserts all of the elements in the specified collection into this list,\n     * starting at the specified position. Shifts the element currently at that\n     * position (if any) and any subsequent elements to the right (increases\n     * their indices). The new elements will appear in the list in the order\n     * that they are returned by the specified collection's iterator.\n     *\n     * @param index\n     *            index at which to insert first element from the specified\n     *            collection.\n     * @param c\n     *            elements to be inserted into this list.\n     * @return \u003ctt\u003etrue\u003c/tt\u003e if this list changed as a result of the call.\n     * @throws IndexOutOfBoundsException\n     *             if the specified index is out of range (\n     *             \u003ctt\u003eindex \u0026lt; 0 || index \u0026gt; size()\u003c/tt\u003e).\n     * @throws NullPointerException\n     *             if the specified collection is null.\n     */\n    public boolean addAll(int index, Collection c) {\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        if (numNew == 0)\n            return false;\n        modCount++;\n\n        Entry successor = (index == size ? header : entry(index));\n        Entry predecessor = successor.previous;\n        for (int i = 0; i \u003c numNew; i++) {\n            Entry e = new Entry(a[i], successor, predecessor);\n            predecessor.next = e;\n            predecessor = e;\n        }\n        successor.previous = predecessor;\n\n        size += numNew;\n        return true;\n    }\n\n    /**\n     * Removes all of the elements from this list.\n     */\n    //@ ensures size == 0;\n    public void clear() {\n        modCount++;\n        header.next = header.previous = header;\n        size = 0;\n    }\n\n    // Positional Access Operations\n\n    /**\n     * Returns the element at the specified position in this list.\n     *\n     * @param index\n     *            index of element to return.\n     * @return the element at the specified position in this list.\n     *\n     * @throws IndexOutOfBoundsException\n     *             if the specified index is is out of range (\n     *             \u003ctt\u003eindex \u0026lt; 0 || index \u0026gt;= size()\u003c/tt\u003e).\n     */\n    public Object get(int index) {\n        return entry(index).element;\n    }\n\n    /**\n     * Replaces the element at the specified position in this list with the\n     * specified element.\n     *\n     * @param index\n     *            index of element to replace.\n     * @param element\n     *            element to be stored at the specified position.\n     * @return the element previously at the specified position.\n     * @throws IndexOutOfBoundsException\n     *             if the specified index is out of range (\n     *             \u003ctt\u003eindex \u0026lt; 0 || index \u0026gt;= size()\u003c/tt\u003e).\n     */\n    public Object set(int index, Object element) {\n        Entry e = entry(index);\n        Object oldVal = e.element;\n        e.element = element;\n        return oldVal;\n    }\n\n    /**\n     * Inserts the specified element at the specified position in this list.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).\n     *\n     * @param index\n     *            index at which the specified element is to be inserted.\n     * @param element\n     *            element to be inserted.\n     *\n     * @throws IndexOutOfBoundsException\n     *             if the specified index is out of range (\n     *             \u003ctt\u003eindex \u0026lt; 0 || index \u0026gt; size()\u003c/tt\u003e).\n     */\n    public void add(int index, Object element) {\n        addBefore(element, (index == size ? header : entry(index)));\n    }\n\n    /**\n     * Removes the element at the specified position in this list. Shifts any\n     * subsequent elements to the left (subtracts one from their indices).\n     * Returns the element that was removed from the list.\n     *\n     * @param index\n     *            the index of the element to removed.\n     * @return the element previously at the specified position.\n     *\n     * @throws IndexOutOfBoundsException\n     *             if the specified index is out of range (\n     *             \u003ctt\u003eindex \u0026lt; 0 || index \u0026gt;= size()\u003c/tt\u003e).\n     */\n    public Object remove(int index) {\n        Entry e = entry(index);\n        remove(e);\n        return e.element;\n    }\n\n    /**\n     * Return the indexed entry.\n     */\n    private Entry entry(int index) {\n        if (index \u003c 0 || index \u003e= size)\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \"\n                                                + size);\n        Entry e = header;\n        // if (index \u003c (size \u003e\u003e 1)) { // Kiasan can not handle bit shifting\n        // currently.\n        // if (index \u003c (size/2)) {\n        for (int i = 0; i \u003c= index; i++)\n            e = e.next;\n        /*\n         * } else { for (int i = size; i \u003e index; i--) e = e.previous; }\n         */\n        return e;\n    }\n\n    // Search Operations\n\n    /**\n     * Returns the index in this list of the first occurrence of the specified\n     * element, or -1 if the List does not contain this element. More formally,\n     * returns the lowest index i such that\n     * \u003ctt\u003e(o==null ? get(i)==null : o.equals(get(i)))\u003c/tt\u003e, or -1 if there is\n     * no such index.\n     *\n     * @param o\n     *            element to search for.\n     * @return the index in this list of the first occurrence of the specified\n     *         element, or -1 if the list does not contain this element.\n     */\n    public int indexOf(Object o) {\n        int index = 0;\n        if (o == null) {\n            for (Entry e = header.next; e != header; e = e.next) {\n                if (e.element == null)\n                    return index;\n                index++;\n            }\n        } else {\n            for (Entry e = header.next; e != header; e = e.next) {\n                if (o == e.element)\n                    return index;\n                index++;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the index in this list of the last occurrence of the specified\n     * element, or -1 if the list does not contain this element. More formally,\n     * returns the highest index i such that\n     * \u003ctt\u003e(o==null ? get(i)==null : o.equals(get(i)))\u003c/tt\u003e, or -1 if there is\n     * no such index.\n     *\n     * @param o\n     *            element to search for.\n     * @return the index in this list of the last occurrence of the specified\n     *         element, or -1 if the list does not contain this element.\n     */\n    public int lastIndexOf(Object o) {\n        int index = size;\n        if (o == null) {\n            for (Entry e = header.previous; e != header; e = e.previous) {\n                index--;\n                if (e.element == null)\n                    return index;\n            }\n        } else {\n            for (Entry e = header.previous; e != header; e = e.previous) {\n                index--;\n                if (o == e.element)\n                    return index;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns a list-iterator of the elements in this list (in proper\n     * sequence), starting at the specified position in the list. Obeys the\n     * general contract of \u003ctt\u003eList.listIterator(int)\u003c/tt\u003e.\n     * \u003cp\u003e\n     *\n     * The list-iterator is \u003ci\u003efail-fast\u003c/i\u003e: if the list is structurally\n     * modified at any time after the Iterator is created, in any way except\n     * through the list-iterator's own \u003ctt\u003eremove\u003c/tt\u003e or \u003ctt\u003eadd\u003c/tt\u003e methods,\n     * the list-iterator will throw a \u003ctt\u003eConcurrentModificationException\u003c/tt\u003e.\n     * Thus, in the face of concurrent modification, the iterator fails quickly\n     * and cleanly, rather than risking arbitrary, non-deterministic behavior at\n     * an undetermined time in the future.\n     *\n     * @param index\n     *            index of first element to be returned from the list-iterator\n     *            (by a call to \u003ctt\u003enext\u003c/tt\u003e).\n     * @return a ListIterator of the elements in this list (in proper sequence),\n     *         starting at the specified position in the list.\n     * @throws IndexOutOfBoundsException\n     *             if index is out of range (\n     *             \u003ctt\u003eindex \u0026lt; 0 || index \u0026gt; size()\u003c/tt\u003e).\n     * @see List#listIterator(int)\n     */\n    public ListIterator listIterator(int index) {\n        return new ListItr(index);\n    }\n\n    private class ListItr implements ListIterator {\n        private Entry lastReturned = header;\n        private Entry next;\n        private int nextIndex;\n        private int expectedModCount = modCount;\n\n        ListItr(int index) {\n            if (index \u003c 0 || index \u003e size)\n                throw new IndexOutOfBoundsException(\"Index: \" + index\n                                                    + \", Size: \" + size);\n            if (index \u003c (size \u003e\u003e 1)) {\n                next = header.next;\n                for (nextIndex = 0; nextIndex \u003c index; nextIndex++)\n                    next = next.next;\n            } else {\n                next = header;\n                for (nextIndex = size; nextIndex \u003e index; nextIndex--)\n                    next = next.previous;\n            }\n        }\n\n        public boolean hasNext() {\n            return nextIndex != size;\n        }\n\n        public Object next() {\n            checkForComodification();\n            if (nextIndex == size)\n                throw new NoSuchElementException();\n\n            lastReturned = next;\n            next = next.next;\n            nextIndex++;\n            return lastReturned.element;\n        }\n\n        public boolean hasPrevious() {\n            return nextIndex != 0;\n        }\n\n        public Object previous() {\n            if (nextIndex == 0)\n                throw new NoSuchElementException();\n\n            lastReturned = next = next.previous;\n            nextIndex--;\n            checkForComodification();\n            return lastReturned.element;\n        }\n\n        public int nextIndex() {\n            return nextIndex;\n        }\n\n        public int previousIndex() {\n            return nextIndex - 1;\n        }\n\n        public void remove() {\n            checkForComodification();\n            try {\n                DoubleLinkedList.this.remove(lastReturned);\n            } catch (NoSuchElementException e) {\n                throw new IllegalStateException();\n            }\n            if (next == lastReturned)\n                next = lastReturned.next;\n            else\n                nextIndex--;\n            lastReturned = header;\n            expectedModCount++;\n        }\n\n        public void set(Object o) {\n            if (lastReturned == header)\n                throw new IllegalStateException();\n            checkForComodification();\n            lastReturned.element = o;\n        }\n\n        public void add(Object o) {\n            checkForComodification();\n            lastReturned = header;\n            addBefore(o, next);\n            nextIndex++;\n            expectedModCount++;\n        }\n\n        final void checkForComodification() {\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n        }\n    }\n\n    private static class Entry {\n        Object element;\n        Entry next;\n        Entry previous;\n\n        Entry(Object element, Entry next, Entry previous) {\n            this.element = element;\n            this.next = next;\n            this.previous = previous;\n        }\n\n        boolean nonNullPointers() {\n            return next != null \u0026\u0026 previous != null;\n        }\n\n        boolean repOK() {\n            return next.previous == this;\n        }\n    }\n\n    //@ requires inList(e);\n    private Entry addBefore(Object o, Entry e) {\n        Entry newEntry = new Entry(o, e, e.previous);\n        newEntry.previous.next = newEntry;\n        newEntry.next.previous = newEntry;\n        size++;\n        modCount++;\n        return newEntry;\n    }\n\n    private void remove(Entry e) {\n        if (e == header)\n            throw new NoSuchElementException();\n\n        e.previous.next = e.next;\n        e.next.previous = e.previous;\n        size--;\n        modCount++;\n    }\n\n    /**\n     * Returns a shallow copy of this \u003ctt\u003eDoubleLinkedList\u003c/tt\u003e. (The elements\n     * themselves are not cloned.)\n     *\n     * @return a shallow copy of this \u003ctt\u003eDoubleLinkedList\u003c/tt\u003e instance.\n     */\n    public Object clone() {\n        DoubleLinkedList clone = null;\n        try {\n            clone = (DoubleLinkedList) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new InternalError();\n        }\n\n        // Put clone into \"virgin\" state\n        clone.header = new Entry(null, null, null);\n        clone.header.next = clone.header.previous = clone.header;\n        clone.size = 0;\n        clone.modCount = 0;\n\n        // Initialize clone with our elements\n        for (Entry e = header.next; e != header; e = e.next)\n            clone.add(e.element);\n\n        return clone;\n    }\n\n    /**\n     * Returns an array containing all of the elements in this list in the\n     * correct order.\n     *\n     * @return an array containing all of the elements in this list in the\n     *         correct order.\n     */\n    //@ ensures \\result != null \u0026\u0026 \\result.length == size;\n    public Object[] toArray() {\n        Object[] result = new Object[size];\n        int i = 0;\n        for (Entry e = header.next; e != header; e = e.next)\n            result[i++] = e.element;\n        return result;\n    }\n\n    boolean containsAllInOrder(Object[] objs) {\n        for (int i = 0; i \u003c size; i++) {\n            if (get(i) != objs[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns an array containing all of the elements in this list in the\n     * correct order; the runtime type of the returned array is that of the\n     * specified array. If the list fits in the specified array, it is returned\n     * therein. Otherwise, a new array is allocated with the runtime type of the\n     * specified array and the size of this list.\n     * \u003cp\u003e\n     *\n     * If the list fits in the specified array with room to spare (i.e., the\n     * array has more elements than the list), the element in the array\n     * immediately following the end of the collection is set to null. This is\n     * useful in determining the length of the list \u003ci\u003eonly\u003c/i\u003e if the caller\n     * knows that the list does not contain any null elements.\n     *\n     * @param a\n     *            the array into which the elements of the list are to be\n     *            stored, if it is big enough; otherwise, a new array of the\n     *            same runtime type is allocated for this purpose.\n     * @return an array containing the elements of the list.\n     * @throws ArrayStoreException\n     *             if the runtime type of a is not a supertype of the runtime\n     *             type of every element in this list.\n     * @throws NullPointerException\n     *             if the specified array is null.\n     */\n    public Object[] toArray(Object a[]) {\n        if (a.length \u003c size)\n            a = (Object[]) java.lang.reflect.Array.newInstance(a.getClass()\n                    .getComponentType(), size);\n        int i = 0;\n        for (Entry e = header.next; e != header; e = e.next)\n            a[i++] = e.element;\n\n        if (a.length \u003e size)\n            a[size] = null;\n\n        return a;\n    }\n\n    private static final long serialVersionUID = 876323262645176354L;\n\n    /**\n     * Save the state of this \u003ctt\u003eDoubleLinkedList\u003c/tt\u003e instance to a stream\n     * (that is, serialize it).\n     *\n     * @serialData The size of the list (the number of elements it contains) is\n     *             emitted (int), followed by all of its elements (each an\n     *             Object) in the proper order.\n     */\n    private void writeObject(java.io.ObjectOutputStream s)\n    throws java.io.IOException {\n        // Write out any hidden serialization magic\n        s.defaultWriteObject();\n\n        // Write out size\n        s.writeInt(size);\n\n        // Write out all elements in the proper order.\n        for (Entry e = header.next; e != header; e = e.next)\n            s.writeObject(e.element);\n    }\n\n    /**\n     * Reconstitute this \u003ctt\u003eDoubleLinkedList\u003c/tt\u003e instance from a stream (that\n     * is deserialize it).\n     */\n    private void readObject(java.io.ObjectInputStream s)\n    throws java.io.IOException, ClassNotFoundException {\n        // Read in any hidden serialization magic\n        s.defaultReadObject();\n\n        // Read in size\n        int size = s.readInt();\n\n        // Initialize header\n        header = new Entry(null, null, null);\n        header.next = header.previous = header;\n\n        // Read in all elements in the proper order.\n        for (int i = 0; i \u003c size; i++)\n            add(s.readObject());\n    }\n}\n",
        "name": "DoubleLinkedList.java",
        "path": "demos/3-coverage-jacoco/doublelinkedlist/src/main/java/DoubleLinkedList.java",
        "url": "/github.com/STAR-RG/practical_testing_book/-/blob/demos/3-coverage-jacoco/doublelinkedlist/src/main/java/DoubleLinkedList.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 149,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires size \u003e 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 345,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures size == 0;"
        },
        {
          "limitHit": false,
          "lineNumber": 649,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires inList(e);"
        },
        {
          "limitHit": false,
          "lineNumber": 703,
          "offsetAndLengths": [
            [
              4,
              12
            ]
          ],
          "preview": "    //@ ensures \\result != null \u0026\u0026 \\result.length == size;"
        }
      ],
      "repository": {
        "name": "github.com/STAR-RG/practical_testing_book",
        "url": "/github.com/STAR-RG/practical_testing_book"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 8,
  "ElapsedMilliseconds": 173,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
