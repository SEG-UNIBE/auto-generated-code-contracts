{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/Waikato/moa lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "f37dffdd3dc2ac22f5d66d2b6538e074e021cdc0"
        },
        "content": "/*\n *   This program is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n/*\n *    Utils.java\n *    Copyright (C) 1999-2012 University of Waikato, Hamilton, New Zealand\n *\n */\n\npackage moa.core;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.lang.reflect.Array;\nimport java.net.URL;\nimport java.text.BreakIterator;\nimport java.util.Enumeration;\nimport java.util.Properties;\nimport java.util.Random;\nimport java.util.Vector;\n\n/**\n * Class implementing some simple utility methods.\n *\n * @author Eibe Frank \n * @author Yong Wang \n * @author Len Trigg \n * @author Julien Prados\n * @version $Revision: 8080 $\n */\npublic final class Utils {\n\n  /** The natural logarithm of 2. */\n  public static double log2 = Math.log(2);\n\n  /** The small deviation allowed in double comparisons. */\n  public static double SMALL = 1e-6;\n  \n  /**\n   * Tests if the given value codes \"missing\".\n   *\n   * @param val the value to be tested\n   * @return true if val codes \"missing\"\n   */\n  public static boolean isMissingValue(double val) {\n\n    return Double.isNaN(val);\n  }\n\n  /**\n   * Returns the value used to code a missing value.  Note that\n   * equality tests on this value will always return false, so use\n   * isMissingValue(double val) for testing..\n   *\n   * @return the value used as missing value.\n   */\n  public static double missingValue() {\n    \n    return Double.NaN;\n  }\n\n  /**\n   * Casting an object without \"unchecked\" compile-time warnings.\n   * Use only when absolutely necessary (e.g. when using clone()).\n   */\n  @SuppressWarnings(\"unchecked\")\n    public static \u003cT\u003e T cast(Object x) {\n    return (T) x;\n  }\n  \n  \n\n  /**\n   * Returns the correlation coefficient of two double vectors.\n   *\n   * @param y1 double vector 1\n   * @param y2 double vector 2\n   * @param n the length of two double vectors\n   * @return the correlation coefficient\n   */\n  public static final double correlation(double y1[],double y2[],int n) {\n\n    int i;\n    double av1 = 0.0, av2 = 0.0, y11 = 0.0, y22 = 0.0, y12 = 0.0, c;\n    \n    if (n \u003c= 1) {\n      return 1.0;\n    }\n    for (i = 0; i \u003c n; i++) {\n      av1 += y1[i];\n      av2 += y2[i];\n    }\n    av1 /= (double) n;\n    av2 /= (double) n;\n    for (i = 0; i \u003c n; i++) {\n      y11 += (y1[i] - av1) * (y1[i] - av1);\n      y22 += (y2[i] - av2) * (y2[i] - av2);\n      y12 += (y1[i] - av1) * (y2[i] - av2);\n    }\n    if (y11 * y22 == 0.0) {\n      c=1.0;\n    } else {\n      c = y12 / Math.sqrt(Math.abs(y11 * y22));\n    }\n    \n    return c;\n  }\n\n  /**\n   * Removes all occurrences of a string from another string.\n   *\n   * @param inString the string to remove substrings from.\n   * @param substring the substring to remove.\n   * @return the input string with occurrences of substring removed.\n   */\n  public static String removeSubstring(String inString, String substring) {\n\n    StringBuffer result = new StringBuffer();\n    int oldLoc = 0, loc = 0;\n    while ((loc = inString.indexOf(substring, oldLoc))!= -1) {\n      result.append(inString.substring(oldLoc, loc));\n      oldLoc = loc + substring.length();\n    }\n    result.append(inString.substring(oldLoc));\n    return result.toString();\n  }\n\n  /**\n   * Replaces with a new string, all occurrences of a string from \n   * another string.\n   *\n   * @param inString the string to replace substrings in.\n   * @param subString the substring to replace.\n   * @param replaceString the replacement substring\n   * @return the input string with occurrences of substring replaced.\n   */\n  public static String replaceSubstring(String inString, String subString,\n\t\t\t\t\tString replaceString) {\n\n    StringBuffer result = new StringBuffer();\n    int oldLoc = 0, loc = 0;\n    while ((loc = inString.indexOf(subString, oldLoc))!= -1) {\n      result.append(inString.substring(oldLoc, loc));\n      result.append(replaceString);\n      oldLoc = loc + subString.length();\n    }\n    result.append(inString.substring(oldLoc));\n    return result.toString();\n  }\n\n\n  /**\n   * Pads a string to a specified length, inserting spaces on the left\n   * as required. If the string is too long, characters are removed (from\n   * the right).\n   *\n   * @param inString the input string\n   * @param length the desired length of the output string\n   * @return the output string\n   */\n  public static String padLeft(String inString, int length) {\n\n    return fixStringLength(inString, length, false);\n  }\n  \n  /**\n   * Pads a string to a specified length, inserting spaces on the right\n   * as required. If the string is too long, characters are removed (from\n   * the right).\n   *\n   * @param inString the input string\n   * @param length the desired length of the output string\n   * @return the output string\n   */\n  public static String padRight(String inString, int length) {\n\n    return fixStringLength(inString, length, true);\n  }\n  \n  /**\n   * Pads a string to a specified length, inserting spaces as\n   * required. If the string is too long, characters are removed (from\n   * the right).\n   *\n   * @param inString the input string\n   * @param length the desired length of the output string\n   * @param right true if inserted spaces should be added to the right\n   * @return the output string\n   */\n  private static /*@pure@*/ String fixStringLength(String inString, int length,\n\t\t\t\t\tboolean right) {\n\n    if (inString.length() \u003c length) {\n      while (inString.length() \u003c length) {\n\tinString = (right ? inString.concat(\" \") : \" \".concat(inString));\n      }\n    } else if (inString.length() \u003e length) {\n      inString = inString.substring(0, length);\n    }\n    return inString;\n  }\n \n  /**\n   * Rounds a double and converts it into String.\n   *\n   * @param value the double value\n   * @param afterDecimalPoint the (maximum) number of digits permitted\n   * after the decimal point\n   * @return the double as a formatted string\n   */\n  public static /*@pure@*/ String doubleToString(double value, int afterDecimalPoint) {\n    \n    StringBuffer stringBuffer;\n    double temp;\n    int dotPosition;\n    long precisionValue;\n    \n    temp = value * Math.pow(10.0, afterDecimalPoint);\n    if (Math.abs(temp) \u003c Long.MAX_VALUE) {\n      precisionValue = \t(temp \u003e 0) ? (long)(temp + 0.5) \n                                   : -(long)(Math.abs(temp) + 0.5);\n      if (precisionValue == 0) {\n\tstringBuffer = new StringBuffer(String.valueOf(0));\n      } else {\n\tstringBuffer = new StringBuffer(String.valueOf(precisionValue));\n      }\n      if (afterDecimalPoint == 0) {\n\treturn stringBuffer.toString();\n      }\n      dotPosition = stringBuffer.length() - afterDecimalPoint;\n      while (((precisionValue \u003c 0) \u0026\u0026 (dotPosition \u003c 1)) ||\n\t     (dotPosition \u003c 0)) {\n\tif (precisionValue \u003c 0) {\n\t  stringBuffer.insert(1, '0');\n\t} else {\n\t  stringBuffer.insert(0, '0');\n\t}\n\tdotPosition++;\n      }\n      stringBuffer.insert(dotPosition, '.');\n      if ((precisionValue \u003c 0) \u0026\u0026 (stringBuffer.charAt(1) == '.')) {\n\tstringBuffer.insert(1, '0');\n      } else if (stringBuffer.charAt(0) == '.') {\n\tstringBuffer.insert(0, '0');\n      }\n      int currentPos = stringBuffer.length() - 1;\n      while ((currentPos \u003e dotPosition) \u0026\u0026\n\t     (stringBuffer.charAt(currentPos) == '0')) {\n\tstringBuffer.setCharAt(currentPos--, ' ');\n      }\n      if (stringBuffer.charAt(currentPos) == '.') {\n\tstringBuffer.setCharAt(currentPos, ' ');\n      }\n      \n      return stringBuffer.toString().trim();\n    }\n    return new String(\"\" + value);\n  }\n\n  /**\n   * Rounds a double and converts it into a formatted decimal-justified String.\n   * Trailing 0's are replaced with spaces.\n   *\n   * @param value the double value\n   * @param width the width of the string\n   * @param afterDecimalPoint the number of digits after the decimal point\n   * @return the double as a formatted string\n   */\n  public static /*@pure@*/ String doubleToString(double value, int width,\n\t\t\t\t      int afterDecimalPoint) {\n    \n    String tempString = doubleToString(value, afterDecimalPoint);\n    char[] result;\n    int dotPosition;\n\n    if ((afterDecimalPoint \u003e= width) \n        || (tempString.indexOf('E') != -1)) { // Protects sci notation\n      return tempString;\n    }\n\n    // Initialize result\n    result = new char[width];\n    for (int i = 0; i \u003c result.length; i++) {\n      result[i] = ' ';\n    }\n\n    if (afterDecimalPoint \u003e 0) {\n      // Get position of decimal point and insert decimal point\n      dotPosition = tempString.indexOf('.');\n      if (dotPosition == -1) {\n\tdotPosition = tempString.length();\n      } else {\n\tresult[width - afterDecimalPoint - 1] = '.';\n      }\n    } else {\n      dotPosition = tempString.length();\n    }\n    \n\n    int offset = width - afterDecimalPoint - dotPosition;\n    if (afterDecimalPoint \u003e 0) {\n      offset--;\n    }\n\n    // Not enough room to decimal align within the supplied width\n    if (offset \u003c 0) {\n      return tempString;\n    }\n\n    // Copy characters before decimal point\n    for (int i = 0; i \u003c dotPosition; i++) {\n      result[offset + i] = tempString.charAt(i);\n    }\n\n    // Copy characters after decimal point\n    for (int i = dotPosition + 1; i \u003c tempString.length(); i++) {\n      result[offset + i] = tempString.charAt(i);\n    }\n\n    return new String(result);\n  }\n\n  /**\n   * Returns the basic class of an array class (handles multi-dimensional\n   * arrays).\n   * @param c        the array to inspect\n   * @return         the class of the innermost elements\n   */\n  public static Class getArrayClass(Class c) {\n     if (c.getComponentType().isArray())\n        return getArrayClass(c.getComponentType());\n     else\n        return c.getComponentType();\n  }\n\n  /**\n   * Returns the dimensions of the given array. Even though the\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\n   * int[3] or double[2][4].\n   *\n   * @param array       the array to determine the dimensions for\n   * @return            the dimensions of the array\n   */\n  public static int getArrayDimensions(Class array) {\n    if (array.getComponentType().isArray())\n      return 1 + getArrayDimensions(array.getComponentType());\n    else\n      return 1;\n  }\n\n  /**\n   * Returns the dimensions of the given array. Even though the\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\n   * int[3] or double[2][4].\n   *\n   * @param array       the array to determine the dimensions for\n   * @return            the dimensions of the array\n   */\n  public static int getArrayDimensions(Object array) {\n    return getArrayDimensions(array.getClass());\n  }\n\n  /**\n   * Returns the given Array in a string representation. Even though the\n   * parameter is of type \"Object\" one can hand over primitve arrays, e.g.\n   * int[3] or double[2][4].\n   * \n   * @param array       the array to return in a string representation\n   * @return            the array as string\n   */\n  public static String arrayToString(Object array) {\n    String        result;\n    int           dimensions;\n    int           i;       \n\n    result     = \"\";\n    dimensions = getArrayDimensions(array);\n    \n    if (dimensions == 0) {\n      result = \"null\";\n    }\n    else if (dimensions == 1) {\n      for (i = 0; i \u003c Array.getLength(array); i++) {\n        if (i \u003e 0)\n          result += \",\";\n        if (Array.get(array, i) == null)\n          result += \"null\";\n        else\n          result += Array.get(array, i).toString();\n      }\n    }\n    else {\n      for (i = 0; i \u003c Array.getLength(array); i++) {\n        if (i \u003e 0)\n          result += \",\";\n        result += \"[\" + arrayToString(Array.get(array, i)) + \"]\";\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * Tests if a is equal to b.\n   *\n   * @param a a double\n   * @param b a double\n   */\n  public static /*@pure@*/ boolean eq(double a, double b){\n    \n    return (a - b \u003c SMALL) \u0026\u0026 (b - a \u003c SMALL); \n  }\n\n  /**\n   * Checks if the given array contains any non-empty options.\n   *\n   * @param options an array of strings\n   * @exception Exception if there are any non-empty options\n   */\n  public static void checkForRemainingOptions(String[] options) \n    throws Exception {\n    \n    int illegalOptionsFound = 0;\n    StringBuffer text = new StringBuffer();\n\n    if (options == null) {\n      return;\n    }\n    for (int i = 0; i \u003c options.length; i++) {\n      if (options[i].length() \u003e 0) {\n\tillegalOptionsFound++;\n\ttext.append(options[i] + ' ');\n      }\n    }\n    if (illegalOptionsFound \u003e 0) {\n      throw new Exception(\"Illegal options: \" + text);\n    }\n  }\n  \n  /**\n   * Checks if the given array contains the flag \"-Char\". Stops\n   * searching at the first marker \"--\". If the flag is found,\n   * it is replaced with the empty string.\n   *\n   * @param flag the character indicating the flag.\n   * @param options the array of strings containing all the options.\n   * @return true if the flag was found\n   * @exception Exception if an illegal option was found\n   */\n  public static boolean getFlag(char flag, String[] options) \n    throws Exception {\n    \n    return getFlag(\"\" + flag, options);\n  }\n  \n  /**\n   * Checks if the given array contains the flag \"-String\". Stops\n   * searching at the first marker \"--\". If the flag is found,\n   * it is replaced with the empty string.\n   *\n   * @param flag the String indicating the flag.\n   * @param options the array of strings containing all the options.\n   * @return true if the flag was found\n   * @exception Exception if an illegal option was found\n   */\n  public static boolean getFlag(String flag, String[] options) \n    throws Exception {\n    \n    int pos = getOptionPos(flag, options);\n\n    if (pos \u003e -1)\n      options[pos] = \"\";\n    \n    return (pos \u003e -1);\n  }\n\n  /**\n   * Gets an option indicated by a flag \"-Char\" from the given array\n   * of strings. Stops searching at the first marker \"--\". Replaces \n   * flag and option with empty strings.\n   *\n   * @param flag the character indicating the option.\n   * @param options the array of strings containing all the options.\n   * @return the indicated option or an empty string\n   * @exception Exception if the option indicated by the flag can't be found\n   */\n  public static /*@non_null@*/ String getOption(char flag, String[] options) \n    throws Exception {\n    \n    return getOption(\"\" + flag, options);\n  }\n\n  /**\n   * Gets an option indicated by a flag \"-String\" from the given array\n   * of strings. Stops searching at the first marker \"--\". Replaces \n   * flag and option with empty strings.\n   *\n   * @param flag the String indicating the option.\n   * @param options the array of strings containing all the options.\n   * @return the indicated option or an empty string\n   * @exception Exception if the option indicated by the flag can't be found\n   */\n  public static /*@non_null@*/ String getOption(String flag, String[] options) \n    throws Exception {\n\n    String newString;\n    int i = getOptionPos(flag, options);\n\n    if (i \u003e -1) {\n      if (options[i].equals(\"-\" + flag)) {\n\tif (i + 1 == options.length) {\n\t  throw new Exception(\"No value given for -\" + flag + \" option.\");\n\t}\n\toptions[i] = \"\";\n\tnewString = new String(options[i + 1]);\n\toptions[i + 1] = \"\";\n\treturn newString;\n      }\n      if (options[i].charAt(1) == '-') {\n\treturn \"\";\n      }\n    }\n    \n    return \"\";\n  }\n\n  /**\n   * Gets the index of an option or flag indicated by a flag \"-Char\" from \n   * the given array of strings. Stops searching at the first marker \"--\".\n   *\n   * @param flag \tthe character indicating the option.\n   * @param options \tthe array of strings containing all the options.\n   * @return \t\tthe position if found, or -1 otherwise\n   */\n  public static int getOptionPos(char flag, String[] options) {\n     return getOptionPos(\"\" + flag, options);\n  }\n\n  /**\n   * Gets the index of an option or flag indicated by a flag \"-String\" from \n   * the given array of strings. Stops searching at the first marker \"--\".\n   *\n   * @param flag \tthe String indicating the option.\n   * @param options \tthe array of strings containing all the options.\n   * @return \t\tthe position if found, or -1 otherwise\n   */\n  public static int getOptionPos(String flag, String[] options) {\n    if (options == null)\n      return -1;\n    \n    for (int i = 0; i \u003c options.length; i++) {\n      if ((options[i].length() \u003e 0) \u0026\u0026 (options[i].charAt(0) == '-')) {\n\t// Check if it is a negative number\n\ttry {\n\t  Double.valueOf(options[i]);\n\t} \n\tcatch (NumberFormatException e) {\n\t  // found?\n\t  if (options[i].equals(\"-\" + flag))\n\t    return i;\n\t  // did we reach \"--\"?\n\t  if (options[i].charAt(1) == '-')\n\t    return -1;\n\t}\n      }\n    }\n    \n    return -1;\n  }\n\n  /**\n   * Quotes a string if it contains special characters.\n   * \n   * The following rules are applied:\n   *\n   * A character is backquoted version of it is one \n   * of \u003ctt\u003e\" ' % \\ \\n \\r \\t\u003c/tt\u003e.\n   *\n   * A string is enclosed within single quotes if a character has been\n   * backquoted using the previous rule above or contains \n   * \u003ctt\u003e{ }\u003c/tt\u003e or is exactly equal to the strings \n   * \u003ctt\u003e, ? space or \"\"\u003c/tt\u003e (empty string).\n   *\n   * A quoted question mark distinguishes it from the missing value which\n   * is represented as an unquoted question mark in arff files.\n   *\n   * @param string \tthe string to be quoted\n   * @return \t\tthe string (possibly quoted)\n   * @see\t\t#unquote(String)\n   */\n  public static /*@pure@*/ String quote(String string) {\n      boolean quote = false;\n\n      // backquote the following characters \n      if ((string.indexOf('\\n') != -1) || (string.indexOf('\\r') != -1) || \n\t  (string.indexOf('\\'') != -1) || (string.indexOf('\"') != -1) || \n\t  (string.indexOf('\\\\') != -1) || \n\t  (string.indexOf('\\t') != -1) || (string.indexOf('%') != -1) ||\n\t  (string.indexOf('\\u001E') != -1)) {\n\t  string = backQuoteChars(string);\n\t  quote = true;\n      }\n\n      // Enclose the string in 's if the string contains a recently added\n      // backquote or contains one of the following characters.\n      if((quote == true) || \n\t (string.indexOf('{') != -1) || (string.indexOf('}') != -1) ||\n\t (string.indexOf(',') != -1) || (string.equals(\"?\")) ||\n\t (string.indexOf(' ') != -1) || (string.equals(\"\"))) {\n\t  string = (\"'\".concat(string)).concat(\"'\");\n      }\n\n      return string;\n  }\n\n  /**\n   * unquotes are previously quoted string (but only if necessary), i.e., it\n   * removes the single quotes around it. Inverse to quote(String).\n   * \n   * @param string\tthe string to process\n   * @return\t\tthe unquoted string\n   * @see\t\t#quote(String)\n   */\n  public static String unquote(String string) {\n    if (string.startsWith(\"'\") \u0026\u0026 string.endsWith(\"'\")) {\n      string = string.substring(1, string.length() - 1);\n      \n      if ((string.indexOf(\"\\\\n\") != -1) || (string.indexOf(\"\\\\r\") != -1) || \n\t  (string.indexOf(\"\\\\'\") != -1) || (string.indexOf(\"\\\\\\\"\") != -1) || \n\t  (string.indexOf(\"\\\\\\\\\") != -1) || \n\t  (string.indexOf(\"\\\\t\") != -1) || (string.indexOf(\"\\\\%\") != -1) ||\n\t  (string.indexOf(\"\\\\u001E\") != -1)) {\n\tstring = unbackQuoteChars(string);\n      }\n    }\n\n    return string;\n  }\n\n  /**\n   * Converts carriage returns and new lines in a string into \\r and \\n.\n   * Backquotes the following characters: ` \" \\ \\t and %\n   * \n   * @param string \tthe string\n   * @return \t\tthe converted string\n   * @see\t\t#unbackQuoteChars(String)\n   */\n  public static /*@pure@*/ String backQuoteChars(String string) {\n\n    int index;\n    StringBuffer newStringBuffer;\n\n    // replace each of the following characters with the backquoted version\n    char   charsFind[] =    {'\\\\',   '\\'',  '\\t',  '\\n',  '\\r',  '\"',    '%', \n        '\\u001E'};\n    String charsReplace[] = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\n\", \"\\\\r\", \"\\\\\\\"\", \"\\\\%\",\n        \"\\\\u001E\"};\n    for (int i = 0; i \u003c charsFind.length; i++) {\n      if (string.indexOf(charsFind[i]) != -1 ) {\n\tnewStringBuffer = new StringBuffer();\n\twhile ((index = string.indexOf(charsFind[i])) != -1) {\n\t  if (index \u003e 0) {\n\t    newStringBuffer.append(string.substring(0, index));\n\t  }\n\t  newStringBuffer.append(charsReplace[i]);\n\t  if ((index + 1) \u003c string.length()) {\n\t    string = string.substring(index + 1);\n\t  } else {\n\t    string = \"\";\n\t  }\n\t}\n\tnewStringBuffer.append(string);\n\tstring = newStringBuffer.toString();\n      }\n    }\n\n    return string;\n  }\n\n  /**\n   * Converts carriage returns and new lines in a string into \\r and \\n.\n   *\n   * @param string the string\n   * @return the converted string\n   */\n  public static String convertNewLines(String string) {\n    int index;\n\n    // Replace with \\n\n    StringBuffer newStringBuffer = new StringBuffer();\n    while ((index = string.indexOf('\\n')) != -1) {\n      if (index \u003e 0) {\n\tnewStringBuffer.append(string.substring(0, index));\n      }\n      newStringBuffer.append('\\\\');\n      newStringBuffer.append('n');\n      if ((index + 1) \u003c string.length()) {\n\tstring = string.substring(index + 1);\n      } else {\n\tstring = \"\";\n      }\n    }\n    newStringBuffer.append(string);\n    string = newStringBuffer.toString();\n\n    // Replace with \\r\n    newStringBuffer = new StringBuffer();\n    while ((index = string.indexOf('\\r')) != -1) {\n      if (index \u003e 0) {\n\tnewStringBuffer.append(string.substring(0, index));\n      }\n      newStringBuffer.append('\\\\');\n      newStringBuffer.append('r');\n      if ((index + 1) \u003c string.length()){\n\tstring = string.substring(index + 1);\n      } else {\n\tstring = \"\";\n      }\n    }\n    newStringBuffer.append(string);\n    return newStringBuffer.toString();\n  }\n\n  /**\n   * Reverts \\r and \\n in a string into carriage returns and new lines.\n   * \n   * @param string the string\n   * @return the converted string\n   */\n  public static String revertNewLines(String string) {\n    int index;\n\n    // Replace with \\n\n    StringBuffer newStringBuffer = new StringBuffer();\n    while ((index = string.indexOf(\"\\\\n\")) != -1) {\n      if (index \u003e 0) {\n\tnewStringBuffer.append(string.substring(0, index));\n      }\n      newStringBuffer.append('\\n');\n      if ((index + 2) \u003c string.length()) {\n\tstring = string.substring(index + 2);\n      } else {\n\tstring = \"\";\n      }\n    }\n    newStringBuffer.append(string);\n    string = newStringBuffer.toString();\n\n    // Replace with \\r\n    newStringBuffer = new StringBuffer();\n    while ((index = string.indexOf(\"\\\\r\")) != -1) {\n      if (index \u003e 0) {\n\tnewStringBuffer.append(string.substring(0, index));\n      }\n      newStringBuffer.append('\\r');\n      if ((index + 2) \u003c string.length()){\n\tstring = string.substring(index + 2);\n      } else {\n\tstring = \"\";\n      }\n    }\n    newStringBuffer.append(string);\n    \n    return newStringBuffer.toString();\n  }\n\n  /**\n   * Returns the secondary set of options (if any) contained in\n   * the supplied options array. The secondary set is defined to\n   * be any options after the first \"--\". These options are removed from\n   * the original options array.\n   *\n   * @param options the input array of options\n   * @return the array of secondary options\n   */\n  public static String[] partitionOptions(String[] options) {\n\n    for (int i = 0; i \u003c options.length; i++) {\n      if (options[i].equals(\"--\")) {\n\toptions[i++] = \"\";\n\tString[] result = new String [options.length - i];\n\tfor (int j = i; j \u003c options.length; j++) {\n\t  result[j - i] = options[j];\n\t  options[j] = \"\";\n\t}\n\treturn result;\n      }\n    }\n    return new String [0];\n  }\n    \n  /**\n   * The inverse operation of backQuoteChars().\n   * Converts back-quoted carriage returns and new lines in a string \n   * to the corresponding character ('\\r' and '\\n').\n   * Also \"un\"-back-quotes the following characters: ` \" \\ \\t and %\n   *\n   * @param string \tthe string\n   * @return \t\tthe converted string\n   * @see\t\t#backQuoteChars(String)\n   */\n  public static String unbackQuoteChars(String string) {\n\n    int index;\n    StringBuffer newStringBuffer;\n    \n    // replace each of the following characters with the backquoted version\n    String charsFind[]    = {\"\\\\\\\\\", \"\\\\'\", \"\\\\t\", \"\\\\n\", \"\\\\r\", \"\\\\\\\"\", \"\\\\%\",\n        \"\\\\u001E\"};\n    char   charsReplace[] = {'\\\\',   '\\'',  '\\t',  '\\n',  '\\r',  '\"',    '%',\n        '\\u001E'};\n    int pos[] = new int[charsFind.length];\n    int\tcurPos;\n    \n    String str = new String(string);\n    newStringBuffer = new StringBuffer();\n    while (str.length() \u003e 0) {\n      // get positions and closest character to replace\n      curPos = str.length();\n      index  = -1;\n      for (int i = 0; i \u003c pos.length; i++) {\n\tpos[i] = str.indexOf(charsFind[i]);\n\tif ( (pos[i] \u003e -1) \u0026\u0026 (pos[i] \u003c curPos) ) {\n\t  index  = i;\n\t  curPos = pos[i];\n\t}\n      }\n      \n      // replace character if found, otherwise finished\n      if (index == -1) {\n\tnewStringBuffer.append(str);\n\tstr = \"\";\n      }\n      else {\n\tnewStringBuffer.append(str.substring(0, pos[index]));\n\tnewStringBuffer.append(charsReplace[index]);\n\tstr = str.substring(pos[index] + charsFind[index].length());\n      }\n    }\n\n    return newStringBuffer.toString();\n  }    \n  \n  /**\n   * Split up a string containing options into an array of strings,\n   * one for each option.\n   *\n   * @param \t\tquotedOptionString the string containing the options\n   * @return \t\tthe array of options\n   * @throws Exception \tin case of an unterminated string, unknown character or\n   * \t\t\ta parse error\n   */\n  public static String[] splitOptions(String quotedOptionString) throws Exception{\n\n    Vector\u003cString\u003e optionsVec = new Vector\u003cString\u003e();\n    String str = new String(quotedOptionString);\n    int i;\n    \n    while (true){\n\n      //trimLeft \n      i = 0;\n      while ((i \u003c str.length()) \u0026\u0026 (Character.isWhitespace(str.charAt(i)))) i++;\n      str = str.substring(i);\n      \n      //stop when str is empty\n      if (str.length() == 0) break;\n      \n      //if str start with a double quote\n      if (str.charAt(0) == '\"'){\n\t\n\t//find the first not anti-slached double quote\n\ti = 1;\n\twhile(i \u003c str.length()){\n\t  if (str.charAt(i) == str.charAt(0)) break;\n\t  if (str.charAt(i) == '\\\\'){\n\t    i += 1;\n\t    if (i \u003e= str.length()) \n\t      throw new Exception(\"String should not finish with \\\\\");\n\t  }\n\t  i += 1;\n\t}\n\tif (i \u003e= str.length()) throw new Exception(\"Quote parse error.\");\n\t\n\t//add the founded string to the option vector (without quotes)\n\tString optStr = str.substring(1,i);\n\toptStr = unbackQuoteChars(optStr);\n\toptionsVec.addElement(optStr);\n\tstr = str.substring(i+1);\n      } else {\n\t//find first whiteSpace\n\ti=0;\n\twhile((i \u003c str.length()) \u0026\u0026 (!Character.isWhitespace(str.charAt(i)))) i++;\n\t\n\t//add the founded string to the option vector\n\tString optStr = str.substring(0,i);\n\toptionsVec.addElement(optStr);\n\tstr = str.substring(i);\n      }\n    }\n    \n    //convert optionsVec to an array of String\n    String[] options = new String[optionsVec.size()];\n    for (i = 0; i \u003c optionsVec.size(); i++) {\n      options[i] = (String)optionsVec.elementAt(i);\n    }\n    return options;\n  }    \n\n  /**\n   * Joins all the options in an option array into a single string,\n   * as might be used on the command line.\n   *\n   * @param optionArray the array of options\n   * @return the string containing all options.\n   */\n  public static String joinOptions(String[] optionArray) {\n\n    String optionString = \"\";\n    for (int i = 0; i \u003c optionArray.length; i++) {\n      if (optionArray[i].equals(\"\")) {\n\tcontinue;\n      }\n      boolean escape = false;\n      for (int n = 0; n \u003c optionArray[i].length(); n++) {\n\tif (Character.isWhitespace(optionArray[i].charAt(n))) {\n\t  escape = true;\n\t  break;\n\t}\n      }\n      if (escape) {\n\toptionString += '\"' + backQuoteChars(optionArray[i]) + '\"';\n      } else {\n\toptionString += optionArray[i];\n      }\n      optionString += \" \";\n    }\n    return optionString.trim();\n  }\n  \n  \n  /**\n   * Computes entropy for an array of integers.\n   *\n   * @param counts array of counts\n   * @return - a log2 a - b log2 b - c log2 c + (a+b+c) log2 (a+b+c)\n   * when given array [a b c]\n   */\n  public static /*@pure@*/ double info(int counts[]) {\n    \n    int total = 0;\n    double x = 0;\n    for (int j = 0; j \u003c counts.length; j++) {\n      x -= xlogx(counts[j]);\n      total += counts[j];\n    }\n    return x + xlogx(total);\n  }\n\n  /**\n   * Tests if a is smaller or equal to b.\n   *\n   * @param a a double\n   * @param b a double\n   */\n  public static /*@pure@*/ boolean smOrEq(double a,double b) {\n    \n    return (a-b \u003c SMALL);\n  }\n\n  /**\n   * Tests if a is greater or equal to b.\n   *\n   * @param a a double\n   * @param b a double\n   */\n  public static /*@pure@*/ boolean grOrEq(double a,double b) {\n    \n    return (b-a \u003c SMALL);\n  }\n  \n  /**\n   * Tests if a is smaller than b.\n   *\n   * @param a a double\n   * @param b a double\n   */\n  public static /*@pure@*/ boolean sm(double a,double b) {\n    \n    return (b-a \u003e SMALL);\n  }\n\n  /**\n   * Tests if a is greater than b.\n   *\n   * @param a a double\n   * @param b a double \n   */\n  public static /*@pure@*/ boolean gr(double a,double b) {\n    \n    return (a-b \u003e SMALL);\n  }\n\n  /**\n   * Returns the kth-smallest value in the array.\n   *\n   * @param array the array of integers\n   * @param k the value of k\n   * @return the kth-smallest value\n   */\n  public static double kthSmallestValue(int[] array, int k) {\n\n    int[] index = new int[array.length];\n    \n    for (int i = 0; i \u003c index.length; i++) {\n      index[i] = i;\n    }\n\n    return array[index[select(array, index, 0, array.length - 1, k)]];\n  }\n\n  /**\n   * Returns the kth-smallest value in the array\n   *\n   * @param array the array of double\n   * @param k the value of k\n   * @return the kth-smallest value\n   */\n  public static double kthSmallestValue(double[] array, int k) {\n\n    int[] index = new int[array.length];\n    \n    for (int i = 0; i \u003c index.length; i++) {\n      index[i] = i;\n    }\n\n    return array[index[select(array, index, 0, array.length - 1, k)]];\n  }\n\n  /**\n   * Returns the logarithm of a for base 2.\n   *\n   * @param a \ta double\n   * @return\tthe logarithm for base 2\n   */\n  public static /*@pure@*/ double log2(double a) {\n    \n    return Math.log(a) / log2;\n  }\n\n  /**\n   * Returns index of maximum element in a given\n   * array of doubles. First maximum is returned.\n   *\n   * @param doubles the array of doubles\n   * @return the index of the maximum element\n   */\n  public static /*@pure@*/ int maxIndex(double[] doubles) {\n\n    double maximum = 0;\n    int maxIndex = 0;\n\n    for (int i = 0; i \u003c doubles.length; i++) {\n      if ((i == 0) || (doubles[i] \u003e maximum)) {\n\tmaxIndex = i;\n\tmaximum = doubles[i];\n      }\n    }\n\n    return maxIndex;\n  }\n\n  /**\n   * Returns index of maximum element in a given\n   * array of integers. First maximum is returned.\n   *\n   * @param ints the array of integers\n   * @return the index of the maximum element\n   */\n  public static /*@pure@*/ int maxIndex(int[] ints) {\n\n    int maximum = 0;\n    int maxIndex = 0;\n\n    for (int i = 0; i \u003c ints.length; i++) {\n      if ((i == 0) || (ints[i] \u003e maximum)) {\n\tmaxIndex = i;\n\tmaximum = ints[i];\n      }\n    }\n\n    return maxIndex;\n  }\n\n  /**\n   * Computes the mean for an array of doubles.\n   *\n   * @param vector the array\n   * @return the mean\n   */\n  public static /*@pure@*/ double mean(double[] vector) {\n  \n    double sum = 0;\n\n    if (vector.length == 0) {\n      return 0;\n    }\n    for (int i = 0; i \u003c vector.length; i++) {\n      sum += vector[i];\n    }\n    return sum / (double) vector.length;\n  }\n\n  /**\n   * Returns index of minimum element in a given\n   * array of integers. First minimum is returned.\n   *\n   * @param ints the array of integers\n   * @return the index of the minimum element\n   */\n  public static /*@pure@*/ int minIndex(int[] ints) {\n\n    int minimum = 0;\n    int minIndex = 0;\n\n    for (int i = 0; i \u003c ints.length; i++) {\n      if ((i == 0) || (ints[i] \u003c minimum)) {\n\tminIndex = i;\n\tminimum = ints[i];\n      }\n    }\n\n    return minIndex;\n  }\n\n  /**\n   * Returns index of minimum element in a given\n   * array of doubles. First minimum is returned.\n   *\n   * @param doubles the array of doubles\n   * @return the index of the minimum element\n   */\n  public static /*@pure@*/ int minIndex(double[] doubles) {\n\n    double minimum = 0;\n    int minIndex = 0;\n\n    for (int i = 0; i \u003c doubles.length; i++) {\n      if ((i == 0) || (doubles[i] \u003c minimum)) {\n\tminIndex = i;\n\tminimum = doubles[i];\n      }\n    }\n\n    return minIndex;\n  }\n\n  /**\n   * Normalizes the doubles in the array by their sum.\n   *\n   * @param doubles the array of double\n   * @exception IllegalArgumentException if sum is Zero or NaN\n   */\n  public static void normalize(double[] doubles) {\n\n    double sum = 0;\n    for (int i = 0; i \u003c doubles.length; i++) {\n      sum += doubles[i];\n    }\n    normalize(doubles, sum);\n  }\n\n  /**\n   * Normalizes the doubles in the array using the given value.\n   *\n   * @param doubles the array of double\n   * @param sum the value by which the doubles are to be normalized\n   * @exception IllegalArgumentException if sum is zero or NaN\n   */\n  public static void normalize(double[] doubles, double sum) {\n\n    if (Double.isNaN(sum)) {\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is NaN.\");\n    }\n    if (sum == 0) {\n      // Maybe this should just be a return.\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is zero.\");\n    }\n    for (int i = 0; i \u003c doubles.length; i++) {\n      doubles[i] /= sum;\n    }\n  }\n\n  /**\n   * Converts an array containing the natural logarithms of\n   * probabilities stored in a vector back into probabilities.\n   * The probabilities are assumed to sum to one.\n   *\n   * @param a an array holding the natural logarithms of the probabilities\n   * @return the converted array \n   */\n  public static double[] logs2probs(double[] a) {\n\n    double max = a[maxIndex(a)];\n    double sum = 0.0;\n\n    double[] result = new double[a.length];\n    for(int i = 0; i \u003c a.length; i++) {\n      result[i] = Math.exp(a[i] - max);\n      sum += result[i];\n    }\n\n    normalize(result, sum);\n\n    return result;\n  } \n\n  /**\n   * Returns the log-odds for a given probabilitiy.\n   *\n   * @param prob the probabilitiy\n   *\n   * @return the log-odds after the probability has been mapped to\n   * [Utils.SMALL, 1-Utils.SMALL]\n   */\n  public static /*@pure@*/ double probToLogOdds(double prob) {\n\n    if (gr(prob, 1) || (sm(prob, 0))) {\n      throw new IllegalArgumentException(\"probToLogOdds: probability must \" +\n\t\t\t\t     \"be in [0,1] \"+prob);\n    }\n    double p = SMALL + (1.0 - 2 * SMALL) * prob;\n    return Math.log(p / (1 - p));\n  }\n\n  /**\n   * Rounds a double to the next nearest integer value. The JDK version\n   * of it doesn't work properly.\n   *\n   * @param value the double value\n   * @return the resulting integer value\n   */\n  public static /*@pure@*/ int round(double value) {\n\n    int roundedValue = value \u003e 0\n      ? (int)(value + 0.5)\n      : -(int)(Math.abs(value) + 0.5);\n    \n    return roundedValue;\n  }\n\n  /**\n   * Rounds a double to the next nearest integer value in a probabilistic\n   * fashion (e.g. 0.8 has a 20% chance of being rounded down to 0 and a\n   * 80% chance of being rounded up to 1). In the limit, the average of\n   * the rounded numbers generated by this procedure should converge to\n   * the original double.\n   *\n   * @param value the double value\n   * @param rand the random number generator\n   * @return the resulting integer value\n   */\n  public static int probRound(double value, Random rand) {\n\n    if (value \u003e= 0) {\n      double lower = Math.floor(value);\n      double prob = value - lower;\n      if (rand.nextDouble() \u003c prob) {\n\treturn (int)lower + 1;\n      } else {\n\treturn (int)lower;\n      }\n    } else {\n      double lower = Math.floor(Math.abs(value));\n      double prob = Math.abs(value) - lower;\n      if (rand.nextDouble() \u003c prob) {\n\treturn -((int)lower + 1);\n      } else {\n\treturn -(int)lower;\n      }\n    }\n  }\n\n  /**\n   * Rounds a double to the given number of decimal places.\n   *\n   * @param value the double value\n   * @param afterDecimalPoint the number of digits after the decimal point\n   * @return the double rounded to the given precision\n   */\n  public static /*@pure@*/ double roundDouble(double value,int afterDecimalPoint) {\n\n    double mask = Math.pow(10.0, (double)afterDecimalPoint);\n\n    return (double)(Math.round(value * mask)) / mask;\n  }\n\n  /**\n   * Sorts a given array of integers in ascending order and returns an \n   * array of integers with the positions of the elements of the original \n   * array in the sorted array. The sort is stable. (Equal elements remain\n   * in their original order.)\n   *\n   * @param array this array is not changed by the method!\n   * @return an array of integers with the positions in the sorted\n   * array.\n   */\n  public static /*@pure@*/ int[] sort(int[] array) {\n\n    int[] index = new int[array.length];\n    int[] newIndex = new int[array.length];\n    int[] helpIndex;\n    int numEqual;\n    \n    for (int i = 0; i \u003c index.length; i++) {\n      index[i] = i;\n    }\n    quickSort(array, index, 0, array.length - 1);\n\n    // Make sort stable\n    int i = 0;\n    while (i \u003c index.length) {\n      numEqual = 1;\n      for (int j = i + 1; ((j \u003c index.length)\n\t\t\t   \u0026\u0026 (array[index[i]] == array[index[j]]));\n\t   j++) {\n\tnumEqual++;\n      }\n      if (numEqual \u003e 1) {\n\thelpIndex = new int[numEqual];\n\tfor (int j = 0; j \u003c numEqual; j++) {\n\t  helpIndex[j] = i + j;\n\t}\n\tquickSort(index, helpIndex, 0, numEqual - 1);\n\tfor (int j = 0; j \u003c numEqual; j++) {\n\t  newIndex[i + j] = index[helpIndex[j]];\n\t}\n\ti += numEqual;\n      } else {\n\tnewIndex[i] = index[i];\n\ti++;\n      }\n    }\n    return newIndex;\n  }\n\n  /**\n   * Sorts a given array of doubles in ascending order and returns an\n   * array of integers with the positions of the elements of the\n   * original array in the sorted array. NOTE THESE CHANGES: the sort\n   * is no longer stable and it doesn't use safe floating-point\n   * comparisons anymore. Occurrences of Double.NaN are treated as \n   * Double.MAX_VALUE\n   *\n   * @param array this array is not changed by the method!\n   * @return an array of integers with the positions in the sorted\n   * array.  \n   */\n  public static /*@pure@*/ int[] sort(/*@non_null@*/ double[] array) {\n\n    int[] index = new int[array.length];\n    array = (double[])array.clone();\n    for (int i = 0; i \u003c index.length; i++) {\n      index[i] = i;\n      if (Double.isNaN(array[i])) {\n        array[i] = Double.MAX_VALUE;\n      }\n    }\n    quickSort(array, index, 0, array.length - 1);\n    return index;\n  }\n\n  /**\n   * Sorts a given array of doubles in ascending order and returns an \n   * array of integers with the positions of the elements of the original \n   * array in the sorted array. The sort is stable (Equal elements remain\n   * in their original order.) Occurrences of Double.NaN are treated as \n   * Double.MAX_VALUE\n   *\n   * @param array this array is not changed by the method!\n   * @return an array of integers with the positions in the sorted\n   * array.\n   */\n  public static /*@pure@*/ int[] stableSort(double[] array){\n\n    int[] index = new int[array.length];\n    int[] newIndex = new int[array.length];\n    int[] helpIndex;\n    int numEqual;\n    \n    array = (double[])array.clone();\n    for (int i = 0; i \u003c index.length; i++) {\n      index[i] = i;\n      if (Double.isNaN(array[i])) {\n        array[i] = Double.MAX_VALUE;\n      }\n    }\n    quickSort(array,index,0,array.length-1);\n\n    // Make sort stable\n\n    int i = 0;\n    while (i \u003c index.length) {\n      numEqual = 1;\n      for (int j = i+1; ((j \u003c index.length) \u0026\u0026 Utils.eq(array[index[i]],\n\t\t\t\t\t\t\tarray[index[j]])); j++)\n\tnumEqual++;\n      if (numEqual \u003e 1) {\n\thelpIndex = new int[numEqual];\n\tfor (int j = 0; j \u003c numEqual; j++)\n\t  helpIndex[j] = i+j;\n\tquickSort(index, helpIndex, 0, numEqual-1);\n\tfor (int j = 0; j \u003c numEqual; j++) \n\t  newIndex[i+j] = index[helpIndex[j]];\n\ti += numEqual;\n      } else {\n\tnewIndex[i] = index[i];\n\ti++;\n      }\n    }\n\n    return newIndex;\n  }\n\n  /**\n   * Computes the variance for an array of doubles.\n   *\n   * @param vector the array\n   * @return the variance\n   */\n  public static /*@pure@*/ double variance(double[] vector) {\n  \n    double sum = 0, sumSquared = 0;\n\n    if (vector.length \u003c= 1) {\n      return 0;\n    }\n    for (int i = 0; i \u003c vector.length; i++) {\n      sum += vector[i];\n      sumSquared += (vector[i] * vector[i]);\n    }\n    double result = (sumSquared - (sum * sum / (double) vector.length)) / \n      (double) (vector.length - 1);\n\n    // We don't like negative variance\n    if (result \u003c 0) {\n      return 0;\n    } else {\n      return result;\n    }\n  }\n\n  /**\n   * Computes the sum of the elements of an array of doubles.\n   *\n   * @param doubles the array of double\n   * @return the sum of the elements\n   */\n  public static /*@pure@*/ double sum(double[] doubles) {\n\n    double sum = 0;\n\n    for (int i = 0; i \u003c doubles.length; i++) {\n      sum += doubles[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Computes the sum of the elements of an array of integers.\n   *\n   * @param ints the array of integers\n   * @return the sum of the elements\n   */\n  public static /*@pure@*/ int sum(int[] ints) {\n\n    int sum = 0;\n\n    for (int i = 0; i \u003c ints.length; i++) {\n      sum += ints[i];\n    }\n    return sum;\n  }\n\n  /**\n   * Returns c*log2(c) for a given integer value c.\n   *\n   * @param c an integer value\n   * @return c*log2(c) (but is careful to return 0 if c is 0)\n   */\n  public static /*@pure@*/ double xlogx(int c) {\n    \n    if (c == 0) {\n      return 0.0;\n    }\n    return c * Utils.log2((double) c);\n  }\n\n  /**\n   * Partitions the instances around a pivot. Used by quicksort and\n   * kthSmallestValue.\n   *\n   * @param array the array of doubles to be sorted\n   * @param index the index into the array of doubles\n   * @param l the first index of the subset \n   * @param r the last index of the subset \n   *\n   * @return the index of the middle element\n   */\n  private static int partition(double[] array, int[] index, int l, int r) {\n    \n    double pivot = array[index[(l + r) / 2]];\n    int help;\n\n    while (l \u003c r) {\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\n        l++;\n      }\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\n        r--;\n      }\n      if (l \u003c r) {\n        help = index[l];\n        index[l] = index[r];\n        index[r] = help;\n        l++;\n        r--;\n      }\n    }\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\n      r--;\n    } \n\n    return r;\n  }\n\n  /**\n   * Partitions the instances around a pivot. Used by quicksort and\n   * kthSmallestValue.\n   *\n   * @param array the array of integers to be sorted\n   * @param index the index into the array of integers\n   * @param l the first index of the subset \n   * @param r the last index of the subset \n   *\n   * @return the index of the middle element\n   */\n  private static int partition(int[] array, int[] index, int l, int r) {\n    \n    double pivot = array[index[(l + r) / 2]];\n    int help;\n\n    while (l \u003c r) {\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\n        l++;\n      }\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\n        r--;\n      }\n      if (l \u003c r) {\n        help = index[l];\n        index[l] = index[r];\n        index[r] = help;\n        l++;\n        r--;\n      }\n    }\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\n      r--;\n    } \n\n    return r;\n  }\n  \n  /**\n   * Implements quicksort according to Manber's \"Introduction to\n   * Algorithms\".\n   *\n   * @param array the array of doubles to be sorted\n   * @param index the index into the array of doubles\n   * @param left the first index of the subset to be sorted\n   * @param right the last index of the subset to be sorted\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\n  //@ requires array != index;\n  //  assignable index;\n  private static void quickSort(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \n                                int left, int right) {\n\n    if (left \u003c right) {\n      int middle = partition(array, index, left, right);\n      quickSort(array, index, left, middle);\n      quickSort(array, index, middle + 1, right);\n    }\n  }\n  \n  /**\n   * Implements quicksort according to Manber's \"Introduction to\n   * Algorithms\".\n   *\n   * @param array the array of integers to be sorted\n   * @param index the index into the array of integers\n   * @param left the first index of the subset to be sorted\n   * @param right the last index of the subset to be sorted\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\n  //@ requires array != index;\n  //  assignable index;\n  private static void quickSort(/*@non_null@*/ int[] array, /*@non_null@*/  int[] index, \n                                int left, int right) {\n\n    if (left \u003c right) {\n      int middle = partition(array, index, left, right);\n      quickSort(array, index, left, middle);\n      quickSort(array, index, middle + 1, right);\n    }\n  }\n  \n  /**\n   * Implements computation of the kth-smallest element according\n   * to Manber's \"Introduction to Algorithms\".\n   *\n   * @param array the array of double\n   * @param index the index into the array of doubles\n   * @param left the first index of the subset \n   * @param right the last index of the subset \n   * @param k the value of k\n   *\n   * @return the index of the kth-smallest element\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n  private static int select(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, \n                            int left, int right, int k) {\n    \n    if (left == right) {\n      return left;\n    } else {\n      int middle = partition(array, index, left, right);\n      if ((middle - left + 1) \u003e= k) {\n        return select(array, index, left, middle, k);\n      } else {\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\n      }\n    }\n  }\n\n  /**\n   * Converts a File's absolute path to a path relative to the user\n   * (ie start) directory. Includes an additional workaround for Cygwin, which\n   * doesn't like upper case drive letters.\n   * @param absolute the File to convert to relative path\n   * @return a File with a path that is relative to the user's directory\n   * @exception Exception if the path cannot be constructed\n   */\n  public static File convertToRelativePath(File absolute) throws Exception {\n    File        result;\n    String      fileStr;\n    \n    result = null;\n    \n    // if we're running windows, it could be Cygwin\n    if (File.separator.equals(\"\\\\\")) {\n      // Cygwin doesn't like upper case drives -\u003e try lower case drive\n      try {\n        fileStr = absolute.getPath();\n        fileStr =   fileStr.substring(0, 1).toLowerCase() \n                  + fileStr.substring(1);\n        result = createRelativePath(new File(fileStr));\n      }\n      catch (Exception e) {\n        // no luck with Cygwin workaround, convert it like it is\n        result = createRelativePath(absolute);\n      }\n    }\n    else {\n      result = createRelativePath(absolute);\n    }\n\n    return result;\n  }\n\n  /**\n   * Converts a File's absolute path to a path relative to the user\n   * (ie start) directory.\n   * \n   * @param absolute the File to convert to relative path\n   * @return a File with a path that is relative to the user's directory\n   * @exception Exception if the path cannot be constructed\n   */\n  protected static File createRelativePath(File absolute) throws Exception {\n    File userDir = new File(System.getProperty(\"user.dir\"));\n    String userPath = userDir.getAbsolutePath() + File.separator;\n    String targetPath = (new File(absolute.getParent())).getPath() \n      + File.separator;\n    String fileName = absolute.getName();\n    StringBuffer relativePath = new StringBuffer();\n    //    relativePath.append(\".\"+File.separator);\n    //    System.err.println(\"User dir \"+userPath);\n    //    System.err.println(\"Target path \"+targetPath);\n    \n    // file is in user dir (or subdir)\n    int subdir = targetPath.indexOf(userPath);\n    if (subdir == 0) {\n      if (userPath.length() == targetPath.length()) {\n\trelativePath.append(fileName);\n      } else {\n\tint ll = userPath.length();\n\trelativePath.append(targetPath.substring(ll));\n\trelativePath.append(fileName);\n      }\n    } else {\n      int sepCount = 0;\n      String temp = new String(userPath);\n      while (temp.indexOf(File.separator) != -1) {\n\tint ind = temp.indexOf(File.separator);\n\tsepCount++;\n\ttemp = temp.substring(ind+1, temp.length());\n      }\n      \n      String targetTemp = new String(targetPath);\n      String userTemp = new String(userPath);\n      int tcount = 0;\n      while (targetTemp.indexOf(File.separator) != -1) {\n\tint ind = targetTemp.indexOf(File.separator);\n\tint ind2 = userTemp.indexOf(File.separator);\n\tString tpart = targetTemp.substring(0,ind+1);\n\tString upart = userTemp.substring(0,ind2+1);\n\tif (tpart.compareTo(upart) != 0) {\n\t  if (tcount == 0) {\n\t    tcount = -1;\n\t  }\n\t  break;\n\t}\n\ttcount++;\n\ttargetTemp = targetTemp.substring(ind+1, targetTemp.length());\n\tuserTemp = userTemp.substring(ind2+1, userTemp.length());\n      }\n      if (tcount == -1) {\n\t// then target file is probably on another drive (under windows)\n\tthrow new Exception(\"Can't construct a path to file relative to user \"\n\t\t\t    +\"dir.\");\n      }\n      if (targetTemp.indexOf(File.separator) == -1) {\n\ttargetTemp = \"\";\n      }\n      for (int i = 0; i \u003c sepCount - tcount; i++) {\n\trelativePath.append(\"..\"+File.separator);\n      }\n      relativePath.append(targetTemp + fileName);\n    }\n    //    System.err.println(\"new path : \"+relativePath.toString());\n    return new File(relativePath.toString());\n  }\n  \n  /**\n   * Implements computation of the kth-smallest element according\n   * to Manber's \"Introduction to Algorithms\".\n   *\n   * @param array the array of integers\n   * @param index the index into the array of integers\n   * @param left the first index of the subset \n   * @param right the last index of the subset \n   * @param k the value of k\n   *\n   * @return the index of the kth-smallest element\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n  private static int select(/*@non_null@*/ int[] array, /*@non_null@*/ int[] index, \n                            int left, int right, int k) {\n    \n    if (left == right) {\n      return left;\n    } else {\n      int middle = partition(array, index, left, right);\n      if ((middle - left + 1) \u003e= k) {\n        return select(array, index, left, middle, k);\n      } else {\n        return select(array, index, middle + 1, right, k - (middle - left + 1));\n      }\n    }\n  }\n  \n  \n \n  /**\n   * Breaks up the string, if wider than \"columns\" characters.\n   *\n   * @param s\t\tthe string to process\n   * @param columns\tthe width in columns\n   * @return\t\tthe processed string\n   */\n  public static String[] breakUp(String s, int columns) {\n    Vector\u003cString\u003e\tresult;\n    String\t\tline;\n    BreakIterator\tboundary;\n    int\t\t\tboundaryStart;\n    int\t\t\tboundaryEnd;\n    String\t\tword;\n    String\t\tpunctuation;\n    int\t\t\ti;\n    String[]\t\tlines;\n\n    result      = new Vector\u003cString\u003e();\n    punctuation = \" .,;:!?'\\\"\";\n    lines       = s.split(\"\\n\");\n\n    for (i = 0; i \u003c lines.length; i++) {\n      boundary      = BreakIterator.getWordInstance();\n      boundary.setText(lines[i]);\n      boundaryStart = boundary.first();\n      boundaryEnd   = boundary.next();\n      line          = \"\";\n\n      while (boundaryEnd != BreakIterator.DONE) {\n\tword = lines[i].substring(boundaryStart, boundaryEnd);\n\tif (line.length() \u003e= columns) {\n\t  if (word.length() == 1) {\n\t    if (punctuation.indexOf(word.charAt(0)) \u003e -1) {\n\t      line += word;\n\t      word = \"\";\n\t    }\n\t  }\n\t  result.add(line);\n\t  line = \"\";\n\t}\n\tline          += word;\n\tboundaryStart  = boundaryEnd;\n\tboundaryEnd    = boundary.next();\n      }\n      if (line.length() \u003e 0)\n\tresult.add(line);\n    }\n\n    return result.toArray(new String[result.size()]);\n  }\n\n  /**\n   * Creates a new instance of an object given it's class name and\n   * (optional) arguments to pass to it's setOptions method. If the\n   * object implements OptionHandler and the options parameter is\n   * non-null, the object will have it's options set. Example use:\u003cp\u003e\n   *\n   * \u003ccode\u003e \u003cpre\u003e\n   * String classifierName = Utils.getOption('W', options);\n   * Classifier c = (Classifier)Utils.forName(Classifier.class,\n   *                                          classifierName,\n   *                                          options);\n   * setClassifier(c);\n   * \u003c/pre\u003e\u003c/code\u003e\n   *\n   * @param classType the class that the instantiated object should\n   * be assignable to -- an exception is thrown if this is not the case\n   * @param className the fully qualified class name of the object\n   * @param options an array of options suitable for passing to setOptions. May\n   * be null. Any options accepted by the object will be removed from the\n   * array.\n   * @return the newly created object, ready for use.\n   * @exception Exception if the class name is invalid, or if the\n   * class is not assignable to the desired class type, or the options\n   * supplied are not acceptable to the object\n   */\n  public static Object forName(Class\u003c?\u003e classType,\n\t\t\t       String className,\n\t\t\t       String[] options) throws Exception {\n\n    Class\u003c?\u003e c = null;\n    try {\n      c = Class.forName(className);\n    } catch (Exception ex) {\n      throw new Exception(\"Can't find class called: \" + className);\n    }\n    if (!classType.isAssignableFrom(c)) {\n      throw new Exception(classType.getName() + \" is not assignable from \"\n\t\t\t  + className);\n    }\n    Object o = c.newInstance();\n    /*if ((o instanceof OptionHandler)\n\t\u0026\u0026 (options != null)) {\n      ((OptionHandler)o).setOptions(options);\n      Utils.checkForRemainingOptions(options);\n    }*/\n    return o;\n  }\n\n}\n  \n\n",
        "name": "Utils.java",
        "path": "moa/src/main/java/moa/core/Utils.java",
        "url": "/github.com/Waikato/moa/-/blob/moa/src/main/java/moa/core/Utils.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 1599,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 1600,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);"
        },
        {
          "limitHit": false,
          "lineNumber": 1601,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1622,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 1623,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);"
        },
        {
          "limitHit": false,
          "lineNumber": 1624,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;"
        },
        {
          "limitHit": false,
          "lineNumber": 1648,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 1784,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        }
      ],
      "repository": {
        "name": "github.com/Waikato/moa",
        "url": "/github.com/Waikato/moa"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 8,
  "ElapsedMilliseconds": 1400,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
