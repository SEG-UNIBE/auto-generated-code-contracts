{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/dangtunguyen/IoTSan lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "73b6ee84ae0f0bb700f8cbc01bc76de1828142eb"
        },
        "content": "package edu.ksu.cis.bandera.prog;\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Bandera, a Java(TM) analysis and transformation toolkit           *\n * Copyright (C) 1998-2001 SAnToS Laboratories (santos@cis.ksu.edu)  *\n\n * All rights reserved.                                              *\n *                                                                   *\n * This work was done as a project in the SAnToS Laboratory,         *\n * Department of Computing and Information Sciences, Kansas State    *\n * University, USA (http://www.cis.ksu.edu/santos).                  *\n * It is understood that any modification not identified as such is  *\n * not covered by the preceding statement.                           *\n *                                                                   *\n * This work is free software; you can redistribute it and/or        *\n * modify it under the terms of the GNU Library General Public       *\n * License as published by the Free Software Foundation; either      *\n * version 2 of the License, or (at your option) any later version.  *\n *                                                                   *\n * This work is distributed in the hope that it will be useful,      *\n * but WITHOUT ANY WARRANTY; without even the implied warranty of    *\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *\n * Library General Public License for more details.                  *\n *                                                                   *\n * You should have received a copy of the GNU Library General Public *\n * License along with this toolkit; if not, write to the             *\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,      *\n * Boston, MA  02111-1307, USA.                                      *\n *                                                                   *\n * Java is a trademark of Sun Microsystems, Inc.                     *\n *                                                                   *\n * To submit a bug report, send a comment, or get the latest news on *\n * this project and other SAnToS projects, please visit the web-site *\n *                http://www.cis.ksu.edu/santos                      *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\nimport java.util.Hashtable;\nimport java.util.Enumeration;\nimport java.util.Vector;\nimport java.io.*;\n\nimport org.apache.log4j.Category;\n\nimport ca.mcgill.sable.soot.*;\nimport ca.mcgill.sable.soot.jimple.*;\nimport ca.mcgill.sable.util.*;\n\nimport edu.ksu.cis.bandera.jjjc.*;\n\n/**\n * Provides a collection of static methods that enrich\n * the set of queries about the class/interface hierarchy that are \n * supported directly by Soot.\n *\n * Three such queries are supported\n * \u003cul\u003e\n * \u003cli\u003e Whether a class implementsInterface an interface\n * \u003cli\u003e Whether a class extendsClass another class\n * \u003cli\u003e Produce list of classes that lie below a class or interface in the\n *      hierarchy where a class precedes any of its ancestors in the list.\n * \u003c/ul\u003e\n * Note that in Java an interface, \u003ccode\u003ea\u003c/code\u003e, can be declared as a \n * sub-interface of another interface, \u003ccode\u003eb\u003c/code\u003e, \n * e.g., \u003ccode\u003einterface a extends b {...\u003c/code\u003e.  \n * Soot represents such a relationship between interfaces as an \"implementation\"\n * relationship, e.g., if \u003ccode\u003ear\u003c/code\u003e is the \n * \u003ccode\u003eSootClass\u003c/code\u003e reference to the class named \"a\" \n * then \u003ccode\u003ear.implementsInterface(\"b\")\u003c/code\u003e would return true.\n *\n * This code is not re-entrant.  \n * A single instance of this class can be active in any program run\n * as there is write-once static data created and accessed by the \n * methods.\n */\npublic class HierarchyQuery {\n/**\n * Class logger \n */\n\tprivate static Category log = \n\t        Category.getInstance(HierarchyQuery.class.getName());\n\n/**\n * Stores a mapping from classes to list of immediate descendants in both\n * the class and interface hierarchies.  \n */\n\tprivate static Hashtable subType; \n\n/**\n * Determines whether \u003ccode\u003etheClass\u003c/code\u003e implements \u003ccode\u003etheInterface\u003c/code\u003e\n * either directly or through sub-classing/interfacing.\n * \n * @param theClass\tclass in question\n * @param theInterface\tinterface which class implements (or not)\n * @return\t\ttrue if \u003ccode\u003etheClass\u003c/code\u003e \n *\t\t\timplements \u003ccode\u003etheInterface\u003c/code\u003e\n */\n//@ requires theClass != null;\n//@ requires theInterface != null;\npublic static boolean implementsInterface(SootClass theClass, \n\t\t\t\t\t  SootClass theInterface) {\n\tList workList = new ArrayList();\n\n\t// iterates up the type and interface hierarchy\n\tworkList.add(theClass);\n\twhile (!workList.isEmpty()) {\n\t    SootClass current = (SootClass)workList.remove(0);\n\n\t    List interfaces = current.getInterfaces();\n\t    if (interfaces.contains(theInterface)) return true;\n\n\t    workList.addAll(interfaces);\n\t    if (current.hasSuperClass()) workList.add(current.getSuperClass());\n\t}\n\treturn false;\n}\n\n/**\n * Determines whether \u003ccode\u003etheClass\u003c/code\u003e extends \u003ccode\u003etheSuperType\u003c/code\u003e \n * either directly or through sub-classing.\n * \n * @param theClass\tClass in question\n * @param theSuperType\tClass which \u003ccode\u003etheClass\u003c/code\u003e extends (or not)\n * @return\t\ttrue if \u003ccode\u003etheClass\u003c/code\u003e extends \n *\t\t\t\u003ccode\u003etheSuperType\u003c/code\u003e\n */\n//@ requires theClass != null;\n//@ requires theSuperType != null;\npublic static boolean extendsClass(SootClass theClass, \n\t\t\t\t   SootClass theSuperType) {\n\tSootClass current = theClass;\n\twhile (current.hasSuperClass()) {\n\t    if (current.getSuperClass() == theSuperType) return true;\n\t    current = current.getSuperClass();\n\t}\n\treturn false;\n}\n\n/**\n * Collects all classes that lie below the given class/interface in the \n * inheritence/implements hierarchy.  This is a private helper method\n * for \u003ccode\u003eorderedClasses\u003c/code\u003e  That method insures\n * that the List it produces is (partially) ordered according to\n * the inheritence relation.  To reduce the cost of producing that\n * ordering, we collect the sub/implementing classes in a depth-first\n * fashion.  Since we may start with an interface and descend through\n * a sequence of sub-interfaces, we take care to skip adding them to \n * the list, but we do traverse them to find the classes that implement\n * them.\n *\n * @param theClassInterface\tThe class or interface in question\n * @param classList\t\tThe accumulated list of classes that lie\n *                              below \u003ccode\u003etheClassInterface\u003c/code\u003e\n */\n//@ requires theClassInterface != null;\n//@ requires classList != null;\nprivate static void lowerClasses(SootClass theClassInterface, List classList) {\n\tList children = (List)subType.get(theClassInterface);\n\n\tfor (Iterator childIt = children.iterator(); childIt.hasNext(); ) {\n\t    SootClass current = (SootClass)childIt.next();\n \t    lowerClasses(current, classList);\n\t    if (!Modifier.isInterface(current.getModifiers()) \u0026\u0026\n\t\t!classList.contains(current)) {\n\t        classList.add(current);\n\t    } \n\t}\n}\n\n/**\n * Returns an ordered list of classes that lie beneath the given class/interface\n * in the inheritence/implements hierarchy.  The classes should be ordered\n * so that no ancestor of a given class precedes it in the list.\n * We exploit the fact that the depth-first traversal \n * in \u003ccode\u003elowerClasses\u003c/code\u003e\n * will produce a quasi-ordered list.  We do a bubble sort of\n * the list (which is efficient for nearly sorted data) to \n * properly order the classes, then pack them into a list to be returned.\n *\n * @param theClassInterface\tThe class or interface in question\n * @return  \t\t\tThe list of classes that lie below \n *\t\t\t\t\u003ccode\u003etheClassInterface\u003c/code\u003e partially \n *\t\t\t\tordered by the \u003ccode\u003eextends()\u003c/code\u003e relation\n */\n//@ requires theClassInterface != null;\npublic static List orderedClasses(SootClass theClassInterface) {\n\tbuildSubMap(theClassInterface);\n\n\tList classList = new ArrayList();\n\tlowerClasses(theClassInterface, classList);\n\n\tObject oa[] = classList.toArray();\n\t\n\t// bubble-sort the quasi-ordered list by the extends partial order\n\tfor (int i = 0; i \u003c oa.length-1; i++) { \n\t    for (int j = oa.length-1; j \u003e i; j--) {\n\t\tif ( extendsClass((SootClass)oa[j], (SootClass)oa[j-1]) ) {\n\t\t    Object tmp = oa[j]; \n\t\t    oa[j] = oa[j-1]; \n\t\t    oa[j-1] = tmp; \n\t        } \n\t    } \n\t} \n\n\t// create a new list to load the values in the order\n\tclassList = new ArrayList();\n\tfor (int i = 0; i \u003c oa.length; i++) { \n\t    classList.add(i,oa[i]);\n\t}\n\treturn classList;\n}\n\n/**\n * Builds an explicit representation of descendents in the class/interface\n * hierarchy.\n * For each class, a SootClass explicitly represents direct ancestors\n * in the class/interface hierarchy, it does not represent descendents.\n * This private helper method calculates the direct descendents of a\n * given class and stores them in subType (which maps classes to lists of\n * classes)\n *\n * @param theClass\tA class used to access the list of all classes\n *\t\t\tin the compiled unit.\n */\n//@ requires theClass != null;\nprivate static void buildSubMap(SootClass theClass) {\n\nlog.debug(\"buildSubMap: \" + theClass);\n\n\tsubType = new Hashtable();\n\tList allClasses = theClass.getManager().getClasses();\n\tfor (Iterator classIt = allClasses.iterator(); classIt.hasNext(); ) {\n\t    SootClass current = (SootClass)classIt.next();\n\n\t    // Look for a parent in the class hierarchy\n            if (current.hasSuperClass()) {\n\t\tSootClass parent = current.getSuperClass();\n\t\tif (subType.get(parent) == null) {\n\t\t    subType.put(parent, new ArrayList());\n\t\t}\n\t\t((List)subType.get(parent)).add(current);\n\t    }\n\n\t    // Look for parents in the interface hierarchy\n            if (current.getInterfaceCount() \u003e 0) {\n\t\tList interfaces = current.getInterfaces();\n\t\tfor (Iterator interfaceIt = interfaces.iterator(); \n\t\t     interfaceIt.hasNext(); ) {\n\t\t    SootClass anInterface = (SootClass)interfaceIt.next();\n\t\t    if (subType.get(anInterface) == null) {\n\t\t        subType.put(anInterface, new ArrayList());\n\t\t    }\n\t\t    ((List)subType.get(anInterface)).add(current);\n\t\t}\n\t    }\n\n\t    // If not already created, we create a list of descendents\n\t    if (subType.get(current) == null) { \n\t\tsubType.put(current, new ArrayList());\n\t    }\n\n\t}\n}\n\n/**\n * Unit test driver. \n * takes as input\n * \u003cul\u003e\n * \u003cli\u003e a name for a Java source file\n * \u003cli\u003e the names of either two classes or a class and an interface\n * \u003c/ul\u003e\n * compiles the source file, prints out whether their is an extends or\n * implementation relationship between the other inputs and finaly \n * prints the ordered list of descendents of the two classes/interfaces.\n */\npublic static void main(String args[]) {\n\tSootClassManager classManager = new SootClassManager();\n\tCompilationManager.reset();\n\tCompilationManager.setFilename(args[0]);\n\tCompilationManager.setClasspath(\".\");\n\tCompilationManager.setIncludedPackagesOrTypes(new String[0]);\n\n\ttry { \n\t    CompilationManager.compile(); \n\t} catch (Exception e) { \n            e.printStackTrace();\n\t}\n\n        Hashtable exceptions = CompilationManager.getExceptions();\n        if (exceptions.size() \u003e 0) {\n            System.out.println(\"Compilation failed:\");\n            for (Enumeration e = exceptions.keys(); e.hasMoreElements();) {\n                Object filename = e.nextElement();\n                System.out.println(\"- \" + filename);\n                Vector es = (Vector) exceptions.get(filename);\n                for (java.util.Iterator i = es.iterator(); i.hasNext();) {\n                    System.out.println(\"  * \" + i.next());\n                }\n            }\n\t    return;\n        }\n\n\tHashtable storedClasses = CompilationManager.getCompiledClasses();\n\tfor (Enumeration scIter = storedClasses.elements(); \n\t     scIter.hasMoreElements(); ) {\n\t    ((SootClass) scIter.nextElement()).resolveIfNecessary();\n\t}\n\n\tSootClass a = null;\n\tSootClass b = null;\n\n\tfor (Enumeration scIter = storedClasses.elements(); \n\t     scIter.hasMoreElements(); ) {\n\t    SootClass tmp = (SootClass) scIter.nextElement();\n\t    if (tmp.getName().equals(args[1])) {\n\t      a = tmp;\n\t    }\n\t    if (args.length \u003e 2 \u0026\u0026 tmp.getName().equals(args[2])) {\n\t      b = tmp; \n\t    }\n\t}\n\n        if (args.length \u003e 2) {\n\t    if (extendsClass(a,b)) {\n\t        System.out.println(a.getName() + \" extends \" + b.getName());\n\t    } else {\n\t        System.out.println(a.getName() + \" does not extend \" + b.getName());\n\t    }\n\n\t    if (implementsInterface(a,b)) {\n\t        System.out.println(a.getName() + \" implements \" + b.getName());\n\t    } else {\n\t        System.out.println(a.getName() + \" does not implement \" + b.getName());\n\t    }\n\t}\n\n\tList curDescendants = orderedClasses(a);\n\tSystem.out.print(\"Descendants of \" + a.getName() + \" are: \");\n\tfor (Iterator classIt = curDescendants.iterator(); \n\t     classIt.hasNext(); ) {\n\t    System.out.print(((SootClass)classIt.next()).getName());\n\t    if (classIt.hasNext()) System.out.print(\", \");\n\t}\n\tSystem.out.println(\"\");\n\n\tif (args.length \u003e 2) {\n\t    curDescendants = orderedClasses(b);\n\t    System.out.print(\"Descendants of \" + b.getName() + \" are: \");\n\t    for (Iterator classIt = curDescendants.iterator(); \n\t         classIt.hasNext(); ) {\n\t        System.out.print(((SootClass)classIt.next()).getName());\n\t        if (classIt.hasNext()) System.out.print(\", \");\n\t    }\n\t    System.out.println(\"\");\n\t}\n}\n}\n",
        "name": "HierarchyQuery.java",
        "path": "src/edu/ksu/cis/bandera/prog/HierarchyQuery.java",
        "url": "/github.com/dangtunguyen/IoTSan/-/blob/src/edu/ksu/cis/bandera/prog/HierarchyQuery.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 95,
          "offsetAndLengths": [
            [
              0,
              13
            ]
          ],
          "preview": "//@ requires theClass != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 96,
          "offsetAndLengths": [
            [
              0,
              13
            ]
          ],
          "preview": "//@ requires theInterface != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 124,
          "offsetAndLengths": [
            [
              0,
              13
            ]
          ],
          "preview": "//@ requires theClass != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 125,
          "offsetAndLengths": [
            [
              0,
              13
            ]
          ],
          "preview": "//@ requires theSuperType != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 152,
          "offsetAndLengths": [
            [
              0,
              13
            ]
          ],
          "preview": "//@ requires theClassInterface != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 153,
          "offsetAndLengths": [
            [
              0,
              13
            ]
          ],
          "preview": "//@ requires classList != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 182,
          "offsetAndLengths": [
            [
              0,
              13
            ]
          ],
          "preview": "//@ requires theClassInterface != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 222,
          "offsetAndLengths": [
            [
              0,
              13
            ]
          ],
          "preview": "//@ requires theClass != null;"
        }
      ],
      "repository": {
        "name": "github.com/dangtunguyen/IoTSan",
        "url": "/github.com/dangtunguyen/IoTSan"
      }
    },
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "73b6ee84ae0f0bb700f8cbc01bc76de1828142eb"
        },
        "content": "package edu.ksu.cis.bandera.prog;\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Bandera, a Java(TM) analysis and transformation toolkit           *\n * Copyright (C) 1998-2001 SAnToS Laboratories (santos@cis.ksu.edu)  *\n\n * All rights reserved.                                              *\n *                                                                   *\n * This work was done as a project in the SAnToS Laboratory,         *\n * Department of Computing and Information Sciences, Kansas State    *\n * University, USA (http://www.cis.ksu.edu/santos).                  *\n * It is understood that any modification not identified as such is  *\n * not covered by the preceding statement.                           *\n *                                                                   *\n * This work is free software; you can redistribute it and/or        *\n * modify it under the terms of the GNU Library General Public       *\n * License as published by the Free Software Foundation; either      *\n * version 2 of the License, or (at your option) any later version.  *\n *                                                                   *\n * This work is distributed in the hope that it will be useful,      *\n * but WITHOUT ANY WARRANTY; without even the implied warranty of    *\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *\n * Library General Public License for more details.                  *\n *                                                                   *\n * You should have received a copy of the GNU Library General Public *\n * License along with this toolkit; if not, write to the             *\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,      *\n * Boston, MA  02111-1307, USA.                                      *\n *                                                                   *\n * Java is a trademark of Sun Microsystems, Inc.                     *\n *                                                                   *\n * To submit a bug report, send a comment, or get the latest news on *\n * this project and other SAnToS projects, please visit the web-site *\n *                http://www.cis.ksu.edu/santos                      *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\nimport java.util.Vector;\nimport java.util.Hashtable;\nimport java.util.HashSet;\nimport java.util.Enumeration;\nimport java.io.*;\n\nimport org.apache.log4j.Category;\n\nimport ca.mcgill.sable.soot.*;\nimport ca.mcgill.sable.soot.jimple.*;\nimport ca.mcgill.sable.util.*;\n\nimport edu.ksu.cis.bandera.jjjc.*;\nimport edu.ksu.cis.bandera.spin.*;\n\n/**\n * Provides a static method, \u003ccode\u003eidentify\u003c/code\u003e, that returns a hashSet \n * of SootClass objects that are potentially executable as threads.\n *\n * A SootClass is returned in the set if:\n * \u003cul\u003e\n * \u003cli\u003e it is a sub-type of \u003ccode\u003ejava.lang.Thread\u003c/code\u003e\n * \u003cli\u003e it implements \u003ccode\u003ejava.lang.Runnable\u003c/code\u003e\n * \u003c/ul\u003e\n *\n * Subtyping and implementation relationships may be transitive so this\n * code searches the inheritence and interface hierarchies.\n *\n * In addition to determining \"runnability\" of a class.  This code\n * copies the appropriate \u003ccode\u003erun\u003c/code\u003e method from super-types down to\n * \"runnable\" sub-types if they do not define a \u003ccode\u003erun\u003c/code\u003e\n * method locally..\n *\n * This code is not re-entrant, but cannot be executed concurrently.  \n * A single instance of this class can be active in any program run\n * as there is static data created and accessed by the methods.\n */\npublic class IdentifyRunnableClasses {\n/**\n * Logger\n */\n\tprivate static Category log = \n\t        Category.getInstance(IdentifyRunnableClasses.class.getName());\n\n\tprivate static SootMethod theRun;\n\n/**\n * Determines whether \u003ccode\u003etheClass\u003c/code\u003e is \"runnable\" and if so\n * it sets \u003ccode\u003etheRun\u003c/code\u003e to be the \u003ccode\u003erun\u003c/code\u003e that would\n * be executed when the class is \"started\".\n * \n * @param theClass\tclass in question\n * @return\t\ttrue if \u003ccode\u003etheClass\u003c/code\u003e is \"runnable\"\n */\n//@ requires theClass != null;\nprivate static boolean FindRun(SootClass theClass) {\n\t// Check to see if this class implements Runnable\n\tif (theClass.implementsInterface(\"java.lang.Runnable\")) {\n\t  // return run method\n\t  theRun = theClass.getMethod(\"run\", new ArrayList(), VoidType.v());\n\t  log.debug(\"propogating run method from \" + theClass);\n\t  return true; \n\t}\n\n\t// Check to see if this class extends Thread\n\t//   check to see if it implements a run method\n\tif (theClass.hasSuperClass() \u0026\u0026\n\t    theClass.getSuperClass().getName().equals(\"java.lang.Thread\")) {\n\t  // if there is no run method generate an empty one\n\t  if (!theClass.declaresMethod(\"run\", new ArrayList(), VoidType.v())) {\n\t    theRun = new SootMethod(\"run\", new ArrayList(), VoidType.v());\n\t    JimpleBody body = (JimpleBody) Jimple.v().newBody(theRun);\n\t    theClass.addMethod(theRun);\n\t    log.debug(\"adding empty method for \" + theClass);\n\t  } else {\n\t    theRun = theClass.getMethod(\"run\", new ArrayList(), VoidType.v());\n\t    log.debug(\"propogating run method from \" + theClass);\n\t  }\n\t  return true; \n\t}\n\n\t// search up\n\tif (theClass.hasSuperClass() \u0026\u0026 FindRun(theClass.getSuperClass())) {\n\t  // if there is a local \"run\" method then reset theRun\n\t  if (theClass.declaresMethod(\"run\", new ArrayList(), VoidType.v())) {\n\t    theRun = theClass.getMethod(\"run\", new ArrayList(), VoidType.v());\n\t    log.debug(\"propogating run method from \" + theClass);\n\t  } else {\n\t    log.debug(\"propogating run method\");\n          }\n\t  return true; \n\t}\n\n\treturn false;\n}\n\n/**\n * Returns true if the given interface, named as a \u003ccode\u003eString\u003c/code\u003e, \n * is implemented by the given \u003ccode\u003eSootClass\u003c/code\u003e either directly or\n * indirectly.\n *\n * @param theClass\tname of candidate implementor of interface\n * @param name\t        name of interface\n * @return\t\tindication of implements relationship\n */\n//@ requires theClass != null;\n//@ requires name != null;\npublic static boolean implementsInterface(SootClass theClass, String intName) {\n\tboolean verdict = false;\n\tif ( theClass.implementsInterface(intName) ) {\n\t  verdict = true;\n\t} else {\n\t  if ( theClass.getInterfaceCount() == 0 ) {\n\t    verdict = false;\n\t  } else {\n            Iterator iiIter = theClass.getInterfaces().iterator();\n\t    while (iiIter.hasNext()) {\n\t      SootClass theInterface = (SootClass)iiIter.next();\n\t      verdict = implementsInterface(theInterface, intName);\n\t      if (verdict) break;\n\n\t      if (theInterface.hasSuperClass()) {\n\t\tverdict = implementsInterface(theInterface.getSuperClass(), intName);\n\t      }\n\t      if (verdict) break;\n\t    }\n\t  }\n\t}\n\treturn verdict;\n}\n\n\n/**\n * Returns the subset of \u003ccode\u003eSootClass\u003c/code\u003e iterated over by the\n * parameter that correspond to \"runnable\" classes (either by\n * sub-typing \u003ccode\u003ejava.lang.Thread\u003c/code\u003e or implementing \n * \u003ccode\u003ejava.lang.Runnable\u003c/code\u003e.\n * \n * @param scIter\titerator for candidate \u003ccode\u003eSootClass\u003c/code\u003ees\n * @return\t\tset of \"runnable\" classes\n */\n//@ requires scIter != null;\n//@ ensures ret != null;\npublic static java.util.HashSet identify(Enumeration scIter) {\n\tjava.util.HashSet tmpClasses = new java.util.HashSet();\n\n\twhile (scIter.hasMoreElements()) {\n\t  SootClass theClass = (SootClass) scIter.nextElement();\n\n\t  log.debug(\"trying to identify \" + theClass);\n\n\t  /* [Thomas, April 29, 2017]\n\t   * We will accept main function with the following format:\n\t   * public void main() {}\n\t   * */\n\t  \n  \t  // Check to see if this class has a \"main\" method\n\t  ca.mcgill.sable.util.LinkedList args = new ca.mcgill.sable.util.LinkedList();\n//\t  args.add(ca.mcgill.sable.soot.ArrayType.v(RefType.v(\"java.lang.String\"), 1));\n//\t  if (theClass.declaresMethod(\"main\", args, VoidType.v())) {\n\t  if (SpinUtil.containEvtHandlerMethod(theClass)) {\n//\t    int mods = \n//\t        theClass.getMethod(\"main\", args, VoidType.v()).getModifiers();\n\t    tmpClasses.add(theClass);\n//\t    if (Modifier.isPublic(mods) \u0026\u0026 Modifier.isStatic(mods)) {\n//  \t      tmpClasses.add(theClass);\n//\t      continue;\n//\t    }\n\t  }\n\n  \t  // Check to see if this class implements Runnable or a\n          // sub-interface of Runable\n\t  if (implementsInterface(theClass, \"java.lang.Runnable\")) {\n\t    tmpClasses.add(theClass);\n\t    continue;\n\t  }\n\n\t  // Check to see if this class extends Thread\n\t  //   check to see if it implements a run method\n\t  if (theClass.hasSuperClass() \u0026\u0026\n\t      theClass.getSuperClass().getName().equals(\"java.lang.Thread\")) {\n\t    // if there is no run method generate an empty one\n \t    if (!theClass.declaresMethod(\"run\", new ArrayList(), \n\t\t\t\t\t\tVoidType.v())) {\n\t      SootMethod newRun = new SootMethod(\"run\", new ArrayList(), \n\t\t\t\t\t\t\tVoidType.v());\n\t      JimpleBody body = (JimpleBody) Jimple.v().newBody(newRun);\n\t      theClass.addMethod(newRun);\n\t      log.debug(\"adding empty run method for \" + theClass);\n\t    }\n\t    tmpClasses.add(theClass);\n\t    continue;\n\t  }\n\n  \t  // If neither of the above then search up the type hierarchy\n\t  // to see if a supertype extends Thread\n\t  //   recurse up the hierarchy searching\n\t  //   if found then pick up the lowest \"run\" method coming down\n\t  //\n\t  // Also check to see if a supertype implements Runnable\n\t  // directly or indirectly  \n\t  //   recurse up the hierarchy searching\n\t  //   if found then pick up the lowest \"run\" method coming down\n\t  {\n\t    theRun = null;\n\t    if (theClass.hasSuperClass() \u0026\u0026 FindRun(theClass.getSuperClass())) {\n              // ensure that there is no local \"run\" method\n \t      if (!theClass.declaresMethod(\"run\", new ArrayList(), \n\t \t\t\t\t\t  VoidType.v())) {\n\t        SootMethod newRun = new SootMethod(\"run\", new ArrayList(), \n\t\t\t\t\t\t\t  VoidType.v());\n\t        JimpleBody body = (JimpleBody) Jimple.v().newBody(newRun);\n\t        body.getStmtList().addAll(\n\t\t  ((JimpleBody) theRun.getBody(Jimple.v())).getStmtList());\n\t        body.getLocals().addAll(\n\t\t  ((JimpleBody) theRun.getBody(Jimple.v())).getLocals());\n\t        body.getTraps().addAll(\n\t\t  ((JimpleBody) theRun.getBody(Jimple.v())).getTraps());\n\t        newRun.storeBody(Jimple.v(), body);\n\t        theClass.addMethod(newRun);\n\t        log.debug(\"adding inherited run method for \" + theClass);\n\t      }\n\t      tmpClasses.add(theClass);\n\t      continue;\n\t    }\n\t  }\n\t}\n\treturn tmpClasses;\n}\n\npublic static void main(String args[]) {\n\tSootClassManager classManager = new SootClassManager();\n\tCompilationManager.reset();\n\tCompilationManager.setFilename(args[0]);\n\tCompilationManager.setClasspath(\".\");\n\tCompilationManager.setIncludedPackagesOrTypes(new String[0]);\n\n\t//Compile \n\ttry { CompilationManager.compile(); } \n\t\tcatch (Exception e) { \n\t  System.out.println(e);\n\t  System.out.println(\"Compilation failed\");\n\t}\n\n        Hashtable exceptions = CompilationManager.getExceptions();\n        if (exceptions.size() \u003e 0) {\n            System.out.println(\"Compilation failed:\");\n            for (Enumeration e = exceptions.keys(); e.hasMoreElements();) {\n                Object filename = e.nextElement();\n                System.out.println(\"- \" + filename);\n                Vector es = (Vector) exceptions.get(filename);\n                for (java.util.Iterator i = es.iterator(); i.hasNext();) {\n                    System.out.println(\"  * \" + i.next());\n                }\n            }\n\t    return;\n        }\n\n\tHashtable storedClasses = CompilationManager.getCompiledClasses();\n\n\tEnumeration scIter = storedClasses.elements();\n\twhile (scIter.hasMoreElements()) {\n\t  ((SootClass) scIter.nextElement()).resolveIfNecessary();\n\t}\n\n\tjava.util.HashSet rClasses = IdentifyRunnableClasses.identify(storedClasses.elements());\n\n\tfor (java.util.Iterator cIt = rClasses.iterator(); cIt.hasNext(); ) {\n\t  ((SootClass)cIt.next()).printTo(new StoredBody(Jimple.v()), new PrintWriter(System.out, true));\n\t}\n}\n}\n",
        "name": "IdentifyRunnableClasses.java",
        "path": "src/edu/ksu/cis/bandera/prog/IdentifyRunnableClasses.java",
        "url": "/github.com/dangtunguyen/IoTSan/-/blob/src/edu/ksu/cis/bandera/prog/IdentifyRunnableClasses.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 89,
          "offsetAndLengths": [
            [
              0,
              13
            ]
          ],
          "preview": "//@ requires theClass != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 140,
          "offsetAndLengths": [
            [
              0,
              13
            ]
          ],
          "preview": "//@ requires theClass != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 141,
          "offsetAndLengths": [
            [
              0,
              13
            ]
          ],
          "preview": "//@ requires name != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 176,
          "offsetAndLengths": [
            [
              0,
              13
            ]
          ],
          "preview": "//@ requires scIter != null;"
        },
        {
          "limitHit": false,
          "lineNumber": 177,
          "offsetAndLengths": [
            [
              0,
              12
            ]
          ],
          "preview": "//@ ensures ret != null;"
        }
      ],
      "repository": {
        "name": "github.com/dangtunguyen/IoTSan",
        "url": "/github.com/dangtunguyen/IoTSan"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 13,
  "ElapsedMilliseconds": 1394,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
