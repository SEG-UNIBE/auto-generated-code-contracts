{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/wahibhaq/android-speaker-audioanalysis lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "a188f5b8fa7f4b6627d06b6fb86063e926b770ae"
        },
        "content": "/*\n *    This program is free software; you can redistribute it and/or modify\n *    it under the terms of the GNU General Public License as published by\n *    the Free Software Foundation; either version 2 of the License, or\n *    (at your option) any later version.\n *\n *    This program is distributed in the hope that it will be useful,\n *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *    GNU General Public License for more details.\n *\n *    You should have received a copy of the GNU General Public License\n *    along with this program; if not, write to the Free Software\n *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n/*\n *    FastRfUtils.java\n *    Copyright (C) 1999-2004 University of Waikato, Hamilton, NZ (original\n *      code, Utils.java )\n *    Copyright (C) 2008 Fran Supek (adapted code)\n */\n\npackage com.tum.classifiertest;\n\nimport weka.core.Instance;\nimport weka.core.Instances;\n\nimport java.util.Random;\n\n/**\n * Utility functions for sorting float (single-precision) arrays, and for\n * normalizing double arrays. Adapted from weka.core.Utils, version 1.57.\n *\n * @author Eibe Frank - original code\n * @author Yong Wang - original code\n * @author Len Trigg - original code\n * @author Julien Prados - original code\n * @author Fran Supek (fran.supek[AT]irb.hr) - adapted code\n */\npublic class FastRfUtils {\n\n\n  /**\n   * Sorts a given array of floats in ascending order and returns an\n   * array of integers with the positions of the elements of the\n   * original array in the sorted array. NOTE THESE CHANGES: the sort\n   * is no longer stable and it doesn't use safe floating-point\n   * comparisons anymore. Occurrences of Double.NaN behave unpredictably in\n   * sorting.\n   *\n   * @param array this array is not changed by the method!\n   *\n   * @return an array of integers with the positions in the sorted\n   *         array.\n   */\n  public static /*@pure@*/ int[] sort(/*@non_null@*/ float[] array) {\n    int[] index = new int[array.length];\n    for (int i = 0; i \u003c index.length; i++)\n      index[i] = i;\n    array = array.clone();\n    quickSort(array, index, 0, array.length - 1);\n    return index;\n  }\n\n\n  /**\n   * Partitions the instances around a pivot. Used by quicksort and\n   * kthSmallestValue.\n   *\n   * @param array the array of doubles to be sorted\n   * @param index the index into the array of doubles\n   * @param l     the first index of the subset\n   * @param r     the last index of the subset\n   *\n   * @return the index of the middle element\n   */\n  private static int partition(float[] array, int[] index, int l, int r) {\n\n    double pivot = array[index[(l + r) / 2]];\n    int help;\n\n    while (l \u003c r) {\n      while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\n        l++;\n      }\n      while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\n        r--;\n      }\n      if (l \u003c r) {\n        help = index[l];\n        index[l] = index[r];\n        index[r] = help;\n        l++;\n        r--;\n      }\n    }\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\n      r--;\n    }\n\n    return r;\n  }\n\n\n  /**\n   * Implements quicksort according to Manber's \"Introduction to\n   * Algorithms\".\n   *\n   * @param array the array of doubles to be sorted\n   * @param index the index into the array of doubles\n   * @param left  the first index of the subset to be sorted\n   * @param right the last index of the subset to be sorted\n   */\n  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\n  //@ requires array != index;\n  //  assignable index;\n  private static void quickSort(/*@non_null@*/ float[] array, /*@non_null@*/ int[] index,\n                                int left, int right) {\n\n    if (left \u003c right) {\n      int middle = partition(array, index, left, right);\n      quickSort(array, index, left, middle);\n      quickSort(array, index, middle + 1, right);\n    }\n  }\n\n\n  /**\n   * Normalizes the doubles in the array by their sum.\n   * \u003cp/\u003e\n   * If supplied an array full of zeroes, does not modify the array.\n   *\n   * @param doubles the array of double\n   *\n   * @throws IllegalArgumentException if sum is NaN\n   */\n  public static void normalize(double[] doubles) {\n\n    double sum = 0;\n    for (int i = 0; i \u003c doubles.length; i++) {\n      sum += doubles[i];\n    }\n    normalize(doubles, sum);\n  }\n\n\n  /**\n   * Normalizes the doubles in the array using the given value.\n   * \u003cp/\u003e\n   * If supplied an array full of zeroes, does not modify the array.\n   *\n   * @param doubles the array of double\n   * @param sum     the value by which the doubles are to be normalized\n   *\n   * @throws IllegalArgumentException if sum is zero or NaN\n   */\n  private static void normalize(double[] doubles, double sum) {\n\n    if (Double.isNaN(sum)) {\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is NaN.\");\n    }\n    if (sum == 0) {\n      return;\n    }\n    for (int i = 0; i \u003c doubles.length; i++) {\n      doubles[i] /= sum;\n    }\n  }\n\n  /**\n   * Produces a random permutation using Knuth shuffle.\n   *\n   * @param numElems the size of the permutation\n   * @param rng      the random number generator\n   *\n   * @return a random permutation\n   */\n  public static int[] randomPermutation(int numElems, Random rng) {\n\n    int[] permutation = new int[numElems];\n\n    for (int i = 0; i \u003c numElems; i++)\n      permutation[i] = i;\n\n    for (int i = 0; i \u003c numElems - 1; i++) {\n      int next = rng.nextInt(numElems);\n      int tmp = permutation[i];\n      permutation[i] = permutation[next];\n      permutation[next] = tmp;\n    }\n\n    return permutation;\n  }\n\n  /**\n   * Produces a random permutation of the values of an attribute in a dataset using Knuth shuffle.\n   * \u003cp/\u003e\n   * Copies back the current values of the previously scrambled attribute and uses the given permutation\n   * to scramble the values of the new attribute all by copying from the original dataset.\n   *\n   * @param src      the source dataset\n   * @param dst      the scrambled dataset\n   * @param attIndex the attribute index\n   * @param perm     the random permutation\n   *\n   * @return fluent\n   */\n  public static Instances scramble(Instances src, Instances dst, final int attIndex, int[] perm) {\n\n    for (int i = 0; i \u003c src.numInstances(); i++) {\n\n      Instance scrambled = dst.instance(i);\n\n      if (attIndex \u003e 0)\n        scrambled.setValue(attIndex - 1, src.instance(i).value(attIndex - 1));\n      scrambled.setValue(attIndex, src.instance(perm[i]).value(attIndex));\n    }\n\n    return dst;\n  }\n\n  /**\n   * Load a dataset into memory.\n   *\n   * @param location the location of the dataset\n   *\n   * @return the dataset\n   */\n  public static Instances readInstances(String location) throws Exception {\n    Instances data = new weka.core.converters.ConverterUtils.DataSource(location).getDataSet();\n    if (data.classIndex() == -1)\n      data.setClassIndex(data.numAttributes() - 1);\n    return data;\n  }\n}\n",
        "name": "FastRfUtils.java",
        "path": "Android/VoiceRecognizerSP/src/com/tum/classifiertest/FastRfUtils.java",
        "url": "/github.com/wahibhaq/android-speaker-audioanalysis/-/blob/Android/VoiceRecognizerSP/src/com/tum/classifiertest/FastRfUtils.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 114,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 115,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);"
        },
        {
          "limitHit": false,
          "lineNumber": 116,
          "offsetAndLengths": [
            [
              2,
              13
            ]
          ],
          "preview": "  //@ requires array != index;"
        }
      ],
      "repository": {
        "name": "github.com/wahibhaq/android-speaker-audioanalysis",
        "url": "/github.com/wahibhaq/android-speaker-audioanalysis"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 3,
  "ElapsedMilliseconds": 1705,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
