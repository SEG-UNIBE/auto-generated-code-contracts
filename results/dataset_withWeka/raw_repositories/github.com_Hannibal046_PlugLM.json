{
  "SourcegraphEndpoint": "https://sourcegraph.com",
  "Query": "(//@ requires )|(//@ ensures ) repo:github.com/Hannibal046/PlugLM lang:java count:all case:yes type:file patterntype:regexp",
  "Site": {
    "BuildVersion": "238702_2023-08-16_5.1-acf4bcc841e5"
  },
  "Results": [
    {
      "__typename": "FileMatch",
      "file": {
        "commit": {
          "oid": "93f29df28b76f668c31ceb1b99f078e3b76d8ea9"
        },
        "content": "/*\n * Copyright 2013,2014 BioASQ project: FP7/2007-2013, ICT-2011.4.4(d), \n *  Intelligent Information Management, \n *  Targeted Competition Framework grant agreement nÂ° 318652.\n *  www: http://www.bioasq.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n *\n * @author Ioannis Partalas\n */\n\npackage tools;\n\nimport java.util.ArrayList;\n\npublic class MathUtils{\n\n    public static double SMALL = 1e-6;\n  \n    private MathUtils(){};\n\n    public static double average(double values[])\n    {\n        int s = values.length;\n        if(s==0)\n            return Double.MIN_VALUE;\n        double avg = 0.0;\n        for(int i=0;i\u003cs;i++)\n            avg+=values[i];\n\n        return avg/s;\n    }\n\n    public static double max( double[] arr ) {\n        double max = -Double.MAX_VALUE;\n        int length = arr.length;\n\n        for (int i=0; i \u003c length; ++i)\n                if (arr[i] \u003e max)\n                        max = arr[i];\n        return max;\n    }\n\n    public static double min( double[] arr ) {\n        double min = Double.MAX_VALUE;\n        int length = arr.length;\n\n        for (int i=0; i \u003c length; ++i)\n                if (arr[i] \u003c min)\n                        min = arr[i];\n\n        return min;\n    }\n\n    public static int min( int[] arr ) {\n        int min = Integer.MAX_VALUE;\n        int length = arr.length;\n\n        for (int i=0; i \u003c length; ++i)\n                if (arr[i] \u003c min)\n                        min = arr[i];\n        return min;\n    }\n\n    public static int min( ArrayList\u003cInteger\u003e arr ) {\n        int min = Integer.MAX_VALUE;\n        int length = arr.size();\n\n        for (int i=0; i \u003c length; ++i)\n                if (arr.get(i).intValue() \u003c min)\n                        min = arr.get(i).intValue();\n        return min;\n    }\n\n    /**\n    *  Returns the range of the data in the specified array.\n    *  Range is the difference between the maximum and minimum\n    *  values in the data set.\n    *\n    *  @param  arr  An array of sample data values.\n    *  @return The range of the data in the input array.\n    **/\n    public static double range(double[] arr) {\n        return max(arr) - min(arr);\n    }\n\n    /**\n    *  Returns the root mean square of an array of sample data.\n    *\n    *  @param   arr  An array of sample data values.\n    *  @return  The root mean square of the sample data.\n    **/\n    public static double rms( double[] arr ) {\n        int size = arr.length;\n        double sum = 0;\n        for (int i=0; i \u003c size; ++i)\n                sum += arr[i]*arr[i];\n\n        return Math.sqrt(sum/size);\n    }\n\n    public static double variance(double[] arr) {\n        int n = arr.length;\n        if (n \u003c 2)\n                return 0;\n                //throw new IllegalArgumentException(\"Must be at least 2 elements in array.\");\n\n        //\t1st get the average of the data.\n        double ave = average(arr);\n\n        double var = 0;\n        double ep = 0;\n        for (int i=0; i \u003c n; ++i) {\n                double s = arr[i] - ave;\n                ep += s;\n                var += s*s;\n        }\n\n        var = (var - ep*ep/n)/(n-1);\n\n        return var;\n    }\n\n     public static double variance(double[] arr,double average) {\n        int n = arr.length;\n        if (n \u003c 2)\n                return 0;\n                //throw new IllegalArgumentException(\"Must be at least 2 elements in array.\");\n\n        //\t1st get the average of the data.\n        double ave = average;\n\n        double var = 0;\n        double ep = 0;\n        for (int i=0; i \u003c n; ++i) {\n                double s = arr[i] - ave;\n                ep += s;\n                var += s*s;\n        }\n\n        var = (var - ep*ep/n)/(n-1);\n\n        return var;\n    }\n\n    /**\n    *  Returns the standard deviation of an array of sample data.\n    *\n    *  @param  arr  An array of sample data values.\n    *  @return The standard deviation of the sample data.\n    **/\n    public static double sdev(double[] arr) {\n        return Math.sqrt(variance(arr));\n    }\n\n    public static double dif(double Dx, double Dy)\n    {\n        return Dx/Dy;\n    }\n\n    public static int indexOf(double[] values,double val)\n    {\n        for (int i = 0; i \u003c values.length; i++) {\n            if(values[i]==val)\n                return i;\n        }\n        return -1;\n    }\n\n    public static int indexOf(int[] values,int val)\n    {\n        for (int i = 0; i \u003c values.length; i++) {\n            if(values[i]==val)\n                return i;\n        }\n        return -1;\n    }\n      \n    public static /*@pure@*/ int maxIndex(double[] doubles) {\n\n    double maximum = 0;\n    int maxIndex = 0;\n\n    for (int i = 0; i \u003c doubles.length; i++) {\n        if ((i == 0) || (doubles[i] \u003e maximum)) {\n          maxIndex = i;\n          maximum = doubles[i];\n        }\n    }\n\n    return maxIndex;\n  }\n\n    public static /*@pure@*/ int maxIndex(int[] ints) {\n\n    int maximum = 0;\n    int maxIndex = 0;\n\n    for (int i = 0; i \u003c ints.length; i++) {\n        if ((i == 0) || (ints[i] \u003e maximum)) {\n          maxIndex = i;\n          maximum = ints[i];\n        }\n    }\n\n    return maxIndex;\n  }\n  \n    public static double sum(double[] sim_values) {\n        double sum=0.0;\n        \n        for(int i=0;i\u003csim_values.length;i++)\n            sum+=sim_values[i];\n        \n        return sum;\n    }\n    \n    public static void normalize(double[] doubles, double sum) {\n\n    if (Double.isNaN(sum)) {\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is NaN.\");\n    }\n    if (sum == 0) {\n      // Maybe this should just be a return.\n      throw new IllegalArgumentException(\"Can't normalize array. Sum is zero.\");\n    }\n    for (int i = 0; i \u003c doubles.length; i++) {\n      doubles[i] /= sum;\n    }\n  }\n        \n    public static /*@pure@*/ int[] stableSort(double[] array){\n\n    int[] index = new int[array.length];\n    int[] newIndex = new int[array.length];\n    int[] helpIndex;\n    int numEqual;\n    \n    array = (double[])array.clone();\n    for (int i = 0; i \u003c index.length; i++) {\n        index[i] = i;\n        if (Double.isNaN(array[i])) {\n            array[i] = Double.MAX_VALUE;\n        }\n    }\n    quickSort(array,index,0,array.length-1);\n\n    // Make sort stable\n\n    int i = 0;\n    while (i \u003c index.length) {\n        numEqual = 1;\n        for (int j = i+1; ((j \u003c index.length) \u0026\u0026 eq(array[index[i]],array[index[j]])); j++)\n            numEqual++;\n        if (numEqual \u003e 1) {\n            helpIndex = new int[numEqual];\n            for (int j = 0; j \u003c numEqual; j++)\n                helpIndex[j] = i+j;\n            quickSort(index, helpIndex, 0, numEqual-1);\n            for (int j = 0; j \u003c numEqual; j++) \n                newIndex[i+j] = index[helpIndex[j]];\n            i += numEqual;\n        } else {\n            newIndex[i] = index[i];\n            i++;\n        }\n    }\n\n    return newIndex;\n  }\n      \n    public static /*@pure@*/ boolean eq(double a, double b){\n    \n    return (a - b \u003c SMALL) \u0026\u0026 (b - a \u003c SMALL); \n  }\n        \n    /**\n    * Implements quicksort according to Manber's \"Introduction to\n    * Algorithms\".\n    *\n    * @param array the array of integers to be sorted\n    * @param index the index into the array of integers\n    * @param left the first index of the subset to be sorted\n    * @param right the last index of the subset to be sorted\n    */\n    //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n    //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\n    //@ requires array != index;\n    //  assignable index;\n    private static void quickSort(/*@non_null@*/ int[] array, /*@non_null@*/  int[] index, int left, int right) {\n        if (left \u003c right) {\n            int middle = partition(array, index, left, right);\n            quickSort(array, index, left, middle);\n            quickSort(array, index, middle + 1, right);\n        }\n  }\n    /**\n    * Implements quicksort according to Manber's \"Introduction to\n    * Algorithms\".\n    *\n    * @param array the array of doubles to be sorted\n    * @param index the index into the array of doubles\n    * @param left the first index of the subset to be sorted\n    * @param right the last index of the subset to be sorted\n    */\n    //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;\n    //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);\n    //@ requires array != index;\n    //  assignable index;\n    private static void quickSort(/*@non_null@*/ double[] array, /*@non_null@*/ int[] index, int left, int right) {\n        if (left \u003c right) {\n            int middle = partition(array, index, left, right);\n            quickSort(array, index, left, middle);\n            quickSort(array, index, middle + 1, right);\n        }\n    }\n  \n    /**\n   * Partitions the instances around a pivot. Used by quicksort and\n   * kthSmallestValue.\n   *\n   * @param array the array of doubles to be sorted\n   * @param index the index into the array of doubles\n   * @param l the first index of the subset \n   * @param r the last index of the subset \n   *\n   * @return the index of the middle element\n   */\n    private static int partition(double[] array, int[] index, int l, int r) {\n        double pivot = array[index[(l + r) / 2]];\n        int help;\n\n        while (l \u003c r) {\n            while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\n                l++;\n            }\n            while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\n                 r--;\n            }\n            if (l \u003c r) {\n                help = index[l];\n                index[l] = index[r];\n                index[r] = help;\n                l++;\n                r--;\n            }\n        }\n        if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\n            r--;\n        } \n\n        return r;\n  }\n  \n    private static int partition(int[] array, int[] index, int l, int r) {\n    double pivot = array[index[(l + r) / 2]];\n    int help;\n\n    while (l \u003c r) {\n        while ((array[index[l]] \u003c pivot) \u0026\u0026 (l \u003c r)) {\n            l++;\n        }\n        while ((array[index[r]] \u003e pivot) \u0026\u0026 (l \u003c r)) {\n            r--;\n        }\n        if (l \u003c r) {\n            help = index[l];\n            index[l] = index[r];\n            index[r] = help;\n            l++;\n            r--;\n        }\n    }\n    if ((l == r) \u0026\u0026 (array[index[r]] \u003e pivot)) {\n        r--;\n    } \n\n    return r;\n  }\n  \n    public static /*@pure@*/ int round(double value) {\n        int roundedValue = value \u003e 0\n          ? (int)(value + 0.5)\n          : -(int)(Math.abs(value) + 0.5);\n\n        return roundedValue;\n  }\n  \n}\n",
        "name": "MathUtils.java",
        "path": "src/biomed_qa/scripts/bioasq_eval/flat/BioASQEvaluation/src/tools/MathUtils.java",
        "url": "/github.com/Hannibal046/PlugLM/-/blob/src/biomed_qa/scripts/bioasq_eval/flat/BioASQEvaluation/src/tools/MathUtils.java"
      },
      "lineMatches": [
        {
          "limitHit": false,
          "lineNumber": 297,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 298,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);"
        },
        {
          "limitHit": false,
          "lineNumber": 299,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires array != index;"
        },
        {
          "limitHit": false,
          "lineNumber": 317,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires 0 \u003c= first \u0026\u0026 first \u003c= right \u0026\u0026 right \u003c array.length;"
        },
        {
          "limitHit": false,
          "lineNumber": 318,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires (\\forall int i; 0 \u003c= i \u0026\u0026 i \u003c index.length; 0 \u003c= index[i] \u0026\u0026 index[i] \u003c array.length);"
        },
        {
          "limitHit": false,
          "lineNumber": 319,
          "offsetAndLengths": [
            [
              4,
              13
            ]
          ],
          "preview": "    //@ requires array != index;"
        }
      ],
      "repository": {
        "name": "github.com/Hannibal046/PlugLM",
        "url": "/github.com/Hannibal046/PlugLM"
      }
    }
  ],
  "LimitHit": false,
  "Cloning": [],
  "Missing": [],
  "Timedout": [],
  "ResultCount": 6,
  "ElapsedMilliseconds": 701,
  "Alert": {
    "Title": "",
    "Description": "",
    "ProposedQueries": null
  }
}
